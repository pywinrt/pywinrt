// WARNING: Please don't edit this file. It was generated by Python/WinRT v0.0.0

#include "py.Microsoft.UI.Xaml.Input.h"


namespace py::cpp::Microsoft::UI::Xaml::Input
{
    // ----- AccessKeyDisplayDismissedEventArgs class --------------------

    static PyObject* _new_AccessKeyDisplayDismissedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Microsoft::UI::Xaml::Input::AccessKeyDisplayDismissedEventArgs instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_AccessKeyDisplayDismissedEventArgs(py::wrapper::Microsoft::UI::Xaml::Input::AccessKeyDisplayDismissedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_AccessKeyDisplayDismissedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Input::AccessKeyDisplayDismissedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AccessKeyDisplayDismissedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Input::AccessKeyDisplayDismissedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AccessKeyDisplayDismissedEventArgs[] = {
        { "_assign_array_", _assign_array_AccessKeyDisplayDismissedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AccessKeyDisplayDismissedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AccessKeyDisplayDismissedEventArgs[] = {
        { }
    };

    static PyType_Slot _type_slots_AccessKeyDisplayDismissedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_AccessKeyDisplayDismissedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AccessKeyDisplayDismissedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AccessKeyDisplayDismissedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AccessKeyDisplayDismissedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_AccessKeyDisplayDismissedEventArgs =
    {
        "winrt._winrt_microsoft_ui_xaml_input.AccessKeyDisplayDismissedEventArgs",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Input::AccessKeyDisplayDismissedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AccessKeyDisplayDismissedEventArgs
    };

    // ----- AccessKeyDisplayRequestedEventArgs class --------------------

    static PyObject* _new_AccessKeyDisplayRequestedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Microsoft::UI::Xaml::Input::AccessKeyDisplayRequestedEventArgs instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_AccessKeyDisplayRequestedEventArgs(py::wrapper::Microsoft::UI::Xaml::Input::AccessKeyDisplayRequestedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AccessKeyDisplayRequestedEventArgs_get_PressedKeys(py::wrapper::Microsoft::UI::Xaml::Input::AccessKeyDisplayRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Input.AccessKeyDisplayRequestedEventArgs", L"PressedKeys"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PressedKeys());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AccessKeyDisplayRequestedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Input::AccessKeyDisplayRequestedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AccessKeyDisplayRequestedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Input::AccessKeyDisplayRequestedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AccessKeyDisplayRequestedEventArgs[] = {
        { "_assign_array_", _assign_array_AccessKeyDisplayRequestedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AccessKeyDisplayRequestedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AccessKeyDisplayRequestedEventArgs[] = {
        { "pressed_keys", reinterpret_cast<getter>(AccessKeyDisplayRequestedEventArgs_get_PressedKeys), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AccessKeyDisplayRequestedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_AccessKeyDisplayRequestedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AccessKeyDisplayRequestedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AccessKeyDisplayRequestedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AccessKeyDisplayRequestedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_AccessKeyDisplayRequestedEventArgs =
    {
        "winrt._winrt_microsoft_ui_xaml_input.AccessKeyDisplayRequestedEventArgs",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Input::AccessKeyDisplayRequestedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AccessKeyDisplayRequestedEventArgs
    };

    // ----- AccessKeyInvokedEventArgs class --------------------

    static PyObject* _new_AccessKeyInvokedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Microsoft::UI::Xaml::Input::AccessKeyInvokedEventArgs instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_AccessKeyInvokedEventArgs(py::wrapper::Microsoft::UI::Xaml::Input::AccessKeyInvokedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AccessKeyInvokedEventArgs_get_Handled(py::wrapper::Microsoft::UI::Xaml::Input::AccessKeyInvokedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Input.AccessKeyInvokedEventArgs", L"Handled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Handled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AccessKeyInvokedEventArgs_put_Handled(py::wrapper::Microsoft::UI::Xaml::Input::AccessKeyInvokedEventArgs* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Input.AccessKeyInvokedEventArgs", L"Handled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.Handled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_AccessKeyInvokedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Input::AccessKeyInvokedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AccessKeyInvokedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Input::AccessKeyInvokedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AccessKeyInvokedEventArgs[] = {
        { "_assign_array_", _assign_array_AccessKeyInvokedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AccessKeyInvokedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AccessKeyInvokedEventArgs[] = {
        { "handled", reinterpret_cast<getter>(AccessKeyInvokedEventArgs_get_Handled), reinterpret_cast<setter>(AccessKeyInvokedEventArgs_put_Handled), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AccessKeyInvokedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_AccessKeyInvokedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AccessKeyInvokedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AccessKeyInvokedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AccessKeyInvokedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_AccessKeyInvokedEventArgs =
    {
        "winrt._winrt_microsoft_ui_xaml_input.AccessKeyInvokedEventArgs",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Input::AccessKeyInvokedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AccessKeyInvokedEventArgs
    };

    // ----- AccessKeyManager class --------------------

    static PyObject* _new_AccessKeyManager(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Xaml::Input::AccessKeyManager>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Xaml::Input::AccessKeyManager>::type_name);
        return nullptr;
    }

    static void _dealloc_AccessKeyManager(py::wrapper::Microsoft::UI::Xaml::Input::AccessKeyManager* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AccessKeyManager_EnterDisplayMode(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Input.AccessKeyManager", L"EnterDisplayMode", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::XamlRoot>(args, 0);

                winrt::Microsoft::UI::Xaml::Input::AccessKeyManager::EnterDisplayMode(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AccessKeyManager_ExitDisplayMode(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Input.AccessKeyManager", L"ExitDisplayMode", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                winrt::Microsoft::UI::Xaml::Input::AccessKeyManager::ExitDisplayMode();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AccessKeyManager_get_AreKeyTipsEnabled(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Input.AccessKeyManager", L"AreKeyTipsEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Input::AccessKeyManager::AreKeyTipsEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AccessKeyManager_put_AreKeyTipsEnabled(PyObject* /*unused*/, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Input.AccessKeyManager", L"AreKeyTipsEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            winrt::Microsoft::UI::Xaml::Input::AccessKeyManager::AreKeyTipsEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AccessKeyManager_get_IsDisplayModeEnabled(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Input.AccessKeyManager", L"IsDisplayModeEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Input::AccessKeyManager::IsDisplayModeEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AccessKeyManager_add_IsDisplayModeEnabledChanged(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Input.AccessKeyManager", L"IsDisplayModeEnabledChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Foundation::IInspectable, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(winrt::Microsoft::UI::Xaml::Input::AccessKeyManager::IsDisplayModeEnabledChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AccessKeyManager_remove_IsDisplayModeEnabledChanged(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Input.AccessKeyManager", L"IsDisplayModeEnabledChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            winrt::Microsoft::UI::Xaml::Input::AccessKeyManager::IsDisplayModeEnabledChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AccessKeyManager(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Input::AccessKeyManager>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AccessKeyManager(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Input::AccessKeyManager>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AccessKeyManager[] = {
        { "add_is_display_mode_enabled_changed", reinterpret_cast<PyCFunction>(AccessKeyManager_add_IsDisplayModeEnabledChanged), METH_O | METH_STATIC, nullptr },
        { "remove_is_display_mode_enabled_changed", reinterpret_cast<PyCFunction>(AccessKeyManager_remove_IsDisplayModeEnabledChanged), METH_O | METH_STATIC, nullptr },
        { "_assign_array_", _assign_array_AccessKeyManager, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AccessKeyManager), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AccessKeyManager[] = {
        { }
    };

    static PyType_Slot _type_slots_AccessKeyManager[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_AccessKeyManager) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AccessKeyManager) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AccessKeyManager) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AccessKeyManager) },
        { },
    };

    static PyType_Spec type_spec_AccessKeyManager =
    {
        "winrt._winrt_microsoft_ui_xaml_input.AccessKeyManager",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Input::AccessKeyManager),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AccessKeyManager
    };

    static PyGetSetDef getset_AccessKeyManager_Static[] = {
        { "are_key_tips_enabled", reinterpret_cast<getter>(AccessKeyManager_get_AreKeyTipsEnabled), reinterpret_cast<setter>(AccessKeyManager_put_AreKeyTipsEnabled), nullptr, nullptr },
        { "is_display_mode_enabled", reinterpret_cast<getter>(AccessKeyManager_get_IsDisplayModeEnabled), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_AccessKeyManager_Static[] = {
        { "enter_display_mode", reinterpret_cast<PyCFunction>(AccessKeyManager_EnterDisplayMode), METH_VARARGS, nullptr },
        { "exit_display_mode", reinterpret_cast<PyCFunction>(AccessKeyManager_ExitDisplayMode), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_AccessKeyManager_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_AccessKeyManager_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_AccessKeyManager_Static) },
        { }
    };

    static PyType_Spec type_spec_AccessKeyManager_Static =
    {
        "winrt._winrt_microsoft_ui_xaml_input.AccessKeyManager_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_AccessKeyManager_Static
    };

    // ----- CanExecuteRequestedEventArgs class --------------------

    static PyObject* _new_CanExecuteRequestedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Xaml::Input::CanExecuteRequestedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Xaml::Input::CanExecuteRequestedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_CanExecuteRequestedEventArgs(py::wrapper::Microsoft::UI::Xaml::Input::CanExecuteRequestedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CanExecuteRequestedEventArgs_get_CanExecute(py::wrapper::Microsoft::UI::Xaml::Input::CanExecuteRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Input.CanExecuteRequestedEventArgs", L"CanExecute"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CanExecute());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CanExecuteRequestedEventArgs_put_CanExecute(py::wrapper::Microsoft::UI::Xaml::Input::CanExecuteRequestedEventArgs* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Input.CanExecuteRequestedEventArgs", L"CanExecute"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.CanExecute(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CanExecuteRequestedEventArgs_get_Parameter(py::wrapper::Microsoft::UI::Xaml::Input::CanExecuteRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Input.CanExecuteRequestedEventArgs", L"Parameter"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Parameter());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_CanExecuteRequestedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Input::CanExecuteRequestedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CanExecuteRequestedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Input::CanExecuteRequestedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CanExecuteRequestedEventArgs[] = {
        { "_assign_array_", _assign_array_CanExecuteRequestedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CanExecuteRequestedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CanExecuteRequestedEventArgs[] = {
        { "can_execute", reinterpret_cast<getter>(CanExecuteRequestedEventArgs_get_CanExecute), reinterpret_cast<setter>(CanExecuteRequestedEventArgs_put_CanExecute), nullptr, nullptr },
        { "parameter", reinterpret_cast<getter>(CanExecuteRequestedEventArgs_get_Parameter), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CanExecuteRequestedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_CanExecuteRequestedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CanExecuteRequestedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CanExecuteRequestedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CanExecuteRequestedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_CanExecuteRequestedEventArgs =
    {
        "winrt._winrt_microsoft_ui_xaml_input.CanExecuteRequestedEventArgs",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Input::CanExecuteRequestedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CanExecuteRequestedEventArgs
    };

    // ----- CharacterReceivedRoutedEventArgs class --------------------

    static PyObject* _new_CharacterReceivedRoutedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Xaml::Input::CharacterReceivedRoutedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Xaml::Input::CharacterReceivedRoutedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_CharacterReceivedRoutedEventArgs(py::wrapper::Microsoft::UI::Xaml::Input::CharacterReceivedRoutedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CharacterReceivedRoutedEventArgs_get_Handled(py::wrapper::Microsoft::UI::Xaml::Input::CharacterReceivedRoutedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Input.CharacterReceivedRoutedEventArgs", L"Handled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Handled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CharacterReceivedRoutedEventArgs_put_Handled(py::wrapper::Microsoft::UI::Xaml::Input::CharacterReceivedRoutedEventArgs* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Input.CharacterReceivedRoutedEventArgs", L"Handled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.Handled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CharacterReceivedRoutedEventArgs_get_Character(py::wrapper::Microsoft::UI::Xaml::Input::CharacterReceivedRoutedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Input.CharacterReceivedRoutedEventArgs", L"Character"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Character());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CharacterReceivedRoutedEventArgs_get_KeyStatus(py::wrapper::Microsoft::UI::Xaml::Input::CharacterReceivedRoutedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Input.CharacterReceivedRoutedEventArgs", L"KeyStatus"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.KeyStatus());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_CharacterReceivedRoutedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Input::CharacterReceivedRoutedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CharacterReceivedRoutedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Input::CharacterReceivedRoutedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CharacterReceivedRoutedEventArgs[] = {
        { "_assign_array_", _assign_array_CharacterReceivedRoutedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CharacterReceivedRoutedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CharacterReceivedRoutedEventArgs[] = {
        { "handled", reinterpret_cast<getter>(CharacterReceivedRoutedEventArgs_get_Handled), reinterpret_cast<setter>(CharacterReceivedRoutedEventArgs_put_Handled), nullptr, nullptr },
        { "character", reinterpret_cast<getter>(CharacterReceivedRoutedEventArgs_get_Character), nullptr, nullptr, nullptr },
        { "key_status", reinterpret_cast<getter>(CharacterReceivedRoutedEventArgs_get_KeyStatus), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CharacterReceivedRoutedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_CharacterReceivedRoutedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CharacterReceivedRoutedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CharacterReceivedRoutedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CharacterReceivedRoutedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_CharacterReceivedRoutedEventArgs =
    {
        "winrt._winrt_microsoft_ui_xaml_input.CharacterReceivedRoutedEventArgs",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Input::CharacterReceivedRoutedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CharacterReceivedRoutedEventArgs
    };

    // ----- ContextRequestedEventArgs class --------------------

    static PyObject* _new_ContextRequestedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Microsoft::UI::Xaml::Input::ContextRequestedEventArgs instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ContextRequestedEventArgs(py::wrapper::Microsoft::UI::Xaml::Input::ContextRequestedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ContextRequestedEventArgs_TryGetPosition(py::wrapper::Microsoft::UI::Xaml::Input::ContextRequestedEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Input.ContextRequestedEventArgs", L"TryGetPosition", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::UIElement>(args, 0);
                winrt::Windows::Foundation::Point param1 {  };

                auto return_value = self->obj.TryGetPosition(param0, param1);

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out1{ py::convert(param1) };
                if (!out1)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out_return_value.get(), out1.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContextRequestedEventArgs_get_Handled(py::wrapper::Microsoft::UI::Xaml::Input::ContextRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Input.ContextRequestedEventArgs", L"Handled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Handled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContextRequestedEventArgs_put_Handled(py::wrapper::Microsoft::UI::Xaml::Input::ContextRequestedEventArgs* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Input.ContextRequestedEventArgs", L"Handled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.Handled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_ContextRequestedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Input::ContextRequestedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ContextRequestedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Input::ContextRequestedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ContextRequestedEventArgs[] = {
        { "try_get_position", reinterpret_cast<PyCFunction>(ContextRequestedEventArgs_TryGetPosition), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_ContextRequestedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ContextRequestedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ContextRequestedEventArgs[] = {
        { "handled", reinterpret_cast<getter>(ContextRequestedEventArgs_get_Handled), reinterpret_cast<setter>(ContextRequestedEventArgs_put_Handled), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ContextRequestedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ContextRequestedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ContextRequestedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ContextRequestedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ContextRequestedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_ContextRequestedEventArgs =
    {
        "winrt._winrt_microsoft_ui_xaml_input.ContextRequestedEventArgs",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Input::ContextRequestedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ContextRequestedEventArgs
    };

    // ----- DoubleTappedRoutedEventArgs class --------------------

    static PyObject* _new_DoubleTappedRoutedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Microsoft::UI::Xaml::Input::DoubleTappedRoutedEventArgs instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_DoubleTappedRoutedEventArgs(py::wrapper::Microsoft::UI::Xaml::Input::DoubleTappedRoutedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* DoubleTappedRoutedEventArgs_GetPosition(py::wrapper::Microsoft::UI::Xaml::Input::DoubleTappedRoutedEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Input.DoubleTappedRoutedEventArgs", L"GetPosition", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::UIElement>(args, 0);

                return py::convert(self->obj.GetPosition(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DoubleTappedRoutedEventArgs_get_Handled(py::wrapper::Microsoft::UI::Xaml::Input::DoubleTappedRoutedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Input.DoubleTappedRoutedEventArgs", L"Handled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Handled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DoubleTappedRoutedEventArgs_put_Handled(py::wrapper::Microsoft::UI::Xaml::Input::DoubleTappedRoutedEventArgs* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Input.DoubleTappedRoutedEventArgs", L"Handled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.Handled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DoubleTappedRoutedEventArgs_get_PointerDeviceType(py::wrapper::Microsoft::UI::Xaml::Input::DoubleTappedRoutedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Input.DoubleTappedRoutedEventArgs", L"PointerDeviceType"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PointerDeviceType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_DoubleTappedRoutedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Input::DoubleTappedRoutedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_DoubleTappedRoutedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Input::DoubleTappedRoutedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DoubleTappedRoutedEventArgs[] = {
        { "get_position", reinterpret_cast<PyCFunction>(DoubleTappedRoutedEventArgs_GetPosition), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_DoubleTappedRoutedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_DoubleTappedRoutedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_DoubleTappedRoutedEventArgs[] = {
        { "handled", reinterpret_cast<getter>(DoubleTappedRoutedEventArgs_get_Handled), reinterpret_cast<setter>(DoubleTappedRoutedEventArgs_put_Handled), nullptr, nullptr },
        { "pointer_device_type", reinterpret_cast<getter>(DoubleTappedRoutedEventArgs_get_PointerDeviceType), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_DoubleTappedRoutedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_DoubleTappedRoutedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_DoubleTappedRoutedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_DoubleTappedRoutedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_DoubleTappedRoutedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_DoubleTappedRoutedEventArgs =
    {
        "winrt._winrt_microsoft_ui_xaml_input.DoubleTappedRoutedEventArgs",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Input::DoubleTappedRoutedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DoubleTappedRoutedEventArgs
    };

    // ----- ExecuteRequestedEventArgs class --------------------

    static PyObject* _new_ExecuteRequestedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Xaml::Input::ExecuteRequestedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Xaml::Input::ExecuteRequestedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_ExecuteRequestedEventArgs(py::wrapper::Microsoft::UI::Xaml::Input::ExecuteRequestedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ExecuteRequestedEventArgs_get_Parameter(py::wrapper::Microsoft::UI::Xaml::Input::ExecuteRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Input.ExecuteRequestedEventArgs", L"Parameter"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Parameter());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ExecuteRequestedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Input::ExecuteRequestedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ExecuteRequestedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Input::ExecuteRequestedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ExecuteRequestedEventArgs[] = {
        { "_assign_array_", _assign_array_ExecuteRequestedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ExecuteRequestedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ExecuteRequestedEventArgs[] = {
        { "parameter", reinterpret_cast<getter>(ExecuteRequestedEventArgs_get_Parameter), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ExecuteRequestedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ExecuteRequestedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ExecuteRequestedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ExecuteRequestedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ExecuteRequestedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_ExecuteRequestedEventArgs =
    {
        "winrt._winrt_microsoft_ui_xaml_input.ExecuteRequestedEventArgs",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Input::ExecuteRequestedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ExecuteRequestedEventArgs
    };

    // ----- FindNextElementOptions class --------------------

    static PyObject* _new_FindNextElementOptions(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Microsoft::UI::Xaml::Input::FindNextElementOptions instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_FindNextElementOptions(py::wrapper::Microsoft::UI::Xaml::Input::FindNextElementOptions* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* FindNextElementOptions_get_XYFocusNavigationStrategyOverride(py::wrapper::Microsoft::UI::Xaml::Input::FindNextElementOptions* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Input.FindNextElementOptions", L"XYFocusNavigationStrategyOverride"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.XYFocusNavigationStrategyOverride());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int FindNextElementOptions_put_XYFocusNavigationStrategyOverride(py::wrapper::Microsoft::UI::Xaml::Input::FindNextElementOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Input.FindNextElementOptions", L"XYFocusNavigationStrategyOverride"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Input::XYFocusNavigationStrategyOverride>(arg);

            self->obj.XYFocusNavigationStrategyOverride(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* FindNextElementOptions_get_SearchRoot(py::wrapper::Microsoft::UI::Xaml::Input::FindNextElementOptions* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Input.FindNextElementOptions", L"SearchRoot"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SearchRoot());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int FindNextElementOptions_put_SearchRoot(py::wrapper::Microsoft::UI::Xaml::Input::FindNextElementOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Input.FindNextElementOptions", L"SearchRoot"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyObject>(arg);

            self->obj.SearchRoot(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* FindNextElementOptions_get_HintRect(py::wrapper::Microsoft::UI::Xaml::Input::FindNextElementOptions* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Input.FindNextElementOptions", L"HintRect"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.HintRect());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int FindNextElementOptions_put_HintRect(py::wrapper::Microsoft::UI::Xaml::Input::FindNextElementOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Input.FindNextElementOptions", L"HintRect"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Rect>(arg);

            self->obj.HintRect(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* FindNextElementOptions_get_ExclusionRect(py::wrapper::Microsoft::UI::Xaml::Input::FindNextElementOptions* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Input.FindNextElementOptions", L"ExclusionRect"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ExclusionRect());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int FindNextElementOptions_put_ExclusionRect(py::wrapper::Microsoft::UI::Xaml::Input::FindNextElementOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Input.FindNextElementOptions", L"ExclusionRect"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Rect>(arg);

            self->obj.ExclusionRect(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_FindNextElementOptions(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Input::FindNextElementOptions>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_FindNextElementOptions(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Input::FindNextElementOptions>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_FindNextElementOptions[] = {
        { "_assign_array_", _assign_array_FindNextElementOptions, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_FindNextElementOptions), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_FindNextElementOptions[] = {
        { "x_y_focus_navigation_strategy_override", reinterpret_cast<getter>(FindNextElementOptions_get_XYFocusNavigationStrategyOverride), reinterpret_cast<setter>(FindNextElementOptions_put_XYFocusNavigationStrategyOverride), nullptr, nullptr },
        { "search_root", reinterpret_cast<getter>(FindNextElementOptions_get_SearchRoot), reinterpret_cast<setter>(FindNextElementOptions_put_SearchRoot), nullptr, nullptr },
        { "hint_rect", reinterpret_cast<getter>(FindNextElementOptions_get_HintRect), reinterpret_cast<setter>(FindNextElementOptions_put_HintRect), nullptr, nullptr },
        { "exclusion_rect", reinterpret_cast<getter>(FindNextElementOptions_get_ExclusionRect), reinterpret_cast<setter>(FindNextElementOptions_put_ExclusionRect), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_FindNextElementOptions[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_FindNextElementOptions) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_FindNextElementOptions) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_FindNextElementOptions) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_FindNextElementOptions) },
        { },
    };

    static PyType_Spec type_spec_FindNextElementOptions =
    {
        "winrt._winrt_microsoft_ui_xaml_input.FindNextElementOptions",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Input::FindNextElementOptions),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_FindNextElementOptions
    };

    // ----- FocusManager class --------------------

    static PyObject* _new_FocusManager(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Xaml::Input::FocusManager>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Xaml::Input::FocusManager>::type_name);
        return nullptr;
    }

    static void _dealloc_FocusManager(py::wrapper::Microsoft::UI::Xaml::Input::FocusManager* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* FocusManager_FindFirstFocusableElement(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Input.FocusManager", L"FindFirstFocusableElement", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyObject>(args, 0);

                return py::convert(winrt::Microsoft::UI::Xaml::Input::FocusManager::FindFirstFocusableElement(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* FocusManager_FindLastFocusableElement(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Input.FocusManager", L"FindLastFocusableElement", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyObject>(args, 0);

                return py::convert(winrt::Microsoft::UI::Xaml::Input::FocusManager::FindLastFocusableElement(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* FocusManager_FindNextElement(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Input.FocusManager", L"FindNextElement", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Input::FocusNavigationDirection>(args, 0);

                return py::convert(winrt::Microsoft::UI::Xaml::Input::FocusManager::FindNextElement(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Input.FocusManager", L"FindNextElement", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Input::FocusNavigationDirection>(args, 0);
                auto param1 = py::convert_to<winrt::Microsoft::UI::Xaml::Input::FindNextElementOptions>(args, 1);

                return py::convert(winrt::Microsoft::UI::Xaml::Input::FocusManager::FindNextElement(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* FocusManager_FindNextFocusableElement(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Input.FocusManager", L"FindNextFocusableElement", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Input::FocusNavigationDirection>(args, 0);

                return py::convert(winrt::Microsoft::UI::Xaml::Input::FocusManager::FindNextFocusableElement(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Input.FocusManager", L"FindNextFocusableElement", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Input::FocusNavigationDirection>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Rect>(args, 1);

                return py::convert(winrt::Microsoft::UI::Xaml::Input::FocusManager::FindNextFocusableElement(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* FocusManager_GetFocusedElement(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Input.FocusManager", L"GetFocusedElement", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(winrt::Microsoft::UI::Xaml::Input::FocusManager::GetFocusedElement());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Input.FocusManager", L"GetFocusedElement", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::XamlRoot>(args, 0);

                return py::convert(winrt::Microsoft::UI::Xaml::Input::FocusManager::GetFocusedElement(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* FocusManager_TryFocusAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Input.FocusManager", L"TryFocusAsync", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyObject>(args, 0);
                auto param1 = py::convert_to<winrt::Microsoft::UI::Xaml::FocusState>(args, 1);

                return py::convert(winrt::Microsoft::UI::Xaml::Input::FocusManager::TryFocusAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* FocusManager_TryMoveFocus(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Input.FocusManager", L"TryMoveFocus", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Input::FocusNavigationDirection>(args, 0);

                return py::convert(winrt::Microsoft::UI::Xaml::Input::FocusManager::TryMoveFocus(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Input.FocusManager", L"TryMoveFocus", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Input::FocusNavigationDirection>(args, 0);
                auto param1 = py::convert_to<winrt::Microsoft::UI::Xaml::Input::FindNextElementOptions>(args, 1);

                return py::convert(winrt::Microsoft::UI::Xaml::Input::FocusManager::TryMoveFocus(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* FocusManager_TryMoveFocusAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Input.FocusManager", L"TryMoveFocusAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Input::FocusNavigationDirection>(args, 0);

                return py::convert(winrt::Microsoft::UI::Xaml::Input::FocusManager::TryMoveFocusAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Input.FocusManager", L"TryMoveFocusAsync", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Input::FocusNavigationDirection>(args, 0);
                auto param1 = py::convert_to<winrt::Microsoft::UI::Xaml::Input::FindNextElementOptions>(args, 1);

                return py::convert(winrt::Microsoft::UI::Xaml::Input::FocusManager::TryMoveFocusAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* FocusManager_add_GettingFocus(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Input.FocusManager", L"GettingFocus"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::EventHandler<winrt::Microsoft::UI::Xaml::Input::GettingFocusEventArgs>>(arg);

            return py::convert(winrt::Microsoft::UI::Xaml::Input::FocusManager::GettingFocus(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FocusManager_remove_GettingFocus(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Input.FocusManager", L"GettingFocus"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            winrt::Microsoft::UI::Xaml::Input::FocusManager::GettingFocus(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FocusManager_add_GotFocus(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Input.FocusManager", L"GotFocus"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::EventHandler<winrt::Microsoft::UI::Xaml::Input::FocusManagerGotFocusEventArgs>>(arg);

            return py::convert(winrt::Microsoft::UI::Xaml::Input::FocusManager::GotFocus(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FocusManager_remove_GotFocus(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Input.FocusManager", L"GotFocus"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            winrt::Microsoft::UI::Xaml::Input::FocusManager::GotFocus(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FocusManager_add_LosingFocus(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Input.FocusManager", L"LosingFocus"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::EventHandler<winrt::Microsoft::UI::Xaml::Input::LosingFocusEventArgs>>(arg);

            return py::convert(winrt::Microsoft::UI::Xaml::Input::FocusManager::LosingFocus(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FocusManager_remove_LosingFocus(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Input.FocusManager", L"LosingFocus"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            winrt::Microsoft::UI::Xaml::Input::FocusManager::LosingFocus(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FocusManager_add_LostFocus(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Input.FocusManager", L"LostFocus"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::EventHandler<winrt::Microsoft::UI::Xaml::Input::FocusManagerLostFocusEventArgs>>(arg);

            return py::convert(winrt::Microsoft::UI::Xaml::Input::FocusManager::LostFocus(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FocusManager_remove_LostFocus(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Input.FocusManager", L"LostFocus"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            winrt::Microsoft::UI::Xaml::Input::FocusManager::LostFocus(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_FocusManager(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Input::FocusManager>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_FocusManager(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Input::FocusManager>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_FocusManager[] = {
        { "add_getting_focus", reinterpret_cast<PyCFunction>(FocusManager_add_GettingFocus), METH_O | METH_STATIC, nullptr },
        { "remove_getting_focus", reinterpret_cast<PyCFunction>(FocusManager_remove_GettingFocus), METH_O | METH_STATIC, nullptr },
        { "add_got_focus", reinterpret_cast<PyCFunction>(FocusManager_add_GotFocus), METH_O | METH_STATIC, nullptr },
        { "remove_got_focus", reinterpret_cast<PyCFunction>(FocusManager_remove_GotFocus), METH_O | METH_STATIC, nullptr },
        { "add_losing_focus", reinterpret_cast<PyCFunction>(FocusManager_add_LosingFocus), METH_O | METH_STATIC, nullptr },
        { "remove_losing_focus", reinterpret_cast<PyCFunction>(FocusManager_remove_LosingFocus), METH_O | METH_STATIC, nullptr },
        { "add_lost_focus", reinterpret_cast<PyCFunction>(FocusManager_add_LostFocus), METH_O | METH_STATIC, nullptr },
        { "remove_lost_focus", reinterpret_cast<PyCFunction>(FocusManager_remove_LostFocus), METH_O | METH_STATIC, nullptr },
        { "_assign_array_", _assign_array_FocusManager, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_FocusManager), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_FocusManager[] = {
        { }
    };

    static PyType_Slot _type_slots_FocusManager[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_FocusManager) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_FocusManager) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_FocusManager) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_FocusManager) },
        { },
    };

    static PyType_Spec type_spec_FocusManager =
    {
        "winrt._winrt_microsoft_ui_xaml_input.FocusManager",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Input::FocusManager),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_FocusManager
    };

    static PyGetSetDef getset_FocusManager_Static[] = {
        { }
    };

    static PyMethodDef methods_FocusManager_Static[] = {
        { "find_first_focusable_element", reinterpret_cast<PyCFunction>(FocusManager_FindFirstFocusableElement), METH_VARARGS, nullptr },
        { "find_last_focusable_element", reinterpret_cast<PyCFunction>(FocusManager_FindLastFocusableElement), METH_VARARGS, nullptr },
        { "find_next_element", reinterpret_cast<PyCFunction>(FocusManager_FindNextElement), METH_VARARGS, nullptr },
        { "find_next_focusable_element", reinterpret_cast<PyCFunction>(FocusManager_FindNextFocusableElement), METH_VARARGS, nullptr },
        { "get_focused_element", reinterpret_cast<PyCFunction>(FocusManager_GetFocusedElement), METH_VARARGS, nullptr },
        { "try_focus_async", reinterpret_cast<PyCFunction>(FocusManager_TryFocusAsync), METH_VARARGS, nullptr },
        { "try_move_focus", reinterpret_cast<PyCFunction>(FocusManager_TryMoveFocus), METH_VARARGS, nullptr },
        { "try_move_focus_async", reinterpret_cast<PyCFunction>(FocusManager_TryMoveFocusAsync), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_FocusManager_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_FocusManager_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_FocusManager_Static) },
        { }
    };

    static PyType_Spec type_spec_FocusManager_Static =
    {
        "winrt._winrt_microsoft_ui_xaml_input.FocusManager_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_FocusManager_Static
    };

    // ----- FocusManagerGotFocusEventArgs class --------------------

    static PyObject* _new_FocusManagerGotFocusEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Xaml::Input::FocusManagerGotFocusEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Xaml::Input::FocusManagerGotFocusEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_FocusManagerGotFocusEventArgs(py::wrapper::Microsoft::UI::Xaml::Input::FocusManagerGotFocusEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* FocusManagerGotFocusEventArgs_get_CorrelationId(py::wrapper::Microsoft::UI::Xaml::Input::FocusManagerGotFocusEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Input.FocusManagerGotFocusEventArgs", L"CorrelationId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CorrelationId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FocusManagerGotFocusEventArgs_get_NewFocusedElement(py::wrapper::Microsoft::UI::Xaml::Input::FocusManagerGotFocusEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Input.FocusManagerGotFocusEventArgs", L"NewFocusedElement"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.NewFocusedElement());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_FocusManagerGotFocusEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Input::FocusManagerGotFocusEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_FocusManagerGotFocusEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Input::FocusManagerGotFocusEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_FocusManagerGotFocusEventArgs[] = {
        { "_assign_array_", _assign_array_FocusManagerGotFocusEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_FocusManagerGotFocusEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_FocusManagerGotFocusEventArgs[] = {
        { "correlation_id", reinterpret_cast<getter>(FocusManagerGotFocusEventArgs_get_CorrelationId), nullptr, nullptr, nullptr },
        { "new_focused_element", reinterpret_cast<getter>(FocusManagerGotFocusEventArgs_get_NewFocusedElement), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_FocusManagerGotFocusEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_FocusManagerGotFocusEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_FocusManagerGotFocusEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_FocusManagerGotFocusEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_FocusManagerGotFocusEventArgs) },
        { },
    };

    static PyType_Spec type_spec_FocusManagerGotFocusEventArgs =
    {
        "winrt._winrt_microsoft_ui_xaml_input.FocusManagerGotFocusEventArgs",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Input::FocusManagerGotFocusEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_FocusManagerGotFocusEventArgs
    };

    // ----- FocusManagerLostFocusEventArgs class --------------------

    static PyObject* _new_FocusManagerLostFocusEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Xaml::Input::FocusManagerLostFocusEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Xaml::Input::FocusManagerLostFocusEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_FocusManagerLostFocusEventArgs(py::wrapper::Microsoft::UI::Xaml::Input::FocusManagerLostFocusEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* FocusManagerLostFocusEventArgs_get_CorrelationId(py::wrapper::Microsoft::UI::Xaml::Input::FocusManagerLostFocusEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Input.FocusManagerLostFocusEventArgs", L"CorrelationId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CorrelationId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FocusManagerLostFocusEventArgs_get_OldFocusedElement(py::wrapper::Microsoft::UI::Xaml::Input::FocusManagerLostFocusEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Input.FocusManagerLostFocusEventArgs", L"OldFocusedElement"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.OldFocusedElement());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_FocusManagerLostFocusEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Input::FocusManagerLostFocusEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_FocusManagerLostFocusEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Input::FocusManagerLostFocusEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_FocusManagerLostFocusEventArgs[] = {
        { "_assign_array_", _assign_array_FocusManagerLostFocusEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_FocusManagerLostFocusEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_FocusManagerLostFocusEventArgs[] = {
        { "correlation_id", reinterpret_cast<getter>(FocusManagerLostFocusEventArgs_get_CorrelationId), nullptr, nullptr, nullptr },
        { "old_focused_element", reinterpret_cast<getter>(FocusManagerLostFocusEventArgs_get_OldFocusedElement), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_FocusManagerLostFocusEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_FocusManagerLostFocusEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_FocusManagerLostFocusEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_FocusManagerLostFocusEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_FocusManagerLostFocusEventArgs) },
        { },
    };

    static PyType_Spec type_spec_FocusManagerLostFocusEventArgs =
    {
        "winrt._winrt_microsoft_ui_xaml_input.FocusManagerLostFocusEventArgs",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Input::FocusManagerLostFocusEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_FocusManagerLostFocusEventArgs
    };

    // ----- FocusMovementResult class --------------------

    static PyObject* _new_FocusMovementResult(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Xaml::Input::FocusMovementResult>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Xaml::Input::FocusMovementResult>::type_name);
        return nullptr;
    }

    static void _dealloc_FocusMovementResult(py::wrapper::Microsoft::UI::Xaml::Input::FocusMovementResult* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* FocusMovementResult_get_Succeeded(py::wrapper::Microsoft::UI::Xaml::Input::FocusMovementResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Input.FocusMovementResult", L"Succeeded"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Succeeded());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_FocusMovementResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Input::FocusMovementResult>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_FocusMovementResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Input::FocusMovementResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_FocusMovementResult[] = {
        { "_assign_array_", _assign_array_FocusMovementResult, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_FocusMovementResult), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_FocusMovementResult[] = {
        { "succeeded", reinterpret_cast<getter>(FocusMovementResult_get_Succeeded), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_FocusMovementResult[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_FocusMovementResult) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_FocusMovementResult) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_FocusMovementResult) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_FocusMovementResult) },
        { },
    };

    static PyType_Spec type_spec_FocusMovementResult =
    {
        "winrt._winrt_microsoft_ui_xaml_input.FocusMovementResult",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Input::FocusMovementResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_FocusMovementResult
    };

    // ----- GettingFocusEventArgs class --------------------

    static PyObject* _new_GettingFocusEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Xaml::Input::GettingFocusEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Xaml::Input::GettingFocusEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_GettingFocusEventArgs(py::wrapper::Microsoft::UI::Xaml::Input::GettingFocusEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* GettingFocusEventArgs_TryCancel(py::wrapper::Microsoft::UI::Xaml::Input::GettingFocusEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Input.GettingFocusEventArgs", L"TryCancel", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.TryCancel());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* GettingFocusEventArgs_TrySetNewFocusedElement(py::wrapper::Microsoft::UI::Xaml::Input::GettingFocusEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Input.GettingFocusEventArgs", L"TrySetNewFocusedElement", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyObject>(args, 0);

                return py::convert(self->obj.TrySetNewFocusedElement(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* GettingFocusEventArgs_get_NewFocusedElement(py::wrapper::Microsoft::UI::Xaml::Input::GettingFocusEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Input.GettingFocusEventArgs", L"NewFocusedElement"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.NewFocusedElement());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int GettingFocusEventArgs_put_NewFocusedElement(py::wrapper::Microsoft::UI::Xaml::Input::GettingFocusEventArgs* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Input.GettingFocusEventArgs", L"NewFocusedElement"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyObject>(arg);

            self->obj.NewFocusedElement(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* GettingFocusEventArgs_get_Handled(py::wrapper::Microsoft::UI::Xaml::Input::GettingFocusEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Input.GettingFocusEventArgs", L"Handled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Handled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int GettingFocusEventArgs_put_Handled(py::wrapper::Microsoft::UI::Xaml::Input::GettingFocusEventArgs* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Input.GettingFocusEventArgs", L"Handled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.Handled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* GettingFocusEventArgs_get_Cancel(py::wrapper::Microsoft::UI::Xaml::Input::GettingFocusEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Input.GettingFocusEventArgs", L"Cancel"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Cancel());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int GettingFocusEventArgs_put_Cancel(py::wrapper::Microsoft::UI::Xaml::Input::GettingFocusEventArgs* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Input.GettingFocusEventArgs", L"Cancel"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.Cancel(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* GettingFocusEventArgs_get_CorrelationId(py::wrapper::Microsoft::UI::Xaml::Input::GettingFocusEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Input.GettingFocusEventArgs", L"CorrelationId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CorrelationId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GettingFocusEventArgs_get_Direction(py::wrapper::Microsoft::UI::Xaml::Input::GettingFocusEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Input.GettingFocusEventArgs", L"Direction"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Direction());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GettingFocusEventArgs_get_FocusState(py::wrapper::Microsoft::UI::Xaml::Input::GettingFocusEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Input.GettingFocusEventArgs", L"FocusState"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.FocusState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GettingFocusEventArgs_get_InputDevice(py::wrapper::Microsoft::UI::Xaml::Input::GettingFocusEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Input.GettingFocusEventArgs", L"InputDevice"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.InputDevice());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GettingFocusEventArgs_get_OldFocusedElement(py::wrapper::Microsoft::UI::Xaml::Input::GettingFocusEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Input.GettingFocusEventArgs", L"OldFocusedElement"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.OldFocusedElement());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_GettingFocusEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Input::GettingFocusEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_GettingFocusEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Input::GettingFocusEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_GettingFocusEventArgs[] = {
        { "try_cancel", reinterpret_cast<PyCFunction>(GettingFocusEventArgs_TryCancel), METH_VARARGS, nullptr },
        { "try_set_new_focused_element", reinterpret_cast<PyCFunction>(GettingFocusEventArgs_TrySetNewFocusedElement), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_GettingFocusEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_GettingFocusEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_GettingFocusEventArgs[] = {
        { "new_focused_element", reinterpret_cast<getter>(GettingFocusEventArgs_get_NewFocusedElement), reinterpret_cast<setter>(GettingFocusEventArgs_put_NewFocusedElement), nullptr, nullptr },
        { "handled", reinterpret_cast<getter>(GettingFocusEventArgs_get_Handled), reinterpret_cast<setter>(GettingFocusEventArgs_put_Handled), nullptr, nullptr },
        { "cancel", reinterpret_cast<getter>(GettingFocusEventArgs_get_Cancel), reinterpret_cast<setter>(GettingFocusEventArgs_put_Cancel), nullptr, nullptr },
        { "correlation_id", reinterpret_cast<getter>(GettingFocusEventArgs_get_CorrelationId), nullptr, nullptr, nullptr },
        { "direction", reinterpret_cast<getter>(GettingFocusEventArgs_get_Direction), nullptr, nullptr, nullptr },
        { "focus_state", reinterpret_cast<getter>(GettingFocusEventArgs_get_FocusState), nullptr, nullptr, nullptr },
        { "input_device", reinterpret_cast<getter>(GettingFocusEventArgs_get_InputDevice), nullptr, nullptr, nullptr },
        { "old_focused_element", reinterpret_cast<getter>(GettingFocusEventArgs_get_OldFocusedElement), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_GettingFocusEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_GettingFocusEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_GettingFocusEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_GettingFocusEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_GettingFocusEventArgs) },
        { },
    };

    static PyType_Spec type_spec_GettingFocusEventArgs =
    {
        "winrt._winrt_microsoft_ui_xaml_input.GettingFocusEventArgs",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Input::GettingFocusEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_GettingFocusEventArgs
    };

    // ----- HoldingRoutedEventArgs class --------------------

    static PyObject* _new_HoldingRoutedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Microsoft::UI::Xaml::Input::HoldingRoutedEventArgs instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_HoldingRoutedEventArgs(py::wrapper::Microsoft::UI::Xaml::Input::HoldingRoutedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* HoldingRoutedEventArgs_GetPosition(py::wrapper::Microsoft::UI::Xaml::Input::HoldingRoutedEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Input.HoldingRoutedEventArgs", L"GetPosition", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::UIElement>(args, 0);

                return py::convert(self->obj.GetPosition(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HoldingRoutedEventArgs_get_Handled(py::wrapper::Microsoft::UI::Xaml::Input::HoldingRoutedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Input.HoldingRoutedEventArgs", L"Handled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Handled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int HoldingRoutedEventArgs_put_Handled(py::wrapper::Microsoft::UI::Xaml::Input::HoldingRoutedEventArgs* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Input.HoldingRoutedEventArgs", L"Handled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.Handled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* HoldingRoutedEventArgs_get_HoldingState(py::wrapper::Microsoft::UI::Xaml::Input::HoldingRoutedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Input.HoldingRoutedEventArgs", L"HoldingState"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.HoldingState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HoldingRoutedEventArgs_get_PointerDeviceType(py::wrapper::Microsoft::UI::Xaml::Input::HoldingRoutedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Input.HoldingRoutedEventArgs", L"PointerDeviceType"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PointerDeviceType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_HoldingRoutedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Input::HoldingRoutedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_HoldingRoutedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Input::HoldingRoutedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_HoldingRoutedEventArgs[] = {
        { "get_position", reinterpret_cast<PyCFunction>(HoldingRoutedEventArgs_GetPosition), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_HoldingRoutedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_HoldingRoutedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_HoldingRoutedEventArgs[] = {
        { "handled", reinterpret_cast<getter>(HoldingRoutedEventArgs_get_Handled), reinterpret_cast<setter>(HoldingRoutedEventArgs_put_Handled), nullptr, nullptr },
        { "holding_state", reinterpret_cast<getter>(HoldingRoutedEventArgs_get_HoldingState), nullptr, nullptr, nullptr },
        { "pointer_device_type", reinterpret_cast<getter>(HoldingRoutedEventArgs_get_PointerDeviceType), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_HoldingRoutedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_HoldingRoutedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_HoldingRoutedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_HoldingRoutedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_HoldingRoutedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_HoldingRoutedEventArgs =
    {
        "winrt._winrt_microsoft_ui_xaml_input.HoldingRoutedEventArgs",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Input::HoldingRoutedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_HoldingRoutedEventArgs
    };

    // ----- InertiaExpansionBehavior class --------------------

    static PyObject* _new_InertiaExpansionBehavior(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Xaml::Input::InertiaExpansionBehavior>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Xaml::Input::InertiaExpansionBehavior>::type_name);
        return nullptr;
    }

    static void _dealloc_InertiaExpansionBehavior(py::wrapper::Microsoft::UI::Xaml::Input::InertiaExpansionBehavior* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* InertiaExpansionBehavior_get_DesiredExpansion(py::wrapper::Microsoft::UI::Xaml::Input::InertiaExpansionBehavior* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Input.InertiaExpansionBehavior", L"DesiredExpansion"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DesiredExpansion());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InertiaExpansionBehavior_put_DesiredExpansion(py::wrapper::Microsoft::UI::Xaml::Input::InertiaExpansionBehavior* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Input.InertiaExpansionBehavior", L"DesiredExpansion"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.DesiredExpansion(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InertiaExpansionBehavior_get_DesiredDeceleration(py::wrapper::Microsoft::UI::Xaml::Input::InertiaExpansionBehavior* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Input.InertiaExpansionBehavior", L"DesiredDeceleration"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DesiredDeceleration());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InertiaExpansionBehavior_put_DesiredDeceleration(py::wrapper::Microsoft::UI::Xaml::Input::InertiaExpansionBehavior* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Input.InertiaExpansionBehavior", L"DesiredDeceleration"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.DesiredDeceleration(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_InertiaExpansionBehavior(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Input::InertiaExpansionBehavior>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_InertiaExpansionBehavior(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Input::InertiaExpansionBehavior>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_InertiaExpansionBehavior[] = {
        { "_assign_array_", _assign_array_InertiaExpansionBehavior, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_InertiaExpansionBehavior), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_InertiaExpansionBehavior[] = {
        { "desired_expansion", reinterpret_cast<getter>(InertiaExpansionBehavior_get_DesiredExpansion), reinterpret_cast<setter>(InertiaExpansionBehavior_put_DesiredExpansion), nullptr, nullptr },
        { "desired_deceleration", reinterpret_cast<getter>(InertiaExpansionBehavior_get_DesiredDeceleration), reinterpret_cast<setter>(InertiaExpansionBehavior_put_DesiredDeceleration), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_InertiaExpansionBehavior[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_InertiaExpansionBehavior) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_InertiaExpansionBehavior) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_InertiaExpansionBehavior) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_InertiaExpansionBehavior) },
        { },
    };

    static PyType_Spec type_spec_InertiaExpansionBehavior =
    {
        "winrt._winrt_microsoft_ui_xaml_input.InertiaExpansionBehavior",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Input::InertiaExpansionBehavior),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_InertiaExpansionBehavior
    };

    // ----- InertiaRotationBehavior class --------------------

    static PyObject* _new_InertiaRotationBehavior(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Xaml::Input::InertiaRotationBehavior>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Xaml::Input::InertiaRotationBehavior>::type_name);
        return nullptr;
    }

    static void _dealloc_InertiaRotationBehavior(py::wrapper::Microsoft::UI::Xaml::Input::InertiaRotationBehavior* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* InertiaRotationBehavior_get_DesiredRotation(py::wrapper::Microsoft::UI::Xaml::Input::InertiaRotationBehavior* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Input.InertiaRotationBehavior", L"DesiredRotation"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DesiredRotation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InertiaRotationBehavior_put_DesiredRotation(py::wrapper::Microsoft::UI::Xaml::Input::InertiaRotationBehavior* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Input.InertiaRotationBehavior", L"DesiredRotation"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.DesiredRotation(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InertiaRotationBehavior_get_DesiredDeceleration(py::wrapper::Microsoft::UI::Xaml::Input::InertiaRotationBehavior* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Input.InertiaRotationBehavior", L"DesiredDeceleration"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DesiredDeceleration());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InertiaRotationBehavior_put_DesiredDeceleration(py::wrapper::Microsoft::UI::Xaml::Input::InertiaRotationBehavior* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Input.InertiaRotationBehavior", L"DesiredDeceleration"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.DesiredDeceleration(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_InertiaRotationBehavior(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Input::InertiaRotationBehavior>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_InertiaRotationBehavior(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Input::InertiaRotationBehavior>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_InertiaRotationBehavior[] = {
        { "_assign_array_", _assign_array_InertiaRotationBehavior, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_InertiaRotationBehavior), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_InertiaRotationBehavior[] = {
        { "desired_rotation", reinterpret_cast<getter>(InertiaRotationBehavior_get_DesiredRotation), reinterpret_cast<setter>(InertiaRotationBehavior_put_DesiredRotation), nullptr, nullptr },
        { "desired_deceleration", reinterpret_cast<getter>(InertiaRotationBehavior_get_DesiredDeceleration), reinterpret_cast<setter>(InertiaRotationBehavior_put_DesiredDeceleration), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_InertiaRotationBehavior[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_InertiaRotationBehavior) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_InertiaRotationBehavior) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_InertiaRotationBehavior) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_InertiaRotationBehavior) },
        { },
    };

    static PyType_Spec type_spec_InertiaRotationBehavior =
    {
        "winrt._winrt_microsoft_ui_xaml_input.InertiaRotationBehavior",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Input::InertiaRotationBehavior),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_InertiaRotationBehavior
    };

    // ----- InertiaTranslationBehavior class --------------------

    static PyObject* _new_InertiaTranslationBehavior(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Xaml::Input::InertiaTranslationBehavior>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Xaml::Input::InertiaTranslationBehavior>::type_name);
        return nullptr;
    }

    static void _dealloc_InertiaTranslationBehavior(py::wrapper::Microsoft::UI::Xaml::Input::InertiaTranslationBehavior* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* InertiaTranslationBehavior_get_DesiredDisplacement(py::wrapper::Microsoft::UI::Xaml::Input::InertiaTranslationBehavior* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Input.InertiaTranslationBehavior", L"DesiredDisplacement"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DesiredDisplacement());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InertiaTranslationBehavior_put_DesiredDisplacement(py::wrapper::Microsoft::UI::Xaml::Input::InertiaTranslationBehavior* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Input.InertiaTranslationBehavior", L"DesiredDisplacement"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.DesiredDisplacement(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InertiaTranslationBehavior_get_DesiredDeceleration(py::wrapper::Microsoft::UI::Xaml::Input::InertiaTranslationBehavior* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Input.InertiaTranslationBehavior", L"DesiredDeceleration"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DesiredDeceleration());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InertiaTranslationBehavior_put_DesiredDeceleration(py::wrapper::Microsoft::UI::Xaml::Input::InertiaTranslationBehavior* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Input.InertiaTranslationBehavior", L"DesiredDeceleration"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.DesiredDeceleration(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_InertiaTranslationBehavior(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Input::InertiaTranslationBehavior>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_InertiaTranslationBehavior(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Input::InertiaTranslationBehavior>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_InertiaTranslationBehavior[] = {
        { "_assign_array_", _assign_array_InertiaTranslationBehavior, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_InertiaTranslationBehavior), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_InertiaTranslationBehavior[] = {
        { "desired_displacement", reinterpret_cast<getter>(InertiaTranslationBehavior_get_DesiredDisplacement), reinterpret_cast<setter>(InertiaTranslationBehavior_put_DesiredDisplacement), nullptr, nullptr },
        { "desired_deceleration", reinterpret_cast<getter>(InertiaTranslationBehavior_get_DesiredDeceleration), reinterpret_cast<setter>(InertiaTranslationBehavior_put_DesiredDeceleration), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_InertiaTranslationBehavior[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_InertiaTranslationBehavior) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_InertiaTranslationBehavior) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_InertiaTranslationBehavior) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_InertiaTranslationBehavior) },
        { },
    };

    static PyType_Spec type_spec_InertiaTranslationBehavior =
    {
        "winrt._winrt_microsoft_ui_xaml_input.InertiaTranslationBehavior",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Input::InertiaTranslationBehavior),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_InertiaTranslationBehavior
    };

    // ----- InputScope class --------------------

    static PyObject* _new_InputScope(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Microsoft::UI::Xaml::Input::InputScope instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_InputScope(py::wrapper::Microsoft::UI::Xaml::Input::InputScope* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* InputScope_get_Names(py::wrapper::Microsoft::UI::Xaml::Input::InputScope* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Input.InputScope", L"Names"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Names());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_InputScope(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Input::InputScope>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_InputScope(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Input::InputScope>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_InputScope[] = {
        { "_assign_array_", _assign_array_InputScope, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_InputScope), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_InputScope[] = {
        { "names", reinterpret_cast<getter>(InputScope_get_Names), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_InputScope[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_InputScope) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_InputScope) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_InputScope) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_InputScope) },
        { },
    };

    static PyType_Spec type_spec_InputScope =
    {
        "winrt._winrt_microsoft_ui_xaml_input.InputScope",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Input::InputScope),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_InputScope
    };

    // ----- InputScopeName class --------------------

    static PyObject* _new_InputScopeName(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Input::InputScopeNameValue>(args, 0);

                winrt::Microsoft::UI::Xaml::Input::InputScopeName instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 0)
        {
            try
            {
                winrt::Microsoft::UI::Xaml::Input::InputScopeName instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_InputScopeName(py::wrapper::Microsoft::UI::Xaml::Input::InputScopeName* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* InputScopeName_get_NameValue(py::wrapper::Microsoft::UI::Xaml::Input::InputScopeName* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Input.InputScopeName", L"NameValue"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.NameValue());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InputScopeName_put_NameValue(py::wrapper::Microsoft::UI::Xaml::Input::InputScopeName* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Input.InputScopeName", L"NameValue"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Input::InputScopeNameValue>(arg);

            self->obj.NameValue(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_InputScopeName(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Input::InputScopeName>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_InputScopeName(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Input::InputScopeName>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_InputScopeName[] = {
        { "_assign_array_", _assign_array_InputScopeName, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_InputScopeName), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_InputScopeName[] = {
        { "name_value", reinterpret_cast<getter>(InputScopeName_get_NameValue), reinterpret_cast<setter>(InputScopeName_put_NameValue), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_InputScopeName[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_InputScopeName) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_InputScopeName) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_InputScopeName) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_InputScopeName) },
        { },
    };

    static PyType_Spec type_spec_InputScopeName =
    {
        "winrt._winrt_microsoft_ui_xaml_input.InputScopeName",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Input::InputScopeName),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_InputScopeName
    };

    // ----- KeyRoutedEventArgs class --------------------

    static PyObject* _new_KeyRoutedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Xaml::Input::KeyRoutedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Xaml::Input::KeyRoutedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_KeyRoutedEventArgs(py::wrapper::Microsoft::UI::Xaml::Input::KeyRoutedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* KeyRoutedEventArgs_get_Handled(py::wrapper::Microsoft::UI::Xaml::Input::KeyRoutedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Input.KeyRoutedEventArgs", L"Handled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Handled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int KeyRoutedEventArgs_put_Handled(py::wrapper::Microsoft::UI::Xaml::Input::KeyRoutedEventArgs* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Input.KeyRoutedEventArgs", L"Handled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.Handled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* KeyRoutedEventArgs_get_DeviceId(py::wrapper::Microsoft::UI::Xaml::Input::KeyRoutedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Input.KeyRoutedEventArgs", L"DeviceId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DeviceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KeyRoutedEventArgs_get_Key(py::wrapper::Microsoft::UI::Xaml::Input::KeyRoutedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Input.KeyRoutedEventArgs", L"Key"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Key());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KeyRoutedEventArgs_get_KeyStatus(py::wrapper::Microsoft::UI::Xaml::Input::KeyRoutedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Input.KeyRoutedEventArgs", L"KeyStatus"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.KeyStatus());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KeyRoutedEventArgs_get_OriginalKey(py::wrapper::Microsoft::UI::Xaml::Input::KeyRoutedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Input.KeyRoutedEventArgs", L"OriginalKey"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.OriginalKey());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_KeyRoutedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Input::KeyRoutedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_KeyRoutedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Input::KeyRoutedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_KeyRoutedEventArgs[] = {
        { "_assign_array_", _assign_array_KeyRoutedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_KeyRoutedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_KeyRoutedEventArgs[] = {
        { "handled", reinterpret_cast<getter>(KeyRoutedEventArgs_get_Handled), reinterpret_cast<setter>(KeyRoutedEventArgs_put_Handled), nullptr, nullptr },
        { "device_id", reinterpret_cast<getter>(KeyRoutedEventArgs_get_DeviceId), nullptr, nullptr, nullptr },
        { "key", reinterpret_cast<getter>(KeyRoutedEventArgs_get_Key), nullptr, nullptr, nullptr },
        { "key_status", reinterpret_cast<getter>(KeyRoutedEventArgs_get_KeyStatus), nullptr, nullptr, nullptr },
        { "original_key", reinterpret_cast<getter>(KeyRoutedEventArgs_get_OriginalKey), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_KeyRoutedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_KeyRoutedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_KeyRoutedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_KeyRoutedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_KeyRoutedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_KeyRoutedEventArgs =
    {
        "winrt._winrt_microsoft_ui_xaml_input.KeyRoutedEventArgs",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Input::KeyRoutedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_KeyRoutedEventArgs
    };

    // ----- KeyboardAccelerator class --------------------

    static PyObject* _new_KeyboardAccelerator(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Microsoft::UI::Xaml::Input::KeyboardAccelerator instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_KeyboardAccelerator(py::wrapper::Microsoft::UI::Xaml::Input::KeyboardAccelerator* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* KeyboardAccelerator_get_ScopeOwner(py::wrapper::Microsoft::UI::Xaml::Input::KeyboardAccelerator* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Input.KeyboardAccelerator", L"ScopeOwner"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ScopeOwner());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int KeyboardAccelerator_put_ScopeOwner(py::wrapper::Microsoft::UI::Xaml::Input::KeyboardAccelerator* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Input.KeyboardAccelerator", L"ScopeOwner"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyObject>(arg);

            self->obj.ScopeOwner(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* KeyboardAccelerator_get_Modifiers(py::wrapper::Microsoft::UI::Xaml::Input::KeyboardAccelerator* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Input.KeyboardAccelerator", L"Modifiers"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Modifiers());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int KeyboardAccelerator_put_Modifiers(py::wrapper::Microsoft::UI::Xaml::Input::KeyboardAccelerator* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Input.KeyboardAccelerator", L"Modifiers"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::System::VirtualKeyModifiers>(arg);

            self->obj.Modifiers(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* KeyboardAccelerator_get_Key(py::wrapper::Microsoft::UI::Xaml::Input::KeyboardAccelerator* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Input.KeyboardAccelerator", L"Key"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Key());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int KeyboardAccelerator_put_Key(py::wrapper::Microsoft::UI::Xaml::Input::KeyboardAccelerator* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Input.KeyboardAccelerator", L"Key"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::System::VirtualKey>(arg);

            self->obj.Key(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* KeyboardAccelerator_get_IsEnabled(py::wrapper::Microsoft::UI::Xaml::Input::KeyboardAccelerator* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Input.KeyboardAccelerator", L"IsEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int KeyboardAccelerator_put_IsEnabled(py::wrapper::Microsoft::UI::Xaml::Input::KeyboardAccelerator* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Input.KeyboardAccelerator", L"IsEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* KeyboardAccelerator_get_IsEnabledProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Input.KeyboardAccelerator", L"IsEnabledProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Input::KeyboardAccelerator::IsEnabledProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KeyboardAccelerator_get_KeyProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Input.KeyboardAccelerator", L"KeyProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Input::KeyboardAccelerator::KeyProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KeyboardAccelerator_get_ModifiersProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Input.KeyboardAccelerator", L"ModifiersProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Input::KeyboardAccelerator::ModifiersProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KeyboardAccelerator_get_ScopeOwnerProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Input.KeyboardAccelerator", L"ScopeOwnerProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Input::KeyboardAccelerator::ScopeOwnerProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KeyboardAccelerator_add_Invoked(py::wrapper::Microsoft::UI::Xaml::Input::KeyboardAccelerator* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Input.KeyboardAccelerator", L"Invoked"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Xaml::Input::KeyboardAccelerator, winrt::Microsoft::UI::Xaml::Input::KeyboardAcceleratorInvokedEventArgs>>(arg);

            return py::convert(self->obj.Invoked(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KeyboardAccelerator_remove_Invoked(py::wrapper::Microsoft::UI::Xaml::Input::KeyboardAccelerator* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Input.KeyboardAccelerator", L"Invoked"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Invoked(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_KeyboardAccelerator(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Input::KeyboardAccelerator>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_KeyboardAccelerator(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Input::KeyboardAccelerator>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_KeyboardAccelerator[] = {
        { "add_invoked", reinterpret_cast<PyCFunction>(KeyboardAccelerator_add_Invoked), METH_O, nullptr },
        { "remove_invoked", reinterpret_cast<PyCFunction>(KeyboardAccelerator_remove_Invoked), METH_O, nullptr },
        { "_assign_array_", _assign_array_KeyboardAccelerator, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_KeyboardAccelerator), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_KeyboardAccelerator[] = {
        { "scope_owner", reinterpret_cast<getter>(KeyboardAccelerator_get_ScopeOwner), reinterpret_cast<setter>(KeyboardAccelerator_put_ScopeOwner), nullptr, nullptr },
        { "modifiers", reinterpret_cast<getter>(KeyboardAccelerator_get_Modifiers), reinterpret_cast<setter>(KeyboardAccelerator_put_Modifiers), nullptr, nullptr },
        { "key", reinterpret_cast<getter>(KeyboardAccelerator_get_Key), reinterpret_cast<setter>(KeyboardAccelerator_put_Key), nullptr, nullptr },
        { "is_enabled", reinterpret_cast<getter>(KeyboardAccelerator_get_IsEnabled), reinterpret_cast<setter>(KeyboardAccelerator_put_IsEnabled), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_KeyboardAccelerator[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_KeyboardAccelerator) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_KeyboardAccelerator) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_KeyboardAccelerator) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_KeyboardAccelerator) },
        { },
    };

    static PyType_Spec type_spec_KeyboardAccelerator =
    {
        "winrt._winrt_microsoft_ui_xaml_input.KeyboardAccelerator",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Input::KeyboardAccelerator),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_KeyboardAccelerator
    };

    static PyGetSetDef getset_KeyboardAccelerator_Static[] = {
        { "is_enabled_property", reinterpret_cast<getter>(KeyboardAccelerator_get_IsEnabledProperty), nullptr, nullptr, nullptr },
        { "key_property", reinterpret_cast<getter>(KeyboardAccelerator_get_KeyProperty), nullptr, nullptr, nullptr },
        { "modifiers_property", reinterpret_cast<getter>(KeyboardAccelerator_get_ModifiersProperty), nullptr, nullptr, nullptr },
        { "scope_owner_property", reinterpret_cast<getter>(KeyboardAccelerator_get_ScopeOwnerProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_KeyboardAccelerator_Static[] = {
        { }
    };

    static PyType_Slot type_slots_KeyboardAccelerator_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_KeyboardAccelerator_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_KeyboardAccelerator_Static) },
        { }
    };

    static PyType_Spec type_spec_KeyboardAccelerator_Static =
    {
        "winrt._winrt_microsoft_ui_xaml_input.KeyboardAccelerator_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_KeyboardAccelerator_Static
    };

    // ----- KeyboardAcceleratorInvokedEventArgs class --------------------

    static PyObject* _new_KeyboardAcceleratorInvokedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Xaml::Input::KeyboardAcceleratorInvokedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Xaml::Input::KeyboardAcceleratorInvokedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_KeyboardAcceleratorInvokedEventArgs(py::wrapper::Microsoft::UI::Xaml::Input::KeyboardAcceleratorInvokedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* KeyboardAcceleratorInvokedEventArgs_get_Handled(py::wrapper::Microsoft::UI::Xaml::Input::KeyboardAcceleratorInvokedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Input.KeyboardAcceleratorInvokedEventArgs", L"Handled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Handled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int KeyboardAcceleratorInvokedEventArgs_put_Handled(py::wrapper::Microsoft::UI::Xaml::Input::KeyboardAcceleratorInvokedEventArgs* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Input.KeyboardAcceleratorInvokedEventArgs", L"Handled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.Handled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* KeyboardAcceleratorInvokedEventArgs_get_Element(py::wrapper::Microsoft::UI::Xaml::Input::KeyboardAcceleratorInvokedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Input.KeyboardAcceleratorInvokedEventArgs", L"Element"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Element());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KeyboardAcceleratorInvokedEventArgs_get_KeyboardAccelerator(py::wrapper::Microsoft::UI::Xaml::Input::KeyboardAcceleratorInvokedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Input.KeyboardAcceleratorInvokedEventArgs", L"KeyboardAccelerator"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.KeyboardAccelerator());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_KeyboardAcceleratorInvokedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Input::KeyboardAcceleratorInvokedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_KeyboardAcceleratorInvokedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Input::KeyboardAcceleratorInvokedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_KeyboardAcceleratorInvokedEventArgs[] = {
        { "_assign_array_", _assign_array_KeyboardAcceleratorInvokedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_KeyboardAcceleratorInvokedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_KeyboardAcceleratorInvokedEventArgs[] = {
        { "handled", reinterpret_cast<getter>(KeyboardAcceleratorInvokedEventArgs_get_Handled), reinterpret_cast<setter>(KeyboardAcceleratorInvokedEventArgs_put_Handled), nullptr, nullptr },
        { "element", reinterpret_cast<getter>(KeyboardAcceleratorInvokedEventArgs_get_Element), nullptr, nullptr, nullptr },
        { "keyboard_accelerator", reinterpret_cast<getter>(KeyboardAcceleratorInvokedEventArgs_get_KeyboardAccelerator), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_KeyboardAcceleratorInvokedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_KeyboardAcceleratorInvokedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_KeyboardAcceleratorInvokedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_KeyboardAcceleratorInvokedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_KeyboardAcceleratorInvokedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_KeyboardAcceleratorInvokedEventArgs =
    {
        "winrt._winrt_microsoft_ui_xaml_input.KeyboardAcceleratorInvokedEventArgs",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Input::KeyboardAcceleratorInvokedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_KeyboardAcceleratorInvokedEventArgs
    };

    // ----- LosingFocusEventArgs class --------------------

    static PyObject* _new_LosingFocusEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Xaml::Input::LosingFocusEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Xaml::Input::LosingFocusEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_LosingFocusEventArgs(py::wrapper::Microsoft::UI::Xaml::Input::LosingFocusEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* LosingFocusEventArgs_TryCancel(py::wrapper::Microsoft::UI::Xaml::Input::LosingFocusEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Input.LosingFocusEventArgs", L"TryCancel", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.TryCancel());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LosingFocusEventArgs_TrySetNewFocusedElement(py::wrapper::Microsoft::UI::Xaml::Input::LosingFocusEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Input.LosingFocusEventArgs", L"TrySetNewFocusedElement", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyObject>(args, 0);

                return py::convert(self->obj.TrySetNewFocusedElement(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LosingFocusEventArgs_get_NewFocusedElement(py::wrapper::Microsoft::UI::Xaml::Input::LosingFocusEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Input.LosingFocusEventArgs", L"NewFocusedElement"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.NewFocusedElement());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LosingFocusEventArgs_put_NewFocusedElement(py::wrapper::Microsoft::UI::Xaml::Input::LosingFocusEventArgs* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Input.LosingFocusEventArgs", L"NewFocusedElement"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyObject>(arg);

            self->obj.NewFocusedElement(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* LosingFocusEventArgs_get_Handled(py::wrapper::Microsoft::UI::Xaml::Input::LosingFocusEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Input.LosingFocusEventArgs", L"Handled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Handled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LosingFocusEventArgs_put_Handled(py::wrapper::Microsoft::UI::Xaml::Input::LosingFocusEventArgs* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Input.LosingFocusEventArgs", L"Handled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.Handled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* LosingFocusEventArgs_get_Cancel(py::wrapper::Microsoft::UI::Xaml::Input::LosingFocusEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Input.LosingFocusEventArgs", L"Cancel"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Cancel());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LosingFocusEventArgs_put_Cancel(py::wrapper::Microsoft::UI::Xaml::Input::LosingFocusEventArgs* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Input.LosingFocusEventArgs", L"Cancel"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.Cancel(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* LosingFocusEventArgs_get_CorrelationId(py::wrapper::Microsoft::UI::Xaml::Input::LosingFocusEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Input.LosingFocusEventArgs", L"CorrelationId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CorrelationId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LosingFocusEventArgs_get_Direction(py::wrapper::Microsoft::UI::Xaml::Input::LosingFocusEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Input.LosingFocusEventArgs", L"Direction"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Direction());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LosingFocusEventArgs_get_FocusState(py::wrapper::Microsoft::UI::Xaml::Input::LosingFocusEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Input.LosingFocusEventArgs", L"FocusState"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.FocusState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LosingFocusEventArgs_get_InputDevice(py::wrapper::Microsoft::UI::Xaml::Input::LosingFocusEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Input.LosingFocusEventArgs", L"InputDevice"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.InputDevice());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LosingFocusEventArgs_get_OldFocusedElement(py::wrapper::Microsoft::UI::Xaml::Input::LosingFocusEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Input.LosingFocusEventArgs", L"OldFocusedElement"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.OldFocusedElement());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_LosingFocusEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Input::LosingFocusEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_LosingFocusEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Input::LosingFocusEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_LosingFocusEventArgs[] = {
        { "try_cancel", reinterpret_cast<PyCFunction>(LosingFocusEventArgs_TryCancel), METH_VARARGS, nullptr },
        { "try_set_new_focused_element", reinterpret_cast<PyCFunction>(LosingFocusEventArgs_TrySetNewFocusedElement), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_LosingFocusEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_LosingFocusEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_LosingFocusEventArgs[] = {
        { "new_focused_element", reinterpret_cast<getter>(LosingFocusEventArgs_get_NewFocusedElement), reinterpret_cast<setter>(LosingFocusEventArgs_put_NewFocusedElement), nullptr, nullptr },
        { "handled", reinterpret_cast<getter>(LosingFocusEventArgs_get_Handled), reinterpret_cast<setter>(LosingFocusEventArgs_put_Handled), nullptr, nullptr },
        { "cancel", reinterpret_cast<getter>(LosingFocusEventArgs_get_Cancel), reinterpret_cast<setter>(LosingFocusEventArgs_put_Cancel), nullptr, nullptr },
        { "correlation_id", reinterpret_cast<getter>(LosingFocusEventArgs_get_CorrelationId), nullptr, nullptr, nullptr },
        { "direction", reinterpret_cast<getter>(LosingFocusEventArgs_get_Direction), nullptr, nullptr, nullptr },
        { "focus_state", reinterpret_cast<getter>(LosingFocusEventArgs_get_FocusState), nullptr, nullptr, nullptr },
        { "input_device", reinterpret_cast<getter>(LosingFocusEventArgs_get_InputDevice), nullptr, nullptr, nullptr },
        { "old_focused_element", reinterpret_cast<getter>(LosingFocusEventArgs_get_OldFocusedElement), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_LosingFocusEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_LosingFocusEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_LosingFocusEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_LosingFocusEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_LosingFocusEventArgs) },
        { },
    };

    static PyType_Spec type_spec_LosingFocusEventArgs =
    {
        "winrt._winrt_microsoft_ui_xaml_input.LosingFocusEventArgs",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Input::LosingFocusEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_LosingFocusEventArgs
    };

    // ----- ManipulationCompletedRoutedEventArgs class --------------------

    static PyObject* _new_ManipulationCompletedRoutedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Microsoft::UI::Xaml::Input::ManipulationCompletedRoutedEventArgs instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ManipulationCompletedRoutedEventArgs(py::wrapper::Microsoft::UI::Xaml::Input::ManipulationCompletedRoutedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ManipulationCompletedRoutedEventArgs_get_Handled(py::wrapper::Microsoft::UI::Xaml::Input::ManipulationCompletedRoutedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Input.ManipulationCompletedRoutedEventArgs", L"Handled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Handled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ManipulationCompletedRoutedEventArgs_put_Handled(py::wrapper::Microsoft::UI::Xaml::Input::ManipulationCompletedRoutedEventArgs* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Input.ManipulationCompletedRoutedEventArgs", L"Handled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.Handled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ManipulationCompletedRoutedEventArgs_get_Container(py::wrapper::Microsoft::UI::Xaml::Input::ManipulationCompletedRoutedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Input.ManipulationCompletedRoutedEventArgs", L"Container"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Container());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ManipulationCompletedRoutedEventArgs_get_Cumulative(py::wrapper::Microsoft::UI::Xaml::Input::ManipulationCompletedRoutedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Input.ManipulationCompletedRoutedEventArgs", L"Cumulative"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Cumulative());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ManipulationCompletedRoutedEventArgs_get_IsInertial(py::wrapper::Microsoft::UI::Xaml::Input::ManipulationCompletedRoutedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Input.ManipulationCompletedRoutedEventArgs", L"IsInertial"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsInertial());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ManipulationCompletedRoutedEventArgs_get_PointerDeviceType(py::wrapper::Microsoft::UI::Xaml::Input::ManipulationCompletedRoutedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Input.ManipulationCompletedRoutedEventArgs", L"PointerDeviceType"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PointerDeviceType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ManipulationCompletedRoutedEventArgs_get_Position(py::wrapper::Microsoft::UI::Xaml::Input::ManipulationCompletedRoutedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Input.ManipulationCompletedRoutedEventArgs", L"Position"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Position());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ManipulationCompletedRoutedEventArgs_get_Velocities(py::wrapper::Microsoft::UI::Xaml::Input::ManipulationCompletedRoutedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Input.ManipulationCompletedRoutedEventArgs", L"Velocities"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Velocities());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ManipulationCompletedRoutedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Input::ManipulationCompletedRoutedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ManipulationCompletedRoutedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Input::ManipulationCompletedRoutedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ManipulationCompletedRoutedEventArgs[] = {
        { "_assign_array_", _assign_array_ManipulationCompletedRoutedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ManipulationCompletedRoutedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ManipulationCompletedRoutedEventArgs[] = {
        { "handled", reinterpret_cast<getter>(ManipulationCompletedRoutedEventArgs_get_Handled), reinterpret_cast<setter>(ManipulationCompletedRoutedEventArgs_put_Handled), nullptr, nullptr },
        { "container", reinterpret_cast<getter>(ManipulationCompletedRoutedEventArgs_get_Container), nullptr, nullptr, nullptr },
        { "cumulative", reinterpret_cast<getter>(ManipulationCompletedRoutedEventArgs_get_Cumulative), nullptr, nullptr, nullptr },
        { "is_inertial", reinterpret_cast<getter>(ManipulationCompletedRoutedEventArgs_get_IsInertial), nullptr, nullptr, nullptr },
        { "pointer_device_type", reinterpret_cast<getter>(ManipulationCompletedRoutedEventArgs_get_PointerDeviceType), nullptr, nullptr, nullptr },
        { "position", reinterpret_cast<getter>(ManipulationCompletedRoutedEventArgs_get_Position), nullptr, nullptr, nullptr },
        { "velocities", reinterpret_cast<getter>(ManipulationCompletedRoutedEventArgs_get_Velocities), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ManipulationCompletedRoutedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ManipulationCompletedRoutedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ManipulationCompletedRoutedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ManipulationCompletedRoutedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ManipulationCompletedRoutedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_ManipulationCompletedRoutedEventArgs =
    {
        "winrt._winrt_microsoft_ui_xaml_input.ManipulationCompletedRoutedEventArgs",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Input::ManipulationCompletedRoutedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ManipulationCompletedRoutedEventArgs
    };

    // ----- ManipulationDeltaRoutedEventArgs class --------------------

    static PyObject* _new_ManipulationDeltaRoutedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Microsoft::UI::Xaml::Input::ManipulationDeltaRoutedEventArgs instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ManipulationDeltaRoutedEventArgs(py::wrapper::Microsoft::UI::Xaml::Input::ManipulationDeltaRoutedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ManipulationDeltaRoutedEventArgs_Complete(py::wrapper::Microsoft::UI::Xaml::Input::ManipulationDeltaRoutedEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Input.ManipulationDeltaRoutedEventArgs", L"Complete", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Complete();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ManipulationDeltaRoutedEventArgs_get_Handled(py::wrapper::Microsoft::UI::Xaml::Input::ManipulationDeltaRoutedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Input.ManipulationDeltaRoutedEventArgs", L"Handled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Handled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ManipulationDeltaRoutedEventArgs_put_Handled(py::wrapper::Microsoft::UI::Xaml::Input::ManipulationDeltaRoutedEventArgs* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Input.ManipulationDeltaRoutedEventArgs", L"Handled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.Handled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ManipulationDeltaRoutedEventArgs_get_Container(py::wrapper::Microsoft::UI::Xaml::Input::ManipulationDeltaRoutedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Input.ManipulationDeltaRoutedEventArgs", L"Container"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Container());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ManipulationDeltaRoutedEventArgs_get_Cumulative(py::wrapper::Microsoft::UI::Xaml::Input::ManipulationDeltaRoutedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Input.ManipulationDeltaRoutedEventArgs", L"Cumulative"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Cumulative());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ManipulationDeltaRoutedEventArgs_get_Delta(py::wrapper::Microsoft::UI::Xaml::Input::ManipulationDeltaRoutedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Input.ManipulationDeltaRoutedEventArgs", L"Delta"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Delta());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ManipulationDeltaRoutedEventArgs_get_IsInertial(py::wrapper::Microsoft::UI::Xaml::Input::ManipulationDeltaRoutedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Input.ManipulationDeltaRoutedEventArgs", L"IsInertial"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsInertial());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ManipulationDeltaRoutedEventArgs_get_PointerDeviceType(py::wrapper::Microsoft::UI::Xaml::Input::ManipulationDeltaRoutedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Input.ManipulationDeltaRoutedEventArgs", L"PointerDeviceType"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PointerDeviceType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ManipulationDeltaRoutedEventArgs_get_Position(py::wrapper::Microsoft::UI::Xaml::Input::ManipulationDeltaRoutedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Input.ManipulationDeltaRoutedEventArgs", L"Position"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Position());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ManipulationDeltaRoutedEventArgs_get_Velocities(py::wrapper::Microsoft::UI::Xaml::Input::ManipulationDeltaRoutedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Input.ManipulationDeltaRoutedEventArgs", L"Velocities"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Velocities());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ManipulationDeltaRoutedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Input::ManipulationDeltaRoutedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ManipulationDeltaRoutedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Input::ManipulationDeltaRoutedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ManipulationDeltaRoutedEventArgs[] = {
        { "complete", reinterpret_cast<PyCFunction>(ManipulationDeltaRoutedEventArgs_Complete), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_ManipulationDeltaRoutedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ManipulationDeltaRoutedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ManipulationDeltaRoutedEventArgs[] = {
        { "handled", reinterpret_cast<getter>(ManipulationDeltaRoutedEventArgs_get_Handled), reinterpret_cast<setter>(ManipulationDeltaRoutedEventArgs_put_Handled), nullptr, nullptr },
        { "container", reinterpret_cast<getter>(ManipulationDeltaRoutedEventArgs_get_Container), nullptr, nullptr, nullptr },
        { "cumulative", reinterpret_cast<getter>(ManipulationDeltaRoutedEventArgs_get_Cumulative), nullptr, nullptr, nullptr },
        { "delta", reinterpret_cast<getter>(ManipulationDeltaRoutedEventArgs_get_Delta), nullptr, nullptr, nullptr },
        { "is_inertial", reinterpret_cast<getter>(ManipulationDeltaRoutedEventArgs_get_IsInertial), nullptr, nullptr, nullptr },
        { "pointer_device_type", reinterpret_cast<getter>(ManipulationDeltaRoutedEventArgs_get_PointerDeviceType), nullptr, nullptr, nullptr },
        { "position", reinterpret_cast<getter>(ManipulationDeltaRoutedEventArgs_get_Position), nullptr, nullptr, nullptr },
        { "velocities", reinterpret_cast<getter>(ManipulationDeltaRoutedEventArgs_get_Velocities), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ManipulationDeltaRoutedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ManipulationDeltaRoutedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ManipulationDeltaRoutedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ManipulationDeltaRoutedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ManipulationDeltaRoutedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_ManipulationDeltaRoutedEventArgs =
    {
        "winrt._winrt_microsoft_ui_xaml_input.ManipulationDeltaRoutedEventArgs",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Input::ManipulationDeltaRoutedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ManipulationDeltaRoutedEventArgs
    };

    // ----- ManipulationInertiaStartingRoutedEventArgs class --------------------

    static PyObject* _new_ManipulationInertiaStartingRoutedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Microsoft::UI::Xaml::Input::ManipulationInertiaStartingRoutedEventArgs instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ManipulationInertiaStartingRoutedEventArgs(py::wrapper::Microsoft::UI::Xaml::Input::ManipulationInertiaStartingRoutedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ManipulationInertiaStartingRoutedEventArgs_get_TranslationBehavior(py::wrapper::Microsoft::UI::Xaml::Input::ManipulationInertiaStartingRoutedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Input.ManipulationInertiaStartingRoutedEventArgs", L"TranslationBehavior"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.TranslationBehavior());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ManipulationInertiaStartingRoutedEventArgs_put_TranslationBehavior(py::wrapper::Microsoft::UI::Xaml::Input::ManipulationInertiaStartingRoutedEventArgs* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Input.ManipulationInertiaStartingRoutedEventArgs", L"TranslationBehavior"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Input::InertiaTranslationBehavior>(arg);

            self->obj.TranslationBehavior(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ManipulationInertiaStartingRoutedEventArgs_get_RotationBehavior(py::wrapper::Microsoft::UI::Xaml::Input::ManipulationInertiaStartingRoutedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Input.ManipulationInertiaStartingRoutedEventArgs", L"RotationBehavior"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.RotationBehavior());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ManipulationInertiaStartingRoutedEventArgs_put_RotationBehavior(py::wrapper::Microsoft::UI::Xaml::Input::ManipulationInertiaStartingRoutedEventArgs* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Input.ManipulationInertiaStartingRoutedEventArgs", L"RotationBehavior"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Input::InertiaRotationBehavior>(arg);

            self->obj.RotationBehavior(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ManipulationInertiaStartingRoutedEventArgs_get_Handled(py::wrapper::Microsoft::UI::Xaml::Input::ManipulationInertiaStartingRoutedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Input.ManipulationInertiaStartingRoutedEventArgs", L"Handled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Handled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ManipulationInertiaStartingRoutedEventArgs_put_Handled(py::wrapper::Microsoft::UI::Xaml::Input::ManipulationInertiaStartingRoutedEventArgs* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Input.ManipulationInertiaStartingRoutedEventArgs", L"Handled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.Handled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ManipulationInertiaStartingRoutedEventArgs_get_ExpansionBehavior(py::wrapper::Microsoft::UI::Xaml::Input::ManipulationInertiaStartingRoutedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Input.ManipulationInertiaStartingRoutedEventArgs", L"ExpansionBehavior"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ExpansionBehavior());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ManipulationInertiaStartingRoutedEventArgs_put_ExpansionBehavior(py::wrapper::Microsoft::UI::Xaml::Input::ManipulationInertiaStartingRoutedEventArgs* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Input.ManipulationInertiaStartingRoutedEventArgs", L"ExpansionBehavior"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Input::InertiaExpansionBehavior>(arg);

            self->obj.ExpansionBehavior(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ManipulationInertiaStartingRoutedEventArgs_get_Container(py::wrapper::Microsoft::UI::Xaml::Input::ManipulationInertiaStartingRoutedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Input.ManipulationInertiaStartingRoutedEventArgs", L"Container"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Container());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ManipulationInertiaStartingRoutedEventArgs_get_Cumulative(py::wrapper::Microsoft::UI::Xaml::Input::ManipulationInertiaStartingRoutedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Input.ManipulationInertiaStartingRoutedEventArgs", L"Cumulative"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Cumulative());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ManipulationInertiaStartingRoutedEventArgs_get_Delta(py::wrapper::Microsoft::UI::Xaml::Input::ManipulationInertiaStartingRoutedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Input.ManipulationInertiaStartingRoutedEventArgs", L"Delta"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Delta());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ManipulationInertiaStartingRoutedEventArgs_get_PointerDeviceType(py::wrapper::Microsoft::UI::Xaml::Input::ManipulationInertiaStartingRoutedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Input.ManipulationInertiaStartingRoutedEventArgs", L"PointerDeviceType"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PointerDeviceType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ManipulationInertiaStartingRoutedEventArgs_get_Velocities(py::wrapper::Microsoft::UI::Xaml::Input::ManipulationInertiaStartingRoutedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Input.ManipulationInertiaStartingRoutedEventArgs", L"Velocities"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Velocities());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ManipulationInertiaStartingRoutedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Input::ManipulationInertiaStartingRoutedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ManipulationInertiaStartingRoutedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Input::ManipulationInertiaStartingRoutedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ManipulationInertiaStartingRoutedEventArgs[] = {
        { "_assign_array_", _assign_array_ManipulationInertiaStartingRoutedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ManipulationInertiaStartingRoutedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ManipulationInertiaStartingRoutedEventArgs[] = {
        { "translation_behavior", reinterpret_cast<getter>(ManipulationInertiaStartingRoutedEventArgs_get_TranslationBehavior), reinterpret_cast<setter>(ManipulationInertiaStartingRoutedEventArgs_put_TranslationBehavior), nullptr, nullptr },
        { "rotation_behavior", reinterpret_cast<getter>(ManipulationInertiaStartingRoutedEventArgs_get_RotationBehavior), reinterpret_cast<setter>(ManipulationInertiaStartingRoutedEventArgs_put_RotationBehavior), nullptr, nullptr },
        { "handled", reinterpret_cast<getter>(ManipulationInertiaStartingRoutedEventArgs_get_Handled), reinterpret_cast<setter>(ManipulationInertiaStartingRoutedEventArgs_put_Handled), nullptr, nullptr },
        { "expansion_behavior", reinterpret_cast<getter>(ManipulationInertiaStartingRoutedEventArgs_get_ExpansionBehavior), reinterpret_cast<setter>(ManipulationInertiaStartingRoutedEventArgs_put_ExpansionBehavior), nullptr, nullptr },
        { "container", reinterpret_cast<getter>(ManipulationInertiaStartingRoutedEventArgs_get_Container), nullptr, nullptr, nullptr },
        { "cumulative", reinterpret_cast<getter>(ManipulationInertiaStartingRoutedEventArgs_get_Cumulative), nullptr, nullptr, nullptr },
        { "delta", reinterpret_cast<getter>(ManipulationInertiaStartingRoutedEventArgs_get_Delta), nullptr, nullptr, nullptr },
        { "pointer_device_type", reinterpret_cast<getter>(ManipulationInertiaStartingRoutedEventArgs_get_PointerDeviceType), nullptr, nullptr, nullptr },
        { "velocities", reinterpret_cast<getter>(ManipulationInertiaStartingRoutedEventArgs_get_Velocities), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ManipulationInertiaStartingRoutedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ManipulationInertiaStartingRoutedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ManipulationInertiaStartingRoutedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ManipulationInertiaStartingRoutedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ManipulationInertiaStartingRoutedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_ManipulationInertiaStartingRoutedEventArgs =
    {
        "winrt._winrt_microsoft_ui_xaml_input.ManipulationInertiaStartingRoutedEventArgs",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Input::ManipulationInertiaStartingRoutedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ManipulationInertiaStartingRoutedEventArgs
    };

    // ----- ManipulationPivot class --------------------

    static PyObject* _new_ManipulationPivot(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Point>(args, 0);
                auto param1 = py::convert_to<double>(args, 1);

                winrt::Microsoft::UI::Xaml::Input::ManipulationPivot instance{ param0, param1 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 0)
        {
            try
            {
                winrt::Microsoft::UI::Xaml::Input::ManipulationPivot instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ManipulationPivot(py::wrapper::Microsoft::UI::Xaml::Input::ManipulationPivot* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ManipulationPivot_get_Radius(py::wrapper::Microsoft::UI::Xaml::Input::ManipulationPivot* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Input.ManipulationPivot", L"Radius"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Radius());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ManipulationPivot_put_Radius(py::wrapper::Microsoft::UI::Xaml::Input::ManipulationPivot* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Input.ManipulationPivot", L"Radius"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.Radius(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ManipulationPivot_get_Center(py::wrapper::Microsoft::UI::Xaml::Input::ManipulationPivot* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Input.ManipulationPivot", L"Center"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Center());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ManipulationPivot_put_Center(py::wrapper::Microsoft::UI::Xaml::Input::ManipulationPivot* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Input.ManipulationPivot", L"Center"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Point>(arg);

            self->obj.Center(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_ManipulationPivot(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Input::ManipulationPivot>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ManipulationPivot(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Input::ManipulationPivot>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ManipulationPivot[] = {
        { "_assign_array_", _assign_array_ManipulationPivot, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ManipulationPivot), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ManipulationPivot[] = {
        { "radius", reinterpret_cast<getter>(ManipulationPivot_get_Radius), reinterpret_cast<setter>(ManipulationPivot_put_Radius), nullptr, nullptr },
        { "center", reinterpret_cast<getter>(ManipulationPivot_get_Center), reinterpret_cast<setter>(ManipulationPivot_put_Center), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ManipulationPivot[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ManipulationPivot) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ManipulationPivot) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ManipulationPivot) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ManipulationPivot) },
        { },
    };

    static PyType_Spec type_spec_ManipulationPivot =
    {
        "winrt._winrt_microsoft_ui_xaml_input.ManipulationPivot",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Input::ManipulationPivot),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ManipulationPivot
    };

    // ----- ManipulationStartedRoutedEventArgs class --------------------

    static PyObject* _new_ManipulationStartedRoutedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Microsoft::UI::Xaml::Input::ManipulationStartedRoutedEventArgs instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ManipulationStartedRoutedEventArgs(py::wrapper::Microsoft::UI::Xaml::Input::ManipulationStartedRoutedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ManipulationStartedRoutedEventArgs_Complete(py::wrapper::Microsoft::UI::Xaml::Input::ManipulationStartedRoutedEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Input.ManipulationStartedRoutedEventArgs", L"Complete", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Complete();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ManipulationStartedRoutedEventArgs_get_Handled(py::wrapper::Microsoft::UI::Xaml::Input::ManipulationStartedRoutedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Input.ManipulationStartedRoutedEventArgs", L"Handled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Handled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ManipulationStartedRoutedEventArgs_put_Handled(py::wrapper::Microsoft::UI::Xaml::Input::ManipulationStartedRoutedEventArgs* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Input.ManipulationStartedRoutedEventArgs", L"Handled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.Handled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ManipulationStartedRoutedEventArgs_get_Container(py::wrapper::Microsoft::UI::Xaml::Input::ManipulationStartedRoutedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Input.ManipulationStartedRoutedEventArgs", L"Container"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Container());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ManipulationStartedRoutedEventArgs_get_Cumulative(py::wrapper::Microsoft::UI::Xaml::Input::ManipulationStartedRoutedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Input.ManipulationStartedRoutedEventArgs", L"Cumulative"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Cumulative());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ManipulationStartedRoutedEventArgs_get_PointerDeviceType(py::wrapper::Microsoft::UI::Xaml::Input::ManipulationStartedRoutedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Input.ManipulationStartedRoutedEventArgs", L"PointerDeviceType"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PointerDeviceType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ManipulationStartedRoutedEventArgs_get_Position(py::wrapper::Microsoft::UI::Xaml::Input::ManipulationStartedRoutedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Input.ManipulationStartedRoutedEventArgs", L"Position"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Position());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ManipulationStartedRoutedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Input::ManipulationStartedRoutedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ManipulationStartedRoutedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Input::ManipulationStartedRoutedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ManipulationStartedRoutedEventArgs[] = {
        { "complete", reinterpret_cast<PyCFunction>(ManipulationStartedRoutedEventArgs_Complete), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_ManipulationStartedRoutedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ManipulationStartedRoutedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ManipulationStartedRoutedEventArgs[] = {
        { "handled", reinterpret_cast<getter>(ManipulationStartedRoutedEventArgs_get_Handled), reinterpret_cast<setter>(ManipulationStartedRoutedEventArgs_put_Handled), nullptr, nullptr },
        { "container", reinterpret_cast<getter>(ManipulationStartedRoutedEventArgs_get_Container), nullptr, nullptr, nullptr },
        { "cumulative", reinterpret_cast<getter>(ManipulationStartedRoutedEventArgs_get_Cumulative), nullptr, nullptr, nullptr },
        { "pointer_device_type", reinterpret_cast<getter>(ManipulationStartedRoutedEventArgs_get_PointerDeviceType), nullptr, nullptr, nullptr },
        { "position", reinterpret_cast<getter>(ManipulationStartedRoutedEventArgs_get_Position), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ManipulationStartedRoutedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ManipulationStartedRoutedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ManipulationStartedRoutedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ManipulationStartedRoutedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ManipulationStartedRoutedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_ManipulationStartedRoutedEventArgs =
    {
        "winrt._winrt_microsoft_ui_xaml_input.ManipulationStartedRoutedEventArgs",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Input::ManipulationStartedRoutedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ManipulationStartedRoutedEventArgs
    };

    // ----- ManipulationStartingRoutedEventArgs class --------------------

    static PyObject* _new_ManipulationStartingRoutedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Microsoft::UI::Xaml::Input::ManipulationStartingRoutedEventArgs instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ManipulationStartingRoutedEventArgs(py::wrapper::Microsoft::UI::Xaml::Input::ManipulationStartingRoutedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ManipulationStartingRoutedEventArgs_get_Pivot(py::wrapper::Microsoft::UI::Xaml::Input::ManipulationStartingRoutedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Input.ManipulationStartingRoutedEventArgs", L"Pivot"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Pivot());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ManipulationStartingRoutedEventArgs_put_Pivot(py::wrapper::Microsoft::UI::Xaml::Input::ManipulationStartingRoutedEventArgs* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Input.ManipulationStartingRoutedEventArgs", L"Pivot"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Input::ManipulationPivot>(arg);

            self->obj.Pivot(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ManipulationStartingRoutedEventArgs_get_Mode(py::wrapper::Microsoft::UI::Xaml::Input::ManipulationStartingRoutedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Input.ManipulationStartingRoutedEventArgs", L"Mode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Mode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ManipulationStartingRoutedEventArgs_put_Mode(py::wrapper::Microsoft::UI::Xaml::Input::ManipulationStartingRoutedEventArgs* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Input.ManipulationStartingRoutedEventArgs", L"Mode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Input::ManipulationModes>(arg);

            self->obj.Mode(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ManipulationStartingRoutedEventArgs_get_Handled(py::wrapper::Microsoft::UI::Xaml::Input::ManipulationStartingRoutedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Input.ManipulationStartingRoutedEventArgs", L"Handled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Handled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ManipulationStartingRoutedEventArgs_put_Handled(py::wrapper::Microsoft::UI::Xaml::Input::ManipulationStartingRoutedEventArgs* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Input.ManipulationStartingRoutedEventArgs", L"Handled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.Handled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ManipulationStartingRoutedEventArgs_get_Container(py::wrapper::Microsoft::UI::Xaml::Input::ManipulationStartingRoutedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Input.ManipulationStartingRoutedEventArgs", L"Container"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Container());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ManipulationStartingRoutedEventArgs_put_Container(py::wrapper::Microsoft::UI::Xaml::Input::ManipulationStartingRoutedEventArgs* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Input.ManipulationStartingRoutedEventArgs", L"Container"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::UIElement>(arg);

            self->obj.Container(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_ManipulationStartingRoutedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Input::ManipulationStartingRoutedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ManipulationStartingRoutedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Input::ManipulationStartingRoutedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ManipulationStartingRoutedEventArgs[] = {
        { "_assign_array_", _assign_array_ManipulationStartingRoutedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ManipulationStartingRoutedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ManipulationStartingRoutedEventArgs[] = {
        { "pivot", reinterpret_cast<getter>(ManipulationStartingRoutedEventArgs_get_Pivot), reinterpret_cast<setter>(ManipulationStartingRoutedEventArgs_put_Pivot), nullptr, nullptr },
        { "mode", reinterpret_cast<getter>(ManipulationStartingRoutedEventArgs_get_Mode), reinterpret_cast<setter>(ManipulationStartingRoutedEventArgs_put_Mode), nullptr, nullptr },
        { "handled", reinterpret_cast<getter>(ManipulationStartingRoutedEventArgs_get_Handled), reinterpret_cast<setter>(ManipulationStartingRoutedEventArgs_put_Handled), nullptr, nullptr },
        { "container", reinterpret_cast<getter>(ManipulationStartingRoutedEventArgs_get_Container), reinterpret_cast<setter>(ManipulationStartingRoutedEventArgs_put_Container), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ManipulationStartingRoutedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ManipulationStartingRoutedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ManipulationStartingRoutedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ManipulationStartingRoutedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ManipulationStartingRoutedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_ManipulationStartingRoutedEventArgs =
    {
        "winrt._winrt_microsoft_ui_xaml_input.ManipulationStartingRoutedEventArgs",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Input::ManipulationStartingRoutedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ManipulationStartingRoutedEventArgs
    };

    // ----- NoFocusCandidateFoundEventArgs class --------------------

    static PyObject* _new_NoFocusCandidateFoundEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Xaml::Input::NoFocusCandidateFoundEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Xaml::Input::NoFocusCandidateFoundEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_NoFocusCandidateFoundEventArgs(py::wrapper::Microsoft::UI::Xaml::Input::NoFocusCandidateFoundEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* NoFocusCandidateFoundEventArgs_get_Handled(py::wrapper::Microsoft::UI::Xaml::Input::NoFocusCandidateFoundEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Input.NoFocusCandidateFoundEventArgs", L"Handled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Handled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int NoFocusCandidateFoundEventArgs_put_Handled(py::wrapper::Microsoft::UI::Xaml::Input::NoFocusCandidateFoundEventArgs* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Input.NoFocusCandidateFoundEventArgs", L"Handled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.Handled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* NoFocusCandidateFoundEventArgs_get_Direction(py::wrapper::Microsoft::UI::Xaml::Input::NoFocusCandidateFoundEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Input.NoFocusCandidateFoundEventArgs", L"Direction"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Direction());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NoFocusCandidateFoundEventArgs_get_InputDevice(py::wrapper::Microsoft::UI::Xaml::Input::NoFocusCandidateFoundEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Input.NoFocusCandidateFoundEventArgs", L"InputDevice"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.InputDevice());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_NoFocusCandidateFoundEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Input::NoFocusCandidateFoundEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_NoFocusCandidateFoundEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Input::NoFocusCandidateFoundEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_NoFocusCandidateFoundEventArgs[] = {
        { "_assign_array_", _assign_array_NoFocusCandidateFoundEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_NoFocusCandidateFoundEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_NoFocusCandidateFoundEventArgs[] = {
        { "handled", reinterpret_cast<getter>(NoFocusCandidateFoundEventArgs_get_Handled), reinterpret_cast<setter>(NoFocusCandidateFoundEventArgs_put_Handled), nullptr, nullptr },
        { "direction", reinterpret_cast<getter>(NoFocusCandidateFoundEventArgs_get_Direction), nullptr, nullptr, nullptr },
        { "input_device", reinterpret_cast<getter>(NoFocusCandidateFoundEventArgs_get_InputDevice), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_NoFocusCandidateFoundEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_NoFocusCandidateFoundEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_NoFocusCandidateFoundEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_NoFocusCandidateFoundEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_NoFocusCandidateFoundEventArgs) },
        { },
    };

    static PyType_Spec type_spec_NoFocusCandidateFoundEventArgs =
    {
        "winrt._winrt_microsoft_ui_xaml_input.NoFocusCandidateFoundEventArgs",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Input::NoFocusCandidateFoundEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_NoFocusCandidateFoundEventArgs
    };

    // ----- Pointer class --------------------

    static PyObject* _new_Pointer(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Xaml::Input::Pointer>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Xaml::Input::Pointer>::type_name);
        return nullptr;
    }

    static void _dealloc_Pointer(py::wrapper::Microsoft::UI::Xaml::Input::Pointer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* Pointer_get_IsInContact(py::wrapper::Microsoft::UI::Xaml::Input::Pointer* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Input.Pointer", L"IsInContact"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsInContact());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Pointer_get_IsInRange(py::wrapper::Microsoft::UI::Xaml::Input::Pointer* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Input.Pointer", L"IsInRange"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsInRange());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Pointer_get_PointerDeviceType(py::wrapper::Microsoft::UI::Xaml::Input::Pointer* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Input.Pointer", L"PointerDeviceType"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PointerDeviceType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Pointer_get_PointerId(py::wrapper::Microsoft::UI::Xaml::Input::Pointer* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Input.Pointer", L"PointerId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PointerId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_Pointer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Input::Pointer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_Pointer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Input::Pointer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_Pointer[] = {
        { "_assign_array_", _assign_array_Pointer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_Pointer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_Pointer[] = {
        { "is_in_contact", reinterpret_cast<getter>(Pointer_get_IsInContact), nullptr, nullptr, nullptr },
        { "is_in_range", reinterpret_cast<getter>(Pointer_get_IsInRange), nullptr, nullptr, nullptr },
        { "pointer_device_type", reinterpret_cast<getter>(Pointer_get_PointerDeviceType), nullptr, nullptr, nullptr },
        { "pointer_id", reinterpret_cast<getter>(Pointer_get_PointerId), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_Pointer[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_Pointer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_Pointer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_Pointer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_Pointer) },
        { },
    };

    static PyType_Spec type_spec_Pointer =
    {
        "winrt._winrt_microsoft_ui_xaml_input.Pointer",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Input::Pointer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_Pointer
    };

    // ----- PointerRoutedEventArgs class --------------------

    static PyObject* _new_PointerRoutedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Xaml::Input::PointerRoutedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Xaml::Input::PointerRoutedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_PointerRoutedEventArgs(py::wrapper::Microsoft::UI::Xaml::Input::PointerRoutedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PointerRoutedEventArgs_GetCurrentPoint(py::wrapper::Microsoft::UI::Xaml::Input::PointerRoutedEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Input.PointerRoutedEventArgs", L"GetCurrentPoint", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::UIElement>(args, 0);

                return py::convert(self->obj.GetCurrentPoint(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PointerRoutedEventArgs_GetIntermediatePoints(py::wrapper::Microsoft::UI::Xaml::Input::PointerRoutedEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Input.PointerRoutedEventArgs", L"GetIntermediatePoints", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::UIElement>(args, 0);

                return py::convert(self->obj.GetIntermediatePoints(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PointerRoutedEventArgs_get_Handled(py::wrapper::Microsoft::UI::Xaml::Input::PointerRoutedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Input.PointerRoutedEventArgs", L"Handled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Handled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PointerRoutedEventArgs_put_Handled(py::wrapper::Microsoft::UI::Xaml::Input::PointerRoutedEventArgs* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Input.PointerRoutedEventArgs", L"Handled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.Handled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PointerRoutedEventArgs_get_IsGenerated(py::wrapper::Microsoft::UI::Xaml::Input::PointerRoutedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Input.PointerRoutedEventArgs", L"IsGenerated"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsGenerated());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PointerRoutedEventArgs_get_KeyModifiers(py::wrapper::Microsoft::UI::Xaml::Input::PointerRoutedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Input.PointerRoutedEventArgs", L"KeyModifiers"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.KeyModifiers());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PointerRoutedEventArgs_get_Pointer(py::wrapper::Microsoft::UI::Xaml::Input::PointerRoutedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Input.PointerRoutedEventArgs", L"Pointer"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Pointer());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PointerRoutedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Input::PointerRoutedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PointerRoutedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Input::PointerRoutedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PointerRoutedEventArgs[] = {
        { "get_current_point", reinterpret_cast<PyCFunction>(PointerRoutedEventArgs_GetCurrentPoint), METH_VARARGS, nullptr },
        { "get_intermediate_points", reinterpret_cast<PyCFunction>(PointerRoutedEventArgs_GetIntermediatePoints), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_PointerRoutedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PointerRoutedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PointerRoutedEventArgs[] = {
        { "handled", reinterpret_cast<getter>(PointerRoutedEventArgs_get_Handled), reinterpret_cast<setter>(PointerRoutedEventArgs_put_Handled), nullptr, nullptr },
        { "is_generated", reinterpret_cast<getter>(PointerRoutedEventArgs_get_IsGenerated), nullptr, nullptr, nullptr },
        { "key_modifiers", reinterpret_cast<getter>(PointerRoutedEventArgs_get_KeyModifiers), nullptr, nullptr, nullptr },
        { "pointer", reinterpret_cast<getter>(PointerRoutedEventArgs_get_Pointer), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PointerRoutedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PointerRoutedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PointerRoutedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PointerRoutedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PointerRoutedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_PointerRoutedEventArgs =
    {
        "winrt._winrt_microsoft_ui_xaml_input.PointerRoutedEventArgs",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Input::PointerRoutedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PointerRoutedEventArgs
    };

    // ----- ProcessKeyboardAcceleratorEventArgs class --------------------

    static PyObject* _new_ProcessKeyboardAcceleratorEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Xaml::Input::ProcessKeyboardAcceleratorEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Xaml::Input::ProcessKeyboardAcceleratorEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_ProcessKeyboardAcceleratorEventArgs(py::wrapper::Microsoft::UI::Xaml::Input::ProcessKeyboardAcceleratorEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ProcessKeyboardAcceleratorEventArgs_get_Handled(py::wrapper::Microsoft::UI::Xaml::Input::ProcessKeyboardAcceleratorEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Input.ProcessKeyboardAcceleratorEventArgs", L"Handled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Handled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ProcessKeyboardAcceleratorEventArgs_put_Handled(py::wrapper::Microsoft::UI::Xaml::Input::ProcessKeyboardAcceleratorEventArgs* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Input.ProcessKeyboardAcceleratorEventArgs", L"Handled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.Handled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ProcessKeyboardAcceleratorEventArgs_get_Key(py::wrapper::Microsoft::UI::Xaml::Input::ProcessKeyboardAcceleratorEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Input.ProcessKeyboardAcceleratorEventArgs", L"Key"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Key());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ProcessKeyboardAcceleratorEventArgs_get_Modifiers(py::wrapper::Microsoft::UI::Xaml::Input::ProcessKeyboardAcceleratorEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Input.ProcessKeyboardAcceleratorEventArgs", L"Modifiers"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Modifiers());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ProcessKeyboardAcceleratorEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Input::ProcessKeyboardAcceleratorEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ProcessKeyboardAcceleratorEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Input::ProcessKeyboardAcceleratorEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ProcessKeyboardAcceleratorEventArgs[] = {
        { "_assign_array_", _assign_array_ProcessKeyboardAcceleratorEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ProcessKeyboardAcceleratorEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ProcessKeyboardAcceleratorEventArgs[] = {
        { "handled", reinterpret_cast<getter>(ProcessKeyboardAcceleratorEventArgs_get_Handled), reinterpret_cast<setter>(ProcessKeyboardAcceleratorEventArgs_put_Handled), nullptr, nullptr },
        { "key", reinterpret_cast<getter>(ProcessKeyboardAcceleratorEventArgs_get_Key), nullptr, nullptr, nullptr },
        { "modifiers", reinterpret_cast<getter>(ProcessKeyboardAcceleratorEventArgs_get_Modifiers), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ProcessKeyboardAcceleratorEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ProcessKeyboardAcceleratorEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ProcessKeyboardAcceleratorEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ProcessKeyboardAcceleratorEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ProcessKeyboardAcceleratorEventArgs) },
        { },
    };

    static PyType_Spec type_spec_ProcessKeyboardAcceleratorEventArgs =
    {
        "winrt._winrt_microsoft_ui_xaml_input.ProcessKeyboardAcceleratorEventArgs",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Input::ProcessKeyboardAcceleratorEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ProcessKeyboardAcceleratorEventArgs
    };

    // ----- RightTappedRoutedEventArgs class --------------------

    static PyObject* _new_RightTappedRoutedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Microsoft::UI::Xaml::Input::RightTappedRoutedEventArgs instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_RightTappedRoutedEventArgs(py::wrapper::Microsoft::UI::Xaml::Input::RightTappedRoutedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* RightTappedRoutedEventArgs_GetPosition(py::wrapper::Microsoft::UI::Xaml::Input::RightTappedRoutedEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Input.RightTappedRoutedEventArgs", L"GetPosition", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::UIElement>(args, 0);

                return py::convert(self->obj.GetPosition(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RightTappedRoutedEventArgs_get_Handled(py::wrapper::Microsoft::UI::Xaml::Input::RightTappedRoutedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Input.RightTappedRoutedEventArgs", L"Handled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Handled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int RightTappedRoutedEventArgs_put_Handled(py::wrapper::Microsoft::UI::Xaml::Input::RightTappedRoutedEventArgs* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Input.RightTappedRoutedEventArgs", L"Handled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.Handled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* RightTappedRoutedEventArgs_get_PointerDeviceType(py::wrapper::Microsoft::UI::Xaml::Input::RightTappedRoutedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Input.RightTappedRoutedEventArgs", L"PointerDeviceType"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PointerDeviceType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_RightTappedRoutedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Input::RightTappedRoutedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_RightTappedRoutedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Input::RightTappedRoutedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_RightTappedRoutedEventArgs[] = {
        { "get_position", reinterpret_cast<PyCFunction>(RightTappedRoutedEventArgs_GetPosition), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_RightTappedRoutedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_RightTappedRoutedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_RightTappedRoutedEventArgs[] = {
        { "handled", reinterpret_cast<getter>(RightTappedRoutedEventArgs_get_Handled), reinterpret_cast<setter>(RightTappedRoutedEventArgs_put_Handled), nullptr, nullptr },
        { "pointer_device_type", reinterpret_cast<getter>(RightTappedRoutedEventArgs_get_PointerDeviceType), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_RightTappedRoutedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_RightTappedRoutedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_RightTappedRoutedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_RightTappedRoutedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_RightTappedRoutedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_RightTappedRoutedEventArgs =
    {
        "winrt._winrt_microsoft_ui_xaml_input.RightTappedRoutedEventArgs",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Input::RightTappedRoutedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_RightTappedRoutedEventArgs
    };

    // ----- StandardUICommand class --------------------

    static PyObject* _new_StandardUICommand(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Microsoft::UI::Xaml::Input::StandardUICommand instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Input::StandardUICommandKind>(args, 0);

                winrt::Microsoft::UI::Xaml::Input::StandardUICommand instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_StandardUICommand(py::wrapper::Microsoft::UI::Xaml::Input::StandardUICommand* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* StandardUICommand_get_Kind(py::wrapper::Microsoft::UI::Xaml::Input::StandardUICommand* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Input.StandardUICommand", L"Kind"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StandardUICommand_put_Kind(py::wrapper::Microsoft::UI::Xaml::Input::StandardUICommand* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Input.StandardUICommand", L"Kind"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Input::StandardUICommandKind>(arg);

            self->obj.Kind(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StandardUICommand_get_KindProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Input.StandardUICommand", L"KindProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Input::StandardUICommand::KindProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_StandardUICommand(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Input::StandardUICommand>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_StandardUICommand(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Input::StandardUICommand>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StandardUICommand[] = {
        { "_assign_array_", _assign_array_StandardUICommand, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_StandardUICommand), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_StandardUICommand[] = {
        { "kind", reinterpret_cast<getter>(StandardUICommand_get_Kind), reinterpret_cast<setter>(StandardUICommand_put_Kind), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_StandardUICommand[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_StandardUICommand) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_StandardUICommand) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_StandardUICommand) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_StandardUICommand) },
        { },
    };

    static PyType_Spec type_spec_StandardUICommand =
    {
        "winrt._winrt_microsoft_ui_xaml_input.StandardUICommand",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Input::StandardUICommand),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StandardUICommand
    };

    static PyGetSetDef getset_StandardUICommand_Static[] = {
        { "kind_property", reinterpret_cast<getter>(StandardUICommand_get_KindProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_StandardUICommand_Static[] = {
        { }
    };

    static PyType_Slot type_slots_StandardUICommand_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_StandardUICommand_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_StandardUICommand_Static) },
        { }
    };

    static PyType_Spec type_spec_StandardUICommand_Static =
    {
        "winrt._winrt_microsoft_ui_xaml_input.StandardUICommand_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_StandardUICommand_Static
    };

    // ----- TappedRoutedEventArgs class --------------------

    static PyObject* _new_TappedRoutedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Microsoft::UI::Xaml::Input::TappedRoutedEventArgs instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_TappedRoutedEventArgs(py::wrapper::Microsoft::UI::Xaml::Input::TappedRoutedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* TappedRoutedEventArgs_GetPosition(py::wrapper::Microsoft::UI::Xaml::Input::TappedRoutedEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Input.TappedRoutedEventArgs", L"GetPosition", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::UIElement>(args, 0);

                return py::convert(self->obj.GetPosition(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TappedRoutedEventArgs_get_Handled(py::wrapper::Microsoft::UI::Xaml::Input::TappedRoutedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Input.TappedRoutedEventArgs", L"Handled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Handled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TappedRoutedEventArgs_put_Handled(py::wrapper::Microsoft::UI::Xaml::Input::TappedRoutedEventArgs* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Input.TappedRoutedEventArgs", L"Handled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.Handled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TappedRoutedEventArgs_get_PointerDeviceType(py::wrapper::Microsoft::UI::Xaml::Input::TappedRoutedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Input.TappedRoutedEventArgs", L"PointerDeviceType"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PointerDeviceType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_TappedRoutedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Input::TappedRoutedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_TappedRoutedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Input::TappedRoutedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_TappedRoutedEventArgs[] = {
        { "get_position", reinterpret_cast<PyCFunction>(TappedRoutedEventArgs_GetPosition), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_TappedRoutedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_TappedRoutedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_TappedRoutedEventArgs[] = {
        { "handled", reinterpret_cast<getter>(TappedRoutedEventArgs_get_Handled), reinterpret_cast<setter>(TappedRoutedEventArgs_put_Handled), nullptr, nullptr },
        { "pointer_device_type", reinterpret_cast<getter>(TappedRoutedEventArgs_get_PointerDeviceType), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_TappedRoutedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_TappedRoutedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_TappedRoutedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_TappedRoutedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_TappedRoutedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_TappedRoutedEventArgs =
    {
        "winrt._winrt_microsoft_ui_xaml_input.TappedRoutedEventArgs",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Input::TappedRoutedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TappedRoutedEventArgs
    };

    // ----- XamlUICommand class --------------------

    static PyObject* _new_XamlUICommand(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Microsoft::UI::Xaml::Input::XamlUICommand instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_XamlUICommand(py::wrapper::Microsoft::UI::Xaml::Input::XamlUICommand* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* XamlUICommand_CanExecute(py::wrapper::Microsoft::UI::Xaml::Input::XamlUICommand* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Input.XamlUICommand", L"CanExecute", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 0);

                return py::convert(self->obj.CanExecute(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* XamlUICommand_Execute(py::wrapper::Microsoft::UI::Xaml::Input::XamlUICommand* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Input.XamlUICommand", L"Execute", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 0);

                self->obj.Execute(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* XamlUICommand_NotifyCanExecuteChanged(py::wrapper::Microsoft::UI::Xaml::Input::XamlUICommand* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Input.XamlUICommand", L"NotifyCanExecuteChanged", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.NotifyCanExecuteChanged();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* XamlUICommand_get_Label(py::wrapper::Microsoft::UI::Xaml::Input::XamlUICommand* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Input.XamlUICommand", L"Label"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Label());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int XamlUICommand_put_Label(py::wrapper::Microsoft::UI::Xaml::Input::XamlUICommand* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Input.XamlUICommand", L"Label"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Label(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* XamlUICommand_get_IconSource(py::wrapper::Microsoft::UI::Xaml::Input::XamlUICommand* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Input.XamlUICommand", L"IconSource"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IconSource());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int XamlUICommand_put_IconSource(py::wrapper::Microsoft::UI::Xaml::Input::XamlUICommand* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Input.XamlUICommand", L"IconSource"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::IconSource>(arg);

            self->obj.IconSource(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* XamlUICommand_get_Description(py::wrapper::Microsoft::UI::Xaml::Input::XamlUICommand* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Input.XamlUICommand", L"Description"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Description());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int XamlUICommand_put_Description(py::wrapper::Microsoft::UI::Xaml::Input::XamlUICommand* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Input.XamlUICommand", L"Description"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Description(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* XamlUICommand_get_Command(py::wrapper::Microsoft::UI::Xaml::Input::XamlUICommand* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Input.XamlUICommand", L"Command"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Command());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int XamlUICommand_put_Command(py::wrapper::Microsoft::UI::Xaml::Input::XamlUICommand* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Input.XamlUICommand", L"Command"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Input::ICommand>(arg);

            self->obj.Command(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* XamlUICommand_get_AccessKey(py::wrapper::Microsoft::UI::Xaml::Input::XamlUICommand* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Input.XamlUICommand", L"AccessKey"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AccessKey());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int XamlUICommand_put_AccessKey(py::wrapper::Microsoft::UI::Xaml::Input::XamlUICommand* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Input.XamlUICommand", L"AccessKey"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.AccessKey(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* XamlUICommand_get_KeyboardAccelerators(py::wrapper::Microsoft::UI::Xaml::Input::XamlUICommand* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Input.XamlUICommand", L"KeyboardAccelerators"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.KeyboardAccelerators());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* XamlUICommand_get_AccessKeyProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Input.XamlUICommand", L"AccessKeyProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Input::XamlUICommand::AccessKeyProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* XamlUICommand_get_CommandProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Input.XamlUICommand", L"CommandProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Input::XamlUICommand::CommandProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* XamlUICommand_get_DescriptionProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Input.XamlUICommand", L"DescriptionProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Input::XamlUICommand::DescriptionProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* XamlUICommand_get_IconSourceProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Input.XamlUICommand", L"IconSourceProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Input::XamlUICommand::IconSourceProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* XamlUICommand_get_KeyboardAcceleratorsProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Input.XamlUICommand", L"KeyboardAcceleratorsProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Input::XamlUICommand::KeyboardAcceleratorsProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* XamlUICommand_get_LabelProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Input.XamlUICommand", L"LabelProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Input::XamlUICommand::LabelProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* XamlUICommand_add_CanExecuteRequested(py::wrapper::Microsoft::UI::Xaml::Input::XamlUICommand* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Input.XamlUICommand", L"CanExecuteRequested"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Xaml::Input::XamlUICommand, winrt::Microsoft::UI::Xaml::Input::CanExecuteRequestedEventArgs>>(arg);

            return py::convert(self->obj.CanExecuteRequested(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* XamlUICommand_remove_CanExecuteRequested(py::wrapper::Microsoft::UI::Xaml::Input::XamlUICommand* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Input.XamlUICommand", L"CanExecuteRequested"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.CanExecuteRequested(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* XamlUICommand_add_ExecuteRequested(py::wrapper::Microsoft::UI::Xaml::Input::XamlUICommand* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Input.XamlUICommand", L"ExecuteRequested"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Xaml::Input::XamlUICommand, winrt::Microsoft::UI::Xaml::Input::ExecuteRequestedEventArgs>>(arg);

            return py::convert(self->obj.ExecuteRequested(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* XamlUICommand_remove_ExecuteRequested(py::wrapper::Microsoft::UI::Xaml::Input::XamlUICommand* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Input.XamlUICommand", L"ExecuteRequested"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ExecuteRequested(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* XamlUICommand_add_CanExecuteChanged(py::wrapper::Microsoft::UI::Xaml::Input::XamlUICommand* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Input.XamlUICommand", L"CanExecuteChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::EventHandler<winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.CanExecuteChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* XamlUICommand_remove_CanExecuteChanged(py::wrapper::Microsoft::UI::Xaml::Input::XamlUICommand* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Input.XamlUICommand", L"CanExecuteChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.CanExecuteChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_XamlUICommand(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Input::XamlUICommand>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_XamlUICommand(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Input::XamlUICommand>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_XamlUICommand[] = {
        { "can_execute", reinterpret_cast<PyCFunction>(XamlUICommand_CanExecute), METH_VARARGS, nullptr },
        { "execute", reinterpret_cast<PyCFunction>(XamlUICommand_Execute), METH_VARARGS, nullptr },
        { "notify_can_execute_changed", reinterpret_cast<PyCFunction>(XamlUICommand_NotifyCanExecuteChanged), METH_VARARGS, nullptr },
        { "add_can_execute_requested", reinterpret_cast<PyCFunction>(XamlUICommand_add_CanExecuteRequested), METH_O, nullptr },
        { "remove_can_execute_requested", reinterpret_cast<PyCFunction>(XamlUICommand_remove_CanExecuteRequested), METH_O, nullptr },
        { "add_execute_requested", reinterpret_cast<PyCFunction>(XamlUICommand_add_ExecuteRequested), METH_O, nullptr },
        { "remove_execute_requested", reinterpret_cast<PyCFunction>(XamlUICommand_remove_ExecuteRequested), METH_O, nullptr },
        { "add_can_execute_changed", reinterpret_cast<PyCFunction>(XamlUICommand_add_CanExecuteChanged), METH_O, nullptr },
        { "remove_can_execute_changed", reinterpret_cast<PyCFunction>(XamlUICommand_remove_CanExecuteChanged), METH_O, nullptr },
        { "_assign_array_", _assign_array_XamlUICommand, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_XamlUICommand), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_XamlUICommand[] = {
        { "label", reinterpret_cast<getter>(XamlUICommand_get_Label), reinterpret_cast<setter>(XamlUICommand_put_Label), nullptr, nullptr },
        { "icon_source", reinterpret_cast<getter>(XamlUICommand_get_IconSource), reinterpret_cast<setter>(XamlUICommand_put_IconSource), nullptr, nullptr },
        { "description", reinterpret_cast<getter>(XamlUICommand_get_Description), reinterpret_cast<setter>(XamlUICommand_put_Description), nullptr, nullptr },
        { "command", reinterpret_cast<getter>(XamlUICommand_get_Command), reinterpret_cast<setter>(XamlUICommand_put_Command), nullptr, nullptr },
        { "access_key", reinterpret_cast<getter>(XamlUICommand_get_AccessKey), reinterpret_cast<setter>(XamlUICommand_put_AccessKey), nullptr, nullptr },
        { "keyboard_accelerators", reinterpret_cast<getter>(XamlUICommand_get_KeyboardAccelerators), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_XamlUICommand[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_XamlUICommand) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_XamlUICommand) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_XamlUICommand) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_XamlUICommand) },
        { },
    };

    static PyType_Spec type_spec_XamlUICommand =
    {
        "winrt._winrt_microsoft_ui_xaml_input.XamlUICommand",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Input::XamlUICommand),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_XamlUICommand
    };

    static PyGetSetDef getset_XamlUICommand_Static[] = {
        { "access_key_property", reinterpret_cast<getter>(XamlUICommand_get_AccessKeyProperty), nullptr, nullptr, nullptr },
        { "command_property", reinterpret_cast<getter>(XamlUICommand_get_CommandProperty), nullptr, nullptr, nullptr },
        { "description_property", reinterpret_cast<getter>(XamlUICommand_get_DescriptionProperty), nullptr, nullptr, nullptr },
        { "icon_source_property", reinterpret_cast<getter>(XamlUICommand_get_IconSourceProperty), nullptr, nullptr, nullptr },
        { "keyboard_accelerators_property", reinterpret_cast<getter>(XamlUICommand_get_KeyboardAcceleratorsProperty), nullptr, nullptr, nullptr },
        { "label_property", reinterpret_cast<getter>(XamlUICommand_get_LabelProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_XamlUICommand_Static[] = {
        { }
    };

    static PyType_Slot type_slots_XamlUICommand_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_XamlUICommand_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_XamlUICommand_Static) },
        { }
    };

    static PyType_Spec type_spec_XamlUICommand_Static =
    {
        "winrt._winrt_microsoft_ui_xaml_input.XamlUICommand_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_XamlUICommand_Static
    };

    // ----- ICommand interface --------------------

    static PyObject* _new_ICommand(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Xaml::Input::ICommand>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Xaml::Input::ICommand>::type_name);
        return nullptr;
    }

    static void _dealloc_ICommand(py::wrapper::Microsoft::UI::Xaml::Input::ICommand* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ICommand_CanExecute(py::wrapper::Microsoft::UI::Xaml::Input::ICommand* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Input.ICommand", L"CanExecute", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 0);

                return py::convert(self->obj.CanExecute(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ICommand_Execute(py::wrapper::Microsoft::UI::Xaml::Input::ICommand* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Input.ICommand", L"Execute", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 0);

                self->obj.Execute(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ICommand_add_CanExecuteChanged(py::wrapper::Microsoft::UI::Xaml::Input::ICommand* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Input.ICommand", L"CanExecuteChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::EventHandler<winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.CanExecuteChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICommand_remove_CanExecuteChanged(py::wrapper::Microsoft::UI::Xaml::Input::ICommand* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Input.ICommand", L"CanExecuteChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.CanExecuteChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ICommand(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Input::ICommand>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ICommand(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Input::ICommand>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ICommand[] = {
        { "can_execute", reinterpret_cast<PyCFunction>(ICommand_CanExecute), METH_VARARGS, nullptr },
        { "execute", reinterpret_cast<PyCFunction>(ICommand_Execute), METH_VARARGS, nullptr },
        { "add_can_execute_changed", reinterpret_cast<PyCFunction>(ICommand_add_CanExecuteChanged), METH_O, nullptr },
        { "remove_can_execute_changed", reinterpret_cast<PyCFunction>(ICommand_remove_CanExecuteChanged), METH_O, nullptr },
        { "_assign_array_", _assign_array_ICommand, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ICommand), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ICommand[] = {
        { }
    };

    static PyType_Slot _type_slots_ICommand[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ICommand) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ICommand) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ICommand) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ICommand) },
        { },
    };

    static PyType_Spec type_spec_ICommand =
    {
        "winrt._winrt_microsoft_ui_xaml_input.ICommand",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Input::ICommand),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ICommand
    };

    // ----- Microsoft.UI.Xaml.Input Initialization --------------------
    PyDoc_STRVAR(module_doc, "Microsoft::UI::Xaml::Input");


    static PyModuleDef module_def
        = {PyModuleDef_HEAD_INIT,
           "_winrt_microsoft_ui_xaml_input",
           module_doc,
           0,
           nullptr,
           nullptr,
           nullptr,
           nullptr,
           nullptr};

} // py::cpp::Microsoft::UI::Xaml::Input

PyMODINIT_FUNC PyInit__winrt_microsoft_ui_xaml_input(void) noexcept
{
    using namespace py::cpp::Microsoft::UI::Xaml::Input;

    if (py::import_winrt_runtime() == -1)
    {
        return nullptr;
    }

    py::pyobj_handle module{PyModule_Create(&module_def)};

    if (!module)
    {
        return nullptr;
    }

    auto object_type = py::get_object_type();
    if (!object_type)
    {
        return nullptr;
    }

    py::pyobj_handle object_bases{PyTuple_Pack(1, object_type)};

    if (!object_bases)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_AccessKeyDisplayDismissedEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_AccessKeyDisplayRequestedEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_AccessKeyInvokedEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_AccessKeyManager_Static{PyType_FromSpec(&type_spec_AccessKeyManager_Static)};
    if (!type_AccessKeyManager_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_AccessKeyManager, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_AccessKeyManager_Static.get())) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_CanExecuteRequestedEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_CharacterReceivedRoutedEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ContextRequestedEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_DoubleTappedRoutedEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ExecuteRequestedEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_FindNextElementOptions, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_FocusManager_Static{PyType_FromSpec(&type_spec_FocusManager_Static)};
    if (!type_FocusManager_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_FocusManager, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_FocusManager_Static.get())) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_FocusManagerGotFocusEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_FocusManagerLostFocusEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_FocusMovementResult, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_GettingFocusEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_HoldingRoutedEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_InertiaExpansionBehavior, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_InertiaRotationBehavior, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_InertiaTranslationBehavior, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_InputScope, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_InputScopeName, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_KeyRoutedEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_KeyboardAccelerator_Static{PyType_FromSpec(&type_spec_KeyboardAccelerator_Static)};
    if (!type_KeyboardAccelerator_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_KeyboardAccelerator, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_KeyboardAccelerator_Static.get())) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_KeyboardAcceleratorInvokedEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_LosingFocusEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ManipulationCompletedRoutedEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ManipulationDeltaRoutedEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ManipulationInertiaStartingRoutedEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ManipulationPivot, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ManipulationStartedRoutedEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ManipulationStartingRoutedEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_NoFocusCandidateFoundEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_Pointer, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_PointerRoutedEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ProcessKeyboardAcceleratorEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_RightTappedRoutedEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_StandardUICommand_Static{PyType_FromSpec(&type_spec_StandardUICommand_Static)};
    if (!type_StandardUICommand_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_StandardUICommand, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_StandardUICommand_Static.get())) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_TappedRoutedEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_XamlUICommand_Static{PyType_FromSpec(&type_spec_XamlUICommand_Static)};
    if (!type_XamlUICommand_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_XamlUICommand, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_XamlUICommand_Static.get())) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ICommand, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }


    return module.detach();
}
