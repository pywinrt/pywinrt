# WARNING: Please don't edit this file. It was generated by Python/WinRT v2.3.0

import datetime
import sys
import types
import typing
import uuid as _uuid
from builtins import property as _property

import winrt._winrt
import winrt.system
import winrt.microsoft.ui.dispatching as microsoft_ui_dispatching
import winrt.microsoft.ui.input as microsoft_ui_input
import winrt.microsoft.ui.xaml as microsoft_ui_xaml
import winrt.microsoft.ui.xaml.controls as microsoft_ui_xaml_controls
import winrt.windows.foundation as windows_foundation
import winrt.windows.foundation.collections as windows_foundation_collections
import winrt.windows.system as windows_system
import winrt.windows.ui.core as windows_ui_core

from winrt.microsoft.ui.xaml.input import FocusInputDeviceKind, FocusNavigationDirection, InputScopeNameValue, KeyTipPlacementMode, KeyboardAcceleratorPlacementMode, KeyboardNavigationMode, ManipulationModes, StandardUICommandKind, XYFocusKeyboardNavigationMode, XYFocusNavigationStrategy, XYFocusNavigationStrategyOverride
from winrt.microsoft.ui.xaml.input import DoubleTappedEventHandler, HoldingEventHandler, KeyEventHandler, ManipulationCompletedEventHandler, ManipulationDeltaEventHandler, ManipulationInertiaStartingEventHandler, ManipulationStartedEventHandler, ManipulationStartingEventHandler, PointerEventHandler, RightTappedEventHandler, TappedEventHandler

Self = typing.TypeVar('Self')

@typing.final
class AccessKeyDisplayDismissedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> AccessKeyDisplayDismissedEventArgs: ...
    def __new__(cls: typing.Type[AccessKeyDisplayDismissedEventArgs]) -> AccessKeyDisplayDismissedEventArgs: ...

@typing.final
class AccessKeyDisplayRequestedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> AccessKeyDisplayRequestedEventArgs: ...
    def __new__(cls: typing.Type[AccessKeyDisplayRequestedEventArgs]) -> AccessKeyDisplayRequestedEventArgs: ...
    @_property
    def pressed_keys(self) -> str: ...

@typing.final
class AccessKeyInvokedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> AccessKeyInvokedEventArgs: ...
    def __new__(cls: typing.Type[AccessKeyInvokedEventArgs]) -> AccessKeyInvokedEventArgs: ...
    @_property
    def handled(self) -> bool: ...
    @handled.setter
    def handled(self, value: bool) -> None: ...

@typing.final
class AccessKeyManager_Static(type):
    def enter_display_mode(cls, xaml_root: typing.Optional[microsoft_ui_xaml.XamlRoot], /) -> None: ...
    def exit_display_mode(cls) -> None: ...
    def add_is_display_mode_enabled_changed(cls, handler: windows_foundation.TypedEventHandler[winrt.system.Object, winrt.system.Object], /) -> windows_foundation.EventRegistrationToken: ...
    def remove_is_display_mode_enabled_changed(cls, token: windows_foundation.EventRegistrationToken, /) -> None: ...
    @_property
    def are_key_tips_enabled(cls) -> bool: ...
    @are_key_tips_enabled.setter
    def are_key_tips_enabled(cls, value: bool) -> None: ...
    @_property
    def is_display_mode_enabled(cls) -> bool: ...

@typing.final
class AccessKeyManager(winrt.system.Object, metaclass=AccessKeyManager_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> AccessKeyManager: ...

@typing.final
class CanExecuteRequestedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> CanExecuteRequestedEventArgs: ...
    @_property
    def can_execute(self) -> bool: ...
    @can_execute.setter
    def can_execute(self, value: bool) -> None: ...
    @_property
    def parameter(self) -> typing.Optional[winrt.system.Object]: ...

@typing.final
class CharacterReceivedRoutedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> CharacterReceivedRoutedEventArgs: ...
    @_property
    def handled(self) -> bool: ...
    @handled.setter
    def handled(self, value: bool) -> None: ...
    @_property
    def character(self) -> winrt.system.Char16: ...
    @_property
    def key_status(self) -> windows_ui_core.CorePhysicalKeyStatus: ...
    @_property
    def original_source(self) -> typing.Optional[winrt.system.Object]: ...

@typing.final
class ContextRequestedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ContextRequestedEventArgs: ...
    def __new__(cls: typing.Type[ContextRequestedEventArgs]) -> ContextRequestedEventArgs: ...
    def try_get_position(self, relative_to: typing.Optional[microsoft_ui_xaml.UIElement], /) -> typing.Tuple[bool, windows_foundation.Point]: ...
    @_property
    def handled(self) -> bool: ...
    @handled.setter
    def handled(self, value: bool) -> None: ...
    @_property
    def original_source(self) -> typing.Optional[winrt.system.Object]: ...

@typing.final
class DoubleTappedRoutedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> DoubleTappedRoutedEventArgs: ...
    def __new__(cls: typing.Type[DoubleTappedRoutedEventArgs]) -> DoubleTappedRoutedEventArgs: ...
    def get_position(self, relative_to: typing.Optional[microsoft_ui_xaml.UIElement], /) -> windows_foundation.Point: ...
    @_property
    def handled(self) -> bool: ...
    @handled.setter
    def handled(self, value: bool) -> None: ...
    @_property
    def pointer_device_type(self) -> microsoft_ui_input.PointerDeviceType: ...
    @_property
    def original_source(self) -> typing.Optional[winrt.system.Object]: ...

@typing.final
class ExecuteRequestedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ExecuteRequestedEventArgs: ...
    @_property
    def parameter(self) -> typing.Optional[winrt.system.Object]: ...

@typing.final
class FindNextElementOptions(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> FindNextElementOptions: ...
    def __new__(cls: typing.Type[FindNextElementOptions]) -> FindNextElementOptions: ...
    @_property
    def x_y_focus_navigation_strategy_override(self) -> XYFocusNavigationStrategyOverride: ...
    @x_y_focus_navigation_strategy_override.setter
    def x_y_focus_navigation_strategy_override(self, value: XYFocusNavigationStrategyOverride) -> None: ...
    @_property
    def search_root(self) -> typing.Optional[microsoft_ui_xaml.DependencyObject]: ...
    @search_root.setter
    def search_root(self, value: typing.Optional[microsoft_ui_xaml.DependencyObject]) -> None: ...
    @_property
    def hint_rect(self) -> windows_foundation.Rect: ...
    @hint_rect.setter
    def hint_rect(self, value: windows_foundation.Rect) -> None: ...
    @_property
    def exclusion_rect(self) -> windows_foundation.Rect: ...
    @exclusion_rect.setter
    def exclusion_rect(self, value: windows_foundation.Rect) -> None: ...

@typing.final
class FocusManager_Static(type):
    def find_first_focusable_element(cls, search_scope: typing.Optional[microsoft_ui_xaml.DependencyObject], /) -> typing.Optional[microsoft_ui_xaml.DependencyObject]: ...
    def find_last_focusable_element(cls, search_scope: typing.Optional[microsoft_ui_xaml.DependencyObject], /) -> typing.Optional[microsoft_ui_xaml.DependencyObject]: ...
    @typing.overload
    def find_next_element(cls, focus_navigation_direction: FocusNavigationDirection, /) -> typing.Optional[microsoft_ui_xaml.DependencyObject]: ...
    @typing.overload
    def find_next_element(cls, focus_navigation_direction: FocusNavigationDirection, focus_navigation_options: typing.Optional[FindNextElementOptions], /) -> typing.Optional[microsoft_ui_xaml.DependencyObject]: ...
    @typing.overload
    def find_next_focusable_element(cls, focus_navigation_direction: FocusNavigationDirection, /) -> typing.Optional[microsoft_ui_xaml.UIElement]: ...
    @typing.overload
    def find_next_focusable_element(cls, focus_navigation_direction: FocusNavigationDirection, hint_rect: windows_foundation.Rect, /) -> typing.Optional[microsoft_ui_xaml.UIElement]: ...
    @typing.overload
    def get_focused_element(cls) -> typing.Optional[winrt.system.Object]: ...
    @typing.overload
    def get_focused_element(cls, xaml_root: typing.Optional[microsoft_ui_xaml.XamlRoot], /) -> typing.Optional[winrt.system.Object]: ...
    def try_focus_async(cls, element: typing.Optional[microsoft_ui_xaml.DependencyObject], value: microsoft_ui_xaml.FocusState, /) -> windows_foundation.IAsyncOperation[FocusMovementResult]: ...
    @typing.overload
    def try_move_focus(cls, focus_navigation_direction: FocusNavigationDirection, /) -> bool: ...
    @typing.overload
    def try_move_focus(cls, focus_navigation_direction: FocusNavigationDirection, focus_navigation_options: typing.Optional[FindNextElementOptions], /) -> bool: ...
    @typing.overload
    def try_move_focus_async(cls, focus_navigation_direction: FocusNavigationDirection, /) -> windows_foundation.IAsyncOperation[FocusMovementResult]: ...
    @typing.overload
    def try_move_focus_async(cls, focus_navigation_direction: FocusNavigationDirection, focus_navigation_options: typing.Optional[FindNextElementOptions], /) -> windows_foundation.IAsyncOperation[FocusMovementResult]: ...
    def add_getting_focus(cls, handler: windows_foundation.EventHandler[GettingFocusEventArgs], /) -> windows_foundation.EventRegistrationToken: ...
    def remove_getting_focus(cls, token: windows_foundation.EventRegistrationToken, /) -> None: ...
    def add_got_focus(cls, handler: windows_foundation.EventHandler[FocusManagerGotFocusEventArgs], /) -> windows_foundation.EventRegistrationToken: ...
    def remove_got_focus(cls, token: windows_foundation.EventRegistrationToken, /) -> None: ...
    def add_losing_focus(cls, handler: windows_foundation.EventHandler[LosingFocusEventArgs], /) -> windows_foundation.EventRegistrationToken: ...
    def remove_losing_focus(cls, token: windows_foundation.EventRegistrationToken, /) -> None: ...
    def add_lost_focus(cls, handler: windows_foundation.EventHandler[FocusManagerLostFocusEventArgs], /) -> windows_foundation.EventRegistrationToken: ...
    def remove_lost_focus(cls, token: windows_foundation.EventRegistrationToken, /) -> None: ...

@typing.final
class FocusManager(winrt.system.Object, metaclass=FocusManager_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> FocusManager: ...

@typing.final
class FocusManagerGotFocusEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> FocusManagerGotFocusEventArgs: ...
    @_property
    def correlation_id(self) -> _uuid.UUID: ...
    @_property
    def new_focused_element(self) -> typing.Optional[microsoft_ui_xaml.DependencyObject]: ...

@typing.final
class FocusManagerLostFocusEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> FocusManagerLostFocusEventArgs: ...
    @_property
    def correlation_id(self) -> _uuid.UUID: ...
    @_property
    def old_focused_element(self) -> typing.Optional[microsoft_ui_xaml.DependencyObject]: ...

@typing.final
class FocusMovementResult(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> FocusMovementResult: ...
    @_property
    def succeeded(self) -> bool: ...

@typing.final
class GettingFocusEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> GettingFocusEventArgs: ...
    def try_cancel(self) -> bool: ...
    def try_set_new_focused_element(self, element: typing.Optional[microsoft_ui_xaml.DependencyObject], /) -> bool: ...
    @_property
    def new_focused_element(self) -> typing.Optional[microsoft_ui_xaml.DependencyObject]: ...
    @new_focused_element.setter
    def new_focused_element(self, value: typing.Optional[microsoft_ui_xaml.DependencyObject]) -> None: ...
    @_property
    def handled(self) -> bool: ...
    @handled.setter
    def handled(self, value: bool) -> None: ...
    @_property
    def cancel(self) -> bool: ...
    @cancel.setter
    def cancel(self, value: bool) -> None: ...
    @_property
    def correlation_id(self) -> _uuid.UUID: ...
    @_property
    def direction(self) -> FocusNavigationDirection: ...
    @_property
    def focus_state(self) -> microsoft_ui_xaml.FocusState: ...
    @_property
    def input_device(self) -> FocusInputDeviceKind: ...
    @_property
    def old_focused_element(self) -> typing.Optional[microsoft_ui_xaml.DependencyObject]: ...
    @_property
    def original_source(self) -> typing.Optional[winrt.system.Object]: ...

@typing.final
class HoldingRoutedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> HoldingRoutedEventArgs: ...
    def __new__(cls: typing.Type[HoldingRoutedEventArgs]) -> HoldingRoutedEventArgs: ...
    def get_position(self, relative_to: typing.Optional[microsoft_ui_xaml.UIElement], /) -> windows_foundation.Point: ...
    @_property
    def handled(self) -> bool: ...
    @handled.setter
    def handled(self, value: bool) -> None: ...
    @_property
    def holding_state(self) -> microsoft_ui_input.HoldingState: ...
    @_property
    def pointer_device_type(self) -> microsoft_ui_input.PointerDeviceType: ...
    @_property
    def original_source(self) -> typing.Optional[winrt.system.Object]: ...

@typing.final
class InertiaExpansionBehavior(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> InertiaExpansionBehavior: ...
    @_property
    def desired_expansion(self) -> winrt.system.Double: ...
    @desired_expansion.setter
    def desired_expansion(self, value: winrt.system.Double) -> None: ...
    @_property
    def desired_deceleration(self) -> winrt.system.Double: ...
    @desired_deceleration.setter
    def desired_deceleration(self, value: winrt.system.Double) -> None: ...

@typing.final
class InertiaRotationBehavior(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> InertiaRotationBehavior: ...
    @_property
    def desired_rotation(self) -> winrt.system.Double: ...
    @desired_rotation.setter
    def desired_rotation(self, value: winrt.system.Double) -> None: ...
    @_property
    def desired_deceleration(self) -> winrt.system.Double: ...
    @desired_deceleration.setter
    def desired_deceleration(self, value: winrt.system.Double) -> None: ...

@typing.final
class InertiaTranslationBehavior(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> InertiaTranslationBehavior: ...
    @_property
    def desired_displacement(self) -> winrt.system.Double: ...
    @desired_displacement.setter
    def desired_displacement(self, value: winrt.system.Double) -> None: ...
    @_property
    def desired_deceleration(self) -> winrt.system.Double: ...
    @desired_deceleration.setter
    def desired_deceleration(self, value: winrt.system.Double) -> None: ...

@typing.final
class InputScope(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> InputScope: ...
    def __new__(cls: typing.Type[InputScope]) -> InputScope: ...
    def clear_value(self, dp: typing.Optional[microsoft_ui_xaml.DependencyProperty], /) -> None: ...
    def get_animation_base_value(self, dp: typing.Optional[microsoft_ui_xaml.DependencyProperty], /) -> typing.Optional[winrt.system.Object]: ...
    def get_value(self, dp: typing.Optional[microsoft_ui_xaml.DependencyProperty], /) -> typing.Optional[winrt.system.Object]: ...
    def read_local_value(self, dp: typing.Optional[microsoft_ui_xaml.DependencyProperty], /) -> typing.Optional[winrt.system.Object]: ...
    def register_property_changed_callback(self, dp: typing.Optional[microsoft_ui_xaml.DependencyProperty], callback: typing.Optional[microsoft_ui_xaml.DependencyPropertyChangedCallback], /) -> winrt.system.Int64: ...
    def set_value(self, dp: typing.Optional[microsoft_ui_xaml.DependencyProperty], value: typing.Optional[winrt.system.Object], /) -> None: ...
    def unregister_property_changed_callback(self, dp: typing.Optional[microsoft_ui_xaml.DependencyProperty], token: winrt.system.Int64, /) -> None: ...
    @_property
    def names(self) -> typing.Optional[windows_foundation_collections.IVector[InputScopeName]]: ...
    @_property
    def dispatcher(self) -> typing.Optional[windows_ui_core.CoreDispatcher]: ...
    @_property
    def dispatcher_queue(self) -> typing.Optional[microsoft_ui_dispatching.DispatcherQueue]: ...

@typing.final
class InputScopeName(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> InputScopeName: ...
    @typing.overload
    def __new__(cls: typing.Type[InputScopeName], name_value: InputScopeNameValue) -> InputScopeName: ...
    @typing.overload
    def __new__(cls: typing.Type[InputScopeName]) -> InputScopeName: ...
    def clear_value(self, dp: typing.Optional[microsoft_ui_xaml.DependencyProperty], /) -> None: ...
    def get_animation_base_value(self, dp: typing.Optional[microsoft_ui_xaml.DependencyProperty], /) -> typing.Optional[winrt.system.Object]: ...
    def get_value(self, dp: typing.Optional[microsoft_ui_xaml.DependencyProperty], /) -> typing.Optional[winrt.system.Object]: ...
    def read_local_value(self, dp: typing.Optional[microsoft_ui_xaml.DependencyProperty], /) -> typing.Optional[winrt.system.Object]: ...
    def register_property_changed_callback(self, dp: typing.Optional[microsoft_ui_xaml.DependencyProperty], callback: typing.Optional[microsoft_ui_xaml.DependencyPropertyChangedCallback], /) -> winrt.system.Int64: ...
    def set_value(self, dp: typing.Optional[microsoft_ui_xaml.DependencyProperty], value: typing.Optional[winrt.system.Object], /) -> None: ...
    def unregister_property_changed_callback(self, dp: typing.Optional[microsoft_ui_xaml.DependencyProperty], token: winrt.system.Int64, /) -> None: ...
    @_property
    def name_value(self) -> InputScopeNameValue: ...
    @name_value.setter
    def name_value(self, value: InputScopeNameValue) -> None: ...
    @_property
    def dispatcher(self) -> typing.Optional[windows_ui_core.CoreDispatcher]: ...
    @_property
    def dispatcher_queue(self) -> typing.Optional[microsoft_ui_dispatching.DispatcherQueue]: ...

@typing.final
class KeyRoutedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> KeyRoutedEventArgs: ...
    @_property
    def handled(self) -> bool: ...
    @handled.setter
    def handled(self, value: bool) -> None: ...
    @_property
    def device_id(self) -> str: ...
    @_property
    def key(self) -> windows_system.VirtualKey: ...
    @_property
    def key_status(self) -> windows_ui_core.CorePhysicalKeyStatus: ...
    @_property
    def original_key(self) -> windows_system.VirtualKey: ...
    @_property
    def original_source(self) -> typing.Optional[winrt.system.Object]: ...

@typing.final
class KeyboardAccelerator_Static(type):
    @_property
    def is_enabled_property(cls) -> typing.Optional[microsoft_ui_xaml.DependencyProperty]: ...
    @_property
    def key_property(cls) -> typing.Optional[microsoft_ui_xaml.DependencyProperty]: ...
    @_property
    def modifiers_property(cls) -> typing.Optional[microsoft_ui_xaml.DependencyProperty]: ...
    @_property
    def scope_owner_property(cls) -> typing.Optional[microsoft_ui_xaml.DependencyProperty]: ...

@typing.final
class KeyboardAccelerator(winrt.system.Object, metaclass=KeyboardAccelerator_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> KeyboardAccelerator: ...
    def __new__(cls: typing.Type[KeyboardAccelerator]) -> KeyboardAccelerator: ...
    def clear_value(self, dp: typing.Optional[microsoft_ui_xaml.DependencyProperty], /) -> None: ...
    def get_animation_base_value(self, dp: typing.Optional[microsoft_ui_xaml.DependencyProperty], /) -> typing.Optional[winrt.system.Object]: ...
    def get_value(self, dp: typing.Optional[microsoft_ui_xaml.DependencyProperty], /) -> typing.Optional[winrt.system.Object]: ...
    def read_local_value(self, dp: typing.Optional[microsoft_ui_xaml.DependencyProperty], /) -> typing.Optional[winrt.system.Object]: ...
    def register_property_changed_callback(self, dp: typing.Optional[microsoft_ui_xaml.DependencyProperty], callback: typing.Optional[microsoft_ui_xaml.DependencyPropertyChangedCallback], /) -> winrt.system.Int64: ...
    def set_value(self, dp: typing.Optional[microsoft_ui_xaml.DependencyProperty], value: typing.Optional[winrt.system.Object], /) -> None: ...
    def unregister_property_changed_callback(self, dp: typing.Optional[microsoft_ui_xaml.DependencyProperty], token: winrt.system.Int64, /) -> None: ...
    def add_invoked(self, handler: windows_foundation.TypedEventHandler[KeyboardAccelerator, KeyboardAcceleratorInvokedEventArgs], /) -> windows_foundation.EventRegistrationToken: ...
    def remove_invoked(self, token: windows_foundation.EventRegistrationToken, /) -> None: ...
    @_property
    def scope_owner(self) -> typing.Optional[microsoft_ui_xaml.DependencyObject]: ...
    @scope_owner.setter
    def scope_owner(self, value: typing.Optional[microsoft_ui_xaml.DependencyObject]) -> None: ...
    @_property
    def modifiers(self) -> windows_system.VirtualKeyModifiers: ...
    @modifiers.setter
    def modifiers(self, value: windows_system.VirtualKeyModifiers) -> None: ...
    @_property
    def key(self) -> windows_system.VirtualKey: ...
    @key.setter
    def key(self, value: windows_system.VirtualKey) -> None: ...
    @_property
    def is_enabled(self) -> bool: ...
    @is_enabled.setter
    def is_enabled(self, value: bool) -> None: ...
    @_property
    def dispatcher(self) -> typing.Optional[windows_ui_core.CoreDispatcher]: ...
    @_property
    def dispatcher_queue(self) -> typing.Optional[microsoft_ui_dispatching.DispatcherQueue]: ...

@typing.final
class KeyboardAcceleratorInvokedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> KeyboardAcceleratorInvokedEventArgs: ...
    @_property
    def handled(self) -> bool: ...
    @handled.setter
    def handled(self, value: bool) -> None: ...
    @_property
    def element(self) -> typing.Optional[microsoft_ui_xaml.DependencyObject]: ...
    @_property
    def keyboard_accelerator(self) -> typing.Optional[KeyboardAccelerator]: ...

@typing.final
class LosingFocusEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> LosingFocusEventArgs: ...
    def try_cancel(self) -> bool: ...
    def try_set_new_focused_element(self, element: typing.Optional[microsoft_ui_xaml.DependencyObject], /) -> bool: ...
    @_property
    def new_focused_element(self) -> typing.Optional[microsoft_ui_xaml.DependencyObject]: ...
    @new_focused_element.setter
    def new_focused_element(self, value: typing.Optional[microsoft_ui_xaml.DependencyObject]) -> None: ...
    @_property
    def handled(self) -> bool: ...
    @handled.setter
    def handled(self, value: bool) -> None: ...
    @_property
    def cancel(self) -> bool: ...
    @cancel.setter
    def cancel(self, value: bool) -> None: ...
    @_property
    def correlation_id(self) -> _uuid.UUID: ...
    @_property
    def direction(self) -> FocusNavigationDirection: ...
    @_property
    def focus_state(self) -> microsoft_ui_xaml.FocusState: ...
    @_property
    def input_device(self) -> FocusInputDeviceKind: ...
    @_property
    def old_focused_element(self) -> typing.Optional[microsoft_ui_xaml.DependencyObject]: ...
    @_property
    def original_source(self) -> typing.Optional[winrt.system.Object]: ...

@typing.final
class ManipulationCompletedRoutedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ManipulationCompletedRoutedEventArgs: ...
    def __new__(cls: typing.Type[ManipulationCompletedRoutedEventArgs]) -> ManipulationCompletedRoutedEventArgs: ...
    @_property
    def handled(self) -> bool: ...
    @handled.setter
    def handled(self, value: bool) -> None: ...
    @_property
    def container(self) -> typing.Optional[microsoft_ui_xaml.UIElement]: ...
    @_property
    def cumulative(self) -> microsoft_ui_input.ManipulationDelta: ...
    @_property
    def is_inertial(self) -> bool: ...
    @_property
    def pointer_device_type(self) -> microsoft_ui_input.PointerDeviceType: ...
    @_property
    def position(self) -> windows_foundation.Point: ...
    @_property
    def velocities(self) -> microsoft_ui_input.ManipulationVelocities: ...
    @_property
    def original_source(self) -> typing.Optional[winrt.system.Object]: ...

@typing.final
class ManipulationDeltaRoutedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ManipulationDeltaRoutedEventArgs: ...
    def __new__(cls: typing.Type[ManipulationDeltaRoutedEventArgs]) -> ManipulationDeltaRoutedEventArgs: ...
    def complete(self) -> None: ...
    @_property
    def handled(self) -> bool: ...
    @handled.setter
    def handled(self, value: bool) -> None: ...
    @_property
    def container(self) -> typing.Optional[microsoft_ui_xaml.UIElement]: ...
    @_property
    def cumulative(self) -> microsoft_ui_input.ManipulationDelta: ...
    @_property
    def delta(self) -> microsoft_ui_input.ManipulationDelta: ...
    @_property
    def is_inertial(self) -> bool: ...
    @_property
    def pointer_device_type(self) -> microsoft_ui_input.PointerDeviceType: ...
    @_property
    def position(self) -> windows_foundation.Point: ...
    @_property
    def velocities(self) -> microsoft_ui_input.ManipulationVelocities: ...
    @_property
    def original_source(self) -> typing.Optional[winrt.system.Object]: ...

@typing.final
class ManipulationInertiaStartingRoutedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ManipulationInertiaStartingRoutedEventArgs: ...
    def __new__(cls: typing.Type[ManipulationInertiaStartingRoutedEventArgs]) -> ManipulationInertiaStartingRoutedEventArgs: ...
    @_property
    def translation_behavior(self) -> typing.Optional[InertiaTranslationBehavior]: ...
    @translation_behavior.setter
    def translation_behavior(self, value: typing.Optional[InertiaTranslationBehavior]) -> None: ...
    @_property
    def rotation_behavior(self) -> typing.Optional[InertiaRotationBehavior]: ...
    @rotation_behavior.setter
    def rotation_behavior(self, value: typing.Optional[InertiaRotationBehavior]) -> None: ...
    @_property
    def handled(self) -> bool: ...
    @handled.setter
    def handled(self, value: bool) -> None: ...
    @_property
    def expansion_behavior(self) -> typing.Optional[InertiaExpansionBehavior]: ...
    @expansion_behavior.setter
    def expansion_behavior(self, value: typing.Optional[InertiaExpansionBehavior]) -> None: ...
    @_property
    def container(self) -> typing.Optional[microsoft_ui_xaml.UIElement]: ...
    @_property
    def cumulative(self) -> microsoft_ui_input.ManipulationDelta: ...
    @_property
    def delta(self) -> microsoft_ui_input.ManipulationDelta: ...
    @_property
    def pointer_device_type(self) -> microsoft_ui_input.PointerDeviceType: ...
    @_property
    def velocities(self) -> microsoft_ui_input.ManipulationVelocities: ...
    @_property
    def original_source(self) -> typing.Optional[winrt.system.Object]: ...

@typing.final
class ManipulationPivot(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ManipulationPivot: ...
    @typing.overload
    def __new__(cls: typing.Type[ManipulationPivot], center: windows_foundation.Point, radius: winrt.system.Double) -> ManipulationPivot: ...
    @typing.overload
    def __new__(cls: typing.Type[ManipulationPivot]) -> ManipulationPivot: ...
    @_property
    def radius(self) -> winrt.system.Double: ...
    @radius.setter
    def radius(self, value: winrt.system.Double) -> None: ...
    @_property
    def center(self) -> windows_foundation.Point: ...
    @center.setter
    def center(self, value: windows_foundation.Point) -> None: ...

@typing.final
class ManipulationStartedRoutedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ManipulationStartedRoutedEventArgs: ...
    def __new__(cls: typing.Type[ManipulationStartedRoutedEventArgs]) -> ManipulationStartedRoutedEventArgs: ...
    def complete(self) -> None: ...
    @_property
    def handled(self) -> bool: ...
    @handled.setter
    def handled(self, value: bool) -> None: ...
    @_property
    def container(self) -> typing.Optional[microsoft_ui_xaml.UIElement]: ...
    @_property
    def cumulative(self) -> microsoft_ui_input.ManipulationDelta: ...
    @_property
    def pointer_device_type(self) -> microsoft_ui_input.PointerDeviceType: ...
    @_property
    def position(self) -> windows_foundation.Point: ...
    @_property
    def original_source(self) -> typing.Optional[winrt.system.Object]: ...

@typing.final
class ManipulationStartingRoutedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ManipulationStartingRoutedEventArgs: ...
    def __new__(cls: typing.Type[ManipulationStartingRoutedEventArgs]) -> ManipulationStartingRoutedEventArgs: ...
    @_property
    def pivot(self) -> typing.Optional[ManipulationPivot]: ...
    @pivot.setter
    def pivot(self, value: typing.Optional[ManipulationPivot]) -> None: ...
    @_property
    def mode(self) -> ManipulationModes: ...
    @mode.setter
    def mode(self, value: ManipulationModes) -> None: ...
    @_property
    def handled(self) -> bool: ...
    @handled.setter
    def handled(self, value: bool) -> None: ...
    @_property
    def container(self) -> typing.Optional[microsoft_ui_xaml.UIElement]: ...
    @container.setter
    def container(self, value: typing.Optional[microsoft_ui_xaml.UIElement]) -> None: ...
    @_property
    def original_source(self) -> typing.Optional[winrt.system.Object]: ...

@typing.final
class NoFocusCandidateFoundEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> NoFocusCandidateFoundEventArgs: ...
    @_property
    def handled(self) -> bool: ...
    @handled.setter
    def handled(self, value: bool) -> None: ...
    @_property
    def direction(self) -> FocusNavigationDirection: ...
    @_property
    def input_device(self) -> FocusInputDeviceKind: ...
    @_property
    def original_source(self) -> typing.Optional[winrt.system.Object]: ...

@typing.final
class Pointer(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> Pointer: ...
    @_property
    def is_in_contact(self) -> bool: ...
    @_property
    def is_in_range(self) -> bool: ...
    @_property
    def pointer_device_type(self) -> microsoft_ui_input.PointerDeviceType: ...
    @_property
    def pointer_id(self) -> winrt.system.UInt32: ...

@typing.final
class PointerRoutedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> PointerRoutedEventArgs: ...
    def get_current_point(self, relative_to: typing.Optional[microsoft_ui_xaml.UIElement], /) -> typing.Optional[microsoft_ui_input.PointerPoint]: ...
    def get_intermediate_points(self, relative_to: typing.Optional[microsoft_ui_xaml.UIElement], /) -> typing.Optional[windows_foundation_collections.IVector[microsoft_ui_input.PointerPoint]]: ...
    @_property
    def handled(self) -> bool: ...
    @handled.setter
    def handled(self, value: bool) -> None: ...
    @_property
    def is_generated(self) -> bool: ...
    @_property
    def key_modifiers(self) -> windows_system.VirtualKeyModifiers: ...
    @_property
    def pointer(self) -> typing.Optional[Pointer]: ...
    @_property
    def original_source(self) -> typing.Optional[winrt.system.Object]: ...

@typing.final
class ProcessKeyboardAcceleratorEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ProcessKeyboardAcceleratorEventArgs: ...
    @_property
    def handled(self) -> bool: ...
    @handled.setter
    def handled(self, value: bool) -> None: ...
    @_property
    def key(self) -> windows_system.VirtualKey: ...
    @_property
    def modifiers(self) -> windows_system.VirtualKeyModifiers: ...

@typing.final
class RightTappedRoutedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> RightTappedRoutedEventArgs: ...
    def __new__(cls: typing.Type[RightTappedRoutedEventArgs]) -> RightTappedRoutedEventArgs: ...
    def get_position(self, relative_to: typing.Optional[microsoft_ui_xaml.UIElement], /) -> windows_foundation.Point: ...
    @_property
    def handled(self) -> bool: ...
    @handled.setter
    def handled(self, value: bool) -> None: ...
    @_property
    def pointer_device_type(self) -> microsoft_ui_input.PointerDeviceType: ...
    @_property
    def original_source(self) -> typing.Optional[winrt.system.Object]: ...

@typing.final
class StandardUICommand_Static(type):
    @_property
    def kind_property(cls) -> typing.Optional[microsoft_ui_xaml.DependencyProperty]: ...

@typing.final
class StandardUICommand(winrt.system.Object, metaclass=StandardUICommand_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> StandardUICommand: ...
    @typing.overload
    def __new__(cls: typing.Type[StandardUICommand]) -> StandardUICommand: ...
    @typing.overload
    def __new__(cls: typing.Type[StandardUICommand], kind: StandardUICommandKind) -> StandardUICommand: ...
    def can_execute(self, parameter: typing.Optional[winrt.system.Object], /) -> bool: ...
    def clear_value(self, dp: typing.Optional[microsoft_ui_xaml.DependencyProperty], /) -> None: ...
    def execute(self, parameter: typing.Optional[winrt.system.Object], /) -> None: ...
    def get_animation_base_value(self, dp: typing.Optional[microsoft_ui_xaml.DependencyProperty], /) -> typing.Optional[winrt.system.Object]: ...
    def get_value(self, dp: typing.Optional[microsoft_ui_xaml.DependencyProperty], /) -> typing.Optional[winrt.system.Object]: ...
    def notify_can_execute_changed(self) -> None: ...
    def read_local_value(self, dp: typing.Optional[microsoft_ui_xaml.DependencyProperty], /) -> typing.Optional[winrt.system.Object]: ...
    def register_property_changed_callback(self, dp: typing.Optional[microsoft_ui_xaml.DependencyProperty], callback: typing.Optional[microsoft_ui_xaml.DependencyPropertyChangedCallback], /) -> winrt.system.Int64: ...
    def set_value(self, dp: typing.Optional[microsoft_ui_xaml.DependencyProperty], value: typing.Optional[winrt.system.Object], /) -> None: ...
    def unregister_property_changed_callback(self, dp: typing.Optional[microsoft_ui_xaml.DependencyProperty], token: winrt.system.Int64, /) -> None: ...
    def add_can_execute_requested(self, handler: windows_foundation.TypedEventHandler[XamlUICommand, CanExecuteRequestedEventArgs], /) -> windows_foundation.EventRegistrationToken: ...
    def remove_can_execute_requested(self, token: windows_foundation.EventRegistrationToken, /) -> None: ...
    def add_execute_requested(self, handler: windows_foundation.TypedEventHandler[XamlUICommand, ExecuteRequestedEventArgs], /) -> windows_foundation.EventRegistrationToken: ...
    def remove_execute_requested(self, token: windows_foundation.EventRegistrationToken, /) -> None: ...
    def add_can_execute_changed(self, handler: windows_foundation.EventHandler[winrt.system.Object], /) -> windows_foundation.EventRegistrationToken: ...
    def remove_can_execute_changed(self, token: windows_foundation.EventRegistrationToken, /) -> None: ...
    @_property
    def kind(self) -> StandardUICommandKind: ...
    @kind.setter
    def kind(self, value: StandardUICommandKind) -> None: ...
    @_property
    def label(self) -> str: ...
    @label.setter
    def label(self, value: str) -> None: ...
    @_property
    def icon_source(self) -> typing.Optional[microsoft_ui_xaml_controls.IconSource]: ...
    @icon_source.setter
    def icon_source(self, value: typing.Optional[microsoft_ui_xaml_controls.IconSource]) -> None: ...
    @_property
    def description(self) -> str: ...
    @description.setter
    def description(self, value: str) -> None: ...
    @_property
    def command(self) -> typing.Optional[ICommand]: ...
    @command.setter
    def command(self, value: typing.Optional[ICommand]) -> None: ...
    @_property
    def access_key(self) -> str: ...
    @access_key.setter
    def access_key(self, value: str) -> None: ...
    @_property
    def keyboard_accelerators(self) -> typing.Optional[windows_foundation_collections.IVector[KeyboardAccelerator]]: ...
    @_property
    def dispatcher(self) -> typing.Optional[windows_ui_core.CoreDispatcher]: ...
    @_property
    def dispatcher_queue(self) -> typing.Optional[microsoft_ui_dispatching.DispatcherQueue]: ...

@typing.final
class TappedRoutedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> TappedRoutedEventArgs: ...
    def __new__(cls: typing.Type[TappedRoutedEventArgs]) -> TappedRoutedEventArgs: ...
    def get_position(self, relative_to: typing.Optional[microsoft_ui_xaml.UIElement], /) -> windows_foundation.Point: ...
    @_property
    def handled(self) -> bool: ...
    @handled.setter
    def handled(self, value: bool) -> None: ...
    @_property
    def pointer_device_type(self) -> microsoft_ui_input.PointerDeviceType: ...
    @_property
    def original_source(self) -> typing.Optional[winrt.system.Object]: ...

@typing.final
class XamlUICommand_Static(type):
    @_property
    def access_key_property(cls) -> typing.Optional[microsoft_ui_xaml.DependencyProperty]: ...
    @_property
    def command_property(cls) -> typing.Optional[microsoft_ui_xaml.DependencyProperty]: ...
    @_property
    def description_property(cls) -> typing.Optional[microsoft_ui_xaml.DependencyProperty]: ...
    @_property
    def icon_source_property(cls) -> typing.Optional[microsoft_ui_xaml.DependencyProperty]: ...
    @_property
    def keyboard_accelerators_property(cls) -> typing.Optional[microsoft_ui_xaml.DependencyProperty]: ...
    @_property
    def label_property(cls) -> typing.Optional[microsoft_ui_xaml.DependencyProperty]: ...

@typing.final
class XamlUICommand(winrt.system.Object, metaclass=XamlUICommand_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> XamlUICommand: ...
    def __new__(cls: typing.Type[XamlUICommand]) -> XamlUICommand: ...
    def can_execute(self, parameter: typing.Optional[winrt.system.Object], /) -> bool: ...
    def clear_value(self, dp: typing.Optional[microsoft_ui_xaml.DependencyProperty], /) -> None: ...
    def execute(self, parameter: typing.Optional[winrt.system.Object], /) -> None: ...
    def get_animation_base_value(self, dp: typing.Optional[microsoft_ui_xaml.DependencyProperty], /) -> typing.Optional[winrt.system.Object]: ...
    def get_value(self, dp: typing.Optional[microsoft_ui_xaml.DependencyProperty], /) -> typing.Optional[winrt.system.Object]: ...
    def notify_can_execute_changed(self) -> None: ...
    def read_local_value(self, dp: typing.Optional[microsoft_ui_xaml.DependencyProperty], /) -> typing.Optional[winrt.system.Object]: ...
    def register_property_changed_callback(self, dp: typing.Optional[microsoft_ui_xaml.DependencyProperty], callback: typing.Optional[microsoft_ui_xaml.DependencyPropertyChangedCallback], /) -> winrt.system.Int64: ...
    def set_value(self, dp: typing.Optional[microsoft_ui_xaml.DependencyProperty], value: typing.Optional[winrt.system.Object], /) -> None: ...
    def unregister_property_changed_callback(self, dp: typing.Optional[microsoft_ui_xaml.DependencyProperty], token: winrt.system.Int64, /) -> None: ...
    def add_can_execute_requested(self, handler: windows_foundation.TypedEventHandler[XamlUICommand, CanExecuteRequestedEventArgs], /) -> windows_foundation.EventRegistrationToken: ...
    def remove_can_execute_requested(self, token: windows_foundation.EventRegistrationToken, /) -> None: ...
    def add_execute_requested(self, handler: windows_foundation.TypedEventHandler[XamlUICommand, ExecuteRequestedEventArgs], /) -> windows_foundation.EventRegistrationToken: ...
    def remove_execute_requested(self, token: windows_foundation.EventRegistrationToken, /) -> None: ...
    def add_can_execute_changed(self, handler: windows_foundation.EventHandler[winrt.system.Object], /) -> windows_foundation.EventRegistrationToken: ...
    def remove_can_execute_changed(self, token: windows_foundation.EventRegistrationToken, /) -> None: ...
    @_property
    def label(self) -> str: ...
    @label.setter
    def label(self, value: str) -> None: ...
    @_property
    def icon_source(self) -> typing.Optional[microsoft_ui_xaml_controls.IconSource]: ...
    @icon_source.setter
    def icon_source(self, value: typing.Optional[microsoft_ui_xaml_controls.IconSource]) -> None: ...
    @_property
    def description(self) -> str: ...
    @description.setter
    def description(self, value: str) -> None: ...
    @_property
    def command(self) -> typing.Optional[ICommand]: ...
    @command.setter
    def command(self, value: typing.Optional[ICommand]) -> None: ...
    @_property
    def access_key(self) -> str: ...
    @access_key.setter
    def access_key(self, value: str) -> None: ...
    @_property
    def keyboard_accelerators(self) -> typing.Optional[windows_foundation_collections.IVector[KeyboardAccelerator]]: ...
    @_property
    def dispatcher(self) -> typing.Optional[windows_ui_core.CoreDispatcher]: ...
    @_property
    def dispatcher_queue(self) -> typing.Optional[microsoft_ui_dispatching.DispatcherQueue]: ...

@typing.final
class ICommand(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ICommand: ...
    def can_execute(self, parameter: typing.Optional[winrt.system.Object], /) -> bool: ...
    def execute(self, parameter: typing.Optional[winrt.system.Object], /) -> None: ...
    def add_can_execute_changed(self, handler: windows_foundation.EventHandler[winrt.system.Object], /) -> windows_foundation.EventRegistrationToken: ...
    def remove_can_execute_changed(self, token: windows_foundation.EventRegistrationToken, /) -> None: ...

