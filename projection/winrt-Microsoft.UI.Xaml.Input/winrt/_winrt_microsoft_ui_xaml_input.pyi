# WARNING: Please don't edit this file. It was generated by Python/WinRT v2.0.0-beta.2

import datetime
import sys
import types
import typing
import uuid as _uuid
from builtins import property as _property

import winrt._winrt
import winrt.system
import winrt.microsoft.ui.input
import winrt.microsoft.ui.xaml
import winrt.microsoft.ui.xaml.controls
import winrt.windows.foundation
import winrt.windows.foundation.collections
import winrt.windows.system
import winrt.windows.ui.core

from winrt.microsoft.ui.xaml.input import FocusInputDeviceKind, FocusNavigationDirection, InputScopeNameValue, KeyTipPlacementMode, KeyboardAcceleratorPlacementMode, KeyboardNavigationMode, ManipulationModes, StandardUICommandKind, XYFocusKeyboardNavigationMode, XYFocusNavigationStrategy, XYFocusNavigationStrategyOverride
from winrt.microsoft.ui.xaml.input import DoubleTappedEventHandler, HoldingEventHandler, KeyEventHandler, ManipulationCompletedEventHandler, ManipulationDeltaEventHandler, ManipulationInertiaStartingEventHandler, ManipulationStartedEventHandler, ManipulationStartingEventHandler, PointerEventHandler, RightTappedEventHandler, TappedEventHandler

Self = typing.TypeVar('Self')

@typing.final
class AccessKeyDisplayDismissedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> AccessKeyDisplayDismissedEventArgs: ...
    def __new__(cls: typing.Type[AccessKeyDisplayDismissedEventArgs]) -> AccessKeyDisplayDismissedEventArgs:...

@typing.final
class AccessKeyDisplayRequestedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> AccessKeyDisplayRequestedEventArgs: ...
    def __new__(cls: typing.Type[AccessKeyDisplayRequestedEventArgs]) -> AccessKeyDisplayRequestedEventArgs:...
    @_property
    def pressed_keys(self) -> str: ...

@typing.final
class AccessKeyInvokedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> AccessKeyInvokedEventArgs: ...
    def __new__(cls: typing.Type[AccessKeyInvokedEventArgs]) -> AccessKeyInvokedEventArgs:...
    @_property
    def handled(self) -> bool: ...
    @handled.setter
    def handled(self, value: bool) -> None: ...

@typing.final
class AccessKeyManager_Static(type):
    def enter_display_mode(cls, xaml_root: typing.Optional[winrt.microsoft.ui.xaml.XamlRoot], /) -> None: ...
    def exit_display_mode(cls) -> None: ...
    def add_is_display_mode_enabled_changed(cls, handler: winrt.windows.foundation.TypedEventHandler[winrt.system.Object, winrt.system.Object], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_is_display_mode_enabled_changed(cls, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    @_property
    def are_key_tips_enabled(cls) -> bool: ...
    @are_key_tips_enabled.setter
    def are_key_tips_enabled(cls, value: bool) -> None: ...
    @_property
    def is_display_mode_enabled(cls) -> bool: ...

@typing.final
class AccessKeyManager(winrt.system.Object, metaclass=AccessKeyManager_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> AccessKeyManager: ...

@typing.final
class CanExecuteRequestedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> CanExecuteRequestedEventArgs: ...
    @_property
    def can_execute(self) -> bool: ...
    @can_execute.setter
    def can_execute(self, value: bool) -> None: ...
    @_property
    def parameter(self) -> typing.Optional[winrt.system.Object]: ...

@typing.final
class CharacterReceivedRoutedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> CharacterReceivedRoutedEventArgs: ...
    @_property
    def handled(self) -> bool: ...
    @handled.setter
    def handled(self, value: bool) -> None: ...
    @_property
    def character(self) -> winrt.system.Char16: ...
    @_property
    def key_status(self) -> winrt.windows.ui.core.CorePhysicalKeyStatus: ...

@typing.final
class ContextRequestedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ContextRequestedEventArgs: ...
    def __new__(cls: typing.Type[ContextRequestedEventArgs]) -> ContextRequestedEventArgs:...
    def try_get_position(self, relative_to: typing.Optional[winrt.microsoft.ui.xaml.UIElement], /) -> typing.Tuple[bool, winrt.windows.foundation.Point]: ...
    @_property
    def handled(self) -> bool: ...
    @handled.setter
    def handled(self, value: bool) -> None: ...

@typing.final
class DoubleTappedRoutedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> DoubleTappedRoutedEventArgs: ...
    def __new__(cls: typing.Type[DoubleTappedRoutedEventArgs]) -> DoubleTappedRoutedEventArgs:...
    def get_position(self, relative_to: typing.Optional[winrt.microsoft.ui.xaml.UIElement], /) -> winrt.windows.foundation.Point: ...
    @_property
    def handled(self) -> bool: ...
    @handled.setter
    def handled(self, value: bool) -> None: ...
    @_property
    def pointer_device_type(self) -> winrt.microsoft.ui.input.PointerDeviceType: ...

@typing.final
class ExecuteRequestedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ExecuteRequestedEventArgs: ...
    @_property
    def parameter(self) -> typing.Optional[winrt.system.Object]: ...

@typing.final
class FindNextElementOptions(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> FindNextElementOptions: ...
    def __new__(cls: typing.Type[FindNextElementOptions]) -> FindNextElementOptions:...
    @_property
    def x_y_focus_navigation_strategy_override(self) -> XYFocusNavigationStrategyOverride: ...
    @x_y_focus_navigation_strategy_override.setter
    def x_y_focus_navigation_strategy_override(self, value: XYFocusNavigationStrategyOverride) -> None: ...
    @_property
    def search_root(self) -> typing.Optional[winrt.microsoft.ui.xaml.DependencyObject]: ...
    @search_root.setter
    def search_root(self, value: typing.Optional[winrt.microsoft.ui.xaml.DependencyObject]) -> None: ...
    @_property
    def hint_rect(self) -> winrt.windows.foundation.Rect: ...
    @hint_rect.setter
    def hint_rect(self, value: winrt.windows.foundation.Rect) -> None: ...
    @_property
    def exclusion_rect(self) -> winrt.windows.foundation.Rect: ...
    @exclusion_rect.setter
    def exclusion_rect(self, value: winrt.windows.foundation.Rect) -> None: ...

@typing.final
class FocusManager_Static(type):
    def find_first_focusable_element(cls, search_scope: typing.Optional[winrt.microsoft.ui.xaml.DependencyObject], /) -> typing.Optional[winrt.microsoft.ui.xaml.DependencyObject]: ...
    def find_last_focusable_element(cls, search_scope: typing.Optional[winrt.microsoft.ui.xaml.DependencyObject], /) -> typing.Optional[winrt.microsoft.ui.xaml.DependencyObject]: ...
    @typing.overload
    def find_next_element(cls, focus_navigation_direction: FocusNavigationDirection, /) -> typing.Optional[winrt.microsoft.ui.xaml.DependencyObject]: ...
    @typing.overload
    def find_next_element(cls, focus_navigation_direction: FocusNavigationDirection, focus_navigation_options: typing.Optional[FindNextElementOptions], /) -> typing.Optional[winrt.microsoft.ui.xaml.DependencyObject]: ...
    @typing.overload
    def find_next_focusable_element(cls, focus_navigation_direction: FocusNavigationDirection, /) -> typing.Optional[winrt.microsoft.ui.xaml.UIElement]: ...
    @typing.overload
    def find_next_focusable_element(cls, focus_navigation_direction: FocusNavigationDirection, hint_rect: winrt.windows.foundation.Rect, /) -> typing.Optional[winrt.microsoft.ui.xaml.UIElement]: ...
    @typing.overload
    def get_focused_element(cls) -> typing.Optional[winrt.system.Object]: ...
    @typing.overload
    def get_focused_element(cls, xaml_root: typing.Optional[winrt.microsoft.ui.xaml.XamlRoot], /) -> typing.Optional[winrt.system.Object]: ...
    def try_focus_async(cls, element: typing.Optional[winrt.microsoft.ui.xaml.DependencyObject], value: winrt.microsoft.ui.xaml.FocusState, /) -> winrt.windows.foundation.IAsyncOperation[FocusMovementResult]: ...
    @typing.overload
    def try_move_focus(cls, focus_navigation_direction: FocusNavigationDirection, /) -> bool: ...
    @typing.overload
    def try_move_focus(cls, focus_navigation_direction: FocusNavigationDirection, focus_navigation_options: typing.Optional[FindNextElementOptions], /) -> bool: ...
    @typing.overload
    def try_move_focus_async(cls, focus_navigation_direction: FocusNavigationDirection, /) -> winrt.windows.foundation.IAsyncOperation[FocusMovementResult]: ...
    @typing.overload
    def try_move_focus_async(cls, focus_navigation_direction: FocusNavigationDirection, focus_navigation_options: typing.Optional[FindNextElementOptions], /) -> winrt.windows.foundation.IAsyncOperation[FocusMovementResult]: ...
    def add_getting_focus(cls, handler: winrt.windows.foundation.EventHandler[GettingFocusEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_getting_focus(cls, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_got_focus(cls, handler: winrt.windows.foundation.EventHandler[FocusManagerGotFocusEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_got_focus(cls, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_losing_focus(cls, handler: winrt.windows.foundation.EventHandler[LosingFocusEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_losing_focus(cls, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_lost_focus(cls, handler: winrt.windows.foundation.EventHandler[FocusManagerLostFocusEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_lost_focus(cls, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...

@typing.final
class FocusManager(winrt.system.Object, metaclass=FocusManager_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> FocusManager: ...

@typing.final
class FocusManagerGotFocusEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> FocusManagerGotFocusEventArgs: ...
    @_property
    def correlation_id(self) -> _uuid.UUID: ...
    @_property
    def new_focused_element(self) -> typing.Optional[winrt.microsoft.ui.xaml.DependencyObject]: ...

@typing.final
class FocusManagerLostFocusEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> FocusManagerLostFocusEventArgs: ...
    @_property
    def correlation_id(self) -> _uuid.UUID: ...
    @_property
    def old_focused_element(self) -> typing.Optional[winrt.microsoft.ui.xaml.DependencyObject]: ...

@typing.final
class FocusMovementResult(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> FocusMovementResult: ...
    @_property
    def succeeded(self) -> bool: ...

@typing.final
class GettingFocusEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> GettingFocusEventArgs: ...
    def try_cancel(self) -> bool: ...
    def try_set_new_focused_element(self, element: typing.Optional[winrt.microsoft.ui.xaml.DependencyObject], /) -> bool: ...
    @_property
    def new_focused_element(self) -> typing.Optional[winrt.microsoft.ui.xaml.DependencyObject]: ...
    @new_focused_element.setter
    def new_focused_element(self, value: typing.Optional[winrt.microsoft.ui.xaml.DependencyObject]) -> None: ...
    @_property
    def handled(self) -> bool: ...
    @handled.setter
    def handled(self, value: bool) -> None: ...
    @_property
    def cancel(self) -> bool: ...
    @cancel.setter
    def cancel(self, value: bool) -> None: ...
    @_property
    def correlation_id(self) -> _uuid.UUID: ...
    @_property
    def direction(self) -> FocusNavigationDirection: ...
    @_property
    def focus_state(self) -> winrt.microsoft.ui.xaml.FocusState: ...
    @_property
    def input_device(self) -> FocusInputDeviceKind: ...
    @_property
    def old_focused_element(self) -> typing.Optional[winrt.microsoft.ui.xaml.DependencyObject]: ...

@typing.final
class HoldingRoutedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> HoldingRoutedEventArgs: ...
    def __new__(cls: typing.Type[HoldingRoutedEventArgs]) -> HoldingRoutedEventArgs:...
    def get_position(self, relative_to: typing.Optional[winrt.microsoft.ui.xaml.UIElement], /) -> winrt.windows.foundation.Point: ...
    @_property
    def handled(self) -> bool: ...
    @handled.setter
    def handled(self, value: bool) -> None: ...
    @_property
    def holding_state(self) -> winrt.microsoft.ui.input.HoldingState: ...
    @_property
    def pointer_device_type(self) -> winrt.microsoft.ui.input.PointerDeviceType: ...

@typing.final
class InertiaExpansionBehavior(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> InertiaExpansionBehavior: ...
    @_property
    def desired_expansion(self) -> winrt.system.Double: ...
    @desired_expansion.setter
    def desired_expansion(self, value: winrt.system.Double) -> None: ...
    @_property
    def desired_deceleration(self) -> winrt.system.Double: ...
    @desired_deceleration.setter
    def desired_deceleration(self, value: winrt.system.Double) -> None: ...

@typing.final
class InertiaRotationBehavior(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> InertiaRotationBehavior: ...
    @_property
    def desired_rotation(self) -> winrt.system.Double: ...
    @desired_rotation.setter
    def desired_rotation(self, value: winrt.system.Double) -> None: ...
    @_property
    def desired_deceleration(self) -> winrt.system.Double: ...
    @desired_deceleration.setter
    def desired_deceleration(self, value: winrt.system.Double) -> None: ...

@typing.final
class InertiaTranslationBehavior(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> InertiaTranslationBehavior: ...
    @_property
    def desired_displacement(self) -> winrt.system.Double: ...
    @desired_displacement.setter
    def desired_displacement(self, value: winrt.system.Double) -> None: ...
    @_property
    def desired_deceleration(self) -> winrt.system.Double: ...
    @desired_deceleration.setter
    def desired_deceleration(self, value: winrt.system.Double) -> None: ...

@typing.final
class InputScope(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> InputScope: ...
    def __new__(cls: typing.Type[InputScope]) -> InputScope:...
    @_property
    def names(self) -> typing.Optional[winrt.windows.foundation.collections.IVector[InputScopeName]]: ...

@typing.final
class InputScopeName(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> InputScopeName: ...
    @typing.overload
    def __new__(cls: typing.Type[InputScopeName], name_value: InputScopeNameValue) -> InputScopeName:...
    @typing.overload
    def __new__(cls: typing.Type[InputScopeName]) -> InputScopeName:...
    @_property
    def name_value(self) -> InputScopeNameValue: ...
    @name_value.setter
    def name_value(self, value: InputScopeNameValue) -> None: ...

@typing.final
class KeyRoutedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> KeyRoutedEventArgs: ...
    @_property
    def handled(self) -> bool: ...
    @handled.setter
    def handled(self, value: bool) -> None: ...
    @_property
    def device_id(self) -> str: ...
    @_property
    def key(self) -> winrt.windows.system.VirtualKey: ...
    @_property
    def key_status(self) -> winrt.windows.ui.core.CorePhysicalKeyStatus: ...
    @_property
    def original_key(self) -> winrt.windows.system.VirtualKey: ...

@typing.final
class KeyboardAccelerator_Static(type):
    @_property
    def is_enabled_property(cls) -> typing.Optional[winrt.microsoft.ui.xaml.DependencyProperty]: ...
    @_property
    def key_property(cls) -> typing.Optional[winrt.microsoft.ui.xaml.DependencyProperty]: ...
    @_property
    def modifiers_property(cls) -> typing.Optional[winrt.microsoft.ui.xaml.DependencyProperty]: ...
    @_property
    def scope_owner_property(cls) -> typing.Optional[winrt.microsoft.ui.xaml.DependencyProperty]: ...

@typing.final
class KeyboardAccelerator(winrt.system.Object, metaclass=KeyboardAccelerator_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> KeyboardAccelerator: ...
    def __new__(cls: typing.Type[KeyboardAccelerator]) -> KeyboardAccelerator:...
    def add_invoked(self, handler: winrt.windows.foundation.TypedEventHandler[KeyboardAccelerator, KeyboardAcceleratorInvokedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_invoked(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    @_property
    def scope_owner(self) -> typing.Optional[winrt.microsoft.ui.xaml.DependencyObject]: ...
    @scope_owner.setter
    def scope_owner(self, value: typing.Optional[winrt.microsoft.ui.xaml.DependencyObject]) -> None: ...
    @_property
    def modifiers(self) -> winrt.windows.system.VirtualKeyModifiers: ...
    @modifiers.setter
    def modifiers(self, value: winrt.windows.system.VirtualKeyModifiers) -> None: ...
    @_property
    def key(self) -> winrt.windows.system.VirtualKey: ...
    @key.setter
    def key(self, value: winrt.windows.system.VirtualKey) -> None: ...
    @_property
    def is_enabled(self) -> bool: ...
    @is_enabled.setter
    def is_enabled(self, value: bool) -> None: ...

@typing.final
class KeyboardAcceleratorInvokedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> KeyboardAcceleratorInvokedEventArgs: ...
    @_property
    def handled(self) -> bool: ...
    @handled.setter
    def handled(self, value: bool) -> None: ...
    @_property
    def element(self) -> typing.Optional[winrt.microsoft.ui.xaml.DependencyObject]: ...
    @_property
    def keyboard_accelerator(self) -> typing.Optional[KeyboardAccelerator]: ...

@typing.final
class LosingFocusEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> LosingFocusEventArgs: ...
    def try_cancel(self) -> bool: ...
    def try_set_new_focused_element(self, element: typing.Optional[winrt.microsoft.ui.xaml.DependencyObject], /) -> bool: ...
    @_property
    def new_focused_element(self) -> typing.Optional[winrt.microsoft.ui.xaml.DependencyObject]: ...
    @new_focused_element.setter
    def new_focused_element(self, value: typing.Optional[winrt.microsoft.ui.xaml.DependencyObject]) -> None: ...
    @_property
    def handled(self) -> bool: ...
    @handled.setter
    def handled(self, value: bool) -> None: ...
    @_property
    def cancel(self) -> bool: ...
    @cancel.setter
    def cancel(self, value: bool) -> None: ...
    @_property
    def correlation_id(self) -> _uuid.UUID: ...
    @_property
    def direction(self) -> FocusNavigationDirection: ...
    @_property
    def focus_state(self) -> winrt.microsoft.ui.xaml.FocusState: ...
    @_property
    def input_device(self) -> FocusInputDeviceKind: ...
    @_property
    def old_focused_element(self) -> typing.Optional[winrt.microsoft.ui.xaml.DependencyObject]: ...

@typing.final
class ManipulationCompletedRoutedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ManipulationCompletedRoutedEventArgs: ...
    def __new__(cls: typing.Type[ManipulationCompletedRoutedEventArgs]) -> ManipulationCompletedRoutedEventArgs:...
    @_property
    def handled(self) -> bool: ...
    @handled.setter
    def handled(self, value: bool) -> None: ...
    @_property
    def container(self) -> typing.Optional[winrt.microsoft.ui.xaml.UIElement]: ...
    @_property
    def cumulative(self) -> winrt.microsoft.ui.input.ManipulationDelta: ...
    @_property
    def is_inertial(self) -> bool: ...
    @_property
    def pointer_device_type(self) -> winrt.microsoft.ui.input.PointerDeviceType: ...
    @_property
    def position(self) -> winrt.windows.foundation.Point: ...
    @_property
    def velocities(self) -> winrt.microsoft.ui.input.ManipulationVelocities: ...

@typing.final
class ManipulationDeltaRoutedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ManipulationDeltaRoutedEventArgs: ...
    def __new__(cls: typing.Type[ManipulationDeltaRoutedEventArgs]) -> ManipulationDeltaRoutedEventArgs:...
    def complete(self) -> None: ...
    @_property
    def handled(self) -> bool: ...
    @handled.setter
    def handled(self, value: bool) -> None: ...
    @_property
    def container(self) -> typing.Optional[winrt.microsoft.ui.xaml.UIElement]: ...
    @_property
    def cumulative(self) -> winrt.microsoft.ui.input.ManipulationDelta: ...
    @_property
    def delta(self) -> winrt.microsoft.ui.input.ManipulationDelta: ...
    @_property
    def is_inertial(self) -> bool: ...
    @_property
    def pointer_device_type(self) -> winrt.microsoft.ui.input.PointerDeviceType: ...
    @_property
    def position(self) -> winrt.windows.foundation.Point: ...
    @_property
    def velocities(self) -> winrt.microsoft.ui.input.ManipulationVelocities: ...

@typing.final
class ManipulationInertiaStartingRoutedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ManipulationInertiaStartingRoutedEventArgs: ...
    def __new__(cls: typing.Type[ManipulationInertiaStartingRoutedEventArgs]) -> ManipulationInertiaStartingRoutedEventArgs:...
    @_property
    def translation_behavior(self) -> typing.Optional[InertiaTranslationBehavior]: ...
    @translation_behavior.setter
    def translation_behavior(self, value: typing.Optional[InertiaTranslationBehavior]) -> None: ...
    @_property
    def rotation_behavior(self) -> typing.Optional[InertiaRotationBehavior]: ...
    @rotation_behavior.setter
    def rotation_behavior(self, value: typing.Optional[InertiaRotationBehavior]) -> None: ...
    @_property
    def handled(self) -> bool: ...
    @handled.setter
    def handled(self, value: bool) -> None: ...
    @_property
    def expansion_behavior(self) -> typing.Optional[InertiaExpansionBehavior]: ...
    @expansion_behavior.setter
    def expansion_behavior(self, value: typing.Optional[InertiaExpansionBehavior]) -> None: ...
    @_property
    def container(self) -> typing.Optional[winrt.microsoft.ui.xaml.UIElement]: ...
    @_property
    def cumulative(self) -> winrt.microsoft.ui.input.ManipulationDelta: ...
    @_property
    def delta(self) -> winrt.microsoft.ui.input.ManipulationDelta: ...
    @_property
    def pointer_device_type(self) -> winrt.microsoft.ui.input.PointerDeviceType: ...
    @_property
    def velocities(self) -> winrt.microsoft.ui.input.ManipulationVelocities: ...

@typing.final
class ManipulationPivot(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ManipulationPivot: ...
    @typing.overload
    def __new__(cls: typing.Type[ManipulationPivot], center: winrt.windows.foundation.Point, radius: winrt.system.Double) -> ManipulationPivot:...
    @typing.overload
    def __new__(cls: typing.Type[ManipulationPivot]) -> ManipulationPivot:...
    @_property
    def radius(self) -> winrt.system.Double: ...
    @radius.setter
    def radius(self, value: winrt.system.Double) -> None: ...
    @_property
    def center(self) -> winrt.windows.foundation.Point: ...
    @center.setter
    def center(self, value: winrt.windows.foundation.Point) -> None: ...

@typing.final
class ManipulationStartedRoutedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ManipulationStartedRoutedEventArgs: ...
    def __new__(cls: typing.Type[ManipulationStartedRoutedEventArgs]) -> ManipulationStartedRoutedEventArgs:...
    def complete(self) -> None: ...
    @_property
    def handled(self) -> bool: ...
    @handled.setter
    def handled(self, value: bool) -> None: ...
    @_property
    def container(self) -> typing.Optional[winrt.microsoft.ui.xaml.UIElement]: ...
    @_property
    def cumulative(self) -> winrt.microsoft.ui.input.ManipulationDelta: ...
    @_property
    def pointer_device_type(self) -> winrt.microsoft.ui.input.PointerDeviceType: ...
    @_property
    def position(self) -> winrt.windows.foundation.Point: ...

@typing.final
class ManipulationStartingRoutedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ManipulationStartingRoutedEventArgs: ...
    def __new__(cls: typing.Type[ManipulationStartingRoutedEventArgs]) -> ManipulationStartingRoutedEventArgs:...
    @_property
    def pivot(self) -> typing.Optional[ManipulationPivot]: ...
    @pivot.setter
    def pivot(self, value: typing.Optional[ManipulationPivot]) -> None: ...
    @_property
    def mode(self) -> ManipulationModes: ...
    @mode.setter
    def mode(self, value: ManipulationModes) -> None: ...
    @_property
    def handled(self) -> bool: ...
    @handled.setter
    def handled(self, value: bool) -> None: ...
    @_property
    def container(self) -> typing.Optional[winrt.microsoft.ui.xaml.UIElement]: ...
    @container.setter
    def container(self, value: typing.Optional[winrt.microsoft.ui.xaml.UIElement]) -> None: ...

@typing.final
class NoFocusCandidateFoundEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> NoFocusCandidateFoundEventArgs: ...
    @_property
    def handled(self) -> bool: ...
    @handled.setter
    def handled(self, value: bool) -> None: ...
    @_property
    def direction(self) -> FocusNavigationDirection: ...
    @_property
    def input_device(self) -> FocusInputDeviceKind: ...

@typing.final
class Pointer(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> Pointer: ...
    @_property
    def is_in_contact(self) -> bool: ...
    @_property
    def is_in_range(self) -> bool: ...
    @_property
    def pointer_device_type(self) -> winrt.microsoft.ui.input.PointerDeviceType: ...
    @_property
    def pointer_id(self) -> winrt.system.UInt32: ...

@typing.final
class PointerRoutedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> PointerRoutedEventArgs: ...
    def get_current_point(self, relative_to: typing.Optional[winrt.microsoft.ui.xaml.UIElement], /) -> typing.Optional[winrt.microsoft.ui.input.PointerPoint]: ...
    def get_intermediate_points(self, relative_to: typing.Optional[winrt.microsoft.ui.xaml.UIElement], /) -> typing.Optional[winrt.windows.foundation.collections.IVector[winrt.microsoft.ui.input.PointerPoint]]: ...
    @_property
    def handled(self) -> bool: ...
    @handled.setter
    def handled(self, value: bool) -> None: ...
    @_property
    def is_generated(self) -> bool: ...
    @_property
    def key_modifiers(self) -> winrt.windows.system.VirtualKeyModifiers: ...
    @_property
    def pointer(self) -> typing.Optional[Pointer]: ...

@typing.final
class ProcessKeyboardAcceleratorEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ProcessKeyboardAcceleratorEventArgs: ...
    @_property
    def handled(self) -> bool: ...
    @handled.setter
    def handled(self, value: bool) -> None: ...
    @_property
    def key(self) -> winrt.windows.system.VirtualKey: ...
    @_property
    def modifiers(self) -> winrt.windows.system.VirtualKeyModifiers: ...

@typing.final
class RightTappedRoutedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> RightTappedRoutedEventArgs: ...
    def __new__(cls: typing.Type[RightTappedRoutedEventArgs]) -> RightTappedRoutedEventArgs:...
    def get_position(self, relative_to: typing.Optional[winrt.microsoft.ui.xaml.UIElement], /) -> winrt.windows.foundation.Point: ...
    @_property
    def handled(self) -> bool: ...
    @handled.setter
    def handled(self, value: bool) -> None: ...
    @_property
    def pointer_device_type(self) -> winrt.microsoft.ui.input.PointerDeviceType: ...

@typing.final
class StandardUICommand_Static(type):
    @_property
    def kind_property(cls) -> typing.Optional[winrt.microsoft.ui.xaml.DependencyProperty]: ...

@typing.final
class StandardUICommand(winrt.system.Object, metaclass=StandardUICommand_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> StandardUICommand: ...
    @typing.overload
    def __new__(cls: typing.Type[StandardUICommand]) -> StandardUICommand:...
    @typing.overload
    def __new__(cls: typing.Type[StandardUICommand], kind: StandardUICommandKind) -> StandardUICommand:...
    @_property
    def kind(self) -> StandardUICommandKind: ...
    @kind.setter
    def kind(self, value: StandardUICommandKind) -> None: ...

@typing.final
class TappedRoutedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> TappedRoutedEventArgs: ...
    def __new__(cls: typing.Type[TappedRoutedEventArgs]) -> TappedRoutedEventArgs:...
    def get_position(self, relative_to: typing.Optional[winrt.microsoft.ui.xaml.UIElement], /) -> winrt.windows.foundation.Point: ...
    @_property
    def handled(self) -> bool: ...
    @handled.setter
    def handled(self, value: bool) -> None: ...
    @_property
    def pointer_device_type(self) -> winrt.microsoft.ui.input.PointerDeviceType: ...

@typing.final
class XamlUICommand_Static(type):
    @_property
    def access_key_property(cls) -> typing.Optional[winrt.microsoft.ui.xaml.DependencyProperty]: ...
    @_property
    def command_property(cls) -> typing.Optional[winrt.microsoft.ui.xaml.DependencyProperty]: ...
    @_property
    def description_property(cls) -> typing.Optional[winrt.microsoft.ui.xaml.DependencyProperty]: ...
    @_property
    def icon_source_property(cls) -> typing.Optional[winrt.microsoft.ui.xaml.DependencyProperty]: ...
    @_property
    def keyboard_accelerators_property(cls) -> typing.Optional[winrt.microsoft.ui.xaml.DependencyProperty]: ...
    @_property
    def label_property(cls) -> typing.Optional[winrt.microsoft.ui.xaml.DependencyProperty]: ...

@typing.final
class XamlUICommand(winrt.system.Object, metaclass=XamlUICommand_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> XamlUICommand: ...
    def __new__(cls: typing.Type[XamlUICommand]) -> XamlUICommand:...
    def can_execute(self, parameter: typing.Optional[winrt.system.Object], /) -> bool: ...
    def execute(self, parameter: typing.Optional[winrt.system.Object], /) -> None: ...
    def notify_can_execute_changed(self) -> None: ...
    def add_can_execute_requested(self, handler: winrt.windows.foundation.TypedEventHandler[XamlUICommand, CanExecuteRequestedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_can_execute_requested(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_execute_requested(self, handler: winrt.windows.foundation.TypedEventHandler[XamlUICommand, ExecuteRequestedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_execute_requested(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_can_execute_changed(self, handler: winrt.windows.foundation.EventHandler[winrt.system.Object], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_can_execute_changed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    @_property
    def label(self) -> str: ...
    @label.setter
    def label(self, value: str) -> None: ...
    @_property
    def icon_source(self) -> typing.Optional[winrt.microsoft.ui.xaml.controls.IconSource]: ...
    @icon_source.setter
    def icon_source(self, value: typing.Optional[winrt.microsoft.ui.xaml.controls.IconSource]) -> None: ...
    @_property
    def description(self) -> str: ...
    @description.setter
    def description(self, value: str) -> None: ...
    @_property
    def command(self) -> typing.Optional[ICommand]: ...
    @command.setter
    def command(self, value: typing.Optional[ICommand]) -> None: ...
    @_property
    def access_key(self) -> str: ...
    @access_key.setter
    def access_key(self, value: str) -> None: ...
    @_property
    def keyboard_accelerators(self) -> typing.Optional[winrt.windows.foundation.collections.IVector[KeyboardAccelerator]]: ...

@typing.final
class ICommand(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ICommand: ...
    def can_execute(self, parameter: typing.Optional[winrt.system.Object], /) -> bool: ...
    def execute(self, parameter: typing.Optional[winrt.system.Object], /) -> None: ...
    def add_can_execute_changed(self, handler: winrt.windows.foundation.EventHandler[winrt.system.Object], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_can_execute_changed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...

