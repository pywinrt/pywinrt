# WARNING: Please don't edit this file. It was generated by Python/WinRT v2.1.0

import datetime
import sys
import types
import typing
import uuid as _uuid
from builtins import property as _property

import winrt._winrt
import winrt.system
import winrt.windows.foundation as windows_foundation
import winrt.windows.foundation.collections as windows_foundation_collections
import winrt.windows.storage.streams as windows_storage_streams

from winrt.windows.services.targetedcontent import TargetedContentAppInstallationState, TargetedContentAvailability, TargetedContentInteraction, TargetedContentObjectKind, TargetedContentValueKind

Self = typing.TypeVar('Self')

@typing.final
class TargetedContentAction(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> TargetedContentAction: ...
    def invoke_async(self) -> windows_foundation.IAsyncAction: ...

@typing.final
class TargetedContentAvailabilityChangedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> TargetedContentAvailabilityChangedEventArgs: ...
    def get_deferral(self) -> typing.Optional[windows_foundation.Deferral]: ...

@typing.final
class TargetedContentChangedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> TargetedContentChangedEventArgs: ...
    def get_deferral(self) -> typing.Optional[windows_foundation.Deferral]: ...
    @_property
    def has_previous_content_expired(self) -> bool: ...

@typing.final
class TargetedContentCollection(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> TargetedContentCollection: ...
    def report_custom_interaction(self, custom_interaction_name: str, /) -> None: ...
    def report_interaction(self, interaction: TargetedContentInteraction, /) -> None: ...
    @_property
    def collections(self) -> typing.Optional[windows_foundation_collections.IVectorView[TargetedContentCollection]]: ...
    @_property
    def id(self) -> str: ...
    @_property
    def items(self) -> typing.Optional[windows_foundation_collections.IVectorView[TargetedContentItem]]: ...
    @_property
    def path(self) -> str: ...
    @_property
    def properties(self) -> typing.Optional[windows_foundation_collections.IMapView[str, TargetedContentValue]]: ...

@typing.final
class TargetedContentContainer_Static(type):
    def get_async(cls, content_id: str, /) -> windows_foundation.IAsyncOperation[TargetedContentContainer]: ...

@typing.final
class TargetedContentContainer(winrt.system.Object, metaclass=TargetedContentContainer_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> TargetedContentContainer: ...
    def select_single_object(self, path: str, /) -> typing.Optional[TargetedContentObject]: ...
    @_property
    def availability(self) -> TargetedContentAvailability: ...
    @_property
    def content(self) -> typing.Optional[TargetedContentCollection]: ...
    @_property
    def id(self) -> str: ...
    @_property
    def timestamp(self) -> datetime.datetime: ...

@typing.final
class TargetedContentFile(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> TargetedContentFile: ...
    def open_read_async(self) -> windows_foundation.IAsyncOperation[windows_storage_streams.IRandomAccessStreamWithContentType]: ...

@typing.final
class TargetedContentImage(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> TargetedContentImage: ...
    def open_read_async(self) -> windows_foundation.IAsyncOperation[windows_storage_streams.IRandomAccessStreamWithContentType]: ...
    @_property
    def height(self) -> winrt.system.UInt32: ...
    @_property
    def width(self) -> winrt.system.UInt32: ...

@typing.final
class TargetedContentItem(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> TargetedContentItem: ...
    def report_custom_interaction(self, custom_interaction_name: str, /) -> None: ...
    def report_interaction(self, interaction: TargetedContentInteraction, /) -> None: ...
    @_property
    def collections(self) -> typing.Optional[windows_foundation_collections.IVectorView[TargetedContentCollection]]: ...
    @_property
    def path(self) -> str: ...
    @_property
    def properties(self) -> typing.Optional[windows_foundation_collections.IMapView[str, TargetedContentValue]]: ...
    @_property
    def state(self) -> typing.Optional[TargetedContentItemState]: ...

@typing.final
class TargetedContentItemState(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> TargetedContentItemState: ...
    @_property
    def app_installation_state(self) -> TargetedContentAppInstallationState: ...
    @_property
    def should_display(self) -> bool: ...

@typing.final
class TargetedContentObject(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> TargetedContentObject: ...
    @_property
    def collection(self) -> typing.Optional[TargetedContentCollection]: ...
    @_property
    def item(self) -> typing.Optional[TargetedContentItem]: ...
    @_property
    def object_kind(self) -> TargetedContentObjectKind: ...
    @_property
    def value(self) -> typing.Optional[TargetedContentValue]: ...

@typing.final
class TargetedContentStateChangedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> TargetedContentStateChangedEventArgs: ...
    def get_deferral(self) -> typing.Optional[windows_foundation.Deferral]: ...

@typing.final
class TargetedContentSubscription_Static(type):
    def get_async(cls, subscription_id: str, /) -> windows_foundation.IAsyncOperation[TargetedContentSubscription]: ...
    def get_options(cls, subscription_id: str, /) -> typing.Optional[TargetedContentSubscriptionOptions]: ...

@typing.final
class TargetedContentSubscription(winrt.system.Object, metaclass=TargetedContentSubscription_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> TargetedContentSubscription: ...
    def get_content_container_async(self) -> windows_foundation.IAsyncOperation[TargetedContentContainer]: ...
    def add_availability_changed(self, handler: windows_foundation.TypedEventHandler[TargetedContentSubscription, TargetedContentAvailabilityChangedEventArgs], /) -> windows_foundation.EventRegistrationToken: ...
    def remove_availability_changed(self, cookie: windows_foundation.EventRegistrationToken, /) -> None: ...
    def add_content_changed(self, handler: windows_foundation.TypedEventHandler[TargetedContentSubscription, TargetedContentChangedEventArgs], /) -> windows_foundation.EventRegistrationToken: ...
    def remove_content_changed(self, cookie: windows_foundation.EventRegistrationToken, /) -> None: ...
    def add_state_changed(self, handler: windows_foundation.TypedEventHandler[TargetedContentSubscription, TargetedContentStateChangedEventArgs], /) -> windows_foundation.EventRegistrationToken: ...
    def remove_state_changed(self, cookie: windows_foundation.EventRegistrationToken, /) -> None: ...
    @_property
    def id(self) -> str: ...

@typing.final
class TargetedContentSubscriptionOptions(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> TargetedContentSubscriptionOptions: ...
    def update(self) -> None: ...
    @_property
    def allow_partial_content_availability(self) -> bool: ...
    @allow_partial_content_availability.setter
    def allow_partial_content_availability(self, value: bool) -> None: ...
    @_property
    def cloud_query_parameters(self) -> typing.Optional[windows_foundation_collections.IMap[str, str]]: ...
    @_property
    def local_filters(self) -> typing.Optional[windows_foundation_collections.IVector[str]]: ...
    @_property
    def subscription_id(self) -> str: ...

@typing.final
class TargetedContentValue(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> TargetedContentValue: ...
    @_property
    def action(self) -> typing.Optional[TargetedContentAction]: ...
    @_property
    def actions(self) -> typing.Optional[windows_foundation_collections.IVectorView[TargetedContentAction]]: ...
    @_property
    def boolean(self) -> bool: ...
    @_property
    def booleans(self) -> typing.Optional[windows_foundation_collections.IVectorView[bool]]: ...
    @_property
    def file(self) -> typing.Optional[TargetedContentFile]: ...
    @_property
    def files(self) -> typing.Optional[windows_foundation_collections.IVectorView[TargetedContentFile]]: ...
    @_property
    def image_file(self) -> typing.Optional[TargetedContentImage]: ...
    @_property
    def image_files(self) -> typing.Optional[windows_foundation_collections.IVectorView[TargetedContentImage]]: ...
    @_property
    def number(self) -> winrt.system.Double: ...
    @_property
    def numbers(self) -> typing.Optional[windows_foundation_collections.IVectorView[winrt.system.Double]]: ...
    @_property
    def path(self) -> str: ...
    @_property
    def string(self) -> str: ...
    @_property
    def strings(self) -> typing.Optional[windows_foundation_collections.IVectorView[str]]: ...
    @_property
    def uri(self) -> typing.Optional[windows_foundation.Uri]: ...
    @_property
    def uris(self) -> typing.Optional[windows_foundation_collections.IVectorView[windows_foundation.Uri]]: ...
    @_property
    def value_kind(self) -> TargetedContentValueKind: ...

