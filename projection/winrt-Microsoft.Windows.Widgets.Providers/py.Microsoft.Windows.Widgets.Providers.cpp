// WARNING: Please don't edit this file. It was generated by Python/WinRT v2.0.0-beta.2

#include "py.Microsoft.Windows.Widgets.Providers.h"


namespace py::cpp::Microsoft::Windows::Widgets::Providers
{
    // ----- WidgetActionInvokedArgs class --------------------

    static PyObject* _new_WidgetActionInvokedArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::Windows::Widgets::Providers::WidgetActionInvokedArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::Windows::Widgets::Providers::WidgetActionInvokedArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_WidgetActionInvokedArgs(py::wrapper::Microsoft::Windows::Widgets::Providers::WidgetActionInvokedArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* WidgetActionInvokedArgs_get_CustomState(py::wrapper::Microsoft::Windows::Widgets::Providers::WidgetActionInvokedArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.Widgets.Providers.WidgetActionInvokedArgs", L"CustomState"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CustomState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WidgetActionInvokedArgs_get_Data(py::wrapper::Microsoft::Windows::Widgets::Providers::WidgetActionInvokedArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.Widgets.Providers.WidgetActionInvokedArgs", L"Data"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Data());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WidgetActionInvokedArgs_get_Verb(py::wrapper::Microsoft::Windows::Widgets::Providers::WidgetActionInvokedArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.Widgets.Providers.WidgetActionInvokedArgs", L"Verb"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Verb());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WidgetActionInvokedArgs_get_WidgetContext(py::wrapper::Microsoft::Windows::Widgets::Providers::WidgetActionInvokedArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.Widgets.Providers.WidgetActionInvokedArgs", L"WidgetContext"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.WidgetContext());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_WidgetActionInvokedArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::Windows::Widgets::Providers::WidgetActionInvokedArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_WidgetActionInvokedArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::Windows::Widgets::Providers::WidgetActionInvokedArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_WidgetActionInvokedArgs[] = {
        { "_assign_array_", _assign_array_WidgetActionInvokedArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_WidgetActionInvokedArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_WidgetActionInvokedArgs[] = {
        { "custom_state", reinterpret_cast<getter>(WidgetActionInvokedArgs_get_CustomState), nullptr, nullptr, nullptr },
        { "data", reinterpret_cast<getter>(WidgetActionInvokedArgs_get_Data), nullptr, nullptr, nullptr },
        { "verb", reinterpret_cast<getter>(WidgetActionInvokedArgs_get_Verb), nullptr, nullptr, nullptr },
        { "widget_context", reinterpret_cast<getter>(WidgetActionInvokedArgs_get_WidgetContext), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_WidgetActionInvokedArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_WidgetActionInvokedArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_WidgetActionInvokedArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_WidgetActionInvokedArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_WidgetActionInvokedArgs) },
        { },
    };

    static PyType_Spec type_spec_WidgetActionInvokedArgs =
    {
        "winrt._winrt_microsoft_windows_widgets_providers.WidgetActionInvokedArgs",
        sizeof(py::wrapper::Microsoft::Windows::Widgets::Providers::WidgetActionInvokedArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_WidgetActionInvokedArgs
    };

    // ----- WidgetAnalyticsInfoReportedArgs class --------------------

    static PyObject* _new_WidgetAnalyticsInfoReportedArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::Windows::Widgets::Providers::WidgetAnalyticsInfoReportedArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::Windows::Widgets::Providers::WidgetAnalyticsInfoReportedArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_WidgetAnalyticsInfoReportedArgs(py::wrapper::Microsoft::Windows::Widgets::Providers::WidgetAnalyticsInfoReportedArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* WidgetAnalyticsInfoReportedArgs_get_AnalyticsJson(py::wrapper::Microsoft::Windows::Widgets::Providers::WidgetAnalyticsInfoReportedArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.Widgets.Providers.WidgetAnalyticsInfoReportedArgs", L"AnalyticsJson"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AnalyticsJson());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WidgetAnalyticsInfoReportedArgs_get_WidgetContext(py::wrapper::Microsoft::Windows::Widgets::Providers::WidgetAnalyticsInfoReportedArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.Widgets.Providers.WidgetAnalyticsInfoReportedArgs", L"WidgetContext"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.WidgetContext());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_WidgetAnalyticsInfoReportedArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::Windows::Widgets::Providers::WidgetAnalyticsInfoReportedArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_WidgetAnalyticsInfoReportedArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::Windows::Widgets::Providers::WidgetAnalyticsInfoReportedArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_WidgetAnalyticsInfoReportedArgs[] = {
        { "_assign_array_", _assign_array_WidgetAnalyticsInfoReportedArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_WidgetAnalyticsInfoReportedArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_WidgetAnalyticsInfoReportedArgs[] = {
        { "analytics_json", reinterpret_cast<getter>(WidgetAnalyticsInfoReportedArgs_get_AnalyticsJson), nullptr, nullptr, nullptr },
        { "widget_context", reinterpret_cast<getter>(WidgetAnalyticsInfoReportedArgs_get_WidgetContext), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_WidgetAnalyticsInfoReportedArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_WidgetAnalyticsInfoReportedArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_WidgetAnalyticsInfoReportedArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_WidgetAnalyticsInfoReportedArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_WidgetAnalyticsInfoReportedArgs) },
        { },
    };

    static PyType_Spec type_spec_WidgetAnalyticsInfoReportedArgs =
    {
        "winrt._winrt_microsoft_windows_widgets_providers.WidgetAnalyticsInfoReportedArgs",
        sizeof(py::wrapper::Microsoft::Windows::Widgets::Providers::WidgetAnalyticsInfoReportedArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_WidgetAnalyticsInfoReportedArgs
    };

    // ----- WidgetContext class --------------------

    static PyObject* _new_WidgetContext(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::Windows::Widgets::Providers::WidgetContext>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::Windows::Widgets::Providers::WidgetContext>::type_name);
        return nullptr;
    }

    static void _dealloc_WidgetContext(py::wrapper::Microsoft::Windows::Widgets::Providers::WidgetContext* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* WidgetContext_get_DefinitionId(py::wrapper::Microsoft::Windows::Widgets::Providers::WidgetContext* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.Widgets.Providers.WidgetContext", L"DefinitionId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DefinitionId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WidgetContext_get_Id(py::wrapper::Microsoft::Windows::Widgets::Providers::WidgetContext* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.Widgets.Providers.WidgetContext", L"Id"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Id());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WidgetContext_get_IsActive(py::wrapper::Microsoft::Windows::Widgets::Providers::WidgetContext* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.Widgets.Providers.WidgetContext", L"IsActive"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsActive());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WidgetContext_get_Size(py::wrapper::Microsoft::Windows::Widgets::Providers::WidgetContext* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.Widgets.Providers.WidgetContext", L"Size"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_WidgetContext(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::Windows::Widgets::Providers::WidgetContext>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_WidgetContext(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::Windows::Widgets::Providers::WidgetContext>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_WidgetContext[] = {
        { "_assign_array_", _assign_array_WidgetContext, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_WidgetContext), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_WidgetContext[] = {
        { "definition_id", reinterpret_cast<getter>(WidgetContext_get_DefinitionId), nullptr, nullptr, nullptr },
        { "id", reinterpret_cast<getter>(WidgetContext_get_Id), nullptr, nullptr, nullptr },
        { "is_active", reinterpret_cast<getter>(WidgetContext_get_IsActive), nullptr, nullptr, nullptr },
        { "size", reinterpret_cast<getter>(WidgetContext_get_Size), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_WidgetContext[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_WidgetContext) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_WidgetContext) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_WidgetContext) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_WidgetContext) },
        { },
    };

    static PyType_Spec type_spec_WidgetContext =
    {
        "winrt._winrt_microsoft_windows_widgets_providers.WidgetContext",
        sizeof(py::wrapper::Microsoft::Windows::Widgets::Providers::WidgetContext),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_WidgetContext
    };

    // ----- WidgetContextChangedArgs class --------------------

    static PyObject* _new_WidgetContextChangedArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::Windows::Widgets::Providers::WidgetContextChangedArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::Windows::Widgets::Providers::WidgetContextChangedArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_WidgetContextChangedArgs(py::wrapper::Microsoft::Windows::Widgets::Providers::WidgetContextChangedArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* WidgetContextChangedArgs_get_WidgetContext(py::wrapper::Microsoft::Windows::Widgets::Providers::WidgetContextChangedArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.Widgets.Providers.WidgetContextChangedArgs", L"WidgetContext"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.WidgetContext());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_WidgetContextChangedArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::Windows::Widgets::Providers::WidgetContextChangedArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_WidgetContextChangedArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::Windows::Widgets::Providers::WidgetContextChangedArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_WidgetContextChangedArgs[] = {
        { "_assign_array_", _assign_array_WidgetContextChangedArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_WidgetContextChangedArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_WidgetContextChangedArgs[] = {
        { "widget_context", reinterpret_cast<getter>(WidgetContextChangedArgs_get_WidgetContext), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_WidgetContextChangedArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_WidgetContextChangedArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_WidgetContextChangedArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_WidgetContextChangedArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_WidgetContextChangedArgs) },
        { },
    };

    static PyType_Spec type_spec_WidgetContextChangedArgs =
    {
        "winrt._winrt_microsoft_windows_widgets_providers.WidgetContextChangedArgs",
        sizeof(py::wrapper::Microsoft::Windows::Widgets::Providers::WidgetContextChangedArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_WidgetContextChangedArgs
    };

    // ----- WidgetCustomizationRequestedArgs class --------------------

    static PyObject* _new_WidgetCustomizationRequestedArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::Windows::Widgets::Providers::WidgetCustomizationRequestedArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::Windows::Widgets::Providers::WidgetCustomizationRequestedArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_WidgetCustomizationRequestedArgs(py::wrapper::Microsoft::Windows::Widgets::Providers::WidgetCustomizationRequestedArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* WidgetCustomizationRequestedArgs_get_CustomState(py::wrapper::Microsoft::Windows::Widgets::Providers::WidgetCustomizationRequestedArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.Widgets.Providers.WidgetCustomizationRequestedArgs", L"CustomState"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CustomState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WidgetCustomizationRequestedArgs_get_WidgetContext(py::wrapper::Microsoft::Windows::Widgets::Providers::WidgetCustomizationRequestedArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.Widgets.Providers.WidgetCustomizationRequestedArgs", L"WidgetContext"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.WidgetContext());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_WidgetCustomizationRequestedArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::Windows::Widgets::Providers::WidgetCustomizationRequestedArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_WidgetCustomizationRequestedArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::Windows::Widgets::Providers::WidgetCustomizationRequestedArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_WidgetCustomizationRequestedArgs[] = {
        { "_assign_array_", _assign_array_WidgetCustomizationRequestedArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_WidgetCustomizationRequestedArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_WidgetCustomizationRequestedArgs[] = {
        { "custom_state", reinterpret_cast<getter>(WidgetCustomizationRequestedArgs_get_CustomState), nullptr, nullptr, nullptr },
        { "widget_context", reinterpret_cast<getter>(WidgetCustomizationRequestedArgs_get_WidgetContext), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_WidgetCustomizationRequestedArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_WidgetCustomizationRequestedArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_WidgetCustomizationRequestedArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_WidgetCustomizationRequestedArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_WidgetCustomizationRequestedArgs) },
        { },
    };

    static PyType_Spec type_spec_WidgetCustomizationRequestedArgs =
    {
        "winrt._winrt_microsoft_windows_widgets_providers.WidgetCustomizationRequestedArgs",
        sizeof(py::wrapper::Microsoft::Windows::Widgets::Providers::WidgetCustomizationRequestedArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_WidgetCustomizationRequestedArgs
    };

    // ----- WidgetErrorInfoReportedArgs class --------------------

    static PyObject* _new_WidgetErrorInfoReportedArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::Windows::Widgets::Providers::WidgetErrorInfoReportedArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::Windows::Widgets::Providers::WidgetErrorInfoReportedArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_WidgetErrorInfoReportedArgs(py::wrapper::Microsoft::Windows::Widgets::Providers::WidgetErrorInfoReportedArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* WidgetErrorInfoReportedArgs_get_ErrorJson(py::wrapper::Microsoft::Windows::Widgets::Providers::WidgetErrorInfoReportedArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.Widgets.Providers.WidgetErrorInfoReportedArgs", L"ErrorJson"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ErrorJson());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WidgetErrorInfoReportedArgs_get_WidgetContext(py::wrapper::Microsoft::Windows::Widgets::Providers::WidgetErrorInfoReportedArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.Widgets.Providers.WidgetErrorInfoReportedArgs", L"WidgetContext"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.WidgetContext());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_WidgetErrorInfoReportedArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::Windows::Widgets::Providers::WidgetErrorInfoReportedArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_WidgetErrorInfoReportedArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::Windows::Widgets::Providers::WidgetErrorInfoReportedArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_WidgetErrorInfoReportedArgs[] = {
        { "_assign_array_", _assign_array_WidgetErrorInfoReportedArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_WidgetErrorInfoReportedArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_WidgetErrorInfoReportedArgs[] = {
        { "error_json", reinterpret_cast<getter>(WidgetErrorInfoReportedArgs_get_ErrorJson), nullptr, nullptr, nullptr },
        { "widget_context", reinterpret_cast<getter>(WidgetErrorInfoReportedArgs_get_WidgetContext), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_WidgetErrorInfoReportedArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_WidgetErrorInfoReportedArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_WidgetErrorInfoReportedArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_WidgetErrorInfoReportedArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_WidgetErrorInfoReportedArgs) },
        { },
    };

    static PyType_Spec type_spec_WidgetErrorInfoReportedArgs =
    {
        "winrt._winrt_microsoft_windows_widgets_providers.WidgetErrorInfoReportedArgs",
        sizeof(py::wrapper::Microsoft::Windows::Widgets::Providers::WidgetErrorInfoReportedArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_WidgetErrorInfoReportedArgs
    };

    // ----- WidgetInfo class --------------------

    static PyObject* _new_WidgetInfo(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::Windows::Widgets::Providers::WidgetInfo>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::Windows::Widgets::Providers::WidgetInfo>::type_name);
        return nullptr;
    }

    static void _dealloc_WidgetInfo(py::wrapper::Microsoft::Windows::Widgets::Providers::WidgetInfo* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* WidgetInfo_get_CustomState(py::wrapper::Microsoft::Windows::Widgets::Providers::WidgetInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.Widgets.Providers.WidgetInfo", L"CustomState"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CustomState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WidgetInfo_get_Data(py::wrapper::Microsoft::Windows::Widgets::Providers::WidgetInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.Widgets.Providers.WidgetInfo", L"Data"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Data());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WidgetInfo_get_LastUpdateTime(py::wrapper::Microsoft::Windows::Widgets::Providers::WidgetInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.Widgets.Providers.WidgetInfo", L"LastUpdateTime"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.LastUpdateTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WidgetInfo_get_Template(py::wrapper::Microsoft::Windows::Widgets::Providers::WidgetInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.Widgets.Providers.WidgetInfo", L"Template"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Template());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WidgetInfo_get_WidgetContext(py::wrapper::Microsoft::Windows::Widgets::Providers::WidgetInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.Widgets.Providers.WidgetInfo", L"WidgetContext"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.WidgetContext());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_WidgetInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::Windows::Widgets::Providers::WidgetInfo>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_WidgetInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::Windows::Widgets::Providers::WidgetInfo>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_WidgetInfo[] = {
        { "_assign_array_", _assign_array_WidgetInfo, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_WidgetInfo), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_WidgetInfo[] = {
        { "custom_state", reinterpret_cast<getter>(WidgetInfo_get_CustomState), nullptr, nullptr, nullptr },
        { "data", reinterpret_cast<getter>(WidgetInfo_get_Data), nullptr, nullptr, nullptr },
        { "last_update_time", reinterpret_cast<getter>(WidgetInfo_get_LastUpdateTime), nullptr, nullptr, nullptr },
        { "template", reinterpret_cast<getter>(WidgetInfo_get_Template), nullptr, nullptr, nullptr },
        { "widget_context", reinterpret_cast<getter>(WidgetInfo_get_WidgetContext), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_WidgetInfo[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_WidgetInfo) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_WidgetInfo) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_WidgetInfo) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_WidgetInfo) },
        { },
    };

    static PyType_Spec type_spec_WidgetInfo =
    {
        "winrt._winrt_microsoft_windows_widgets_providers.WidgetInfo",
        sizeof(py::wrapper::Microsoft::Windows::Widgets::Providers::WidgetInfo),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_WidgetInfo
    };

    // ----- WidgetManager class --------------------

    static PyObject* _new_WidgetManager(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::Windows::Widgets::Providers::WidgetManager>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::Windows::Widgets::Providers::WidgetManager>::type_name);
        return nullptr;
    }

    static void _dealloc_WidgetManager(py::wrapper::Microsoft::Windows::Widgets::Providers::WidgetManager* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* WidgetManager_DeleteWidget(py::wrapper::Microsoft::Windows::Widgets::Providers::WidgetManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Windows.Widgets.Providers.WidgetManager", L"DeleteWidget", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                self->obj.DeleteWidget(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* WidgetManager_GetDefault(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Windows.Widgets.Providers.WidgetManager", L"GetDefault", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(winrt::Microsoft::Windows::Widgets::Providers::WidgetManager::GetDefault());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* WidgetManager_GetWidgetIds(py::wrapper::Microsoft::Windows::Widgets::Providers::WidgetManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Windows.Widgets.Providers.WidgetManager", L"GetWidgetIds", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetWidgetIds());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* WidgetManager_GetWidgetInfo(py::wrapper::Microsoft::Windows::Widgets::Providers::WidgetManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Windows.Widgets.Providers.WidgetManager", L"GetWidgetInfo", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.GetWidgetInfo(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* WidgetManager_GetWidgetInfos(py::wrapper::Microsoft::Windows::Widgets::Providers::WidgetManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Windows.Widgets.Providers.WidgetManager", L"GetWidgetInfos", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetWidgetInfos());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* WidgetManager_UpdateWidget(py::wrapper::Microsoft::Windows::Widgets::Providers::WidgetManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Windows.Widgets.Providers.WidgetManager", L"UpdateWidget", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::Windows::Widgets::Providers::WidgetUpdateRequestOptions>(args, 0);

                self->obj.UpdateWidget(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_WidgetManager(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::Windows::Widgets::Providers::WidgetManager>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_WidgetManager(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::Windows::Widgets::Providers::WidgetManager>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_WidgetManager[] = {
        { "delete_widget", reinterpret_cast<PyCFunction>(WidgetManager_DeleteWidget), METH_VARARGS, nullptr },
        { "get_widget_ids", reinterpret_cast<PyCFunction>(WidgetManager_GetWidgetIds), METH_VARARGS, nullptr },
        { "get_widget_info", reinterpret_cast<PyCFunction>(WidgetManager_GetWidgetInfo), METH_VARARGS, nullptr },
        { "get_widget_infos", reinterpret_cast<PyCFunction>(WidgetManager_GetWidgetInfos), METH_VARARGS, nullptr },
        { "update_widget", reinterpret_cast<PyCFunction>(WidgetManager_UpdateWidget), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_WidgetManager, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_WidgetManager), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_WidgetManager[] = {
        { }
    };

    static PyType_Slot _type_slots_WidgetManager[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_WidgetManager) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_WidgetManager) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_WidgetManager) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_WidgetManager) },
        { },
    };

    static PyType_Spec type_spec_WidgetManager =
    {
        "winrt._winrt_microsoft_windows_widgets_providers.WidgetManager",
        sizeof(py::wrapper::Microsoft::Windows::Widgets::Providers::WidgetManager),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_WidgetManager
    };

    static PyGetSetDef getset_WidgetManager_Static[] = {
        { }
    };

    static PyMethodDef methods_WidgetManager_Static[] = {
        { "get_default", reinterpret_cast<PyCFunction>(WidgetManager_GetDefault), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_WidgetManager_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_WidgetManager_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_WidgetManager_Static) },
        { }
    };

    static PyType_Spec type_spec_WidgetManager_Static =
    {
        "winrt._winrt_microsoft_windows_widgets_providers.WidgetManager_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_WidgetManager_Static
    };

    // ----- WidgetUpdateRequestOptions class --------------------

    static PyObject* _new_WidgetUpdateRequestOptions(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                winrt::Microsoft::Windows::Widgets::Providers::WidgetUpdateRequestOptions instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_WidgetUpdateRequestOptions(py::wrapper::Microsoft::Windows::Widgets::Providers::WidgetUpdateRequestOptions* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* WidgetUpdateRequestOptions_get_Template(py::wrapper::Microsoft::Windows::Widgets::Providers::WidgetUpdateRequestOptions* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.Widgets.Providers.WidgetUpdateRequestOptions", L"Template"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Template());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int WidgetUpdateRequestOptions_put_Template(py::wrapper::Microsoft::Windows::Widgets::Providers::WidgetUpdateRequestOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.Widgets.Providers.WidgetUpdateRequestOptions", L"Template"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Template(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* WidgetUpdateRequestOptions_get_Data(py::wrapper::Microsoft::Windows::Widgets::Providers::WidgetUpdateRequestOptions* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.Widgets.Providers.WidgetUpdateRequestOptions", L"Data"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Data());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int WidgetUpdateRequestOptions_put_Data(py::wrapper::Microsoft::Windows::Widgets::Providers::WidgetUpdateRequestOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.Widgets.Providers.WidgetUpdateRequestOptions", L"Data"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Data(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* WidgetUpdateRequestOptions_get_CustomState(py::wrapper::Microsoft::Windows::Widgets::Providers::WidgetUpdateRequestOptions* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.Widgets.Providers.WidgetUpdateRequestOptions", L"CustomState"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CustomState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int WidgetUpdateRequestOptions_put_CustomState(py::wrapper::Microsoft::Windows::Widgets::Providers::WidgetUpdateRequestOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.Widgets.Providers.WidgetUpdateRequestOptions", L"CustomState"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.CustomState(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* WidgetUpdateRequestOptions_get_WidgetId(py::wrapper::Microsoft::Windows::Widgets::Providers::WidgetUpdateRequestOptions* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.Widgets.Providers.WidgetUpdateRequestOptions", L"WidgetId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.WidgetId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WidgetUpdateRequestOptions_get_UnsetValue(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.Widgets.Providers.WidgetUpdateRequestOptions", L"UnsetValue"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::Windows::Widgets::Providers::WidgetUpdateRequestOptions::UnsetValue());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_WidgetUpdateRequestOptions(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::Windows::Widgets::Providers::WidgetUpdateRequestOptions>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_WidgetUpdateRequestOptions(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::Windows::Widgets::Providers::WidgetUpdateRequestOptions>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_WidgetUpdateRequestOptions[] = {
        { "_assign_array_", _assign_array_WidgetUpdateRequestOptions, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_WidgetUpdateRequestOptions), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_WidgetUpdateRequestOptions[] = {
        { "template", reinterpret_cast<getter>(WidgetUpdateRequestOptions_get_Template), reinterpret_cast<setter>(WidgetUpdateRequestOptions_put_Template), nullptr, nullptr },
        { "data", reinterpret_cast<getter>(WidgetUpdateRequestOptions_get_Data), reinterpret_cast<setter>(WidgetUpdateRequestOptions_put_Data), nullptr, nullptr },
        { "custom_state", reinterpret_cast<getter>(WidgetUpdateRequestOptions_get_CustomState), reinterpret_cast<setter>(WidgetUpdateRequestOptions_put_CustomState), nullptr, nullptr },
        { "widget_id", reinterpret_cast<getter>(WidgetUpdateRequestOptions_get_WidgetId), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_WidgetUpdateRequestOptions[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_WidgetUpdateRequestOptions) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_WidgetUpdateRequestOptions) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_WidgetUpdateRequestOptions) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_WidgetUpdateRequestOptions) },
        { },
    };

    static PyType_Spec type_spec_WidgetUpdateRequestOptions =
    {
        "winrt._winrt_microsoft_windows_widgets_providers.WidgetUpdateRequestOptions",
        sizeof(py::wrapper::Microsoft::Windows::Widgets::Providers::WidgetUpdateRequestOptions),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_WidgetUpdateRequestOptions
    };

    static PyGetSetDef getset_WidgetUpdateRequestOptions_Static[] = {
        { "unset_value", reinterpret_cast<getter>(WidgetUpdateRequestOptions_get_UnsetValue), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_WidgetUpdateRequestOptions_Static[] = {
        { }
    };

    static PyType_Slot type_slots_WidgetUpdateRequestOptions_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_WidgetUpdateRequestOptions_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_WidgetUpdateRequestOptions_Static) },
        { }
    };

    static PyType_Spec type_spec_WidgetUpdateRequestOptions_Static =
    {
        "winrt._winrt_microsoft_windows_widgets_providers.WidgetUpdateRequestOptions_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_WidgetUpdateRequestOptions_Static
    };

    // ----- IWidgetManager interface --------------------

    static PyObject* _new_IWidgetManager(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::Windows::Widgets::Providers::IWidgetManager>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::Windows::Widgets::Providers::IWidgetManager>::type_name);
        return nullptr;
    }

    static void _dealloc_IWidgetManager(py::wrapper::Microsoft::Windows::Widgets::Providers::IWidgetManager* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IWidgetManager_DeleteWidget(py::wrapper::Microsoft::Windows::Widgets::Providers::IWidgetManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Windows.Widgets.Providers.IWidgetManager", L"DeleteWidget", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                self->obj.DeleteWidget(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IWidgetManager_GetWidgetIds(py::wrapper::Microsoft::Windows::Widgets::Providers::IWidgetManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Windows.Widgets.Providers.IWidgetManager", L"GetWidgetIds", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetWidgetIds());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IWidgetManager_GetWidgetInfo(py::wrapper::Microsoft::Windows::Widgets::Providers::IWidgetManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Windows.Widgets.Providers.IWidgetManager", L"GetWidgetInfo", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.GetWidgetInfo(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IWidgetManager_GetWidgetInfos(py::wrapper::Microsoft::Windows::Widgets::Providers::IWidgetManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Windows.Widgets.Providers.IWidgetManager", L"GetWidgetInfos", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetWidgetInfos());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IWidgetManager_UpdateWidget(py::wrapper::Microsoft::Windows::Widgets::Providers::IWidgetManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Windows.Widgets.Providers.IWidgetManager", L"UpdateWidget", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::Windows::Widgets::Providers::WidgetUpdateRequestOptions>(args, 0);

                self->obj.UpdateWidget(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_IWidgetManager(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::Windows::Widgets::Providers::IWidgetManager>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IWidgetManager(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::Windows::Widgets::Providers::IWidgetManager>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IWidgetManager[] = {
        { "delete_widget", reinterpret_cast<PyCFunction>(IWidgetManager_DeleteWidget), METH_VARARGS, nullptr },
        { "get_widget_ids", reinterpret_cast<PyCFunction>(IWidgetManager_GetWidgetIds), METH_VARARGS, nullptr },
        { "get_widget_info", reinterpret_cast<PyCFunction>(IWidgetManager_GetWidgetInfo), METH_VARARGS, nullptr },
        { "get_widget_infos", reinterpret_cast<PyCFunction>(IWidgetManager_GetWidgetInfos), METH_VARARGS, nullptr },
        { "update_widget", reinterpret_cast<PyCFunction>(IWidgetManager_UpdateWidget), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_IWidgetManager, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IWidgetManager), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IWidgetManager[] = {
        { }
    };

    static PyType_Slot _type_slots_IWidgetManager[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_IWidgetManager) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IWidgetManager) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IWidgetManager) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IWidgetManager) },
        { },
    };

    static PyType_Spec type_spec_IWidgetManager =
    {
        "winrt._winrt_microsoft_windows_widgets_providers.IWidgetManager",
        sizeof(py::wrapper::Microsoft::Windows::Widgets::Providers::IWidgetManager),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IWidgetManager
    };

    // ----- IWidgetProvider interface --------------------

    static PyObject* _new_IWidgetProvider(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::Windows::Widgets::Providers::IWidgetProvider>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::Windows::Widgets::Providers::IWidgetProvider>::type_name);
        return nullptr;
    }

    static void _dealloc_IWidgetProvider(py::wrapper::Microsoft::Windows::Widgets::Providers::IWidgetProvider* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IWidgetProvider_Activate(py::wrapper::Microsoft::Windows::Widgets::Providers::IWidgetProvider* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Windows.Widgets.Providers.IWidgetProvider", L"Activate", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::Windows::Widgets::Providers::WidgetContext>(args, 0);

                self->obj.Activate(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IWidgetProvider_CreateWidget(py::wrapper::Microsoft::Windows::Widgets::Providers::IWidgetProvider* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Windows.Widgets.Providers.IWidgetProvider", L"CreateWidget", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::Windows::Widgets::Providers::WidgetContext>(args, 0);

                self->obj.CreateWidget(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IWidgetProvider_Deactivate(py::wrapper::Microsoft::Windows::Widgets::Providers::IWidgetProvider* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Windows.Widgets.Providers.IWidgetProvider", L"Deactivate", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                self->obj.Deactivate(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IWidgetProvider_DeleteWidget(py::wrapper::Microsoft::Windows::Widgets::Providers::IWidgetProvider* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Windows.Widgets.Providers.IWidgetProvider", L"DeleteWidget", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                self->obj.DeleteWidget(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IWidgetProvider_OnActionInvoked(py::wrapper::Microsoft::Windows::Widgets::Providers::IWidgetProvider* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Windows.Widgets.Providers.IWidgetProvider", L"OnActionInvoked", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::Windows::Widgets::Providers::WidgetActionInvokedArgs>(args, 0);

                self->obj.OnActionInvoked(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IWidgetProvider_OnWidgetContextChanged(py::wrapper::Microsoft::Windows::Widgets::Providers::IWidgetProvider* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Windows.Widgets.Providers.IWidgetProvider", L"OnWidgetContextChanged", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::Windows::Widgets::Providers::WidgetContextChangedArgs>(args, 0);

                self->obj.OnWidgetContextChanged(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_IWidgetProvider(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::Windows::Widgets::Providers::IWidgetProvider>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IWidgetProvider(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::Windows::Widgets::Providers::IWidgetProvider>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IWidgetProvider[] = {
        { "activate", reinterpret_cast<PyCFunction>(IWidgetProvider_Activate), METH_VARARGS, nullptr },
        { "create_widget", reinterpret_cast<PyCFunction>(IWidgetProvider_CreateWidget), METH_VARARGS, nullptr },
        { "deactivate", reinterpret_cast<PyCFunction>(IWidgetProvider_Deactivate), METH_VARARGS, nullptr },
        { "delete_widget", reinterpret_cast<PyCFunction>(IWidgetProvider_DeleteWidget), METH_VARARGS, nullptr },
        { "on_action_invoked", reinterpret_cast<PyCFunction>(IWidgetProvider_OnActionInvoked), METH_VARARGS, nullptr },
        { "on_widget_context_changed", reinterpret_cast<PyCFunction>(IWidgetProvider_OnWidgetContextChanged), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_IWidgetProvider, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IWidgetProvider), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IWidgetProvider[] = {
        { }
    };

    static PyType_Slot _type_slots_IWidgetProvider[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_IWidgetProvider) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IWidgetProvider) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IWidgetProvider) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IWidgetProvider) },
        { },
    };

    static PyType_Spec type_spec_IWidgetProvider =
    {
        "winrt._winrt_microsoft_windows_widgets_providers.IWidgetProvider",
        sizeof(py::wrapper::Microsoft::Windows::Widgets::Providers::IWidgetProvider),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IWidgetProvider
    };

    // ----- IWidgetProvider2 interface --------------------

    static PyObject* _new_IWidgetProvider2(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::Windows::Widgets::Providers::IWidgetProvider2>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::Windows::Widgets::Providers::IWidgetProvider2>::type_name);
        return nullptr;
    }

    static void _dealloc_IWidgetProvider2(py::wrapper::Microsoft::Windows::Widgets::Providers::IWidgetProvider2* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IWidgetProvider2_OnCustomizationRequested(py::wrapper::Microsoft::Windows::Widgets::Providers::IWidgetProvider2* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Windows.Widgets.Providers.IWidgetProvider2", L"OnCustomizationRequested", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::Windows::Widgets::Providers::WidgetCustomizationRequestedArgs>(args, 0);

                self->obj.OnCustomizationRequested(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_IWidgetProvider2(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::Windows::Widgets::Providers::IWidgetProvider2>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IWidgetProvider2(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::Windows::Widgets::Providers::IWidgetProvider2>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IWidgetProvider2[] = {
        { "on_customization_requested", reinterpret_cast<PyCFunction>(IWidgetProvider2_OnCustomizationRequested), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_IWidgetProvider2, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IWidgetProvider2), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IWidgetProvider2[] = {
        { }
    };

    static PyType_Slot _type_slots_IWidgetProvider2[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_IWidgetProvider2) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IWidgetProvider2) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IWidgetProvider2) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IWidgetProvider2) },
        { },
    };

    static PyType_Spec type_spec_IWidgetProvider2 =
    {
        "winrt._winrt_microsoft_windows_widgets_providers.IWidgetProvider2",
        sizeof(py::wrapper::Microsoft::Windows::Widgets::Providers::IWidgetProvider2),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IWidgetProvider2
    };

    // ----- IWidgetProviderAnalytics interface --------------------

    static PyObject* _new_IWidgetProviderAnalytics(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::Windows::Widgets::Providers::IWidgetProviderAnalytics>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::Windows::Widgets::Providers::IWidgetProviderAnalytics>::type_name);
        return nullptr;
    }

    static void _dealloc_IWidgetProviderAnalytics(py::wrapper::Microsoft::Windows::Widgets::Providers::IWidgetProviderAnalytics* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IWidgetProviderAnalytics_OnAnalyticsInfoReported(py::wrapper::Microsoft::Windows::Widgets::Providers::IWidgetProviderAnalytics* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Windows.Widgets.Providers.IWidgetProviderAnalytics", L"OnAnalyticsInfoReported", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::Windows::Widgets::Providers::WidgetAnalyticsInfoReportedArgs>(args, 0);

                self->obj.OnAnalyticsInfoReported(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_IWidgetProviderAnalytics(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::Windows::Widgets::Providers::IWidgetProviderAnalytics>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IWidgetProviderAnalytics(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::Windows::Widgets::Providers::IWidgetProviderAnalytics>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IWidgetProviderAnalytics[] = {
        { "on_analytics_info_reported", reinterpret_cast<PyCFunction>(IWidgetProviderAnalytics_OnAnalyticsInfoReported), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_IWidgetProviderAnalytics, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IWidgetProviderAnalytics), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IWidgetProviderAnalytics[] = {
        { }
    };

    static PyType_Slot _type_slots_IWidgetProviderAnalytics[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_IWidgetProviderAnalytics) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IWidgetProviderAnalytics) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IWidgetProviderAnalytics) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IWidgetProviderAnalytics) },
        { },
    };

    static PyType_Spec type_spec_IWidgetProviderAnalytics =
    {
        "winrt._winrt_microsoft_windows_widgets_providers.IWidgetProviderAnalytics",
        sizeof(py::wrapper::Microsoft::Windows::Widgets::Providers::IWidgetProviderAnalytics),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IWidgetProviderAnalytics
    };

    // ----- IWidgetProviderErrors interface --------------------

    static PyObject* _new_IWidgetProviderErrors(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::Windows::Widgets::Providers::IWidgetProviderErrors>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::Windows::Widgets::Providers::IWidgetProviderErrors>::type_name);
        return nullptr;
    }

    static void _dealloc_IWidgetProviderErrors(py::wrapper::Microsoft::Windows::Widgets::Providers::IWidgetProviderErrors* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IWidgetProviderErrors_OnErrorInfoReported(py::wrapper::Microsoft::Windows::Widgets::Providers::IWidgetProviderErrors* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Windows.Widgets.Providers.IWidgetProviderErrors", L"OnErrorInfoReported", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::Windows::Widgets::Providers::WidgetErrorInfoReportedArgs>(args, 0);

                self->obj.OnErrorInfoReported(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_IWidgetProviderErrors(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::Windows::Widgets::Providers::IWidgetProviderErrors>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IWidgetProviderErrors(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::Windows::Widgets::Providers::IWidgetProviderErrors>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IWidgetProviderErrors[] = {
        { "on_error_info_reported", reinterpret_cast<PyCFunction>(IWidgetProviderErrors_OnErrorInfoReported), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_IWidgetProviderErrors, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IWidgetProviderErrors), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IWidgetProviderErrors[] = {
        { }
    };

    static PyType_Slot _type_slots_IWidgetProviderErrors[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_IWidgetProviderErrors) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IWidgetProviderErrors) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IWidgetProviderErrors) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IWidgetProviderErrors) },
        { },
    };

    static PyType_Spec type_spec_IWidgetProviderErrors =
    {
        "winrt._winrt_microsoft_windows_widgets_providers.IWidgetProviderErrors",
        sizeof(py::wrapper::Microsoft::Windows::Widgets::Providers::IWidgetProviderErrors),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IWidgetProviderErrors
    };

    // ----- Microsoft.Windows.Widgets.Providers Initialization --------------------
    PyDoc_STRVAR(module_doc, "Microsoft::Windows::Widgets::Providers");


    static PyModuleDef module_def
        = {PyModuleDef_HEAD_INIT,
           "_winrt_microsoft_windows_widgets_providers",
           module_doc,
           0,
           nullptr,
           nullptr,
           nullptr,
           nullptr,
           nullptr};

} // py::cpp::Microsoft::Windows::Widgets::Providers

PyMODINIT_FUNC PyInit__winrt_microsoft_windows_widgets_providers(void) noexcept
{
    using namespace py::cpp::Microsoft::Windows::Widgets::Providers;

    if (py::import_winrt_runtime() == -1)
    {
        return nullptr;
    }

    py::pyobj_handle module{PyModule_Create(&module_def)};

    if (!module)
    {
        return nullptr;
    }

    auto object_type = py::get_object_type();
    if (!object_type)
    {
        return nullptr;
    }

    py::pyobj_handle object_bases{PyTuple_Pack(1, object_type)};

    if (!object_bases)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_WidgetActionInvokedArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_WidgetAnalyticsInfoReportedArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_WidgetContext, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_WidgetContextChangedArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_WidgetCustomizationRequestedArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_WidgetErrorInfoReportedArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_WidgetInfo, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_WidgetManager_Static{PyType_FromSpec(&type_spec_WidgetManager_Static)};
    if (!type_WidgetManager_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_WidgetManager, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_WidgetManager_Static.get())) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_WidgetUpdateRequestOptions_Static{PyType_FromSpec(&type_spec_WidgetUpdateRequestOptions_Static)};
    if (!type_WidgetUpdateRequestOptions_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_WidgetUpdateRequestOptions, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_WidgetUpdateRequestOptions_Static.get())) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_IWidgetManager, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_IWidgetProvider, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_IWidgetProvider2, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_IWidgetProviderAnalytics, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_IWidgetProviderErrors, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }


    return module.detach();
}
