// WARNING: Please don't edit this file. It was generated by Python/WinRT v2.2.0

#include "py.Windows.UI.Core.Preview.Communications.h"

namespace py::cpp::Windows::UI::Core::Preview::Communications
{
    // ----- PreviewTeamCleanupRequestedEventArgs class --------------------

    static PyObject* _new_PreviewTeamCleanupRequestedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Core::Preview::Communications::PreviewTeamCleanupRequestedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Core::Preview::Communications::PreviewTeamCleanupRequestedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_PreviewTeamCleanupRequestedEventArgs(py::wrapper::Windows::UI::Core::Preview::Communications::PreviewTeamCleanupRequestedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PreviewTeamCleanupRequestedEventArgs_GetDeferral(py::wrapper::Windows::UI::Core::Preview::Communications::PreviewTeamCleanupRequestedEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Core.Preview.Communications.PreviewTeamCleanupRequestedEventArgs", L"GetDeferral", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetDeferral());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_PreviewTeamCleanupRequestedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Core::Preview::Communications::PreviewTeamCleanupRequestedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PreviewTeamCleanupRequestedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Core::Preview::Communications::PreviewTeamCleanupRequestedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PreviewTeamCleanupRequestedEventArgs[] = {
        { "get_deferral", reinterpret_cast<PyCFunction>(PreviewTeamCleanupRequestedEventArgs_GetDeferral), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_PreviewTeamCleanupRequestedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PreviewTeamCleanupRequestedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PreviewTeamCleanupRequestedEventArgs[] = {
        { }
    };

    static PyType_Slot _type_slots_PreviewTeamCleanupRequestedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_PreviewTeamCleanupRequestedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PreviewTeamCleanupRequestedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PreviewTeamCleanupRequestedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PreviewTeamCleanupRequestedEventArgs) },
        { }
    };

    static PyType_Spec type_spec_PreviewTeamCleanupRequestedEventArgs = {
        "winrt._winrt_windows_ui_core_preview_communications.PreviewTeamCleanupRequestedEventArgs",
        sizeof(py::wrapper::Windows::UI::Core::Preview::Communications::PreviewTeamCleanupRequestedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PreviewTeamCleanupRequestedEventArgs};

    // ----- PreviewTeamCommandInvokedEventArgs class --------------------

    static PyObject* _new_PreviewTeamCommandInvokedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Core::Preview::Communications::PreviewTeamCommandInvokedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Core::Preview::Communications::PreviewTeamCommandInvokedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_PreviewTeamCommandInvokedEventArgs(py::wrapper::Windows::UI::Core::Preview::Communications::PreviewTeamCommandInvokedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PreviewTeamCommandInvokedEventArgs_get_Command(py::wrapper::Windows::UI::Core::Preview::Communications::PreviewTeamCommandInvokedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.Preview.Communications.PreviewTeamCommandInvokedEventArgs", L"Command");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Command());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PreviewTeamCommandInvokedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Core::Preview::Communications::PreviewTeamCommandInvokedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PreviewTeamCommandInvokedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Core::Preview::Communications::PreviewTeamCommandInvokedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PreviewTeamCommandInvokedEventArgs[] = {
        { "_assign_array_", _assign_array_PreviewTeamCommandInvokedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PreviewTeamCommandInvokedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PreviewTeamCommandInvokedEventArgs[] = {
        { "command", reinterpret_cast<getter>(PreviewTeamCommandInvokedEventArgs_get_Command), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PreviewTeamCommandInvokedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_PreviewTeamCommandInvokedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PreviewTeamCommandInvokedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PreviewTeamCommandInvokedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PreviewTeamCommandInvokedEventArgs) },
        { }
    };

    static PyType_Spec type_spec_PreviewTeamCommandInvokedEventArgs = {
        "winrt._winrt_windows_ui_core_preview_communications.PreviewTeamCommandInvokedEventArgs",
        sizeof(py::wrapper::Windows::UI::Core::Preview::Communications::PreviewTeamCommandInvokedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PreviewTeamCommandInvokedEventArgs};

    // ----- PreviewTeamDeviceCredentials class --------------------

    static PyObject* _new_PreviewTeamDeviceCredentials(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Core::Preview::Communications::PreviewTeamDeviceCredentials instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_PreviewTeamDeviceCredentials(py::wrapper::Windows::UI::Core::Preview::Communications::PreviewTeamDeviceCredentials* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PreviewTeamDeviceCredentials_get_DomainUserName(py::wrapper::Windows::UI::Core::Preview::Communications::PreviewTeamDeviceCredentials* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.Preview.Communications.PreviewTeamDeviceCredentials", L"DomainUserName");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DomainUserName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PreviewTeamDeviceCredentials_get_Password(py::wrapper::Windows::UI::Core::Preview::Communications::PreviewTeamDeviceCredentials* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.Preview.Communications.PreviewTeamDeviceCredentials", L"Password");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Password());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PreviewTeamDeviceCredentials_get_UserPrincipalName(py::wrapper::Windows::UI::Core::Preview::Communications::PreviewTeamDeviceCredentials* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.Preview.Communications.PreviewTeamDeviceCredentials", L"UserPrincipalName");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.UserPrincipalName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PreviewTeamDeviceCredentials(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Core::Preview::Communications::PreviewTeamDeviceCredentials>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PreviewTeamDeviceCredentials(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Core::Preview::Communications::PreviewTeamDeviceCredentials>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PreviewTeamDeviceCredentials[] = {
        { "_assign_array_", _assign_array_PreviewTeamDeviceCredentials, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PreviewTeamDeviceCredentials), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PreviewTeamDeviceCredentials[] = {
        { "domain_user_name", reinterpret_cast<getter>(PreviewTeamDeviceCredentials_get_DomainUserName), nullptr, nullptr, nullptr },
        { "password", reinterpret_cast<getter>(PreviewTeamDeviceCredentials_get_Password), nullptr, nullptr, nullptr },
        { "user_principal_name", reinterpret_cast<getter>(PreviewTeamDeviceCredentials_get_UserPrincipalName), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PreviewTeamDeviceCredentials[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_PreviewTeamDeviceCredentials) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PreviewTeamDeviceCredentials) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PreviewTeamDeviceCredentials) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PreviewTeamDeviceCredentials) },
        { }
    };

    static PyType_Spec type_spec_PreviewTeamDeviceCredentials = {
        "winrt._winrt_windows_ui_core_preview_communications.PreviewTeamDeviceCredentials",
        sizeof(py::wrapper::Windows::UI::Core::Preview::Communications::PreviewTeamDeviceCredentials),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PreviewTeamDeviceCredentials};

    // ----- PreviewTeamEndMeetingRequestedEventArgs class --------------------

    static PyObject* _new_PreviewTeamEndMeetingRequestedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Core::Preview::Communications::PreviewTeamEndMeetingRequestedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Core::Preview::Communications::PreviewTeamEndMeetingRequestedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_PreviewTeamEndMeetingRequestedEventArgs(py::wrapper::Windows::UI::Core::Preview::Communications::PreviewTeamEndMeetingRequestedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PreviewTeamEndMeetingRequestedEventArgs_GetDeferral(py::wrapper::Windows::UI::Core::Preview::Communications::PreviewTeamEndMeetingRequestedEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Core.Preview.Communications.PreviewTeamEndMeetingRequestedEventArgs", L"GetDeferral", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetDeferral());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_PreviewTeamEndMeetingRequestedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Core::Preview::Communications::PreviewTeamEndMeetingRequestedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PreviewTeamEndMeetingRequestedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Core::Preview::Communications::PreviewTeamEndMeetingRequestedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PreviewTeamEndMeetingRequestedEventArgs[] = {
        { "get_deferral", reinterpret_cast<PyCFunction>(PreviewTeamEndMeetingRequestedEventArgs_GetDeferral), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_PreviewTeamEndMeetingRequestedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PreviewTeamEndMeetingRequestedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PreviewTeamEndMeetingRequestedEventArgs[] = {
        { }
    };

    static PyType_Slot _type_slots_PreviewTeamEndMeetingRequestedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_PreviewTeamEndMeetingRequestedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PreviewTeamEndMeetingRequestedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PreviewTeamEndMeetingRequestedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PreviewTeamEndMeetingRequestedEventArgs) },
        { }
    };

    static PyType_Spec type_spec_PreviewTeamEndMeetingRequestedEventArgs = {
        "winrt._winrt_windows_ui_core_preview_communications.PreviewTeamEndMeetingRequestedEventArgs",
        sizeof(py::wrapper::Windows::UI::Core::Preview::Communications::PreviewTeamEndMeetingRequestedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PreviewTeamEndMeetingRequestedEventArgs};

    // ----- PreviewTeamJoinMeetingRequestedEventArgs class --------------------

    static PyObject* _new_PreviewTeamJoinMeetingRequestedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Core::Preview::Communications::PreviewTeamJoinMeetingRequestedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Core::Preview::Communications::PreviewTeamJoinMeetingRequestedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_PreviewTeamJoinMeetingRequestedEventArgs(py::wrapper::Windows::UI::Core::Preview::Communications::PreviewTeamJoinMeetingRequestedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PreviewTeamJoinMeetingRequestedEventArgs_GetDeferral(py::wrapper::Windows::UI::Core::Preview::Communications::PreviewTeamJoinMeetingRequestedEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Core.Preview.Communications.PreviewTeamJoinMeetingRequestedEventArgs", L"GetDeferral", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetDeferral());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PreviewTeamJoinMeetingRequestedEventArgs_get_MeetingUri(py::wrapper::Windows::UI::Core::Preview::Communications::PreviewTeamJoinMeetingRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.Preview.Communications.PreviewTeamJoinMeetingRequestedEventArgs", L"MeetingUri");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.MeetingUri());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PreviewTeamJoinMeetingRequestedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Core::Preview::Communications::PreviewTeamJoinMeetingRequestedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PreviewTeamJoinMeetingRequestedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Core::Preview::Communications::PreviewTeamJoinMeetingRequestedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PreviewTeamJoinMeetingRequestedEventArgs[] = {
        { "get_deferral", reinterpret_cast<PyCFunction>(PreviewTeamJoinMeetingRequestedEventArgs_GetDeferral), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_PreviewTeamJoinMeetingRequestedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PreviewTeamJoinMeetingRequestedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PreviewTeamJoinMeetingRequestedEventArgs[] = {
        { "meeting_uri", reinterpret_cast<getter>(PreviewTeamJoinMeetingRequestedEventArgs_get_MeetingUri), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PreviewTeamJoinMeetingRequestedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_PreviewTeamJoinMeetingRequestedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PreviewTeamJoinMeetingRequestedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PreviewTeamJoinMeetingRequestedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PreviewTeamJoinMeetingRequestedEventArgs) },
        { }
    };

    static PyType_Spec type_spec_PreviewTeamJoinMeetingRequestedEventArgs = {
        "winrt._winrt_windows_ui_core_preview_communications.PreviewTeamJoinMeetingRequestedEventArgs",
        sizeof(py::wrapper::Windows::UI::Core::Preview::Communications::PreviewTeamJoinMeetingRequestedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PreviewTeamJoinMeetingRequestedEventArgs};

    // ----- PreviewTeamView class --------------------

    static PyObject* _new_PreviewTeamView(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Core::Preview::Communications::PreviewTeamView>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Core::Preview::Communications::PreviewTeamView>::type_name);
        return nullptr;
    }

    static void _dealloc_PreviewTeamView(py::wrapper::Windows::UI::Core::Preview::Communications::PreviewTeamView* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PreviewTeamView_EnterFullScreen(py::wrapper::Windows::UI::Core::Preview::Communications::PreviewTeamView* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Core.Preview.Communications.PreviewTeamView", L"EnterFullScreen", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.EnterFullScreen();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PreviewTeamView_GetForCurrentView(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Core.Preview.Communications.PreviewTeamView", L"GetForCurrentView", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(winrt::Windows::UI::Core::Preview::Communications::PreviewTeamView::GetForCurrentView());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PreviewTeamView_JoinMeetingWithUri(py::wrapper::Windows::UI::Core::Preview::Communications::PreviewTeamView* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Core.Preview.Communications.PreviewTeamView", L"JoinMeetingWithUri", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);

                self->obj.JoinMeetingWithUri(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PreviewTeamView_LeaveFullScreen(py::wrapper::Windows::UI::Core::Preview::Communications::PreviewTeamView* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Core.Preview.Communications.PreviewTeamView", L"LeaveFullScreen", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.LeaveFullScreen();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PreviewTeamView_NotifyMeetingEnded(py::wrapper::Windows::UI::Core::Preview::Communications::PreviewTeamView* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Core.Preview.Communications.PreviewTeamView", L"NotifyMeetingEnded", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Core::Preview::Communications::PreviewTeamEndMeetingKind>(args, 0);

                self->obj.NotifyMeetingEnded(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PreviewTeamView_RequestForeground(py::wrapper::Windows::UI::Core::Preview::Communications::PreviewTeamView* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Core.Preview.Communications.PreviewTeamView", L"RequestForeground", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.RequestForeground();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PreviewTeamView_SetButtonLabel(py::wrapper::Windows::UI::Core::Preview::Communications::PreviewTeamView* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Core.Preview.Communications.PreviewTeamView", L"SetButtonLabel", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                self->obj.SetButtonLabel(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PreviewTeamView_SetTitle(py::wrapper::Windows::UI::Core::Preview::Communications::PreviewTeamView* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Core.Preview.Communications.PreviewTeamView", L"SetTitle", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                self->obj.SetTitle(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PreviewTeamView_StartSharingScreen(py::wrapper::Windows::UI::Core::Preview::Communications::PreviewTeamView* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Core.Preview.Communications.PreviewTeamView", L"StartSharingScreen", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.StartSharingScreen();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PreviewTeamView_StopSharingScreen(py::wrapper::Windows::UI::Core::Preview::Communications::PreviewTeamView* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Core.Preview.Communications.PreviewTeamView", L"StopSharingScreen", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.StopSharingScreen();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PreviewTeamView_get_IsFullScreen(py::wrapper::Windows::UI::Core::Preview::Communications::PreviewTeamView* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.Preview.Communications.PreviewTeamView", L"IsFullScreen");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsFullScreen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PreviewTeamView_get_IsScreenSharing(py::wrapper::Windows::UI::Core::Preview::Communications::PreviewTeamView* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.Preview.Communications.PreviewTeamView", L"IsScreenSharing");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsScreenSharing());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PreviewTeamView_get_MeetingInfoDisplayType(py::wrapper::Windows::UI::Core::Preview::Communications::PreviewTeamView* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.Preview.Communications.PreviewTeamView", L"MeetingInfoDisplayType");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.MeetingInfoDisplayType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PreviewTeamView_get_MeetingUri(py::wrapper::Windows::UI::Core::Preview::Communications::PreviewTeamView* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.Preview.Communications.PreviewTeamView", L"MeetingUri");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.MeetingUri());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PreviewTeamView_get_SharingScreenBounds(py::wrapper::Windows::UI::Core::Preview::Communications::PreviewTeamView* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.Preview.Communications.PreviewTeamView", L"SharingScreenBounds");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SharingScreenBounds());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PreviewTeamView_get_SystemState(py::wrapper::Windows::UI::Core::Preview::Communications::PreviewTeamView* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.Preview.Communications.PreviewTeamView", L"SystemState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SystemState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PreviewTeamView_add_CleanupRequested(py::wrapper::Windows::UI::Core::Preview::Communications::PreviewTeamView* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.Preview.Communications.PreviewTeamView", L"CleanupRequested");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Core::Preview::Communications::PreviewTeamView, winrt::Windows::UI::Core::Preview::Communications::PreviewTeamCleanupRequestedEventArgs>>(arg);

            return py::convert(self->obj.CleanupRequested(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PreviewTeamView_remove_CleanupRequested(py::wrapper::Windows::UI::Core::Preview::Communications::PreviewTeamView* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.Preview.Communications.PreviewTeamView", L"CleanupRequested");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.CleanupRequested(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PreviewTeamView_add_CommandInvoked(py::wrapper::Windows::UI::Core::Preview::Communications::PreviewTeamView* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.Preview.Communications.PreviewTeamView", L"CommandInvoked");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Core::Preview::Communications::PreviewTeamView, winrt::Windows::UI::Core::Preview::Communications::PreviewTeamCommandInvokedEventArgs>>(arg);

            return py::convert(self->obj.CommandInvoked(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PreviewTeamView_remove_CommandInvoked(py::wrapper::Windows::UI::Core::Preview::Communications::PreviewTeamView* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.Preview.Communications.PreviewTeamView", L"CommandInvoked");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.CommandInvoked(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PreviewTeamView_add_EndMeetingRequested(py::wrapper::Windows::UI::Core::Preview::Communications::PreviewTeamView* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.Preview.Communications.PreviewTeamView", L"EndMeetingRequested");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Core::Preview::Communications::PreviewTeamView, winrt::Windows::UI::Core::Preview::Communications::PreviewTeamEndMeetingRequestedEventArgs>>(arg);

            return py::convert(self->obj.EndMeetingRequested(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PreviewTeamView_remove_EndMeetingRequested(py::wrapper::Windows::UI::Core::Preview::Communications::PreviewTeamView* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.Preview.Communications.PreviewTeamView", L"EndMeetingRequested");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.EndMeetingRequested(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PreviewTeamView_add_IsFullScreenChanged(py::wrapper::Windows::UI::Core::Preview::Communications::PreviewTeamView* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.Preview.Communications.PreviewTeamView", L"IsFullScreenChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Core::Preview::Communications::PreviewTeamView, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.IsFullScreenChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PreviewTeamView_remove_IsFullScreenChanged(py::wrapper::Windows::UI::Core::Preview::Communications::PreviewTeamView* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.Preview.Communications.PreviewTeamView", L"IsFullScreenChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.IsFullScreenChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PreviewTeamView_add_IsScreenSharingChanged(py::wrapper::Windows::UI::Core::Preview::Communications::PreviewTeamView* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.Preview.Communications.PreviewTeamView", L"IsScreenSharingChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Core::Preview::Communications::PreviewTeamView, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.IsScreenSharingChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PreviewTeamView_remove_IsScreenSharingChanged(py::wrapper::Windows::UI::Core::Preview::Communications::PreviewTeamView* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.Preview.Communications.PreviewTeamView", L"IsScreenSharingChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.IsScreenSharingChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PreviewTeamView_add_JoinMeetingRequested(py::wrapper::Windows::UI::Core::Preview::Communications::PreviewTeamView* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.Preview.Communications.PreviewTeamView", L"JoinMeetingRequested");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Core::Preview::Communications::PreviewTeamView, winrt::Windows::UI::Core::Preview::Communications::PreviewTeamJoinMeetingRequestedEventArgs>>(arg);

            return py::convert(self->obj.JoinMeetingRequested(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PreviewTeamView_remove_JoinMeetingRequested(py::wrapper::Windows::UI::Core::Preview::Communications::PreviewTeamView* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.Preview.Communications.PreviewTeamView", L"JoinMeetingRequested");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.JoinMeetingRequested(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PreviewTeamView_add_SharingScreenBoundsChanged(py::wrapper::Windows::UI::Core::Preview::Communications::PreviewTeamView* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.Preview.Communications.PreviewTeamView", L"SharingScreenBoundsChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Core::Preview::Communications::PreviewTeamView, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.SharingScreenBoundsChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PreviewTeamView_remove_SharingScreenBoundsChanged(py::wrapper::Windows::UI::Core::Preview::Communications::PreviewTeamView* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.Preview.Communications.PreviewTeamView", L"SharingScreenBoundsChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.SharingScreenBoundsChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PreviewTeamView_add_SystemStateChanged(py::wrapper::Windows::UI::Core::Preview::Communications::PreviewTeamView* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.Preview.Communications.PreviewTeamView", L"SystemStateChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Core::Preview::Communications::PreviewTeamView, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.SystemStateChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PreviewTeamView_remove_SystemStateChanged(py::wrapper::Windows::UI::Core::Preview::Communications::PreviewTeamView* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.Preview.Communications.PreviewTeamView", L"SystemStateChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.SystemStateChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PreviewTeamView(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Core::Preview::Communications::PreviewTeamView>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PreviewTeamView(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Core::Preview::Communications::PreviewTeamView>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PreviewTeamView[] = {
        { "enter_full_screen", reinterpret_cast<PyCFunction>(PreviewTeamView_EnterFullScreen), METH_VARARGS, nullptr },
        { "join_meeting_with_uri", reinterpret_cast<PyCFunction>(PreviewTeamView_JoinMeetingWithUri), METH_VARARGS, nullptr },
        { "leave_full_screen", reinterpret_cast<PyCFunction>(PreviewTeamView_LeaveFullScreen), METH_VARARGS, nullptr },
        { "notify_meeting_ended", reinterpret_cast<PyCFunction>(PreviewTeamView_NotifyMeetingEnded), METH_VARARGS, nullptr },
        { "request_foreground", reinterpret_cast<PyCFunction>(PreviewTeamView_RequestForeground), METH_VARARGS, nullptr },
        { "set_button_label", reinterpret_cast<PyCFunction>(PreviewTeamView_SetButtonLabel), METH_VARARGS, nullptr },
        { "set_title", reinterpret_cast<PyCFunction>(PreviewTeamView_SetTitle), METH_VARARGS, nullptr },
        { "start_sharing_screen", reinterpret_cast<PyCFunction>(PreviewTeamView_StartSharingScreen), METH_VARARGS, nullptr },
        { "stop_sharing_screen", reinterpret_cast<PyCFunction>(PreviewTeamView_StopSharingScreen), METH_VARARGS, nullptr },
        { "add_cleanup_requested", reinterpret_cast<PyCFunction>(PreviewTeamView_add_CleanupRequested), METH_O, nullptr },
        { "remove_cleanup_requested", reinterpret_cast<PyCFunction>(PreviewTeamView_remove_CleanupRequested), METH_O, nullptr },
        { "add_command_invoked", reinterpret_cast<PyCFunction>(PreviewTeamView_add_CommandInvoked), METH_O, nullptr },
        { "remove_command_invoked", reinterpret_cast<PyCFunction>(PreviewTeamView_remove_CommandInvoked), METH_O, nullptr },
        { "add_end_meeting_requested", reinterpret_cast<PyCFunction>(PreviewTeamView_add_EndMeetingRequested), METH_O, nullptr },
        { "remove_end_meeting_requested", reinterpret_cast<PyCFunction>(PreviewTeamView_remove_EndMeetingRequested), METH_O, nullptr },
        { "add_is_full_screen_changed", reinterpret_cast<PyCFunction>(PreviewTeamView_add_IsFullScreenChanged), METH_O, nullptr },
        { "remove_is_full_screen_changed", reinterpret_cast<PyCFunction>(PreviewTeamView_remove_IsFullScreenChanged), METH_O, nullptr },
        { "add_is_screen_sharing_changed", reinterpret_cast<PyCFunction>(PreviewTeamView_add_IsScreenSharingChanged), METH_O, nullptr },
        { "remove_is_screen_sharing_changed", reinterpret_cast<PyCFunction>(PreviewTeamView_remove_IsScreenSharingChanged), METH_O, nullptr },
        { "add_join_meeting_requested", reinterpret_cast<PyCFunction>(PreviewTeamView_add_JoinMeetingRequested), METH_O, nullptr },
        { "remove_join_meeting_requested", reinterpret_cast<PyCFunction>(PreviewTeamView_remove_JoinMeetingRequested), METH_O, nullptr },
        { "add_sharing_screen_bounds_changed", reinterpret_cast<PyCFunction>(PreviewTeamView_add_SharingScreenBoundsChanged), METH_O, nullptr },
        { "remove_sharing_screen_bounds_changed", reinterpret_cast<PyCFunction>(PreviewTeamView_remove_SharingScreenBoundsChanged), METH_O, nullptr },
        { "add_system_state_changed", reinterpret_cast<PyCFunction>(PreviewTeamView_add_SystemStateChanged), METH_O, nullptr },
        { "remove_system_state_changed", reinterpret_cast<PyCFunction>(PreviewTeamView_remove_SystemStateChanged), METH_O, nullptr },
        { "_assign_array_", _assign_array_PreviewTeamView, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PreviewTeamView), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PreviewTeamView[] = {
        { "is_full_screen", reinterpret_cast<getter>(PreviewTeamView_get_IsFullScreen), nullptr, nullptr, nullptr },
        { "is_screen_sharing", reinterpret_cast<getter>(PreviewTeamView_get_IsScreenSharing), nullptr, nullptr, nullptr },
        { "meeting_info_display_type", reinterpret_cast<getter>(PreviewTeamView_get_MeetingInfoDisplayType), nullptr, nullptr, nullptr },
        { "meeting_uri", reinterpret_cast<getter>(PreviewTeamView_get_MeetingUri), nullptr, nullptr, nullptr },
        { "sharing_screen_bounds", reinterpret_cast<getter>(PreviewTeamView_get_SharingScreenBounds), nullptr, nullptr, nullptr },
        { "system_state", reinterpret_cast<getter>(PreviewTeamView_get_SystemState), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PreviewTeamView[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_PreviewTeamView) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PreviewTeamView) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PreviewTeamView) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PreviewTeamView) },
        { }
    };

    static PyType_Spec type_spec_PreviewTeamView = {
        "winrt._winrt_windows_ui_core_preview_communications.PreviewTeamView",
        sizeof(py::wrapper::Windows::UI::Core::Preview::Communications::PreviewTeamView),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PreviewTeamView};

    static PyGetSetDef getset_PreviewTeamView_Static[] = {
        { }
    };

    static PyMethodDef methods_PreviewTeamView_Static[] = {
        { "get_for_current_view", reinterpret_cast<PyCFunction>(PreviewTeamView_GetForCurrentView), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_PreviewTeamView_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_PreviewTeamView_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_PreviewTeamView_Static) },
        { }
    };

    static PyType_Spec type_spec_PreviewTeamView_Static =
    {
        "winrt._winrt_windows_ui_core_preview_communications.PreviewTeamView_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_PreviewTeamView_Static
    };

    // ----- Windows.UI.Core.Preview.Communications Initialization --------------------

    PyDoc_STRVAR(module_doc, "Windows.UI.Core.Preview.Communications");

    static PyModuleDef module_def = {
        PyModuleDef_HEAD_INIT,
        "_winrt_windows_ui_core_preview_communications",
        module_doc,
        0,
        nullptr,
        nullptr,
        nullptr,
        nullptr,
        nullptr};
} // py::cpp::Windows::UI::Core::Preview::Communications

PyMODINIT_FUNC PyInit__winrt_windows_ui_core_preview_communications(void) noexcept
{
    using namespace py::cpp::Windows::UI::Core::Preview::Communications;

    if (py::import_winrt_runtime() == -1)
    {
        return nullptr;
    }

    py::pyobj_handle module{PyModule_Create(&module_def)};

    if (!module)
    {
        return nullptr;
    }

    auto object_type = py::get_object_type();
    if (!object_type)
    {
        return nullptr;
    }

    py::pyobj_handle object_bases{PyTuple_Pack(1, object_type)};

    if (!object_bases)
    {
        return nullptr;
    }

    py::pytype_handle PreviewTeamCleanupRequestedEventArgs_type{py::register_python_type(module.get(), &type_spec_PreviewTeamCleanupRequestedEventArgs, object_bases.get(), nullptr)};
    if (!PreviewTeamCleanupRequestedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle PreviewTeamCommandInvokedEventArgs_type{py::register_python_type(module.get(), &type_spec_PreviewTeamCommandInvokedEventArgs, object_bases.get(), nullptr)};
    if (!PreviewTeamCommandInvokedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle PreviewTeamDeviceCredentials_type{py::register_python_type(module.get(), &type_spec_PreviewTeamDeviceCredentials, object_bases.get(), nullptr)};
    if (!PreviewTeamDeviceCredentials_type)
    {
        return nullptr;
    }

    py::pytype_handle PreviewTeamEndMeetingRequestedEventArgs_type{py::register_python_type(module.get(), &type_spec_PreviewTeamEndMeetingRequestedEventArgs, object_bases.get(), nullptr)};
    if (!PreviewTeamEndMeetingRequestedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle PreviewTeamJoinMeetingRequestedEventArgs_type{py::register_python_type(module.get(), &type_spec_PreviewTeamJoinMeetingRequestedEventArgs, object_bases.get(), nullptr)};
    if (!PreviewTeamJoinMeetingRequestedEventArgs_type)
    {
        return nullptr;
    }

    py::pyobj_handle type_PreviewTeamView_Static{PyType_FromSpec(&type_spec_PreviewTeamView_Static)};
    if (!type_PreviewTeamView_Static)
    {
        return nullptr;
    }

    py::pytype_handle PreviewTeamView_type{py::register_python_type(module.get(), &type_spec_PreviewTeamView, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_PreviewTeamView_Static.get()))};
    if (!PreviewTeamView_type)
    {
        return nullptr;
    }


    return module.detach();
}
