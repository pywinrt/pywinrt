// WARNING: Please don't edit this file. It was generated by Python/WinRT v0.0.0

#include "py.Windows.ApplicationModel.Appointments.h"

namespace py::cpp::Windows::ApplicationModel::Appointments
{
    // ----- Appointment class --------------------

    static PyObject* _new_Appointment(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::ApplicationModel::Appointments::Appointment instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_Appointment(py::wrapper::Windows::ApplicationModel::Appointments::Appointment* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* Appointment_get_Location(py::wrapper::Windows::ApplicationModel::Appointments::Appointment* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Appointments.Appointment", L"Location"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Location());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Appointment_put_Location(py::wrapper::Windows::ApplicationModel::Appointments::Appointment* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Appointments.Appointment", L"Location"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Location(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Appointment_get_AllDay(py::wrapper::Windows::ApplicationModel::Appointments::Appointment* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Appointments.Appointment", L"AllDay"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.AllDay());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Appointment_put_AllDay(py::wrapper::Windows::ApplicationModel::Appointments::Appointment* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Appointments.Appointment", L"AllDay"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.AllDay(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Appointment_get_Organizer(py::wrapper::Windows::ApplicationModel::Appointments::Appointment* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Appointments.Appointment", L"Organizer"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Organizer());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Appointment_put_Organizer(py::wrapper::Windows::ApplicationModel::Appointments::Appointment* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Appointments.Appointment", L"Organizer"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Appointments::AppointmentOrganizer>(arg);

            self->obj.Organizer(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Appointment_get_Duration(py::wrapper::Windows::ApplicationModel::Appointments::Appointment* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Appointments.Appointment", L"Duration"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Duration());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Appointment_put_Duration(py::wrapper::Windows::ApplicationModel::Appointments::Appointment* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Appointments.Appointment", L"Duration"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(arg);

            self->obj.Duration(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Appointment_get_Details(py::wrapper::Windows::ApplicationModel::Appointments::Appointment* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Appointments.Appointment", L"Details"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Details());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Appointment_put_Details(py::wrapper::Windows::ApplicationModel::Appointments::Appointment* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Appointments.Appointment", L"Details"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Details(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Appointment_get_BusyStatus(py::wrapper::Windows::ApplicationModel::Appointments::Appointment* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Appointments.Appointment", L"BusyStatus"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.BusyStatus());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Appointment_put_BusyStatus(py::wrapper::Windows::ApplicationModel::Appointments::Appointment* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Appointments.Appointment", L"BusyStatus"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Appointments::AppointmentBusyStatus>(arg);

            self->obj.BusyStatus(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Appointment_get_Recurrence(py::wrapper::Windows::ApplicationModel::Appointments::Appointment* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Appointments.Appointment", L"Recurrence"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Recurrence());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Appointment_put_Recurrence(py::wrapper::Windows::ApplicationModel::Appointments::Appointment* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Appointments.Appointment", L"Recurrence"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Appointments::AppointmentRecurrence>(arg);

            self->obj.Recurrence(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Appointment_get_Subject(py::wrapper::Windows::ApplicationModel::Appointments::Appointment* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Appointments.Appointment", L"Subject"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Subject());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Appointment_put_Subject(py::wrapper::Windows::ApplicationModel::Appointments::Appointment* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Appointments.Appointment", L"Subject"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Subject(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Appointment_get_Uri(py::wrapper::Windows::ApplicationModel::Appointments::Appointment* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Appointments.Appointment", L"Uri"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Uri());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Appointment_put_Uri(py::wrapper::Windows::ApplicationModel::Appointments::Appointment* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Appointments.Appointment", L"Uri"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(arg);

            self->obj.Uri(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Appointment_get_StartTime(py::wrapper::Windows::ApplicationModel::Appointments::Appointment* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Appointments.Appointment", L"StartTime"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.StartTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Appointment_put_StartTime(py::wrapper::Windows::ApplicationModel::Appointments::Appointment* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Appointments.Appointment", L"StartTime"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::DateTime>(arg);

            self->obj.StartTime(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Appointment_get_Sensitivity(py::wrapper::Windows::ApplicationModel::Appointments::Appointment* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Appointments.Appointment", L"Sensitivity"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Sensitivity());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Appointment_put_Sensitivity(py::wrapper::Windows::ApplicationModel::Appointments::Appointment* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Appointments.Appointment", L"Sensitivity"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Appointments::AppointmentSensitivity>(arg);

            self->obj.Sensitivity(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Appointment_get_Reminder(py::wrapper::Windows::ApplicationModel::Appointments::Appointment* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Appointments.Appointment", L"Reminder"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Reminder());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Appointment_put_Reminder(py::wrapper::Windows::ApplicationModel::Appointments::Appointment* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Appointments.Appointment", L"Reminder"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::TimeSpan>>(arg);

            self->obj.Reminder(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Appointment_get_Invitees(py::wrapper::Windows::ApplicationModel::Appointments::Appointment* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Appointments.Appointment", L"Invitees"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Invitees());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Appointment_get_AllowNewTimeProposal(py::wrapper::Windows::ApplicationModel::Appointments::Appointment* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Appointments.Appointment", L"AllowNewTimeProposal"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.AllowNewTimeProposal());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Appointment_put_AllowNewTimeProposal(py::wrapper::Windows::ApplicationModel::Appointments::Appointment* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Appointments.Appointment", L"AllowNewTimeProposal"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.AllowNewTimeProposal(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Appointment_get_UserResponse(py::wrapper::Windows::ApplicationModel::Appointments::Appointment* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Appointments.Appointment", L"UserResponse"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.UserResponse());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Appointment_put_UserResponse(py::wrapper::Windows::ApplicationModel::Appointments::Appointment* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Appointments.Appointment", L"UserResponse"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Appointments::AppointmentParticipantResponse>(arg);

            self->obj.UserResponse(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Appointment_get_RoamingId(py::wrapper::Windows::ApplicationModel::Appointments::Appointment* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Appointments.Appointment", L"RoamingId"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.RoamingId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Appointment_put_RoamingId(py::wrapper::Windows::ApplicationModel::Appointments::Appointment* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Appointments.Appointment", L"RoamingId"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.RoamingId(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Appointment_get_ReplyTime(py::wrapper::Windows::ApplicationModel::Appointments::Appointment* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Appointments.Appointment", L"ReplyTime"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ReplyTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Appointment_put_ReplyTime(py::wrapper::Windows::ApplicationModel::Appointments::Appointment* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Appointments.Appointment", L"ReplyTime"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::DateTime>>(arg);

            self->obj.ReplyTime(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Appointment_get_IsResponseRequested(py::wrapper::Windows::ApplicationModel::Appointments::Appointment* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Appointments.Appointment", L"IsResponseRequested"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsResponseRequested());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Appointment_put_IsResponseRequested(py::wrapper::Windows::ApplicationModel::Appointments::Appointment* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Appointments.Appointment", L"IsResponseRequested"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsResponseRequested(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Appointment_get_IsOrganizedByUser(py::wrapper::Windows::ApplicationModel::Appointments::Appointment* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Appointments.Appointment", L"IsOrganizedByUser"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsOrganizedByUser());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Appointment_put_IsOrganizedByUser(py::wrapper::Windows::ApplicationModel::Appointments::Appointment* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Appointments.Appointment", L"IsOrganizedByUser"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsOrganizedByUser(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Appointment_get_IsCanceledMeeting(py::wrapper::Windows::ApplicationModel::Appointments::Appointment* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Appointments.Appointment", L"IsCanceledMeeting"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsCanceledMeeting());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Appointment_put_IsCanceledMeeting(py::wrapper::Windows::ApplicationModel::Appointments::Appointment* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Appointments.Appointment", L"IsCanceledMeeting"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsCanceledMeeting(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Appointment_get_OnlineMeetingLink(py::wrapper::Windows::ApplicationModel::Appointments::Appointment* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Appointments.Appointment", L"OnlineMeetingLink"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.OnlineMeetingLink());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Appointment_put_OnlineMeetingLink(py::wrapper::Windows::ApplicationModel::Appointments::Appointment* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Appointments.Appointment", L"OnlineMeetingLink"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.OnlineMeetingLink(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Appointment_get_HasInvitees(py::wrapper::Windows::ApplicationModel::Appointments::Appointment* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Appointments.Appointment", L"HasInvitees"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.HasInvitees());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Appointment_get_CalendarId(py::wrapper::Windows::ApplicationModel::Appointments::Appointment* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Appointments.Appointment", L"CalendarId"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CalendarId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Appointment_get_LocalId(py::wrapper::Windows::ApplicationModel::Appointments::Appointment* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Appointments.Appointment", L"LocalId"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.LocalId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Appointment_get_OriginalStartTime(py::wrapper::Windows::ApplicationModel::Appointments::Appointment* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Appointments.Appointment", L"OriginalStartTime"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.OriginalStartTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Appointment_get_RemoteChangeNumber(py::wrapper::Windows::ApplicationModel::Appointments::Appointment* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Appointments.Appointment", L"RemoteChangeNumber"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.RemoteChangeNumber());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Appointment_put_RemoteChangeNumber(py::wrapper::Windows::ApplicationModel::Appointments::Appointment* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Appointments.Appointment", L"RemoteChangeNumber"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<uint64_t>(arg);

            self->obj.RemoteChangeNumber(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Appointment_get_DetailsKind(py::wrapper::Windows::ApplicationModel::Appointments::Appointment* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Appointments.Appointment", L"DetailsKind"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DetailsKind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Appointment_put_DetailsKind(py::wrapper::Windows::ApplicationModel::Appointments::Appointment* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Appointments.Appointment", L"DetailsKind"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Appointments::AppointmentDetailsKind>(arg);

            self->obj.DetailsKind(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Appointment_get_ChangeNumber(py::wrapper::Windows::ApplicationModel::Appointments::Appointment* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Appointments.Appointment", L"ChangeNumber"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ChangeNumber());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_Appointment(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Appointments::Appointment>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_Appointment(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Appointments::Appointment>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_Appointment[] = {
        { "_assign_array_", _assign_array_Appointment, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_Appointment), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_Appointment[] = {
        { "location", reinterpret_cast<getter>(Appointment_get_Location), reinterpret_cast<setter>(Appointment_put_Location), nullptr, nullptr },
        { "all_day", reinterpret_cast<getter>(Appointment_get_AllDay), reinterpret_cast<setter>(Appointment_put_AllDay), nullptr, nullptr },
        { "organizer", reinterpret_cast<getter>(Appointment_get_Organizer), reinterpret_cast<setter>(Appointment_put_Organizer), nullptr, nullptr },
        { "duration", reinterpret_cast<getter>(Appointment_get_Duration), reinterpret_cast<setter>(Appointment_put_Duration), nullptr, nullptr },
        { "details", reinterpret_cast<getter>(Appointment_get_Details), reinterpret_cast<setter>(Appointment_put_Details), nullptr, nullptr },
        { "busy_status", reinterpret_cast<getter>(Appointment_get_BusyStatus), reinterpret_cast<setter>(Appointment_put_BusyStatus), nullptr, nullptr },
        { "recurrence", reinterpret_cast<getter>(Appointment_get_Recurrence), reinterpret_cast<setter>(Appointment_put_Recurrence), nullptr, nullptr },
        { "subject", reinterpret_cast<getter>(Appointment_get_Subject), reinterpret_cast<setter>(Appointment_put_Subject), nullptr, nullptr },
        { "uri", reinterpret_cast<getter>(Appointment_get_Uri), reinterpret_cast<setter>(Appointment_put_Uri), nullptr, nullptr },
        { "start_time", reinterpret_cast<getter>(Appointment_get_StartTime), reinterpret_cast<setter>(Appointment_put_StartTime), nullptr, nullptr },
        { "sensitivity", reinterpret_cast<getter>(Appointment_get_Sensitivity), reinterpret_cast<setter>(Appointment_put_Sensitivity), nullptr, nullptr },
        { "reminder", reinterpret_cast<getter>(Appointment_get_Reminder), reinterpret_cast<setter>(Appointment_put_Reminder), nullptr, nullptr },
        { "invitees", reinterpret_cast<getter>(Appointment_get_Invitees), nullptr, nullptr, nullptr },
        { "allow_new_time_proposal", reinterpret_cast<getter>(Appointment_get_AllowNewTimeProposal), reinterpret_cast<setter>(Appointment_put_AllowNewTimeProposal), nullptr, nullptr },
        { "user_response", reinterpret_cast<getter>(Appointment_get_UserResponse), reinterpret_cast<setter>(Appointment_put_UserResponse), nullptr, nullptr },
        { "roaming_id", reinterpret_cast<getter>(Appointment_get_RoamingId), reinterpret_cast<setter>(Appointment_put_RoamingId), nullptr, nullptr },
        { "reply_time", reinterpret_cast<getter>(Appointment_get_ReplyTime), reinterpret_cast<setter>(Appointment_put_ReplyTime), nullptr, nullptr },
        { "is_response_requested", reinterpret_cast<getter>(Appointment_get_IsResponseRequested), reinterpret_cast<setter>(Appointment_put_IsResponseRequested), nullptr, nullptr },
        { "is_organized_by_user", reinterpret_cast<getter>(Appointment_get_IsOrganizedByUser), reinterpret_cast<setter>(Appointment_put_IsOrganizedByUser), nullptr, nullptr },
        { "is_canceled_meeting", reinterpret_cast<getter>(Appointment_get_IsCanceledMeeting), reinterpret_cast<setter>(Appointment_put_IsCanceledMeeting), nullptr, nullptr },
        { "online_meeting_link", reinterpret_cast<getter>(Appointment_get_OnlineMeetingLink), reinterpret_cast<setter>(Appointment_put_OnlineMeetingLink), nullptr, nullptr },
        { "has_invitees", reinterpret_cast<getter>(Appointment_get_HasInvitees), nullptr, nullptr, nullptr },
        { "calendar_id", reinterpret_cast<getter>(Appointment_get_CalendarId), nullptr, nullptr, nullptr },
        { "local_id", reinterpret_cast<getter>(Appointment_get_LocalId), nullptr, nullptr, nullptr },
        { "original_start_time", reinterpret_cast<getter>(Appointment_get_OriginalStartTime), nullptr, nullptr, nullptr },
        { "remote_change_number", reinterpret_cast<getter>(Appointment_get_RemoteChangeNumber), reinterpret_cast<setter>(Appointment_put_RemoteChangeNumber), nullptr, nullptr },
        { "details_kind", reinterpret_cast<getter>(Appointment_get_DetailsKind), reinterpret_cast<setter>(Appointment_put_DetailsKind), nullptr, nullptr },
        { "change_number", reinterpret_cast<getter>(Appointment_get_ChangeNumber), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_Appointment[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_Appointment) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_Appointment) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_Appointment) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_Appointment) },
        { }
    };

    static PyType_Spec type_spec_Appointment = {
        "winrt._winrt_windows_applicationmodel_appointments.Appointment",
        sizeof(py::wrapper::Windows::ApplicationModel::Appointments::Appointment),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_Appointment};

    // ----- AppointmentCalendar class --------------------

    static PyObject* _new_AppointmentCalendar(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Appointments::AppointmentCalendar>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Appointments::AppointmentCalendar>::type_name);
        return nullptr;
    }

    static void _dealloc_AppointmentCalendar(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentCalendar* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AppointmentCalendar_DeleteAppointmentAsync(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentCalendar* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Appointments.AppointmentCalendar", L"DeleteAppointmentAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.DeleteAppointmentAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppointmentCalendar_DeleteAppointmentInstanceAsync(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentCalendar* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Appointments.AppointmentCalendar", L"DeleteAppointmentInstanceAsync", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::DateTime>(args, 1);

                return py::convert(self->obj.DeleteAppointmentInstanceAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppointmentCalendar_DeleteAsync(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentCalendar* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Appointments.AppointmentCalendar", L"DeleteAsync", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.DeleteAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppointmentCalendar_FindAllInstancesAsync(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentCalendar* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Appointments.AppointmentCalendar", L"FindAllInstancesAsync", 3))
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::DateTime>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(args, 2);

                return py::convert(self->obj.FindAllInstancesAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 4)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Appointments.AppointmentCalendar", L"FindAllInstancesAsync", 4))
                {
                    py::set_arg_count_version_error(4);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::DateTime>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::ApplicationModel::Appointments::FindAppointmentsOptions>(args, 3);

                return py::convert(self->obj.FindAllInstancesAsync(param0, param1, param2, param3));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppointmentCalendar_FindAppointmentsAsync(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentCalendar* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Appointments.AppointmentCalendar", L"FindAppointmentsAsync", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::DateTime>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(args, 1);

                return py::convert(self->obj.FindAppointmentsAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Appointments.AppointmentCalendar", L"FindAppointmentsAsync", 3))
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::DateTime>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::ApplicationModel::Appointments::FindAppointmentsOptions>(args, 2);

                return py::convert(self->obj.FindAppointmentsAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppointmentCalendar_FindExceptionsFromMasterAsync(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentCalendar* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Appointments.AppointmentCalendar", L"FindExceptionsFromMasterAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.FindExceptionsFromMasterAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppointmentCalendar_FindUnexpandedAppointmentsAsync(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentCalendar* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Appointments.AppointmentCalendar", L"FindUnexpandedAppointmentsAsync", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.FindUnexpandedAppointmentsAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Appointments.AppointmentCalendar", L"FindUnexpandedAppointmentsAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Appointments::FindAppointmentsOptions>(args, 0);

                return py::convert(self->obj.FindUnexpandedAppointmentsAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppointmentCalendar_GetAppointmentAsync(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentCalendar* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Appointments.AppointmentCalendar", L"GetAppointmentAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.GetAppointmentAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppointmentCalendar_GetAppointmentInstanceAsync(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentCalendar* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Appointments.AppointmentCalendar", L"GetAppointmentInstanceAsync", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::DateTime>(args, 1);

                return py::convert(self->obj.GetAppointmentInstanceAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppointmentCalendar_RegisterSyncManagerAsync(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentCalendar* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Appointments.AppointmentCalendar", L"RegisterSyncManagerAsync", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.RegisterSyncManagerAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppointmentCalendar_SaveAppointmentAsync(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentCalendar* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Appointments.AppointmentCalendar", L"SaveAppointmentAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Appointments::Appointment>(args, 0);

                return py::convert(self->obj.SaveAppointmentAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppointmentCalendar_SaveAsync(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentCalendar* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Appointments.AppointmentCalendar", L"SaveAsync", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.SaveAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppointmentCalendar_TryCancelMeetingAsync(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentCalendar* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 4)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Appointments.AppointmentCalendar", L"TryCancelMeetingAsync", 4))
                {
                    py::set_arg_count_version_error(4);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Appointments::Appointment>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::hstring>(args, 2);
                auto param3 = py::convert_to<bool>(args, 3);

                return py::convert(self->obj.TryCancelMeetingAsync(param0, param1, param2, param3));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppointmentCalendar_TryCreateOrUpdateAppointmentAsync(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentCalendar* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Appointments.AppointmentCalendar", L"TryCreateOrUpdateAppointmentAsync", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Appointments::Appointment>(args, 0);
                auto param1 = py::convert_to<bool>(args, 1);

                return py::convert(self->obj.TryCreateOrUpdateAppointmentAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppointmentCalendar_TryForwardMeetingAsync(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentCalendar* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 5)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Appointments.AppointmentCalendar", L"TryForwardMeetingAsync", 5))
                {
                    py::set_arg_count_version_error(5);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Appointments::Appointment>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::ApplicationModel::Appointments::AppointmentInvitee>>(args, 1);
                auto param2 = py::convert_to<winrt::hstring>(args, 2);
                auto param3 = py::convert_to<winrt::hstring>(args, 3);
                auto param4 = py::convert_to<winrt::hstring>(args, 4);

                return py::convert(self->obj.TryForwardMeetingAsync(param0, param1, param2, param3, param4));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppointmentCalendar_TryProposeNewTimeForMeetingAsync(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentCalendar* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 5)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Appointments.AppointmentCalendar", L"TryProposeNewTimeForMeetingAsync", 5))
                {
                    py::set_arg_count_version_error(5);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Appointments::Appointment>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::DateTime>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(args, 2);
                auto param3 = py::convert_to<winrt::hstring>(args, 3);
                auto param4 = py::convert_to<winrt::hstring>(args, 4);

                return py::convert(self->obj.TryProposeNewTimeForMeetingAsync(param0, param1, param2, param3, param4));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppointmentCalendar_TryUpdateMeetingResponseAsync(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentCalendar* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 5)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Appointments.AppointmentCalendar", L"TryUpdateMeetingResponseAsync", 5))
                {
                    py::set_arg_count_version_error(5);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Appointments::Appointment>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::ApplicationModel::Appointments::AppointmentParticipantResponse>(args, 1);
                auto param2 = py::convert_to<winrt::hstring>(args, 2);
                auto param3 = py::convert_to<winrt::hstring>(args, 3);
                auto param4 = py::convert_to<bool>(args, 4);

                return py::convert(self->obj.TryUpdateMeetingResponseAsync(param0, param1, param2, param3, param4));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppointmentCalendar_get_SummaryCardView(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentCalendar* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Appointments.AppointmentCalendar", L"SummaryCardView"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SummaryCardView());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppointmentCalendar_put_SummaryCardView(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentCalendar* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Appointments.AppointmentCalendar", L"SummaryCardView"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Appointments::AppointmentSummaryCardView>(arg);

            self->obj.SummaryCardView(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppointmentCalendar_get_OtherAppWriteAccess(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentCalendar* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Appointments.AppointmentCalendar", L"OtherAppWriteAccess"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.OtherAppWriteAccess());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppointmentCalendar_put_OtherAppWriteAccess(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentCalendar* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Appointments.AppointmentCalendar", L"OtherAppWriteAccess"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Appointments::AppointmentCalendarOtherAppWriteAccess>(arg);

            self->obj.OtherAppWriteAccess(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppointmentCalendar_get_DisplayColor(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentCalendar* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Appointments.AppointmentCalendar", L"DisplayColor"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DisplayColor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppointmentCalendar_put_DisplayColor(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentCalendar* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Appointments.AppointmentCalendar", L"DisplayColor"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Color>(arg);

            self->obj.DisplayColor(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppointmentCalendar_get_IsHidden(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentCalendar* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Appointments.AppointmentCalendar", L"IsHidden"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsHidden());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppointmentCalendar_put_IsHidden(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentCalendar* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Appointments.AppointmentCalendar", L"IsHidden"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsHidden(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppointmentCalendar_get_DisplayName(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentCalendar* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Appointments.AppointmentCalendar", L"DisplayName"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DisplayName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppointmentCalendar_put_DisplayName(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentCalendar* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Appointments.AppointmentCalendar", L"DisplayName"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.DisplayName(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppointmentCalendar_get_OtherAppReadAccess(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentCalendar* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Appointments.AppointmentCalendar", L"OtherAppReadAccess"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.OtherAppReadAccess());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppointmentCalendar_put_OtherAppReadAccess(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentCalendar* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Appointments.AppointmentCalendar", L"OtherAppReadAccess"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Appointments::AppointmentCalendarOtherAppReadAccess>(arg);

            self->obj.OtherAppReadAccess(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppointmentCalendar_get_LocalId(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentCalendar* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Appointments.AppointmentCalendar", L"LocalId"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.LocalId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppointmentCalendar_get_SourceDisplayName(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentCalendar* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Appointments.AppointmentCalendar", L"SourceDisplayName"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SourceDisplayName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppointmentCalendar_get_CanCancelMeetings(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentCalendar* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Appointments.AppointmentCalendar", L"CanCancelMeetings"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CanCancelMeetings());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppointmentCalendar_put_CanCancelMeetings(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentCalendar* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Appointments.AppointmentCalendar", L"CanCancelMeetings"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.CanCancelMeetings(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppointmentCalendar_get_CanNotifyInvitees(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentCalendar* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Appointments.AppointmentCalendar", L"CanNotifyInvitees"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CanNotifyInvitees());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppointmentCalendar_put_CanNotifyInvitees(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentCalendar* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Appointments.AppointmentCalendar", L"CanNotifyInvitees"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.CanNotifyInvitees(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppointmentCalendar_get_RemoteId(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentCalendar* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Appointments.AppointmentCalendar", L"RemoteId"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.RemoteId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppointmentCalendar_put_RemoteId(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentCalendar* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Appointments.AppointmentCalendar", L"RemoteId"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.RemoteId(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppointmentCalendar_get_MustNofityInvitees(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentCalendar* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Appointments.AppointmentCalendar", L"MustNofityInvitees"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.MustNofityInvitees());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppointmentCalendar_put_MustNofityInvitees(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentCalendar* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Appointments.AppointmentCalendar", L"MustNofityInvitees"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.MustNofityInvitees(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppointmentCalendar_get_CanUpdateMeetingResponses(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentCalendar* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Appointments.AppointmentCalendar", L"CanUpdateMeetingResponses"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CanUpdateMeetingResponses());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppointmentCalendar_put_CanUpdateMeetingResponses(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentCalendar* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Appointments.AppointmentCalendar", L"CanUpdateMeetingResponses"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.CanUpdateMeetingResponses(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppointmentCalendar_get_CanProposeNewTimeForMeetings(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentCalendar* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Appointments.AppointmentCalendar", L"CanProposeNewTimeForMeetings"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CanProposeNewTimeForMeetings());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppointmentCalendar_put_CanProposeNewTimeForMeetings(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentCalendar* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Appointments.AppointmentCalendar", L"CanProposeNewTimeForMeetings"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.CanProposeNewTimeForMeetings(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppointmentCalendar_get_CanCreateOrUpdateAppointments(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentCalendar* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Appointments.AppointmentCalendar", L"CanCreateOrUpdateAppointments"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CanCreateOrUpdateAppointments());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppointmentCalendar_put_CanCreateOrUpdateAppointments(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentCalendar* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Appointments.AppointmentCalendar", L"CanCreateOrUpdateAppointments"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.CanCreateOrUpdateAppointments(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppointmentCalendar_get_CanForwardMeetings(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentCalendar* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Appointments.AppointmentCalendar", L"CanForwardMeetings"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CanForwardMeetings());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppointmentCalendar_put_CanForwardMeetings(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentCalendar* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Appointments.AppointmentCalendar", L"CanForwardMeetings"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.CanForwardMeetings(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppointmentCalendar_get_SyncManager(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentCalendar* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Appointments.AppointmentCalendar", L"SyncManager"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SyncManager());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppointmentCalendar_get_UserDataAccountId(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentCalendar* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Appointments.AppointmentCalendar", L"UserDataAccountId"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.UserDataAccountId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AppointmentCalendar(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Appointments::AppointmentCalendar>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AppointmentCalendar(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Appointments::AppointmentCalendar>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AppointmentCalendar[] = {
        { "delete_appointment_async", reinterpret_cast<PyCFunction>(AppointmentCalendar_DeleteAppointmentAsync), METH_VARARGS, nullptr },
        { "delete_appointment_instance_async", reinterpret_cast<PyCFunction>(AppointmentCalendar_DeleteAppointmentInstanceAsync), METH_VARARGS, nullptr },
        { "delete_async", reinterpret_cast<PyCFunction>(AppointmentCalendar_DeleteAsync), METH_VARARGS, nullptr },
        { "find_all_instances_async", reinterpret_cast<PyCFunction>(AppointmentCalendar_FindAllInstancesAsync), METH_VARARGS, nullptr },
        { "find_appointments_async", reinterpret_cast<PyCFunction>(AppointmentCalendar_FindAppointmentsAsync), METH_VARARGS, nullptr },
        { "find_exceptions_from_master_async", reinterpret_cast<PyCFunction>(AppointmentCalendar_FindExceptionsFromMasterAsync), METH_VARARGS, nullptr },
        { "find_unexpanded_appointments_async", reinterpret_cast<PyCFunction>(AppointmentCalendar_FindUnexpandedAppointmentsAsync), METH_VARARGS, nullptr },
        { "get_appointment_async", reinterpret_cast<PyCFunction>(AppointmentCalendar_GetAppointmentAsync), METH_VARARGS, nullptr },
        { "get_appointment_instance_async", reinterpret_cast<PyCFunction>(AppointmentCalendar_GetAppointmentInstanceAsync), METH_VARARGS, nullptr },
        { "register_sync_manager_async", reinterpret_cast<PyCFunction>(AppointmentCalendar_RegisterSyncManagerAsync), METH_VARARGS, nullptr },
        { "save_appointment_async", reinterpret_cast<PyCFunction>(AppointmentCalendar_SaveAppointmentAsync), METH_VARARGS, nullptr },
        { "save_async", reinterpret_cast<PyCFunction>(AppointmentCalendar_SaveAsync), METH_VARARGS, nullptr },
        { "try_cancel_meeting_async", reinterpret_cast<PyCFunction>(AppointmentCalendar_TryCancelMeetingAsync), METH_VARARGS, nullptr },
        { "try_create_or_update_appointment_async", reinterpret_cast<PyCFunction>(AppointmentCalendar_TryCreateOrUpdateAppointmentAsync), METH_VARARGS, nullptr },
        { "try_forward_meeting_async", reinterpret_cast<PyCFunction>(AppointmentCalendar_TryForwardMeetingAsync), METH_VARARGS, nullptr },
        { "try_propose_new_time_for_meeting_async", reinterpret_cast<PyCFunction>(AppointmentCalendar_TryProposeNewTimeForMeetingAsync), METH_VARARGS, nullptr },
        { "try_update_meeting_response_async", reinterpret_cast<PyCFunction>(AppointmentCalendar_TryUpdateMeetingResponseAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_AppointmentCalendar, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AppointmentCalendar), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AppointmentCalendar[] = {
        { "summary_card_view", reinterpret_cast<getter>(AppointmentCalendar_get_SummaryCardView), reinterpret_cast<setter>(AppointmentCalendar_put_SummaryCardView), nullptr, nullptr },
        { "other_app_write_access", reinterpret_cast<getter>(AppointmentCalendar_get_OtherAppWriteAccess), reinterpret_cast<setter>(AppointmentCalendar_put_OtherAppWriteAccess), nullptr, nullptr },
        { "display_color", reinterpret_cast<getter>(AppointmentCalendar_get_DisplayColor), reinterpret_cast<setter>(AppointmentCalendar_put_DisplayColor), nullptr, nullptr },
        { "is_hidden", reinterpret_cast<getter>(AppointmentCalendar_get_IsHidden), reinterpret_cast<setter>(AppointmentCalendar_put_IsHidden), nullptr, nullptr },
        { "display_name", reinterpret_cast<getter>(AppointmentCalendar_get_DisplayName), reinterpret_cast<setter>(AppointmentCalendar_put_DisplayName), nullptr, nullptr },
        { "other_app_read_access", reinterpret_cast<getter>(AppointmentCalendar_get_OtherAppReadAccess), reinterpret_cast<setter>(AppointmentCalendar_put_OtherAppReadAccess), nullptr, nullptr },
        { "local_id", reinterpret_cast<getter>(AppointmentCalendar_get_LocalId), nullptr, nullptr, nullptr },
        { "source_display_name", reinterpret_cast<getter>(AppointmentCalendar_get_SourceDisplayName), nullptr, nullptr, nullptr },
        { "can_cancel_meetings", reinterpret_cast<getter>(AppointmentCalendar_get_CanCancelMeetings), reinterpret_cast<setter>(AppointmentCalendar_put_CanCancelMeetings), nullptr, nullptr },
        { "can_notify_invitees", reinterpret_cast<getter>(AppointmentCalendar_get_CanNotifyInvitees), reinterpret_cast<setter>(AppointmentCalendar_put_CanNotifyInvitees), nullptr, nullptr },
        { "remote_id", reinterpret_cast<getter>(AppointmentCalendar_get_RemoteId), reinterpret_cast<setter>(AppointmentCalendar_put_RemoteId), nullptr, nullptr },
        { "must_nofity_invitees", reinterpret_cast<getter>(AppointmentCalendar_get_MustNofityInvitees), reinterpret_cast<setter>(AppointmentCalendar_put_MustNofityInvitees), nullptr, nullptr },
        { "can_update_meeting_responses", reinterpret_cast<getter>(AppointmentCalendar_get_CanUpdateMeetingResponses), reinterpret_cast<setter>(AppointmentCalendar_put_CanUpdateMeetingResponses), nullptr, nullptr },
        { "can_propose_new_time_for_meetings", reinterpret_cast<getter>(AppointmentCalendar_get_CanProposeNewTimeForMeetings), reinterpret_cast<setter>(AppointmentCalendar_put_CanProposeNewTimeForMeetings), nullptr, nullptr },
        { "can_create_or_update_appointments", reinterpret_cast<getter>(AppointmentCalendar_get_CanCreateOrUpdateAppointments), reinterpret_cast<setter>(AppointmentCalendar_put_CanCreateOrUpdateAppointments), nullptr, nullptr },
        { "can_forward_meetings", reinterpret_cast<getter>(AppointmentCalendar_get_CanForwardMeetings), reinterpret_cast<setter>(AppointmentCalendar_put_CanForwardMeetings), nullptr, nullptr },
        { "sync_manager", reinterpret_cast<getter>(AppointmentCalendar_get_SyncManager), nullptr, nullptr, nullptr },
        { "user_data_account_id", reinterpret_cast<getter>(AppointmentCalendar_get_UserDataAccountId), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AppointmentCalendar[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_AppointmentCalendar) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AppointmentCalendar) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AppointmentCalendar) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AppointmentCalendar) },
        { }
    };

    static PyType_Spec type_spec_AppointmentCalendar = {
        "winrt._winrt_windows_applicationmodel_appointments.AppointmentCalendar",
        sizeof(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentCalendar),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AppointmentCalendar};

    // ----- AppointmentCalendarSyncManager class --------------------

    static PyObject* _new_AppointmentCalendarSyncManager(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Appointments::AppointmentCalendarSyncManager>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Appointments::AppointmentCalendarSyncManager>::type_name);
        return nullptr;
    }

    static void _dealloc_AppointmentCalendarSyncManager(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentCalendarSyncManager* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AppointmentCalendarSyncManager_SyncAsync(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentCalendarSyncManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Appointments.AppointmentCalendarSyncManager", L"SyncAsync", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.SyncAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppointmentCalendarSyncManager_get_Status(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentCalendarSyncManager* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Appointments.AppointmentCalendarSyncManager", L"Status"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppointmentCalendarSyncManager_put_Status(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentCalendarSyncManager* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Appointments.AppointmentCalendarSyncManager", L"Status"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Appointments::AppointmentCalendarSyncStatus>(arg);

            self->obj.Status(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppointmentCalendarSyncManager_get_LastSuccessfulSyncTime(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentCalendarSyncManager* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Appointments.AppointmentCalendarSyncManager", L"LastSuccessfulSyncTime"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.LastSuccessfulSyncTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppointmentCalendarSyncManager_put_LastSuccessfulSyncTime(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentCalendarSyncManager* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Appointments.AppointmentCalendarSyncManager", L"LastSuccessfulSyncTime"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::DateTime>(arg);

            self->obj.LastSuccessfulSyncTime(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppointmentCalendarSyncManager_get_LastAttemptedSyncTime(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentCalendarSyncManager* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Appointments.AppointmentCalendarSyncManager", L"LastAttemptedSyncTime"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.LastAttemptedSyncTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppointmentCalendarSyncManager_put_LastAttemptedSyncTime(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentCalendarSyncManager* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Appointments.AppointmentCalendarSyncManager", L"LastAttemptedSyncTime"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::DateTime>(arg);

            self->obj.LastAttemptedSyncTime(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppointmentCalendarSyncManager_add_SyncStatusChanged(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentCalendarSyncManager* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.Appointments.AppointmentCalendarSyncManager", L"SyncStatusChanged"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::ApplicationModel::Appointments::AppointmentCalendarSyncManager, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.SyncStatusChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppointmentCalendarSyncManager_remove_SyncStatusChanged(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentCalendarSyncManager* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.Appointments.AppointmentCalendarSyncManager", L"SyncStatusChanged"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.SyncStatusChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AppointmentCalendarSyncManager(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Appointments::AppointmentCalendarSyncManager>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AppointmentCalendarSyncManager(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Appointments::AppointmentCalendarSyncManager>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AppointmentCalendarSyncManager[] = {
        { "sync_async", reinterpret_cast<PyCFunction>(AppointmentCalendarSyncManager_SyncAsync), METH_VARARGS, nullptr },
        { "add_sync_status_changed", reinterpret_cast<PyCFunction>(AppointmentCalendarSyncManager_add_SyncStatusChanged), METH_O, nullptr },
        { "remove_sync_status_changed", reinterpret_cast<PyCFunction>(AppointmentCalendarSyncManager_remove_SyncStatusChanged), METH_O, nullptr },
        { "_assign_array_", _assign_array_AppointmentCalendarSyncManager, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AppointmentCalendarSyncManager), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AppointmentCalendarSyncManager[] = {
        { "status", reinterpret_cast<getter>(AppointmentCalendarSyncManager_get_Status), reinterpret_cast<setter>(AppointmentCalendarSyncManager_put_Status), nullptr, nullptr },
        { "last_successful_sync_time", reinterpret_cast<getter>(AppointmentCalendarSyncManager_get_LastSuccessfulSyncTime), reinterpret_cast<setter>(AppointmentCalendarSyncManager_put_LastSuccessfulSyncTime), nullptr, nullptr },
        { "last_attempted_sync_time", reinterpret_cast<getter>(AppointmentCalendarSyncManager_get_LastAttemptedSyncTime), reinterpret_cast<setter>(AppointmentCalendarSyncManager_put_LastAttemptedSyncTime), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AppointmentCalendarSyncManager[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_AppointmentCalendarSyncManager) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AppointmentCalendarSyncManager) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AppointmentCalendarSyncManager) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AppointmentCalendarSyncManager) },
        { }
    };

    static PyType_Spec type_spec_AppointmentCalendarSyncManager = {
        "winrt._winrt_windows_applicationmodel_appointments.AppointmentCalendarSyncManager",
        sizeof(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentCalendarSyncManager),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AppointmentCalendarSyncManager};

    // ----- AppointmentConflictResult class --------------------

    static PyObject* _new_AppointmentConflictResult(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Appointments::AppointmentConflictResult>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Appointments::AppointmentConflictResult>::type_name);
        return nullptr;
    }

    static void _dealloc_AppointmentConflictResult(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentConflictResult* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AppointmentConflictResult_get_Date(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentConflictResult* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Appointments.AppointmentConflictResult", L"Date"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Date());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppointmentConflictResult_get_Type(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentConflictResult* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Appointments.AppointmentConflictResult", L"Type"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Type());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AppointmentConflictResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Appointments::AppointmentConflictResult>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AppointmentConflictResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Appointments::AppointmentConflictResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AppointmentConflictResult[] = {
        { "_assign_array_", _assign_array_AppointmentConflictResult, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AppointmentConflictResult), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AppointmentConflictResult[] = {
        { "date", reinterpret_cast<getter>(AppointmentConflictResult_get_Date), nullptr, nullptr, nullptr },
        { "type", reinterpret_cast<getter>(AppointmentConflictResult_get_Type), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AppointmentConflictResult[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_AppointmentConflictResult) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AppointmentConflictResult) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AppointmentConflictResult) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AppointmentConflictResult) },
        { }
    };

    static PyType_Spec type_spec_AppointmentConflictResult = {
        "winrt._winrt_windows_applicationmodel_appointments.AppointmentConflictResult",
        sizeof(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentConflictResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AppointmentConflictResult};

    // ----- AppointmentException class --------------------

    static PyObject* _new_AppointmentException(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Appointments::AppointmentException>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Appointments::AppointmentException>::type_name);
        return nullptr;
    }

    static void _dealloc_AppointmentException(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentException* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AppointmentException_get_Appointment(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentException* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Appointments.AppointmentException", L"Appointment"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Appointment());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppointmentException_get_ExceptionProperties(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentException* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Appointments.AppointmentException", L"ExceptionProperties"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ExceptionProperties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppointmentException_get_IsDeleted(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentException* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Appointments.AppointmentException", L"IsDeleted"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsDeleted());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AppointmentException(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Appointments::AppointmentException>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AppointmentException(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Appointments::AppointmentException>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AppointmentException[] = {
        { "_assign_array_", _assign_array_AppointmentException, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AppointmentException), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AppointmentException[] = {
        { "appointment", reinterpret_cast<getter>(AppointmentException_get_Appointment), nullptr, nullptr, nullptr },
        { "exception_properties", reinterpret_cast<getter>(AppointmentException_get_ExceptionProperties), nullptr, nullptr, nullptr },
        { "is_deleted", reinterpret_cast<getter>(AppointmentException_get_IsDeleted), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AppointmentException[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_AppointmentException) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AppointmentException) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AppointmentException) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AppointmentException) },
        { }
    };

    static PyType_Spec type_spec_AppointmentException = {
        "winrt._winrt_windows_applicationmodel_appointments.AppointmentException",
        sizeof(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentException),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AppointmentException};

    // ----- AppointmentInvitee class --------------------

    static PyObject* _new_AppointmentInvitee(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::ApplicationModel::Appointments::AppointmentInvitee instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_AppointmentInvitee(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentInvitee* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AppointmentInvitee_get_Role(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentInvitee* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Appointments.AppointmentInvitee", L"Role"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Role());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppointmentInvitee_put_Role(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentInvitee* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Appointments.AppointmentInvitee", L"Role"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Appointments::AppointmentParticipantRole>(arg);

            self->obj.Role(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppointmentInvitee_get_Response(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentInvitee* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Appointments.AppointmentInvitee", L"Response"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Response());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppointmentInvitee_put_Response(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentInvitee* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Appointments.AppointmentInvitee", L"Response"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Appointments::AppointmentParticipantResponse>(arg);

            self->obj.Response(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppointmentInvitee_get_DisplayName(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentInvitee* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Appointments.AppointmentInvitee", L"DisplayName"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DisplayName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppointmentInvitee_put_DisplayName(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentInvitee* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Appointments.AppointmentInvitee", L"DisplayName"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.DisplayName(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppointmentInvitee_get_Address(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentInvitee* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Appointments.AppointmentInvitee", L"Address"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Address());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppointmentInvitee_put_Address(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentInvitee* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Appointments.AppointmentInvitee", L"Address"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Address(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_AppointmentInvitee(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Appointments::AppointmentInvitee>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AppointmentInvitee(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Appointments::AppointmentInvitee>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AppointmentInvitee[] = {
        { "_assign_array_", _assign_array_AppointmentInvitee, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AppointmentInvitee), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AppointmentInvitee[] = {
        { "role", reinterpret_cast<getter>(AppointmentInvitee_get_Role), reinterpret_cast<setter>(AppointmentInvitee_put_Role), nullptr, nullptr },
        { "response", reinterpret_cast<getter>(AppointmentInvitee_get_Response), reinterpret_cast<setter>(AppointmentInvitee_put_Response), nullptr, nullptr },
        { "display_name", reinterpret_cast<getter>(AppointmentInvitee_get_DisplayName), reinterpret_cast<setter>(AppointmentInvitee_put_DisplayName), nullptr, nullptr },
        { "address", reinterpret_cast<getter>(AppointmentInvitee_get_Address), reinterpret_cast<setter>(AppointmentInvitee_put_Address), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AppointmentInvitee[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_AppointmentInvitee) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AppointmentInvitee) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AppointmentInvitee) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AppointmentInvitee) },
        { }
    };

    static PyType_Spec type_spec_AppointmentInvitee = {
        "winrt._winrt_windows_applicationmodel_appointments.AppointmentInvitee",
        sizeof(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentInvitee),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AppointmentInvitee};

    // ----- AppointmentManager class --------------------

    static PyObject* _new_AppointmentManager(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Appointments::AppointmentManager>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Appointments::AppointmentManager>::type_name);
        return nullptr;
    }

    static PyObject* AppointmentManager_GetForUser(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Appointments.AppointmentManager", L"GetForUser", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::System::User>(args, 0);

                return py::convert(winrt::Windows::ApplicationModel::Appointments::AppointmentManager::GetForUser(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppointmentManager_RequestStoreAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Appointments.AppointmentManager", L"RequestStoreAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Appointments::AppointmentStoreAccessType>(args, 0);

                return py::convert(winrt::Windows::ApplicationModel::Appointments::AppointmentManager::RequestStoreAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppointmentManager_ShowAddAppointmentAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Appointments.AppointmentManager", L"ShowAddAppointmentAsync", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Appointments::Appointment>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Rect>(args, 1);

                return py::convert(winrt::Windows::ApplicationModel::Appointments::AppointmentManager::ShowAddAppointmentAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Appointments.AppointmentManager", L"ShowAddAppointmentAsync", 3))
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Appointments::Appointment>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Rect>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::UI::Popups::Placement>(args, 2);

                return py::convert(winrt::Windows::ApplicationModel::Appointments::AppointmentManager::ShowAddAppointmentAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppointmentManager_ShowAppointmentDetailsAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Appointments.AppointmentManager", L"ShowAppointmentDetailsAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::ApplicationModel::Appointments::AppointmentManager::ShowAppointmentDetailsAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Appointments.AppointmentManager", L"ShowAppointmentDetailsAsync", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::DateTime>(args, 1);

                return py::convert(winrt::Windows::ApplicationModel::Appointments::AppointmentManager::ShowAppointmentDetailsAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppointmentManager_ShowEditNewAppointmentAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Appointments.AppointmentManager", L"ShowEditNewAppointmentAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Appointments::Appointment>(args, 0);

                return py::convert(winrt::Windows::ApplicationModel::Appointments::AppointmentManager::ShowEditNewAppointmentAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppointmentManager_ShowRemoveAppointmentAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Appointments.AppointmentManager", L"ShowRemoveAppointmentAsync", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Rect>(args, 1);

                return py::convert(winrt::Windows::ApplicationModel::Appointments::AppointmentManager::ShowRemoveAppointmentAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Appointments.AppointmentManager", L"ShowRemoveAppointmentAsync", 3))
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Rect>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::UI::Popups::Placement>(args, 2);

                return py::convert(winrt::Windows::ApplicationModel::Appointments::AppointmentManager::ShowRemoveAppointmentAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 4)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Appointments.AppointmentManager", L"ShowRemoveAppointmentAsync", 4))
                {
                    py::set_arg_count_version_error(4);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Rect>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::UI::Popups::Placement>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::Foundation::DateTime>(args, 3);

                return py::convert(winrt::Windows::ApplicationModel::Appointments::AppointmentManager::ShowRemoveAppointmentAsync(param0, param1, param2, param3));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppointmentManager_ShowReplaceAppointmentAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Appointments.AppointmentManager", L"ShowReplaceAppointmentAsync", 3))
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::ApplicationModel::Appointments::Appointment>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Rect>(args, 2);

                return py::convert(winrt::Windows::ApplicationModel::Appointments::AppointmentManager::ShowReplaceAppointmentAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 4)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Appointments.AppointmentManager", L"ShowReplaceAppointmentAsync", 4))
                {
                    py::set_arg_count_version_error(4);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::ApplicationModel::Appointments::Appointment>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Rect>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::UI::Popups::Placement>(args, 3);

                return py::convert(winrt::Windows::ApplicationModel::Appointments::AppointmentManager::ShowReplaceAppointmentAsync(param0, param1, param2, param3));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 5)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Appointments.AppointmentManager", L"ShowReplaceAppointmentAsync", 5))
                {
                    py::set_arg_count_version_error(5);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::ApplicationModel::Appointments::Appointment>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Rect>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::UI::Popups::Placement>(args, 3);
                auto param4 = py::convert_to<winrt::Windows::Foundation::DateTime>(args, 4);

                return py::convert(winrt::Windows::ApplicationModel::Appointments::AppointmentManager::ShowReplaceAppointmentAsync(param0, param1, param2, param3, param4));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppointmentManager_ShowTimeFrameAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Appointments.AppointmentManager", L"ShowTimeFrameAsync", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::DateTime>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(args, 1);

                return py::convert(winrt::Windows::ApplicationModel::Appointments::AppointmentManager::ShowTimeFrameAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyMethodDef _methods_AppointmentManager[] = {
        { }
    };

    static PyGetSetDef _getset_AppointmentManager[] = {
        { }
    };

    static PyType_Slot _type_slots_AppointmentManager[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_AppointmentManager) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AppointmentManager) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AppointmentManager) },
        { }
    };

    static PyType_Spec type_spec_AppointmentManager = {
        "winrt._winrt_windows_applicationmodel_appointments.AppointmentManager",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AppointmentManager};

    static PyGetSetDef getset_AppointmentManager_Static[] = {
        { }
    };

    static PyMethodDef methods_AppointmentManager_Static[] = {
        { "get_for_user", reinterpret_cast<PyCFunction>(AppointmentManager_GetForUser), METH_VARARGS, nullptr },
        { "request_store_async", reinterpret_cast<PyCFunction>(AppointmentManager_RequestStoreAsync), METH_VARARGS, nullptr },
        { "show_add_appointment_async", reinterpret_cast<PyCFunction>(AppointmentManager_ShowAddAppointmentAsync), METH_VARARGS, nullptr },
        { "show_appointment_details_async", reinterpret_cast<PyCFunction>(AppointmentManager_ShowAppointmentDetailsAsync), METH_VARARGS, nullptr },
        { "show_edit_new_appointment_async", reinterpret_cast<PyCFunction>(AppointmentManager_ShowEditNewAppointmentAsync), METH_VARARGS, nullptr },
        { "show_remove_appointment_async", reinterpret_cast<PyCFunction>(AppointmentManager_ShowRemoveAppointmentAsync), METH_VARARGS, nullptr },
        { "show_replace_appointment_async", reinterpret_cast<PyCFunction>(AppointmentManager_ShowReplaceAppointmentAsync), METH_VARARGS, nullptr },
        { "show_time_frame_async", reinterpret_cast<PyCFunction>(AppointmentManager_ShowTimeFrameAsync), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_AppointmentManager_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_AppointmentManager_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_AppointmentManager_Static) },
        { }
    };

    static PyType_Spec type_spec_AppointmentManager_Static =
    {
        "winrt._winrt_windows_applicationmodel_appointments.AppointmentManager_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_AppointmentManager_Static
    };

    // ----- AppointmentManagerForUser class --------------------

    static PyObject* _new_AppointmentManagerForUser(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Appointments::AppointmentManagerForUser>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Appointments::AppointmentManagerForUser>::type_name);
        return nullptr;
    }

    static void _dealloc_AppointmentManagerForUser(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentManagerForUser* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AppointmentManagerForUser_RequestStoreAsync(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentManagerForUser* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Appointments.AppointmentManagerForUser", L"RequestStoreAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Appointments::AppointmentStoreAccessType>(args, 0);

                return py::convert(self->obj.RequestStoreAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppointmentManagerForUser_ShowAddAppointmentAsync(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentManagerForUser* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Appointments.AppointmentManagerForUser", L"ShowAddAppointmentAsync", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Appointments::Appointment>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Rect>(args, 1);

                return py::convert(self->obj.ShowAddAppointmentAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Appointments.AppointmentManagerForUser", L"ShowAddAppointmentAsync", 3))
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Appointments::Appointment>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Rect>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::UI::Popups::Placement>(args, 2);

                return py::convert(self->obj.ShowAddAppointmentAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppointmentManagerForUser_ShowAppointmentDetailsAsync(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentManagerForUser* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Appointments.AppointmentManagerForUser", L"ShowAppointmentDetailsAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.ShowAppointmentDetailsAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Appointments.AppointmentManagerForUser", L"ShowAppointmentDetailsAsync", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::DateTime>(args, 1);

                return py::convert(self->obj.ShowAppointmentDetailsAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppointmentManagerForUser_ShowEditNewAppointmentAsync(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentManagerForUser* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Appointments.AppointmentManagerForUser", L"ShowEditNewAppointmentAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Appointments::Appointment>(args, 0);

                return py::convert(self->obj.ShowEditNewAppointmentAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppointmentManagerForUser_ShowRemoveAppointmentAsync(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentManagerForUser* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Appointments.AppointmentManagerForUser", L"ShowRemoveAppointmentAsync", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Rect>(args, 1);

                return py::convert(self->obj.ShowRemoveAppointmentAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Appointments.AppointmentManagerForUser", L"ShowRemoveAppointmentAsync", 3))
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Rect>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::UI::Popups::Placement>(args, 2);

                return py::convert(self->obj.ShowRemoveAppointmentAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 4)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Appointments.AppointmentManagerForUser", L"ShowRemoveAppointmentAsync", 4))
                {
                    py::set_arg_count_version_error(4);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Rect>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::UI::Popups::Placement>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::Foundation::DateTime>(args, 3);

                return py::convert(self->obj.ShowRemoveAppointmentAsync(param0, param1, param2, param3));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppointmentManagerForUser_ShowReplaceAppointmentAsync(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentManagerForUser* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Appointments.AppointmentManagerForUser", L"ShowReplaceAppointmentAsync", 3))
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::ApplicationModel::Appointments::Appointment>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Rect>(args, 2);

                return py::convert(self->obj.ShowReplaceAppointmentAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 4)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Appointments.AppointmentManagerForUser", L"ShowReplaceAppointmentAsync", 4))
                {
                    py::set_arg_count_version_error(4);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::ApplicationModel::Appointments::Appointment>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Rect>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::UI::Popups::Placement>(args, 3);

                return py::convert(self->obj.ShowReplaceAppointmentAsync(param0, param1, param2, param3));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 5)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Appointments.AppointmentManagerForUser", L"ShowReplaceAppointmentAsync", 5))
                {
                    py::set_arg_count_version_error(5);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::ApplicationModel::Appointments::Appointment>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Rect>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::UI::Popups::Placement>(args, 3);
                auto param4 = py::convert_to<winrt::Windows::Foundation::DateTime>(args, 4);

                return py::convert(self->obj.ShowReplaceAppointmentAsync(param0, param1, param2, param3, param4));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppointmentManagerForUser_ShowTimeFrameAsync(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentManagerForUser* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Appointments.AppointmentManagerForUser", L"ShowTimeFrameAsync", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::DateTime>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(args, 1);

                return py::convert(self->obj.ShowTimeFrameAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppointmentManagerForUser_get_User(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentManagerForUser* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Appointments.AppointmentManagerForUser", L"User"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.User());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AppointmentManagerForUser(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Appointments::AppointmentManagerForUser>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AppointmentManagerForUser(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Appointments::AppointmentManagerForUser>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AppointmentManagerForUser[] = {
        { "request_store_async", reinterpret_cast<PyCFunction>(AppointmentManagerForUser_RequestStoreAsync), METH_VARARGS, nullptr },
        { "show_add_appointment_async", reinterpret_cast<PyCFunction>(AppointmentManagerForUser_ShowAddAppointmentAsync), METH_VARARGS, nullptr },
        { "show_appointment_details_async", reinterpret_cast<PyCFunction>(AppointmentManagerForUser_ShowAppointmentDetailsAsync), METH_VARARGS, nullptr },
        { "show_edit_new_appointment_async", reinterpret_cast<PyCFunction>(AppointmentManagerForUser_ShowEditNewAppointmentAsync), METH_VARARGS, nullptr },
        { "show_remove_appointment_async", reinterpret_cast<PyCFunction>(AppointmentManagerForUser_ShowRemoveAppointmentAsync), METH_VARARGS, nullptr },
        { "show_replace_appointment_async", reinterpret_cast<PyCFunction>(AppointmentManagerForUser_ShowReplaceAppointmentAsync), METH_VARARGS, nullptr },
        { "show_time_frame_async", reinterpret_cast<PyCFunction>(AppointmentManagerForUser_ShowTimeFrameAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_AppointmentManagerForUser, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AppointmentManagerForUser), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AppointmentManagerForUser[] = {
        { "user", reinterpret_cast<getter>(AppointmentManagerForUser_get_User), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AppointmentManagerForUser[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_AppointmentManagerForUser) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AppointmentManagerForUser) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AppointmentManagerForUser) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AppointmentManagerForUser) },
        { }
    };

    static PyType_Spec type_spec_AppointmentManagerForUser = {
        "winrt._winrt_windows_applicationmodel_appointments.AppointmentManagerForUser",
        sizeof(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentManagerForUser),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AppointmentManagerForUser};

    // ----- AppointmentOrganizer class --------------------

    static PyObject* _new_AppointmentOrganizer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::ApplicationModel::Appointments::AppointmentOrganizer instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_AppointmentOrganizer(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentOrganizer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AppointmentOrganizer_get_DisplayName(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentOrganizer* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Appointments.AppointmentOrganizer", L"DisplayName"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DisplayName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppointmentOrganizer_put_DisplayName(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentOrganizer* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Appointments.AppointmentOrganizer", L"DisplayName"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.DisplayName(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppointmentOrganizer_get_Address(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentOrganizer* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Appointments.AppointmentOrganizer", L"Address"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Address());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppointmentOrganizer_put_Address(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentOrganizer* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Appointments.AppointmentOrganizer", L"Address"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Address(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_AppointmentOrganizer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Appointments::AppointmentOrganizer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AppointmentOrganizer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Appointments::AppointmentOrganizer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AppointmentOrganizer[] = {
        { "_assign_array_", _assign_array_AppointmentOrganizer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AppointmentOrganizer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AppointmentOrganizer[] = {
        { "display_name", reinterpret_cast<getter>(AppointmentOrganizer_get_DisplayName), reinterpret_cast<setter>(AppointmentOrganizer_put_DisplayName), nullptr, nullptr },
        { "address", reinterpret_cast<getter>(AppointmentOrganizer_get_Address), reinterpret_cast<setter>(AppointmentOrganizer_put_Address), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AppointmentOrganizer[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_AppointmentOrganizer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AppointmentOrganizer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AppointmentOrganizer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AppointmentOrganizer) },
        { }
    };

    static PyType_Spec type_spec_AppointmentOrganizer = {
        "winrt._winrt_windows_applicationmodel_appointments.AppointmentOrganizer",
        sizeof(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentOrganizer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AppointmentOrganizer};

    // ----- AppointmentProperties class --------------------

    static PyObject* _new_AppointmentProperties(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Appointments::AppointmentProperties>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Appointments::AppointmentProperties>::type_name);
        return nullptr;
    }

    static PyObject* AppointmentProperties_get_HasInvitees(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Appointments.AppointmentProperties", L"HasInvitees"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::ApplicationModel::Appointments::AppointmentProperties::HasInvitees());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppointmentProperties_get_AllDay(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Appointments.AppointmentProperties", L"AllDay"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::ApplicationModel::Appointments::AppointmentProperties::AllDay());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppointmentProperties_get_AllowNewTimeProposal(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Appointments.AppointmentProperties", L"AllowNewTimeProposal"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::ApplicationModel::Appointments::AppointmentProperties::AllowNewTimeProposal());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppointmentProperties_get_BusyStatus(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Appointments.AppointmentProperties", L"BusyStatus"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::ApplicationModel::Appointments::AppointmentProperties::BusyStatus());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppointmentProperties_get_DefaultProperties(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Appointments.AppointmentProperties", L"DefaultProperties"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::ApplicationModel::Appointments::AppointmentProperties::DefaultProperties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppointmentProperties_get_Details(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Appointments.AppointmentProperties", L"Details"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::ApplicationModel::Appointments::AppointmentProperties::Details());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppointmentProperties_get_Duration(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Appointments.AppointmentProperties", L"Duration"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::ApplicationModel::Appointments::AppointmentProperties::Duration());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppointmentProperties_get_Recurrence(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Appointments.AppointmentProperties", L"Recurrence"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::ApplicationModel::Appointments::AppointmentProperties::Recurrence());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppointmentProperties_get_Invitees(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Appointments.AppointmentProperties", L"Invitees"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::ApplicationModel::Appointments::AppointmentProperties::Invitees());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppointmentProperties_get_IsCanceledMeeting(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Appointments.AppointmentProperties", L"IsCanceledMeeting"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::ApplicationModel::Appointments::AppointmentProperties::IsCanceledMeeting());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppointmentProperties_get_IsOrganizedByUser(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Appointments.AppointmentProperties", L"IsOrganizedByUser"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::ApplicationModel::Appointments::AppointmentProperties::IsOrganizedByUser());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppointmentProperties_get_IsResponseRequested(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Appointments.AppointmentProperties", L"IsResponseRequested"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::ApplicationModel::Appointments::AppointmentProperties::IsResponseRequested());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppointmentProperties_get_Location(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Appointments.AppointmentProperties", L"Location"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::ApplicationModel::Appointments::AppointmentProperties::Location());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppointmentProperties_get_OnlineMeetingLink(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Appointments.AppointmentProperties", L"OnlineMeetingLink"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::ApplicationModel::Appointments::AppointmentProperties::OnlineMeetingLink());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppointmentProperties_get_Organizer(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Appointments.AppointmentProperties", L"Organizer"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::ApplicationModel::Appointments::AppointmentProperties::Organizer());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppointmentProperties_get_OriginalStartTime(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Appointments.AppointmentProperties", L"OriginalStartTime"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::ApplicationModel::Appointments::AppointmentProperties::OriginalStartTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppointmentProperties_get_Reminder(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Appointments.AppointmentProperties", L"Reminder"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::ApplicationModel::Appointments::AppointmentProperties::Reminder());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppointmentProperties_get_ReplyTime(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Appointments.AppointmentProperties", L"ReplyTime"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::ApplicationModel::Appointments::AppointmentProperties::ReplyTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppointmentProperties_get_Sensitivity(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Appointments.AppointmentProperties", L"Sensitivity"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::ApplicationModel::Appointments::AppointmentProperties::Sensitivity());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppointmentProperties_get_StartTime(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Appointments.AppointmentProperties", L"StartTime"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::ApplicationModel::Appointments::AppointmentProperties::StartTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppointmentProperties_get_Subject(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Appointments.AppointmentProperties", L"Subject"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::ApplicationModel::Appointments::AppointmentProperties::Subject());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppointmentProperties_get_Uri(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Appointments.AppointmentProperties", L"Uri"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::ApplicationModel::Appointments::AppointmentProperties::Uri());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppointmentProperties_get_UserResponse(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Appointments.AppointmentProperties", L"UserResponse"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::ApplicationModel::Appointments::AppointmentProperties::UserResponse());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppointmentProperties_get_DetailsKind(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Appointments.AppointmentProperties", L"DetailsKind"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::ApplicationModel::Appointments::AppointmentProperties::DetailsKind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppointmentProperties_get_RemoteChangeNumber(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Appointments.AppointmentProperties", L"RemoteChangeNumber"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::ApplicationModel::Appointments::AppointmentProperties::RemoteChangeNumber());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppointmentProperties_get_ChangeNumber(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Appointments.AppointmentProperties", L"ChangeNumber"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::ApplicationModel::Appointments::AppointmentProperties::ChangeNumber());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AppointmentProperties[] = {
        { }
    };

    static PyGetSetDef _getset_AppointmentProperties[] = {
        { }
    };

    static PyType_Slot _type_slots_AppointmentProperties[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_AppointmentProperties) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AppointmentProperties) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AppointmentProperties) },
        { }
    };

    static PyType_Spec type_spec_AppointmentProperties = {
        "winrt._winrt_windows_applicationmodel_appointments.AppointmentProperties",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AppointmentProperties};

    static PyGetSetDef getset_AppointmentProperties_Static[] = {
        { "has_invitees", reinterpret_cast<getter>(AppointmentProperties_get_HasInvitees), nullptr, nullptr, nullptr },
        { "all_day", reinterpret_cast<getter>(AppointmentProperties_get_AllDay), nullptr, nullptr, nullptr },
        { "allow_new_time_proposal", reinterpret_cast<getter>(AppointmentProperties_get_AllowNewTimeProposal), nullptr, nullptr, nullptr },
        { "busy_status", reinterpret_cast<getter>(AppointmentProperties_get_BusyStatus), nullptr, nullptr, nullptr },
        { "default_properties", reinterpret_cast<getter>(AppointmentProperties_get_DefaultProperties), nullptr, nullptr, nullptr },
        { "details", reinterpret_cast<getter>(AppointmentProperties_get_Details), nullptr, nullptr, nullptr },
        { "duration", reinterpret_cast<getter>(AppointmentProperties_get_Duration), nullptr, nullptr, nullptr },
        { "recurrence", reinterpret_cast<getter>(AppointmentProperties_get_Recurrence), nullptr, nullptr, nullptr },
        { "invitees", reinterpret_cast<getter>(AppointmentProperties_get_Invitees), nullptr, nullptr, nullptr },
        { "is_canceled_meeting", reinterpret_cast<getter>(AppointmentProperties_get_IsCanceledMeeting), nullptr, nullptr, nullptr },
        { "is_organized_by_user", reinterpret_cast<getter>(AppointmentProperties_get_IsOrganizedByUser), nullptr, nullptr, nullptr },
        { "is_response_requested", reinterpret_cast<getter>(AppointmentProperties_get_IsResponseRequested), nullptr, nullptr, nullptr },
        { "location", reinterpret_cast<getter>(AppointmentProperties_get_Location), nullptr, nullptr, nullptr },
        { "online_meeting_link", reinterpret_cast<getter>(AppointmentProperties_get_OnlineMeetingLink), nullptr, nullptr, nullptr },
        { "organizer", reinterpret_cast<getter>(AppointmentProperties_get_Organizer), nullptr, nullptr, nullptr },
        { "original_start_time", reinterpret_cast<getter>(AppointmentProperties_get_OriginalStartTime), nullptr, nullptr, nullptr },
        { "reminder", reinterpret_cast<getter>(AppointmentProperties_get_Reminder), nullptr, nullptr, nullptr },
        { "reply_time", reinterpret_cast<getter>(AppointmentProperties_get_ReplyTime), nullptr, nullptr, nullptr },
        { "sensitivity", reinterpret_cast<getter>(AppointmentProperties_get_Sensitivity), nullptr, nullptr, nullptr },
        { "start_time", reinterpret_cast<getter>(AppointmentProperties_get_StartTime), nullptr, nullptr, nullptr },
        { "subject", reinterpret_cast<getter>(AppointmentProperties_get_Subject), nullptr, nullptr, nullptr },
        { "uri", reinterpret_cast<getter>(AppointmentProperties_get_Uri), nullptr, nullptr, nullptr },
        { "user_response", reinterpret_cast<getter>(AppointmentProperties_get_UserResponse), nullptr, nullptr, nullptr },
        { "details_kind", reinterpret_cast<getter>(AppointmentProperties_get_DetailsKind), nullptr, nullptr, nullptr },
        { "remote_change_number", reinterpret_cast<getter>(AppointmentProperties_get_RemoteChangeNumber), nullptr, nullptr, nullptr },
        { "change_number", reinterpret_cast<getter>(AppointmentProperties_get_ChangeNumber), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_AppointmentProperties_Static[] = {
        { }
    };

    static PyType_Slot type_slots_AppointmentProperties_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_AppointmentProperties_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_AppointmentProperties_Static) },
        { }
    };

    static PyType_Spec type_spec_AppointmentProperties_Static =
    {
        "winrt._winrt_windows_applicationmodel_appointments.AppointmentProperties_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_AppointmentProperties_Static
    };

    // ----- AppointmentRecurrence class --------------------

    static PyObject* _new_AppointmentRecurrence(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::ApplicationModel::Appointments::AppointmentRecurrence instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_AppointmentRecurrence(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentRecurrence* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AppointmentRecurrence_get_Unit(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentRecurrence* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Appointments.AppointmentRecurrence", L"Unit"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Unit());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppointmentRecurrence_put_Unit(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentRecurrence* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Appointments.AppointmentRecurrence", L"Unit"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Appointments::AppointmentRecurrenceUnit>(arg);

            self->obj.Unit(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppointmentRecurrence_get_Occurrences(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentRecurrence* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Appointments.AppointmentRecurrence", L"Occurrences"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Occurrences());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppointmentRecurrence_put_Occurrences(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentRecurrence* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Appointments.AppointmentRecurrence", L"Occurrences"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<uint32_t>>(arg);

            self->obj.Occurrences(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppointmentRecurrence_get_Month(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentRecurrence* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Appointments.AppointmentRecurrence", L"Month"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Month());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppointmentRecurrence_put_Month(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentRecurrence* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Appointments.AppointmentRecurrence", L"Month"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.Month(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppointmentRecurrence_get_Interval(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentRecurrence* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Appointments.AppointmentRecurrence", L"Interval"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Interval());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppointmentRecurrence_put_Interval(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentRecurrence* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Appointments.AppointmentRecurrence", L"Interval"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.Interval(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppointmentRecurrence_get_DaysOfWeek(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentRecurrence* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Appointments.AppointmentRecurrence", L"DaysOfWeek"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DaysOfWeek());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppointmentRecurrence_put_DaysOfWeek(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentRecurrence* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Appointments.AppointmentRecurrence", L"DaysOfWeek"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Appointments::AppointmentDaysOfWeek>(arg);

            self->obj.DaysOfWeek(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppointmentRecurrence_get_Day(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentRecurrence* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Appointments.AppointmentRecurrence", L"Day"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Day());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppointmentRecurrence_put_Day(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentRecurrence* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Appointments.AppointmentRecurrence", L"Day"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.Day(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppointmentRecurrence_get_WeekOfMonth(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentRecurrence* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Appointments.AppointmentRecurrence", L"WeekOfMonth"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.WeekOfMonth());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppointmentRecurrence_put_WeekOfMonth(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentRecurrence* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Appointments.AppointmentRecurrence", L"WeekOfMonth"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Appointments::AppointmentWeekOfMonth>(arg);

            self->obj.WeekOfMonth(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppointmentRecurrence_get_Until(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentRecurrence* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Appointments.AppointmentRecurrence", L"Until"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Until());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppointmentRecurrence_put_Until(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentRecurrence* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Appointments.AppointmentRecurrence", L"Until"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::DateTime>>(arg);

            self->obj.Until(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppointmentRecurrence_get_TimeZone(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentRecurrence* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Appointments.AppointmentRecurrence", L"TimeZone"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.TimeZone());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppointmentRecurrence_put_TimeZone(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentRecurrence* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Appointments.AppointmentRecurrence", L"TimeZone"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.TimeZone(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppointmentRecurrence_get_RecurrenceType(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentRecurrence* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Appointments.AppointmentRecurrence", L"RecurrenceType"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.RecurrenceType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppointmentRecurrence_get_CalendarIdentifier(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentRecurrence* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Appointments.AppointmentRecurrence", L"CalendarIdentifier"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CalendarIdentifier());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AppointmentRecurrence(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Appointments::AppointmentRecurrence>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AppointmentRecurrence(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Appointments::AppointmentRecurrence>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AppointmentRecurrence[] = {
        { "_assign_array_", _assign_array_AppointmentRecurrence, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AppointmentRecurrence), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AppointmentRecurrence[] = {
        { "unit", reinterpret_cast<getter>(AppointmentRecurrence_get_Unit), reinterpret_cast<setter>(AppointmentRecurrence_put_Unit), nullptr, nullptr },
        { "occurrences", reinterpret_cast<getter>(AppointmentRecurrence_get_Occurrences), reinterpret_cast<setter>(AppointmentRecurrence_put_Occurrences), nullptr, nullptr },
        { "month", reinterpret_cast<getter>(AppointmentRecurrence_get_Month), reinterpret_cast<setter>(AppointmentRecurrence_put_Month), nullptr, nullptr },
        { "interval", reinterpret_cast<getter>(AppointmentRecurrence_get_Interval), reinterpret_cast<setter>(AppointmentRecurrence_put_Interval), nullptr, nullptr },
        { "days_of_week", reinterpret_cast<getter>(AppointmentRecurrence_get_DaysOfWeek), reinterpret_cast<setter>(AppointmentRecurrence_put_DaysOfWeek), nullptr, nullptr },
        { "day", reinterpret_cast<getter>(AppointmentRecurrence_get_Day), reinterpret_cast<setter>(AppointmentRecurrence_put_Day), nullptr, nullptr },
        { "week_of_month", reinterpret_cast<getter>(AppointmentRecurrence_get_WeekOfMonth), reinterpret_cast<setter>(AppointmentRecurrence_put_WeekOfMonth), nullptr, nullptr },
        { "until", reinterpret_cast<getter>(AppointmentRecurrence_get_Until), reinterpret_cast<setter>(AppointmentRecurrence_put_Until), nullptr, nullptr },
        { "time_zone", reinterpret_cast<getter>(AppointmentRecurrence_get_TimeZone), reinterpret_cast<setter>(AppointmentRecurrence_put_TimeZone), nullptr, nullptr },
        { "recurrence_type", reinterpret_cast<getter>(AppointmentRecurrence_get_RecurrenceType), nullptr, nullptr, nullptr },
        { "calendar_identifier", reinterpret_cast<getter>(AppointmentRecurrence_get_CalendarIdentifier), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AppointmentRecurrence[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_AppointmentRecurrence) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AppointmentRecurrence) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AppointmentRecurrence) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AppointmentRecurrence) },
        { }
    };

    static PyType_Spec type_spec_AppointmentRecurrence = {
        "winrt._winrt_windows_applicationmodel_appointments.AppointmentRecurrence",
        sizeof(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentRecurrence),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AppointmentRecurrence};

    // ----- AppointmentStore class --------------------

    static PyObject* _new_AppointmentStore(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Appointments::AppointmentStore>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Appointments::AppointmentStore>::type_name);
        return nullptr;
    }

    static void _dealloc_AppointmentStore(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentStore* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AppointmentStore_CreateAppointmentCalendarAsync(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentStore* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Appointments.AppointmentStore", L"CreateAppointmentCalendarAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.CreateAppointmentCalendarAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Appointments.AppointmentStore", L"CreateAppointmentCalendarAsync", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert(self->obj.CreateAppointmentCalendarAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppointmentStore_FindAppointmentCalendarsAsync(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentStore* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Appointments.AppointmentStore", L"FindAppointmentCalendarsAsync", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.FindAppointmentCalendarsAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Appointments.AppointmentStore", L"FindAppointmentCalendarsAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Appointments::FindAppointmentCalendarsOptions>(args, 0);

                return py::convert(self->obj.FindAppointmentCalendarsAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppointmentStore_FindAppointmentsAsync(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentStore* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Appointments.AppointmentStore", L"FindAppointmentsAsync", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::DateTime>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(args, 1);

                return py::convert(self->obj.FindAppointmentsAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Appointments.AppointmentStore", L"FindAppointmentsAsync", 3))
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::DateTime>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::ApplicationModel::Appointments::FindAppointmentsOptions>(args, 2);

                return py::convert(self->obj.FindAppointmentsAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppointmentStore_FindConflictAsync(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentStore* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Appointments.AppointmentStore", L"FindConflictAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Appointments::Appointment>(args, 0);

                return py::convert(self->obj.FindConflictAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Appointments.AppointmentStore", L"FindConflictAsync", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Appointments::Appointment>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::DateTime>(args, 1);

                return py::convert(self->obj.FindConflictAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppointmentStore_FindLocalIdsFromRoamingIdAsync(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentStore* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Appointments.AppointmentStore", L"FindLocalIdsFromRoamingIdAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.FindLocalIdsFromRoamingIdAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppointmentStore_GetAppointmentAsync(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentStore* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Appointments.AppointmentStore", L"GetAppointmentAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.GetAppointmentAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppointmentStore_GetAppointmentCalendarAsync(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentStore* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Appointments.AppointmentStore", L"GetAppointmentCalendarAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.GetAppointmentCalendarAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppointmentStore_GetAppointmentInstanceAsync(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentStore* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Appointments.AppointmentStore", L"GetAppointmentInstanceAsync", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::DateTime>(args, 1);

                return py::convert(self->obj.GetAppointmentInstanceAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppointmentStore_GetChangeTracker(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentStore* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Appointments.AppointmentStore", L"GetChangeTracker", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.GetChangeTracker(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppointmentStore_MoveAppointmentAsync(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentStore* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Appointments.AppointmentStore", L"MoveAppointmentAsync", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Appointments::Appointment>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::ApplicationModel::Appointments::AppointmentCalendar>(args, 1);

                return py::convert(self->obj.MoveAppointmentAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppointmentStore_ShowAddAppointmentAsync(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentStore* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Appointments.AppointmentStore", L"ShowAddAppointmentAsync", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Appointments::Appointment>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Rect>(args, 1);

                return py::convert(self->obj.ShowAddAppointmentAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppointmentStore_ShowAppointmentDetailsAsync(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentStore* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Appointments.AppointmentStore", L"ShowAppointmentDetailsAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.ShowAppointmentDetailsAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Appointments.AppointmentStore", L"ShowAppointmentDetailsAsync", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::DateTime>(args, 1);

                return py::convert(self->obj.ShowAppointmentDetailsAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppointmentStore_ShowEditNewAppointmentAsync(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentStore* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Appointments.AppointmentStore", L"ShowEditNewAppointmentAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Appointments::Appointment>(args, 0);

                return py::convert(self->obj.ShowEditNewAppointmentAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppointmentStore_ShowRemoveAppointmentAsync(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentStore* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Appointments.AppointmentStore", L"ShowRemoveAppointmentAsync", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Rect>(args, 1);

                return py::convert(self->obj.ShowRemoveAppointmentAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 4)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Appointments.AppointmentStore", L"ShowRemoveAppointmentAsync", 4))
                {
                    py::set_arg_count_version_error(4);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Rect>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::UI::Popups::Placement>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::Foundation::DateTime>(args, 3);

                return py::convert(self->obj.ShowRemoveAppointmentAsync(param0, param1, param2, param3));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppointmentStore_ShowReplaceAppointmentAsync(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentStore* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Appointments.AppointmentStore", L"ShowReplaceAppointmentAsync", 3))
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::ApplicationModel::Appointments::Appointment>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Rect>(args, 2);

                return py::convert(self->obj.ShowReplaceAppointmentAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 5)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Appointments.AppointmentStore", L"ShowReplaceAppointmentAsync", 5))
                {
                    py::set_arg_count_version_error(5);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::ApplicationModel::Appointments::Appointment>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Rect>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::UI::Popups::Placement>(args, 3);
                auto param4 = py::convert_to<winrt::Windows::Foundation::DateTime>(args, 4);

                return py::convert(self->obj.ShowReplaceAppointmentAsync(param0, param1, param2, param3, param4));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppointmentStore_get_ChangeTracker(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentStore* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Appointments.AppointmentStore", L"ChangeTracker"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ChangeTracker());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppointmentStore_add_StoreChanged(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentStore* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.Appointments.AppointmentStore", L"StoreChanged"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::ApplicationModel::Appointments::AppointmentStore, winrt::Windows::ApplicationModel::Appointments::AppointmentStoreChangedEventArgs>>(arg);

            return py::convert(self->obj.StoreChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppointmentStore_remove_StoreChanged(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentStore* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.Appointments.AppointmentStore", L"StoreChanged"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.StoreChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AppointmentStore(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Appointments::AppointmentStore>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AppointmentStore(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Appointments::AppointmentStore>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AppointmentStore[] = {
        { "create_appointment_calendar_async", reinterpret_cast<PyCFunction>(AppointmentStore_CreateAppointmentCalendarAsync), METH_VARARGS, nullptr },
        { "find_appointment_calendars_async", reinterpret_cast<PyCFunction>(AppointmentStore_FindAppointmentCalendarsAsync), METH_VARARGS, nullptr },
        { "find_appointments_async", reinterpret_cast<PyCFunction>(AppointmentStore_FindAppointmentsAsync), METH_VARARGS, nullptr },
        { "find_conflict_async", reinterpret_cast<PyCFunction>(AppointmentStore_FindConflictAsync), METH_VARARGS, nullptr },
        { "find_local_ids_from_roaming_id_async", reinterpret_cast<PyCFunction>(AppointmentStore_FindLocalIdsFromRoamingIdAsync), METH_VARARGS, nullptr },
        { "get_appointment_async", reinterpret_cast<PyCFunction>(AppointmentStore_GetAppointmentAsync), METH_VARARGS, nullptr },
        { "get_appointment_calendar_async", reinterpret_cast<PyCFunction>(AppointmentStore_GetAppointmentCalendarAsync), METH_VARARGS, nullptr },
        { "get_appointment_instance_async", reinterpret_cast<PyCFunction>(AppointmentStore_GetAppointmentInstanceAsync), METH_VARARGS, nullptr },
        { "get_change_tracker", reinterpret_cast<PyCFunction>(AppointmentStore_GetChangeTracker), METH_VARARGS, nullptr },
        { "move_appointment_async", reinterpret_cast<PyCFunction>(AppointmentStore_MoveAppointmentAsync), METH_VARARGS, nullptr },
        { "show_add_appointment_async", reinterpret_cast<PyCFunction>(AppointmentStore_ShowAddAppointmentAsync), METH_VARARGS, nullptr },
        { "show_appointment_details_async", reinterpret_cast<PyCFunction>(AppointmentStore_ShowAppointmentDetailsAsync), METH_VARARGS, nullptr },
        { "show_edit_new_appointment_async", reinterpret_cast<PyCFunction>(AppointmentStore_ShowEditNewAppointmentAsync), METH_VARARGS, nullptr },
        { "show_remove_appointment_async", reinterpret_cast<PyCFunction>(AppointmentStore_ShowRemoveAppointmentAsync), METH_VARARGS, nullptr },
        { "show_replace_appointment_async", reinterpret_cast<PyCFunction>(AppointmentStore_ShowReplaceAppointmentAsync), METH_VARARGS, nullptr },
        { "add_store_changed", reinterpret_cast<PyCFunction>(AppointmentStore_add_StoreChanged), METH_O, nullptr },
        { "remove_store_changed", reinterpret_cast<PyCFunction>(AppointmentStore_remove_StoreChanged), METH_O, nullptr },
        { "_assign_array_", _assign_array_AppointmentStore, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AppointmentStore), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AppointmentStore[] = {
        { "change_tracker", reinterpret_cast<getter>(AppointmentStore_get_ChangeTracker), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AppointmentStore[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_AppointmentStore) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AppointmentStore) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AppointmentStore) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AppointmentStore) },
        { }
    };

    static PyType_Spec type_spec_AppointmentStore = {
        "winrt._winrt_windows_applicationmodel_appointments.AppointmentStore",
        sizeof(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentStore),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AppointmentStore};

    // ----- AppointmentStoreChange class --------------------

    static PyObject* _new_AppointmentStoreChange(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Appointments::AppointmentStoreChange>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Appointments::AppointmentStoreChange>::type_name);
        return nullptr;
    }

    static void _dealloc_AppointmentStoreChange(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentStoreChange* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AppointmentStoreChange_get_Appointment(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentStoreChange* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Appointments.AppointmentStoreChange", L"Appointment"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Appointment());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppointmentStoreChange_get_ChangeType(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentStoreChange* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Appointments.AppointmentStoreChange", L"ChangeType"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ChangeType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppointmentStoreChange_get_AppointmentCalendar(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentStoreChange* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Appointments.AppointmentStoreChange", L"AppointmentCalendar"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.AppointmentCalendar());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AppointmentStoreChange(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Appointments::AppointmentStoreChange>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AppointmentStoreChange(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Appointments::AppointmentStoreChange>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AppointmentStoreChange[] = {
        { "_assign_array_", _assign_array_AppointmentStoreChange, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AppointmentStoreChange), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AppointmentStoreChange[] = {
        { "appointment", reinterpret_cast<getter>(AppointmentStoreChange_get_Appointment), nullptr, nullptr, nullptr },
        { "change_type", reinterpret_cast<getter>(AppointmentStoreChange_get_ChangeType), nullptr, nullptr, nullptr },
        { "appointment_calendar", reinterpret_cast<getter>(AppointmentStoreChange_get_AppointmentCalendar), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AppointmentStoreChange[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_AppointmentStoreChange) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AppointmentStoreChange) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AppointmentStoreChange) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AppointmentStoreChange) },
        { }
    };

    static PyType_Spec type_spec_AppointmentStoreChange = {
        "winrt._winrt_windows_applicationmodel_appointments.AppointmentStoreChange",
        sizeof(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentStoreChange),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AppointmentStoreChange};

    // ----- AppointmentStoreChangeReader class --------------------

    static PyObject* _new_AppointmentStoreChangeReader(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Appointments::AppointmentStoreChangeReader>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Appointments::AppointmentStoreChangeReader>::type_name);
        return nullptr;
    }

    static void _dealloc_AppointmentStoreChangeReader(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentStoreChangeReader* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AppointmentStoreChangeReader_AcceptChanges(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentStoreChangeReader* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Appointments.AppointmentStoreChangeReader", L"AcceptChanges", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.AcceptChanges();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppointmentStoreChangeReader_AcceptChangesThrough(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentStoreChangeReader* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Appointments.AppointmentStoreChangeReader", L"AcceptChangesThrough", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Appointments::AppointmentStoreChange>(args, 0);

                self->obj.AcceptChangesThrough(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppointmentStoreChangeReader_ReadBatchAsync(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentStoreChangeReader* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Appointments.AppointmentStoreChangeReader", L"ReadBatchAsync", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.ReadBatchAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_AppointmentStoreChangeReader(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Appointments::AppointmentStoreChangeReader>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AppointmentStoreChangeReader(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Appointments::AppointmentStoreChangeReader>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AppointmentStoreChangeReader[] = {
        { "accept_changes", reinterpret_cast<PyCFunction>(AppointmentStoreChangeReader_AcceptChanges), METH_VARARGS, nullptr },
        { "accept_changes_through", reinterpret_cast<PyCFunction>(AppointmentStoreChangeReader_AcceptChangesThrough), METH_VARARGS, nullptr },
        { "read_batch_async", reinterpret_cast<PyCFunction>(AppointmentStoreChangeReader_ReadBatchAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_AppointmentStoreChangeReader, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AppointmentStoreChangeReader), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AppointmentStoreChangeReader[] = {
        { }
    };

    static PyType_Slot _type_slots_AppointmentStoreChangeReader[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_AppointmentStoreChangeReader) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AppointmentStoreChangeReader) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AppointmentStoreChangeReader) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AppointmentStoreChangeReader) },
        { }
    };

    static PyType_Spec type_spec_AppointmentStoreChangeReader = {
        "winrt._winrt_windows_applicationmodel_appointments.AppointmentStoreChangeReader",
        sizeof(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentStoreChangeReader),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AppointmentStoreChangeReader};

    // ----- AppointmentStoreChangeTracker class --------------------

    static PyObject* _new_AppointmentStoreChangeTracker(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Appointments::AppointmentStoreChangeTracker>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Appointments::AppointmentStoreChangeTracker>::type_name);
        return nullptr;
    }

    static void _dealloc_AppointmentStoreChangeTracker(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentStoreChangeTracker* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AppointmentStoreChangeTracker_Enable(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentStoreChangeTracker* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Appointments.AppointmentStoreChangeTracker", L"Enable", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Enable();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppointmentStoreChangeTracker_GetChangeReader(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentStoreChangeTracker* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Appointments.AppointmentStoreChangeTracker", L"GetChangeReader", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetChangeReader());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppointmentStoreChangeTracker_Reset(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentStoreChangeTracker* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Appointments.AppointmentStoreChangeTracker", L"Reset", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Reset();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppointmentStoreChangeTracker_get_IsTracking(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentStoreChangeTracker* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Appointments.AppointmentStoreChangeTracker", L"IsTracking"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsTracking());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AppointmentStoreChangeTracker(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Appointments::AppointmentStoreChangeTracker>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AppointmentStoreChangeTracker(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Appointments::AppointmentStoreChangeTracker>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AppointmentStoreChangeTracker[] = {
        { "enable", reinterpret_cast<PyCFunction>(AppointmentStoreChangeTracker_Enable), METH_VARARGS, nullptr },
        { "get_change_reader", reinterpret_cast<PyCFunction>(AppointmentStoreChangeTracker_GetChangeReader), METH_VARARGS, nullptr },
        { "reset", reinterpret_cast<PyCFunction>(AppointmentStoreChangeTracker_Reset), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_AppointmentStoreChangeTracker, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AppointmentStoreChangeTracker), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AppointmentStoreChangeTracker[] = {
        { "is_tracking", reinterpret_cast<getter>(AppointmentStoreChangeTracker_get_IsTracking), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AppointmentStoreChangeTracker[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_AppointmentStoreChangeTracker) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AppointmentStoreChangeTracker) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AppointmentStoreChangeTracker) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AppointmentStoreChangeTracker) },
        { }
    };

    static PyType_Spec type_spec_AppointmentStoreChangeTracker = {
        "winrt._winrt_windows_applicationmodel_appointments.AppointmentStoreChangeTracker",
        sizeof(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentStoreChangeTracker),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AppointmentStoreChangeTracker};

    // ----- AppointmentStoreChangedDeferral class --------------------

    static PyObject* _new_AppointmentStoreChangedDeferral(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Appointments::AppointmentStoreChangedDeferral>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Appointments::AppointmentStoreChangedDeferral>::type_name);
        return nullptr;
    }

    static void _dealloc_AppointmentStoreChangedDeferral(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentStoreChangedDeferral* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AppointmentStoreChangedDeferral_Complete(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentStoreChangedDeferral* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Appointments.AppointmentStoreChangedDeferral", L"Complete", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Complete();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_AppointmentStoreChangedDeferral(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Appointments::AppointmentStoreChangedDeferral>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AppointmentStoreChangedDeferral(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Appointments::AppointmentStoreChangedDeferral>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AppointmentStoreChangedDeferral[] = {
        { "complete", reinterpret_cast<PyCFunction>(AppointmentStoreChangedDeferral_Complete), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_AppointmentStoreChangedDeferral, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AppointmentStoreChangedDeferral), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AppointmentStoreChangedDeferral[] = {
        { }
    };

    static PyType_Slot _type_slots_AppointmentStoreChangedDeferral[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_AppointmentStoreChangedDeferral) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AppointmentStoreChangedDeferral) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AppointmentStoreChangedDeferral) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AppointmentStoreChangedDeferral) },
        { }
    };

    static PyType_Spec type_spec_AppointmentStoreChangedDeferral = {
        "winrt._winrt_windows_applicationmodel_appointments.AppointmentStoreChangedDeferral",
        sizeof(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentStoreChangedDeferral),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AppointmentStoreChangedDeferral};

    // ----- AppointmentStoreChangedEventArgs class --------------------

    static PyObject* _new_AppointmentStoreChangedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Appointments::AppointmentStoreChangedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Appointments::AppointmentStoreChangedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_AppointmentStoreChangedEventArgs(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentStoreChangedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AppointmentStoreChangedEventArgs_GetDeferral(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentStoreChangedEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Appointments.AppointmentStoreChangedEventArgs", L"GetDeferral", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetDeferral());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_AppointmentStoreChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Appointments::AppointmentStoreChangedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AppointmentStoreChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Appointments::AppointmentStoreChangedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AppointmentStoreChangedEventArgs[] = {
        { "get_deferral", reinterpret_cast<PyCFunction>(AppointmentStoreChangedEventArgs_GetDeferral), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_AppointmentStoreChangedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AppointmentStoreChangedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AppointmentStoreChangedEventArgs[] = {
        { }
    };

    static PyType_Slot _type_slots_AppointmentStoreChangedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_AppointmentStoreChangedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AppointmentStoreChangedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AppointmentStoreChangedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AppointmentStoreChangedEventArgs) },
        { }
    };

    static PyType_Spec type_spec_AppointmentStoreChangedEventArgs = {
        "winrt._winrt_windows_applicationmodel_appointments.AppointmentStoreChangedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentStoreChangedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AppointmentStoreChangedEventArgs};

    // ----- AppointmentStoreNotificationTriggerDetails class --------------------

    static PyObject* _new_AppointmentStoreNotificationTriggerDetails(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Appointments::AppointmentStoreNotificationTriggerDetails>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Appointments::AppointmentStoreNotificationTriggerDetails>::type_name);
        return nullptr;
    }

    static void _dealloc_AppointmentStoreNotificationTriggerDetails(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentStoreNotificationTriggerDetails* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_AppointmentStoreNotificationTriggerDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Appointments::AppointmentStoreNotificationTriggerDetails>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AppointmentStoreNotificationTriggerDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Appointments::AppointmentStoreNotificationTriggerDetails>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AppointmentStoreNotificationTriggerDetails[] = {
        { "_assign_array_", _assign_array_AppointmentStoreNotificationTriggerDetails, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AppointmentStoreNotificationTriggerDetails), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AppointmentStoreNotificationTriggerDetails[] = {
        { }
    };

    static PyType_Slot _type_slots_AppointmentStoreNotificationTriggerDetails[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_AppointmentStoreNotificationTriggerDetails) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AppointmentStoreNotificationTriggerDetails) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AppointmentStoreNotificationTriggerDetails) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AppointmentStoreNotificationTriggerDetails) },
        { }
    };

    static PyType_Spec type_spec_AppointmentStoreNotificationTriggerDetails = {
        "winrt._winrt_windows_applicationmodel_appointments.AppointmentStoreNotificationTriggerDetails",
        sizeof(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentStoreNotificationTriggerDetails),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AppointmentStoreNotificationTriggerDetails};

    // ----- FindAppointmentsOptions class --------------------

    static PyObject* _new_FindAppointmentsOptions(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::ApplicationModel::Appointments::FindAppointmentsOptions instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_FindAppointmentsOptions(py::wrapper::Windows::ApplicationModel::Appointments::FindAppointmentsOptions* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* FindAppointmentsOptions_get_MaxCount(py::wrapper::Windows::ApplicationModel::Appointments::FindAppointmentsOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Appointments.FindAppointmentsOptions", L"MaxCount"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.MaxCount());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int FindAppointmentsOptions_put_MaxCount(py::wrapper::Windows::ApplicationModel::Appointments::FindAppointmentsOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Appointments.FindAppointmentsOptions", L"MaxCount"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.MaxCount(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* FindAppointmentsOptions_get_IncludeHidden(py::wrapper::Windows::ApplicationModel::Appointments::FindAppointmentsOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Appointments.FindAppointmentsOptions", L"IncludeHidden"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IncludeHidden());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int FindAppointmentsOptions_put_IncludeHidden(py::wrapper::Windows::ApplicationModel::Appointments::FindAppointmentsOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Appointments.FindAppointmentsOptions", L"IncludeHidden"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.IncludeHidden(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* FindAppointmentsOptions_get_CalendarIds(py::wrapper::Windows::ApplicationModel::Appointments::FindAppointmentsOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Appointments.FindAppointmentsOptions", L"CalendarIds"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CalendarIds());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FindAppointmentsOptions_get_FetchProperties(py::wrapper::Windows::ApplicationModel::Appointments::FindAppointmentsOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Appointments.FindAppointmentsOptions", L"FetchProperties"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.FetchProperties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_FindAppointmentsOptions(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Appointments::FindAppointmentsOptions>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_FindAppointmentsOptions(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Appointments::FindAppointmentsOptions>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_FindAppointmentsOptions[] = {
        { "_assign_array_", _assign_array_FindAppointmentsOptions, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_FindAppointmentsOptions), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_FindAppointmentsOptions[] = {
        { "max_count", reinterpret_cast<getter>(FindAppointmentsOptions_get_MaxCount), reinterpret_cast<setter>(FindAppointmentsOptions_put_MaxCount), nullptr, nullptr },
        { "include_hidden", reinterpret_cast<getter>(FindAppointmentsOptions_get_IncludeHidden), reinterpret_cast<setter>(FindAppointmentsOptions_put_IncludeHidden), nullptr, nullptr },
        { "calendar_ids", reinterpret_cast<getter>(FindAppointmentsOptions_get_CalendarIds), nullptr, nullptr, nullptr },
        { "fetch_properties", reinterpret_cast<getter>(FindAppointmentsOptions_get_FetchProperties), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_FindAppointmentsOptions[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_FindAppointmentsOptions) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_FindAppointmentsOptions) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_FindAppointmentsOptions) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_FindAppointmentsOptions) },
        { }
    };

    static PyType_Spec type_spec_FindAppointmentsOptions = {
        "winrt._winrt_windows_applicationmodel_appointments.FindAppointmentsOptions",
        sizeof(py::wrapper::Windows::ApplicationModel::Appointments::FindAppointmentsOptions),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_FindAppointmentsOptions};

    // ----- IAppointmentParticipant interface --------------------

    static PyObject* _new_IAppointmentParticipant(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Appointments::IAppointmentParticipant>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Appointments::IAppointmentParticipant>::type_name);
        return nullptr;
    }

    static void _dealloc_IAppointmentParticipant(py::wrapper::Windows::ApplicationModel::Appointments::IAppointmentParticipant* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IAppointmentParticipant_get_Address(py::wrapper::Windows::ApplicationModel::Appointments::IAppointmentParticipant* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Appointments.IAppointmentParticipant", L"Address"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Address());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IAppointmentParticipant_put_Address(py::wrapper::Windows::ApplicationModel::Appointments::IAppointmentParticipant* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Appointments.IAppointmentParticipant", L"Address"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Address(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* IAppointmentParticipant_get_DisplayName(py::wrapper::Windows::ApplicationModel::Appointments::IAppointmentParticipant* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Appointments.IAppointmentParticipant", L"DisplayName"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DisplayName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IAppointmentParticipant_put_DisplayName(py::wrapper::Windows::ApplicationModel::Appointments::IAppointmentParticipant* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Appointments.IAppointmentParticipant", L"DisplayName"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.DisplayName(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_IAppointmentParticipant(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Appointments::IAppointmentParticipant>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IAppointmentParticipant(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Appointments::IAppointmentParticipant>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IAppointmentParticipant[] = {
        { "_assign_array_", _assign_array_IAppointmentParticipant, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IAppointmentParticipant), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IAppointmentParticipant[] = {
        { "address", reinterpret_cast<getter>(IAppointmentParticipant_get_Address), reinterpret_cast<setter>(IAppointmentParticipant_put_Address), nullptr, nullptr },
        { "display_name", reinterpret_cast<getter>(IAppointmentParticipant_get_DisplayName), reinterpret_cast<setter>(IAppointmentParticipant_put_DisplayName), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IAppointmentParticipant[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_IAppointmentParticipant) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IAppointmentParticipant) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IAppointmentParticipant) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IAppointmentParticipant) },
        { }
    };

    static PyType_Spec type_spec_IAppointmentParticipant = {
        "winrt._winrt_windows_applicationmodel_appointments.IAppointmentParticipant",
        sizeof(py::wrapper::Windows::ApplicationModel::Appointments::IAppointmentParticipant),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IAppointmentParticipant};

    // ----- Windows.ApplicationModel.Appointments Initialization --------------------

    PyDoc_STRVAR(module_doc, "Windows.ApplicationModel.Appointments");

    static PyModuleDef module_def = {
        PyModuleDef_HEAD_INIT,
        "_winrt_windows_applicationmodel_appointments",
        module_doc,
        0,
        nullptr,
        nullptr,
        nullptr,
        nullptr,
        nullptr};
} // py::cpp::Windows::ApplicationModel::Appointments

PyMODINIT_FUNC PyInit__winrt_windows_applicationmodel_appointments(void) noexcept
{
    using namespace py::cpp::Windows::ApplicationModel::Appointments;

    if (py::import_winrt_runtime() == -1)
    {
        return nullptr;
    }

    py::pyobj_handle module{PyModule_Create(&module_def)};

    if (!module)
    {
        return nullptr;
    }

    auto object_type = py::get_object_type();
    if (!object_type)
    {
        return nullptr;
    }

    py::pyobj_handle object_bases{PyTuple_Pack(1, object_type)};

    if (!object_bases)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_Appointment, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_AppointmentCalendar, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_AppointmentCalendarSyncManager, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_AppointmentConflictResult, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_AppointmentException, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_AppointmentInvitee, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_AppointmentManager_Static{PyType_FromSpec(&type_spec_AppointmentManager_Static)};
    if (!type_AppointmentManager_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_AppointmentManager, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_AppointmentManager_Static.get())) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_AppointmentManagerForUser, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_AppointmentOrganizer, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_AppointmentProperties_Static{PyType_FromSpec(&type_spec_AppointmentProperties_Static)};
    if (!type_AppointmentProperties_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_AppointmentProperties, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_AppointmentProperties_Static.get())) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_AppointmentRecurrence, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_AppointmentStore, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_AppointmentStoreChange, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_AppointmentStoreChangeReader, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_AppointmentStoreChangeTracker, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_AppointmentStoreChangedDeferral, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_AppointmentStoreChangedEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_AppointmentStoreNotificationTriggerDetails, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_FindAppointmentsOptions, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_IAppointmentParticipant, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }


    return module.detach();
}
