// WARNING: Please don't edit this file. It was generated by Python/WinRT v2.0.0-beta.2

#include "py.Windows.Foundation.Numerics.h"


namespace py::cpp::Windows::Foundation::Numerics
{
    // ----- Matrix3x2 struct --------------------

    winrt_struct_wrapper<winrt::Windows::Foundation::Numerics::float3x2>* _new_Matrix3x2(PyTypeObject* subclass, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        auto self = reinterpret_cast<winrt_struct_wrapper<winrt::Windows::Foundation::Numerics::float3x2>*>(subclass->tp_alloc(subclass, 0));

        if (!self)
        {
            return nullptr;
        }

        std::construct_at(&self->obj);

        return self;
    }

    int _init_Matrix3x2(winrt_struct_wrapper<winrt::Windows::Foundation::Numerics::float3x2>* self, PyObject* args, PyObject* kwds) noexcept
    {
        auto tuple_size = PyTuple_Size(args);

        if ((tuple_size == 0) && (kwds == nullptr))
        {
            self->obj = {};
            return 0;
        }

        float _M11{};
        float _M12{};
        float _M21{};
        float _M22{};
        float _M31{};
        float _M32{};

        static const char* kwlist[] = {"m11", "m12", "m21", "m22", "m31", "m32", nullptr};
        if (!PyArg_ParseTupleAndKeywords(args, kwds, "ffffff", const_cast<char**>(kwlist), &_M11, &_M12, &_M21, &_M22, &_M31, &_M32))
        {
            return -1;
        }

        try
        {
            self->obj = {_M11, _M12, _M21, _M22, _M31, _M32};
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static void _dealloc_Matrix3x2(py::wrapper::Windows::Foundation::Numerics::Matrix3x2* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_Matrix3x2(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Foundation::Numerics::float3x2>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyMethodDef _methods_Matrix3x2[] = {
        { "_assign_array_", _assign_array_Matrix3x2, METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyObject* Matrix3x2_get_M11(py::wrapper::Windows::Foundation::Numerics::Matrix3x2* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.m11);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Matrix3x2_set_M11(py::wrapper::Windows::Foundation::Numerics::Matrix3x2* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.m11 = py::converter<float>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Matrix3x2_get_M12(py::wrapper::Windows::Foundation::Numerics::Matrix3x2* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.m12);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Matrix3x2_set_M12(py::wrapper::Windows::Foundation::Numerics::Matrix3x2* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.m12 = py::converter<float>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Matrix3x2_get_M21(py::wrapper::Windows::Foundation::Numerics::Matrix3x2* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.m21);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Matrix3x2_set_M21(py::wrapper::Windows::Foundation::Numerics::Matrix3x2* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.m21 = py::converter<float>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Matrix3x2_get_M22(py::wrapper::Windows::Foundation::Numerics::Matrix3x2* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.m22);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Matrix3x2_set_M22(py::wrapper::Windows::Foundation::Numerics::Matrix3x2* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.m22 = py::converter<float>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Matrix3x2_get_M31(py::wrapper::Windows::Foundation::Numerics::Matrix3x2* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.m31);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Matrix3x2_set_M31(py::wrapper::Windows::Foundation::Numerics::Matrix3x2* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.m31 = py::converter<float>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Matrix3x2_get_M32(py::wrapper::Windows::Foundation::Numerics::Matrix3x2* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.m32);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Matrix3x2_set_M32(py::wrapper::Windows::Foundation::Numerics::Matrix3x2* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.m32 = py::converter<float>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyGetSetDef _getset_Matrix3x2[] = {
        { "m11", reinterpret_cast<getter>(Matrix3x2_get_M11), reinterpret_cast<setter>(Matrix3x2_set_M11), nullptr, nullptr },
        { "m12", reinterpret_cast<getter>(Matrix3x2_get_M12), reinterpret_cast<setter>(Matrix3x2_set_M12), nullptr, nullptr },
        { "m21", reinterpret_cast<getter>(Matrix3x2_get_M21), reinterpret_cast<setter>(Matrix3x2_set_M21), nullptr, nullptr },
        { "m22", reinterpret_cast<getter>(Matrix3x2_get_M22), reinterpret_cast<setter>(Matrix3x2_set_M22), nullptr, nullptr },
        { "m31", reinterpret_cast<getter>(Matrix3x2_get_M31), reinterpret_cast<setter>(Matrix3x2_set_M31), nullptr, nullptr },
        { "m32", reinterpret_cast<getter>(Matrix3x2_get_M32), reinterpret_cast<setter>(Matrix3x2_set_M32), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_Matrix3x2[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_Matrix3x2) },
        { Py_tp_init, reinterpret_cast<void*>(_init_Matrix3x2) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_Matrix3x2) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_Matrix3x2) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_Matrix3x2) },
        { },
    };

    static PyType_Spec type_spec_Matrix3x2 =
    {
        "winrt._winrt_windows_foundation_numerics.Matrix3x2",
        sizeof(py::wrapper::Windows::Foundation::Numerics::Matrix3x2),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_Matrix3x2
    };

    // ----- Matrix4x4 struct --------------------

    winrt_struct_wrapper<winrt::Windows::Foundation::Numerics::float4x4>* _new_Matrix4x4(PyTypeObject* subclass, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        auto self = reinterpret_cast<winrt_struct_wrapper<winrt::Windows::Foundation::Numerics::float4x4>*>(subclass->tp_alloc(subclass, 0));

        if (!self)
        {
            return nullptr;
        }

        std::construct_at(&self->obj);

        return self;
    }

    int _init_Matrix4x4(winrt_struct_wrapper<winrt::Windows::Foundation::Numerics::float4x4>* self, PyObject* args, PyObject* kwds) noexcept
    {
        auto tuple_size = PyTuple_Size(args);

        if ((tuple_size == 0) && (kwds == nullptr))
        {
            self->obj = {};
            return 0;
        }

        float _M11{};
        float _M12{};
        float _M13{};
        float _M14{};
        float _M21{};
        float _M22{};
        float _M23{};
        float _M24{};
        float _M31{};
        float _M32{};
        float _M33{};
        float _M34{};
        float _M41{};
        float _M42{};
        float _M43{};
        float _M44{};

        static const char* kwlist[] = {"m11", "m12", "m13", "m14", "m21", "m22", "m23", "m24", "m31", "m32", "m33", "m34", "m41", "m42", "m43", "m44", nullptr};
        if (!PyArg_ParseTupleAndKeywords(args, kwds, "ffffffffffffffff", const_cast<char**>(kwlist), &_M11, &_M12, &_M13, &_M14, &_M21, &_M22, &_M23, &_M24, &_M31, &_M32, &_M33, &_M34, &_M41, &_M42, &_M43, &_M44))
        {
            return -1;
        }

        try
        {
            self->obj = {_M11, _M12, _M13, _M14, _M21, _M22, _M23, _M24, _M31, _M32, _M33, _M34, _M41, _M42, _M43, _M44};
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static void _dealloc_Matrix4x4(py::wrapper::Windows::Foundation::Numerics::Matrix4x4* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_Matrix4x4(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Foundation::Numerics::float4x4>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyMethodDef _methods_Matrix4x4[] = {
        { "_assign_array_", _assign_array_Matrix4x4, METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyObject* Matrix4x4_get_M11(py::wrapper::Windows::Foundation::Numerics::Matrix4x4* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.m11);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Matrix4x4_set_M11(py::wrapper::Windows::Foundation::Numerics::Matrix4x4* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.m11 = py::converter<float>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Matrix4x4_get_M12(py::wrapper::Windows::Foundation::Numerics::Matrix4x4* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.m12);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Matrix4x4_set_M12(py::wrapper::Windows::Foundation::Numerics::Matrix4x4* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.m12 = py::converter<float>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Matrix4x4_get_M13(py::wrapper::Windows::Foundation::Numerics::Matrix4x4* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.m13);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Matrix4x4_set_M13(py::wrapper::Windows::Foundation::Numerics::Matrix4x4* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.m13 = py::converter<float>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Matrix4x4_get_M14(py::wrapper::Windows::Foundation::Numerics::Matrix4x4* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.m14);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Matrix4x4_set_M14(py::wrapper::Windows::Foundation::Numerics::Matrix4x4* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.m14 = py::converter<float>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Matrix4x4_get_M21(py::wrapper::Windows::Foundation::Numerics::Matrix4x4* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.m21);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Matrix4x4_set_M21(py::wrapper::Windows::Foundation::Numerics::Matrix4x4* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.m21 = py::converter<float>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Matrix4x4_get_M22(py::wrapper::Windows::Foundation::Numerics::Matrix4x4* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.m22);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Matrix4x4_set_M22(py::wrapper::Windows::Foundation::Numerics::Matrix4x4* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.m22 = py::converter<float>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Matrix4x4_get_M23(py::wrapper::Windows::Foundation::Numerics::Matrix4x4* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.m23);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Matrix4x4_set_M23(py::wrapper::Windows::Foundation::Numerics::Matrix4x4* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.m23 = py::converter<float>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Matrix4x4_get_M24(py::wrapper::Windows::Foundation::Numerics::Matrix4x4* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.m24);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Matrix4x4_set_M24(py::wrapper::Windows::Foundation::Numerics::Matrix4x4* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.m24 = py::converter<float>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Matrix4x4_get_M31(py::wrapper::Windows::Foundation::Numerics::Matrix4x4* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.m31);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Matrix4x4_set_M31(py::wrapper::Windows::Foundation::Numerics::Matrix4x4* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.m31 = py::converter<float>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Matrix4x4_get_M32(py::wrapper::Windows::Foundation::Numerics::Matrix4x4* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.m32);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Matrix4x4_set_M32(py::wrapper::Windows::Foundation::Numerics::Matrix4x4* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.m32 = py::converter<float>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Matrix4x4_get_M33(py::wrapper::Windows::Foundation::Numerics::Matrix4x4* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.m33);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Matrix4x4_set_M33(py::wrapper::Windows::Foundation::Numerics::Matrix4x4* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.m33 = py::converter<float>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Matrix4x4_get_M34(py::wrapper::Windows::Foundation::Numerics::Matrix4x4* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.m34);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Matrix4x4_set_M34(py::wrapper::Windows::Foundation::Numerics::Matrix4x4* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.m34 = py::converter<float>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Matrix4x4_get_M41(py::wrapper::Windows::Foundation::Numerics::Matrix4x4* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.m41);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Matrix4x4_set_M41(py::wrapper::Windows::Foundation::Numerics::Matrix4x4* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.m41 = py::converter<float>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Matrix4x4_get_M42(py::wrapper::Windows::Foundation::Numerics::Matrix4x4* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.m42);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Matrix4x4_set_M42(py::wrapper::Windows::Foundation::Numerics::Matrix4x4* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.m42 = py::converter<float>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Matrix4x4_get_M43(py::wrapper::Windows::Foundation::Numerics::Matrix4x4* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.m43);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Matrix4x4_set_M43(py::wrapper::Windows::Foundation::Numerics::Matrix4x4* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.m43 = py::converter<float>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Matrix4x4_get_M44(py::wrapper::Windows::Foundation::Numerics::Matrix4x4* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.m44);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Matrix4x4_set_M44(py::wrapper::Windows::Foundation::Numerics::Matrix4x4* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.m44 = py::converter<float>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyGetSetDef _getset_Matrix4x4[] = {
        { "m11", reinterpret_cast<getter>(Matrix4x4_get_M11), reinterpret_cast<setter>(Matrix4x4_set_M11), nullptr, nullptr },
        { "m12", reinterpret_cast<getter>(Matrix4x4_get_M12), reinterpret_cast<setter>(Matrix4x4_set_M12), nullptr, nullptr },
        { "m13", reinterpret_cast<getter>(Matrix4x4_get_M13), reinterpret_cast<setter>(Matrix4x4_set_M13), nullptr, nullptr },
        { "m14", reinterpret_cast<getter>(Matrix4x4_get_M14), reinterpret_cast<setter>(Matrix4x4_set_M14), nullptr, nullptr },
        { "m21", reinterpret_cast<getter>(Matrix4x4_get_M21), reinterpret_cast<setter>(Matrix4x4_set_M21), nullptr, nullptr },
        { "m22", reinterpret_cast<getter>(Matrix4x4_get_M22), reinterpret_cast<setter>(Matrix4x4_set_M22), nullptr, nullptr },
        { "m23", reinterpret_cast<getter>(Matrix4x4_get_M23), reinterpret_cast<setter>(Matrix4x4_set_M23), nullptr, nullptr },
        { "m24", reinterpret_cast<getter>(Matrix4x4_get_M24), reinterpret_cast<setter>(Matrix4x4_set_M24), nullptr, nullptr },
        { "m31", reinterpret_cast<getter>(Matrix4x4_get_M31), reinterpret_cast<setter>(Matrix4x4_set_M31), nullptr, nullptr },
        { "m32", reinterpret_cast<getter>(Matrix4x4_get_M32), reinterpret_cast<setter>(Matrix4x4_set_M32), nullptr, nullptr },
        { "m33", reinterpret_cast<getter>(Matrix4x4_get_M33), reinterpret_cast<setter>(Matrix4x4_set_M33), nullptr, nullptr },
        { "m34", reinterpret_cast<getter>(Matrix4x4_get_M34), reinterpret_cast<setter>(Matrix4x4_set_M34), nullptr, nullptr },
        { "m41", reinterpret_cast<getter>(Matrix4x4_get_M41), reinterpret_cast<setter>(Matrix4x4_set_M41), nullptr, nullptr },
        { "m42", reinterpret_cast<getter>(Matrix4x4_get_M42), reinterpret_cast<setter>(Matrix4x4_set_M42), nullptr, nullptr },
        { "m43", reinterpret_cast<getter>(Matrix4x4_get_M43), reinterpret_cast<setter>(Matrix4x4_set_M43), nullptr, nullptr },
        { "m44", reinterpret_cast<getter>(Matrix4x4_get_M44), reinterpret_cast<setter>(Matrix4x4_set_M44), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_Matrix4x4[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_Matrix4x4) },
        { Py_tp_init, reinterpret_cast<void*>(_init_Matrix4x4) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_Matrix4x4) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_Matrix4x4) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_Matrix4x4) },
        { },
    };

    static PyType_Spec type_spec_Matrix4x4 =
    {
        "winrt._winrt_windows_foundation_numerics.Matrix4x4",
        sizeof(py::wrapper::Windows::Foundation::Numerics::Matrix4x4),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_Matrix4x4
    };

    // ----- Plane struct --------------------

    winrt_struct_wrapper<winrt::Windows::Foundation::Numerics::plane>* _new_Plane(PyTypeObject* subclass, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        auto self = reinterpret_cast<winrt_struct_wrapper<winrt::Windows::Foundation::Numerics::plane>*>(subclass->tp_alloc(subclass, 0));

        if (!self)
        {
            return nullptr;
        }

        std::construct_at(&self->obj);

        return self;
    }

    int _init_Plane(winrt_struct_wrapper<winrt::Windows::Foundation::Numerics::plane>* self, PyObject* args, PyObject* kwds) noexcept
    {
        auto tuple_size = PyTuple_Size(args);

        if ((tuple_size == 0) && (kwds == nullptr))
        {
            self->obj = {};
            return 0;
        }

        PyObject* _Normal{};
        float _D{};

        static const char* kwlist[] = {"normal", "d", nullptr};
        if (!PyArg_ParseTupleAndKeywords(args, kwds, "Of", const_cast<char**>(kwlist), &_Normal, &_D))
        {
            return -1;
        }

        try
        {
            self->obj = {py::converter<winrt::Windows::Foundation::Numerics::float3>::convert_to(_Normal), _D};
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static void _dealloc_Plane(py::wrapper::Windows::Foundation::Numerics::Plane* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_Plane(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Foundation::Numerics::plane>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyMethodDef _methods_Plane[] = {
        { "_assign_array_", _assign_array_Plane, METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyObject* Plane_get_Normal(py::wrapper::Windows::Foundation::Numerics::Plane* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.normal);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Plane_set_Normal(py::wrapper::Windows::Foundation::Numerics::Plane* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.normal = py::converter<winrt::Windows::Foundation::Numerics::float3>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Plane_get_D(py::wrapper::Windows::Foundation::Numerics::Plane* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.d);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Plane_set_D(py::wrapper::Windows::Foundation::Numerics::Plane* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.d = py::converter<float>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyGetSetDef _getset_Plane[] = {
        { "normal", reinterpret_cast<getter>(Plane_get_Normal), reinterpret_cast<setter>(Plane_set_Normal), nullptr, nullptr },
        { "d", reinterpret_cast<getter>(Plane_get_D), reinterpret_cast<setter>(Plane_set_D), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_Plane[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_Plane) },
        { Py_tp_init, reinterpret_cast<void*>(_init_Plane) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_Plane) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_Plane) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_Plane) },
        { },
    };

    static PyType_Spec type_spec_Plane =
    {
        "winrt._winrt_windows_foundation_numerics.Plane",
        sizeof(py::wrapper::Windows::Foundation::Numerics::Plane),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_Plane
    };

    // ----- Quaternion struct --------------------

    winrt_struct_wrapper<winrt::Windows::Foundation::Numerics::quaternion>* _new_Quaternion(PyTypeObject* subclass, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        auto self = reinterpret_cast<winrt_struct_wrapper<winrt::Windows::Foundation::Numerics::quaternion>*>(subclass->tp_alloc(subclass, 0));

        if (!self)
        {
            return nullptr;
        }

        std::construct_at(&self->obj);

        return self;
    }

    int _init_Quaternion(winrt_struct_wrapper<winrt::Windows::Foundation::Numerics::quaternion>* self, PyObject* args, PyObject* kwds) noexcept
    {
        auto tuple_size = PyTuple_Size(args);

        if ((tuple_size == 0) && (kwds == nullptr))
        {
            self->obj = {};
            return 0;
        }

        float _X{};
        float _Y{};
        float _Z{};
        float _W{};

        static const char* kwlist[] = {"x", "y", "z", "w", nullptr};
        if (!PyArg_ParseTupleAndKeywords(args, kwds, "ffff", const_cast<char**>(kwlist), &_X, &_Y, &_Z, &_W))
        {
            return -1;
        }

        try
        {
            self->obj = {_X, _Y, _Z, _W};
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static void _dealloc_Quaternion(py::wrapper::Windows::Foundation::Numerics::Quaternion* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_Quaternion(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Foundation::Numerics::quaternion>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyMethodDef _methods_Quaternion[] = {
        { "_assign_array_", _assign_array_Quaternion, METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyObject* Quaternion_get_X(py::wrapper::Windows::Foundation::Numerics::Quaternion* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.x);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Quaternion_set_X(py::wrapper::Windows::Foundation::Numerics::Quaternion* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.x = py::converter<float>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Quaternion_get_Y(py::wrapper::Windows::Foundation::Numerics::Quaternion* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.y);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Quaternion_set_Y(py::wrapper::Windows::Foundation::Numerics::Quaternion* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.y = py::converter<float>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Quaternion_get_Z(py::wrapper::Windows::Foundation::Numerics::Quaternion* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.z);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Quaternion_set_Z(py::wrapper::Windows::Foundation::Numerics::Quaternion* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.z = py::converter<float>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Quaternion_get_W(py::wrapper::Windows::Foundation::Numerics::Quaternion* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.w);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Quaternion_set_W(py::wrapper::Windows::Foundation::Numerics::Quaternion* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.w = py::converter<float>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyGetSetDef _getset_Quaternion[] = {
        { "x", reinterpret_cast<getter>(Quaternion_get_X), reinterpret_cast<setter>(Quaternion_set_X), nullptr, nullptr },
        { "y", reinterpret_cast<getter>(Quaternion_get_Y), reinterpret_cast<setter>(Quaternion_set_Y), nullptr, nullptr },
        { "z", reinterpret_cast<getter>(Quaternion_get_Z), reinterpret_cast<setter>(Quaternion_set_Z), nullptr, nullptr },
        { "w", reinterpret_cast<getter>(Quaternion_get_W), reinterpret_cast<setter>(Quaternion_set_W), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_Quaternion[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_Quaternion) },
        { Py_tp_init, reinterpret_cast<void*>(_init_Quaternion) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_Quaternion) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_Quaternion) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_Quaternion) },
        { },
    };

    static PyType_Spec type_spec_Quaternion =
    {
        "winrt._winrt_windows_foundation_numerics.Quaternion",
        sizeof(py::wrapper::Windows::Foundation::Numerics::Quaternion),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_Quaternion
    };

    // ----- Rational struct --------------------

    winrt_struct_wrapper<winrt::Windows::Foundation::Numerics::Rational>* _new_Rational(PyTypeObject* subclass, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        auto self = reinterpret_cast<winrt_struct_wrapper<winrt::Windows::Foundation::Numerics::Rational>*>(subclass->tp_alloc(subclass, 0));

        if (!self)
        {
            return nullptr;
        }

        std::construct_at(&self->obj);

        return self;
    }

    int _init_Rational(winrt_struct_wrapper<winrt::Windows::Foundation::Numerics::Rational>* self, PyObject* args, PyObject* kwds) noexcept
    {
        auto tuple_size = PyTuple_Size(args);

        if ((tuple_size == 0) && (kwds == nullptr))
        {
            self->obj = {};
            return 0;
        }

        uint32_t _Numerator{};
        uint32_t _Denominator{};

        static const char* kwlist[] = {"numerator", "denominator", nullptr};
        if (!PyArg_ParseTupleAndKeywords(args, kwds, "II", const_cast<char**>(kwlist), &_Numerator, &_Denominator))
        {
            return -1;
        }

        try
        {
            self->obj = {_Numerator, _Denominator};
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static void _dealloc_Rational(py::wrapper::Windows::Foundation::Numerics::Rational* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_Rational(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Foundation::Numerics::Rational>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyMethodDef _methods_Rational[] = {
        { "_assign_array_", _assign_array_Rational, METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyObject* Rational_get_Numerator(py::wrapper::Windows::Foundation::Numerics::Rational* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Numerator);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Rational_set_Numerator(py::wrapper::Windows::Foundation::Numerics::Rational* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.Numerator = py::converter<uint32_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Rational_get_Denominator(py::wrapper::Windows::Foundation::Numerics::Rational* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Denominator);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Rational_set_Denominator(py::wrapper::Windows::Foundation::Numerics::Rational* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.Denominator = py::converter<uint32_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyGetSetDef _getset_Rational[] = {
        { "numerator", reinterpret_cast<getter>(Rational_get_Numerator), reinterpret_cast<setter>(Rational_set_Numerator), nullptr, nullptr },
        { "denominator", reinterpret_cast<getter>(Rational_get_Denominator), reinterpret_cast<setter>(Rational_set_Denominator), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_Rational[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_Rational) },
        { Py_tp_init, reinterpret_cast<void*>(_init_Rational) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_Rational) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_Rational) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_Rational) },
        { },
    };

    static PyType_Spec type_spec_Rational =
    {
        "winrt._winrt_windows_foundation_numerics.Rational",
        sizeof(py::wrapper::Windows::Foundation::Numerics::Rational),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_Rational
    };

    // ----- Vector2 struct --------------------

    winrt_struct_wrapper<winrt::Windows::Foundation::Numerics::float2>* _new_Vector2(PyTypeObject* subclass, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        auto self = reinterpret_cast<winrt_struct_wrapper<winrt::Windows::Foundation::Numerics::float2>*>(subclass->tp_alloc(subclass, 0));

        if (!self)
        {
            return nullptr;
        }

        std::construct_at(&self->obj);

        return self;
    }

    int _init_Vector2(winrt_struct_wrapper<winrt::Windows::Foundation::Numerics::float2>* self, PyObject* args, PyObject* kwds) noexcept
    {
        auto tuple_size = PyTuple_Size(args);

        if ((tuple_size == 0) && (kwds == nullptr))
        {
            self->obj = {};
            return 0;
        }

        float _X{};
        float _Y{};

        static const char* kwlist[] = {"x", "y", nullptr};
        if (!PyArg_ParseTupleAndKeywords(args, kwds, "ff", const_cast<char**>(kwlist), &_X, &_Y))
        {
            return -1;
        }

        try
        {
            self->obj = {_X, _Y};
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static void _dealloc_Vector2(py::wrapper::Windows::Foundation::Numerics::Vector2* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_Vector2(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Foundation::Numerics::float2>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyMethodDef _methods_Vector2[] = {
        { "_assign_array_", _assign_array_Vector2, METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyObject* Vector2_get_X(py::wrapper::Windows::Foundation::Numerics::Vector2* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.x);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Vector2_set_X(py::wrapper::Windows::Foundation::Numerics::Vector2* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.x = py::converter<float>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Vector2_get_Y(py::wrapper::Windows::Foundation::Numerics::Vector2* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.y);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Vector2_set_Y(py::wrapper::Windows::Foundation::Numerics::Vector2* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.y = py::converter<float>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyGetSetDef _getset_Vector2[] = {
        { "x", reinterpret_cast<getter>(Vector2_get_X), reinterpret_cast<setter>(Vector2_set_X), nullptr, nullptr },
        { "y", reinterpret_cast<getter>(Vector2_get_Y), reinterpret_cast<setter>(Vector2_set_Y), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_Vector2[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_Vector2) },
        { Py_tp_init, reinterpret_cast<void*>(_init_Vector2) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_Vector2) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_Vector2) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_Vector2) },
        { },
    };

    static PyType_Spec type_spec_Vector2 =
    {
        "winrt._winrt_windows_foundation_numerics.Vector2",
        sizeof(py::wrapper::Windows::Foundation::Numerics::Vector2),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_Vector2
    };

    // ----- Vector3 struct --------------------

    winrt_struct_wrapper<winrt::Windows::Foundation::Numerics::float3>* _new_Vector3(PyTypeObject* subclass, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        auto self = reinterpret_cast<winrt_struct_wrapper<winrt::Windows::Foundation::Numerics::float3>*>(subclass->tp_alloc(subclass, 0));

        if (!self)
        {
            return nullptr;
        }

        std::construct_at(&self->obj);

        return self;
    }

    int _init_Vector3(winrt_struct_wrapper<winrt::Windows::Foundation::Numerics::float3>* self, PyObject* args, PyObject* kwds) noexcept
    {
        auto tuple_size = PyTuple_Size(args);

        if ((tuple_size == 0) && (kwds == nullptr))
        {
            self->obj = {};
            return 0;
        }

        float _X{};
        float _Y{};
        float _Z{};

        static const char* kwlist[] = {"x", "y", "z", nullptr};
        if (!PyArg_ParseTupleAndKeywords(args, kwds, "fff", const_cast<char**>(kwlist), &_X, &_Y, &_Z))
        {
            return -1;
        }

        try
        {
            self->obj = {_X, _Y, _Z};
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static void _dealloc_Vector3(py::wrapper::Windows::Foundation::Numerics::Vector3* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_Vector3(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Foundation::Numerics::float3>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyMethodDef _methods_Vector3[] = {
        { "_assign_array_", _assign_array_Vector3, METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyObject* Vector3_get_X(py::wrapper::Windows::Foundation::Numerics::Vector3* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.x);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Vector3_set_X(py::wrapper::Windows::Foundation::Numerics::Vector3* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.x = py::converter<float>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Vector3_get_Y(py::wrapper::Windows::Foundation::Numerics::Vector3* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.y);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Vector3_set_Y(py::wrapper::Windows::Foundation::Numerics::Vector3* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.y = py::converter<float>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Vector3_get_Z(py::wrapper::Windows::Foundation::Numerics::Vector3* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.z);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Vector3_set_Z(py::wrapper::Windows::Foundation::Numerics::Vector3* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.z = py::converter<float>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyGetSetDef _getset_Vector3[] = {
        { "x", reinterpret_cast<getter>(Vector3_get_X), reinterpret_cast<setter>(Vector3_set_X), nullptr, nullptr },
        { "y", reinterpret_cast<getter>(Vector3_get_Y), reinterpret_cast<setter>(Vector3_set_Y), nullptr, nullptr },
        { "z", reinterpret_cast<getter>(Vector3_get_Z), reinterpret_cast<setter>(Vector3_set_Z), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_Vector3[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_Vector3) },
        { Py_tp_init, reinterpret_cast<void*>(_init_Vector3) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_Vector3) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_Vector3) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_Vector3) },
        { },
    };

    static PyType_Spec type_spec_Vector3 =
    {
        "winrt._winrt_windows_foundation_numerics.Vector3",
        sizeof(py::wrapper::Windows::Foundation::Numerics::Vector3),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_Vector3
    };

    // ----- Vector4 struct --------------------

    winrt_struct_wrapper<winrt::Windows::Foundation::Numerics::float4>* _new_Vector4(PyTypeObject* subclass, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        auto self = reinterpret_cast<winrt_struct_wrapper<winrt::Windows::Foundation::Numerics::float4>*>(subclass->tp_alloc(subclass, 0));

        if (!self)
        {
            return nullptr;
        }

        std::construct_at(&self->obj);

        return self;
    }

    int _init_Vector4(winrt_struct_wrapper<winrt::Windows::Foundation::Numerics::float4>* self, PyObject* args, PyObject* kwds) noexcept
    {
        auto tuple_size = PyTuple_Size(args);

        if ((tuple_size == 0) && (kwds == nullptr))
        {
            self->obj = {};
            return 0;
        }

        float _X{};
        float _Y{};
        float _Z{};
        float _W{};

        static const char* kwlist[] = {"x", "y", "z", "w", nullptr};
        if (!PyArg_ParseTupleAndKeywords(args, kwds, "ffff", const_cast<char**>(kwlist), &_X, &_Y, &_Z, &_W))
        {
            return -1;
        }

        try
        {
            self->obj = {_X, _Y, _Z, _W};
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static void _dealloc_Vector4(py::wrapper::Windows::Foundation::Numerics::Vector4* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_Vector4(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Foundation::Numerics::float4>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyMethodDef _methods_Vector4[] = {
        { "_assign_array_", _assign_array_Vector4, METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyObject* Vector4_get_X(py::wrapper::Windows::Foundation::Numerics::Vector4* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.x);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Vector4_set_X(py::wrapper::Windows::Foundation::Numerics::Vector4* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.x = py::converter<float>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Vector4_get_Y(py::wrapper::Windows::Foundation::Numerics::Vector4* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.y);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Vector4_set_Y(py::wrapper::Windows::Foundation::Numerics::Vector4* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.y = py::converter<float>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Vector4_get_Z(py::wrapper::Windows::Foundation::Numerics::Vector4* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.z);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Vector4_set_Z(py::wrapper::Windows::Foundation::Numerics::Vector4* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.z = py::converter<float>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Vector4_get_W(py::wrapper::Windows::Foundation::Numerics::Vector4* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.w);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Vector4_set_W(py::wrapper::Windows::Foundation::Numerics::Vector4* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.w = py::converter<float>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyGetSetDef _getset_Vector4[] = {
        { "x", reinterpret_cast<getter>(Vector4_get_X), reinterpret_cast<setter>(Vector4_set_X), nullptr, nullptr },
        { "y", reinterpret_cast<getter>(Vector4_get_Y), reinterpret_cast<setter>(Vector4_set_Y), nullptr, nullptr },
        { "z", reinterpret_cast<getter>(Vector4_get_Z), reinterpret_cast<setter>(Vector4_set_Z), nullptr, nullptr },
        { "w", reinterpret_cast<getter>(Vector4_get_W), reinterpret_cast<setter>(Vector4_set_W), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_Vector4[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_Vector4) },
        { Py_tp_init, reinterpret_cast<void*>(_init_Vector4) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_Vector4) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_Vector4) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_Vector4) },
        { },
    };

    static PyType_Spec type_spec_Vector4 =
    {
        "winrt._winrt_windows_foundation_numerics.Vector4",
        sizeof(py::wrapper::Windows::Foundation::Numerics::Vector4),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_Vector4
    };

    // ----- Windows.Foundation.Numerics Initialization --------------------
    PyDoc_STRVAR(module_doc, "Windows::Foundation::Numerics");


    static PyModuleDef module_def
        = {PyModuleDef_HEAD_INIT,
           "_winrt_windows_foundation_numerics",
           module_doc,
           0,
           nullptr,
           nullptr,
           nullptr,
           nullptr,
           nullptr};

} // py::cpp::Windows::Foundation::Numerics

PyMODINIT_FUNC PyInit__winrt_windows_foundation_numerics(void) noexcept
{
    using namespace py::cpp::Windows::Foundation::Numerics;

    if (py::import_winrt_runtime() == -1)
    {
        return nullptr;
    }

    py::pyobj_handle module{PyModule_Create(&module_def)};

    if (!module)
    {
        return nullptr;
    }

    auto object_type = py::get_object_type();
    if (!object_type)
    {
        return nullptr;
    }

    py::pyobj_handle object_bases{PyTuple_Pack(1, object_type)};

    if (!object_bases)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_Matrix3x2, nullptr, nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_Matrix4x4, nullptr, nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_Plane, nullptr, nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_Quaternion, nullptr, nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_Rational, nullptr, nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_Vector2, nullptr, nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_Vector3, nullptr, nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_Vector4, nullptr, nullptr) == -1)
    {
        return nullptr;
    }


    return module.detach();
}
