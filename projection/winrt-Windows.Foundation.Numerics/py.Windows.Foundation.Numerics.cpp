// WARNING: Please don't edit this file. It was generated by Python/WinRT v0.0.0

#include "py.Windows.Foundation.Numerics.h"

namespace py::cpp::Windows::Foundation::Numerics
{
    // ----- Matrix3x2 struct --------------------

    winrt::Windows::Foundation::Numerics::float3x2 Matrix3x2_from_tuple(PyObject* tuple)
    {
        if (PyTuple_GET_SIZE(tuple) != 6)
        {
            PyErr_SetString(PyExc_TypeError, "Incorrect number of fields");
            throw python_exception();
        }

        winrt::Windows::Foundation::Numerics::float3x2 result{};

        result.m11 = py::convert_to<float>(tuple, 0);
        result.m12 = py::convert_to<float>(tuple, 1);
        result.m21 = py::convert_to<float>(tuple, 2);
        result.m22 = py::convert_to<float>(tuple, 3);
        result.m31 = py::convert_to<float>(tuple, 4);
        result.m32 = py::convert_to<float>(tuple, 5);

        return result;
    }

    PyObject* _new_Matrix3x2(PyTypeObject* subclass, PyObject* args, PyObject* kwds) noexcept
    {
        pyobj_handle self_obj{(subclass->tp_alloc(subclass, 0))};
        if (!self_obj)
        {
            return nullptr;
        }

        auto self = reinterpret_cast<winrt_struct_wrapper<winrt::Windows::Foundation::Numerics::float3x2>*>(self_obj.get());
        std::construct_at(&self->obj);

        auto tuple_size = PyTuple_GET_SIZE(args);
        if ((tuple_size == 0) && (!kwds))
        {
            return self_obj.detach();
        }

        float _M11{};
        float _M12{};
        float _M21{};
        float _M22{};
        float _M31{};
        float _M32{};

        static const char* kwlist[] = {"m11", "m12", "m21", "m22", "m31", "m32", nullptr};
        if (!PyArg_ParseTupleAndKeywords(args, kwds, "|ffffff", const_cast<char**>(kwlist), &_M11, &_M12, &_M21, &_M22, &_M31, &_M32))
        {
            return nullptr;
        }

        try
        {
            self->obj.m11 = _M11;
            self->obj.m12 = _M12;
            self->obj.m21 = _M21;
            self->obj.m22 = _M22;
            self->obj.m31 = _M31;
            self->obj.m32 = _M32;

            return self_obj.detach();
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static void _dealloc_Matrix3x2(py::wrapper::Windows::Foundation::Numerics::Matrix3x2* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* make_translation_Matrix3x2(PyObject* /*unused*/, PyObject* args) noexcept
    {
        try
        {
            auto n_args = PyTuple_GET_SIZE(args);

            if (n_args == 1)
            {
#if defined(__MINGW32__)
                (void)args;
                PyErr_SetString(PyExc_NotImplementedError, "Overload with 1 args is not implemented on MinGW");
                return nullptr;
#else
                auto _arg0 = py::convert_to<winrt::Windows::Foundation::Numerics::float2>(args, 0);
                auto _result = winrt::Windows::Foundation::Numerics::make_float3x2_translation(_arg0);
                return py::convert(_result);
#endif
            }

            if (n_args == 2)
            {
#if defined(__MINGW32__)
                (void)args;
                PyErr_SetString(PyExc_NotImplementedError, "Overload with 2 args is not implemented on MinGW");
                return nullptr;
#else
                auto _arg0 = py::convert_to<float>(args, 0);
                auto _arg1 = py::convert_to<float>(args, 1);
                auto _result = winrt::Windows::Foundation::Numerics::make_float3x2_translation(_arg0, _arg1);
                return py::convert(_result);
#endif
            }

            PyErr_Format(PyExc_TypeError, "No overload take %d args.", n_args);
            return nullptr;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* make_scale_Matrix3x2(PyObject* /*unused*/, PyObject* args) noexcept
    {
        try
        {
            auto n_args = PyTuple_GET_SIZE(args);

            if (n_args == 2)
            {
#if defined(__MINGW32__)
                (void)args;
                PyErr_SetString(PyExc_NotImplementedError, "Overload with 2 args is not implemented on MinGW");
                return nullptr;
#else
                auto _arg0 = py::convert_to<float>(args, 0);
                auto _arg1 = py::convert_to<float>(args, 1);
                auto _result = winrt::Windows::Foundation::Numerics::make_float3x2_scale(_arg0, _arg1);
                return py::convert(_result);
#endif
            }

            if (n_args == 3)
            {
#if defined(__MINGW32__)
                (void)args;
                PyErr_SetString(PyExc_NotImplementedError, "Overload with 3 args is not implemented on MinGW");
                return nullptr;
#else
                auto _arg0 = py::convert_to<float>(args, 0);
                auto _arg1 = py::convert_to<float>(args, 1);
                auto _arg2 = py::convert_to<winrt::Windows::Foundation::Numerics::float2>(args, 2);
                auto _result = winrt::Windows::Foundation::Numerics::make_float3x2_scale(_arg0, _arg1, _arg2);
                return py::convert(_result);
#endif
            }

            PyErr_Format(PyExc_TypeError, "No overload take %d args.", n_args);
            return nullptr;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* make_scale_from_vector_Matrix3x2(PyObject* /*unused*/, PyObject* args) noexcept
    {
        try
        {
            auto n_args = PyTuple_GET_SIZE(args);

            if (n_args == 1)
            {
#if defined(__MINGW32__)
                (void)args;
                PyErr_SetString(PyExc_NotImplementedError, "Overload with 1 args is not implemented on MinGW");
                return nullptr;
#else
                auto _arg0 = py::convert_to<winrt::Windows::Foundation::Numerics::float2>(args, 0);
                auto _result = winrt::Windows::Foundation::Numerics::make_float3x2_scale(_arg0);
                return py::convert(_result);
#endif
            }

            if (n_args == 2)
            {
#if defined(__MINGW32__)
                (void)args;
                PyErr_SetString(PyExc_NotImplementedError, "Overload with 2 args is not implemented on MinGW");
                return nullptr;
#else
                auto _arg0 = py::convert_to<winrt::Windows::Foundation::Numerics::float2>(args, 0);
                auto _arg1 = py::convert_to<winrt::Windows::Foundation::Numerics::float2>(args, 1);
                auto _result = winrt::Windows::Foundation::Numerics::make_float3x2_scale(_arg0, _arg1);
                return py::convert(_result);
#endif
            }

            PyErr_Format(PyExc_TypeError, "No overload take %d args.", n_args);
            return nullptr;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* make_scale_from_scalar_Matrix3x2(PyObject* /*unused*/, PyObject* args) noexcept
    {
        try
        {
            auto n_args = PyTuple_GET_SIZE(args);

            if (n_args == 1)
            {
#if defined(__MINGW32__)
                (void)args;
                PyErr_SetString(PyExc_NotImplementedError, "Overload with 1 args is not implemented on MinGW");
                return nullptr;
#else
                auto _arg0 = py::convert_to<float>(args, 0);
                auto _result = winrt::Windows::Foundation::Numerics::make_float3x2_scale(_arg0);
                return py::convert(_result);
#endif
            }

            if (n_args == 2)
            {
#if defined(__MINGW32__)
                (void)args;
                PyErr_SetString(PyExc_NotImplementedError, "Overload with 2 args is not implemented on MinGW");
                return nullptr;
#else
                auto _arg0 = py::convert_to<float>(args, 0);
                auto _arg1 = py::convert_to<winrt::Windows::Foundation::Numerics::float2>(args, 1);
                auto _result = winrt::Windows::Foundation::Numerics::make_float3x2_scale(_arg0, _arg1);
                return py::convert(_result);
#endif
            }

            PyErr_Format(PyExc_TypeError, "No overload take %d args.", n_args);
            return nullptr;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* make_skew_Matrix3x2(PyObject* /*unused*/, PyObject* args) noexcept
    {
        try
        {
            auto n_args = PyTuple_GET_SIZE(args);

            if (n_args == 2)
            {
#if defined(__MINGW32__)
                (void)args;
                PyErr_SetString(PyExc_NotImplementedError, "Overload with 2 args is not implemented on MinGW");
                return nullptr;
#else
                auto _arg0 = py::convert_to<float>(args, 0);
                auto _arg1 = py::convert_to<float>(args, 1);
                auto _result = winrt::Windows::Foundation::Numerics::make_float3x2_skew(_arg0, _arg1);
                return py::convert(_result);
#endif
            }

            if (n_args == 3)
            {
#if defined(__MINGW32__)
                (void)args;
                PyErr_SetString(PyExc_NotImplementedError, "Overload with 3 args is not implemented on MinGW");
                return nullptr;
#else
                auto _arg0 = py::convert_to<float>(args, 0);
                auto _arg1 = py::convert_to<float>(args, 1);
                auto _arg2 = py::convert_to<winrt::Windows::Foundation::Numerics::float2>(args, 2);
                auto _result = winrt::Windows::Foundation::Numerics::make_float3x2_skew(_arg0, _arg1, _arg2);
                return py::convert(_result);
#endif
            }

            PyErr_Format(PyExc_TypeError, "No overload take %d args.", n_args);
            return nullptr;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* make_rotation_Matrix3x2(PyObject* /*unused*/, PyObject* args) noexcept
    {
        try
        {
            auto n_args = PyTuple_GET_SIZE(args);

            if (n_args == 1)
            {
#if defined(__MINGW32__)
                (void)args;
                PyErr_SetString(PyExc_NotImplementedError, "Overload with 1 args is not implemented on MinGW");
                return nullptr;
#else
                auto _arg0 = py::convert_to<float>(args, 0);
                auto _result = winrt::Windows::Foundation::Numerics::make_float3x2_rotation(_arg0);
                return py::convert(_result);
#endif
            }

            if (n_args == 2)
            {
#if defined(__MINGW32__)
                (void)args;
                PyErr_SetString(PyExc_NotImplementedError, "Overload with 2 args is not implemented on MinGW");
                return nullptr;
#else
                auto _arg0 = py::convert_to<float>(args, 0);
                auto _arg1 = py::convert_to<winrt::Windows::Foundation::Numerics::float2>(args, 1);
                auto _result = winrt::Windows::Foundation::Numerics::make_float3x2_rotation(_arg0, _arg1);
                return py::convert(_result);
#endif
            }

            PyErr_Format(PyExc_TypeError, "No overload take %d args.", n_args);
            return nullptr;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _get_identity_Matrix3x2(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        return py::convert(winrt::Windows::Foundation::Numerics::float3x2::identity());
    }

    static PyObject* is_identity_Matrix3x2(winrt_struct_wrapper<winrt::Windows::Foundation::Numerics::float3x2>* self, PyObject* /*unused*/) noexcept
    {
        try
        {
            auto _result = winrt::Windows::Foundation::Numerics::is_identity(self->obj);
            return py::convert(_result);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* determinant_Matrix3x2(winrt_struct_wrapper<winrt::Windows::Foundation::Numerics::float3x2>* self, PyObject* /*unused*/) noexcept
    {
        try
        {
            auto _result = winrt::Windows::Foundation::Numerics::determinant(self->obj);
            return py::convert(_result);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* translation_Matrix3x2(winrt_struct_wrapper<winrt::Windows::Foundation::Numerics::float3x2>* self, PyObject* /*unused*/) noexcept
    {
        try
        {
            auto _result = winrt::Windows::Foundation::Numerics::translation(self->obj);
            return py::convert(_result);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* invert_Matrix3x2(winrt_struct_wrapper<winrt::Windows::Foundation::Numerics::float3x2>* self, PyObject* /*unused*/) noexcept
    {
        try
        {
#if defined(__MINGW32__)
            (void)self;
            PyErr_SetString(PyExc_NotImplementedError, "This method is not implemented on MinGW");
            return nullptr;
#else
            winrt::Windows::Foundation::Numerics::float3x2 _result;

            if (!winrt::Windows::Foundation::Numerics::invert(self->obj, &_result))
            {
                PyErr_SetString(PyExc_ValueError, "Matrix is not invertible");
                return nullptr;
            }

            return py::convert(_result);
#endif
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* lerp_Matrix3x2(winrt_struct_wrapper<winrt::Windows::Foundation::Numerics::float3x2>* self, PyObject* args) noexcept
    {
        try
        {
#if defined(__MINGW32__)
            (void)self;
            (void)args;
            PyErr_SetString(PyExc_NotImplementedError, "This method is not implemented on MinGW");
            return nullptr;
#else
            auto _arg0 = py::convert_to<winrt::Windows::Foundation::Numerics::float3x2>(args, 0);
            auto _arg1 = py::convert_to<float>(args, 1);
            auto _result = winrt::Windows::Foundation::Numerics::lerp(self->obj, _arg0, _arg1);
            return py::convert(_result);
#endif
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_Matrix3x2(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Foundation::Numerics::float3x2>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    PyObject* _replace_Matrix3x2(py::wrapper::Windows::Foundation::Numerics::Matrix3x2* self, PyObject* args, PyObject* kwds) noexcept
    {
        try
        {
            float _M11{self->obj.m11};
            float _M12{self->obj.m12};
            float _M21{self->obj.m21};
            float _M22{self->obj.m22};
            float _M31{self->obj.m31};
            float _M32{self->obj.m32};

            static const char* kwlist[] = {"m11", "m12", "m21", "m22", "m31", "m32", nullptr};
            if (!PyArg_ParseTupleAndKeywords(args, kwds, "|$ffffff", const_cast<char**>(kwlist), &_M11, &_M12, &_M21, &_M22, &_M31, &_M32))
            {
                return nullptr;
            }

            auto copy = self->obj;
            copy.m11 = _M11;
            copy.m12 = _M12;
            copy.m21 = _M21;
            copy.m22 = _M22;
            copy.m31 = _M31;
            copy.m32 = _M32;

            return convert(copy);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    PyObject* unpack_Matrix3x2(py::wrapper::Windows::Foundation::Numerics::Matrix3x2* self, PyObject* /*unused*/) noexcept
    {
        py::pyobj_handle M11{convert(self->obj.m11)};
        if (!M11)
        {
            return nullptr;
        }

        py::pyobj_handle M12{convert(self->obj.m12)};
        if (!M12)
        {
            return nullptr;
        }

        py::pyobj_handle M21{convert(self->obj.m21)};
        if (!M21)
        {
            return nullptr;
        }

        py::pyobj_handle M22{convert(self->obj.m22)};
        if (!M22)
        {
            return nullptr;
        }

        py::pyobj_handle M31{convert(self->obj.m31)};
        if (!M31)
        {
            return nullptr;
        }

        py::pyobj_handle M32{convert(self->obj.m32)};
        if (!M32)
        {
            return nullptr;
        }

        pyobj_handle tuple{PyTuple_New(6)};
        if (!tuple)
        {
            return nullptr;
        }

        PyTuple_SET_ITEM(tuple.get(), 0, M11.detach());
        PyTuple_SET_ITEM(tuple.get(), 1, M12.detach());
        PyTuple_SET_ITEM(tuple.get(), 2, M21.detach());
        PyTuple_SET_ITEM(tuple.get(), 3, M22.detach());
        PyTuple_SET_ITEM(tuple.get(), 4, M31.detach());
        PyTuple_SET_ITEM(tuple.get(), 5, M32.detach());

        return tuple.detach();
    }

    static PyMethodDef _methods_Matrix3x2[] = {
        { "is_identity", reinterpret_cast<PyCFunction>(is_identity_Matrix3x2), METH_NOARGS, nullptr },
        { "determinant", reinterpret_cast<PyCFunction>(determinant_Matrix3x2), METH_NOARGS, nullptr },
        { "translation", reinterpret_cast<PyCFunction>(translation_Matrix3x2), METH_NOARGS, nullptr },
        { "invert", reinterpret_cast<PyCFunction>(invert_Matrix3x2), METH_NOARGS, nullptr },
        { "lerp", reinterpret_cast<PyCFunction>(lerp_Matrix3x2), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_Matrix3x2, METH_O | METH_STATIC, nullptr },
        { "__replace__", reinterpret_cast<PyCFunction>(reinterpret_cast<void*>(_replace_Matrix3x2)), METH_VARARGS | METH_KEYWORDS, nullptr },
        { "unpack", reinterpret_cast<PyCFunction>(unpack_Matrix3x2), METH_NOARGS, nullptr },
        { }};

    static PyObject* Matrix3x2_get_M11(py::wrapper::Windows::Foundation::Numerics::Matrix3x2* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.m11);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Matrix3x2_get_M12(py::wrapper::Windows::Foundation::Numerics::Matrix3x2* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.m12);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Matrix3x2_get_M21(py::wrapper::Windows::Foundation::Numerics::Matrix3x2* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.m21);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Matrix3x2_get_M22(py::wrapper::Windows::Foundation::Numerics::Matrix3x2* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.m22);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Matrix3x2_get_M31(py::wrapper::Windows::Foundation::Numerics::Matrix3x2* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.m31);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Matrix3x2_get_M32(py::wrapper::Windows::Foundation::Numerics::Matrix3x2* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.m32);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyGetSetDef _getset_Matrix3x2[] = {
        { "m11", reinterpret_cast<getter>(Matrix3x2_get_M11), nullptr, nullptr, nullptr },
        { "m12", reinterpret_cast<getter>(Matrix3x2_get_M12), nullptr, nullptr, nullptr },
        { "m21", reinterpret_cast<getter>(Matrix3x2_get_M21), nullptr, nullptr, nullptr },
        { "m22", reinterpret_cast<getter>(Matrix3x2_get_M22), nullptr, nullptr, nullptr },
        { "m31", reinterpret_cast<getter>(Matrix3x2_get_M31), nullptr, nullptr, nullptr },
        { "m32", reinterpret_cast<getter>(Matrix3x2_get_M32), nullptr, nullptr, nullptr },
        { }};

    static PyObject* _add_Matrix3x2(PyObject* left, PyObject* right) noexcept
    {
        try
        {
            auto _left = py::convert_to<winrt::Windows::Foundation::Numerics::float3x2>(left);
            auto _right = py::convert_to<winrt::Windows::Foundation::Numerics::float3x2>(right);

            auto _result = _left + _right;
            return py::convert(_result);
        }
        catch (...)
        {
            py::to_PyErr();

            if (PyErr_ExceptionMatches(PyExc_TypeError))
            {
                PyErr_Clear();
                Py_RETURN_NOTIMPLEMENTED;
            }

            return nullptr;
        }
    }

    static PyObject* _sub_Matrix3x2(PyObject* left, PyObject* right) noexcept
    {
        try
        {
            auto _left = py::convert_to<winrt::Windows::Foundation::Numerics::float3x2>(left);
            auto _right = py::convert_to<winrt::Windows::Foundation::Numerics::float3x2>(right);

            auto _result = _left - _right;
            return py::convert(_result);
        }
        catch (...)
        {
            py::to_PyErr();

            if (PyErr_ExceptionMatches(PyExc_TypeError))
            {
                PyErr_Clear();
                Py_RETURN_NOTIMPLEMENTED;
            }

            return nullptr;
        }
    }

    static PyObject* _mul_Matrix3x2(PyObject* left, PyObject* right) noexcept
    {
        try
        {
            auto _left = py::convert_to<winrt::Windows::Foundation::Numerics::float3x2>(left);

            py::pyobj_handle right_float{PyNumber_Float(right)};
            if (right_float)
            {
                auto _right_float = PyFloat_AsDouble(right_float.get());
                if (_right_float == -1 && PyErr_Occurred())
                {
                    return nullptr;
                }

                auto _result = _left * static_cast<float>(_right_float);
                return py::convert(_result);
            }
            else
            {
                PyErr_Clear();
            }

            auto _right = py::convert_to<winrt::Windows::Foundation::Numerics::float3x2>(right);

            auto _result = _left * _right;
            return py::convert(_result);
        }
        catch (...)
        {
            py::to_PyErr();

            if (PyErr_ExceptionMatches(PyExc_TypeError))
            {
                PyErr_Clear();
                Py_RETURN_NOTIMPLEMENTED;
            }

            return nullptr;
        }
    }

    static PyObject* _neg_Matrix3x2(PyObject* operand) noexcept
    {
        try
        {
            auto _operand = py::convert_to<winrt::Windows::Foundation::Numerics::float3x2>(operand);
            auto _result = -_operand;
            return py::convert(_result);
        }
        catch (...)
        {
            py::to_PyErr();

            if (PyErr_ExceptionMatches(PyExc_TypeError))
            {
                PyErr_Clear();
                Py_RETURN_NOTIMPLEMENTED;
            }

            return nullptr;
        }
    }

    static PyObject* _richcompare_Matrix3x2(py::wrapper::Windows::Foundation::Numerics::Matrix3x2* self, PyObject* other, int op) noexcept
    {
        try
        {
            auto _other = py::convert_to<winrt::Windows::Foundation::Numerics::float3x2>(other);

            if (op == Py_EQ)
            {
                if (self->obj == _other)
                {
                    Py_RETURN_TRUE;
                }

                Py_RETURN_FALSE;
            }

            if (op == Py_NE)
            {
                if (self->obj != _other)
                {
                    Py_RETURN_TRUE;
                }

                Py_RETURN_FALSE;
            }

            Py_RETURN_NOTIMPLEMENTED;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _repr_Matrix3x2(PyObject* self) noexcept
    {
        py::pyobj_handle M11{PyObject_GetAttrString(self, "m11")};
        if (!M11)
        {
            return nullptr;
        }

        py::pyobj_handle M12{PyObject_GetAttrString(self, "m12")};
        if (!M12)
        {
            return nullptr;
        }

        py::pyobj_handle M21{PyObject_GetAttrString(self, "m21")};
        if (!M21)
        {
            return nullptr;
        }

        py::pyobj_handle M22{PyObject_GetAttrString(self, "m22")};
        if (!M22)
        {
            return nullptr;
        }

        py::pyobj_handle M31{PyObject_GetAttrString(self, "m31")};
        if (!M31)
        {
            return nullptr;
        }

        py::pyobj_handle M32{PyObject_GetAttrString(self, "m32")};
        if (!M32)
        {
            return nullptr;
        }

        return PyUnicode_FromFormat("Matrix3x2(m11=%R, m12=%R, m21=%R, m22=%R, m31=%R, m32=%R)", M11.get(), M12.get(), M21.get(), M22.get(), M31.get(), M32.get());
    }

    static PyType_Slot _type_slots_Matrix3x2[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_Matrix3x2) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_Matrix3x2) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_Matrix3x2) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_Matrix3x2) },
        { Py_nb_add, reinterpret_cast<void*>(_add_Matrix3x2) },
        { Py_nb_subtract, reinterpret_cast<void*>(_sub_Matrix3x2) },
        { Py_nb_multiply, reinterpret_cast<void*>(_mul_Matrix3x2) },
        { Py_nb_negative, reinterpret_cast<void*>(_neg_Matrix3x2) },
        { Py_tp_richcompare, reinterpret_cast<void*>(_richcompare_Matrix3x2) },
        { Py_tp_repr, reinterpret_cast<void*>(_repr_Matrix3x2) },
        { }};

    static PyType_Spec type_spec_Matrix3x2 = {
        "winrt._winrt_windows_foundation_numerics.Matrix3x2",
        sizeof(py::wrapper::Windows::Foundation::Numerics::Matrix3x2),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_Matrix3x2};

    static PyGetSetDef getset_Matrix3x2_Static[] = {
        { "identity", _get_identity_Matrix3x2, nullptr, nullptr, nullptr },
        { }};

    static PyMethodDef methods_Matrix3x2_Static[] = {
        { "make_translation", make_translation_Matrix3x2, METH_VARARGS, nullptr },
        { "make_scale", make_scale_Matrix3x2, METH_VARARGS, nullptr },
        { "make_scale_from_vector", make_scale_from_vector_Matrix3x2, METH_VARARGS, nullptr },
        { "make_scale_from_scalar", make_scale_from_scalar_Matrix3x2, METH_VARARGS, nullptr },
        { "make_skew", make_skew_Matrix3x2, METH_VARARGS, nullptr },
        { "make_rotation", make_rotation_Matrix3x2, METH_VARARGS, nullptr },
        { }};

    static PyType_Slot type_slots_Matrix3x2_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_Matrix3x2_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_Matrix3x2_Static) },
        { }
    };

    static PyType_Spec type_spec_Matrix3x2_Static = {
        "winrt._winrt_windows_foundation_numerics.Matrix3x2_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_Matrix3x2_Static};

    // ----- Matrix4x4 struct --------------------

    winrt::Windows::Foundation::Numerics::float4x4 Matrix4x4_from_tuple(PyObject* tuple)
    {
        if (PyTuple_GET_SIZE(tuple) != 16)
        {
            PyErr_SetString(PyExc_TypeError, "Incorrect number of fields");
            throw python_exception();
        }

        winrt::Windows::Foundation::Numerics::float4x4 result{};

        result.m11 = py::convert_to<float>(tuple, 0);
        result.m12 = py::convert_to<float>(tuple, 1);
        result.m13 = py::convert_to<float>(tuple, 2);
        result.m14 = py::convert_to<float>(tuple, 3);
        result.m21 = py::convert_to<float>(tuple, 4);
        result.m22 = py::convert_to<float>(tuple, 5);
        result.m23 = py::convert_to<float>(tuple, 6);
        result.m24 = py::convert_to<float>(tuple, 7);
        result.m31 = py::convert_to<float>(tuple, 8);
        result.m32 = py::convert_to<float>(tuple, 9);
        result.m33 = py::convert_to<float>(tuple, 10);
        result.m34 = py::convert_to<float>(tuple, 11);
        result.m41 = py::convert_to<float>(tuple, 12);
        result.m42 = py::convert_to<float>(tuple, 13);
        result.m43 = py::convert_to<float>(tuple, 14);
        result.m44 = py::convert_to<float>(tuple, 15);

        return result;
    }

    PyObject* _new_Matrix4x4(PyTypeObject* subclass, PyObject* args, PyObject* kwds) noexcept
    {
        pyobj_handle self_obj{(subclass->tp_alloc(subclass, 0))};
        if (!self_obj)
        {
            return nullptr;
        }

        auto self = reinterpret_cast<winrt_struct_wrapper<winrt::Windows::Foundation::Numerics::float4x4>*>(self_obj.get());
        std::construct_at(&self->obj);

        auto tuple_size = PyTuple_GET_SIZE(args);
        if ((tuple_size == 0) && (!kwds))
        {
            return self_obj.detach();
        }

        float _M11{};
        float _M12{};
        float _M13{};
        float _M14{};
        float _M21{};
        float _M22{};
        float _M23{};
        float _M24{};
        float _M31{};
        float _M32{};
        float _M33{};
        float _M34{};
        float _M41{};
        float _M42{};
        float _M43{};
        float _M44{};

        static const char* kwlist[] = {"m11", "m12", "m13", "m14", "m21", "m22", "m23", "m24", "m31", "m32", "m33", "m34", "m41", "m42", "m43", "m44", nullptr};
        if (!PyArg_ParseTupleAndKeywords(args, kwds, "|ffffffffffffffff", const_cast<char**>(kwlist), &_M11, &_M12, &_M13, &_M14, &_M21, &_M22, &_M23, &_M24, &_M31, &_M32, &_M33, &_M34, &_M41, &_M42, &_M43, &_M44))
        {
            return nullptr;
        }

        try
        {
            self->obj.m11 = _M11;
            self->obj.m12 = _M12;
            self->obj.m13 = _M13;
            self->obj.m14 = _M14;
            self->obj.m21 = _M21;
            self->obj.m22 = _M22;
            self->obj.m23 = _M23;
            self->obj.m24 = _M24;
            self->obj.m31 = _M31;
            self->obj.m32 = _M32;
            self->obj.m33 = _M33;
            self->obj.m34 = _M34;
            self->obj.m41 = _M41;
            self->obj.m42 = _M42;
            self->obj.m43 = _M43;
            self->obj.m44 = _M44;

            return self_obj.detach();
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static void _dealloc_Matrix4x4(py::wrapper::Windows::Foundation::Numerics::Matrix4x4* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* make_billboard_Matrix4x4(PyObject* /*unused*/, PyObject* args) noexcept
    {
        try
        {
            auto n_args = PyTuple_GET_SIZE(args);

            if (n_args == 4)
            {
#if defined(__MINGW32__)
                (void)args;
                PyErr_SetString(PyExc_NotImplementedError, "Overload with 4 args is not implemented on MinGW");
                return nullptr;
#else
                auto _arg0 = py::convert_to<winrt::Windows::Foundation::Numerics::float3>(args, 0);
                auto _arg1 = py::convert_to<winrt::Windows::Foundation::Numerics::float3>(args, 1);
                auto _arg2 = py::convert_to<winrt::Windows::Foundation::Numerics::float3>(args, 2);
                auto _arg3 = py::convert_to<winrt::Windows::Foundation::Numerics::float3>(args, 3);
                auto _result = winrt::Windows::Foundation::Numerics::make_float4x4_billboard(_arg0, _arg1, _arg2, _arg3);
                return py::convert(_result);
#endif
            }

            PyErr_Format(PyExc_TypeError, "No overload take %d args.", n_args);
            return nullptr;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* make_constrained_billboard_Matrix4x4(PyObject* /*unused*/, PyObject* args) noexcept
    {
        try
        {
            auto n_args = PyTuple_GET_SIZE(args);

            if (n_args == 5)
            {
#if defined(__MINGW32__)
                (void)args;
                PyErr_SetString(PyExc_NotImplementedError, "Overload with 5 args is not implemented on MinGW");
                return nullptr;
#else
                auto _arg0 = py::convert_to<winrt::Windows::Foundation::Numerics::float3>(args, 0);
                auto _arg1 = py::convert_to<winrt::Windows::Foundation::Numerics::float3>(args, 1);
                auto _arg2 = py::convert_to<winrt::Windows::Foundation::Numerics::float3>(args, 2);
                auto _arg3 = py::convert_to<winrt::Windows::Foundation::Numerics::float3>(args, 3);
                auto _arg4 = py::convert_to<winrt::Windows::Foundation::Numerics::float3>(args, 4);
                auto _result = winrt::Windows::Foundation::Numerics::make_float4x4_constrained_billboard(_arg0, _arg1, _arg2, _arg3, _arg4);
                return py::convert(_result);
#endif
            }

            PyErr_Format(PyExc_TypeError, "No overload take %d args.", n_args);
            return nullptr;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* make_translation_Matrix4x4(PyObject* /*unused*/, PyObject* args) noexcept
    {
        try
        {
            auto n_args = PyTuple_GET_SIZE(args);

            if (n_args == 1)
            {
                auto _arg0 = py::convert_to<winrt::Windows::Foundation::Numerics::float3>(args, 0);
                auto _result = winrt::Windows::Foundation::Numerics::make_float4x4_translation(_arg0);
                return py::convert(_result);
            }

            if (n_args == 3)
            {
#if defined(__MINGW32__)
                (void)args;
                PyErr_SetString(PyExc_NotImplementedError, "Overload with 3 args is not implemented on MinGW");
                return nullptr;
#else
                auto _arg0 = py::convert_to<float>(args, 0);
                auto _arg1 = py::convert_to<float>(args, 1);
                auto _arg2 = py::convert_to<float>(args, 2);
                auto _result = winrt::Windows::Foundation::Numerics::make_float4x4_translation(_arg0, _arg1, _arg2);
                return py::convert(_result);
#endif
            }

            PyErr_Format(PyExc_TypeError, "No overload take %d args.", n_args);
            return nullptr;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* make_scale_Matrix4x4(PyObject* /*unused*/, PyObject* args) noexcept
    {
        try
        {
            auto n_args = PyTuple_GET_SIZE(args);

            if (n_args == 3)
            {
#if defined(__MINGW32__)
                (void)args;
                PyErr_SetString(PyExc_NotImplementedError, "Overload with 3 args is not implemented on MinGW");
                return nullptr;
#else
                auto _arg0 = py::convert_to<float>(args, 0);
                auto _arg1 = py::convert_to<float>(args, 1);
                auto _arg2 = py::convert_to<float>(args, 2);
                auto _result = winrt::Windows::Foundation::Numerics::make_float4x4_scale(_arg0, _arg1, _arg2);
                return py::convert(_result);
#endif
            }

            if (n_args == 4)
            {
#if defined(__MINGW32__)
                (void)args;
                PyErr_SetString(PyExc_NotImplementedError, "Overload with 4 args is not implemented on MinGW");
                return nullptr;
#else
                auto _arg0 = py::convert_to<float>(args, 0);
                auto _arg1 = py::convert_to<float>(args, 1);
                auto _arg2 = py::convert_to<float>(args, 2);
                auto _arg3 = py::convert_to<winrt::Windows::Foundation::Numerics::float3>(args, 3);
                auto _result = winrt::Windows::Foundation::Numerics::make_float4x4_scale(_arg0, _arg1, _arg2, _arg3);
                return py::convert(_result);
#endif
            }

            PyErr_Format(PyExc_TypeError, "No overload take %d args.", n_args);
            return nullptr;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* make_scale_from_vector_Matrix4x4(PyObject* /*unused*/, PyObject* args) noexcept
    {
        try
        {
            auto n_args = PyTuple_GET_SIZE(args);

            if (n_args == 1)
            {
#if defined(__MINGW32__)
                (void)args;
                PyErr_SetString(PyExc_NotImplementedError, "Overload with 1 args is not implemented on MinGW");
                return nullptr;
#else
                auto _arg0 = py::convert_to<winrt::Windows::Foundation::Numerics::float3>(args, 0);
                auto _result = winrt::Windows::Foundation::Numerics::make_float4x4_scale(_arg0);
                return py::convert(_result);
#endif
            }

            if (n_args == 2)
            {
#if defined(__MINGW32__)
                (void)args;
                PyErr_SetString(PyExc_NotImplementedError, "Overload with 2 args is not implemented on MinGW");
                return nullptr;
#else
                auto _arg0 = py::convert_to<winrt::Windows::Foundation::Numerics::float3>(args, 0);
                auto _arg1 = py::convert_to<winrt::Windows::Foundation::Numerics::float3>(args, 1);
                auto _result = winrt::Windows::Foundation::Numerics::make_float4x4_scale(_arg0, _arg1);
                return py::convert(_result);
#endif
            }

            PyErr_Format(PyExc_TypeError, "No overload take %d args.", n_args);
            return nullptr;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* make_scale_from_scalar_Matrix4x4(PyObject* /*unused*/, PyObject* args) noexcept
    {
        try
        {
            auto n_args = PyTuple_GET_SIZE(args);

            if (n_args == 1)
            {
#if defined(__MINGW32__)
                (void)args;
                PyErr_SetString(PyExc_NotImplementedError, "Overload with 1 args is not implemented on MinGW");
                return nullptr;
#else
                auto _arg0 = py::convert_to<float>(args, 0);
                auto _result = winrt::Windows::Foundation::Numerics::make_float4x4_scale(_arg0);
                return py::convert(_result);
#endif
            }

            if (n_args == 2)
            {
#if defined(__MINGW32__)
                (void)args;
                PyErr_SetString(PyExc_NotImplementedError, "Overload with 2 args is not implemented on MinGW");
                return nullptr;
#else
                auto _arg0 = py::convert_to<float>(args, 0);
                auto _arg1 = py::convert_to<winrt::Windows::Foundation::Numerics::float3>(args, 1);
                auto _result = winrt::Windows::Foundation::Numerics::make_float4x4_scale(_arg0, _arg1);
                return py::convert(_result);
#endif
            }

            PyErr_Format(PyExc_TypeError, "No overload take %d args.", n_args);
            return nullptr;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* make_rotation_x_Matrix4x4(PyObject* /*unused*/, PyObject* args) noexcept
    {
        try
        {
            auto n_args = PyTuple_GET_SIZE(args);

            if (n_args == 1)
            {
#if defined(__MINGW32__)
                (void)args;
                PyErr_SetString(PyExc_NotImplementedError, "Overload with 1 args is not implemented on MinGW");
                return nullptr;
#else
                auto _arg0 = py::convert_to<float>(args, 0);
                auto _result = winrt::Windows::Foundation::Numerics::make_float4x4_rotation_x(_arg0);
                return py::convert(_result);
#endif
            }

            if (n_args == 2)
            {
#if defined(__MINGW32__)
                (void)args;
                PyErr_SetString(PyExc_NotImplementedError, "Overload with 2 args is not implemented on MinGW");
                return nullptr;
#else
                auto _arg0 = py::convert_to<float>(args, 0);
                auto _arg1 = py::convert_to<winrt::Windows::Foundation::Numerics::float3>(args, 1);
                auto _result = winrt::Windows::Foundation::Numerics::make_float4x4_rotation_x(_arg0, _arg1);
                return py::convert(_result);
#endif
            }

            PyErr_Format(PyExc_TypeError, "No overload take %d args.", n_args);
            return nullptr;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* make_rotation_y_Matrix4x4(PyObject* /*unused*/, PyObject* args) noexcept
    {
        try
        {
            auto n_args = PyTuple_GET_SIZE(args);

            if (n_args == 1)
            {
#if defined(__MINGW32__)
                (void)args;
                PyErr_SetString(PyExc_NotImplementedError, "Overload with 1 args is not implemented on MinGW");
                return nullptr;
#else
                auto _arg0 = py::convert_to<float>(args, 0);
                auto _result = winrt::Windows::Foundation::Numerics::make_float4x4_rotation_y(_arg0);
                return py::convert(_result);
#endif
            }

            if (n_args == 2)
            {
#if defined(__MINGW32__)
                (void)args;
                PyErr_SetString(PyExc_NotImplementedError, "Overload with 2 args is not implemented on MinGW");
                return nullptr;
#else
                auto _arg0 = py::convert_to<float>(args, 0);
                auto _arg1 = py::convert_to<winrt::Windows::Foundation::Numerics::float3>(args, 1);
                auto _result = winrt::Windows::Foundation::Numerics::make_float4x4_rotation_y(_arg0, _arg1);
                return py::convert(_result);
#endif
            }

            PyErr_Format(PyExc_TypeError, "No overload take %d args.", n_args);
            return nullptr;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* make_rotation_z_Matrix4x4(PyObject* /*unused*/, PyObject* args) noexcept
    {
        try
        {
            auto n_args = PyTuple_GET_SIZE(args);

            if (n_args == 1)
            {
#if defined(__MINGW32__)
                (void)args;
                PyErr_SetString(PyExc_NotImplementedError, "Overload with 1 args is not implemented on MinGW");
                return nullptr;
#else
                auto _arg0 = py::convert_to<float>(args, 0);
                auto _result = winrt::Windows::Foundation::Numerics::make_float4x4_rotation_z(_arg0);
                return py::convert(_result);
#endif
            }

            if (n_args == 2)
            {
#if defined(__MINGW32__)
                (void)args;
                PyErr_SetString(PyExc_NotImplementedError, "Overload with 2 args is not implemented on MinGW");
                return nullptr;
#else
                auto _arg0 = py::convert_to<float>(args, 0);
                auto _arg1 = py::convert_to<winrt::Windows::Foundation::Numerics::float3>(args, 1);
                auto _result = winrt::Windows::Foundation::Numerics::make_float4x4_rotation_z(_arg0, _arg1);
                return py::convert(_result);
#endif
            }

            PyErr_Format(PyExc_TypeError, "No overload take %d args.", n_args);
            return nullptr;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* make_from_axis_angle_Matrix4x4(PyObject* /*unused*/, PyObject* args) noexcept
    {
        try
        {
            auto n_args = PyTuple_GET_SIZE(args);

            if (n_args == 2)
            {
#if defined(__MINGW32__)
                (void)args;
                PyErr_SetString(PyExc_NotImplementedError, "Overload with 2 args is not implemented on MinGW");
                return nullptr;
#else
                auto _arg0 = py::convert_to<winrt::Windows::Foundation::Numerics::float3>(args, 0);
                auto _arg1 = py::convert_to<float>(args, 1);
                auto _result = winrt::Windows::Foundation::Numerics::make_float4x4_from_axis_angle(_arg0, _arg1);
                return py::convert(_result);
#endif
            }

            PyErr_Format(PyExc_TypeError, "No overload take %d args.", n_args);
            return nullptr;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* make_perspective_field_of_view_Matrix4x4(PyObject* /*unused*/, PyObject* args) noexcept
    {
        try
        {
            auto n_args = PyTuple_GET_SIZE(args);

            if (n_args == 4)
            {
#if defined(__MINGW32__)
                (void)args;
                PyErr_SetString(PyExc_NotImplementedError, "Overload with 4 args is not implemented on MinGW");
                return nullptr;
#else
                auto _arg0 = py::convert_to<float>(args, 0);
                auto _arg1 = py::convert_to<float>(args, 1);
                auto _arg2 = py::convert_to<float>(args, 2);
                auto _arg3 = py::convert_to<float>(args, 3);
                auto _result = winrt::Windows::Foundation::Numerics::make_float4x4_perspective_field_of_view(_arg0, _arg1, _arg2, _arg3);
                return py::convert(_result);
#endif
            }

            PyErr_Format(PyExc_TypeError, "No overload take %d args.", n_args);
            return nullptr;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* make_perspective_Matrix4x4(PyObject* /*unused*/, PyObject* args) noexcept
    {
        try
        {
            auto n_args = PyTuple_GET_SIZE(args);

            if (n_args == 4)
            {
#if defined(__MINGW32__)
                (void)args;
                PyErr_SetString(PyExc_NotImplementedError, "Overload with 4 args is not implemented on MinGW");
                return nullptr;
#else
                auto _arg0 = py::convert_to<float>(args, 0);
                auto _arg1 = py::convert_to<float>(args, 1);
                auto _arg2 = py::convert_to<float>(args, 2);
                auto _arg3 = py::convert_to<float>(args, 3);
                auto _result = winrt::Windows::Foundation::Numerics::make_float4x4_perspective(_arg0, _arg1, _arg2, _arg3);
                return py::convert(_result);
#endif
            }

            PyErr_Format(PyExc_TypeError, "No overload take %d args.", n_args);
            return nullptr;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* make_perspective_off_center_Matrix4x4(PyObject* /*unused*/, PyObject* args) noexcept
    {
        try
        {
            auto n_args = PyTuple_GET_SIZE(args);

            if (n_args == 6)
            {
#if defined(__MINGW32__)
                (void)args;
                PyErr_SetString(PyExc_NotImplementedError, "Overload with 6 args is not implemented on MinGW");
                return nullptr;
#else
                auto _arg0 = py::convert_to<float>(args, 0);
                auto _arg1 = py::convert_to<float>(args, 1);
                auto _arg2 = py::convert_to<float>(args, 2);
                auto _arg3 = py::convert_to<float>(args, 3);
                auto _arg4 = py::convert_to<float>(args, 4);
                auto _arg5 = py::convert_to<float>(args, 5);
                auto _result = winrt::Windows::Foundation::Numerics::make_float4x4_perspective_off_center(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5);
                return py::convert(_result);
#endif
            }

            PyErr_Format(PyExc_TypeError, "No overload take %d args.", n_args);
            return nullptr;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* make_orthographic_Matrix4x4(PyObject* /*unused*/, PyObject* args) noexcept
    {
        try
        {
            auto n_args = PyTuple_GET_SIZE(args);

            if (n_args == 4)
            {
#if defined(__MINGW32__)
                (void)args;
                PyErr_SetString(PyExc_NotImplementedError, "Overload with 4 args is not implemented on MinGW");
                return nullptr;
#else
                auto _arg0 = py::convert_to<float>(args, 0);
                auto _arg1 = py::convert_to<float>(args, 1);
                auto _arg2 = py::convert_to<float>(args, 2);
                auto _arg3 = py::convert_to<float>(args, 3);
                auto _result = winrt::Windows::Foundation::Numerics::make_float4x4_orthographic(_arg0, _arg1, _arg2, _arg3);
                return py::convert(_result);
#endif
            }

            PyErr_Format(PyExc_TypeError, "No overload take %d args.", n_args);
            return nullptr;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* make_orthographic_off_center_Matrix4x4(PyObject* /*unused*/, PyObject* args) noexcept
    {
        try
        {
            auto n_args = PyTuple_GET_SIZE(args);

            if (n_args == 6)
            {
#if defined(__MINGW32__)
                (void)args;
                PyErr_SetString(PyExc_NotImplementedError, "Overload with 6 args is not implemented on MinGW");
                return nullptr;
#else
                auto _arg0 = py::convert_to<float>(args, 0);
                auto _arg1 = py::convert_to<float>(args, 1);
                auto _arg2 = py::convert_to<float>(args, 2);
                auto _arg3 = py::convert_to<float>(args, 3);
                auto _arg4 = py::convert_to<float>(args, 4);
                auto _arg5 = py::convert_to<float>(args, 5);
                auto _result = winrt::Windows::Foundation::Numerics::make_float4x4_orthographic_off_center(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5);
                return py::convert(_result);
#endif
            }

            PyErr_Format(PyExc_TypeError, "No overload take %d args.", n_args);
            return nullptr;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* make_look_at_Matrix4x4(PyObject* /*unused*/, PyObject* args) noexcept
    {
        try
        {
            auto n_args = PyTuple_GET_SIZE(args);

            if (n_args == 3)
            {
#if defined(__MINGW32__)
                (void)args;
                PyErr_SetString(PyExc_NotImplementedError, "Overload with 3 args is not implemented on MinGW");
                return nullptr;
#else
                auto _arg0 = py::convert_to<winrt::Windows::Foundation::Numerics::float3>(args, 0);
                auto _arg1 = py::convert_to<winrt::Windows::Foundation::Numerics::float3>(args, 1);
                auto _arg2 = py::convert_to<winrt::Windows::Foundation::Numerics::float3>(args, 2);
                auto _result = winrt::Windows::Foundation::Numerics::make_float4x4_look_at(_arg0, _arg1, _arg2);
                return py::convert(_result);
#endif
            }

            PyErr_Format(PyExc_TypeError, "No overload take %d args.", n_args);
            return nullptr;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* make_world_Matrix4x4(PyObject* /*unused*/, PyObject* args) noexcept
    {
        try
        {
            auto n_args = PyTuple_GET_SIZE(args);

            if (n_args == 3)
            {
#if defined(__MINGW32__)
                (void)args;
                PyErr_SetString(PyExc_NotImplementedError, "Overload with 3 args is not implemented on MinGW");
                return nullptr;
#else
                auto _arg0 = py::convert_to<winrt::Windows::Foundation::Numerics::float3>(args, 0);
                auto _arg1 = py::convert_to<winrt::Windows::Foundation::Numerics::float3>(args, 1);
                auto _arg2 = py::convert_to<winrt::Windows::Foundation::Numerics::float3>(args, 2);
                auto _result = winrt::Windows::Foundation::Numerics::make_float4x4_world(_arg0, _arg1, _arg2);
                return py::convert(_result);
#endif
            }

            PyErr_Format(PyExc_TypeError, "No overload take %d args.", n_args);
            return nullptr;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* make_from_quaternion_Matrix4x4(PyObject* /*unused*/, PyObject* args) noexcept
    {
        try
        {
            auto n_args = PyTuple_GET_SIZE(args);

            if (n_args == 1)
            {
                auto _arg0 = py::convert_to<winrt::Windows::Foundation::Numerics::quaternion>(args, 0);
                auto _result = winrt::Windows::Foundation::Numerics::make_float4x4_from_quaternion(_arg0);
                return py::convert(_result);
            }

            PyErr_Format(PyExc_TypeError, "No overload take %d args.", n_args);
            return nullptr;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* make_from_yaw_pitch_roll_Matrix4x4(PyObject* /*unused*/, PyObject* args) noexcept
    {
        try
        {
            auto n_args = PyTuple_GET_SIZE(args);

            if (n_args == 3)
            {
#if defined(__MINGW32__)
                (void)args;
                PyErr_SetString(PyExc_NotImplementedError, "Overload with 3 args is not implemented on MinGW");
                return nullptr;
#else
                auto _arg0 = py::convert_to<float>(args, 0);
                auto _arg1 = py::convert_to<float>(args, 1);
                auto _arg2 = py::convert_to<float>(args, 2);
                auto _result = winrt::Windows::Foundation::Numerics::make_float4x4_from_yaw_pitch_roll(_arg0, _arg1, _arg2);
                return py::convert(_result);
#endif
            }

            PyErr_Format(PyExc_TypeError, "No overload take %d args.", n_args);
            return nullptr;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* make_shadow_Matrix4x4(PyObject* /*unused*/, PyObject* args) noexcept
    {
        try
        {
            auto n_args = PyTuple_GET_SIZE(args);

            if (n_args == 2)
            {
#if defined(__MINGW32__)
                (void)args;
                PyErr_SetString(PyExc_NotImplementedError, "Overload with 2 args is not implemented on MinGW");
                return nullptr;
#else
                auto _arg0 = py::convert_to<winrt::Windows::Foundation::Numerics::float3>(args, 0);
                auto _arg1 = py::convert_to<winrt::Windows::Foundation::Numerics::plane>(args, 1);
                auto _result = winrt::Windows::Foundation::Numerics::make_float4x4_shadow(_arg0, _arg1);
                return py::convert(_result);
#endif
            }

            PyErr_Format(PyExc_TypeError, "No overload take %d args.", n_args);
            return nullptr;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* make_reflection_Matrix4x4(PyObject* /*unused*/, PyObject* args) noexcept
    {
        try
        {
            auto n_args = PyTuple_GET_SIZE(args);

            if (n_args == 1)
            {
#if defined(__MINGW32__)
                (void)args;
                PyErr_SetString(PyExc_NotImplementedError, "Overload with 1 args is not implemented on MinGW");
                return nullptr;
#else
                auto _arg0 = py::convert_to<winrt::Windows::Foundation::Numerics::plane>(args, 0);
                auto _result = winrt::Windows::Foundation::Numerics::make_float4x4_reflection(_arg0);
                return py::convert(_result);
#endif
            }

            PyErr_Format(PyExc_TypeError, "No overload take %d args.", n_args);
            return nullptr;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _get_identity_Matrix4x4(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        return py::convert(winrt::Windows::Foundation::Numerics::float4x4::identity());
    }

    static PyObject* is_identity_Matrix4x4(winrt_struct_wrapper<winrt::Windows::Foundation::Numerics::float4x4>* self, PyObject* /*unused*/) noexcept
    {
        try
        {
            auto _result = winrt::Windows::Foundation::Numerics::is_identity(self->obj);
            return py::convert(_result);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* determinant_Matrix4x4(winrt_struct_wrapper<winrt::Windows::Foundation::Numerics::float4x4>* self, PyObject* /*unused*/) noexcept
    {
        try
        {
            auto _result = winrt::Windows::Foundation::Numerics::determinant(self->obj);
            return py::convert(_result);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* translation_Matrix4x4(winrt_struct_wrapper<winrt::Windows::Foundation::Numerics::float4x4>* self, PyObject* /*unused*/) noexcept
    {
        try
        {
            auto _result = winrt::Windows::Foundation::Numerics::translation(self->obj);
            return py::convert(_result);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* invert_Matrix4x4(winrt_struct_wrapper<winrt::Windows::Foundation::Numerics::float4x4>* self, PyObject* /*unused*/) noexcept
    {
        try
        {
#if defined(__MINGW32__)
            (void)self;
            PyErr_SetString(PyExc_NotImplementedError, "This method is not implemented on MinGW");
            return nullptr;
#else
            winrt::Windows::Foundation::Numerics::float4x4 _result;

            if (!winrt::Windows::Foundation::Numerics::invert(self->obj, &_result))
            {
                PyErr_SetString(PyExc_ValueError, "Matrix is not invertible");
                return nullptr;
            }

            return py::convert(_result);
#endif
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* decompose_Matrix4x4(winrt_struct_wrapper<winrt::Windows::Foundation::Numerics::float4x4>* self, PyObject* /*unused*/) noexcept
    {
        try
        {
#if defined(__MINGW32__)
            (void)self;
            PyErr_SetString(PyExc_NotImplementedError, "This method is not implemented on MinGW");
            return nullptr;
#else
            winrt::Windows::Foundation::Numerics::float3 _out0;
            winrt::Windows::Foundation::Numerics::quaternion _out1;
            winrt::Windows::Foundation::Numerics::float3 _out2;

            if (!winrt::Windows::Foundation::Numerics::decompose(self->obj, &_out0, &_out1, &_out2))
            {
                PyErr_SetString(PyExc_ValueError, "Matrix is not decomposable");
                return nullptr;
            }

            py::pyobj_handle out0{py::convert(_out0)};
            py::pyobj_handle out1{py::convert(_out1)};
            py::pyobj_handle out2{py::convert(_out2)};

            return PyTuple_Pack(3, out0.get(), out1.get(), out2.get());
#endif
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* transform_Matrix4x4(winrt_struct_wrapper<winrt::Windows::Foundation::Numerics::float4x4>* self, PyObject* arg) noexcept
    {
        try
        {
#if defined(__MINGW32__)
            (void)self;
            (void)arg;
            PyErr_SetString(PyExc_NotImplementedError, "This method is not implemented on MinGW");
            return nullptr;
#else
            auto _arg = py::convert_to<winrt::Windows::Foundation::Numerics::quaternion>(arg);
            auto _result = winrt::Windows::Foundation::Numerics::transform(self->obj, _arg);
            return py::convert(_result);
#endif
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* transpose_Matrix4x4(winrt_struct_wrapper<winrt::Windows::Foundation::Numerics::float4x4>* self, PyObject* /*unused*/) noexcept
    {
        try
        {
            auto _result = winrt::Windows::Foundation::Numerics::transpose(self->obj);
            return py::convert(_result);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* lerp_Matrix4x4(winrt_struct_wrapper<winrt::Windows::Foundation::Numerics::float4x4>* self, PyObject* args) noexcept
    {
        try
        {
#if defined(__MINGW32__)
            (void)self;
            (void)args;
            PyErr_SetString(PyExc_NotImplementedError, "This method is not implemented on MinGW");
            return nullptr;
#else
            auto _arg0 = py::convert_to<winrt::Windows::Foundation::Numerics::float4x4>(args, 0);
            auto _arg1 = py::convert_to<float>(args, 1);
            auto _result = winrt::Windows::Foundation::Numerics::lerp(self->obj, _arg0, _arg1);
            return py::convert(_result);
#endif
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_Matrix4x4(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Foundation::Numerics::float4x4>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    PyObject* _replace_Matrix4x4(py::wrapper::Windows::Foundation::Numerics::Matrix4x4* self, PyObject* args, PyObject* kwds) noexcept
    {
        try
        {
            float _M11{self->obj.m11};
            float _M12{self->obj.m12};
            float _M13{self->obj.m13};
            float _M14{self->obj.m14};
            float _M21{self->obj.m21};
            float _M22{self->obj.m22};
            float _M23{self->obj.m23};
            float _M24{self->obj.m24};
            float _M31{self->obj.m31};
            float _M32{self->obj.m32};
            float _M33{self->obj.m33};
            float _M34{self->obj.m34};
            float _M41{self->obj.m41};
            float _M42{self->obj.m42};
            float _M43{self->obj.m43};
            float _M44{self->obj.m44};

            static const char* kwlist[] = {"m11", "m12", "m13", "m14", "m21", "m22", "m23", "m24", "m31", "m32", "m33", "m34", "m41", "m42", "m43", "m44", nullptr};
            if (!PyArg_ParseTupleAndKeywords(args, kwds, "|$ffffffffffffffff", const_cast<char**>(kwlist), &_M11, &_M12, &_M13, &_M14, &_M21, &_M22, &_M23, &_M24, &_M31, &_M32, &_M33, &_M34, &_M41, &_M42, &_M43, &_M44))
            {
                return nullptr;
            }

            auto copy = self->obj;
            copy.m11 = _M11;
            copy.m12 = _M12;
            copy.m13 = _M13;
            copy.m14 = _M14;
            copy.m21 = _M21;
            copy.m22 = _M22;
            copy.m23 = _M23;
            copy.m24 = _M24;
            copy.m31 = _M31;
            copy.m32 = _M32;
            copy.m33 = _M33;
            copy.m34 = _M34;
            copy.m41 = _M41;
            copy.m42 = _M42;
            copy.m43 = _M43;
            copy.m44 = _M44;

            return convert(copy);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    PyObject* unpack_Matrix4x4(py::wrapper::Windows::Foundation::Numerics::Matrix4x4* self, PyObject* /*unused*/) noexcept
    {
        py::pyobj_handle M11{convert(self->obj.m11)};
        if (!M11)
        {
            return nullptr;
        }

        py::pyobj_handle M12{convert(self->obj.m12)};
        if (!M12)
        {
            return nullptr;
        }

        py::pyobj_handle M13{convert(self->obj.m13)};
        if (!M13)
        {
            return nullptr;
        }

        py::pyobj_handle M14{convert(self->obj.m14)};
        if (!M14)
        {
            return nullptr;
        }

        py::pyobj_handle M21{convert(self->obj.m21)};
        if (!M21)
        {
            return nullptr;
        }

        py::pyobj_handle M22{convert(self->obj.m22)};
        if (!M22)
        {
            return nullptr;
        }

        py::pyobj_handle M23{convert(self->obj.m23)};
        if (!M23)
        {
            return nullptr;
        }

        py::pyobj_handle M24{convert(self->obj.m24)};
        if (!M24)
        {
            return nullptr;
        }

        py::pyobj_handle M31{convert(self->obj.m31)};
        if (!M31)
        {
            return nullptr;
        }

        py::pyobj_handle M32{convert(self->obj.m32)};
        if (!M32)
        {
            return nullptr;
        }

        py::pyobj_handle M33{convert(self->obj.m33)};
        if (!M33)
        {
            return nullptr;
        }

        py::pyobj_handle M34{convert(self->obj.m34)};
        if (!M34)
        {
            return nullptr;
        }

        py::pyobj_handle M41{convert(self->obj.m41)};
        if (!M41)
        {
            return nullptr;
        }

        py::pyobj_handle M42{convert(self->obj.m42)};
        if (!M42)
        {
            return nullptr;
        }

        py::pyobj_handle M43{convert(self->obj.m43)};
        if (!M43)
        {
            return nullptr;
        }

        py::pyobj_handle M44{convert(self->obj.m44)};
        if (!M44)
        {
            return nullptr;
        }

        pyobj_handle tuple{PyTuple_New(16)};
        if (!tuple)
        {
            return nullptr;
        }

        PyTuple_SET_ITEM(tuple.get(), 0, M11.detach());
        PyTuple_SET_ITEM(tuple.get(), 1, M12.detach());
        PyTuple_SET_ITEM(tuple.get(), 2, M13.detach());
        PyTuple_SET_ITEM(tuple.get(), 3, M14.detach());
        PyTuple_SET_ITEM(tuple.get(), 4, M21.detach());
        PyTuple_SET_ITEM(tuple.get(), 5, M22.detach());
        PyTuple_SET_ITEM(tuple.get(), 6, M23.detach());
        PyTuple_SET_ITEM(tuple.get(), 7, M24.detach());
        PyTuple_SET_ITEM(tuple.get(), 8, M31.detach());
        PyTuple_SET_ITEM(tuple.get(), 9, M32.detach());
        PyTuple_SET_ITEM(tuple.get(), 10, M33.detach());
        PyTuple_SET_ITEM(tuple.get(), 11, M34.detach());
        PyTuple_SET_ITEM(tuple.get(), 12, M41.detach());
        PyTuple_SET_ITEM(tuple.get(), 13, M42.detach());
        PyTuple_SET_ITEM(tuple.get(), 14, M43.detach());
        PyTuple_SET_ITEM(tuple.get(), 15, M44.detach());

        return tuple.detach();
    }

    static PyMethodDef _methods_Matrix4x4[] = {
        { "is_identity", reinterpret_cast<PyCFunction>(is_identity_Matrix4x4), METH_NOARGS, nullptr },
        { "determinant", reinterpret_cast<PyCFunction>(determinant_Matrix4x4), METH_NOARGS, nullptr },
        { "translation", reinterpret_cast<PyCFunction>(translation_Matrix4x4), METH_NOARGS, nullptr },
        { "invert", reinterpret_cast<PyCFunction>(invert_Matrix4x4), METH_NOARGS, nullptr },
        { "decompose", reinterpret_cast<PyCFunction>(decompose_Matrix4x4), METH_NOARGS, nullptr },
        { "transform", reinterpret_cast<PyCFunction>(transform_Matrix4x4), METH_O, nullptr },
        { "transpose", reinterpret_cast<PyCFunction>(transpose_Matrix4x4), METH_NOARGS, nullptr },
        { "lerp", reinterpret_cast<PyCFunction>(lerp_Matrix4x4), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_Matrix4x4, METH_O | METH_STATIC, nullptr },
        { "__replace__", reinterpret_cast<PyCFunction>(reinterpret_cast<void*>(_replace_Matrix4x4)), METH_VARARGS | METH_KEYWORDS, nullptr },
        { "unpack", reinterpret_cast<PyCFunction>(unpack_Matrix4x4), METH_NOARGS, nullptr },
        { }};

    static PyObject* Matrix4x4_get_M11(py::wrapper::Windows::Foundation::Numerics::Matrix4x4* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.m11);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Matrix4x4_get_M12(py::wrapper::Windows::Foundation::Numerics::Matrix4x4* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.m12);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Matrix4x4_get_M13(py::wrapper::Windows::Foundation::Numerics::Matrix4x4* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.m13);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Matrix4x4_get_M14(py::wrapper::Windows::Foundation::Numerics::Matrix4x4* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.m14);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Matrix4x4_get_M21(py::wrapper::Windows::Foundation::Numerics::Matrix4x4* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.m21);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Matrix4x4_get_M22(py::wrapper::Windows::Foundation::Numerics::Matrix4x4* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.m22);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Matrix4x4_get_M23(py::wrapper::Windows::Foundation::Numerics::Matrix4x4* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.m23);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Matrix4x4_get_M24(py::wrapper::Windows::Foundation::Numerics::Matrix4x4* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.m24);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Matrix4x4_get_M31(py::wrapper::Windows::Foundation::Numerics::Matrix4x4* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.m31);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Matrix4x4_get_M32(py::wrapper::Windows::Foundation::Numerics::Matrix4x4* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.m32);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Matrix4x4_get_M33(py::wrapper::Windows::Foundation::Numerics::Matrix4x4* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.m33);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Matrix4x4_get_M34(py::wrapper::Windows::Foundation::Numerics::Matrix4x4* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.m34);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Matrix4x4_get_M41(py::wrapper::Windows::Foundation::Numerics::Matrix4x4* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.m41);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Matrix4x4_get_M42(py::wrapper::Windows::Foundation::Numerics::Matrix4x4* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.m42);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Matrix4x4_get_M43(py::wrapper::Windows::Foundation::Numerics::Matrix4x4* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.m43);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Matrix4x4_get_M44(py::wrapper::Windows::Foundation::Numerics::Matrix4x4* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.m44);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyGetSetDef _getset_Matrix4x4[] = {
        { "m11", reinterpret_cast<getter>(Matrix4x4_get_M11), nullptr, nullptr, nullptr },
        { "m12", reinterpret_cast<getter>(Matrix4x4_get_M12), nullptr, nullptr, nullptr },
        { "m13", reinterpret_cast<getter>(Matrix4x4_get_M13), nullptr, nullptr, nullptr },
        { "m14", reinterpret_cast<getter>(Matrix4x4_get_M14), nullptr, nullptr, nullptr },
        { "m21", reinterpret_cast<getter>(Matrix4x4_get_M21), nullptr, nullptr, nullptr },
        { "m22", reinterpret_cast<getter>(Matrix4x4_get_M22), nullptr, nullptr, nullptr },
        { "m23", reinterpret_cast<getter>(Matrix4x4_get_M23), nullptr, nullptr, nullptr },
        { "m24", reinterpret_cast<getter>(Matrix4x4_get_M24), nullptr, nullptr, nullptr },
        { "m31", reinterpret_cast<getter>(Matrix4x4_get_M31), nullptr, nullptr, nullptr },
        { "m32", reinterpret_cast<getter>(Matrix4x4_get_M32), nullptr, nullptr, nullptr },
        { "m33", reinterpret_cast<getter>(Matrix4x4_get_M33), nullptr, nullptr, nullptr },
        { "m34", reinterpret_cast<getter>(Matrix4x4_get_M34), nullptr, nullptr, nullptr },
        { "m41", reinterpret_cast<getter>(Matrix4x4_get_M41), nullptr, nullptr, nullptr },
        { "m42", reinterpret_cast<getter>(Matrix4x4_get_M42), nullptr, nullptr, nullptr },
        { "m43", reinterpret_cast<getter>(Matrix4x4_get_M43), nullptr, nullptr, nullptr },
        { "m44", reinterpret_cast<getter>(Matrix4x4_get_M44), nullptr, nullptr, nullptr },
        { }};

    static PyObject* _add_Matrix4x4(PyObject* left, PyObject* right) noexcept
    {
        try
        {
            auto _left = py::convert_to<winrt::Windows::Foundation::Numerics::float4x4>(left);
            auto _right = py::convert_to<winrt::Windows::Foundation::Numerics::float4x4>(right);

            auto _result = _left + _right;
            return py::convert(_result);
        }
        catch (...)
        {
            py::to_PyErr();

            if (PyErr_ExceptionMatches(PyExc_TypeError))
            {
                PyErr_Clear();
                Py_RETURN_NOTIMPLEMENTED;
            }

            return nullptr;
        }
    }

    static PyObject* _sub_Matrix4x4(PyObject* left, PyObject* right) noexcept
    {
        try
        {
            auto _left = py::convert_to<winrt::Windows::Foundation::Numerics::float4x4>(left);
            auto _right = py::convert_to<winrt::Windows::Foundation::Numerics::float4x4>(right);

            auto _result = _left - _right;
            return py::convert(_result);
        }
        catch (...)
        {
            py::to_PyErr();

            if (PyErr_ExceptionMatches(PyExc_TypeError))
            {
                PyErr_Clear();
                Py_RETURN_NOTIMPLEMENTED;
            }

            return nullptr;
        }
    }

    static PyObject* _mul_Matrix4x4(PyObject* left, PyObject* right) noexcept
    {
        try
        {
            auto _left = py::convert_to<winrt::Windows::Foundation::Numerics::float4x4>(left);

            py::pyobj_handle right_float{PyNumber_Float(right)};
            if (right_float)
            {
                auto _right_float = PyFloat_AsDouble(right_float.get());
                if (_right_float == -1 && PyErr_Occurred())
                {
                    return nullptr;
                }

                auto _result = _left * static_cast<float>(_right_float);
                return py::convert(_result);
            }
            else
            {
                PyErr_Clear();
            }

            auto _right = py::convert_to<winrt::Windows::Foundation::Numerics::float4x4>(right);

            auto _result = _left * _right;
            return py::convert(_result);
        }
        catch (...)
        {
            py::to_PyErr();

            if (PyErr_ExceptionMatches(PyExc_TypeError))
            {
                PyErr_Clear();
                Py_RETURN_NOTIMPLEMENTED;
            }

            return nullptr;
        }
    }

    static PyObject* _neg_Matrix4x4(PyObject* operand) noexcept
    {
        try
        {
            auto _operand = py::convert_to<winrt::Windows::Foundation::Numerics::float4x4>(operand);
            auto _result = -_operand;
            return py::convert(_result);
        }
        catch (...)
        {
            py::to_PyErr();

            if (PyErr_ExceptionMatches(PyExc_TypeError))
            {
                PyErr_Clear();
                Py_RETURN_NOTIMPLEMENTED;
            }

            return nullptr;
        }
    }

    static PyObject* _richcompare_Matrix4x4(py::wrapper::Windows::Foundation::Numerics::Matrix4x4* self, PyObject* other, int op) noexcept
    {
        try
        {
            auto _other = py::convert_to<winrt::Windows::Foundation::Numerics::float4x4>(other);

            if (op == Py_EQ)
            {
                if (self->obj == _other)
                {
                    Py_RETURN_TRUE;
                }

                Py_RETURN_FALSE;
            }

            if (op == Py_NE)
            {
                if (self->obj != _other)
                {
                    Py_RETURN_TRUE;
                }

                Py_RETURN_FALSE;
            }

            Py_RETURN_NOTIMPLEMENTED;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _repr_Matrix4x4(PyObject* self) noexcept
    {
        py::pyobj_handle M11{PyObject_GetAttrString(self, "m11")};
        if (!M11)
        {
            return nullptr;
        }

        py::pyobj_handle M12{PyObject_GetAttrString(self, "m12")};
        if (!M12)
        {
            return nullptr;
        }

        py::pyobj_handle M13{PyObject_GetAttrString(self, "m13")};
        if (!M13)
        {
            return nullptr;
        }

        py::pyobj_handle M14{PyObject_GetAttrString(self, "m14")};
        if (!M14)
        {
            return nullptr;
        }

        py::pyobj_handle M21{PyObject_GetAttrString(self, "m21")};
        if (!M21)
        {
            return nullptr;
        }

        py::pyobj_handle M22{PyObject_GetAttrString(self, "m22")};
        if (!M22)
        {
            return nullptr;
        }

        py::pyobj_handle M23{PyObject_GetAttrString(self, "m23")};
        if (!M23)
        {
            return nullptr;
        }

        py::pyobj_handle M24{PyObject_GetAttrString(self, "m24")};
        if (!M24)
        {
            return nullptr;
        }

        py::pyobj_handle M31{PyObject_GetAttrString(self, "m31")};
        if (!M31)
        {
            return nullptr;
        }

        py::pyobj_handle M32{PyObject_GetAttrString(self, "m32")};
        if (!M32)
        {
            return nullptr;
        }

        py::pyobj_handle M33{PyObject_GetAttrString(self, "m33")};
        if (!M33)
        {
            return nullptr;
        }

        py::pyobj_handle M34{PyObject_GetAttrString(self, "m34")};
        if (!M34)
        {
            return nullptr;
        }

        py::pyobj_handle M41{PyObject_GetAttrString(self, "m41")};
        if (!M41)
        {
            return nullptr;
        }

        py::pyobj_handle M42{PyObject_GetAttrString(self, "m42")};
        if (!M42)
        {
            return nullptr;
        }

        py::pyobj_handle M43{PyObject_GetAttrString(self, "m43")};
        if (!M43)
        {
            return nullptr;
        }

        py::pyobj_handle M44{PyObject_GetAttrString(self, "m44")};
        if (!M44)
        {
            return nullptr;
        }

        return PyUnicode_FromFormat("Matrix4x4(m11=%R, m12=%R, m13=%R, m14=%R, m21=%R, m22=%R, m23=%R, m24=%R, m31=%R, m32=%R, m33=%R, m34=%R, m41=%R, m42=%R, m43=%R, m44=%R)", M11.get(), M12.get(), M13.get(), M14.get(), M21.get(), M22.get(), M23.get(), M24.get(), M31.get(), M32.get(), M33.get(), M34.get(), M41.get(), M42.get(), M43.get(), M44.get());
    }

    static PyType_Slot _type_slots_Matrix4x4[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_Matrix4x4) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_Matrix4x4) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_Matrix4x4) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_Matrix4x4) },
        { Py_nb_add, reinterpret_cast<void*>(_add_Matrix4x4) },
        { Py_nb_subtract, reinterpret_cast<void*>(_sub_Matrix4x4) },
        { Py_nb_multiply, reinterpret_cast<void*>(_mul_Matrix4x4) },
        { Py_nb_negative, reinterpret_cast<void*>(_neg_Matrix4x4) },
        { Py_tp_richcompare, reinterpret_cast<void*>(_richcompare_Matrix4x4) },
        { Py_tp_repr, reinterpret_cast<void*>(_repr_Matrix4x4) },
        { }};

    static PyType_Spec type_spec_Matrix4x4 = {
        "winrt._winrt_windows_foundation_numerics.Matrix4x4",
        sizeof(py::wrapper::Windows::Foundation::Numerics::Matrix4x4),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_Matrix4x4};

    static PyGetSetDef getset_Matrix4x4_Static[] = {
        { "identity", _get_identity_Matrix4x4, nullptr, nullptr, nullptr },
        { }};

    static PyMethodDef methods_Matrix4x4_Static[] = {
        { "make_billboard", make_billboard_Matrix4x4, METH_VARARGS, nullptr },
        { "make_constrained_billboard", make_constrained_billboard_Matrix4x4, METH_VARARGS, nullptr },
        { "make_translation", make_translation_Matrix4x4, METH_VARARGS, nullptr },
        { "make_scale", make_scale_Matrix4x4, METH_VARARGS, nullptr },
        { "make_scale_from_vector", make_scale_from_vector_Matrix4x4, METH_VARARGS, nullptr },
        { "make_scale_from_scalar", make_scale_from_scalar_Matrix4x4, METH_VARARGS, nullptr },
        { "make_rotation_x", make_rotation_x_Matrix4x4, METH_VARARGS, nullptr },
        { "make_rotation_y", make_rotation_y_Matrix4x4, METH_VARARGS, nullptr },
        { "make_rotation_z", make_rotation_z_Matrix4x4, METH_VARARGS, nullptr },
        { "make_from_axis_angle", make_from_axis_angle_Matrix4x4, METH_VARARGS, nullptr },
        { "make_perspective_field_of_view", make_perspective_field_of_view_Matrix4x4, METH_VARARGS, nullptr },
        { "make_perspective", make_perspective_Matrix4x4, METH_VARARGS, nullptr },
        { "make_perspective_off_center", make_perspective_off_center_Matrix4x4, METH_VARARGS, nullptr },
        { "make_orthographic", make_orthographic_Matrix4x4, METH_VARARGS, nullptr },
        { "make_orthographic_off_center", make_orthographic_off_center_Matrix4x4, METH_VARARGS, nullptr },
        { "make_look_at", make_look_at_Matrix4x4, METH_VARARGS, nullptr },
        { "make_world", make_world_Matrix4x4, METH_VARARGS, nullptr },
        { "make_from_quaternion", make_from_quaternion_Matrix4x4, METH_VARARGS, nullptr },
        { "make_from_yaw_pitch_roll", make_from_yaw_pitch_roll_Matrix4x4, METH_VARARGS, nullptr },
        { "make_shadow", make_shadow_Matrix4x4, METH_VARARGS, nullptr },
        { "make_reflection", make_reflection_Matrix4x4, METH_VARARGS, nullptr },
        { }};

    static PyType_Slot type_slots_Matrix4x4_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_Matrix4x4_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_Matrix4x4_Static) },
        { }
    };

    static PyType_Spec type_spec_Matrix4x4_Static = {
        "winrt._winrt_windows_foundation_numerics.Matrix4x4_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_Matrix4x4_Static};

    // ----- Plane struct --------------------

    winrt::Windows::Foundation::Numerics::plane Plane_from_tuple(PyObject* tuple)
    {
        if (PyTuple_GET_SIZE(tuple) != 2)
        {
            PyErr_SetString(PyExc_TypeError, "Incorrect number of fields");
            throw python_exception();
        }

        winrt::Windows::Foundation::Numerics::plane result{};

        result.normal = py::convert_to<winrt::Windows::Foundation::Numerics::float3>(tuple, 0);
        result.d = py::convert_to<float>(tuple, 1);

        return result;
    }

    PyObject* _new_Plane(PyTypeObject* subclass, PyObject* args, PyObject* kwds) noexcept
    {
        pyobj_handle self_obj{(subclass->tp_alloc(subclass, 0))};
        if (!self_obj)
        {
            return nullptr;
        }

        auto self = reinterpret_cast<winrt_struct_wrapper<winrt::Windows::Foundation::Numerics::plane>*>(self_obj.get());
        std::construct_at(&self->obj);

        auto tuple_size = PyTuple_GET_SIZE(args);
        if ((tuple_size == 0) && (!kwds))
        {
            return self_obj.detach();
        }

        PyObject* _Normal{};
        float _D{};

        static const char* kwlist[] = {"normal", "d", nullptr};
        if (!PyArg_ParseTupleAndKeywords(args, kwds, "|Of", const_cast<char**>(kwlist), &_Normal, &_D))
        {
            return nullptr;
        }

        try
        {
            self->obj.normal = _Normal ? py::convert_to<winrt::Windows::Foundation::Numerics::float3>(_Normal) : winrt::Windows::Foundation::Numerics::float3{};
            self->obj.d = _D;

            return self_obj.detach();
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static void _dealloc_Plane(py::wrapper::Windows::Foundation::Numerics::Plane* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* make_from_vertices_Plane(PyObject* /*unused*/, PyObject* args) noexcept
    {
        try
        {
            auto n_args = PyTuple_GET_SIZE(args);

            if (n_args == 3)
            {
#if defined(__MINGW32__)
                (void)args;
                PyErr_SetString(PyExc_NotImplementedError, "Overload with 3 args is not implemented on MinGW");
                return nullptr;
#else
                auto _arg0 = py::convert_to<winrt::Windows::Foundation::Numerics::float3>(args, 0);
                auto _arg1 = py::convert_to<winrt::Windows::Foundation::Numerics::float3>(args, 1);
                auto _arg2 = py::convert_to<winrt::Windows::Foundation::Numerics::float3>(args, 2);
                auto _result = winrt::Windows::Foundation::Numerics::make_plane_from_vertices(_arg0, _arg1, _arg2);
                return py::convert(_result);
#endif
            }

            PyErr_Format(PyExc_TypeError, "No overload take %d args.", n_args);
            return nullptr;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* normalize_Plane(winrt_struct_wrapper<winrt::Windows::Foundation::Numerics::plane>* self, PyObject* /*unused*/) noexcept
    {
        try
        {
            auto _result = winrt::Windows::Foundation::Numerics::normalize(self->obj);
            return py::convert(_result);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* transform_Plane(winrt_struct_wrapper<winrt::Windows::Foundation::Numerics::plane>* self, PyObject* arg) noexcept
    {
        try
        {
            if (std::string_view(Py_TYPE(arg)->tp_name) == "Matrix4x4" || std::string_view(Py_TYPE(arg)->tp_name) == "winrt._winrt_windows_foundation_numerics.Matrix4x4")
            {
#if defined(__MINGW32__)
                PyErr_SetString(PyExc_NotImplementedError, "Overload for Matrix4x4 is not implemented on MinGW");
                return nullptr;
#else
                auto _arg = py::convert_to<winrt::Windows::Foundation::Numerics::float4x4>(arg);
                auto _result = winrt::Windows::Foundation::Numerics::transform(self->obj, _arg);
                return py::convert(_result);
#endif
            }

            if (std::string_view(Py_TYPE(arg)->tp_name) == "Quaternion" || std::string_view(Py_TYPE(arg)->tp_name) == "winrt._winrt_windows_foundation_numerics.Quaternion")
            {
                auto _arg = py::convert_to<winrt::Windows::Foundation::Numerics::quaternion>(arg);
                auto _result = winrt::Windows::Foundation::Numerics::transform(self->obj, _arg);
                return py::convert(_result);
            }

            PyErr_Format(PyExc_TypeError, "Expecting one of 'winrt._winrt_windows_foundation_numerics.Matrix4x4', 'winrt._winrt_windows_foundation_numerics.Quaternion' but got '%s'", Py_TYPE(arg)->tp_name);
            return nullptr;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* dot_Plane(winrt_struct_wrapper<winrt::Windows::Foundation::Numerics::plane>* self, PyObject* arg) noexcept
    {
        try
        {
#if defined(__MINGW32__)
            (void)self;
            (void)arg;
            PyErr_SetString(PyExc_NotImplementedError, "This method is not implemented on MinGW");
            return nullptr;
#else
            auto _arg = py::convert_to<winrt::Windows::Foundation::Numerics::float4>(arg);
            auto _result = winrt::Windows::Foundation::Numerics::dot(self->obj, _arg);
            return py::convert(_result);
#endif
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* dot_coordinate_Plane(winrt_struct_wrapper<winrt::Windows::Foundation::Numerics::plane>* self, PyObject* arg) noexcept
    {
        try
        {
#if defined(__MINGW32__)
            (void)self;
            (void)arg;
            PyErr_SetString(PyExc_NotImplementedError, "This method is not implemented on MinGW");
            return nullptr;
#else
            auto _arg = py::convert_to<winrt::Windows::Foundation::Numerics::float3>(arg);
            auto _result = winrt::Windows::Foundation::Numerics::dot_coordinate(self->obj, _arg);
            return py::convert(_result);
#endif
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* dot_normal_Plane(winrt_struct_wrapper<winrt::Windows::Foundation::Numerics::plane>* self, PyObject* arg) noexcept
    {
        try
        {
#if defined(__MINGW32__)
            (void)self;
            (void)arg;
            PyErr_SetString(PyExc_NotImplementedError, "This method is not implemented on MinGW");
            return nullptr;
#else
            auto _arg = py::convert_to<winrt::Windows::Foundation::Numerics::float3>(arg);
            auto _result = winrt::Windows::Foundation::Numerics::dot_normal(self->obj, _arg);
            return py::convert(_result);
#endif
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_Plane(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Foundation::Numerics::plane>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    PyObject* _replace_Plane(py::wrapper::Windows::Foundation::Numerics::Plane* self, PyObject* args, PyObject* kwds) noexcept
    {
        try
        {
            PyObject* _Normal{};
            float _D{self->obj.d};

            static const char* kwlist[] = {"normal", "d", nullptr};
            if (!PyArg_ParseTupleAndKeywords(args, kwds, "|$Of", const_cast<char**>(kwlist), &_Normal, &_D))
            {
                return nullptr;
            }

            auto copy = self->obj;
            copy.normal = _Normal ? py::convert_to<winrt::Windows::Foundation::Numerics::float3>(_Normal) : self->obj.normal;
            copy.d = _D;

            return convert(copy);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    PyObject* unpack_Plane(py::wrapper::Windows::Foundation::Numerics::Plane* self, PyObject* /*unused*/) noexcept
    {
        py::pyobj_handle Normal{convert(self->obj.normal)};
        if (!Normal)
        {
            return nullptr;
        }

        py::pyobj_handle D{convert(self->obj.d)};
        if (!D)
        {
            return nullptr;
        }

        pyobj_handle tuple{PyTuple_New(2)};
        if (!tuple)
        {
            return nullptr;
        }

        PyTuple_SET_ITEM(tuple.get(), 0, Normal.detach());
        PyTuple_SET_ITEM(tuple.get(), 1, D.detach());

        return tuple.detach();
    }

    static PyMethodDef _methods_Plane[] = {
        { "normalize", reinterpret_cast<PyCFunction>(normalize_Plane), METH_NOARGS, nullptr },
        { "transform", reinterpret_cast<PyCFunction>(transform_Plane), METH_O, nullptr },
        { "dot", reinterpret_cast<PyCFunction>(dot_Plane), METH_O, nullptr },
        { "dot_coordinate", reinterpret_cast<PyCFunction>(dot_coordinate_Plane), METH_O, nullptr },
        { "dot_normal", reinterpret_cast<PyCFunction>(dot_normal_Plane), METH_O, nullptr },
        { "_assign_array_", _assign_array_Plane, METH_O | METH_STATIC, nullptr },
        { "__replace__", reinterpret_cast<PyCFunction>(reinterpret_cast<void*>(_replace_Plane)), METH_VARARGS | METH_KEYWORDS, nullptr },
        { "unpack", reinterpret_cast<PyCFunction>(unpack_Plane), METH_NOARGS, nullptr },
        { }};

    static PyObject* Plane_get_Normal(py::wrapper::Windows::Foundation::Numerics::Plane* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.normal);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Plane_get_D(py::wrapper::Windows::Foundation::Numerics::Plane* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.d);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyGetSetDef _getset_Plane[] = {
        { "normal", reinterpret_cast<getter>(Plane_get_Normal), nullptr, nullptr, nullptr },
        { "d", reinterpret_cast<getter>(Plane_get_D), nullptr, nullptr, nullptr },
        { }};

    static PyObject* _richcompare_Plane(py::wrapper::Windows::Foundation::Numerics::Plane* self, PyObject* other, int op) noexcept
    {
        try
        {
            auto _other = py::convert_to<winrt::Windows::Foundation::Numerics::plane>(other);

            if (op == Py_EQ)
            {
                if (self->obj == _other)
                {
                    Py_RETURN_TRUE;
                }

                Py_RETURN_FALSE;
            }

            if (op == Py_NE)
            {
                if (self->obj != _other)
                {
                    Py_RETURN_TRUE;
                }

                Py_RETURN_FALSE;
            }

            Py_RETURN_NOTIMPLEMENTED;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _repr_Plane(PyObject* self) noexcept
    {
        py::pyobj_handle Normal{PyObject_GetAttrString(self, "normal")};
        if (!Normal)
        {
            return nullptr;
        }

        py::pyobj_handle D{PyObject_GetAttrString(self, "d")};
        if (!D)
        {
            return nullptr;
        }

        return PyUnicode_FromFormat("Plane(normal=%R, d=%R)", Normal.get(), D.get());
    }

    static PyType_Slot _type_slots_Plane[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_Plane) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_Plane) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_Plane) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_Plane) },
        { Py_tp_richcompare, reinterpret_cast<void*>(_richcompare_Plane) },
        { Py_tp_repr, reinterpret_cast<void*>(_repr_Plane) },
        { }};

    static PyType_Spec type_spec_Plane = {
        "winrt._winrt_windows_foundation_numerics.Plane",
        sizeof(py::wrapper::Windows::Foundation::Numerics::Plane),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_Plane};

    static PyGetSetDef getset_Plane_Static[] = {
        { }};

    static PyMethodDef methods_Plane_Static[] = {
        { "make_from_vertices", make_from_vertices_Plane, METH_VARARGS, nullptr },
        { }};

    static PyType_Slot type_slots_Plane_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_Plane_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_Plane_Static) },
        { }
    };

    static PyType_Spec type_spec_Plane_Static = {
        "winrt._winrt_windows_foundation_numerics.Plane_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_Plane_Static};

    // ----- Quaternion struct --------------------

    winrt::Windows::Foundation::Numerics::quaternion Quaternion_from_tuple(PyObject* tuple)
    {
        if (PyTuple_GET_SIZE(tuple) != 4)
        {
            PyErr_SetString(PyExc_TypeError, "Incorrect number of fields");
            throw python_exception();
        }

        winrt::Windows::Foundation::Numerics::quaternion result{};

        result.x = py::convert_to<float>(tuple, 0);
        result.y = py::convert_to<float>(tuple, 1);
        result.z = py::convert_to<float>(tuple, 2);
        result.w = py::convert_to<float>(tuple, 3);

        return result;
    }

    PyObject* _new_Quaternion(PyTypeObject* subclass, PyObject* args, PyObject* kwds) noexcept
    {
        pyobj_handle self_obj{(subclass->tp_alloc(subclass, 0))};
        if (!self_obj)
        {
            return nullptr;
        }

        auto self = reinterpret_cast<winrt_struct_wrapper<winrt::Windows::Foundation::Numerics::quaternion>*>(self_obj.get());
        std::construct_at(&self->obj);

        auto tuple_size = PyTuple_GET_SIZE(args);
        if ((tuple_size == 0) && (!kwds))
        {
            return self_obj.detach();
        }

        float _X{};
        float _Y{};
        float _Z{};
        float _W{};

        static const char* kwlist[] = {"x", "y", "z", "w", nullptr};
        if (!PyArg_ParseTupleAndKeywords(args, kwds, "|ffff", const_cast<char**>(kwlist), &_X, &_Y, &_Z, &_W))
        {
            return nullptr;
        }

        try
        {
            self->obj.x = _X;
            self->obj.y = _Y;
            self->obj.z = _Z;
            self->obj.w = _W;

            return self_obj.detach();
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static void _dealloc_Quaternion(py::wrapper::Windows::Foundation::Numerics::Quaternion* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* make_from_axis_angle_Quaternion(PyObject* /*unused*/, PyObject* args) noexcept
    {
        try
        {
            auto n_args = PyTuple_GET_SIZE(args);

            if (n_args == 2)
            {
                auto _arg0 = py::convert_to<winrt::Windows::Foundation::Numerics::float3>(args, 0);
                auto _arg1 = py::convert_to<float>(args, 1);
                auto _result = winrt::Windows::Foundation::Numerics::make_quaternion_from_axis_angle(_arg0, _arg1);
                return py::convert(_result);
            }

            PyErr_Format(PyExc_TypeError, "No overload take %d args.", n_args);
            return nullptr;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* make_from_yaw_pitch_roll_Quaternion(PyObject* /*unused*/, PyObject* args) noexcept
    {
        try
        {
            auto n_args = PyTuple_GET_SIZE(args);

            if (n_args == 3)
            {
                auto _arg0 = py::convert_to<float>(args, 0);
                auto _arg1 = py::convert_to<float>(args, 1);
                auto _arg2 = py::convert_to<float>(args, 2);
                auto _result = winrt::Windows::Foundation::Numerics::make_quaternion_from_yaw_pitch_roll(_arg0, _arg1, _arg2);
                return py::convert(_result);
            }

            PyErr_Format(PyExc_TypeError, "No overload take %d args.", n_args);
            return nullptr;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* make_from_rotation_matrix_Quaternion(PyObject* /*unused*/, PyObject* args) noexcept
    {
        try
        {
            auto n_args = PyTuple_GET_SIZE(args);

            if (n_args == 1)
            {
                auto _arg0 = py::convert_to<winrt::Windows::Foundation::Numerics::float4x4>(args, 0);
                auto _result = winrt::Windows::Foundation::Numerics::make_quaternion_from_rotation_matrix(_arg0);
                return py::convert(_result);
            }

            PyErr_Format(PyExc_TypeError, "No overload take %d args.", n_args);
            return nullptr;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _get_identity_Quaternion(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        return py::convert(winrt::Windows::Foundation::Numerics::quaternion::identity());
    }

    static PyObject* is_identity_Quaternion(winrt_struct_wrapper<winrt::Windows::Foundation::Numerics::quaternion>* self, PyObject* /*unused*/) noexcept
    {
        try
        {
            auto _result = winrt::Windows::Foundation::Numerics::is_identity(self->obj);
            return py::convert(_result);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* length_Quaternion(winrt_struct_wrapper<winrt::Windows::Foundation::Numerics::quaternion>* self, PyObject* /*unused*/) noexcept
    {
        try
        {
            auto _result = winrt::Windows::Foundation::Numerics::length(self->obj);
            return py::convert(_result);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* length_squared_Quaternion(winrt_struct_wrapper<winrt::Windows::Foundation::Numerics::quaternion>* self, PyObject* /*unused*/) noexcept
    {
        try
        {
            auto _result = winrt::Windows::Foundation::Numerics::length_squared(self->obj);
            return py::convert(_result);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* dot_Quaternion(winrt_struct_wrapper<winrt::Windows::Foundation::Numerics::quaternion>* self, PyObject* arg) noexcept
    {
        try
        {
            auto _arg = py::convert_to<winrt::Windows::Foundation::Numerics::quaternion>(arg);
            auto _result = winrt::Windows::Foundation::Numerics::dot(self->obj, _arg);
            return py::convert(_result);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* normalize_Quaternion(winrt_struct_wrapper<winrt::Windows::Foundation::Numerics::quaternion>* self, PyObject* /*unused*/) noexcept
    {
        try
        {
            auto _result = winrt::Windows::Foundation::Numerics::normalize(self->obj);
            return py::convert(_result);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* conjugate_Quaternion(winrt_struct_wrapper<winrt::Windows::Foundation::Numerics::quaternion>* self, PyObject* /*unused*/) noexcept
    {
        try
        {
            auto _result = winrt::Windows::Foundation::Numerics::conjugate(self->obj);
            return py::convert(_result);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* inverse_Quaternion(winrt_struct_wrapper<winrt::Windows::Foundation::Numerics::quaternion>* self, PyObject* /*unused*/) noexcept
    {
        try
        {
            auto _result = winrt::Windows::Foundation::Numerics::inverse(self->obj);
            return py::convert(_result);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* slerp_Quaternion(winrt_struct_wrapper<winrt::Windows::Foundation::Numerics::quaternion>* self, PyObject* args) noexcept
    {
        try
        {
            auto _arg0 = py::convert_to<winrt::Windows::Foundation::Numerics::quaternion>(args, 0);
            auto _arg1 = py::convert_to<float>(args, 1);
            auto _result = winrt::Windows::Foundation::Numerics::slerp(self->obj, _arg0, _arg1);
            return py::convert(_result);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* lerp_Quaternion(winrt_struct_wrapper<winrt::Windows::Foundation::Numerics::quaternion>* self, PyObject* args) noexcept
    {
        try
        {
            auto _arg0 = py::convert_to<winrt::Windows::Foundation::Numerics::quaternion>(args, 0);
            auto _arg1 = py::convert_to<float>(args, 1);
            auto _result = winrt::Windows::Foundation::Numerics::lerp(self->obj, _arg0, _arg1);
            return py::convert(_result);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* concatenate_Quaternion(winrt_struct_wrapper<winrt::Windows::Foundation::Numerics::quaternion>* self, PyObject* arg) noexcept
    {
        try
        {
            auto _arg = py::convert_to<winrt::Windows::Foundation::Numerics::quaternion>(arg);
            auto _result = winrt::Windows::Foundation::Numerics::concatenate(self->obj, _arg);
            return py::convert(_result);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_Quaternion(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Foundation::Numerics::quaternion>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    PyObject* _replace_Quaternion(py::wrapper::Windows::Foundation::Numerics::Quaternion* self, PyObject* args, PyObject* kwds) noexcept
    {
        try
        {
            float _X{self->obj.x};
            float _Y{self->obj.y};
            float _Z{self->obj.z};
            float _W{self->obj.w};

            static const char* kwlist[] = {"x", "y", "z", "w", nullptr};
            if (!PyArg_ParseTupleAndKeywords(args, kwds, "|$ffff", const_cast<char**>(kwlist), &_X, &_Y, &_Z, &_W))
            {
                return nullptr;
            }

            auto copy = self->obj;
            copy.x = _X;
            copy.y = _Y;
            copy.z = _Z;
            copy.w = _W;

            return convert(copy);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    PyObject* unpack_Quaternion(py::wrapper::Windows::Foundation::Numerics::Quaternion* self, PyObject* /*unused*/) noexcept
    {
        py::pyobj_handle X{convert(self->obj.x)};
        if (!X)
        {
            return nullptr;
        }

        py::pyobj_handle Y{convert(self->obj.y)};
        if (!Y)
        {
            return nullptr;
        }

        py::pyobj_handle Z{convert(self->obj.z)};
        if (!Z)
        {
            return nullptr;
        }

        py::pyobj_handle W{convert(self->obj.w)};
        if (!W)
        {
            return nullptr;
        }

        pyobj_handle tuple{PyTuple_New(4)};
        if (!tuple)
        {
            return nullptr;
        }

        PyTuple_SET_ITEM(tuple.get(), 0, X.detach());
        PyTuple_SET_ITEM(tuple.get(), 1, Y.detach());
        PyTuple_SET_ITEM(tuple.get(), 2, Z.detach());
        PyTuple_SET_ITEM(tuple.get(), 3, W.detach());

        return tuple.detach();
    }

    static PyMethodDef _methods_Quaternion[] = {
        { "is_identity", reinterpret_cast<PyCFunction>(is_identity_Quaternion), METH_NOARGS, nullptr },
        { "length", reinterpret_cast<PyCFunction>(length_Quaternion), METH_NOARGS, nullptr },
        { "length_squared", reinterpret_cast<PyCFunction>(length_squared_Quaternion), METH_NOARGS, nullptr },
        { "dot", reinterpret_cast<PyCFunction>(dot_Quaternion), METH_O, nullptr },
        { "normalize", reinterpret_cast<PyCFunction>(normalize_Quaternion), METH_NOARGS, nullptr },
        { "conjugate", reinterpret_cast<PyCFunction>(conjugate_Quaternion), METH_NOARGS, nullptr },
        { "inverse", reinterpret_cast<PyCFunction>(inverse_Quaternion), METH_NOARGS, nullptr },
        { "slerp", reinterpret_cast<PyCFunction>(slerp_Quaternion), METH_VARARGS, nullptr },
        { "lerp", reinterpret_cast<PyCFunction>(lerp_Quaternion), METH_VARARGS, nullptr },
        { "concatenate", reinterpret_cast<PyCFunction>(concatenate_Quaternion), METH_O, nullptr },
        { "_assign_array_", _assign_array_Quaternion, METH_O | METH_STATIC, nullptr },
        { "__replace__", reinterpret_cast<PyCFunction>(reinterpret_cast<void*>(_replace_Quaternion)), METH_VARARGS | METH_KEYWORDS, nullptr },
        { "unpack", reinterpret_cast<PyCFunction>(unpack_Quaternion), METH_NOARGS, nullptr },
        { }};

    static PyObject* Quaternion_get_X(py::wrapper::Windows::Foundation::Numerics::Quaternion* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.x);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Quaternion_get_Y(py::wrapper::Windows::Foundation::Numerics::Quaternion* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.y);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Quaternion_get_Z(py::wrapper::Windows::Foundation::Numerics::Quaternion* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.z);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Quaternion_get_W(py::wrapper::Windows::Foundation::Numerics::Quaternion* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.w);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyGetSetDef _getset_Quaternion[] = {
        { "x", reinterpret_cast<getter>(Quaternion_get_X), nullptr, nullptr, nullptr },
        { "y", reinterpret_cast<getter>(Quaternion_get_Y), nullptr, nullptr, nullptr },
        { "z", reinterpret_cast<getter>(Quaternion_get_Z), nullptr, nullptr, nullptr },
        { "w", reinterpret_cast<getter>(Quaternion_get_W), nullptr, nullptr, nullptr },
        { }};

    static PyObject* _add_Quaternion(PyObject* left, PyObject* right) noexcept
    {
        try
        {
            auto _left = py::convert_to<winrt::Windows::Foundation::Numerics::quaternion>(left);
            auto _right = py::convert_to<winrt::Windows::Foundation::Numerics::quaternion>(right);

            auto _result = _left + _right;
            return py::convert(_result);
        }
        catch (...)
        {
            py::to_PyErr();

            if (PyErr_ExceptionMatches(PyExc_TypeError))
            {
                PyErr_Clear();
                Py_RETURN_NOTIMPLEMENTED;
            }

            return nullptr;
        }
    }

    static PyObject* _sub_Quaternion(PyObject* left, PyObject* right) noexcept
    {
        try
        {
            auto _left = py::convert_to<winrt::Windows::Foundation::Numerics::quaternion>(left);
            auto _right = py::convert_to<winrt::Windows::Foundation::Numerics::quaternion>(right);

            auto _result = _left - _right;
            return py::convert(_result);
        }
        catch (...)
        {
            py::to_PyErr();

            if (PyErr_ExceptionMatches(PyExc_TypeError))
            {
                PyErr_Clear();
                Py_RETURN_NOTIMPLEMENTED;
            }

            return nullptr;
        }
    }

    static PyObject* _mul_Quaternion(PyObject* left, PyObject* right) noexcept
    {
        try
        {
            auto _left = py::convert_to<winrt::Windows::Foundation::Numerics::quaternion>(left);

            py::pyobj_handle right_float{PyNumber_Float(right)};
            if (right_float)
            {
                auto _right_float = PyFloat_AsDouble(right_float.get());
                if (_right_float == -1 && PyErr_Occurred())
                {
                    return nullptr;
                }

                auto _result = _left * static_cast<float>(_right_float);
                return py::convert(_result);
            }
            else
            {
                PyErr_Clear();
            }

            auto _right = py::convert_to<winrt::Windows::Foundation::Numerics::quaternion>(right);

            auto _result = _left * _right;
            return py::convert(_result);
        }
        catch (...)
        {
            py::to_PyErr();

            if (PyErr_ExceptionMatches(PyExc_TypeError))
            {
                PyErr_Clear();
                Py_RETURN_NOTIMPLEMENTED;
            }

            return nullptr;
        }
    }

    static PyObject* _truediv_Quaternion(PyObject* left, PyObject* right) noexcept
    {
        try
        {
            auto _left = py::convert_to<winrt::Windows::Foundation::Numerics::quaternion>(left);
            auto _right = py::convert_to<winrt::Windows::Foundation::Numerics::quaternion>(right);

            auto _result = _left / _right;
            return py::convert(_result);
        }
        catch (...)
        {
            py::to_PyErr();

            if (PyErr_ExceptionMatches(PyExc_TypeError))
            {
                PyErr_Clear();
                Py_RETURN_NOTIMPLEMENTED;
            }

            return nullptr;
        }
    }

    static PyObject* _neg_Quaternion(PyObject* operand) noexcept
    {
        try
        {
            auto _operand = py::convert_to<winrt::Windows::Foundation::Numerics::quaternion>(operand);
            auto _result = -_operand;
            return py::convert(_result);
        }
        catch (...)
        {
            py::to_PyErr();

            if (PyErr_ExceptionMatches(PyExc_TypeError))
            {
                PyErr_Clear();
                Py_RETURN_NOTIMPLEMENTED;
            }

            return nullptr;
        }
    }

    static PyObject* _abs_Quaternion(PyObject* operand) noexcept
    {
        try
        {
            auto _operand = py::convert_to<winrt::Windows::Foundation::Numerics::quaternion>(operand);
            auto _result = winrt::Windows::Foundation::Numerics::length(_operand);
            return py::convert(_result);
        }
        catch (...)
        {
            py::to_PyErr();

            if (PyErr_ExceptionMatches(PyExc_TypeError))
            {
                PyErr_Clear();
                Py_RETURN_NOTIMPLEMENTED;
            }

            return nullptr;
        }
    }

    static PyObject* _richcompare_Quaternion(py::wrapper::Windows::Foundation::Numerics::Quaternion* self, PyObject* other, int op) noexcept
    {
        try
        {
            auto _other = py::convert_to<winrt::Windows::Foundation::Numerics::quaternion>(other);

            if (op == Py_EQ)
            {
                if (self->obj == _other)
                {
                    Py_RETURN_TRUE;
                }

                Py_RETURN_FALSE;
            }

            if (op == Py_NE)
            {
                if (self->obj != _other)
                {
                    Py_RETURN_TRUE;
                }

                Py_RETURN_FALSE;
            }

            Py_RETURN_NOTIMPLEMENTED;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _repr_Quaternion(PyObject* self) noexcept
    {
        py::pyobj_handle X{PyObject_GetAttrString(self, "x")};
        if (!X)
        {
            return nullptr;
        }

        py::pyobj_handle Y{PyObject_GetAttrString(self, "y")};
        if (!Y)
        {
            return nullptr;
        }

        py::pyobj_handle Z{PyObject_GetAttrString(self, "z")};
        if (!Z)
        {
            return nullptr;
        }

        py::pyobj_handle W{PyObject_GetAttrString(self, "w")};
        if (!W)
        {
            return nullptr;
        }

        return PyUnicode_FromFormat("Quaternion(x=%R, y=%R, z=%R, w=%R)", X.get(), Y.get(), Z.get(), W.get());
    }

    static PyType_Slot _type_slots_Quaternion[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_Quaternion) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_Quaternion) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_Quaternion) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_Quaternion) },
        { Py_nb_add, reinterpret_cast<void*>(_add_Quaternion) },
        { Py_nb_subtract, reinterpret_cast<void*>(_sub_Quaternion) },
        { Py_nb_multiply, reinterpret_cast<void*>(_mul_Quaternion) },
        { Py_nb_true_divide, reinterpret_cast<void*>(_truediv_Quaternion) },
        { Py_nb_negative, reinterpret_cast<void*>(_neg_Quaternion) },
        { Py_nb_absolute, reinterpret_cast<void*>(_abs_Quaternion) },
        { Py_tp_richcompare, reinterpret_cast<void*>(_richcompare_Quaternion) },
        { Py_tp_repr, reinterpret_cast<void*>(_repr_Quaternion) },
        { }};

    static PyType_Spec type_spec_Quaternion = {
        "winrt._winrt_windows_foundation_numerics.Quaternion",
        sizeof(py::wrapper::Windows::Foundation::Numerics::Quaternion),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_Quaternion};

    static PyGetSetDef getset_Quaternion_Static[] = {
        { "identity", _get_identity_Quaternion, nullptr, nullptr, nullptr },
        { }};

    static PyMethodDef methods_Quaternion_Static[] = {
        { "make_from_axis_angle", make_from_axis_angle_Quaternion, METH_VARARGS, nullptr },
        { "make_from_yaw_pitch_roll", make_from_yaw_pitch_roll_Quaternion, METH_VARARGS, nullptr },
        { "make_from_rotation_matrix", make_from_rotation_matrix_Quaternion, METH_VARARGS, nullptr },
        { }};

    static PyType_Slot type_slots_Quaternion_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_Quaternion_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_Quaternion_Static) },
        { }
    };

    static PyType_Spec type_spec_Quaternion_Static = {
        "winrt._winrt_windows_foundation_numerics.Quaternion_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_Quaternion_Static};

    // ----- Rational struct --------------------

    winrt::Windows::Foundation::Numerics::Rational Rational_from_tuple(PyObject* tuple)
    {
        if (PyTuple_GET_SIZE(tuple) != 2)
        {
            PyErr_SetString(PyExc_TypeError, "Incorrect number of fields");
            throw python_exception();
        }

        winrt::Windows::Foundation::Numerics::Rational result{};

        result.Numerator = py::convert_to<uint32_t>(tuple, 0);
        result.Denominator = py::convert_to<uint32_t>(tuple, 1);

        return result;
    }

    PyObject* _new_Rational(PyTypeObject* subclass, PyObject* args, PyObject* kwds) noexcept
    {
        pyobj_handle self_obj{(subclass->tp_alloc(subclass, 0))};
        if (!self_obj)
        {
            return nullptr;
        }

        auto self = reinterpret_cast<winrt_struct_wrapper<winrt::Windows::Foundation::Numerics::Rational>*>(self_obj.get());
        std::construct_at(&self->obj);

        auto tuple_size = PyTuple_GET_SIZE(args);
        if ((tuple_size == 0) && (!kwds))
        {
            return self_obj.detach();
        }

        uint32_t _Numerator{};
        uint32_t _Denominator{};

        static const char* kwlist[] = {"numerator", "denominator", nullptr};
        if (!PyArg_ParseTupleAndKeywords(args, kwds, "|II", const_cast<char**>(kwlist), &_Numerator, &_Denominator))
        {
            return nullptr;
        }

        try
        {
            self->obj.Numerator = _Numerator;
            self->obj.Denominator = _Denominator;

            return self_obj.detach();
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static void _dealloc_Rational(py::wrapper::Windows::Foundation::Numerics::Rational* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_Rational(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Foundation::Numerics::Rational>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    PyObject* _replace_Rational(py::wrapper::Windows::Foundation::Numerics::Rational* self, PyObject* args, PyObject* kwds) noexcept
    {
        try
        {
            uint32_t _Numerator{self->obj.Numerator};
            uint32_t _Denominator{self->obj.Denominator};

            static const char* kwlist[] = {"numerator", "denominator", nullptr};
            if (!PyArg_ParseTupleAndKeywords(args, kwds, "|$II", const_cast<char**>(kwlist), &_Numerator, &_Denominator))
            {
                return nullptr;
            }

            auto copy = self->obj;
            copy.Numerator = _Numerator;
            copy.Denominator = _Denominator;

            return convert(copy);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    PyObject* unpack_Rational(py::wrapper::Windows::Foundation::Numerics::Rational* self, PyObject* /*unused*/) noexcept
    {
        py::pyobj_handle Numerator{convert(self->obj.Numerator)};
        if (!Numerator)
        {
            return nullptr;
        }

        py::pyobj_handle Denominator{convert(self->obj.Denominator)};
        if (!Denominator)
        {
            return nullptr;
        }

        pyobj_handle tuple{PyTuple_New(2)};
        if (!tuple)
        {
            return nullptr;
        }

        PyTuple_SET_ITEM(tuple.get(), 0, Numerator.detach());
        PyTuple_SET_ITEM(tuple.get(), 1, Denominator.detach());

        return tuple.detach();
    }

    static PyMethodDef _methods_Rational[] = {
        { "_assign_array_", _assign_array_Rational, METH_O | METH_STATIC, nullptr },
        { "__replace__", reinterpret_cast<PyCFunction>(reinterpret_cast<void*>(_replace_Rational)), METH_VARARGS | METH_KEYWORDS, nullptr },
        { "unpack", reinterpret_cast<PyCFunction>(unpack_Rational), METH_NOARGS, nullptr },
        { }};

    static PyObject* Rational_get_Numerator(py::wrapper::Windows::Foundation::Numerics::Rational* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Numerator);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Rational_get_Denominator(py::wrapper::Windows::Foundation::Numerics::Rational* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Denominator);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyGetSetDef _getset_Rational[] = {
        { "numerator", reinterpret_cast<getter>(Rational_get_Numerator), nullptr, nullptr, nullptr },
        { "denominator", reinterpret_cast<getter>(Rational_get_Denominator), nullptr, nullptr, nullptr },
        { }};

    static PyObject* _richcompare_Rational(py::wrapper::Windows::Foundation::Numerics::Rational* self, PyObject* other, int op) noexcept
    {
        try
        {
            auto _other = py::convert_to<winrt::Windows::Foundation::Numerics::Rational>(other);

            if (op == Py_EQ)
            {
                if (self->obj == _other)
                {
                    Py_RETURN_TRUE;
                }

                Py_RETURN_FALSE;
            }

            if (op == Py_NE)
            {
                if (self->obj != _other)
                {
                    Py_RETURN_TRUE;
                }

                Py_RETURN_FALSE;
            }

            Py_RETURN_NOTIMPLEMENTED;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _repr_Rational(PyObject* self) noexcept
    {
        py::pyobj_handle Numerator{PyObject_GetAttrString(self, "numerator")};
        if (!Numerator)
        {
            return nullptr;
        }

        py::pyobj_handle Denominator{PyObject_GetAttrString(self, "denominator")};
        if (!Denominator)
        {
            return nullptr;
        }

        return PyUnicode_FromFormat("Rational(numerator=%R, denominator=%R)", Numerator.get(), Denominator.get());
    }

    static PyType_Slot _type_slots_Rational[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_Rational) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_Rational) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_Rational) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_Rational) },
        { Py_tp_richcompare, reinterpret_cast<void*>(_richcompare_Rational) },
        { Py_tp_repr, reinterpret_cast<void*>(_repr_Rational) },
        { }};

    static PyType_Spec type_spec_Rational = {
        "winrt._winrt_windows_foundation_numerics.Rational",
        sizeof(py::wrapper::Windows::Foundation::Numerics::Rational),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_Rational};

    // ----- Vector2 struct --------------------

    winrt::Windows::Foundation::Numerics::float2 Vector2_from_tuple(PyObject* tuple)
    {
        if (PyTuple_GET_SIZE(tuple) != 2)
        {
            PyErr_SetString(PyExc_TypeError, "Incorrect number of fields");
            throw python_exception();
        }

        winrt::Windows::Foundation::Numerics::float2 result{};

        result.x = py::convert_to<float>(tuple, 0);
        result.y = py::convert_to<float>(tuple, 1);

        return result;
    }

    PyObject* _new_Vector2(PyTypeObject* subclass, PyObject* args, PyObject* kwds) noexcept
    {
        pyobj_handle self_obj{(subclass->tp_alloc(subclass, 0))};
        if (!self_obj)
        {
            return nullptr;
        }

        auto self = reinterpret_cast<winrt_struct_wrapper<winrt::Windows::Foundation::Numerics::float2>*>(self_obj.get());
        std::construct_at(&self->obj);

        auto tuple_size = PyTuple_GET_SIZE(args);
        if ((tuple_size == 0) && (!kwds))
        {
            return self_obj.detach();
        }

        float _X{};
        float _Y{};

        static const char* kwlist[] = {"x", "y", nullptr};
        if (!PyArg_ParseTupleAndKeywords(args, kwds, "|ff", const_cast<char**>(kwlist), &_X, &_Y))
        {
            return nullptr;
        }

        try
        {
            self->obj.x = _X;
            self->obj.y = _Y;

            return self_obj.detach();
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static void _dealloc_Vector2(py::wrapper::Windows::Foundation::Numerics::Vector2* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _get_zero_Vector2(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        return py::convert(winrt::Windows::Foundation::Numerics::float2::zero());
    }

    static PyObject* _get_one_Vector2(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        return py::convert(winrt::Windows::Foundation::Numerics::float2::one());
    }

    static PyObject* _get_unit_x_Vector2(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        return py::convert(winrt::Windows::Foundation::Numerics::float2::unit_x());
    }

    static PyObject* _get_unit_y_Vector2(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        return py::convert(winrt::Windows::Foundation::Numerics::float2::unit_y());
    }

    static PyObject* length_Vector2(winrt_struct_wrapper<winrt::Windows::Foundation::Numerics::float2>* self, PyObject* /*unused*/) noexcept
    {
        try
        {
            auto _result = winrt::Windows::Foundation::Numerics::length(self->obj);
            return py::convert(_result);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* length_squared_Vector2(winrt_struct_wrapper<winrt::Windows::Foundation::Numerics::float2>* self, PyObject* /*unused*/) noexcept
    {
        try
        {
            auto _result = winrt::Windows::Foundation::Numerics::length_squared(self->obj);
            return py::convert(_result);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* distance_Vector2(winrt_struct_wrapper<winrt::Windows::Foundation::Numerics::float2>* self, PyObject* arg) noexcept
    {
        try
        {
            auto _arg = py::convert_to<winrt::Windows::Foundation::Numerics::float2>(arg);
            auto _result = winrt::Windows::Foundation::Numerics::distance(self->obj, _arg);
            return py::convert(_result);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* distance_squared_Vector2(winrt_struct_wrapper<winrt::Windows::Foundation::Numerics::float2>* self, PyObject* arg) noexcept
    {
        try
        {
            auto _arg = py::convert_to<winrt::Windows::Foundation::Numerics::float2>(arg);
            auto _result = winrt::Windows::Foundation::Numerics::distance_squared(self->obj, _arg);
            return py::convert(_result);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* dot_Vector2(winrt_struct_wrapper<winrt::Windows::Foundation::Numerics::float2>* self, PyObject* arg) noexcept
    {
        try
        {
            auto _arg = py::convert_to<winrt::Windows::Foundation::Numerics::float2>(arg);
            auto _result = winrt::Windows::Foundation::Numerics::dot(self->obj, _arg);
            return py::convert(_result);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* normalize_Vector2(winrt_struct_wrapper<winrt::Windows::Foundation::Numerics::float2>* self, PyObject* /*unused*/) noexcept
    {
        try
        {
            auto _result = winrt::Windows::Foundation::Numerics::normalize(self->obj);
            return py::convert(_result);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* reflect_Vector2(winrt_struct_wrapper<winrt::Windows::Foundation::Numerics::float2>* self, PyObject* arg) noexcept
    {
        try
        {
            auto _arg = py::convert_to<winrt::Windows::Foundation::Numerics::float2>(arg);
            auto _result = winrt::Windows::Foundation::Numerics::reflect(self->obj, _arg);
            return py::convert(_result);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* min_Vector2(winrt_struct_wrapper<winrt::Windows::Foundation::Numerics::float2>* self, PyObject* arg) noexcept
    {
        try
        {
            auto _arg = py::convert_to<winrt::Windows::Foundation::Numerics::float2>(arg);
            auto _result = winrt::Windows::Foundation::Numerics::min(self->obj, _arg);
            return py::convert(_result);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* max_Vector2(winrt_struct_wrapper<winrt::Windows::Foundation::Numerics::float2>* self, PyObject* arg) noexcept
    {
        try
        {
            auto _arg = py::convert_to<winrt::Windows::Foundation::Numerics::float2>(arg);
            auto _result = winrt::Windows::Foundation::Numerics::max(self->obj, _arg);
            return py::convert(_result);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* clamp_Vector2(winrt_struct_wrapper<winrt::Windows::Foundation::Numerics::float2>* self, PyObject* args) noexcept
    {
        try
        {
            auto _arg0 = py::convert_to<winrt::Windows::Foundation::Numerics::float2>(args, 0);
            auto _arg1 = py::convert_to<winrt::Windows::Foundation::Numerics::float2>(args, 1);
            auto _result = winrt::Windows::Foundation::Numerics::clamp(self->obj, _arg0, _arg1);
            return py::convert(_result);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* lerp_Vector2(winrt_struct_wrapper<winrt::Windows::Foundation::Numerics::float2>* self, PyObject* args) noexcept
    {
        try
        {
            auto _arg0 = py::convert_to<winrt::Windows::Foundation::Numerics::float2>(args, 0);
            auto _arg1 = py::convert_to<float>(args, 1);
            auto _result = winrt::Windows::Foundation::Numerics::lerp(self->obj, _arg0, _arg1);
            return py::convert(_result);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* transform_Vector2(winrt_struct_wrapper<winrt::Windows::Foundation::Numerics::float2>* self, PyObject* arg) noexcept
    {
        try
        {
            if (std::string_view(Py_TYPE(arg)->tp_name) == "Matrix3x2" || std::string_view(Py_TYPE(arg)->tp_name) == "winrt._winrt_windows_foundation_numerics.Matrix3x2")
            {
#if defined(__MINGW32__)
                PyErr_SetString(PyExc_NotImplementedError, "Overload for Matrix3x2 is not implemented on MinGW");
                return nullptr;
#else
                auto _arg = py::convert_to<winrt::Windows::Foundation::Numerics::float3x2>(arg);
                auto _result = winrt::Windows::Foundation::Numerics::transform(self->obj, _arg);
                return py::convert(_result);
#endif
            }

            if (std::string_view(Py_TYPE(arg)->tp_name) == "Matrix4x4" || std::string_view(Py_TYPE(arg)->tp_name) == "winrt._winrt_windows_foundation_numerics.Matrix4x4")
            {
#if defined(__MINGW32__)
                PyErr_SetString(PyExc_NotImplementedError, "Overload for Matrix4x4 is not implemented on MinGW");
                return nullptr;
#else
                auto _arg = py::convert_to<winrt::Windows::Foundation::Numerics::float4x4>(arg);
                auto _result = winrt::Windows::Foundation::Numerics::transform(self->obj, _arg);
                return py::convert(_result);
#endif
            }

            if (std::string_view(Py_TYPE(arg)->tp_name) == "Quaternion" || std::string_view(Py_TYPE(arg)->tp_name) == "winrt._winrt_windows_foundation_numerics.Quaternion")
            {
                auto _arg = py::convert_to<winrt::Windows::Foundation::Numerics::quaternion>(arg);
                auto _result = winrt::Windows::Foundation::Numerics::transform(self->obj, _arg);
                return py::convert(_result);
            }

            PyErr_Format(PyExc_TypeError, "Expecting one of 'winrt._winrt_windows_foundation_numerics.Matrix3x2', 'winrt._winrt_windows_foundation_numerics.Matrix4x4', 'winrt._winrt_windows_foundation_numerics.Quaternion' but got '%s'", Py_TYPE(arg)->tp_name);
            return nullptr;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* transform_normal_Vector2(winrt_struct_wrapper<winrt::Windows::Foundation::Numerics::float2>* self, PyObject* arg) noexcept
    {
        try
        {
#if defined(__MINGW32__)
            (void)self;
            (void)arg;
            PyErr_SetString(PyExc_NotImplementedError, "This method is not implemented on MinGW");
            return nullptr;
#else
            if (std::string_view(Py_TYPE(arg)->tp_name) == "Matrix3x2" || std::string_view(Py_TYPE(arg)->tp_name) == "winrt._winrt_windows_foundation_numerics.Matrix3x2")
            {
                auto _arg = py::convert_to<winrt::Windows::Foundation::Numerics::float3x2>(arg);
                auto _result = winrt::Windows::Foundation::Numerics::transform_normal(self->obj, _arg);
                return py::convert(_result);
            }

            if (std::string_view(Py_TYPE(arg)->tp_name) == "Matrix4x4" || std::string_view(Py_TYPE(arg)->tp_name) == "winrt._winrt_windows_foundation_numerics.Matrix4x4")
            {
                auto _arg = py::convert_to<winrt::Windows::Foundation::Numerics::float4x4>(arg);
                auto _result = winrt::Windows::Foundation::Numerics::transform_normal(self->obj, _arg);
                return py::convert(_result);
            }

            PyErr_Format(PyExc_TypeError, "Expecting one of 'winrt._winrt_windows_foundation_numerics.Matrix3x2', 'winrt._winrt_windows_foundation_numerics.Matrix4x4' but got '%s'", Py_TYPE(arg)->tp_name);
            return nullptr;
#endif
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* transform4_Vector2(winrt_struct_wrapper<winrt::Windows::Foundation::Numerics::float2>* self, PyObject* arg) noexcept
    {
        try
        {
            if (std::string_view(Py_TYPE(arg)->tp_name) == "Matrix4x4" || std::string_view(Py_TYPE(arg)->tp_name) == "winrt._winrt_windows_foundation_numerics.Matrix4x4")
            {
#if defined(__MINGW32__)
                PyErr_SetString(PyExc_NotImplementedError, "Overload for Matrix4x4 is not implemented on MinGW");
                return nullptr;
#else
                auto _arg = py::convert_to<winrt::Windows::Foundation::Numerics::float4x4>(arg);
                auto _result = winrt::Windows::Foundation::Numerics::transform4(self->obj, _arg);
                return py::convert(_result);
#endif
            }

            if (std::string_view(Py_TYPE(arg)->tp_name) == "Quaternion" || std::string_view(Py_TYPE(arg)->tp_name) == "winrt._winrt_windows_foundation_numerics.Quaternion")
            {
                auto _arg = py::convert_to<winrt::Windows::Foundation::Numerics::quaternion>(arg);
                auto _result = winrt::Windows::Foundation::Numerics::transform4(self->obj, _arg);
                return py::convert(_result);
            }

            PyErr_Format(PyExc_TypeError, "Expecting one of 'winrt._winrt_windows_foundation_numerics.Matrix4x4', 'winrt._winrt_windows_foundation_numerics.Quaternion' but got '%s'", Py_TYPE(arg)->tp_name);
            return nullptr;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_Vector2(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Foundation::Numerics::float2>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    PyObject* _replace_Vector2(py::wrapper::Windows::Foundation::Numerics::Vector2* self, PyObject* args, PyObject* kwds) noexcept
    {
        try
        {
            float _X{self->obj.x};
            float _Y{self->obj.y};

            static const char* kwlist[] = {"x", "y", nullptr};
            if (!PyArg_ParseTupleAndKeywords(args, kwds, "|$ff", const_cast<char**>(kwlist), &_X, &_Y))
            {
                return nullptr;
            }

            auto copy = self->obj;
            copy.x = _X;
            copy.y = _Y;

            return convert(copy);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    PyObject* unpack_Vector2(py::wrapper::Windows::Foundation::Numerics::Vector2* self, PyObject* /*unused*/) noexcept
    {
        py::pyobj_handle X{convert(self->obj.x)};
        if (!X)
        {
            return nullptr;
        }

        py::pyobj_handle Y{convert(self->obj.y)};
        if (!Y)
        {
            return nullptr;
        }

        pyobj_handle tuple{PyTuple_New(2)};
        if (!tuple)
        {
            return nullptr;
        }

        PyTuple_SET_ITEM(tuple.get(), 0, X.detach());
        PyTuple_SET_ITEM(tuple.get(), 1, Y.detach());

        return tuple.detach();
    }

    static PyMethodDef _methods_Vector2[] = {
        { "length", reinterpret_cast<PyCFunction>(length_Vector2), METH_NOARGS, nullptr },
        { "length_squared", reinterpret_cast<PyCFunction>(length_squared_Vector2), METH_NOARGS, nullptr },
        { "distance", reinterpret_cast<PyCFunction>(distance_Vector2), METH_O, nullptr },
        { "distance_squared", reinterpret_cast<PyCFunction>(distance_squared_Vector2), METH_O, nullptr },
        { "dot", reinterpret_cast<PyCFunction>(dot_Vector2), METH_O, nullptr },
        { "normalize", reinterpret_cast<PyCFunction>(normalize_Vector2), METH_NOARGS, nullptr },
        { "reflect", reinterpret_cast<PyCFunction>(reflect_Vector2), METH_O, nullptr },
        { "min", reinterpret_cast<PyCFunction>(min_Vector2), METH_O, nullptr },
        { "max", reinterpret_cast<PyCFunction>(max_Vector2), METH_O, nullptr },
        { "clamp", reinterpret_cast<PyCFunction>(clamp_Vector2), METH_VARARGS, nullptr },
        { "lerp", reinterpret_cast<PyCFunction>(lerp_Vector2), METH_VARARGS, nullptr },
        { "transform", reinterpret_cast<PyCFunction>(transform_Vector2), METH_O, nullptr },
        { "transform_normal", reinterpret_cast<PyCFunction>(transform_normal_Vector2), METH_O, nullptr },
        { "transform4", reinterpret_cast<PyCFunction>(transform4_Vector2), METH_O, nullptr },
        { "_assign_array_", _assign_array_Vector2, METH_O | METH_STATIC, nullptr },
        { "__replace__", reinterpret_cast<PyCFunction>(reinterpret_cast<void*>(_replace_Vector2)), METH_VARARGS | METH_KEYWORDS, nullptr },
        { "unpack", reinterpret_cast<PyCFunction>(unpack_Vector2), METH_NOARGS, nullptr },
        { }};

    static PyObject* Vector2_get_X(py::wrapper::Windows::Foundation::Numerics::Vector2* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.x);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Vector2_get_Y(py::wrapper::Windows::Foundation::Numerics::Vector2* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.y);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyGetSetDef _getset_Vector2[] = {
        { "x", reinterpret_cast<getter>(Vector2_get_X), nullptr, nullptr, nullptr },
        { "y", reinterpret_cast<getter>(Vector2_get_Y), nullptr, nullptr, nullptr },
        { }};

    static PyObject* _add_Vector2(PyObject* left, PyObject* right) noexcept
    {
        try
        {
            auto _left = py::convert_to<winrt::Windows::Foundation::Numerics::float2>(left);
            auto _right = py::convert_to<winrt::Windows::Foundation::Numerics::float2>(right);

            auto _result = _left + _right;
            return py::convert(_result);
        }
        catch (...)
        {
            py::to_PyErr();

            if (PyErr_ExceptionMatches(PyExc_TypeError))
            {
                PyErr_Clear();
                Py_RETURN_NOTIMPLEMENTED;
            }

            return nullptr;
        }
    }

    static PyObject* _sub_Vector2(PyObject* left, PyObject* right) noexcept
    {
        try
        {
            auto _left = py::convert_to<winrt::Windows::Foundation::Numerics::float2>(left);
            auto _right = py::convert_to<winrt::Windows::Foundation::Numerics::float2>(right);

            auto _result = _left - _right;
            return py::convert(_result);
        }
        catch (...)
        {
            py::to_PyErr();

            if (PyErr_ExceptionMatches(PyExc_TypeError))
            {
                PyErr_Clear();
                Py_RETURN_NOTIMPLEMENTED;
            }

            return nullptr;
        }
    }

    static PyObject* _mul_Vector2(PyObject* left, PyObject* right) noexcept
    {
        try
        {
            py::pyobj_handle left_float{PyNumber_Float(left)};
            if (left_float)
            {
                auto _left_float = PyFloat_AsDouble(left_float.get());
                if (_left_float == -1 && PyErr_Occurred())
                {
                    return nullptr;
                }
                auto _result = static_cast<float>(_left_float) * py::convert_to<winrt::Windows::Foundation::Numerics::float2>(right);
                return py::convert(_result);
            }
            else
            {
                PyErr_Clear();
            }

            auto _left = py::convert_to<winrt::Windows::Foundation::Numerics::float2>(left);

            py::pyobj_handle right_float{PyNumber_Float(right)};
            if (right_float)
            {
                auto _right_float = PyFloat_AsDouble(right_float.get());
                if (_right_float == -1 && PyErr_Occurred())
                {
                    return nullptr;
                }

                auto _result = _left * static_cast<float>(_right_float);
                return py::convert(_result);
            }
            else
            {
                PyErr_Clear();
            }

            auto _right = py::convert_to<winrt::Windows::Foundation::Numerics::float2>(right);

            auto _result = _left * _right;
            return py::convert(_result);
        }
        catch (...)
        {
            py::to_PyErr();

            if (PyErr_ExceptionMatches(PyExc_TypeError))
            {
                PyErr_Clear();
                Py_RETURN_NOTIMPLEMENTED;
            }

            return nullptr;
        }
    }

    static PyObject* _truediv_Vector2(PyObject* left, PyObject* right) noexcept
    {
        try
        {
            auto _left = py::convert_to<winrt::Windows::Foundation::Numerics::float2>(left);

            py::pyobj_handle right_float{PyNumber_Float(right)};
            if (right_float)
            {
                auto _right_float = PyFloat_AsDouble(right_float.get());
                if (_right_float == -1 && PyErr_Occurred())
                {
                    return nullptr;
                }

                auto _result = _left / static_cast<float>(_right_float);
                return py::convert(_result);
            }
            else
            {
                PyErr_Clear();
            }
            auto _right = py::convert_to<winrt::Windows::Foundation::Numerics::float2>(right);

            auto _result = _left / _right;
            return py::convert(_result);
        }
        catch (...)
        {
            py::to_PyErr();

            if (PyErr_ExceptionMatches(PyExc_TypeError))
            {
                PyErr_Clear();
                Py_RETURN_NOTIMPLEMENTED;
            }

            return nullptr;
        }
    }

    static PyObject* _neg_Vector2(PyObject* operand) noexcept
    {
        try
        {
            auto _operand = py::convert_to<winrt::Windows::Foundation::Numerics::float2>(operand);
            auto _result = -_operand;
            return py::convert(_result);
        }
        catch (...)
        {
            py::to_PyErr();

            if (PyErr_ExceptionMatches(PyExc_TypeError))
            {
                PyErr_Clear();
                Py_RETURN_NOTIMPLEMENTED;
            }

            return nullptr;
        }
    }

    static PyObject* _abs_Vector2(PyObject* operand) noexcept
    {
        try
        {
            auto _operand = py::convert_to<winrt::Windows::Foundation::Numerics::float2>(operand);
            auto _result = winrt::Windows::Foundation::Numerics::length(_operand);
            return py::convert(_result);
        }
        catch (...)
        {
            py::to_PyErr();

            if (PyErr_ExceptionMatches(PyExc_TypeError))
            {
                PyErr_Clear();
                Py_RETURN_NOTIMPLEMENTED;
            }

            return nullptr;
        }
    }

    static PyObject* _richcompare_Vector2(py::wrapper::Windows::Foundation::Numerics::Vector2* self, PyObject* other, int op) noexcept
    {
        try
        {
            auto _other = py::convert_to<winrt::Windows::Foundation::Numerics::float2>(other);

            if (op == Py_EQ)
            {
                if (self->obj == _other)
                {
                    Py_RETURN_TRUE;
                }

                Py_RETURN_FALSE;
            }

            if (op == Py_NE)
            {
                if (self->obj != _other)
                {
                    Py_RETURN_TRUE;
                }

                Py_RETURN_FALSE;
            }

            Py_RETURN_NOTIMPLEMENTED;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _repr_Vector2(PyObject* self) noexcept
    {
        py::pyobj_handle X{PyObject_GetAttrString(self, "x")};
        if (!X)
        {
            return nullptr;
        }

        py::pyobj_handle Y{PyObject_GetAttrString(self, "y")};
        if (!Y)
        {
            return nullptr;
        }

        return PyUnicode_FromFormat("Vector2(x=%R, y=%R)", X.get(), Y.get());
    }

    static PyType_Slot _type_slots_Vector2[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_Vector2) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_Vector2) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_Vector2) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_Vector2) },
        { Py_nb_add, reinterpret_cast<void*>(_add_Vector2) },
        { Py_nb_subtract, reinterpret_cast<void*>(_sub_Vector2) },
        { Py_nb_multiply, reinterpret_cast<void*>(_mul_Vector2) },
        { Py_nb_true_divide, reinterpret_cast<void*>(_truediv_Vector2) },
        { Py_nb_negative, reinterpret_cast<void*>(_neg_Vector2) },
        { Py_nb_absolute, reinterpret_cast<void*>(_abs_Vector2) },
        { Py_tp_richcompare, reinterpret_cast<void*>(_richcompare_Vector2) },
        { Py_tp_repr, reinterpret_cast<void*>(_repr_Vector2) },
        { }};

    static PyType_Spec type_spec_Vector2 = {
        "winrt._winrt_windows_foundation_numerics.Vector2",
        sizeof(py::wrapper::Windows::Foundation::Numerics::Vector2),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_Vector2};

    static PyGetSetDef getset_Vector2_Static[] = {
        { "zero", _get_zero_Vector2, nullptr, nullptr, nullptr },
        { "one", _get_one_Vector2, nullptr, nullptr, nullptr },
        { "unit_x", _get_unit_x_Vector2, nullptr, nullptr, nullptr },
        { "unit_y", _get_unit_y_Vector2, nullptr, nullptr, nullptr },
        { }};

    static PyMethodDef methods_Vector2_Static[] = {
        { }};

    static PyType_Slot type_slots_Vector2_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_Vector2_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_Vector2_Static) },
        { }
    };

    static PyType_Spec type_spec_Vector2_Static = {
        "winrt._winrt_windows_foundation_numerics.Vector2_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_Vector2_Static};

    // ----- Vector3 struct --------------------

    winrt::Windows::Foundation::Numerics::float3 Vector3_from_tuple(PyObject* tuple)
    {
        if (PyTuple_GET_SIZE(tuple) != 3)
        {
            PyErr_SetString(PyExc_TypeError, "Incorrect number of fields");
            throw python_exception();
        }

        winrt::Windows::Foundation::Numerics::float3 result{};

        result.x = py::convert_to<float>(tuple, 0);
        result.y = py::convert_to<float>(tuple, 1);
        result.z = py::convert_to<float>(tuple, 2);

        return result;
    }

    PyObject* _new_Vector3(PyTypeObject* subclass, PyObject* args, PyObject* kwds) noexcept
    {
        pyobj_handle self_obj{(subclass->tp_alloc(subclass, 0))};
        if (!self_obj)
        {
            return nullptr;
        }

        auto self = reinterpret_cast<winrt_struct_wrapper<winrt::Windows::Foundation::Numerics::float3>*>(self_obj.get());
        std::construct_at(&self->obj);

        auto tuple_size = PyTuple_GET_SIZE(args);
        if ((tuple_size == 0) && (!kwds))
        {
            return self_obj.detach();
        }

        float _X{};
        float _Y{};
        float _Z{};

        static const char* kwlist[] = {"x", "y", "z", nullptr};
        if (!PyArg_ParseTupleAndKeywords(args, kwds, "|fff", const_cast<char**>(kwlist), &_X, &_Y, &_Z))
        {
            return nullptr;
        }

        try
        {
            self->obj.x = _X;
            self->obj.y = _Y;
            self->obj.z = _Z;

            return self_obj.detach();
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static void _dealloc_Vector3(py::wrapper::Windows::Foundation::Numerics::Vector3* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _get_zero_Vector3(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        return py::convert(winrt::Windows::Foundation::Numerics::float3::zero());
    }

    static PyObject* _get_one_Vector3(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        return py::convert(winrt::Windows::Foundation::Numerics::float3::one());
    }

    static PyObject* _get_unit_x_Vector3(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        return py::convert(winrt::Windows::Foundation::Numerics::float3::unit_x());
    }

    static PyObject* _get_unit_y_Vector3(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        return py::convert(winrt::Windows::Foundation::Numerics::float3::unit_y());
    }

    static PyObject* _get_unit_z_Vector3(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        return py::convert(winrt::Windows::Foundation::Numerics::float3::unit_z());
    }

    static PyObject* length_Vector3(winrt_struct_wrapper<winrt::Windows::Foundation::Numerics::float3>* self, PyObject* /*unused*/) noexcept
    {
        try
        {
            auto _result = winrt::Windows::Foundation::Numerics::length(self->obj);
            return py::convert(_result);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* length_squared_Vector3(winrt_struct_wrapper<winrt::Windows::Foundation::Numerics::float3>* self, PyObject* /*unused*/) noexcept
    {
        try
        {
            auto _result = winrt::Windows::Foundation::Numerics::length_squared(self->obj);
            return py::convert(_result);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* distance_Vector3(winrt_struct_wrapper<winrt::Windows::Foundation::Numerics::float3>* self, PyObject* arg) noexcept
    {
        try
        {
            auto _arg = py::convert_to<winrt::Windows::Foundation::Numerics::float3>(arg);
            auto _result = winrt::Windows::Foundation::Numerics::distance(self->obj, _arg);
            return py::convert(_result);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* distance_squared_Vector3(winrt_struct_wrapper<winrt::Windows::Foundation::Numerics::float3>* self, PyObject* arg) noexcept
    {
        try
        {
            auto _arg = py::convert_to<winrt::Windows::Foundation::Numerics::float3>(arg);
            auto _result = winrt::Windows::Foundation::Numerics::distance_squared(self->obj, _arg);
            return py::convert(_result);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* dot_Vector3(winrt_struct_wrapper<winrt::Windows::Foundation::Numerics::float3>* self, PyObject* arg) noexcept
    {
        try
        {
            auto _arg = py::convert_to<winrt::Windows::Foundation::Numerics::float3>(arg);
            auto _result = winrt::Windows::Foundation::Numerics::dot(self->obj, _arg);
            return py::convert(_result);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* cross_Vector3(winrt_struct_wrapper<winrt::Windows::Foundation::Numerics::float3>* self, PyObject* arg) noexcept
    {
        try
        {
            auto _arg = py::convert_to<winrt::Windows::Foundation::Numerics::float3>(arg);
            auto _result = winrt::Windows::Foundation::Numerics::cross(self->obj, _arg);
            return py::convert(_result);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* normalize_Vector3(winrt_struct_wrapper<winrt::Windows::Foundation::Numerics::float3>* self, PyObject* /*unused*/) noexcept
    {
        try
        {
            auto _result = winrt::Windows::Foundation::Numerics::normalize(self->obj);
            return py::convert(_result);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* reflect_Vector3(winrt_struct_wrapper<winrt::Windows::Foundation::Numerics::float3>* self, PyObject* arg) noexcept
    {
        try
        {
            auto _arg = py::convert_to<winrt::Windows::Foundation::Numerics::float3>(arg);
            auto _result = winrt::Windows::Foundation::Numerics::reflect(self->obj, _arg);
            return py::convert(_result);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* min_Vector3(winrt_struct_wrapper<winrt::Windows::Foundation::Numerics::float3>* self, PyObject* arg) noexcept
    {
        try
        {
            auto _arg = py::convert_to<winrt::Windows::Foundation::Numerics::float3>(arg);
            auto _result = winrt::Windows::Foundation::Numerics::min(self->obj, _arg);
            return py::convert(_result);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* max_Vector3(winrt_struct_wrapper<winrt::Windows::Foundation::Numerics::float3>* self, PyObject* arg) noexcept
    {
        try
        {
            auto _arg = py::convert_to<winrt::Windows::Foundation::Numerics::float3>(arg);
            auto _result = winrt::Windows::Foundation::Numerics::max(self->obj, _arg);
            return py::convert(_result);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* clamp_Vector3(winrt_struct_wrapper<winrt::Windows::Foundation::Numerics::float3>* self, PyObject* args) noexcept
    {
        try
        {
            auto _arg0 = py::convert_to<winrt::Windows::Foundation::Numerics::float3>(args, 0);
            auto _arg1 = py::convert_to<winrt::Windows::Foundation::Numerics::float3>(args, 1);
            auto _result = winrt::Windows::Foundation::Numerics::clamp(self->obj, _arg0, _arg1);
            return py::convert(_result);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* lerp_Vector3(winrt_struct_wrapper<winrt::Windows::Foundation::Numerics::float3>* self, PyObject* args) noexcept
    {
        try
        {
            auto _arg0 = py::convert_to<winrt::Windows::Foundation::Numerics::float3>(args, 0);
            auto _arg1 = py::convert_to<float>(args, 1);
            auto _result = winrt::Windows::Foundation::Numerics::lerp(self->obj, _arg0, _arg1);
            return py::convert(_result);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* transform_Vector3(winrt_struct_wrapper<winrt::Windows::Foundation::Numerics::float3>* self, PyObject* arg) noexcept
    {
        try
        {
#if defined(__MINGW32__)
            (void)self;
            (void)arg;
            PyErr_SetString(PyExc_NotImplementedError, "This method is not implemented on MinGW");
            return nullptr;
#else
            if (std::string_view(Py_TYPE(arg)->tp_name) == "Matrix4x4" || std::string_view(Py_TYPE(arg)->tp_name) == "winrt._winrt_windows_foundation_numerics.Matrix4x4")
            {
                auto _arg = py::convert_to<winrt::Windows::Foundation::Numerics::float4x4>(arg);
                auto _result = winrt::Windows::Foundation::Numerics::transform(self->obj, _arg);
                return py::convert(_result);
            }

            if (std::string_view(Py_TYPE(arg)->tp_name) == "Quaternion" || std::string_view(Py_TYPE(arg)->tp_name) == "winrt._winrt_windows_foundation_numerics.Quaternion")
            {
                auto _arg = py::convert_to<winrt::Windows::Foundation::Numerics::quaternion>(arg);
                auto _result = winrt::Windows::Foundation::Numerics::transform(self->obj, _arg);
                return py::convert(_result);
            }

            PyErr_Format(PyExc_TypeError, "Expecting one of 'winrt._winrt_windows_foundation_numerics.Matrix4x4', 'winrt._winrt_windows_foundation_numerics.Quaternion' but got '%s'", Py_TYPE(arg)->tp_name);
            return nullptr;
#endif
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* transform_normal_Vector3(winrt_struct_wrapper<winrt::Windows::Foundation::Numerics::float3>* self, PyObject* arg) noexcept
    {
        try
        {
#if defined(__MINGW32__)
            (void)self;
            (void)arg;
            PyErr_SetString(PyExc_NotImplementedError, "This method is not implemented on MinGW");
            return nullptr;
#else
            auto _arg = py::convert_to<winrt::Windows::Foundation::Numerics::float4x4>(arg);
            auto _result = winrt::Windows::Foundation::Numerics::transform_normal(self->obj, _arg);
            return py::convert(_result);
#endif
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* transform4_Vector3(winrt_struct_wrapper<winrt::Windows::Foundation::Numerics::float3>* self, PyObject* arg) noexcept
    {
        try
        {
            if (std::string_view(Py_TYPE(arg)->tp_name) == "Matrix4x4" || std::string_view(Py_TYPE(arg)->tp_name) == "winrt._winrt_windows_foundation_numerics.Matrix4x4")
            {
#if defined(__MINGW32__)
                PyErr_SetString(PyExc_NotImplementedError, "Overload for Matrix4x4 is not implemented on MinGW");
                return nullptr;
#else
                auto _arg = py::convert_to<winrt::Windows::Foundation::Numerics::float4x4>(arg);
                auto _result = winrt::Windows::Foundation::Numerics::transform4(self->obj, _arg);
                return py::convert(_result);
#endif
            }

            if (std::string_view(Py_TYPE(arg)->tp_name) == "Quaternion" || std::string_view(Py_TYPE(arg)->tp_name) == "winrt._winrt_windows_foundation_numerics.Quaternion")
            {
                auto _arg = py::convert_to<winrt::Windows::Foundation::Numerics::quaternion>(arg);
                auto _result = winrt::Windows::Foundation::Numerics::transform4(self->obj, _arg);
                return py::convert(_result);
            }

            PyErr_Format(PyExc_TypeError, "Expecting one of 'winrt._winrt_windows_foundation_numerics.Matrix4x4', 'winrt._winrt_windows_foundation_numerics.Quaternion' but got '%s'", Py_TYPE(arg)->tp_name);
            return nullptr;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_Vector3(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Foundation::Numerics::float3>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    PyObject* _replace_Vector3(py::wrapper::Windows::Foundation::Numerics::Vector3* self, PyObject* args, PyObject* kwds) noexcept
    {
        try
        {
            float _X{self->obj.x};
            float _Y{self->obj.y};
            float _Z{self->obj.z};

            static const char* kwlist[] = {"x", "y", "z", nullptr};
            if (!PyArg_ParseTupleAndKeywords(args, kwds, "|$fff", const_cast<char**>(kwlist), &_X, &_Y, &_Z))
            {
                return nullptr;
            }

            auto copy = self->obj;
            copy.x = _X;
            copy.y = _Y;
            copy.z = _Z;

            return convert(copy);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    PyObject* unpack_Vector3(py::wrapper::Windows::Foundation::Numerics::Vector3* self, PyObject* /*unused*/) noexcept
    {
        py::pyobj_handle X{convert(self->obj.x)};
        if (!X)
        {
            return nullptr;
        }

        py::pyobj_handle Y{convert(self->obj.y)};
        if (!Y)
        {
            return nullptr;
        }

        py::pyobj_handle Z{convert(self->obj.z)};
        if (!Z)
        {
            return nullptr;
        }

        pyobj_handle tuple{PyTuple_New(3)};
        if (!tuple)
        {
            return nullptr;
        }

        PyTuple_SET_ITEM(tuple.get(), 0, X.detach());
        PyTuple_SET_ITEM(tuple.get(), 1, Y.detach());
        PyTuple_SET_ITEM(tuple.get(), 2, Z.detach());

        return tuple.detach();
    }

    static PyMethodDef _methods_Vector3[] = {
        { "length", reinterpret_cast<PyCFunction>(length_Vector3), METH_NOARGS, nullptr },
        { "length_squared", reinterpret_cast<PyCFunction>(length_squared_Vector3), METH_NOARGS, nullptr },
        { "distance", reinterpret_cast<PyCFunction>(distance_Vector3), METH_O, nullptr },
        { "distance_squared", reinterpret_cast<PyCFunction>(distance_squared_Vector3), METH_O, nullptr },
        { "dot", reinterpret_cast<PyCFunction>(dot_Vector3), METH_O, nullptr },
        { "cross", reinterpret_cast<PyCFunction>(cross_Vector3), METH_O, nullptr },
        { "normalize", reinterpret_cast<PyCFunction>(normalize_Vector3), METH_NOARGS, nullptr },
        { "reflect", reinterpret_cast<PyCFunction>(reflect_Vector3), METH_O, nullptr },
        { "min", reinterpret_cast<PyCFunction>(min_Vector3), METH_O, nullptr },
        { "max", reinterpret_cast<PyCFunction>(max_Vector3), METH_O, nullptr },
        { "clamp", reinterpret_cast<PyCFunction>(clamp_Vector3), METH_VARARGS, nullptr },
        { "lerp", reinterpret_cast<PyCFunction>(lerp_Vector3), METH_VARARGS, nullptr },
        { "transform", reinterpret_cast<PyCFunction>(transform_Vector3), METH_O, nullptr },
        { "transform_normal", reinterpret_cast<PyCFunction>(transform_normal_Vector3), METH_O, nullptr },
        { "transform4", reinterpret_cast<PyCFunction>(transform4_Vector3), METH_O, nullptr },
        { "_assign_array_", _assign_array_Vector3, METH_O | METH_STATIC, nullptr },
        { "__replace__", reinterpret_cast<PyCFunction>(reinterpret_cast<void*>(_replace_Vector3)), METH_VARARGS | METH_KEYWORDS, nullptr },
        { "unpack", reinterpret_cast<PyCFunction>(unpack_Vector3), METH_NOARGS, nullptr },
        { }};

    static PyObject* Vector3_get_X(py::wrapper::Windows::Foundation::Numerics::Vector3* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.x);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Vector3_get_Y(py::wrapper::Windows::Foundation::Numerics::Vector3* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.y);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Vector3_get_Z(py::wrapper::Windows::Foundation::Numerics::Vector3* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.z);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyGetSetDef _getset_Vector3[] = {
        { "x", reinterpret_cast<getter>(Vector3_get_X), nullptr, nullptr, nullptr },
        { "y", reinterpret_cast<getter>(Vector3_get_Y), nullptr, nullptr, nullptr },
        { "z", reinterpret_cast<getter>(Vector3_get_Z), nullptr, nullptr, nullptr },
        { }};

    static PyObject* _add_Vector3(PyObject* left, PyObject* right) noexcept
    {
        try
        {
            auto _left = py::convert_to<winrt::Windows::Foundation::Numerics::float3>(left);
            auto _right = py::convert_to<winrt::Windows::Foundation::Numerics::float3>(right);

            auto _result = _left + _right;
            return py::convert(_result);
        }
        catch (...)
        {
            py::to_PyErr();

            if (PyErr_ExceptionMatches(PyExc_TypeError))
            {
                PyErr_Clear();
                Py_RETURN_NOTIMPLEMENTED;
            }

            return nullptr;
        }
    }

    static PyObject* _sub_Vector3(PyObject* left, PyObject* right) noexcept
    {
        try
        {
            auto _left = py::convert_to<winrt::Windows::Foundation::Numerics::float3>(left);
            auto _right = py::convert_to<winrt::Windows::Foundation::Numerics::float3>(right);

            auto _result = _left - _right;
            return py::convert(_result);
        }
        catch (...)
        {
            py::to_PyErr();

            if (PyErr_ExceptionMatches(PyExc_TypeError))
            {
                PyErr_Clear();
                Py_RETURN_NOTIMPLEMENTED;
            }

            return nullptr;
        }
    }

    static PyObject* _mul_Vector3(PyObject* left, PyObject* right) noexcept
    {
        try
        {
            py::pyobj_handle left_float{PyNumber_Float(left)};
            if (left_float)
            {
                auto _left_float = PyFloat_AsDouble(left_float.get());
                if (_left_float == -1 && PyErr_Occurred())
                {
                    return nullptr;
                }
                auto _result = static_cast<float>(_left_float) * py::convert_to<winrt::Windows::Foundation::Numerics::float3>(right);
                return py::convert(_result);
            }
            else
            {
                PyErr_Clear();
            }

            auto _left = py::convert_to<winrt::Windows::Foundation::Numerics::float3>(left);

            py::pyobj_handle right_float{PyNumber_Float(right)};
            if (right_float)
            {
                auto _right_float = PyFloat_AsDouble(right_float.get());
                if (_right_float == -1 && PyErr_Occurred())
                {
                    return nullptr;
                }

                auto _result = _left * static_cast<float>(_right_float);
                return py::convert(_result);
            }
            else
            {
                PyErr_Clear();
            }

            auto _right = py::convert_to<winrt::Windows::Foundation::Numerics::float3>(right);

            auto _result = _left * _right;
            return py::convert(_result);
        }
        catch (...)
        {
            py::to_PyErr();

            if (PyErr_ExceptionMatches(PyExc_TypeError))
            {
                PyErr_Clear();
                Py_RETURN_NOTIMPLEMENTED;
            }

            return nullptr;
        }
    }

    static PyObject* _truediv_Vector3(PyObject* left, PyObject* right) noexcept
    {
        try
        {
            auto _left = py::convert_to<winrt::Windows::Foundation::Numerics::float3>(left);

            py::pyobj_handle right_float{PyNumber_Float(right)};
            if (right_float)
            {
                auto _right_float = PyFloat_AsDouble(right_float.get());
                if (_right_float == -1 && PyErr_Occurred())
                {
                    return nullptr;
                }

                auto _result = _left / static_cast<float>(_right_float);
                return py::convert(_result);
            }
            else
            {
                PyErr_Clear();
            }
            auto _right = py::convert_to<winrt::Windows::Foundation::Numerics::float3>(right);

            auto _result = _left / _right;
            return py::convert(_result);
        }
        catch (...)
        {
            py::to_PyErr();

            if (PyErr_ExceptionMatches(PyExc_TypeError))
            {
                PyErr_Clear();
                Py_RETURN_NOTIMPLEMENTED;
            }

            return nullptr;
        }
    }

    static PyObject* _neg_Vector3(PyObject* operand) noexcept
    {
        try
        {
            auto _operand = py::convert_to<winrt::Windows::Foundation::Numerics::float3>(operand);
            auto _result = -_operand;
            return py::convert(_result);
        }
        catch (...)
        {
            py::to_PyErr();

            if (PyErr_ExceptionMatches(PyExc_TypeError))
            {
                PyErr_Clear();
                Py_RETURN_NOTIMPLEMENTED;
            }

            return nullptr;
        }
    }

    static PyObject* _abs_Vector3(PyObject* operand) noexcept
    {
        try
        {
            auto _operand = py::convert_to<winrt::Windows::Foundation::Numerics::float3>(operand);
            auto _result = winrt::Windows::Foundation::Numerics::length(_operand);
            return py::convert(_result);
        }
        catch (...)
        {
            py::to_PyErr();

            if (PyErr_ExceptionMatches(PyExc_TypeError))
            {
                PyErr_Clear();
                Py_RETURN_NOTIMPLEMENTED;
            }

            return nullptr;
        }
    }

    static PyObject* _richcompare_Vector3(py::wrapper::Windows::Foundation::Numerics::Vector3* self, PyObject* other, int op) noexcept
    {
        try
        {
            auto _other = py::convert_to<winrt::Windows::Foundation::Numerics::float3>(other);

            if (op == Py_EQ)
            {
                if (self->obj == _other)
                {
                    Py_RETURN_TRUE;
                }

                Py_RETURN_FALSE;
            }

            if (op == Py_NE)
            {
                if (self->obj != _other)
                {
                    Py_RETURN_TRUE;
                }

                Py_RETURN_FALSE;
            }

            Py_RETURN_NOTIMPLEMENTED;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _repr_Vector3(PyObject* self) noexcept
    {
        py::pyobj_handle X{PyObject_GetAttrString(self, "x")};
        if (!X)
        {
            return nullptr;
        }

        py::pyobj_handle Y{PyObject_GetAttrString(self, "y")};
        if (!Y)
        {
            return nullptr;
        }

        py::pyobj_handle Z{PyObject_GetAttrString(self, "z")};
        if (!Z)
        {
            return nullptr;
        }

        return PyUnicode_FromFormat("Vector3(x=%R, y=%R, z=%R)", X.get(), Y.get(), Z.get());
    }

    static PyType_Slot _type_slots_Vector3[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_Vector3) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_Vector3) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_Vector3) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_Vector3) },
        { Py_nb_add, reinterpret_cast<void*>(_add_Vector3) },
        { Py_nb_subtract, reinterpret_cast<void*>(_sub_Vector3) },
        { Py_nb_multiply, reinterpret_cast<void*>(_mul_Vector3) },
        { Py_nb_true_divide, reinterpret_cast<void*>(_truediv_Vector3) },
        { Py_nb_negative, reinterpret_cast<void*>(_neg_Vector3) },
        { Py_nb_absolute, reinterpret_cast<void*>(_abs_Vector3) },
        { Py_tp_richcompare, reinterpret_cast<void*>(_richcompare_Vector3) },
        { Py_tp_repr, reinterpret_cast<void*>(_repr_Vector3) },
        { }};

    static PyType_Spec type_spec_Vector3 = {
        "winrt._winrt_windows_foundation_numerics.Vector3",
        sizeof(py::wrapper::Windows::Foundation::Numerics::Vector3),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_Vector3};

    static PyGetSetDef getset_Vector3_Static[] = {
        { "zero", _get_zero_Vector3, nullptr, nullptr, nullptr },
        { "one", _get_one_Vector3, nullptr, nullptr, nullptr },
        { "unit_x", _get_unit_x_Vector3, nullptr, nullptr, nullptr },
        { "unit_y", _get_unit_y_Vector3, nullptr, nullptr, nullptr },
        { "unit_z", _get_unit_z_Vector3, nullptr, nullptr, nullptr },
        { }};

    static PyMethodDef methods_Vector3_Static[] = {
        { }};

    static PyType_Slot type_slots_Vector3_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_Vector3_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_Vector3_Static) },
        { }
    };

    static PyType_Spec type_spec_Vector3_Static = {
        "winrt._winrt_windows_foundation_numerics.Vector3_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_Vector3_Static};

    // ----- Vector4 struct --------------------

    winrt::Windows::Foundation::Numerics::float4 Vector4_from_tuple(PyObject* tuple)
    {
        if (PyTuple_GET_SIZE(tuple) != 4)
        {
            PyErr_SetString(PyExc_TypeError, "Incorrect number of fields");
            throw python_exception();
        }

        winrt::Windows::Foundation::Numerics::float4 result{};

        result.x = py::convert_to<float>(tuple, 0);
        result.y = py::convert_to<float>(tuple, 1);
        result.z = py::convert_to<float>(tuple, 2);
        result.w = py::convert_to<float>(tuple, 3);

        return result;
    }

    PyObject* _new_Vector4(PyTypeObject* subclass, PyObject* args, PyObject* kwds) noexcept
    {
        pyobj_handle self_obj{(subclass->tp_alloc(subclass, 0))};
        if (!self_obj)
        {
            return nullptr;
        }

        auto self = reinterpret_cast<winrt_struct_wrapper<winrt::Windows::Foundation::Numerics::float4>*>(self_obj.get());
        std::construct_at(&self->obj);

        auto tuple_size = PyTuple_GET_SIZE(args);
        if ((tuple_size == 0) && (!kwds))
        {
            return self_obj.detach();
        }

        float _X{};
        float _Y{};
        float _Z{};
        float _W{};

        static const char* kwlist[] = {"x", "y", "z", "w", nullptr};
        if (!PyArg_ParseTupleAndKeywords(args, kwds, "|ffff", const_cast<char**>(kwlist), &_X, &_Y, &_Z, &_W))
        {
            return nullptr;
        }

        try
        {
            self->obj.x = _X;
            self->obj.y = _Y;
            self->obj.z = _Z;
            self->obj.w = _W;

            return self_obj.detach();
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static void _dealloc_Vector4(py::wrapper::Windows::Foundation::Numerics::Vector4* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _get_zero_Vector4(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        return py::convert(winrt::Windows::Foundation::Numerics::float4::zero());
    }

    static PyObject* _get_one_Vector4(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        return py::convert(winrt::Windows::Foundation::Numerics::float4::one());
    }

    static PyObject* _get_unit_x_Vector4(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        return py::convert(winrt::Windows::Foundation::Numerics::float4::unit_x());
    }

    static PyObject* _get_unit_y_Vector4(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        return py::convert(winrt::Windows::Foundation::Numerics::float4::unit_y());
    }

    static PyObject* _get_unit_z_Vector4(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        return py::convert(winrt::Windows::Foundation::Numerics::float4::unit_z());
    }

    static PyObject* _get_unit_w_Vector4(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        return py::convert(winrt::Windows::Foundation::Numerics::float4::unit_w());
    }

    static PyObject* length_Vector4(winrt_struct_wrapper<winrt::Windows::Foundation::Numerics::float4>* self, PyObject* /*unused*/) noexcept
    {
        try
        {
            auto _result = winrt::Windows::Foundation::Numerics::length(self->obj);
            return py::convert(_result);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* length_squared_Vector4(winrt_struct_wrapper<winrt::Windows::Foundation::Numerics::float4>* self, PyObject* /*unused*/) noexcept
    {
        try
        {
            auto _result = winrt::Windows::Foundation::Numerics::length_squared(self->obj);
            return py::convert(_result);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* distance_Vector4(winrt_struct_wrapper<winrt::Windows::Foundation::Numerics::float4>* self, PyObject* arg) noexcept
    {
        try
        {
            auto _arg = py::convert_to<winrt::Windows::Foundation::Numerics::float4>(arg);
            auto _result = winrt::Windows::Foundation::Numerics::distance(self->obj, _arg);
            return py::convert(_result);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* distance_squared_Vector4(winrt_struct_wrapper<winrt::Windows::Foundation::Numerics::float4>* self, PyObject* arg) noexcept
    {
        try
        {
            auto _arg = py::convert_to<winrt::Windows::Foundation::Numerics::float4>(arg);
            auto _result = winrt::Windows::Foundation::Numerics::distance_squared(self->obj, _arg);
            return py::convert(_result);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* dot_Vector4(winrt_struct_wrapper<winrt::Windows::Foundation::Numerics::float4>* self, PyObject* arg) noexcept
    {
        try
        {
            auto _arg = py::convert_to<winrt::Windows::Foundation::Numerics::float4>(arg);
            auto _result = winrt::Windows::Foundation::Numerics::dot(self->obj, _arg);
            return py::convert(_result);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* normalize_Vector4(winrt_struct_wrapper<winrt::Windows::Foundation::Numerics::float4>* self, PyObject* /*unused*/) noexcept
    {
        try
        {
            auto _result = winrt::Windows::Foundation::Numerics::normalize(self->obj);
            return py::convert(_result);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* min_Vector4(winrt_struct_wrapper<winrt::Windows::Foundation::Numerics::float4>* self, PyObject* arg) noexcept
    {
        try
        {
            auto _arg = py::convert_to<winrt::Windows::Foundation::Numerics::float4>(arg);
            auto _result = winrt::Windows::Foundation::Numerics::min(self->obj, _arg);
            return py::convert(_result);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* max_Vector4(winrt_struct_wrapper<winrt::Windows::Foundation::Numerics::float4>* self, PyObject* arg) noexcept
    {
        try
        {
            auto _arg = py::convert_to<winrt::Windows::Foundation::Numerics::float4>(arg);
            auto _result = winrt::Windows::Foundation::Numerics::max(self->obj, _arg);
            return py::convert(_result);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* clamp_Vector4(winrt_struct_wrapper<winrt::Windows::Foundation::Numerics::float4>* self, PyObject* args) noexcept
    {
        try
        {
            auto _arg0 = py::convert_to<winrt::Windows::Foundation::Numerics::float4>(args, 0);
            auto _arg1 = py::convert_to<winrt::Windows::Foundation::Numerics::float4>(args, 1);
            auto _result = winrt::Windows::Foundation::Numerics::clamp(self->obj, _arg0, _arg1);
            return py::convert(_result);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* lerp_Vector4(winrt_struct_wrapper<winrt::Windows::Foundation::Numerics::float4>* self, PyObject* args) noexcept
    {
        try
        {
            auto _arg0 = py::convert_to<winrt::Windows::Foundation::Numerics::float4>(args, 0);
            auto _arg1 = py::convert_to<float>(args, 1);
            auto _result = winrt::Windows::Foundation::Numerics::lerp(self->obj, _arg0, _arg1);
            return py::convert(_result);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* transform_Vector4(winrt_struct_wrapper<winrt::Windows::Foundation::Numerics::float4>* self, PyObject* arg) noexcept
    {
        try
        {
            if (std::string_view(Py_TYPE(arg)->tp_name) == "Matrix4x4" || std::string_view(Py_TYPE(arg)->tp_name) == "winrt._winrt_windows_foundation_numerics.Matrix4x4")
            {
#if defined(__MINGW32__)
                PyErr_SetString(PyExc_NotImplementedError, "Overload for Matrix4x4 is not implemented on MinGW");
                return nullptr;
#else
                auto _arg = py::convert_to<winrt::Windows::Foundation::Numerics::float4x4>(arg);
                auto _result = winrt::Windows::Foundation::Numerics::transform(self->obj, _arg);
                return py::convert(_result);
#endif
            }

            if (std::string_view(Py_TYPE(arg)->tp_name) == "Quaternion" || std::string_view(Py_TYPE(arg)->tp_name) == "winrt._winrt_windows_foundation_numerics.Quaternion")
            {
                auto _arg = py::convert_to<winrt::Windows::Foundation::Numerics::quaternion>(arg);
                auto _result = winrt::Windows::Foundation::Numerics::transform(self->obj, _arg);
                return py::convert(_result);
            }

            PyErr_Format(PyExc_TypeError, "Expecting one of 'winrt._winrt_windows_foundation_numerics.Matrix4x4', 'winrt._winrt_windows_foundation_numerics.Quaternion' but got '%s'", Py_TYPE(arg)->tp_name);
            return nullptr;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_Vector4(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Foundation::Numerics::float4>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    PyObject* _replace_Vector4(py::wrapper::Windows::Foundation::Numerics::Vector4* self, PyObject* args, PyObject* kwds) noexcept
    {
        try
        {
            float _X{self->obj.x};
            float _Y{self->obj.y};
            float _Z{self->obj.z};
            float _W{self->obj.w};

            static const char* kwlist[] = {"x", "y", "z", "w", nullptr};
            if (!PyArg_ParseTupleAndKeywords(args, kwds, "|$ffff", const_cast<char**>(kwlist), &_X, &_Y, &_Z, &_W))
            {
                return nullptr;
            }

            auto copy = self->obj;
            copy.x = _X;
            copy.y = _Y;
            copy.z = _Z;
            copy.w = _W;

            return convert(copy);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    PyObject* unpack_Vector4(py::wrapper::Windows::Foundation::Numerics::Vector4* self, PyObject* /*unused*/) noexcept
    {
        py::pyobj_handle X{convert(self->obj.x)};
        if (!X)
        {
            return nullptr;
        }

        py::pyobj_handle Y{convert(self->obj.y)};
        if (!Y)
        {
            return nullptr;
        }

        py::pyobj_handle Z{convert(self->obj.z)};
        if (!Z)
        {
            return nullptr;
        }

        py::pyobj_handle W{convert(self->obj.w)};
        if (!W)
        {
            return nullptr;
        }

        pyobj_handle tuple{PyTuple_New(4)};
        if (!tuple)
        {
            return nullptr;
        }

        PyTuple_SET_ITEM(tuple.get(), 0, X.detach());
        PyTuple_SET_ITEM(tuple.get(), 1, Y.detach());
        PyTuple_SET_ITEM(tuple.get(), 2, Z.detach());
        PyTuple_SET_ITEM(tuple.get(), 3, W.detach());

        return tuple.detach();
    }

    static PyMethodDef _methods_Vector4[] = {
        { "length", reinterpret_cast<PyCFunction>(length_Vector4), METH_NOARGS, nullptr },
        { "length_squared", reinterpret_cast<PyCFunction>(length_squared_Vector4), METH_NOARGS, nullptr },
        { "distance", reinterpret_cast<PyCFunction>(distance_Vector4), METH_O, nullptr },
        { "distance_squared", reinterpret_cast<PyCFunction>(distance_squared_Vector4), METH_O, nullptr },
        { "dot", reinterpret_cast<PyCFunction>(dot_Vector4), METH_O, nullptr },
        { "normalize", reinterpret_cast<PyCFunction>(normalize_Vector4), METH_NOARGS, nullptr },
        { "min", reinterpret_cast<PyCFunction>(min_Vector4), METH_O, nullptr },
        { "max", reinterpret_cast<PyCFunction>(max_Vector4), METH_O, nullptr },
        { "clamp", reinterpret_cast<PyCFunction>(clamp_Vector4), METH_VARARGS, nullptr },
        { "lerp", reinterpret_cast<PyCFunction>(lerp_Vector4), METH_VARARGS, nullptr },
        { "transform", reinterpret_cast<PyCFunction>(transform_Vector4), METH_O, nullptr },
        { "_assign_array_", _assign_array_Vector4, METH_O | METH_STATIC, nullptr },
        { "__replace__", reinterpret_cast<PyCFunction>(reinterpret_cast<void*>(_replace_Vector4)), METH_VARARGS | METH_KEYWORDS, nullptr },
        { "unpack", reinterpret_cast<PyCFunction>(unpack_Vector4), METH_NOARGS, nullptr },
        { }};

    static PyObject* Vector4_get_X(py::wrapper::Windows::Foundation::Numerics::Vector4* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.x);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Vector4_get_Y(py::wrapper::Windows::Foundation::Numerics::Vector4* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.y);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Vector4_get_Z(py::wrapper::Windows::Foundation::Numerics::Vector4* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.z);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Vector4_get_W(py::wrapper::Windows::Foundation::Numerics::Vector4* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.w);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyGetSetDef _getset_Vector4[] = {
        { "x", reinterpret_cast<getter>(Vector4_get_X), nullptr, nullptr, nullptr },
        { "y", reinterpret_cast<getter>(Vector4_get_Y), nullptr, nullptr, nullptr },
        { "z", reinterpret_cast<getter>(Vector4_get_Z), nullptr, nullptr, nullptr },
        { "w", reinterpret_cast<getter>(Vector4_get_W), nullptr, nullptr, nullptr },
        { }};

    static PyObject* _add_Vector4(PyObject* left, PyObject* right) noexcept
    {
        try
        {
            auto _left = py::convert_to<winrt::Windows::Foundation::Numerics::float4>(left);
            auto _right = py::convert_to<winrt::Windows::Foundation::Numerics::float4>(right);

            auto _result = _left + _right;
            return py::convert(_result);
        }
        catch (...)
        {
            py::to_PyErr();

            if (PyErr_ExceptionMatches(PyExc_TypeError))
            {
                PyErr_Clear();
                Py_RETURN_NOTIMPLEMENTED;
            }

            return nullptr;
        }
    }

    static PyObject* _sub_Vector4(PyObject* left, PyObject* right) noexcept
    {
        try
        {
            auto _left = py::convert_to<winrt::Windows::Foundation::Numerics::float4>(left);
            auto _right = py::convert_to<winrt::Windows::Foundation::Numerics::float4>(right);

            auto _result = _left - _right;
            return py::convert(_result);
        }
        catch (...)
        {
            py::to_PyErr();

            if (PyErr_ExceptionMatches(PyExc_TypeError))
            {
                PyErr_Clear();
                Py_RETURN_NOTIMPLEMENTED;
            }

            return nullptr;
        }
    }

    static PyObject* _mul_Vector4(PyObject* left, PyObject* right) noexcept
    {
        try
        {
            py::pyobj_handle left_float{PyNumber_Float(left)};
            if (left_float)
            {
                auto _left_float = PyFloat_AsDouble(left_float.get());
                if (_left_float == -1 && PyErr_Occurred())
                {
                    return nullptr;
                }
                auto _result = static_cast<float>(_left_float) * py::convert_to<winrt::Windows::Foundation::Numerics::float4>(right);
                return py::convert(_result);
            }
            else
            {
                PyErr_Clear();
            }

            auto _left = py::convert_to<winrt::Windows::Foundation::Numerics::float4>(left);

            py::pyobj_handle right_float{PyNumber_Float(right)};
            if (right_float)
            {
                auto _right_float = PyFloat_AsDouble(right_float.get());
                if (_right_float == -1 && PyErr_Occurred())
                {
                    return nullptr;
                }

                auto _result = _left * static_cast<float>(_right_float);
                return py::convert(_result);
            }
            else
            {
                PyErr_Clear();
            }

            auto _right = py::convert_to<winrt::Windows::Foundation::Numerics::float4>(right);

            auto _result = _left * _right;
            return py::convert(_result);
        }
        catch (...)
        {
            py::to_PyErr();

            if (PyErr_ExceptionMatches(PyExc_TypeError))
            {
                PyErr_Clear();
                Py_RETURN_NOTIMPLEMENTED;
            }

            return nullptr;
        }
    }

    static PyObject* _truediv_Vector4(PyObject* left, PyObject* right) noexcept
    {
        try
        {
            auto _left = py::convert_to<winrt::Windows::Foundation::Numerics::float4>(left);

            py::pyobj_handle right_float{PyNumber_Float(right)};
            if (right_float)
            {
                auto _right_float = PyFloat_AsDouble(right_float.get());
                if (_right_float == -1 && PyErr_Occurred())
                {
                    return nullptr;
                }

                auto _result = _left / static_cast<float>(_right_float);
                return py::convert(_result);
            }
            else
            {
                PyErr_Clear();
            }
            auto _right = py::convert_to<winrt::Windows::Foundation::Numerics::float4>(right);

            auto _result = _left / _right;
            return py::convert(_result);
        }
        catch (...)
        {
            py::to_PyErr();

            if (PyErr_ExceptionMatches(PyExc_TypeError))
            {
                PyErr_Clear();
                Py_RETURN_NOTIMPLEMENTED;
            }

            return nullptr;
        }
    }

    static PyObject* _neg_Vector4(PyObject* operand) noexcept
    {
        try
        {
            auto _operand = py::convert_to<winrt::Windows::Foundation::Numerics::float4>(operand);
            auto _result = -_operand;
            return py::convert(_result);
        }
        catch (...)
        {
            py::to_PyErr();

            if (PyErr_ExceptionMatches(PyExc_TypeError))
            {
                PyErr_Clear();
                Py_RETURN_NOTIMPLEMENTED;
            }

            return nullptr;
        }
    }

    static PyObject* _abs_Vector4(PyObject* operand) noexcept
    {
        try
        {
            auto _operand = py::convert_to<winrt::Windows::Foundation::Numerics::float4>(operand);
            auto _result = winrt::Windows::Foundation::Numerics::length(_operand);
            return py::convert(_result);
        }
        catch (...)
        {
            py::to_PyErr();

            if (PyErr_ExceptionMatches(PyExc_TypeError))
            {
                PyErr_Clear();
                Py_RETURN_NOTIMPLEMENTED;
            }

            return nullptr;
        }
    }

    static PyObject* _richcompare_Vector4(py::wrapper::Windows::Foundation::Numerics::Vector4* self, PyObject* other, int op) noexcept
    {
        try
        {
            auto _other = py::convert_to<winrt::Windows::Foundation::Numerics::float4>(other);

            if (op == Py_EQ)
            {
                if (self->obj == _other)
                {
                    Py_RETURN_TRUE;
                }

                Py_RETURN_FALSE;
            }

            if (op == Py_NE)
            {
                if (self->obj != _other)
                {
                    Py_RETURN_TRUE;
                }

                Py_RETURN_FALSE;
            }

            Py_RETURN_NOTIMPLEMENTED;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _repr_Vector4(PyObject* self) noexcept
    {
        py::pyobj_handle X{PyObject_GetAttrString(self, "x")};
        if (!X)
        {
            return nullptr;
        }

        py::pyobj_handle Y{PyObject_GetAttrString(self, "y")};
        if (!Y)
        {
            return nullptr;
        }

        py::pyobj_handle Z{PyObject_GetAttrString(self, "z")};
        if (!Z)
        {
            return nullptr;
        }

        py::pyobj_handle W{PyObject_GetAttrString(self, "w")};
        if (!W)
        {
            return nullptr;
        }

        return PyUnicode_FromFormat("Vector4(x=%R, y=%R, z=%R, w=%R)", X.get(), Y.get(), Z.get(), W.get());
    }

    static PyType_Slot _type_slots_Vector4[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_Vector4) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_Vector4) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_Vector4) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_Vector4) },
        { Py_nb_add, reinterpret_cast<void*>(_add_Vector4) },
        { Py_nb_subtract, reinterpret_cast<void*>(_sub_Vector4) },
        { Py_nb_multiply, reinterpret_cast<void*>(_mul_Vector4) },
        { Py_nb_true_divide, reinterpret_cast<void*>(_truediv_Vector4) },
        { Py_nb_negative, reinterpret_cast<void*>(_neg_Vector4) },
        { Py_nb_absolute, reinterpret_cast<void*>(_abs_Vector4) },
        { Py_tp_richcompare, reinterpret_cast<void*>(_richcompare_Vector4) },
        { Py_tp_repr, reinterpret_cast<void*>(_repr_Vector4) },
        { }};

    static PyType_Spec type_spec_Vector4 = {
        "winrt._winrt_windows_foundation_numerics.Vector4",
        sizeof(py::wrapper::Windows::Foundation::Numerics::Vector4),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_Vector4};

    static PyGetSetDef getset_Vector4_Static[] = {
        { "zero", _get_zero_Vector4, nullptr, nullptr, nullptr },
        { "one", _get_one_Vector4, nullptr, nullptr, nullptr },
        { "unit_x", _get_unit_x_Vector4, nullptr, nullptr, nullptr },
        { "unit_y", _get_unit_y_Vector4, nullptr, nullptr, nullptr },
        { "unit_z", _get_unit_z_Vector4, nullptr, nullptr, nullptr },
        { "unit_w", _get_unit_w_Vector4, nullptr, nullptr, nullptr },
        { }};

    static PyMethodDef methods_Vector4_Static[] = {
        { }};

    static PyType_Slot type_slots_Vector4_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_Vector4_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_Vector4_Static) },
        { }
    };

    static PyType_Spec type_spec_Vector4_Static = {
        "winrt._winrt_windows_foundation_numerics.Vector4_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_Vector4_Static};

    // ----- Windows.Foundation.Numerics Initialization --------------------

    PyDoc_STRVAR(module_doc, "Windows.Foundation.Numerics");

    static PyModuleDef module_def = {
        PyModuleDef_HEAD_INIT,
        "_winrt_windows_foundation_numerics",
        module_doc,
        0,
        nullptr,
        nullptr,
        nullptr,
        nullptr,
        nullptr};
} // py::cpp::Windows::Foundation::Numerics

PyMODINIT_FUNC PyInit__winrt_windows_foundation_numerics(void) noexcept
{
    using namespace py::cpp::Windows::Foundation::Numerics;

    if (py::import_winrt_runtime() == -1)
    {
        return nullptr;
    }

    py::pyobj_handle module{PyModule_Create(&module_def)};

    if (!module)
    {
        return nullptr;
    }

    auto object_type = py::get_object_type();
    if (!object_type)
    {
        return nullptr;
    }

    py::pyobj_handle object_bases{PyTuple_Pack(1, object_type)};

    if (!object_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_Matrix3x2_Static{PyType_FromSpec(&type_spec_Matrix3x2_Static)};
    if (!type_Matrix3x2_Static)
    {
        return nullptr;
    }

    py::pytype_handle Matrix3x2_type{py::register_python_type(module.get(), &type_spec_Matrix3x2, nullptr, reinterpret_cast<PyTypeObject*>(type_Matrix3x2_Static.get()))};
    if (!Matrix3x2_type)
    {
        return nullptr;
    }

    py::pyobj_handle Matrix3x2_from_tuple_capsule{PyCapsule_New(reinterpret_cast<void*>(Matrix3x2_from_tuple),"winrt._winrt_windows_foundation_numerics.Matrix3x2_from_tuple", nullptr)};
    if (!Matrix3x2_from_tuple_capsule)
    {
        return nullptr;
    }

    if (PyModule_AddObjectRef(module.get(), "Matrix3x2_from_tuple", Matrix3x2_from_tuple_capsule.get()) == -1)
    {
        return nullptr;
    }
    py::pyobj_handle type_Matrix4x4_Static{PyType_FromSpec(&type_spec_Matrix4x4_Static)};
    if (!type_Matrix4x4_Static)
    {
        return nullptr;
    }

    py::pytype_handle Matrix4x4_type{py::register_python_type(module.get(), &type_spec_Matrix4x4, nullptr, reinterpret_cast<PyTypeObject*>(type_Matrix4x4_Static.get()))};
    if (!Matrix4x4_type)
    {
        return nullptr;
    }

    py::pyobj_handle Matrix4x4_from_tuple_capsule{PyCapsule_New(reinterpret_cast<void*>(Matrix4x4_from_tuple),"winrt._winrt_windows_foundation_numerics.Matrix4x4_from_tuple", nullptr)};
    if (!Matrix4x4_from_tuple_capsule)
    {
        return nullptr;
    }

    if (PyModule_AddObjectRef(module.get(), "Matrix4x4_from_tuple", Matrix4x4_from_tuple_capsule.get()) == -1)
    {
        return nullptr;
    }
    py::pyobj_handle type_Plane_Static{PyType_FromSpec(&type_spec_Plane_Static)};
    if (!type_Plane_Static)
    {
        return nullptr;
    }

    py::pytype_handle Plane_type{py::register_python_type(module.get(), &type_spec_Plane, nullptr, reinterpret_cast<PyTypeObject*>(type_Plane_Static.get()))};
    if (!Plane_type)
    {
        return nullptr;
    }

    py::pyobj_handle Plane_from_tuple_capsule{PyCapsule_New(reinterpret_cast<void*>(Plane_from_tuple),"winrt._winrt_windows_foundation_numerics.Plane_from_tuple", nullptr)};
    if (!Plane_from_tuple_capsule)
    {
        return nullptr;
    }

    if (PyModule_AddObjectRef(module.get(), "Plane_from_tuple", Plane_from_tuple_capsule.get()) == -1)
    {
        return nullptr;
    }
    py::pyobj_handle type_Quaternion_Static{PyType_FromSpec(&type_spec_Quaternion_Static)};
    if (!type_Quaternion_Static)
    {
        return nullptr;
    }

    py::pytype_handle Quaternion_type{py::register_python_type(module.get(), &type_spec_Quaternion, nullptr, reinterpret_cast<PyTypeObject*>(type_Quaternion_Static.get()))};
    if (!Quaternion_type)
    {
        return nullptr;
    }

    py::pyobj_handle Quaternion_from_tuple_capsule{PyCapsule_New(reinterpret_cast<void*>(Quaternion_from_tuple),"winrt._winrt_windows_foundation_numerics.Quaternion_from_tuple", nullptr)};
    if (!Quaternion_from_tuple_capsule)
    {
        return nullptr;
    }

    if (PyModule_AddObjectRef(module.get(), "Quaternion_from_tuple", Quaternion_from_tuple_capsule.get()) == -1)
    {
        return nullptr;
    }
    py::pytype_handle Rational_type{py::register_python_type(module.get(), &type_spec_Rational, nullptr, nullptr)};
    if (!Rational_type)
    {
        return nullptr;
    }

    py::pyobj_handle Rational_from_tuple_capsule{PyCapsule_New(reinterpret_cast<void*>(Rational_from_tuple),"winrt._winrt_windows_foundation_numerics.Rational_from_tuple", nullptr)};
    if (!Rational_from_tuple_capsule)
    {
        return nullptr;
    }

    if (PyModule_AddObjectRef(module.get(), "Rational_from_tuple", Rational_from_tuple_capsule.get()) == -1)
    {
        return nullptr;
    }
    py::pyobj_handle type_Vector2_Static{PyType_FromSpec(&type_spec_Vector2_Static)};
    if (!type_Vector2_Static)
    {
        return nullptr;
    }

    py::pytype_handle Vector2_type{py::register_python_type(module.get(), &type_spec_Vector2, nullptr, reinterpret_cast<PyTypeObject*>(type_Vector2_Static.get()))};
    if (!Vector2_type)
    {
        return nullptr;
    }

    py::pyobj_handle Vector2_from_tuple_capsule{PyCapsule_New(reinterpret_cast<void*>(Vector2_from_tuple),"winrt._winrt_windows_foundation_numerics.Vector2_from_tuple", nullptr)};
    if (!Vector2_from_tuple_capsule)
    {
        return nullptr;
    }

    if (PyModule_AddObjectRef(module.get(), "Vector2_from_tuple", Vector2_from_tuple_capsule.get()) == -1)
    {
        return nullptr;
    }
    py::pyobj_handle type_Vector3_Static{PyType_FromSpec(&type_spec_Vector3_Static)};
    if (!type_Vector3_Static)
    {
        return nullptr;
    }

    py::pytype_handle Vector3_type{py::register_python_type(module.get(), &type_spec_Vector3, nullptr, reinterpret_cast<PyTypeObject*>(type_Vector3_Static.get()))};
    if (!Vector3_type)
    {
        return nullptr;
    }

    py::pyobj_handle Vector3_from_tuple_capsule{PyCapsule_New(reinterpret_cast<void*>(Vector3_from_tuple),"winrt._winrt_windows_foundation_numerics.Vector3_from_tuple", nullptr)};
    if (!Vector3_from_tuple_capsule)
    {
        return nullptr;
    }

    if (PyModule_AddObjectRef(module.get(), "Vector3_from_tuple", Vector3_from_tuple_capsule.get()) == -1)
    {
        return nullptr;
    }
    py::pyobj_handle type_Vector4_Static{PyType_FromSpec(&type_spec_Vector4_Static)};
    if (!type_Vector4_Static)
    {
        return nullptr;
    }

    py::pytype_handle Vector4_type{py::register_python_type(module.get(), &type_spec_Vector4, nullptr, reinterpret_cast<PyTypeObject*>(type_Vector4_Static.get()))};
    if (!Vector4_type)
    {
        return nullptr;
    }

    py::pyobj_handle Vector4_from_tuple_capsule{PyCapsule_New(reinterpret_cast<void*>(Vector4_from_tuple),"winrt._winrt_windows_foundation_numerics.Vector4_from_tuple", nullptr)};
    if (!Vector4_from_tuple_capsule)
    {
        return nullptr;
    }

    if (PyModule_AddObjectRef(module.get(), "Vector4_from_tuple", Vector4_from_tuple_capsule.get()) == -1)
    {
        return nullptr;
    }

    return module.detach();
}
