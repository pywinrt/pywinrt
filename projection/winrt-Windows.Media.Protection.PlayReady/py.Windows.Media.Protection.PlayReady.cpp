// WARNING: Please don't edit this file. It was generated by Python/WinRT v0.0.0

#include "py.Windows.Media.Protection.PlayReady.h"


namespace py::cpp::Windows::Media::Protection::PlayReady
{
    // ----- NDClient class --------------------

    static PyObject* _new_NDClient(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Protection::PlayReady::INDDownloadEngine>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Media::Protection::PlayReady::INDStreamParser>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Media::Protection::PlayReady::INDMessenger>(args, 2);

                winrt::Windows::Media::Protection::PlayReady::NDClient instance{ param0, param1, param2 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_NDClient(py::wrapper::Windows::Media::Protection::PlayReady::NDClient* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* NDClient_Close(py::wrapper::Windows::Media::Protection::PlayReady::NDClient* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Protection.PlayReady.NDClient", L"Close", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* NDClient_LicenseFetchAsync(py::wrapper::Windows::Media::Protection::PlayReady::NDClient* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Protection.PlayReady.NDClient", L"LicenseFetchAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Media::Protection::PlayReady::INDLicenseFetchDescriptor>(args, 0);

                return py::convert(self->obj.LicenseFetchAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* NDClient_ReRegistrationAsync(py::wrapper::Windows::Media::Protection::PlayReady::NDClient* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Protection.PlayReady.NDClient", L"ReRegistrationAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Media::Protection::PlayReady::INDCustomData>(args, 0);

                return py::convert(self->obj.ReRegistrationAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* NDClient_StartAsync(py::wrapper::Windows::Media::Protection::PlayReady::NDClient* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 4)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Protection.PlayReady.NDClient", L"StartAsync", 4))
                {
                    py::set_arg_count_version_error(4);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Media::Protection::PlayReady::INDCustomData>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::Media::Protection::PlayReady::INDLicenseFetchDescriptor>(args, 3);

                return py::convert(self->obj.StartAsync(param0, param1, param2, param3));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* NDClient_add_ClosedCaptionDataReceived(py::wrapper::Windows::Media::Protection::PlayReady::NDClient* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Protection.PlayReady.NDClient", L"ClosedCaptionDataReceived"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Protection::PlayReady::NDClient, winrt::Windows::Media::Protection::PlayReady::INDClosedCaptionDataReceivedEventArgs>>(arg);

            return py::convert(self->obj.ClosedCaptionDataReceived(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NDClient_remove_ClosedCaptionDataReceived(py::wrapper::Windows::Media::Protection::PlayReady::NDClient* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Protection.PlayReady.NDClient", L"ClosedCaptionDataReceived"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ClosedCaptionDataReceived(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NDClient_add_LicenseFetchCompleted(py::wrapper::Windows::Media::Protection::PlayReady::NDClient* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Protection.PlayReady.NDClient", L"LicenseFetchCompleted"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Protection::PlayReady::NDClient, winrt::Windows::Media::Protection::PlayReady::INDLicenseFetchCompletedEventArgs>>(arg);

            return py::convert(self->obj.LicenseFetchCompleted(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NDClient_remove_LicenseFetchCompleted(py::wrapper::Windows::Media::Protection::PlayReady::NDClient* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Protection.PlayReady.NDClient", L"LicenseFetchCompleted"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.LicenseFetchCompleted(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NDClient_add_ProximityDetectionCompleted(py::wrapper::Windows::Media::Protection::PlayReady::NDClient* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Protection.PlayReady.NDClient", L"ProximityDetectionCompleted"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Protection::PlayReady::NDClient, winrt::Windows::Media::Protection::PlayReady::INDProximityDetectionCompletedEventArgs>>(arg);

            return py::convert(self->obj.ProximityDetectionCompleted(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NDClient_remove_ProximityDetectionCompleted(py::wrapper::Windows::Media::Protection::PlayReady::NDClient* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Protection.PlayReady.NDClient", L"ProximityDetectionCompleted"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ProximityDetectionCompleted(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NDClient_add_ReRegistrationNeeded(py::wrapper::Windows::Media::Protection::PlayReady::NDClient* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Protection.PlayReady.NDClient", L"ReRegistrationNeeded"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Protection::PlayReady::NDClient, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.ReRegistrationNeeded(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NDClient_remove_ReRegistrationNeeded(py::wrapper::Windows::Media::Protection::PlayReady::NDClient* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Protection.PlayReady.NDClient", L"ReRegistrationNeeded"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ReRegistrationNeeded(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NDClient_add_RegistrationCompleted(py::wrapper::Windows::Media::Protection::PlayReady::NDClient* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Protection.PlayReady.NDClient", L"RegistrationCompleted"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Protection::PlayReady::NDClient, winrt::Windows::Media::Protection::PlayReady::INDRegistrationCompletedEventArgs>>(arg);

            return py::convert(self->obj.RegistrationCompleted(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NDClient_remove_RegistrationCompleted(py::wrapper::Windows::Media::Protection::PlayReady::NDClient* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Protection.PlayReady.NDClient", L"RegistrationCompleted"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.RegistrationCompleted(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_NDClient(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Protection::PlayReady::NDClient>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_NDClient(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Protection::PlayReady::NDClient>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_NDClient[] = {
        { "close", reinterpret_cast<PyCFunction>(NDClient_Close), METH_VARARGS, nullptr },
        { "license_fetch_async", reinterpret_cast<PyCFunction>(NDClient_LicenseFetchAsync), METH_VARARGS, nullptr },
        { "re_registration_async", reinterpret_cast<PyCFunction>(NDClient_ReRegistrationAsync), METH_VARARGS, nullptr },
        { "start_async", reinterpret_cast<PyCFunction>(NDClient_StartAsync), METH_VARARGS, nullptr },
        { "add_closed_caption_data_received", reinterpret_cast<PyCFunction>(NDClient_add_ClosedCaptionDataReceived), METH_O, nullptr },
        { "remove_closed_caption_data_received", reinterpret_cast<PyCFunction>(NDClient_remove_ClosedCaptionDataReceived), METH_O, nullptr },
        { "add_license_fetch_completed", reinterpret_cast<PyCFunction>(NDClient_add_LicenseFetchCompleted), METH_O, nullptr },
        { "remove_license_fetch_completed", reinterpret_cast<PyCFunction>(NDClient_remove_LicenseFetchCompleted), METH_O, nullptr },
        { "add_proximity_detection_completed", reinterpret_cast<PyCFunction>(NDClient_add_ProximityDetectionCompleted), METH_O, nullptr },
        { "remove_proximity_detection_completed", reinterpret_cast<PyCFunction>(NDClient_remove_ProximityDetectionCompleted), METH_O, nullptr },
        { "add_re_registration_needed", reinterpret_cast<PyCFunction>(NDClient_add_ReRegistrationNeeded), METH_O, nullptr },
        { "remove_re_registration_needed", reinterpret_cast<PyCFunction>(NDClient_remove_ReRegistrationNeeded), METH_O, nullptr },
        { "add_registration_completed", reinterpret_cast<PyCFunction>(NDClient_add_RegistrationCompleted), METH_O, nullptr },
        { "remove_registration_completed", reinterpret_cast<PyCFunction>(NDClient_remove_RegistrationCompleted), METH_O, nullptr },
        { "_assign_array_", _assign_array_NDClient, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_NDClient), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_NDClient[] = {
        { }
    };

    static PyType_Slot _type_slots_NDClient[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_NDClient) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_NDClient) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_NDClient) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_NDClient) },
        { },
    };

    static PyType_Spec type_spec_NDClient =
    {
        "winrt._winrt_windows_media_protection_playready.NDClient",
        sizeof(py::wrapper::Windows::Media::Protection::PlayReady::NDClient),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_NDClient
    };

    // ----- NDCustomData class --------------------

    static PyObject* _new_NDCustomData(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<py::pybuf_view<uint8_t, false>>(args, 0);
                auto param1 = py::convert_to<py::pybuf_view<uint8_t, false>>(args, 1);

                winrt::Windows::Media::Protection::PlayReady::NDCustomData instance{ param0, param1 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_NDCustomData(py::wrapper::Windows::Media::Protection::PlayReady::NDCustomData* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* NDCustomData_get_CustomData(py::wrapper::Windows::Media::Protection::PlayReady::NDCustomData* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.NDCustomData", L"CustomData"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CustomData());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NDCustomData_get_CustomDataTypeID(py::wrapper::Windows::Media::Protection::PlayReady::NDCustomData* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.NDCustomData", L"CustomDataTypeID"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CustomDataTypeID());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_NDCustomData(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Protection::PlayReady::NDCustomData>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_NDCustomData(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Protection::PlayReady::NDCustomData>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_NDCustomData[] = {
        { "_assign_array_", _assign_array_NDCustomData, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_NDCustomData), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_NDCustomData[] = {
        { "custom_data", reinterpret_cast<getter>(NDCustomData_get_CustomData), nullptr, nullptr, nullptr },
        { "custom_data_type_i_d", reinterpret_cast<getter>(NDCustomData_get_CustomDataTypeID), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_NDCustomData[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_NDCustomData) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_NDCustomData) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_NDCustomData) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_NDCustomData) },
        { },
    };

    static PyType_Spec type_spec_NDCustomData =
    {
        "winrt._winrt_windows_media_protection_playready.NDCustomData",
        sizeof(py::wrapper::Windows::Media::Protection::PlayReady::NDCustomData),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_NDCustomData
    };

    // ----- NDDownloadEngineNotifier class --------------------

    static PyObject* _new_NDDownloadEngineNotifier(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Media::Protection::PlayReady::NDDownloadEngineNotifier instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_NDDownloadEngineNotifier(py::wrapper::Windows::Media::Protection::PlayReady::NDDownloadEngineNotifier* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* NDDownloadEngineNotifier_OnContentIDReceived(py::wrapper::Windows::Media::Protection::PlayReady::NDDownloadEngineNotifier* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Protection.PlayReady.NDDownloadEngineNotifier", L"OnContentIDReceived", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Media::Protection::PlayReady::INDLicenseFetchDescriptor>(args, 0);

                self->obj.OnContentIDReceived(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* NDDownloadEngineNotifier_OnDataReceived(py::wrapper::Windows::Media::Protection::PlayReady::NDDownloadEngineNotifier* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Protection.PlayReady.NDDownloadEngineNotifier", L"OnDataReceived", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<py::pybuf_view<uint8_t, false>>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);

                self->obj.OnDataReceived(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* NDDownloadEngineNotifier_OnEndOfStream(py::wrapper::Windows::Media::Protection::PlayReady::NDDownloadEngineNotifier* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Protection.PlayReady.NDDownloadEngineNotifier", L"OnEndOfStream", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.OnEndOfStream();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* NDDownloadEngineNotifier_OnNetworkError(py::wrapper::Windows::Media::Protection::PlayReady::NDDownloadEngineNotifier* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Protection.PlayReady.NDDownloadEngineNotifier", L"OnNetworkError", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.OnNetworkError();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* NDDownloadEngineNotifier_OnPlayReadyObjectReceived(py::wrapper::Windows::Media::Protection::PlayReady::NDDownloadEngineNotifier* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Protection.PlayReady.NDDownloadEngineNotifier", L"OnPlayReadyObjectReceived", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<py::pybuf_view<uint8_t, false>>(args, 0);

                self->obj.OnPlayReadyObjectReceived(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* NDDownloadEngineNotifier_OnStreamOpened(py::wrapper::Windows::Media::Protection::PlayReady::NDDownloadEngineNotifier* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Protection.PlayReady.NDDownloadEngineNotifier", L"OnStreamOpened", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.OnStreamOpened();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_NDDownloadEngineNotifier(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Protection::PlayReady::NDDownloadEngineNotifier>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_NDDownloadEngineNotifier(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Protection::PlayReady::NDDownloadEngineNotifier>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_NDDownloadEngineNotifier[] = {
        { "on_content_i_d_received", reinterpret_cast<PyCFunction>(NDDownloadEngineNotifier_OnContentIDReceived), METH_VARARGS, nullptr },
        { "on_data_received", reinterpret_cast<PyCFunction>(NDDownloadEngineNotifier_OnDataReceived), METH_VARARGS, nullptr },
        { "on_end_of_stream", reinterpret_cast<PyCFunction>(NDDownloadEngineNotifier_OnEndOfStream), METH_VARARGS, nullptr },
        { "on_network_error", reinterpret_cast<PyCFunction>(NDDownloadEngineNotifier_OnNetworkError), METH_VARARGS, nullptr },
        { "on_play_ready_object_received", reinterpret_cast<PyCFunction>(NDDownloadEngineNotifier_OnPlayReadyObjectReceived), METH_VARARGS, nullptr },
        { "on_stream_opened", reinterpret_cast<PyCFunction>(NDDownloadEngineNotifier_OnStreamOpened), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_NDDownloadEngineNotifier, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_NDDownloadEngineNotifier), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_NDDownloadEngineNotifier[] = {
        { }
    };

    static PyType_Slot _type_slots_NDDownloadEngineNotifier[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_NDDownloadEngineNotifier) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_NDDownloadEngineNotifier) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_NDDownloadEngineNotifier) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_NDDownloadEngineNotifier) },
        { },
    };

    static PyType_Spec type_spec_NDDownloadEngineNotifier =
    {
        "winrt._winrt_windows_media_protection_playready.NDDownloadEngineNotifier",
        sizeof(py::wrapper::Windows::Media::Protection::PlayReady::NDDownloadEngineNotifier),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_NDDownloadEngineNotifier
    };

    // ----- NDLicenseFetchDescriptor class --------------------

    static PyObject* _new_NDLicenseFetchDescriptor(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Protection::PlayReady::NDContentIDType>(args, 0);
                auto param1 = py::convert_to<py::pybuf_view<uint8_t, false>>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Media::Protection::PlayReady::INDCustomData>(args, 2);

                winrt::Windows::Media::Protection::PlayReady::NDLicenseFetchDescriptor instance{ param0, param1, param2 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_NDLicenseFetchDescriptor(py::wrapper::Windows::Media::Protection::PlayReady::NDLicenseFetchDescriptor* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* NDLicenseFetchDescriptor_get_LicenseFetchChallengeCustomData(py::wrapper::Windows::Media::Protection::PlayReady::NDLicenseFetchDescriptor* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.NDLicenseFetchDescriptor", L"LicenseFetchChallengeCustomData"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.LicenseFetchChallengeCustomData());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int NDLicenseFetchDescriptor_put_LicenseFetchChallengeCustomData(py::wrapper::Windows::Media::Protection::PlayReady::NDLicenseFetchDescriptor* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.NDLicenseFetchDescriptor", L"LicenseFetchChallengeCustomData"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Media::Protection::PlayReady::INDCustomData>(arg);

            self->obj.LicenseFetchChallengeCustomData(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* NDLicenseFetchDescriptor_get_ContentID(py::wrapper::Windows::Media::Protection::PlayReady::NDLicenseFetchDescriptor* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.NDLicenseFetchDescriptor", L"ContentID"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ContentID());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NDLicenseFetchDescriptor_get_ContentIDType(py::wrapper::Windows::Media::Protection::PlayReady::NDLicenseFetchDescriptor* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.NDLicenseFetchDescriptor", L"ContentIDType"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ContentIDType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_NDLicenseFetchDescriptor(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Protection::PlayReady::NDLicenseFetchDescriptor>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_NDLicenseFetchDescriptor(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Protection::PlayReady::NDLicenseFetchDescriptor>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_NDLicenseFetchDescriptor[] = {
        { "_assign_array_", _assign_array_NDLicenseFetchDescriptor, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_NDLicenseFetchDescriptor), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_NDLicenseFetchDescriptor[] = {
        { "license_fetch_challenge_custom_data", reinterpret_cast<getter>(NDLicenseFetchDescriptor_get_LicenseFetchChallengeCustomData), reinterpret_cast<setter>(NDLicenseFetchDescriptor_put_LicenseFetchChallengeCustomData), nullptr, nullptr },
        { "content_i_d", reinterpret_cast<getter>(NDLicenseFetchDescriptor_get_ContentID), nullptr, nullptr, nullptr },
        { "content_i_d_type", reinterpret_cast<getter>(NDLicenseFetchDescriptor_get_ContentIDType), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_NDLicenseFetchDescriptor[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_NDLicenseFetchDescriptor) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_NDLicenseFetchDescriptor) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_NDLicenseFetchDescriptor) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_NDLicenseFetchDescriptor) },
        { },
    };

    static PyType_Spec type_spec_NDLicenseFetchDescriptor =
    {
        "winrt._winrt_windows_media_protection_playready.NDLicenseFetchDescriptor",
        sizeof(py::wrapper::Windows::Media::Protection::PlayReady::NDLicenseFetchDescriptor),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_NDLicenseFetchDescriptor
    };

    // ----- NDStorageFileHelper class --------------------

    static PyObject* _new_NDStorageFileHelper(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Media::Protection::PlayReady::NDStorageFileHelper instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_NDStorageFileHelper(py::wrapper::Windows::Media::Protection::PlayReady::NDStorageFileHelper* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* NDStorageFileHelper_GetFileURLs(py::wrapper::Windows::Media::Protection::PlayReady::NDStorageFileHelper* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Protection.PlayReady.NDStorageFileHelper", L"GetFileURLs", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFile>(args, 0);

                return py::convert(self->obj.GetFileURLs(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_NDStorageFileHelper(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Protection::PlayReady::NDStorageFileHelper>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_NDStorageFileHelper(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Protection::PlayReady::NDStorageFileHelper>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_NDStorageFileHelper[] = {
        { "get_file_u_r_ls", reinterpret_cast<PyCFunction>(NDStorageFileHelper_GetFileURLs), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_NDStorageFileHelper, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_NDStorageFileHelper), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_NDStorageFileHelper[] = {
        { }
    };

    static PyType_Slot _type_slots_NDStorageFileHelper[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_NDStorageFileHelper) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_NDStorageFileHelper) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_NDStorageFileHelper) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_NDStorageFileHelper) },
        { },
    };

    static PyType_Spec type_spec_NDStorageFileHelper =
    {
        "winrt._winrt_windows_media_protection_playready.NDStorageFileHelper",
        sizeof(py::wrapper::Windows::Media::Protection::PlayReady::NDStorageFileHelper),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_NDStorageFileHelper
    };

    // ----- NDStreamParserNotifier class --------------------

    static PyObject* _new_NDStreamParserNotifier(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Media::Protection::PlayReady::NDStreamParserNotifier instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_NDStreamParserNotifier(py::wrapper::Windows::Media::Protection::PlayReady::NDStreamParserNotifier* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* NDStreamParserNotifier_OnBeginSetupDecryptor(py::wrapper::Windows::Media::Protection::PlayReady::NDStreamParserNotifier* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Protection.PlayReady.NDStreamParserNotifier", L"OnBeginSetupDecryptor", 3))
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Media::Core::IMediaStreamDescriptor>(args, 0);
                auto param1 = py::convert_to<winrt::guid>(args, 1);
                auto param2 = py::convert_to<py::pybuf_view<uint8_t, false>>(args, 2);

                self->obj.OnBeginSetupDecryptor(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* NDStreamParserNotifier_OnContentIDReceived(py::wrapper::Windows::Media::Protection::PlayReady::NDStreamParserNotifier* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Protection.PlayReady.NDStreamParserNotifier", L"OnContentIDReceived", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Media::Protection::PlayReady::INDLicenseFetchDescriptor>(args, 0);

                self->obj.OnContentIDReceived(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* NDStreamParserNotifier_OnMediaStreamDescriptorCreated(py::wrapper::Windows::Media::Protection::PlayReady::NDStreamParserNotifier* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Protection.PlayReady.NDStreamParserNotifier", L"OnMediaStreamDescriptorCreated", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IVector<winrt::Windows::Media::Core::AudioStreamDescriptor>>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IVector<winrt::Windows::Media::Core::VideoStreamDescriptor>>(args, 1);

                self->obj.OnMediaStreamDescriptorCreated(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* NDStreamParserNotifier_OnSampleParsed(py::wrapper::Windows::Media::Protection::PlayReady::NDStreamParserNotifier* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 6)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Protection.PlayReady.NDStreamParserNotifier", L"OnSampleParsed", 6))
                {
                    py::set_arg_count_version_error(6);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Media::Protection::PlayReady::NDMediaStreamType>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Media::Core::MediaStreamSample>(args, 2);
                auto param3 = py::convert_to<int64_t>(args, 3);
                auto param4 = py::convert_to<winrt::Windows::Media::Protection::PlayReady::NDClosedCaptionFormat>(args, 4);
                auto param5 = py::convert_to<py::pybuf_view<uint8_t, false>>(args, 5);

                self->obj.OnSampleParsed(param0, param1, param2, param3, param4, param5);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_NDStreamParserNotifier(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Protection::PlayReady::NDStreamParserNotifier>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_NDStreamParserNotifier(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Protection::PlayReady::NDStreamParserNotifier>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_NDStreamParserNotifier[] = {
        { "on_begin_setup_decryptor", reinterpret_cast<PyCFunction>(NDStreamParserNotifier_OnBeginSetupDecryptor), METH_VARARGS, nullptr },
        { "on_content_i_d_received", reinterpret_cast<PyCFunction>(NDStreamParserNotifier_OnContentIDReceived), METH_VARARGS, nullptr },
        { "on_media_stream_descriptor_created", reinterpret_cast<PyCFunction>(NDStreamParserNotifier_OnMediaStreamDescriptorCreated), METH_VARARGS, nullptr },
        { "on_sample_parsed", reinterpret_cast<PyCFunction>(NDStreamParserNotifier_OnSampleParsed), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_NDStreamParserNotifier, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_NDStreamParserNotifier), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_NDStreamParserNotifier[] = {
        { }
    };

    static PyType_Slot _type_slots_NDStreamParserNotifier[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_NDStreamParserNotifier) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_NDStreamParserNotifier) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_NDStreamParserNotifier) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_NDStreamParserNotifier) },
        { },
    };

    static PyType_Spec type_spec_NDStreamParserNotifier =
    {
        "winrt._winrt_windows_media_protection_playready.NDStreamParserNotifier",
        sizeof(py::wrapper::Windows::Media::Protection::PlayReady::NDStreamParserNotifier),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_NDStreamParserNotifier
    };

    // ----- NDTCPMessenger class --------------------

    static PyObject* _new_NDTCPMessenger(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);

                winrt::Windows::Media::Protection::PlayReady::NDTCPMessenger instance{ param0, param1 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_NDTCPMessenger(py::wrapper::Windows::Media::Protection::PlayReady::NDTCPMessenger* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* NDTCPMessenger_SendLicenseFetchRequestAsync(py::wrapper::Windows::Media::Protection::PlayReady::NDTCPMessenger* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Protection.PlayReady.NDTCPMessenger", L"SendLicenseFetchRequestAsync", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<py::pybuf_view<uint8_t, false>>(args, 0);
                auto param1 = py::convert_to<py::pybuf_view<uint8_t, false>>(args, 1);

                return py::convert(self->obj.SendLicenseFetchRequestAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* NDTCPMessenger_SendProximityDetectionResponseAsync(py::wrapper::Windows::Media::Protection::PlayReady::NDTCPMessenger* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 4)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Protection.PlayReady.NDTCPMessenger", L"SendProximityDetectionResponseAsync", 4))
                {
                    py::set_arg_count_version_error(4);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Media::Protection::PlayReady::NDProximityDetectionType>(args, 0);
                auto param1 = py::convert_to<py::pybuf_view<uint8_t, false>>(args, 1);
                auto param2 = py::convert_to<py::pybuf_view<uint8_t, false>>(args, 2);
                auto param3 = py::convert_to<py::pybuf_view<uint8_t, false>>(args, 3);

                return py::convert(self->obj.SendProximityDetectionResponseAsync(param0, param1, param2, param3));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* NDTCPMessenger_SendProximityDetectionStartAsync(py::wrapper::Windows::Media::Protection::PlayReady::NDTCPMessenger* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 4)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Protection.PlayReady.NDTCPMessenger", L"SendProximityDetectionStartAsync", 4))
                {
                    py::set_arg_count_version_error(4);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Media::Protection::PlayReady::NDProximityDetectionType>(args, 0);
                auto param1 = py::convert_to<py::pybuf_view<uint8_t, false>>(args, 1);
                auto param2 = py::convert_to<py::pybuf_view<uint8_t, false>>(args, 2);
                auto param3 = py::convert_to<py::pybuf_view<uint8_t, false>>(args, 3);

                return py::convert(self->obj.SendProximityDetectionStartAsync(param0, param1, param2, param3));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* NDTCPMessenger_SendRegistrationRequestAsync(py::wrapper::Windows::Media::Protection::PlayReady::NDTCPMessenger* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Protection.PlayReady.NDTCPMessenger", L"SendRegistrationRequestAsync", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<py::pybuf_view<uint8_t, false>>(args, 0);
                auto param1 = py::convert_to<py::pybuf_view<uint8_t, false>>(args, 1);

                return py::convert(self->obj.SendRegistrationRequestAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_NDTCPMessenger(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Protection::PlayReady::NDTCPMessenger>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_NDTCPMessenger(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Protection::PlayReady::NDTCPMessenger>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_NDTCPMessenger[] = {
        { "send_license_fetch_request_async", reinterpret_cast<PyCFunction>(NDTCPMessenger_SendLicenseFetchRequestAsync), METH_VARARGS, nullptr },
        { "send_proximity_detection_response_async", reinterpret_cast<PyCFunction>(NDTCPMessenger_SendProximityDetectionResponseAsync), METH_VARARGS, nullptr },
        { "send_proximity_detection_start_async", reinterpret_cast<PyCFunction>(NDTCPMessenger_SendProximityDetectionStartAsync), METH_VARARGS, nullptr },
        { "send_registration_request_async", reinterpret_cast<PyCFunction>(NDTCPMessenger_SendRegistrationRequestAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_NDTCPMessenger, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_NDTCPMessenger), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_NDTCPMessenger[] = {
        { }
    };

    static PyType_Slot _type_slots_NDTCPMessenger[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_NDTCPMessenger) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_NDTCPMessenger) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_NDTCPMessenger) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_NDTCPMessenger) },
        { },
    };

    static PyType_Spec type_spec_NDTCPMessenger =
    {
        "winrt._winrt_windows_media_protection_playready.NDTCPMessenger",
        sizeof(py::wrapper::Windows::Media::Protection::PlayReady::NDTCPMessenger),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_NDTCPMessenger
    };

    // ----- PlayReadyContentHeader class --------------------

    static PyObject* _new_PlayReadyContentHeader(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 8)
        {
            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<py::pybuf_view<winrt::guid, false>>(args, 1);
                auto param2 = py::convert_to<py::pybuf_view<winrt::hstring, false>>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::Media::Protection::PlayReady::PlayReadyEncryptionAlgorithm>(args, 3);
                auto param4 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 4);
                auto param5 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 5);
                auto param6 = py::convert_to<winrt::hstring>(args, 6);
                auto param7 = py::convert_to<winrt::guid>(args, 7);

                winrt::Windows::Media::Protection::PlayReady::PlayReadyContentHeader instance{ param0, param1, param2, param3, param4, param5, param6, param7 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 5)
        {
            try
            {
                auto param0 = py::convert_to<py::pybuf_view<uint8_t, false>>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 2);
                auto param3 = py::convert_to<winrt::hstring>(args, 3);
                auto param4 = py::convert_to<winrt::guid>(args, 4);

                winrt::Windows::Media::Protection::PlayReady::PlayReadyContentHeader instance{ param0, param1, param2, param3, param4 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 7)
        {
            try
            {
                auto param0 = py::convert_to<winrt::guid>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Media::Protection::PlayReady::PlayReadyEncryptionAlgorithm>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 3);
                auto param4 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 4);
                auto param5 = py::convert_to<winrt::hstring>(args, 5);
                auto param6 = py::convert_to<winrt::guid>(args, 6);

                winrt::Windows::Media::Protection::PlayReady::PlayReadyContentHeader instance{ param0, param1, param2, param3, param4, param5, param6 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<py::pybuf_view<uint8_t, false>>(args, 0);

                winrt::Windows::Media::Protection::PlayReady::PlayReadyContentHeader instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_PlayReadyContentHeader(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyContentHeader* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PlayReadyContentHeader_GetSerializedHeader(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyContentHeader* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Protection.PlayReady.PlayReadyContentHeader", L"GetSerializedHeader", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetSerializedHeader());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PlayReadyContentHeader_get_CustomAttributes(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyContentHeader* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.PlayReadyContentHeader", L"CustomAttributes"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CustomAttributes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PlayReadyContentHeader_get_DecryptorSetup(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyContentHeader* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.PlayReadyContentHeader", L"DecryptorSetup"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DecryptorSetup());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PlayReadyContentHeader_get_DomainServiceId(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyContentHeader* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.PlayReadyContentHeader", L"DomainServiceId"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DomainServiceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PlayReadyContentHeader_get_EncryptionType(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyContentHeader* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.PlayReadyContentHeader", L"EncryptionType"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.EncryptionType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PlayReadyContentHeader_get_HeaderWithEmbeddedUpdates(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyContentHeader* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.PlayReadyContentHeader", L"HeaderWithEmbeddedUpdates"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.HeaderWithEmbeddedUpdates());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PlayReadyContentHeader_get_KeyId(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyContentHeader* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.PlayReadyContentHeader", L"KeyId"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.KeyId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PlayReadyContentHeader_get_KeyIdString(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyContentHeader* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.PlayReadyContentHeader", L"KeyIdString"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.KeyIdString());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PlayReadyContentHeader_get_LicenseAcquisitionUrl(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyContentHeader* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.PlayReadyContentHeader", L"LicenseAcquisitionUrl"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.LicenseAcquisitionUrl());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PlayReadyContentHeader_get_LicenseAcquisitionUserInterfaceUrl(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyContentHeader* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.PlayReadyContentHeader", L"LicenseAcquisitionUserInterfaceUrl"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.LicenseAcquisitionUserInterfaceUrl());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PlayReadyContentHeader_get_KeyIdStrings(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyContentHeader* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.PlayReadyContentHeader", L"KeyIdStrings"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.KeyIdStrings());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PlayReadyContentHeader_get_KeyIds(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyContentHeader* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.PlayReadyContentHeader", L"KeyIds"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.KeyIds());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PlayReadyContentHeader(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Protection::PlayReady::PlayReadyContentHeader>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PlayReadyContentHeader(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Protection::PlayReady::PlayReadyContentHeader>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PlayReadyContentHeader[] = {
        { "get_serialized_header", reinterpret_cast<PyCFunction>(PlayReadyContentHeader_GetSerializedHeader), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_PlayReadyContentHeader, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PlayReadyContentHeader), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PlayReadyContentHeader[] = {
        { "custom_attributes", reinterpret_cast<getter>(PlayReadyContentHeader_get_CustomAttributes), nullptr, nullptr, nullptr },
        { "decryptor_setup", reinterpret_cast<getter>(PlayReadyContentHeader_get_DecryptorSetup), nullptr, nullptr, nullptr },
        { "domain_service_id", reinterpret_cast<getter>(PlayReadyContentHeader_get_DomainServiceId), nullptr, nullptr, nullptr },
        { "encryption_type", reinterpret_cast<getter>(PlayReadyContentHeader_get_EncryptionType), nullptr, nullptr, nullptr },
        { "header_with_embedded_updates", reinterpret_cast<getter>(PlayReadyContentHeader_get_HeaderWithEmbeddedUpdates), nullptr, nullptr, nullptr },
        { "key_id", reinterpret_cast<getter>(PlayReadyContentHeader_get_KeyId), nullptr, nullptr, nullptr },
        { "key_id_string", reinterpret_cast<getter>(PlayReadyContentHeader_get_KeyIdString), nullptr, nullptr, nullptr },
        { "license_acquisition_url", reinterpret_cast<getter>(PlayReadyContentHeader_get_LicenseAcquisitionUrl), nullptr, nullptr, nullptr },
        { "license_acquisition_user_interface_url", reinterpret_cast<getter>(PlayReadyContentHeader_get_LicenseAcquisitionUserInterfaceUrl), nullptr, nullptr, nullptr },
        { "key_id_strings", reinterpret_cast<getter>(PlayReadyContentHeader_get_KeyIdStrings), nullptr, nullptr, nullptr },
        { "key_ids", reinterpret_cast<getter>(PlayReadyContentHeader_get_KeyIds), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PlayReadyContentHeader[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PlayReadyContentHeader) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PlayReadyContentHeader) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PlayReadyContentHeader) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PlayReadyContentHeader) },
        { },
    };

    static PyType_Spec type_spec_PlayReadyContentHeader =
    {
        "winrt._winrt_windows_media_protection_playready.PlayReadyContentHeader",
        sizeof(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyContentHeader),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PlayReadyContentHeader
    };

    // ----- PlayReadyContentResolver class --------------------

    static PyObject* _new_PlayReadyContentResolver(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Protection::PlayReady::PlayReadyContentResolver>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Protection::PlayReady::PlayReadyContentResolver>::type_name);
        return nullptr;
    }

    static PyObject* PlayReadyContentResolver_ServiceRequest(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Protection.PlayReady.PlayReadyContentResolver", L"ServiceRequest", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Media::Protection::PlayReady::PlayReadyContentHeader>(args, 0);

                return py::convert(winrt::Windows::Media::Protection::PlayReady::PlayReadyContentResolver::ServiceRequest(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyMethodDef _methods_PlayReadyContentResolver[] = {
        { }
    };

    static PyGetSetDef _getset_PlayReadyContentResolver[] = {
        { }
    };

    static PyType_Slot _type_slots_PlayReadyContentResolver[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PlayReadyContentResolver) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PlayReadyContentResolver) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PlayReadyContentResolver) },
        { },
    };

    static PyType_Spec type_spec_PlayReadyContentResolver =
    {
        "winrt._winrt_windows_media_protection_playready.PlayReadyContentResolver",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PlayReadyContentResolver
    };

    static PyGetSetDef getset_PlayReadyContentResolver_Static[] = {
        { }
    };

    static PyMethodDef methods_PlayReadyContentResolver_Static[] = {
        { "service_request", reinterpret_cast<PyCFunction>(PlayReadyContentResolver_ServiceRequest), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_PlayReadyContentResolver_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_PlayReadyContentResolver_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_PlayReadyContentResolver_Static) },
        { }
    };

    static PyType_Spec type_spec_PlayReadyContentResolver_Static =
    {
        "winrt._winrt_windows_media_protection_playready.PlayReadyContentResolver_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_PlayReadyContentResolver_Static
    };

    // ----- PlayReadyDomain class --------------------

    static PyObject* _new_PlayReadyDomain(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Protection::PlayReady::PlayReadyDomain>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Protection::PlayReady::PlayReadyDomain>::type_name);
        return nullptr;
    }

    static void _dealloc_PlayReadyDomain(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyDomain* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PlayReadyDomain_get_AccountId(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyDomain* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.PlayReadyDomain", L"AccountId"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.AccountId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PlayReadyDomain_get_DomainJoinUrl(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyDomain* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.PlayReadyDomain", L"DomainJoinUrl"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DomainJoinUrl());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PlayReadyDomain_get_FriendlyName(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyDomain* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.PlayReadyDomain", L"FriendlyName"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.FriendlyName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PlayReadyDomain_get_Revision(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyDomain* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.PlayReadyDomain", L"Revision"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Revision());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PlayReadyDomain_get_ServiceId(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyDomain* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.PlayReadyDomain", L"ServiceId"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ServiceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PlayReadyDomain(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Protection::PlayReady::PlayReadyDomain>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PlayReadyDomain(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Protection::PlayReady::PlayReadyDomain>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PlayReadyDomain[] = {
        { "_assign_array_", _assign_array_PlayReadyDomain, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PlayReadyDomain), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PlayReadyDomain[] = {
        { "account_id", reinterpret_cast<getter>(PlayReadyDomain_get_AccountId), nullptr, nullptr, nullptr },
        { "domain_join_url", reinterpret_cast<getter>(PlayReadyDomain_get_DomainJoinUrl), nullptr, nullptr, nullptr },
        { "friendly_name", reinterpret_cast<getter>(PlayReadyDomain_get_FriendlyName), nullptr, nullptr, nullptr },
        { "revision", reinterpret_cast<getter>(PlayReadyDomain_get_Revision), nullptr, nullptr, nullptr },
        { "service_id", reinterpret_cast<getter>(PlayReadyDomain_get_ServiceId), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PlayReadyDomain[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PlayReadyDomain) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PlayReadyDomain) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PlayReadyDomain) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PlayReadyDomain) },
        { },
    };

    static PyType_Spec type_spec_PlayReadyDomain =
    {
        "winrt._winrt_windows_media_protection_playready.PlayReadyDomain",
        sizeof(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyDomain),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PlayReadyDomain
    };

    // ----- PlayReadyDomainIterable class --------------------

    static PyObject* _new_PlayReadyDomainIterable(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::guid>(args, 0);

                winrt::Windows::Media::Protection::PlayReady::PlayReadyDomainIterable instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_PlayReadyDomainIterable(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyDomainIterable* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PlayReadyDomainIterable_First(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyDomainIterable* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Protection.PlayReady.PlayReadyDomainIterable", L"First", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.First());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_PlayReadyDomainIterable(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Protection::PlayReady::PlayReadyDomainIterable>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PlayReadyDomainIterable(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Protection::PlayReady::PlayReadyDomainIterable>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _iterator_PlayReadyDomainIterable(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyDomainIterable* self) noexcept
    {
        try
        {
            return py::convert(self->obj.First());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PlayReadyDomainIterable[] = {
        { "first", reinterpret_cast<PyCFunction>(PlayReadyDomainIterable_First), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_PlayReadyDomainIterable, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PlayReadyDomainIterable), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PlayReadyDomainIterable[] = {
        { }
    };

    static PyType_Slot _type_slots_PlayReadyDomainIterable[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PlayReadyDomainIterable) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PlayReadyDomainIterable) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PlayReadyDomainIterable) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PlayReadyDomainIterable) },
        { Py_tp_iter, reinterpret_cast<void*>(_iterator_PlayReadyDomainIterable) },
        { },
    };

    static PyType_Spec type_spec_PlayReadyDomainIterable =
    {
        "winrt._winrt_windows_media_protection_playready.PlayReadyDomainIterable",
        sizeof(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyDomainIterable),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PlayReadyDomainIterable
    };

    // ----- PlayReadyDomainIterator class --------------------

    static PyObject* _new_PlayReadyDomainIterator(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Protection::PlayReady::PlayReadyDomainIterator>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Protection::PlayReady::PlayReadyDomainIterator>::type_name);
        return nullptr;
    }

    static void _dealloc_PlayReadyDomainIterator(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyDomainIterator* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PlayReadyDomainIterator_GetMany(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyDomainIterator* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Protection.PlayReady.PlayReadyDomainIterator", L"GetMany", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                auto param0 = py::convert_to<py::pybuf_view<winrt::Windows::Media::Protection::PlayReady::IPlayReadyDomain, true>>(args, 0);

                return py::convert(self->obj.GetMany(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PlayReadyDomainIterator_MoveNext(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyDomainIterator* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Protection.PlayReady.PlayReadyDomainIterator", L"MoveNext", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.MoveNext());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PlayReadyDomainIterator_get_Current(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyDomainIterator* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.PlayReadyDomainIterator", L"Current"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Current());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PlayReadyDomainIterator_get_HasCurrent(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyDomainIterator* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.PlayReadyDomainIterator", L"HasCurrent"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.HasCurrent());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PlayReadyDomainIterator(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Protection::PlayReady::PlayReadyDomainIterator>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PlayReadyDomainIterator(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Protection::PlayReady::PlayReadyDomainIterator>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _iterator_PlayReadyDomainIterator(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyDomainIterator* self) noexcept
    {
        return reinterpret_cast<PyObject*>(self);
    }

    static PyObject* _iterator_next_PlayReadyDomainIterator(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyDomainIterator* self) noexcept
    {
        try
        {
            if (self->obj.HasCurrent())
            {
                auto cur = self->obj.Current();
                self->obj.MoveNext();
                return py::convert(cur);
            }
            else
            {
                return nullptr;
            }}
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PlayReadyDomainIterator[] = {
        { "get_many", reinterpret_cast<PyCFunction>(PlayReadyDomainIterator_GetMany), METH_VARARGS, nullptr },
        { "move_next", reinterpret_cast<PyCFunction>(PlayReadyDomainIterator_MoveNext), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_PlayReadyDomainIterator, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PlayReadyDomainIterator), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PlayReadyDomainIterator[] = {
        { "current", reinterpret_cast<getter>(PlayReadyDomainIterator_get_Current), nullptr, nullptr, nullptr },
        { "has_current", reinterpret_cast<getter>(PlayReadyDomainIterator_get_HasCurrent), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PlayReadyDomainIterator[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PlayReadyDomainIterator) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PlayReadyDomainIterator) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PlayReadyDomainIterator) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PlayReadyDomainIterator) },
        { Py_tp_iter, reinterpret_cast<void*>(_iterator_PlayReadyDomainIterator) },
        { Py_tp_iternext, reinterpret_cast<void*>(_iterator_next_PlayReadyDomainIterator) },
        { },
    };

    static PyType_Spec type_spec_PlayReadyDomainIterator =
    {
        "winrt._winrt_windows_media_protection_playready.PlayReadyDomainIterator",
        sizeof(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyDomainIterator),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PlayReadyDomainIterator
    };

    // ----- PlayReadyDomainJoinServiceRequest class --------------------

    static PyObject* _new_PlayReadyDomainJoinServiceRequest(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Media::Protection::PlayReady::PlayReadyDomainJoinServiceRequest instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_PlayReadyDomainJoinServiceRequest(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyDomainJoinServiceRequest* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PlayReadyDomainJoinServiceRequest_BeginServiceRequest(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyDomainJoinServiceRequest* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Protection.PlayReady.PlayReadyDomainJoinServiceRequest", L"BeginServiceRequest", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.BeginServiceRequest());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PlayReadyDomainJoinServiceRequest_GenerateManualEnablingChallenge(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyDomainJoinServiceRequest* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Protection.PlayReady.PlayReadyDomainJoinServiceRequest", L"GenerateManualEnablingChallenge", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GenerateManualEnablingChallenge());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PlayReadyDomainJoinServiceRequest_NextServiceRequest(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyDomainJoinServiceRequest* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Protection.PlayReady.PlayReadyDomainJoinServiceRequest", L"NextServiceRequest", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.NextServiceRequest());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PlayReadyDomainJoinServiceRequest_ProcessManualEnablingResponse(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyDomainJoinServiceRequest* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Protection.PlayReady.PlayReadyDomainJoinServiceRequest", L"ProcessManualEnablingResponse", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<py::pybuf_view<uint8_t, false>>(args, 0);

                return py::convert(self->obj.ProcessManualEnablingResponse(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PlayReadyDomainJoinServiceRequest_get_ProtectionSystem(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyDomainJoinServiceRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.PlayReadyDomainJoinServiceRequest", L"ProtectionSystem"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ProtectionSystem());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PlayReadyDomainJoinServiceRequest_get_Type(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyDomainJoinServiceRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.PlayReadyDomainJoinServiceRequest", L"Type"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Type());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PlayReadyDomainJoinServiceRequest_get_DomainServiceId(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyDomainJoinServiceRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.PlayReadyDomainJoinServiceRequest", L"DomainServiceId"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DomainServiceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PlayReadyDomainJoinServiceRequest_put_DomainServiceId(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyDomainJoinServiceRequest* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.PlayReadyDomainJoinServiceRequest", L"DomainServiceId"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::guid>(arg);

            self->obj.DomainServiceId(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PlayReadyDomainJoinServiceRequest_get_DomainFriendlyName(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyDomainJoinServiceRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.PlayReadyDomainJoinServiceRequest", L"DomainFriendlyName"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DomainFriendlyName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PlayReadyDomainJoinServiceRequest_put_DomainFriendlyName(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyDomainJoinServiceRequest* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.PlayReadyDomainJoinServiceRequest", L"DomainFriendlyName"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.DomainFriendlyName(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PlayReadyDomainJoinServiceRequest_get_DomainAccountId(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyDomainJoinServiceRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.PlayReadyDomainJoinServiceRequest", L"DomainAccountId"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DomainAccountId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PlayReadyDomainJoinServiceRequest_put_DomainAccountId(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyDomainJoinServiceRequest* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.PlayReadyDomainJoinServiceRequest", L"DomainAccountId"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::guid>(arg);

            self->obj.DomainAccountId(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PlayReadyDomainJoinServiceRequest_get_Uri(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyDomainJoinServiceRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.PlayReadyDomainJoinServiceRequest", L"Uri"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Uri());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PlayReadyDomainJoinServiceRequest_put_Uri(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyDomainJoinServiceRequest* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.PlayReadyDomainJoinServiceRequest", L"Uri"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(arg);

            self->obj.Uri(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PlayReadyDomainJoinServiceRequest_get_ChallengeCustomData(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyDomainJoinServiceRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.PlayReadyDomainJoinServiceRequest", L"ChallengeCustomData"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ChallengeCustomData());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PlayReadyDomainJoinServiceRequest_put_ChallengeCustomData(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyDomainJoinServiceRequest* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.PlayReadyDomainJoinServiceRequest", L"ChallengeCustomData"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.ChallengeCustomData(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PlayReadyDomainJoinServiceRequest_get_ResponseCustomData(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyDomainJoinServiceRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.PlayReadyDomainJoinServiceRequest", L"ResponseCustomData"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ResponseCustomData());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PlayReadyDomainJoinServiceRequest(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Protection::PlayReady::PlayReadyDomainJoinServiceRequest>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PlayReadyDomainJoinServiceRequest(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Protection::PlayReady::PlayReadyDomainJoinServiceRequest>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PlayReadyDomainJoinServiceRequest[] = {
        { "begin_service_request", reinterpret_cast<PyCFunction>(PlayReadyDomainJoinServiceRequest_BeginServiceRequest), METH_VARARGS, nullptr },
        { "generate_manual_enabling_challenge", reinterpret_cast<PyCFunction>(PlayReadyDomainJoinServiceRequest_GenerateManualEnablingChallenge), METH_VARARGS, nullptr },
        { "next_service_request", reinterpret_cast<PyCFunction>(PlayReadyDomainJoinServiceRequest_NextServiceRequest), METH_VARARGS, nullptr },
        { "process_manual_enabling_response", reinterpret_cast<PyCFunction>(PlayReadyDomainJoinServiceRequest_ProcessManualEnablingResponse), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_PlayReadyDomainJoinServiceRequest, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PlayReadyDomainJoinServiceRequest), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PlayReadyDomainJoinServiceRequest[] = {
        { "protection_system", reinterpret_cast<getter>(PlayReadyDomainJoinServiceRequest_get_ProtectionSystem), nullptr, nullptr, nullptr },
        { "type", reinterpret_cast<getter>(PlayReadyDomainJoinServiceRequest_get_Type), nullptr, nullptr, nullptr },
        { "domain_service_id", reinterpret_cast<getter>(PlayReadyDomainJoinServiceRequest_get_DomainServiceId), reinterpret_cast<setter>(PlayReadyDomainJoinServiceRequest_put_DomainServiceId), nullptr, nullptr },
        { "domain_friendly_name", reinterpret_cast<getter>(PlayReadyDomainJoinServiceRequest_get_DomainFriendlyName), reinterpret_cast<setter>(PlayReadyDomainJoinServiceRequest_put_DomainFriendlyName), nullptr, nullptr },
        { "domain_account_id", reinterpret_cast<getter>(PlayReadyDomainJoinServiceRequest_get_DomainAccountId), reinterpret_cast<setter>(PlayReadyDomainJoinServiceRequest_put_DomainAccountId), nullptr, nullptr },
        { "uri", reinterpret_cast<getter>(PlayReadyDomainJoinServiceRequest_get_Uri), reinterpret_cast<setter>(PlayReadyDomainJoinServiceRequest_put_Uri), nullptr, nullptr },
        { "challenge_custom_data", reinterpret_cast<getter>(PlayReadyDomainJoinServiceRequest_get_ChallengeCustomData), reinterpret_cast<setter>(PlayReadyDomainJoinServiceRequest_put_ChallengeCustomData), nullptr, nullptr },
        { "response_custom_data", reinterpret_cast<getter>(PlayReadyDomainJoinServiceRequest_get_ResponseCustomData), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PlayReadyDomainJoinServiceRequest[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PlayReadyDomainJoinServiceRequest) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PlayReadyDomainJoinServiceRequest) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PlayReadyDomainJoinServiceRequest) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PlayReadyDomainJoinServiceRequest) },
        { },
    };

    static PyType_Spec type_spec_PlayReadyDomainJoinServiceRequest =
    {
        "winrt._winrt_windows_media_protection_playready.PlayReadyDomainJoinServiceRequest",
        sizeof(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyDomainJoinServiceRequest),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PlayReadyDomainJoinServiceRequest
    };

    // ----- PlayReadyDomainLeaveServiceRequest class --------------------

    static PyObject* _new_PlayReadyDomainLeaveServiceRequest(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Media::Protection::PlayReady::PlayReadyDomainLeaveServiceRequest instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_PlayReadyDomainLeaveServiceRequest(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyDomainLeaveServiceRequest* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PlayReadyDomainLeaveServiceRequest_BeginServiceRequest(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyDomainLeaveServiceRequest* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Protection.PlayReady.PlayReadyDomainLeaveServiceRequest", L"BeginServiceRequest", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.BeginServiceRequest());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PlayReadyDomainLeaveServiceRequest_GenerateManualEnablingChallenge(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyDomainLeaveServiceRequest* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Protection.PlayReady.PlayReadyDomainLeaveServiceRequest", L"GenerateManualEnablingChallenge", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GenerateManualEnablingChallenge());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PlayReadyDomainLeaveServiceRequest_NextServiceRequest(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyDomainLeaveServiceRequest* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Protection.PlayReady.PlayReadyDomainLeaveServiceRequest", L"NextServiceRequest", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.NextServiceRequest());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PlayReadyDomainLeaveServiceRequest_ProcessManualEnablingResponse(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyDomainLeaveServiceRequest* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Protection.PlayReady.PlayReadyDomainLeaveServiceRequest", L"ProcessManualEnablingResponse", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<py::pybuf_view<uint8_t, false>>(args, 0);

                return py::convert(self->obj.ProcessManualEnablingResponse(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PlayReadyDomainLeaveServiceRequest_get_ProtectionSystem(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyDomainLeaveServiceRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.PlayReadyDomainLeaveServiceRequest", L"ProtectionSystem"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ProtectionSystem());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PlayReadyDomainLeaveServiceRequest_get_Type(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyDomainLeaveServiceRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.PlayReadyDomainLeaveServiceRequest", L"Type"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Type());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PlayReadyDomainLeaveServiceRequest_get_DomainServiceId(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyDomainLeaveServiceRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.PlayReadyDomainLeaveServiceRequest", L"DomainServiceId"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DomainServiceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PlayReadyDomainLeaveServiceRequest_put_DomainServiceId(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyDomainLeaveServiceRequest* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.PlayReadyDomainLeaveServiceRequest", L"DomainServiceId"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::guid>(arg);

            self->obj.DomainServiceId(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PlayReadyDomainLeaveServiceRequest_get_DomainAccountId(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyDomainLeaveServiceRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.PlayReadyDomainLeaveServiceRequest", L"DomainAccountId"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DomainAccountId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PlayReadyDomainLeaveServiceRequest_put_DomainAccountId(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyDomainLeaveServiceRequest* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.PlayReadyDomainLeaveServiceRequest", L"DomainAccountId"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::guid>(arg);

            self->obj.DomainAccountId(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PlayReadyDomainLeaveServiceRequest_get_Uri(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyDomainLeaveServiceRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.PlayReadyDomainLeaveServiceRequest", L"Uri"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Uri());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PlayReadyDomainLeaveServiceRequest_put_Uri(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyDomainLeaveServiceRequest* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.PlayReadyDomainLeaveServiceRequest", L"Uri"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(arg);

            self->obj.Uri(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PlayReadyDomainLeaveServiceRequest_get_ChallengeCustomData(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyDomainLeaveServiceRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.PlayReadyDomainLeaveServiceRequest", L"ChallengeCustomData"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ChallengeCustomData());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PlayReadyDomainLeaveServiceRequest_put_ChallengeCustomData(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyDomainLeaveServiceRequest* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.PlayReadyDomainLeaveServiceRequest", L"ChallengeCustomData"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.ChallengeCustomData(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PlayReadyDomainLeaveServiceRequest_get_ResponseCustomData(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyDomainLeaveServiceRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.PlayReadyDomainLeaveServiceRequest", L"ResponseCustomData"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ResponseCustomData());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PlayReadyDomainLeaveServiceRequest(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Protection::PlayReady::PlayReadyDomainLeaveServiceRequest>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PlayReadyDomainLeaveServiceRequest(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Protection::PlayReady::PlayReadyDomainLeaveServiceRequest>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PlayReadyDomainLeaveServiceRequest[] = {
        { "begin_service_request", reinterpret_cast<PyCFunction>(PlayReadyDomainLeaveServiceRequest_BeginServiceRequest), METH_VARARGS, nullptr },
        { "generate_manual_enabling_challenge", reinterpret_cast<PyCFunction>(PlayReadyDomainLeaveServiceRequest_GenerateManualEnablingChallenge), METH_VARARGS, nullptr },
        { "next_service_request", reinterpret_cast<PyCFunction>(PlayReadyDomainLeaveServiceRequest_NextServiceRequest), METH_VARARGS, nullptr },
        { "process_manual_enabling_response", reinterpret_cast<PyCFunction>(PlayReadyDomainLeaveServiceRequest_ProcessManualEnablingResponse), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_PlayReadyDomainLeaveServiceRequest, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PlayReadyDomainLeaveServiceRequest), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PlayReadyDomainLeaveServiceRequest[] = {
        { "protection_system", reinterpret_cast<getter>(PlayReadyDomainLeaveServiceRequest_get_ProtectionSystem), nullptr, nullptr, nullptr },
        { "type", reinterpret_cast<getter>(PlayReadyDomainLeaveServiceRequest_get_Type), nullptr, nullptr, nullptr },
        { "domain_service_id", reinterpret_cast<getter>(PlayReadyDomainLeaveServiceRequest_get_DomainServiceId), reinterpret_cast<setter>(PlayReadyDomainLeaveServiceRequest_put_DomainServiceId), nullptr, nullptr },
        { "domain_account_id", reinterpret_cast<getter>(PlayReadyDomainLeaveServiceRequest_get_DomainAccountId), reinterpret_cast<setter>(PlayReadyDomainLeaveServiceRequest_put_DomainAccountId), nullptr, nullptr },
        { "uri", reinterpret_cast<getter>(PlayReadyDomainLeaveServiceRequest_get_Uri), reinterpret_cast<setter>(PlayReadyDomainLeaveServiceRequest_put_Uri), nullptr, nullptr },
        { "challenge_custom_data", reinterpret_cast<getter>(PlayReadyDomainLeaveServiceRequest_get_ChallengeCustomData), reinterpret_cast<setter>(PlayReadyDomainLeaveServiceRequest_put_ChallengeCustomData), nullptr, nullptr },
        { "response_custom_data", reinterpret_cast<getter>(PlayReadyDomainLeaveServiceRequest_get_ResponseCustomData), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PlayReadyDomainLeaveServiceRequest[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PlayReadyDomainLeaveServiceRequest) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PlayReadyDomainLeaveServiceRequest) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PlayReadyDomainLeaveServiceRequest) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PlayReadyDomainLeaveServiceRequest) },
        { },
    };

    static PyType_Spec type_spec_PlayReadyDomainLeaveServiceRequest =
    {
        "winrt._winrt_windows_media_protection_playready.PlayReadyDomainLeaveServiceRequest",
        sizeof(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyDomainLeaveServiceRequest),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PlayReadyDomainLeaveServiceRequest
    };

    // ----- PlayReadyITADataGenerator class --------------------

    static PyObject* _new_PlayReadyITADataGenerator(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Media::Protection::PlayReady::PlayReadyITADataGenerator instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_PlayReadyITADataGenerator(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyITADataGenerator* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PlayReadyITADataGenerator_GenerateData(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyITADataGenerator* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 4)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Protection.PlayReady.PlayReadyITADataGenerator", L"GenerateData", 4))
                {
                    py::set_arg_count_version_error(4);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::guid>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Collections::IPropertySet>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::Media::Protection::PlayReady::PlayReadyITADataFormat>(args, 3);

                return py::convert(self->obj.GenerateData(param0, param1, param2, param3));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_PlayReadyITADataGenerator(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Protection::PlayReady::PlayReadyITADataGenerator>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PlayReadyITADataGenerator(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Protection::PlayReady::PlayReadyITADataGenerator>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PlayReadyITADataGenerator[] = {
        { "generate_data", reinterpret_cast<PyCFunction>(PlayReadyITADataGenerator_GenerateData), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_PlayReadyITADataGenerator, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PlayReadyITADataGenerator), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PlayReadyITADataGenerator[] = {
        { }
    };

    static PyType_Slot _type_slots_PlayReadyITADataGenerator[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PlayReadyITADataGenerator) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PlayReadyITADataGenerator) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PlayReadyITADataGenerator) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PlayReadyITADataGenerator) },
        { },
    };

    static PyType_Spec type_spec_PlayReadyITADataGenerator =
    {
        "winrt._winrt_windows_media_protection_playready.PlayReadyITADataGenerator",
        sizeof(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyITADataGenerator),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PlayReadyITADataGenerator
    };

    // ----- PlayReadyIndividualizationServiceRequest class --------------------

    static PyObject* _new_PlayReadyIndividualizationServiceRequest(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Media::Protection::PlayReady::PlayReadyIndividualizationServiceRequest instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_PlayReadyIndividualizationServiceRequest(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyIndividualizationServiceRequest* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PlayReadyIndividualizationServiceRequest_BeginServiceRequest(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyIndividualizationServiceRequest* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Protection.PlayReady.PlayReadyIndividualizationServiceRequest", L"BeginServiceRequest", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.BeginServiceRequest());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PlayReadyIndividualizationServiceRequest_GenerateManualEnablingChallenge(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyIndividualizationServiceRequest* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Protection.PlayReady.PlayReadyIndividualizationServiceRequest", L"GenerateManualEnablingChallenge", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GenerateManualEnablingChallenge());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PlayReadyIndividualizationServiceRequest_NextServiceRequest(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyIndividualizationServiceRequest* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Protection.PlayReady.PlayReadyIndividualizationServiceRequest", L"NextServiceRequest", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.NextServiceRequest());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PlayReadyIndividualizationServiceRequest_ProcessManualEnablingResponse(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyIndividualizationServiceRequest* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Protection.PlayReady.PlayReadyIndividualizationServiceRequest", L"ProcessManualEnablingResponse", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<py::pybuf_view<uint8_t, false>>(args, 0);

                return py::convert(self->obj.ProcessManualEnablingResponse(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PlayReadyIndividualizationServiceRequest_get_ProtectionSystem(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyIndividualizationServiceRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.PlayReadyIndividualizationServiceRequest", L"ProtectionSystem"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ProtectionSystem());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PlayReadyIndividualizationServiceRequest_get_Type(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyIndividualizationServiceRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.PlayReadyIndividualizationServiceRequest", L"Type"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Type());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PlayReadyIndividualizationServiceRequest_get_Uri(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyIndividualizationServiceRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.PlayReadyIndividualizationServiceRequest", L"Uri"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Uri());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PlayReadyIndividualizationServiceRequest_put_Uri(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyIndividualizationServiceRequest* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.PlayReadyIndividualizationServiceRequest", L"Uri"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(arg);

            self->obj.Uri(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PlayReadyIndividualizationServiceRequest_get_ChallengeCustomData(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyIndividualizationServiceRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.PlayReadyIndividualizationServiceRequest", L"ChallengeCustomData"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ChallengeCustomData());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PlayReadyIndividualizationServiceRequest_put_ChallengeCustomData(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyIndividualizationServiceRequest* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.PlayReadyIndividualizationServiceRequest", L"ChallengeCustomData"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.ChallengeCustomData(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PlayReadyIndividualizationServiceRequest_get_ResponseCustomData(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyIndividualizationServiceRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.PlayReadyIndividualizationServiceRequest", L"ResponseCustomData"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ResponseCustomData());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PlayReadyIndividualizationServiceRequest(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Protection::PlayReady::PlayReadyIndividualizationServiceRequest>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PlayReadyIndividualizationServiceRequest(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Protection::PlayReady::PlayReadyIndividualizationServiceRequest>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PlayReadyIndividualizationServiceRequest[] = {
        { "begin_service_request", reinterpret_cast<PyCFunction>(PlayReadyIndividualizationServiceRequest_BeginServiceRequest), METH_VARARGS, nullptr },
        { "generate_manual_enabling_challenge", reinterpret_cast<PyCFunction>(PlayReadyIndividualizationServiceRequest_GenerateManualEnablingChallenge), METH_VARARGS, nullptr },
        { "next_service_request", reinterpret_cast<PyCFunction>(PlayReadyIndividualizationServiceRequest_NextServiceRequest), METH_VARARGS, nullptr },
        { "process_manual_enabling_response", reinterpret_cast<PyCFunction>(PlayReadyIndividualizationServiceRequest_ProcessManualEnablingResponse), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_PlayReadyIndividualizationServiceRequest, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PlayReadyIndividualizationServiceRequest), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PlayReadyIndividualizationServiceRequest[] = {
        { "protection_system", reinterpret_cast<getter>(PlayReadyIndividualizationServiceRequest_get_ProtectionSystem), nullptr, nullptr, nullptr },
        { "type", reinterpret_cast<getter>(PlayReadyIndividualizationServiceRequest_get_Type), nullptr, nullptr, nullptr },
        { "uri", reinterpret_cast<getter>(PlayReadyIndividualizationServiceRequest_get_Uri), reinterpret_cast<setter>(PlayReadyIndividualizationServiceRequest_put_Uri), nullptr, nullptr },
        { "challenge_custom_data", reinterpret_cast<getter>(PlayReadyIndividualizationServiceRequest_get_ChallengeCustomData), reinterpret_cast<setter>(PlayReadyIndividualizationServiceRequest_put_ChallengeCustomData), nullptr, nullptr },
        { "response_custom_data", reinterpret_cast<getter>(PlayReadyIndividualizationServiceRequest_get_ResponseCustomData), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PlayReadyIndividualizationServiceRequest[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PlayReadyIndividualizationServiceRequest) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PlayReadyIndividualizationServiceRequest) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PlayReadyIndividualizationServiceRequest) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PlayReadyIndividualizationServiceRequest) },
        { },
    };

    static PyType_Spec type_spec_PlayReadyIndividualizationServiceRequest =
    {
        "winrt._winrt_windows_media_protection_playready.PlayReadyIndividualizationServiceRequest",
        sizeof(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyIndividualizationServiceRequest),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PlayReadyIndividualizationServiceRequest
    };

    // ----- PlayReadyLicense class --------------------

    static PyObject* _new_PlayReadyLicense(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Protection::PlayReady::PlayReadyLicense>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Protection::PlayReady::PlayReadyLicense>::type_name);
        return nullptr;
    }

    static void _dealloc_PlayReadyLicense(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyLicense* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PlayReadyLicense_GetKIDAtChainDepth(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyLicense* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Protection.PlayReady.PlayReadyLicense", L"GetKIDAtChainDepth", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint32_t>(args, 0);

                return py::convert(self->obj.GetKIDAtChainDepth(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PlayReadyLicense_get_ChainDepth(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyLicense* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.PlayReadyLicense", L"ChainDepth"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ChainDepth());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PlayReadyLicense_get_DomainAccountID(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyLicense* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.PlayReadyLicense", L"DomainAccountID"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DomainAccountID());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PlayReadyLicense_get_ExpirationDate(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyLicense* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.PlayReadyLicense", L"ExpirationDate"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ExpirationDate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PlayReadyLicense_get_ExpireAfterFirstPlay(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyLicense* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.PlayReadyLicense", L"ExpireAfterFirstPlay"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ExpireAfterFirstPlay());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PlayReadyLicense_get_FullyEvaluated(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyLicense* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.PlayReadyLicense", L"FullyEvaluated"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.FullyEvaluated());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PlayReadyLicense_get_UsableForPlay(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyLicense* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.PlayReadyLicense", L"UsableForPlay"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.UsableForPlay());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PlayReadyLicense_get_ExpiresInRealTime(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyLicense* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.PlayReadyLicense", L"ExpiresInRealTime"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ExpiresInRealTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PlayReadyLicense_get_InMemoryOnly(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyLicense* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.PlayReadyLicense", L"InMemoryOnly"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.InMemoryOnly());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PlayReadyLicense_get_SecureStopId(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyLicense* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.PlayReadyLicense", L"SecureStopId"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SecureStopId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PlayReadyLicense_get_SecurityLevel(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyLicense* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.PlayReadyLicense", L"SecurityLevel"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SecurityLevel());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PlayReadyLicense(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Protection::PlayReady::PlayReadyLicense>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PlayReadyLicense(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Protection::PlayReady::PlayReadyLicense>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PlayReadyLicense[] = {
        { "get_k_i_d_at_chain_depth", reinterpret_cast<PyCFunction>(PlayReadyLicense_GetKIDAtChainDepth), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_PlayReadyLicense, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PlayReadyLicense), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PlayReadyLicense[] = {
        { "chain_depth", reinterpret_cast<getter>(PlayReadyLicense_get_ChainDepth), nullptr, nullptr, nullptr },
        { "domain_account_i_d", reinterpret_cast<getter>(PlayReadyLicense_get_DomainAccountID), nullptr, nullptr, nullptr },
        { "expiration_date", reinterpret_cast<getter>(PlayReadyLicense_get_ExpirationDate), nullptr, nullptr, nullptr },
        { "expire_after_first_play", reinterpret_cast<getter>(PlayReadyLicense_get_ExpireAfterFirstPlay), nullptr, nullptr, nullptr },
        { "fully_evaluated", reinterpret_cast<getter>(PlayReadyLicense_get_FullyEvaluated), nullptr, nullptr, nullptr },
        { "usable_for_play", reinterpret_cast<getter>(PlayReadyLicense_get_UsableForPlay), nullptr, nullptr, nullptr },
        { "expires_in_real_time", reinterpret_cast<getter>(PlayReadyLicense_get_ExpiresInRealTime), nullptr, nullptr, nullptr },
        { "in_memory_only", reinterpret_cast<getter>(PlayReadyLicense_get_InMemoryOnly), nullptr, nullptr, nullptr },
        { "secure_stop_id", reinterpret_cast<getter>(PlayReadyLicense_get_SecureStopId), nullptr, nullptr, nullptr },
        { "security_level", reinterpret_cast<getter>(PlayReadyLicense_get_SecurityLevel), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PlayReadyLicense[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PlayReadyLicense) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PlayReadyLicense) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PlayReadyLicense) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PlayReadyLicense) },
        { },
    };

    static PyType_Spec type_spec_PlayReadyLicense =
    {
        "winrt._winrt_windows_media_protection_playready.PlayReadyLicense",
        sizeof(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyLicense),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PlayReadyLicense
    };

    // ----- PlayReadyLicenseAcquisitionServiceRequest class --------------------

    static PyObject* _new_PlayReadyLicenseAcquisitionServiceRequest(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Media::Protection::PlayReady::PlayReadyLicenseAcquisitionServiceRequest instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_PlayReadyLicenseAcquisitionServiceRequest(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyLicenseAcquisitionServiceRequest* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PlayReadyLicenseAcquisitionServiceRequest_BeginServiceRequest(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyLicenseAcquisitionServiceRequest* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Protection.PlayReady.PlayReadyLicenseAcquisitionServiceRequest", L"BeginServiceRequest", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.BeginServiceRequest());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PlayReadyLicenseAcquisitionServiceRequest_CreateLicenseIterable(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyLicenseAcquisitionServiceRequest* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Protection.PlayReady.PlayReadyLicenseAcquisitionServiceRequest", L"CreateLicenseIterable", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Media::Protection::PlayReady::PlayReadyContentHeader>(args, 0);
                auto param1 = py::convert_to<bool>(args, 1);

                return py::convert(self->obj.CreateLicenseIterable(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PlayReadyLicenseAcquisitionServiceRequest_GenerateManualEnablingChallenge(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyLicenseAcquisitionServiceRequest* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Protection.PlayReady.PlayReadyLicenseAcquisitionServiceRequest", L"GenerateManualEnablingChallenge", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GenerateManualEnablingChallenge());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PlayReadyLicenseAcquisitionServiceRequest_NextServiceRequest(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyLicenseAcquisitionServiceRequest* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Protection.PlayReady.PlayReadyLicenseAcquisitionServiceRequest", L"NextServiceRequest", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.NextServiceRequest());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PlayReadyLicenseAcquisitionServiceRequest_ProcessManualEnablingResponse(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyLicenseAcquisitionServiceRequest* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Protection.PlayReady.PlayReadyLicenseAcquisitionServiceRequest", L"ProcessManualEnablingResponse", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<py::pybuf_view<uint8_t, false>>(args, 0);

                return py::convert(self->obj.ProcessManualEnablingResponse(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PlayReadyLicenseAcquisitionServiceRequest_get_ProtectionSystem(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyLicenseAcquisitionServiceRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.PlayReadyLicenseAcquisitionServiceRequest", L"ProtectionSystem"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ProtectionSystem());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PlayReadyLicenseAcquisitionServiceRequest_get_Type(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyLicenseAcquisitionServiceRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.PlayReadyLicenseAcquisitionServiceRequest", L"Type"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Type());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PlayReadyLicenseAcquisitionServiceRequest_get_DomainServiceId(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyLicenseAcquisitionServiceRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.PlayReadyLicenseAcquisitionServiceRequest", L"DomainServiceId"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DomainServiceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PlayReadyLicenseAcquisitionServiceRequest_put_DomainServiceId(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyLicenseAcquisitionServiceRequest* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.PlayReadyLicenseAcquisitionServiceRequest", L"DomainServiceId"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::guid>(arg);

            self->obj.DomainServiceId(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PlayReadyLicenseAcquisitionServiceRequest_get_ContentHeader(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyLicenseAcquisitionServiceRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.PlayReadyLicenseAcquisitionServiceRequest", L"ContentHeader"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ContentHeader());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PlayReadyLicenseAcquisitionServiceRequest_put_ContentHeader(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyLicenseAcquisitionServiceRequest* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.PlayReadyLicenseAcquisitionServiceRequest", L"ContentHeader"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Media::Protection::PlayReady::PlayReadyContentHeader>(arg);

            self->obj.ContentHeader(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PlayReadyLicenseAcquisitionServiceRequest_get_SessionId(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyLicenseAcquisitionServiceRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.PlayReadyLicenseAcquisitionServiceRequest", L"SessionId"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SessionId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PlayReadyLicenseAcquisitionServiceRequest_get_Uri(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyLicenseAcquisitionServiceRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.PlayReadyLicenseAcquisitionServiceRequest", L"Uri"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Uri());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PlayReadyLicenseAcquisitionServiceRequest_put_Uri(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyLicenseAcquisitionServiceRequest* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.PlayReadyLicenseAcquisitionServiceRequest", L"Uri"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(arg);

            self->obj.Uri(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PlayReadyLicenseAcquisitionServiceRequest_get_ChallengeCustomData(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyLicenseAcquisitionServiceRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.PlayReadyLicenseAcquisitionServiceRequest", L"ChallengeCustomData"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ChallengeCustomData());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PlayReadyLicenseAcquisitionServiceRequest_put_ChallengeCustomData(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyLicenseAcquisitionServiceRequest* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.PlayReadyLicenseAcquisitionServiceRequest", L"ChallengeCustomData"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.ChallengeCustomData(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PlayReadyLicenseAcquisitionServiceRequest_get_ResponseCustomData(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyLicenseAcquisitionServiceRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.PlayReadyLicenseAcquisitionServiceRequest", L"ResponseCustomData"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ResponseCustomData());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PlayReadyLicenseAcquisitionServiceRequest(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Protection::PlayReady::PlayReadyLicenseAcquisitionServiceRequest>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PlayReadyLicenseAcquisitionServiceRequest(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Protection::PlayReady::PlayReadyLicenseAcquisitionServiceRequest>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PlayReadyLicenseAcquisitionServiceRequest[] = {
        { "begin_service_request", reinterpret_cast<PyCFunction>(PlayReadyLicenseAcquisitionServiceRequest_BeginServiceRequest), METH_VARARGS, nullptr },
        { "create_license_iterable", reinterpret_cast<PyCFunction>(PlayReadyLicenseAcquisitionServiceRequest_CreateLicenseIterable), METH_VARARGS, nullptr },
        { "generate_manual_enabling_challenge", reinterpret_cast<PyCFunction>(PlayReadyLicenseAcquisitionServiceRequest_GenerateManualEnablingChallenge), METH_VARARGS, nullptr },
        { "next_service_request", reinterpret_cast<PyCFunction>(PlayReadyLicenseAcquisitionServiceRequest_NextServiceRequest), METH_VARARGS, nullptr },
        { "process_manual_enabling_response", reinterpret_cast<PyCFunction>(PlayReadyLicenseAcquisitionServiceRequest_ProcessManualEnablingResponse), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_PlayReadyLicenseAcquisitionServiceRequest, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PlayReadyLicenseAcquisitionServiceRequest), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PlayReadyLicenseAcquisitionServiceRequest[] = {
        { "protection_system", reinterpret_cast<getter>(PlayReadyLicenseAcquisitionServiceRequest_get_ProtectionSystem), nullptr, nullptr, nullptr },
        { "type", reinterpret_cast<getter>(PlayReadyLicenseAcquisitionServiceRequest_get_Type), nullptr, nullptr, nullptr },
        { "domain_service_id", reinterpret_cast<getter>(PlayReadyLicenseAcquisitionServiceRequest_get_DomainServiceId), reinterpret_cast<setter>(PlayReadyLicenseAcquisitionServiceRequest_put_DomainServiceId), nullptr, nullptr },
        { "content_header", reinterpret_cast<getter>(PlayReadyLicenseAcquisitionServiceRequest_get_ContentHeader), reinterpret_cast<setter>(PlayReadyLicenseAcquisitionServiceRequest_put_ContentHeader), nullptr, nullptr },
        { "session_id", reinterpret_cast<getter>(PlayReadyLicenseAcquisitionServiceRequest_get_SessionId), nullptr, nullptr, nullptr },
        { "uri", reinterpret_cast<getter>(PlayReadyLicenseAcquisitionServiceRequest_get_Uri), reinterpret_cast<setter>(PlayReadyLicenseAcquisitionServiceRequest_put_Uri), nullptr, nullptr },
        { "challenge_custom_data", reinterpret_cast<getter>(PlayReadyLicenseAcquisitionServiceRequest_get_ChallengeCustomData), reinterpret_cast<setter>(PlayReadyLicenseAcquisitionServiceRequest_put_ChallengeCustomData), nullptr, nullptr },
        { "response_custom_data", reinterpret_cast<getter>(PlayReadyLicenseAcquisitionServiceRequest_get_ResponseCustomData), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PlayReadyLicenseAcquisitionServiceRequest[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PlayReadyLicenseAcquisitionServiceRequest) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PlayReadyLicenseAcquisitionServiceRequest) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PlayReadyLicenseAcquisitionServiceRequest) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PlayReadyLicenseAcquisitionServiceRequest) },
        { },
    };

    static PyType_Spec type_spec_PlayReadyLicenseAcquisitionServiceRequest =
    {
        "winrt._winrt_windows_media_protection_playready.PlayReadyLicenseAcquisitionServiceRequest",
        sizeof(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyLicenseAcquisitionServiceRequest),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PlayReadyLicenseAcquisitionServiceRequest
    };

    // ----- PlayReadyLicenseIterable class --------------------

    static PyObject* _new_PlayReadyLicenseIterable(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Media::Protection::PlayReady::PlayReadyLicenseIterable instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Protection::PlayReady::PlayReadyContentHeader>(args, 0);
                auto param1 = py::convert_to<bool>(args, 1);

                winrt::Windows::Media::Protection::PlayReady::PlayReadyLicenseIterable instance{ param0, param1 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_PlayReadyLicenseIterable(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyLicenseIterable* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PlayReadyLicenseIterable_First(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyLicenseIterable* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Protection.PlayReady.PlayReadyLicenseIterable", L"First", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.First());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_PlayReadyLicenseIterable(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Protection::PlayReady::PlayReadyLicenseIterable>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PlayReadyLicenseIterable(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Protection::PlayReady::PlayReadyLicenseIterable>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _iterator_PlayReadyLicenseIterable(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyLicenseIterable* self) noexcept
    {
        try
        {
            return py::convert(self->obj.First());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PlayReadyLicenseIterable[] = {
        { "first", reinterpret_cast<PyCFunction>(PlayReadyLicenseIterable_First), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_PlayReadyLicenseIterable, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PlayReadyLicenseIterable), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PlayReadyLicenseIterable[] = {
        { }
    };

    static PyType_Slot _type_slots_PlayReadyLicenseIterable[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PlayReadyLicenseIterable) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PlayReadyLicenseIterable) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PlayReadyLicenseIterable) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PlayReadyLicenseIterable) },
        { Py_tp_iter, reinterpret_cast<void*>(_iterator_PlayReadyLicenseIterable) },
        { },
    };

    static PyType_Spec type_spec_PlayReadyLicenseIterable =
    {
        "winrt._winrt_windows_media_protection_playready.PlayReadyLicenseIterable",
        sizeof(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyLicenseIterable),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PlayReadyLicenseIterable
    };

    // ----- PlayReadyLicenseIterator class --------------------

    static PyObject* _new_PlayReadyLicenseIterator(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Protection::PlayReady::PlayReadyLicenseIterator>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Protection::PlayReady::PlayReadyLicenseIterator>::type_name);
        return nullptr;
    }

    static void _dealloc_PlayReadyLicenseIterator(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyLicenseIterator* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PlayReadyLicenseIterator_GetMany(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyLicenseIterator* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Protection.PlayReady.PlayReadyLicenseIterator", L"GetMany", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                auto param0 = py::convert_to<py::pybuf_view<winrt::Windows::Media::Protection::PlayReady::IPlayReadyLicense, true>>(args, 0);

                return py::convert(self->obj.GetMany(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PlayReadyLicenseIterator_MoveNext(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyLicenseIterator* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Protection.PlayReady.PlayReadyLicenseIterator", L"MoveNext", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.MoveNext());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PlayReadyLicenseIterator_get_Current(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyLicenseIterator* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.PlayReadyLicenseIterator", L"Current"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Current());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PlayReadyLicenseIterator_get_HasCurrent(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyLicenseIterator* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.PlayReadyLicenseIterator", L"HasCurrent"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.HasCurrent());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PlayReadyLicenseIterator(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Protection::PlayReady::PlayReadyLicenseIterator>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PlayReadyLicenseIterator(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Protection::PlayReady::PlayReadyLicenseIterator>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _iterator_PlayReadyLicenseIterator(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyLicenseIterator* self) noexcept
    {
        return reinterpret_cast<PyObject*>(self);
    }

    static PyObject* _iterator_next_PlayReadyLicenseIterator(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyLicenseIterator* self) noexcept
    {
        try
        {
            if (self->obj.HasCurrent())
            {
                auto cur = self->obj.Current();
                self->obj.MoveNext();
                return py::convert(cur);
            }
            else
            {
                return nullptr;
            }}
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PlayReadyLicenseIterator[] = {
        { "get_many", reinterpret_cast<PyCFunction>(PlayReadyLicenseIterator_GetMany), METH_VARARGS, nullptr },
        { "move_next", reinterpret_cast<PyCFunction>(PlayReadyLicenseIterator_MoveNext), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_PlayReadyLicenseIterator, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PlayReadyLicenseIterator), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PlayReadyLicenseIterator[] = {
        { "current", reinterpret_cast<getter>(PlayReadyLicenseIterator_get_Current), nullptr, nullptr, nullptr },
        { "has_current", reinterpret_cast<getter>(PlayReadyLicenseIterator_get_HasCurrent), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PlayReadyLicenseIterator[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PlayReadyLicenseIterator) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PlayReadyLicenseIterator) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PlayReadyLicenseIterator) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PlayReadyLicenseIterator) },
        { Py_tp_iter, reinterpret_cast<void*>(_iterator_PlayReadyLicenseIterator) },
        { Py_tp_iternext, reinterpret_cast<void*>(_iterator_next_PlayReadyLicenseIterator) },
        { },
    };

    static PyType_Spec type_spec_PlayReadyLicenseIterator =
    {
        "winrt._winrt_windows_media_protection_playready.PlayReadyLicenseIterator",
        sizeof(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyLicenseIterator),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PlayReadyLicenseIterator
    };

    // ----- PlayReadyLicenseManagement class --------------------

    static PyObject* _new_PlayReadyLicenseManagement(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Protection::PlayReady::PlayReadyLicenseManagement>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Protection::PlayReady::PlayReadyLicenseManagement>::type_name);
        return nullptr;
    }

    static PyObject* PlayReadyLicenseManagement_DeleteLicenses(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Protection.PlayReady.PlayReadyLicenseManagement", L"DeleteLicenses", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Media::Protection::PlayReady::PlayReadyContentHeader>(args, 0);

                return py::convert(winrt::Windows::Media::Protection::PlayReady::PlayReadyLicenseManagement::DeleteLicenses(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyMethodDef _methods_PlayReadyLicenseManagement[] = {
        { }
    };

    static PyGetSetDef _getset_PlayReadyLicenseManagement[] = {
        { }
    };

    static PyType_Slot _type_slots_PlayReadyLicenseManagement[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PlayReadyLicenseManagement) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PlayReadyLicenseManagement) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PlayReadyLicenseManagement) },
        { },
    };

    static PyType_Spec type_spec_PlayReadyLicenseManagement =
    {
        "winrt._winrt_windows_media_protection_playready.PlayReadyLicenseManagement",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PlayReadyLicenseManagement
    };

    static PyGetSetDef getset_PlayReadyLicenseManagement_Static[] = {
        { }
    };

    static PyMethodDef methods_PlayReadyLicenseManagement_Static[] = {
        { "delete_licenses", reinterpret_cast<PyCFunction>(PlayReadyLicenseManagement_DeleteLicenses), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_PlayReadyLicenseManagement_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_PlayReadyLicenseManagement_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_PlayReadyLicenseManagement_Static) },
        { }
    };

    static PyType_Spec type_spec_PlayReadyLicenseManagement_Static =
    {
        "winrt._winrt_windows_media_protection_playready.PlayReadyLicenseManagement_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_PlayReadyLicenseManagement_Static
    };

    // ----- PlayReadyLicenseSession class --------------------

    static PyObject* _new_PlayReadyLicenseSession(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IPropertySet>(args, 0);

                winrt::Windows::Media::Protection::PlayReady::PlayReadyLicenseSession instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_PlayReadyLicenseSession(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyLicenseSession* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PlayReadyLicenseSession_ConfigureMediaProtectionManager(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyLicenseSession* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Protection.PlayReady.PlayReadyLicenseSession", L"ConfigureMediaProtectionManager", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Media::Protection::MediaProtectionManager>(args, 0);

                self->obj.ConfigureMediaProtectionManager(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PlayReadyLicenseSession_CreateLAServiceRequest(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyLicenseSession* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Protection.PlayReady.PlayReadyLicenseSession", L"CreateLAServiceRequest", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.CreateLAServiceRequest());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PlayReadyLicenseSession_CreateLicenseIterable(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyLicenseSession* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Protection.PlayReady.PlayReadyLicenseSession", L"CreateLicenseIterable", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Media::Protection::PlayReady::PlayReadyContentHeader>(args, 0);
                auto param1 = py::convert_to<bool>(args, 1);

                return py::convert(self->obj.CreateLicenseIterable(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_PlayReadyLicenseSession(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Protection::PlayReady::PlayReadyLicenseSession>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PlayReadyLicenseSession(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Protection::PlayReady::PlayReadyLicenseSession>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PlayReadyLicenseSession[] = {
        { "configure_media_protection_manager", reinterpret_cast<PyCFunction>(PlayReadyLicenseSession_ConfigureMediaProtectionManager), METH_VARARGS, nullptr },
        { "create_l_a_service_request", reinterpret_cast<PyCFunction>(PlayReadyLicenseSession_CreateLAServiceRequest), METH_VARARGS, nullptr },
        { "create_license_iterable", reinterpret_cast<PyCFunction>(PlayReadyLicenseSession_CreateLicenseIterable), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_PlayReadyLicenseSession, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PlayReadyLicenseSession), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PlayReadyLicenseSession[] = {
        { }
    };

    static PyType_Slot _type_slots_PlayReadyLicenseSession[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PlayReadyLicenseSession) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PlayReadyLicenseSession) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PlayReadyLicenseSession) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PlayReadyLicenseSession) },
        { },
    };

    static PyType_Spec type_spec_PlayReadyLicenseSession =
    {
        "winrt._winrt_windows_media_protection_playready.PlayReadyLicenseSession",
        sizeof(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyLicenseSession),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PlayReadyLicenseSession
    };

    // ----- PlayReadyMeteringReportServiceRequest class --------------------

    static PyObject* _new_PlayReadyMeteringReportServiceRequest(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Media::Protection::PlayReady::PlayReadyMeteringReportServiceRequest instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_PlayReadyMeteringReportServiceRequest(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyMeteringReportServiceRequest* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PlayReadyMeteringReportServiceRequest_BeginServiceRequest(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyMeteringReportServiceRequest* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Protection.PlayReady.PlayReadyMeteringReportServiceRequest", L"BeginServiceRequest", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.BeginServiceRequest());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PlayReadyMeteringReportServiceRequest_GenerateManualEnablingChallenge(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyMeteringReportServiceRequest* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Protection.PlayReady.PlayReadyMeteringReportServiceRequest", L"GenerateManualEnablingChallenge", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GenerateManualEnablingChallenge());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PlayReadyMeteringReportServiceRequest_NextServiceRequest(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyMeteringReportServiceRequest* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Protection.PlayReady.PlayReadyMeteringReportServiceRequest", L"NextServiceRequest", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.NextServiceRequest());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PlayReadyMeteringReportServiceRequest_ProcessManualEnablingResponse(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyMeteringReportServiceRequest* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Protection.PlayReady.PlayReadyMeteringReportServiceRequest", L"ProcessManualEnablingResponse", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<py::pybuf_view<uint8_t, false>>(args, 0);

                return py::convert(self->obj.ProcessManualEnablingResponse(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PlayReadyMeteringReportServiceRequest_get_ProtectionSystem(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyMeteringReportServiceRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.PlayReadyMeteringReportServiceRequest", L"ProtectionSystem"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ProtectionSystem());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PlayReadyMeteringReportServiceRequest_get_Type(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyMeteringReportServiceRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.PlayReadyMeteringReportServiceRequest", L"Type"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Type());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PlayReadyMeteringReportServiceRequest_get_MeteringCertificate(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyMeteringReportServiceRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.PlayReadyMeteringReportServiceRequest", L"MeteringCertificate"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.MeteringCertificate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PlayReadyMeteringReportServiceRequest_put_MeteringCertificate(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyMeteringReportServiceRequest* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.PlayReadyMeteringReportServiceRequest", L"MeteringCertificate"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<py::pybuf_view<uint8_t, false>>(arg);

            self->obj.MeteringCertificate(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PlayReadyMeteringReportServiceRequest_get_Uri(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyMeteringReportServiceRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.PlayReadyMeteringReportServiceRequest", L"Uri"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Uri());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PlayReadyMeteringReportServiceRequest_put_Uri(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyMeteringReportServiceRequest* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.PlayReadyMeteringReportServiceRequest", L"Uri"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(arg);

            self->obj.Uri(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PlayReadyMeteringReportServiceRequest_get_ChallengeCustomData(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyMeteringReportServiceRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.PlayReadyMeteringReportServiceRequest", L"ChallengeCustomData"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ChallengeCustomData());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PlayReadyMeteringReportServiceRequest_put_ChallengeCustomData(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyMeteringReportServiceRequest* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.PlayReadyMeteringReportServiceRequest", L"ChallengeCustomData"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.ChallengeCustomData(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PlayReadyMeteringReportServiceRequest_get_ResponseCustomData(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyMeteringReportServiceRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.PlayReadyMeteringReportServiceRequest", L"ResponseCustomData"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ResponseCustomData());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PlayReadyMeteringReportServiceRequest(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Protection::PlayReady::PlayReadyMeteringReportServiceRequest>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PlayReadyMeteringReportServiceRequest(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Protection::PlayReady::PlayReadyMeteringReportServiceRequest>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PlayReadyMeteringReportServiceRequest[] = {
        { "begin_service_request", reinterpret_cast<PyCFunction>(PlayReadyMeteringReportServiceRequest_BeginServiceRequest), METH_VARARGS, nullptr },
        { "generate_manual_enabling_challenge", reinterpret_cast<PyCFunction>(PlayReadyMeteringReportServiceRequest_GenerateManualEnablingChallenge), METH_VARARGS, nullptr },
        { "next_service_request", reinterpret_cast<PyCFunction>(PlayReadyMeteringReportServiceRequest_NextServiceRequest), METH_VARARGS, nullptr },
        { "process_manual_enabling_response", reinterpret_cast<PyCFunction>(PlayReadyMeteringReportServiceRequest_ProcessManualEnablingResponse), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_PlayReadyMeteringReportServiceRequest, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PlayReadyMeteringReportServiceRequest), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PlayReadyMeteringReportServiceRequest[] = {
        { "protection_system", reinterpret_cast<getter>(PlayReadyMeteringReportServiceRequest_get_ProtectionSystem), nullptr, nullptr, nullptr },
        { "type", reinterpret_cast<getter>(PlayReadyMeteringReportServiceRequest_get_Type), nullptr, nullptr, nullptr },
        { "metering_certificate", reinterpret_cast<getter>(PlayReadyMeteringReportServiceRequest_get_MeteringCertificate), reinterpret_cast<setter>(PlayReadyMeteringReportServiceRequest_put_MeteringCertificate), nullptr, nullptr },
        { "uri", reinterpret_cast<getter>(PlayReadyMeteringReportServiceRequest_get_Uri), reinterpret_cast<setter>(PlayReadyMeteringReportServiceRequest_put_Uri), nullptr, nullptr },
        { "challenge_custom_data", reinterpret_cast<getter>(PlayReadyMeteringReportServiceRequest_get_ChallengeCustomData), reinterpret_cast<setter>(PlayReadyMeteringReportServiceRequest_put_ChallengeCustomData), nullptr, nullptr },
        { "response_custom_data", reinterpret_cast<getter>(PlayReadyMeteringReportServiceRequest_get_ResponseCustomData), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PlayReadyMeteringReportServiceRequest[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PlayReadyMeteringReportServiceRequest) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PlayReadyMeteringReportServiceRequest) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PlayReadyMeteringReportServiceRequest) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PlayReadyMeteringReportServiceRequest) },
        { },
    };

    static PyType_Spec type_spec_PlayReadyMeteringReportServiceRequest =
    {
        "winrt._winrt_windows_media_protection_playready.PlayReadyMeteringReportServiceRequest",
        sizeof(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyMeteringReportServiceRequest),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PlayReadyMeteringReportServiceRequest
    };

    // ----- PlayReadyRevocationServiceRequest class --------------------

    static PyObject* _new_PlayReadyRevocationServiceRequest(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Media::Protection::PlayReady::PlayReadyRevocationServiceRequest instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_PlayReadyRevocationServiceRequest(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyRevocationServiceRequest* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PlayReadyRevocationServiceRequest_BeginServiceRequest(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyRevocationServiceRequest* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Protection.PlayReady.PlayReadyRevocationServiceRequest", L"BeginServiceRequest", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.BeginServiceRequest());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PlayReadyRevocationServiceRequest_GenerateManualEnablingChallenge(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyRevocationServiceRequest* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Protection.PlayReady.PlayReadyRevocationServiceRequest", L"GenerateManualEnablingChallenge", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GenerateManualEnablingChallenge());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PlayReadyRevocationServiceRequest_NextServiceRequest(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyRevocationServiceRequest* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Protection.PlayReady.PlayReadyRevocationServiceRequest", L"NextServiceRequest", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.NextServiceRequest());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PlayReadyRevocationServiceRequest_ProcessManualEnablingResponse(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyRevocationServiceRequest* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Protection.PlayReady.PlayReadyRevocationServiceRequest", L"ProcessManualEnablingResponse", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<py::pybuf_view<uint8_t, false>>(args, 0);

                return py::convert(self->obj.ProcessManualEnablingResponse(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PlayReadyRevocationServiceRequest_get_ProtectionSystem(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyRevocationServiceRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.PlayReadyRevocationServiceRequest", L"ProtectionSystem"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ProtectionSystem());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PlayReadyRevocationServiceRequest_get_Type(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyRevocationServiceRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.PlayReadyRevocationServiceRequest", L"Type"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Type());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PlayReadyRevocationServiceRequest_get_Uri(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyRevocationServiceRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.PlayReadyRevocationServiceRequest", L"Uri"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Uri());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PlayReadyRevocationServiceRequest_put_Uri(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyRevocationServiceRequest* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.PlayReadyRevocationServiceRequest", L"Uri"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(arg);

            self->obj.Uri(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PlayReadyRevocationServiceRequest_get_ChallengeCustomData(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyRevocationServiceRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.PlayReadyRevocationServiceRequest", L"ChallengeCustomData"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ChallengeCustomData());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PlayReadyRevocationServiceRequest_put_ChallengeCustomData(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyRevocationServiceRequest* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.PlayReadyRevocationServiceRequest", L"ChallengeCustomData"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.ChallengeCustomData(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PlayReadyRevocationServiceRequest_get_ResponseCustomData(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyRevocationServiceRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.PlayReadyRevocationServiceRequest", L"ResponseCustomData"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ResponseCustomData());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PlayReadyRevocationServiceRequest(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Protection::PlayReady::PlayReadyRevocationServiceRequest>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PlayReadyRevocationServiceRequest(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Protection::PlayReady::PlayReadyRevocationServiceRequest>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PlayReadyRevocationServiceRequest[] = {
        { "begin_service_request", reinterpret_cast<PyCFunction>(PlayReadyRevocationServiceRequest_BeginServiceRequest), METH_VARARGS, nullptr },
        { "generate_manual_enabling_challenge", reinterpret_cast<PyCFunction>(PlayReadyRevocationServiceRequest_GenerateManualEnablingChallenge), METH_VARARGS, nullptr },
        { "next_service_request", reinterpret_cast<PyCFunction>(PlayReadyRevocationServiceRequest_NextServiceRequest), METH_VARARGS, nullptr },
        { "process_manual_enabling_response", reinterpret_cast<PyCFunction>(PlayReadyRevocationServiceRequest_ProcessManualEnablingResponse), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_PlayReadyRevocationServiceRequest, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PlayReadyRevocationServiceRequest), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PlayReadyRevocationServiceRequest[] = {
        { "protection_system", reinterpret_cast<getter>(PlayReadyRevocationServiceRequest_get_ProtectionSystem), nullptr, nullptr, nullptr },
        { "type", reinterpret_cast<getter>(PlayReadyRevocationServiceRequest_get_Type), nullptr, nullptr, nullptr },
        { "uri", reinterpret_cast<getter>(PlayReadyRevocationServiceRequest_get_Uri), reinterpret_cast<setter>(PlayReadyRevocationServiceRequest_put_Uri), nullptr, nullptr },
        { "challenge_custom_data", reinterpret_cast<getter>(PlayReadyRevocationServiceRequest_get_ChallengeCustomData), reinterpret_cast<setter>(PlayReadyRevocationServiceRequest_put_ChallengeCustomData), nullptr, nullptr },
        { "response_custom_data", reinterpret_cast<getter>(PlayReadyRevocationServiceRequest_get_ResponseCustomData), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PlayReadyRevocationServiceRequest[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PlayReadyRevocationServiceRequest) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PlayReadyRevocationServiceRequest) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PlayReadyRevocationServiceRequest) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PlayReadyRevocationServiceRequest) },
        { },
    };

    static PyType_Spec type_spec_PlayReadyRevocationServiceRequest =
    {
        "winrt._winrt_windows_media_protection_playready.PlayReadyRevocationServiceRequest",
        sizeof(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyRevocationServiceRequest),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PlayReadyRevocationServiceRequest
    };

    // ----- PlayReadySecureStopIterable class --------------------

    static PyObject* _new_PlayReadySecureStopIterable(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<py::pybuf_view<uint8_t, false>>(args, 0);

                winrt::Windows::Media::Protection::PlayReady::PlayReadySecureStopIterable instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_PlayReadySecureStopIterable(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadySecureStopIterable* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PlayReadySecureStopIterable_First(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadySecureStopIterable* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Protection.PlayReady.PlayReadySecureStopIterable", L"First", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.First());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_PlayReadySecureStopIterable(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Protection::PlayReady::PlayReadySecureStopIterable>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PlayReadySecureStopIterable(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Protection::PlayReady::PlayReadySecureStopIterable>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _iterator_PlayReadySecureStopIterable(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadySecureStopIterable* self) noexcept
    {
        try
        {
            return py::convert(self->obj.First());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PlayReadySecureStopIterable[] = {
        { "first", reinterpret_cast<PyCFunction>(PlayReadySecureStopIterable_First), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_PlayReadySecureStopIterable, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PlayReadySecureStopIterable), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PlayReadySecureStopIterable[] = {
        { }
    };

    static PyType_Slot _type_slots_PlayReadySecureStopIterable[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PlayReadySecureStopIterable) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PlayReadySecureStopIterable) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PlayReadySecureStopIterable) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PlayReadySecureStopIterable) },
        { Py_tp_iter, reinterpret_cast<void*>(_iterator_PlayReadySecureStopIterable) },
        { },
    };

    static PyType_Spec type_spec_PlayReadySecureStopIterable =
    {
        "winrt._winrt_windows_media_protection_playready.PlayReadySecureStopIterable",
        sizeof(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadySecureStopIterable),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PlayReadySecureStopIterable
    };

    // ----- PlayReadySecureStopIterator class --------------------

    static PyObject* _new_PlayReadySecureStopIterator(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Protection::PlayReady::PlayReadySecureStopIterator>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Protection::PlayReady::PlayReadySecureStopIterator>::type_name);
        return nullptr;
    }

    static void _dealloc_PlayReadySecureStopIterator(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadySecureStopIterator* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PlayReadySecureStopIterator_GetMany(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadySecureStopIterator* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Protection.PlayReady.PlayReadySecureStopIterator", L"GetMany", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                auto param0 = py::convert_to<py::pybuf_view<winrt::Windows::Media::Protection::PlayReady::IPlayReadySecureStopServiceRequest, true>>(args, 0);

                return py::convert(self->obj.GetMany(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PlayReadySecureStopIterator_MoveNext(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadySecureStopIterator* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Protection.PlayReady.PlayReadySecureStopIterator", L"MoveNext", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.MoveNext());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PlayReadySecureStopIterator_get_Current(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadySecureStopIterator* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.PlayReadySecureStopIterator", L"Current"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Current());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PlayReadySecureStopIterator_get_HasCurrent(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadySecureStopIterator* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.PlayReadySecureStopIterator", L"HasCurrent"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.HasCurrent());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PlayReadySecureStopIterator(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Protection::PlayReady::PlayReadySecureStopIterator>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PlayReadySecureStopIterator(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Protection::PlayReady::PlayReadySecureStopIterator>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _iterator_PlayReadySecureStopIterator(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadySecureStopIterator* self) noexcept
    {
        return reinterpret_cast<PyObject*>(self);
    }

    static PyObject* _iterator_next_PlayReadySecureStopIterator(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadySecureStopIterator* self) noexcept
    {
        try
        {
            if (self->obj.HasCurrent())
            {
                auto cur = self->obj.Current();
                self->obj.MoveNext();
                return py::convert(cur);
            }
            else
            {
                return nullptr;
            }}
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PlayReadySecureStopIterator[] = {
        { "get_many", reinterpret_cast<PyCFunction>(PlayReadySecureStopIterator_GetMany), METH_VARARGS, nullptr },
        { "move_next", reinterpret_cast<PyCFunction>(PlayReadySecureStopIterator_MoveNext), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_PlayReadySecureStopIterator, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PlayReadySecureStopIterator), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PlayReadySecureStopIterator[] = {
        { "current", reinterpret_cast<getter>(PlayReadySecureStopIterator_get_Current), nullptr, nullptr, nullptr },
        { "has_current", reinterpret_cast<getter>(PlayReadySecureStopIterator_get_HasCurrent), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PlayReadySecureStopIterator[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PlayReadySecureStopIterator) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PlayReadySecureStopIterator) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PlayReadySecureStopIterator) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PlayReadySecureStopIterator) },
        { Py_tp_iter, reinterpret_cast<void*>(_iterator_PlayReadySecureStopIterator) },
        { Py_tp_iternext, reinterpret_cast<void*>(_iterator_next_PlayReadySecureStopIterator) },
        { },
    };

    static PyType_Spec type_spec_PlayReadySecureStopIterator =
    {
        "winrt._winrt_windows_media_protection_playready.PlayReadySecureStopIterator",
        sizeof(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadySecureStopIterator),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PlayReadySecureStopIterator
    };

    // ----- PlayReadySecureStopServiceRequest class --------------------

    static PyObject* _new_PlayReadySecureStopServiceRequest(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<py::pybuf_view<uint8_t, false>>(args, 0);

                winrt::Windows::Media::Protection::PlayReady::PlayReadySecureStopServiceRequest instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::guid>(args, 0);
                auto param1 = py::convert_to<py::pybuf_view<uint8_t, false>>(args, 1);

                winrt::Windows::Media::Protection::PlayReady::PlayReadySecureStopServiceRequest instance{ param0, param1 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_PlayReadySecureStopServiceRequest(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadySecureStopServiceRequest* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PlayReadySecureStopServiceRequest_BeginServiceRequest(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadySecureStopServiceRequest* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Protection.PlayReady.PlayReadySecureStopServiceRequest", L"BeginServiceRequest", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.BeginServiceRequest());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PlayReadySecureStopServiceRequest_GenerateManualEnablingChallenge(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadySecureStopServiceRequest* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Protection.PlayReady.PlayReadySecureStopServiceRequest", L"GenerateManualEnablingChallenge", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GenerateManualEnablingChallenge());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PlayReadySecureStopServiceRequest_NextServiceRequest(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadySecureStopServiceRequest* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Protection.PlayReady.PlayReadySecureStopServiceRequest", L"NextServiceRequest", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.NextServiceRequest());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PlayReadySecureStopServiceRequest_ProcessManualEnablingResponse(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadySecureStopServiceRequest* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Protection.PlayReady.PlayReadySecureStopServiceRequest", L"ProcessManualEnablingResponse", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<py::pybuf_view<uint8_t, false>>(args, 0);

                return py::convert(self->obj.ProcessManualEnablingResponse(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PlayReadySecureStopServiceRequest_get_ProtectionSystem(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadySecureStopServiceRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.PlayReadySecureStopServiceRequest", L"ProtectionSystem"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ProtectionSystem());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PlayReadySecureStopServiceRequest_get_Type(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadySecureStopServiceRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.PlayReadySecureStopServiceRequest", L"Type"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Type());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PlayReadySecureStopServiceRequest_get_PublisherCertificate(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadySecureStopServiceRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.PlayReadySecureStopServiceRequest", L"PublisherCertificate"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.PublisherCertificate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PlayReadySecureStopServiceRequest_get_SessionID(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadySecureStopServiceRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.PlayReadySecureStopServiceRequest", L"SessionID"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SessionID());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PlayReadySecureStopServiceRequest_get_StartTime(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadySecureStopServiceRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.PlayReadySecureStopServiceRequest", L"StartTime"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.StartTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PlayReadySecureStopServiceRequest_get_Stopped(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadySecureStopServiceRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.PlayReadySecureStopServiceRequest", L"Stopped"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Stopped());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PlayReadySecureStopServiceRequest_get_UpdateTime(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadySecureStopServiceRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.PlayReadySecureStopServiceRequest", L"UpdateTime"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.UpdateTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PlayReadySecureStopServiceRequest_get_Uri(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadySecureStopServiceRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.PlayReadySecureStopServiceRequest", L"Uri"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Uri());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PlayReadySecureStopServiceRequest_put_Uri(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadySecureStopServiceRequest* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.PlayReadySecureStopServiceRequest", L"Uri"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(arg);

            self->obj.Uri(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PlayReadySecureStopServiceRequest_get_ChallengeCustomData(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadySecureStopServiceRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.PlayReadySecureStopServiceRequest", L"ChallengeCustomData"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ChallengeCustomData());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PlayReadySecureStopServiceRequest_put_ChallengeCustomData(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadySecureStopServiceRequest* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.PlayReadySecureStopServiceRequest", L"ChallengeCustomData"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.ChallengeCustomData(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PlayReadySecureStopServiceRequest_get_ResponseCustomData(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadySecureStopServiceRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.PlayReadySecureStopServiceRequest", L"ResponseCustomData"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ResponseCustomData());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PlayReadySecureStopServiceRequest(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Protection::PlayReady::PlayReadySecureStopServiceRequest>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PlayReadySecureStopServiceRequest(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Protection::PlayReady::PlayReadySecureStopServiceRequest>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PlayReadySecureStopServiceRequest[] = {
        { "begin_service_request", reinterpret_cast<PyCFunction>(PlayReadySecureStopServiceRequest_BeginServiceRequest), METH_VARARGS, nullptr },
        { "generate_manual_enabling_challenge", reinterpret_cast<PyCFunction>(PlayReadySecureStopServiceRequest_GenerateManualEnablingChallenge), METH_VARARGS, nullptr },
        { "next_service_request", reinterpret_cast<PyCFunction>(PlayReadySecureStopServiceRequest_NextServiceRequest), METH_VARARGS, nullptr },
        { "process_manual_enabling_response", reinterpret_cast<PyCFunction>(PlayReadySecureStopServiceRequest_ProcessManualEnablingResponse), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_PlayReadySecureStopServiceRequest, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PlayReadySecureStopServiceRequest), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PlayReadySecureStopServiceRequest[] = {
        { "protection_system", reinterpret_cast<getter>(PlayReadySecureStopServiceRequest_get_ProtectionSystem), nullptr, nullptr, nullptr },
        { "type", reinterpret_cast<getter>(PlayReadySecureStopServiceRequest_get_Type), nullptr, nullptr, nullptr },
        { "publisher_certificate", reinterpret_cast<getter>(PlayReadySecureStopServiceRequest_get_PublisherCertificate), nullptr, nullptr, nullptr },
        { "session_i_d", reinterpret_cast<getter>(PlayReadySecureStopServiceRequest_get_SessionID), nullptr, nullptr, nullptr },
        { "start_time", reinterpret_cast<getter>(PlayReadySecureStopServiceRequest_get_StartTime), nullptr, nullptr, nullptr },
        { "stopped", reinterpret_cast<getter>(PlayReadySecureStopServiceRequest_get_Stopped), nullptr, nullptr, nullptr },
        { "update_time", reinterpret_cast<getter>(PlayReadySecureStopServiceRequest_get_UpdateTime), nullptr, nullptr, nullptr },
        { "uri", reinterpret_cast<getter>(PlayReadySecureStopServiceRequest_get_Uri), reinterpret_cast<setter>(PlayReadySecureStopServiceRequest_put_Uri), nullptr, nullptr },
        { "challenge_custom_data", reinterpret_cast<getter>(PlayReadySecureStopServiceRequest_get_ChallengeCustomData), reinterpret_cast<setter>(PlayReadySecureStopServiceRequest_put_ChallengeCustomData), nullptr, nullptr },
        { "response_custom_data", reinterpret_cast<getter>(PlayReadySecureStopServiceRequest_get_ResponseCustomData), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PlayReadySecureStopServiceRequest[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PlayReadySecureStopServiceRequest) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PlayReadySecureStopServiceRequest) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PlayReadySecureStopServiceRequest) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PlayReadySecureStopServiceRequest) },
        { },
    };

    static PyType_Spec type_spec_PlayReadySecureStopServiceRequest =
    {
        "winrt._winrt_windows_media_protection_playready.PlayReadySecureStopServiceRequest",
        sizeof(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadySecureStopServiceRequest),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PlayReadySecureStopServiceRequest
    };

    // ----- PlayReadySoapMessage class --------------------

    static PyObject* _new_PlayReadySoapMessage(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Protection::PlayReady::PlayReadySoapMessage>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Protection::PlayReady::PlayReadySoapMessage>::type_name);
        return nullptr;
    }

    static void _dealloc_PlayReadySoapMessage(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadySoapMessage* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PlayReadySoapMessage_GetMessageBody(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadySoapMessage* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Protection.PlayReady.PlayReadySoapMessage", L"GetMessageBody", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetMessageBody());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PlayReadySoapMessage_get_MessageHeaders(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadySoapMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.PlayReadySoapMessage", L"MessageHeaders"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.MessageHeaders());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PlayReadySoapMessage_get_Uri(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadySoapMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.PlayReadySoapMessage", L"Uri"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Uri());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PlayReadySoapMessage(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Protection::PlayReady::PlayReadySoapMessage>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PlayReadySoapMessage(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Protection::PlayReady::PlayReadySoapMessage>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PlayReadySoapMessage[] = {
        { "get_message_body", reinterpret_cast<PyCFunction>(PlayReadySoapMessage_GetMessageBody), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_PlayReadySoapMessage, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PlayReadySoapMessage), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PlayReadySoapMessage[] = {
        { "message_headers", reinterpret_cast<getter>(PlayReadySoapMessage_get_MessageHeaders), nullptr, nullptr, nullptr },
        { "uri", reinterpret_cast<getter>(PlayReadySoapMessage_get_Uri), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PlayReadySoapMessage[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PlayReadySoapMessage) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PlayReadySoapMessage) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PlayReadySoapMessage) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PlayReadySoapMessage) },
        { },
    };

    static PyType_Spec type_spec_PlayReadySoapMessage =
    {
        "winrt._winrt_windows_media_protection_playready.PlayReadySoapMessage",
        sizeof(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadySoapMessage),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PlayReadySoapMessage
    };

    // ----- PlayReadyStatics class --------------------

    static PyObject* _new_PlayReadyStatics(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Protection::PlayReady::PlayReadyStatics>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Protection::PlayReady::PlayReadyStatics>::type_name);
        return nullptr;
    }

    static PyObject* PlayReadyStatics_CheckSupportedHardware(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Protection.PlayReady.PlayReadyStatics", L"CheckSupportedHardware", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Media::Protection::PlayReady::PlayReadyHardwareDRMFeatures>(args, 0);

                return py::convert(winrt::Windows::Media::Protection::PlayReady::PlayReadyStatics::CheckSupportedHardware(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PlayReadyStatics_ResetHardwareDRMDisabled(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Protection.PlayReady.PlayReadyStatics", L"ResetHardwareDRMDisabled", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                winrt::Windows::Media::Protection::PlayReady::PlayReadyStatics::ResetHardwareDRMDisabled();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PlayReadyStatics_get_DomainJoinServiceRequestType(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.PlayReadyStatics", L"DomainJoinServiceRequestType"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Media::Protection::PlayReady::PlayReadyStatics::DomainJoinServiceRequestType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PlayReadyStatics_get_DomainLeaveServiceRequestType(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.PlayReadyStatics", L"DomainLeaveServiceRequestType"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Media::Protection::PlayReady::PlayReadyStatics::DomainLeaveServiceRequestType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PlayReadyStatics_get_IndividualizationServiceRequestType(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.PlayReadyStatics", L"IndividualizationServiceRequestType"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Media::Protection::PlayReady::PlayReadyStatics::IndividualizationServiceRequestType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PlayReadyStatics_get_LicenseAcquirerServiceRequestType(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.PlayReadyStatics", L"LicenseAcquirerServiceRequestType"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Media::Protection::PlayReady::PlayReadyStatics::LicenseAcquirerServiceRequestType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PlayReadyStatics_get_MediaProtectionSystemId(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.PlayReadyStatics", L"MediaProtectionSystemId"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Media::Protection::PlayReady::PlayReadyStatics::MediaProtectionSystemId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PlayReadyStatics_get_MeteringReportServiceRequestType(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.PlayReadyStatics", L"MeteringReportServiceRequestType"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Media::Protection::PlayReady::PlayReadyStatics::MeteringReportServiceRequestType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PlayReadyStatics_get_PlayReadySecurityVersion(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.PlayReadyStatics", L"PlayReadySecurityVersion"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Media::Protection::PlayReady::PlayReadyStatics::PlayReadySecurityVersion());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PlayReadyStatics_get_RevocationServiceRequestType(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.PlayReadyStatics", L"RevocationServiceRequestType"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Media::Protection::PlayReady::PlayReadyStatics::RevocationServiceRequestType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PlayReadyStatics_get_PlayReadyCertificateSecurityLevel(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.PlayReadyStatics", L"PlayReadyCertificateSecurityLevel"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Media::Protection::PlayReady::PlayReadyStatics::PlayReadyCertificateSecurityLevel());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PlayReadyStatics_get_SecureStopServiceRequestType(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.PlayReadyStatics", L"SecureStopServiceRequestType"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Media::Protection::PlayReady::PlayReadyStatics::SecureStopServiceRequestType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PlayReadyStatics_get_ProtectionSystemId(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.PlayReadyStatics", L"ProtectionSystemId"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Media::Protection::PlayReady::PlayReadyStatics::ProtectionSystemId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PlayReadyStatics_get_InputTrustAuthorityToCreate(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.PlayReadyStatics", L"InputTrustAuthorityToCreate"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Media::Protection::PlayReady::PlayReadyStatics::InputTrustAuthorityToCreate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PlayReadyStatics_get_HardwareDRMDisabledUntilTime(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.PlayReadyStatics", L"HardwareDRMDisabledUntilTime"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Media::Protection::PlayReady::PlayReadyStatics::HardwareDRMDisabledUntilTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PlayReadyStatics_get_HardwareDRMDisabledAtTime(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.PlayReadyStatics", L"HardwareDRMDisabledAtTime"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Media::Protection::PlayReady::PlayReadyStatics::HardwareDRMDisabledAtTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PlayReadyStatics[] = {
        { }
    };

    static PyGetSetDef _getset_PlayReadyStatics[] = {
        { }
    };

    static PyType_Slot _type_slots_PlayReadyStatics[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PlayReadyStatics) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PlayReadyStatics) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PlayReadyStatics) },
        { },
    };

    static PyType_Spec type_spec_PlayReadyStatics =
    {
        "winrt._winrt_windows_media_protection_playready.PlayReadyStatics",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PlayReadyStatics
    };

    static PyGetSetDef getset_PlayReadyStatics_Static[] = {
        { "domain_join_service_request_type", reinterpret_cast<getter>(PlayReadyStatics_get_DomainJoinServiceRequestType), nullptr, nullptr, nullptr },
        { "domain_leave_service_request_type", reinterpret_cast<getter>(PlayReadyStatics_get_DomainLeaveServiceRequestType), nullptr, nullptr, nullptr },
        { "individualization_service_request_type", reinterpret_cast<getter>(PlayReadyStatics_get_IndividualizationServiceRequestType), nullptr, nullptr, nullptr },
        { "license_acquirer_service_request_type", reinterpret_cast<getter>(PlayReadyStatics_get_LicenseAcquirerServiceRequestType), nullptr, nullptr, nullptr },
        { "media_protection_system_id", reinterpret_cast<getter>(PlayReadyStatics_get_MediaProtectionSystemId), nullptr, nullptr, nullptr },
        { "metering_report_service_request_type", reinterpret_cast<getter>(PlayReadyStatics_get_MeteringReportServiceRequestType), nullptr, nullptr, nullptr },
        { "play_ready_security_version", reinterpret_cast<getter>(PlayReadyStatics_get_PlayReadySecurityVersion), nullptr, nullptr, nullptr },
        { "revocation_service_request_type", reinterpret_cast<getter>(PlayReadyStatics_get_RevocationServiceRequestType), nullptr, nullptr, nullptr },
        { "play_ready_certificate_security_level", reinterpret_cast<getter>(PlayReadyStatics_get_PlayReadyCertificateSecurityLevel), nullptr, nullptr, nullptr },
        { "secure_stop_service_request_type", reinterpret_cast<getter>(PlayReadyStatics_get_SecureStopServiceRequestType), nullptr, nullptr, nullptr },
        { "protection_system_id", reinterpret_cast<getter>(PlayReadyStatics_get_ProtectionSystemId), nullptr, nullptr, nullptr },
        { "input_trust_authority_to_create", reinterpret_cast<getter>(PlayReadyStatics_get_InputTrustAuthorityToCreate), nullptr, nullptr, nullptr },
        { "hardware_d_r_m_disabled_until_time", reinterpret_cast<getter>(PlayReadyStatics_get_HardwareDRMDisabledUntilTime), nullptr, nullptr, nullptr },
        { "hardware_d_r_m_disabled_at_time", reinterpret_cast<getter>(PlayReadyStatics_get_HardwareDRMDisabledAtTime), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_PlayReadyStatics_Static[] = {
        { "check_supported_hardware", reinterpret_cast<PyCFunction>(PlayReadyStatics_CheckSupportedHardware), METH_VARARGS, nullptr },
        { "reset_hardware_d_r_m_disabled", reinterpret_cast<PyCFunction>(PlayReadyStatics_ResetHardwareDRMDisabled), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_PlayReadyStatics_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_PlayReadyStatics_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_PlayReadyStatics_Static) },
        { }
    };

    static PyType_Spec type_spec_PlayReadyStatics_Static =
    {
        "winrt._winrt_windows_media_protection_playready.PlayReadyStatics_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_PlayReadyStatics_Static
    };

    // ----- INDClosedCaptionDataReceivedEventArgs interface --------------------

    static PyObject* _new_INDClosedCaptionDataReceivedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Protection::PlayReady::INDClosedCaptionDataReceivedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Protection::PlayReady::INDClosedCaptionDataReceivedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_INDClosedCaptionDataReceivedEventArgs(py::wrapper::Windows::Media::Protection::PlayReady::INDClosedCaptionDataReceivedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* INDClosedCaptionDataReceivedEventArgs_get_ClosedCaptionData(py::wrapper::Windows::Media::Protection::PlayReady::INDClosedCaptionDataReceivedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.INDClosedCaptionDataReceivedEventArgs", L"ClosedCaptionData"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ClosedCaptionData());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* INDClosedCaptionDataReceivedEventArgs_get_ClosedCaptionDataFormat(py::wrapper::Windows::Media::Protection::PlayReady::INDClosedCaptionDataReceivedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.INDClosedCaptionDataReceivedEventArgs", L"ClosedCaptionDataFormat"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ClosedCaptionDataFormat());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* INDClosedCaptionDataReceivedEventArgs_get_PresentationTimestamp(py::wrapper::Windows::Media::Protection::PlayReady::INDClosedCaptionDataReceivedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.INDClosedCaptionDataReceivedEventArgs", L"PresentationTimestamp"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.PresentationTimestamp());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_INDClosedCaptionDataReceivedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Protection::PlayReady::INDClosedCaptionDataReceivedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_INDClosedCaptionDataReceivedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Protection::PlayReady::INDClosedCaptionDataReceivedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_INDClosedCaptionDataReceivedEventArgs[] = {
        { "_assign_array_", _assign_array_INDClosedCaptionDataReceivedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_INDClosedCaptionDataReceivedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_INDClosedCaptionDataReceivedEventArgs[] = {
        { "closed_caption_data", reinterpret_cast<getter>(INDClosedCaptionDataReceivedEventArgs_get_ClosedCaptionData), nullptr, nullptr, nullptr },
        { "closed_caption_data_format", reinterpret_cast<getter>(INDClosedCaptionDataReceivedEventArgs_get_ClosedCaptionDataFormat), nullptr, nullptr, nullptr },
        { "presentation_timestamp", reinterpret_cast<getter>(INDClosedCaptionDataReceivedEventArgs_get_PresentationTimestamp), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_INDClosedCaptionDataReceivedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_INDClosedCaptionDataReceivedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_INDClosedCaptionDataReceivedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_INDClosedCaptionDataReceivedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_INDClosedCaptionDataReceivedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_INDClosedCaptionDataReceivedEventArgs =
    {
        "winrt._winrt_windows_media_protection_playready.INDClosedCaptionDataReceivedEventArgs",
        sizeof(py::wrapper::Windows::Media::Protection::PlayReady::INDClosedCaptionDataReceivedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_INDClosedCaptionDataReceivedEventArgs
    };

    // ----- INDCustomData interface --------------------

    static PyObject* _new_INDCustomData(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Protection::PlayReady::INDCustomData>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Protection::PlayReady::INDCustomData>::type_name);
        return nullptr;
    }

    static void _dealloc_INDCustomData(py::wrapper::Windows::Media::Protection::PlayReady::INDCustomData* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* INDCustomData_get_CustomData(py::wrapper::Windows::Media::Protection::PlayReady::INDCustomData* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.INDCustomData", L"CustomData"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CustomData());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* INDCustomData_get_CustomDataTypeID(py::wrapper::Windows::Media::Protection::PlayReady::INDCustomData* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.INDCustomData", L"CustomDataTypeID"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CustomDataTypeID());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_INDCustomData(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Protection::PlayReady::INDCustomData>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_INDCustomData(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Protection::PlayReady::INDCustomData>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_INDCustomData[] = {
        { "_assign_array_", _assign_array_INDCustomData, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_INDCustomData), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_INDCustomData[] = {
        { "custom_data", reinterpret_cast<getter>(INDCustomData_get_CustomData), nullptr, nullptr, nullptr },
        { "custom_data_type_i_d", reinterpret_cast<getter>(INDCustomData_get_CustomDataTypeID), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_INDCustomData[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_INDCustomData) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_INDCustomData) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_INDCustomData) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_INDCustomData) },
        { },
    };

    static PyType_Spec type_spec_INDCustomData =
    {
        "winrt._winrt_windows_media_protection_playready.INDCustomData",
        sizeof(py::wrapper::Windows::Media::Protection::PlayReady::INDCustomData),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_INDCustomData
    };

    // ----- INDDownloadEngine interface --------------------

    static PyObject* _new_INDDownloadEngine(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Protection::PlayReady::INDDownloadEngine>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Protection::PlayReady::INDDownloadEngine>::type_name);
        return nullptr;
    }

    static void _dealloc_INDDownloadEngine(py::wrapper::Windows::Media::Protection::PlayReady::INDDownloadEngine* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* INDDownloadEngine_Close(py::wrapper::Windows::Media::Protection::PlayReady::INDDownloadEngine* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Protection.PlayReady.INDDownloadEngine", L"Close", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* INDDownloadEngine_Open(py::wrapper::Windows::Media::Protection::PlayReady::INDDownloadEngine* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Protection.PlayReady.INDDownloadEngine", L"Open", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);
                auto param1 = py::convert_to<py::pybuf_view<uint8_t, false>>(args, 1);

                self->obj.Open(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* INDDownloadEngine_Pause(py::wrapper::Windows::Media::Protection::PlayReady::INDDownloadEngine* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Protection.PlayReady.INDDownloadEngine", L"Pause", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Pause();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* INDDownloadEngine_Resume(py::wrapper::Windows::Media::Protection::PlayReady::INDDownloadEngine* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Protection.PlayReady.INDDownloadEngine", L"Resume", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Resume();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* INDDownloadEngine_Seek(py::wrapper::Windows::Media::Protection::PlayReady::INDDownloadEngine* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Protection.PlayReady.INDDownloadEngine", L"Seek", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(args, 0);

                self->obj.Seek(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* INDDownloadEngine_get_BufferFullMaxThresholdInSamples(py::wrapper::Windows::Media::Protection::PlayReady::INDDownloadEngine* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.INDDownloadEngine", L"BufferFullMaxThresholdInSamples"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.BufferFullMaxThresholdInSamples());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* INDDownloadEngine_get_BufferFullMinThresholdInSamples(py::wrapper::Windows::Media::Protection::PlayReady::INDDownloadEngine* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.INDDownloadEngine", L"BufferFullMinThresholdInSamples"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.BufferFullMinThresholdInSamples());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* INDDownloadEngine_get_CanSeek(py::wrapper::Windows::Media::Protection::PlayReady::INDDownloadEngine* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.INDDownloadEngine", L"CanSeek"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CanSeek());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* INDDownloadEngine_get_Notifier(py::wrapper::Windows::Media::Protection::PlayReady::INDDownloadEngine* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.INDDownloadEngine", L"Notifier"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Notifier());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_INDDownloadEngine(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Protection::PlayReady::INDDownloadEngine>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_INDDownloadEngine(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Protection::PlayReady::INDDownloadEngine>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_INDDownloadEngine[] = {
        { "close", reinterpret_cast<PyCFunction>(INDDownloadEngine_Close), METH_VARARGS, nullptr },
        { "open", reinterpret_cast<PyCFunction>(INDDownloadEngine_Open), METH_VARARGS, nullptr },
        { "pause", reinterpret_cast<PyCFunction>(INDDownloadEngine_Pause), METH_VARARGS, nullptr },
        { "resume", reinterpret_cast<PyCFunction>(INDDownloadEngine_Resume), METH_VARARGS, nullptr },
        { "seek", reinterpret_cast<PyCFunction>(INDDownloadEngine_Seek), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_INDDownloadEngine, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_INDDownloadEngine), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_INDDownloadEngine[] = {
        { "buffer_full_max_threshold_in_samples", reinterpret_cast<getter>(INDDownloadEngine_get_BufferFullMaxThresholdInSamples), nullptr, nullptr, nullptr },
        { "buffer_full_min_threshold_in_samples", reinterpret_cast<getter>(INDDownloadEngine_get_BufferFullMinThresholdInSamples), nullptr, nullptr, nullptr },
        { "can_seek", reinterpret_cast<getter>(INDDownloadEngine_get_CanSeek), nullptr, nullptr, nullptr },
        { "notifier", reinterpret_cast<getter>(INDDownloadEngine_get_Notifier), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_INDDownloadEngine[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_INDDownloadEngine) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_INDDownloadEngine) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_INDDownloadEngine) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_INDDownloadEngine) },
        { },
    };

    static PyType_Spec type_spec_INDDownloadEngine =
    {
        "winrt._winrt_windows_media_protection_playready.INDDownloadEngine",
        sizeof(py::wrapper::Windows::Media::Protection::PlayReady::INDDownloadEngine),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_INDDownloadEngine
    };

    // ----- INDDownloadEngineNotifier interface --------------------

    static PyObject* _new_INDDownloadEngineNotifier(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Protection::PlayReady::INDDownloadEngineNotifier>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Protection::PlayReady::INDDownloadEngineNotifier>::type_name);
        return nullptr;
    }

    static void _dealloc_INDDownloadEngineNotifier(py::wrapper::Windows::Media::Protection::PlayReady::INDDownloadEngineNotifier* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* INDDownloadEngineNotifier_OnContentIDReceived(py::wrapper::Windows::Media::Protection::PlayReady::INDDownloadEngineNotifier* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Protection.PlayReady.INDDownloadEngineNotifier", L"OnContentIDReceived", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Media::Protection::PlayReady::INDLicenseFetchDescriptor>(args, 0);

                self->obj.OnContentIDReceived(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* INDDownloadEngineNotifier_OnDataReceived(py::wrapper::Windows::Media::Protection::PlayReady::INDDownloadEngineNotifier* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Protection.PlayReady.INDDownloadEngineNotifier", L"OnDataReceived", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<py::pybuf_view<uint8_t, false>>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);

                self->obj.OnDataReceived(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* INDDownloadEngineNotifier_OnEndOfStream(py::wrapper::Windows::Media::Protection::PlayReady::INDDownloadEngineNotifier* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Protection.PlayReady.INDDownloadEngineNotifier", L"OnEndOfStream", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.OnEndOfStream();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* INDDownloadEngineNotifier_OnNetworkError(py::wrapper::Windows::Media::Protection::PlayReady::INDDownloadEngineNotifier* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Protection.PlayReady.INDDownloadEngineNotifier", L"OnNetworkError", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.OnNetworkError();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* INDDownloadEngineNotifier_OnPlayReadyObjectReceived(py::wrapper::Windows::Media::Protection::PlayReady::INDDownloadEngineNotifier* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Protection.PlayReady.INDDownloadEngineNotifier", L"OnPlayReadyObjectReceived", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<py::pybuf_view<uint8_t, false>>(args, 0);

                self->obj.OnPlayReadyObjectReceived(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* INDDownloadEngineNotifier_OnStreamOpened(py::wrapper::Windows::Media::Protection::PlayReady::INDDownloadEngineNotifier* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Protection.PlayReady.INDDownloadEngineNotifier", L"OnStreamOpened", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.OnStreamOpened();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_INDDownloadEngineNotifier(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Protection::PlayReady::INDDownloadEngineNotifier>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_INDDownloadEngineNotifier(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Protection::PlayReady::INDDownloadEngineNotifier>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_INDDownloadEngineNotifier[] = {
        { "on_content_i_d_received", reinterpret_cast<PyCFunction>(INDDownloadEngineNotifier_OnContentIDReceived), METH_VARARGS, nullptr },
        { "on_data_received", reinterpret_cast<PyCFunction>(INDDownloadEngineNotifier_OnDataReceived), METH_VARARGS, nullptr },
        { "on_end_of_stream", reinterpret_cast<PyCFunction>(INDDownloadEngineNotifier_OnEndOfStream), METH_VARARGS, nullptr },
        { "on_network_error", reinterpret_cast<PyCFunction>(INDDownloadEngineNotifier_OnNetworkError), METH_VARARGS, nullptr },
        { "on_play_ready_object_received", reinterpret_cast<PyCFunction>(INDDownloadEngineNotifier_OnPlayReadyObjectReceived), METH_VARARGS, nullptr },
        { "on_stream_opened", reinterpret_cast<PyCFunction>(INDDownloadEngineNotifier_OnStreamOpened), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_INDDownloadEngineNotifier, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_INDDownloadEngineNotifier), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_INDDownloadEngineNotifier[] = {
        { }
    };

    static PyType_Slot _type_slots_INDDownloadEngineNotifier[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_INDDownloadEngineNotifier) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_INDDownloadEngineNotifier) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_INDDownloadEngineNotifier) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_INDDownloadEngineNotifier) },
        { },
    };

    static PyType_Spec type_spec_INDDownloadEngineNotifier =
    {
        "winrt._winrt_windows_media_protection_playready.INDDownloadEngineNotifier",
        sizeof(py::wrapper::Windows::Media::Protection::PlayReady::INDDownloadEngineNotifier),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_INDDownloadEngineNotifier
    };

    // ----- INDLicenseFetchCompletedEventArgs interface --------------------

    static PyObject* _new_INDLicenseFetchCompletedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Protection::PlayReady::INDLicenseFetchCompletedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Protection::PlayReady::INDLicenseFetchCompletedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_INDLicenseFetchCompletedEventArgs(py::wrapper::Windows::Media::Protection::PlayReady::INDLicenseFetchCompletedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* INDLicenseFetchCompletedEventArgs_get_ResponseCustomData(py::wrapper::Windows::Media::Protection::PlayReady::INDLicenseFetchCompletedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.INDLicenseFetchCompletedEventArgs", L"ResponseCustomData"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ResponseCustomData());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_INDLicenseFetchCompletedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Protection::PlayReady::INDLicenseFetchCompletedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_INDLicenseFetchCompletedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Protection::PlayReady::INDLicenseFetchCompletedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_INDLicenseFetchCompletedEventArgs[] = {
        { "_assign_array_", _assign_array_INDLicenseFetchCompletedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_INDLicenseFetchCompletedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_INDLicenseFetchCompletedEventArgs[] = {
        { "response_custom_data", reinterpret_cast<getter>(INDLicenseFetchCompletedEventArgs_get_ResponseCustomData), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_INDLicenseFetchCompletedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_INDLicenseFetchCompletedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_INDLicenseFetchCompletedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_INDLicenseFetchCompletedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_INDLicenseFetchCompletedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_INDLicenseFetchCompletedEventArgs =
    {
        "winrt._winrt_windows_media_protection_playready.INDLicenseFetchCompletedEventArgs",
        sizeof(py::wrapper::Windows::Media::Protection::PlayReady::INDLicenseFetchCompletedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_INDLicenseFetchCompletedEventArgs
    };

    // ----- INDLicenseFetchDescriptor interface --------------------

    static PyObject* _new_INDLicenseFetchDescriptor(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Protection::PlayReady::INDLicenseFetchDescriptor>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Protection::PlayReady::INDLicenseFetchDescriptor>::type_name);
        return nullptr;
    }

    static void _dealloc_INDLicenseFetchDescriptor(py::wrapper::Windows::Media::Protection::PlayReady::INDLicenseFetchDescriptor* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* INDLicenseFetchDescriptor_get_ContentID(py::wrapper::Windows::Media::Protection::PlayReady::INDLicenseFetchDescriptor* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.INDLicenseFetchDescriptor", L"ContentID"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ContentID());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* INDLicenseFetchDescriptor_get_ContentIDType(py::wrapper::Windows::Media::Protection::PlayReady::INDLicenseFetchDescriptor* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.INDLicenseFetchDescriptor", L"ContentIDType"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ContentIDType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* INDLicenseFetchDescriptor_get_LicenseFetchChallengeCustomData(py::wrapper::Windows::Media::Protection::PlayReady::INDLicenseFetchDescriptor* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.INDLicenseFetchDescriptor", L"LicenseFetchChallengeCustomData"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.LicenseFetchChallengeCustomData());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int INDLicenseFetchDescriptor_put_LicenseFetchChallengeCustomData(py::wrapper::Windows::Media::Protection::PlayReady::INDLicenseFetchDescriptor* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.INDLicenseFetchDescriptor", L"LicenseFetchChallengeCustomData"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Media::Protection::PlayReady::INDCustomData>(arg);

            self->obj.LicenseFetchChallengeCustomData(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_INDLicenseFetchDescriptor(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Protection::PlayReady::INDLicenseFetchDescriptor>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_INDLicenseFetchDescriptor(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Protection::PlayReady::INDLicenseFetchDescriptor>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_INDLicenseFetchDescriptor[] = {
        { "_assign_array_", _assign_array_INDLicenseFetchDescriptor, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_INDLicenseFetchDescriptor), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_INDLicenseFetchDescriptor[] = {
        { "content_i_d", reinterpret_cast<getter>(INDLicenseFetchDescriptor_get_ContentID), nullptr, nullptr, nullptr },
        { "content_i_d_type", reinterpret_cast<getter>(INDLicenseFetchDescriptor_get_ContentIDType), nullptr, nullptr, nullptr },
        { "license_fetch_challenge_custom_data", reinterpret_cast<getter>(INDLicenseFetchDescriptor_get_LicenseFetchChallengeCustomData), reinterpret_cast<setter>(INDLicenseFetchDescriptor_put_LicenseFetchChallengeCustomData), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_INDLicenseFetchDescriptor[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_INDLicenseFetchDescriptor) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_INDLicenseFetchDescriptor) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_INDLicenseFetchDescriptor) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_INDLicenseFetchDescriptor) },
        { },
    };

    static PyType_Spec type_spec_INDLicenseFetchDescriptor =
    {
        "winrt._winrt_windows_media_protection_playready.INDLicenseFetchDescriptor",
        sizeof(py::wrapper::Windows::Media::Protection::PlayReady::INDLicenseFetchDescriptor),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_INDLicenseFetchDescriptor
    };

    // ----- INDLicenseFetchResult interface --------------------

    static PyObject* _new_INDLicenseFetchResult(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Protection::PlayReady::INDLicenseFetchResult>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Protection::PlayReady::INDLicenseFetchResult>::type_name);
        return nullptr;
    }

    static void _dealloc_INDLicenseFetchResult(py::wrapper::Windows::Media::Protection::PlayReady::INDLicenseFetchResult* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* INDLicenseFetchResult_get_ResponseCustomData(py::wrapper::Windows::Media::Protection::PlayReady::INDLicenseFetchResult* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.INDLicenseFetchResult", L"ResponseCustomData"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ResponseCustomData());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_INDLicenseFetchResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Protection::PlayReady::INDLicenseFetchResult>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_INDLicenseFetchResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Protection::PlayReady::INDLicenseFetchResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_INDLicenseFetchResult[] = {
        { "_assign_array_", _assign_array_INDLicenseFetchResult, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_INDLicenseFetchResult), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_INDLicenseFetchResult[] = {
        { "response_custom_data", reinterpret_cast<getter>(INDLicenseFetchResult_get_ResponseCustomData), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_INDLicenseFetchResult[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_INDLicenseFetchResult) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_INDLicenseFetchResult) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_INDLicenseFetchResult) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_INDLicenseFetchResult) },
        { },
    };

    static PyType_Spec type_spec_INDLicenseFetchResult =
    {
        "winrt._winrt_windows_media_protection_playready.INDLicenseFetchResult",
        sizeof(py::wrapper::Windows::Media::Protection::PlayReady::INDLicenseFetchResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_INDLicenseFetchResult
    };

    // ----- INDMessenger interface --------------------

    static PyObject* _new_INDMessenger(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Protection::PlayReady::INDMessenger>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Protection::PlayReady::INDMessenger>::type_name);
        return nullptr;
    }

    static void _dealloc_INDMessenger(py::wrapper::Windows::Media::Protection::PlayReady::INDMessenger* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* INDMessenger_SendLicenseFetchRequestAsync(py::wrapper::Windows::Media::Protection::PlayReady::INDMessenger* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Protection.PlayReady.INDMessenger", L"SendLicenseFetchRequestAsync", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<py::pybuf_view<uint8_t, false>>(args, 0);
                auto param1 = py::convert_to<py::pybuf_view<uint8_t, false>>(args, 1);

                return py::convert(self->obj.SendLicenseFetchRequestAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* INDMessenger_SendProximityDetectionResponseAsync(py::wrapper::Windows::Media::Protection::PlayReady::INDMessenger* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 4)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Protection.PlayReady.INDMessenger", L"SendProximityDetectionResponseAsync", 4))
                {
                    py::set_arg_count_version_error(4);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Media::Protection::PlayReady::NDProximityDetectionType>(args, 0);
                auto param1 = py::convert_to<py::pybuf_view<uint8_t, false>>(args, 1);
                auto param2 = py::convert_to<py::pybuf_view<uint8_t, false>>(args, 2);
                auto param3 = py::convert_to<py::pybuf_view<uint8_t, false>>(args, 3);

                return py::convert(self->obj.SendProximityDetectionResponseAsync(param0, param1, param2, param3));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* INDMessenger_SendProximityDetectionStartAsync(py::wrapper::Windows::Media::Protection::PlayReady::INDMessenger* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 4)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Protection.PlayReady.INDMessenger", L"SendProximityDetectionStartAsync", 4))
                {
                    py::set_arg_count_version_error(4);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Media::Protection::PlayReady::NDProximityDetectionType>(args, 0);
                auto param1 = py::convert_to<py::pybuf_view<uint8_t, false>>(args, 1);
                auto param2 = py::convert_to<py::pybuf_view<uint8_t, false>>(args, 2);
                auto param3 = py::convert_to<py::pybuf_view<uint8_t, false>>(args, 3);

                return py::convert(self->obj.SendProximityDetectionStartAsync(param0, param1, param2, param3));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* INDMessenger_SendRegistrationRequestAsync(py::wrapper::Windows::Media::Protection::PlayReady::INDMessenger* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Protection.PlayReady.INDMessenger", L"SendRegistrationRequestAsync", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<py::pybuf_view<uint8_t, false>>(args, 0);
                auto param1 = py::convert_to<py::pybuf_view<uint8_t, false>>(args, 1);

                return py::convert(self->obj.SendRegistrationRequestAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_INDMessenger(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Protection::PlayReady::INDMessenger>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_INDMessenger(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Protection::PlayReady::INDMessenger>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_INDMessenger[] = {
        { "send_license_fetch_request_async", reinterpret_cast<PyCFunction>(INDMessenger_SendLicenseFetchRequestAsync), METH_VARARGS, nullptr },
        { "send_proximity_detection_response_async", reinterpret_cast<PyCFunction>(INDMessenger_SendProximityDetectionResponseAsync), METH_VARARGS, nullptr },
        { "send_proximity_detection_start_async", reinterpret_cast<PyCFunction>(INDMessenger_SendProximityDetectionStartAsync), METH_VARARGS, nullptr },
        { "send_registration_request_async", reinterpret_cast<PyCFunction>(INDMessenger_SendRegistrationRequestAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_INDMessenger, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_INDMessenger), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_INDMessenger[] = {
        { }
    };

    static PyType_Slot _type_slots_INDMessenger[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_INDMessenger) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_INDMessenger) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_INDMessenger) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_INDMessenger) },
        { },
    };

    static PyType_Spec type_spec_INDMessenger =
    {
        "winrt._winrt_windows_media_protection_playready.INDMessenger",
        sizeof(py::wrapper::Windows::Media::Protection::PlayReady::INDMessenger),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_INDMessenger
    };

    // ----- INDProximityDetectionCompletedEventArgs interface --------------------

    static PyObject* _new_INDProximityDetectionCompletedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Protection::PlayReady::INDProximityDetectionCompletedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Protection::PlayReady::INDProximityDetectionCompletedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_INDProximityDetectionCompletedEventArgs(py::wrapper::Windows::Media::Protection::PlayReady::INDProximityDetectionCompletedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* INDProximityDetectionCompletedEventArgs_get_ProximityDetectionRetryCount(py::wrapper::Windows::Media::Protection::PlayReady::INDProximityDetectionCompletedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.INDProximityDetectionCompletedEventArgs", L"ProximityDetectionRetryCount"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ProximityDetectionRetryCount());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_INDProximityDetectionCompletedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Protection::PlayReady::INDProximityDetectionCompletedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_INDProximityDetectionCompletedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Protection::PlayReady::INDProximityDetectionCompletedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_INDProximityDetectionCompletedEventArgs[] = {
        { "_assign_array_", _assign_array_INDProximityDetectionCompletedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_INDProximityDetectionCompletedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_INDProximityDetectionCompletedEventArgs[] = {
        { "proximity_detection_retry_count", reinterpret_cast<getter>(INDProximityDetectionCompletedEventArgs_get_ProximityDetectionRetryCount), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_INDProximityDetectionCompletedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_INDProximityDetectionCompletedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_INDProximityDetectionCompletedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_INDProximityDetectionCompletedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_INDProximityDetectionCompletedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_INDProximityDetectionCompletedEventArgs =
    {
        "winrt._winrt_windows_media_protection_playready.INDProximityDetectionCompletedEventArgs",
        sizeof(py::wrapper::Windows::Media::Protection::PlayReady::INDProximityDetectionCompletedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_INDProximityDetectionCompletedEventArgs
    };

    // ----- INDRegistrationCompletedEventArgs interface --------------------

    static PyObject* _new_INDRegistrationCompletedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Protection::PlayReady::INDRegistrationCompletedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Protection::PlayReady::INDRegistrationCompletedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_INDRegistrationCompletedEventArgs(py::wrapper::Windows::Media::Protection::PlayReady::INDRegistrationCompletedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* INDRegistrationCompletedEventArgs_get_ResponseCustomData(py::wrapper::Windows::Media::Protection::PlayReady::INDRegistrationCompletedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.INDRegistrationCompletedEventArgs", L"ResponseCustomData"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ResponseCustomData());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* INDRegistrationCompletedEventArgs_get_TransmitterCertificateAccepted(py::wrapper::Windows::Media::Protection::PlayReady::INDRegistrationCompletedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.INDRegistrationCompletedEventArgs", L"TransmitterCertificateAccepted"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.TransmitterCertificateAccepted());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int INDRegistrationCompletedEventArgs_put_TransmitterCertificateAccepted(py::wrapper::Windows::Media::Protection::PlayReady::INDRegistrationCompletedEventArgs* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.INDRegistrationCompletedEventArgs", L"TransmitterCertificateAccepted"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.TransmitterCertificateAccepted(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* INDRegistrationCompletedEventArgs_get_TransmitterProperties(py::wrapper::Windows::Media::Protection::PlayReady::INDRegistrationCompletedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.INDRegistrationCompletedEventArgs", L"TransmitterProperties"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.TransmitterProperties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_INDRegistrationCompletedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Protection::PlayReady::INDRegistrationCompletedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_INDRegistrationCompletedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Protection::PlayReady::INDRegistrationCompletedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_INDRegistrationCompletedEventArgs[] = {
        { "_assign_array_", _assign_array_INDRegistrationCompletedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_INDRegistrationCompletedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_INDRegistrationCompletedEventArgs[] = {
        { "response_custom_data", reinterpret_cast<getter>(INDRegistrationCompletedEventArgs_get_ResponseCustomData), nullptr, nullptr, nullptr },
        { "transmitter_certificate_accepted", reinterpret_cast<getter>(INDRegistrationCompletedEventArgs_get_TransmitterCertificateAccepted), reinterpret_cast<setter>(INDRegistrationCompletedEventArgs_put_TransmitterCertificateAccepted), nullptr, nullptr },
        { "transmitter_properties", reinterpret_cast<getter>(INDRegistrationCompletedEventArgs_get_TransmitterProperties), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_INDRegistrationCompletedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_INDRegistrationCompletedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_INDRegistrationCompletedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_INDRegistrationCompletedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_INDRegistrationCompletedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_INDRegistrationCompletedEventArgs =
    {
        "winrt._winrt_windows_media_protection_playready.INDRegistrationCompletedEventArgs",
        sizeof(py::wrapper::Windows::Media::Protection::PlayReady::INDRegistrationCompletedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_INDRegistrationCompletedEventArgs
    };

    // ----- INDSendResult interface --------------------

    static PyObject* _new_INDSendResult(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Protection::PlayReady::INDSendResult>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Protection::PlayReady::INDSendResult>::type_name);
        return nullptr;
    }

    static void _dealloc_INDSendResult(py::wrapper::Windows::Media::Protection::PlayReady::INDSendResult* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* INDSendResult_get_Response(py::wrapper::Windows::Media::Protection::PlayReady::INDSendResult* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.INDSendResult", L"Response"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Response());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_INDSendResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Protection::PlayReady::INDSendResult>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_INDSendResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Protection::PlayReady::INDSendResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_INDSendResult[] = {
        { "_assign_array_", _assign_array_INDSendResult, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_INDSendResult), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_INDSendResult[] = {
        { "response", reinterpret_cast<getter>(INDSendResult_get_Response), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_INDSendResult[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_INDSendResult) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_INDSendResult) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_INDSendResult) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_INDSendResult) },
        { },
    };

    static PyType_Spec type_spec_INDSendResult =
    {
        "winrt._winrt_windows_media_protection_playready.INDSendResult",
        sizeof(py::wrapper::Windows::Media::Protection::PlayReady::INDSendResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_INDSendResult
    };

    // ----- INDStartResult interface --------------------

    static PyObject* _new_INDStartResult(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Protection::PlayReady::INDStartResult>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Protection::PlayReady::INDStartResult>::type_name);
        return nullptr;
    }

    static void _dealloc_INDStartResult(py::wrapper::Windows::Media::Protection::PlayReady::INDStartResult* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* INDStartResult_get_MediaStreamSource(py::wrapper::Windows::Media::Protection::PlayReady::INDStartResult* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.INDStartResult", L"MediaStreamSource"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.MediaStreamSource());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_INDStartResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Protection::PlayReady::INDStartResult>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_INDStartResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Protection::PlayReady::INDStartResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_INDStartResult[] = {
        { "_assign_array_", _assign_array_INDStartResult, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_INDStartResult), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_INDStartResult[] = {
        { "media_stream_source", reinterpret_cast<getter>(INDStartResult_get_MediaStreamSource), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_INDStartResult[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_INDStartResult) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_INDStartResult) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_INDStartResult) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_INDStartResult) },
        { },
    };

    static PyType_Spec type_spec_INDStartResult =
    {
        "winrt._winrt_windows_media_protection_playready.INDStartResult",
        sizeof(py::wrapper::Windows::Media::Protection::PlayReady::INDStartResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_INDStartResult
    };

    // ----- INDStorageFileHelper interface --------------------

    static PyObject* _new_INDStorageFileHelper(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Protection::PlayReady::INDStorageFileHelper>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Protection::PlayReady::INDStorageFileHelper>::type_name);
        return nullptr;
    }

    static void _dealloc_INDStorageFileHelper(py::wrapper::Windows::Media::Protection::PlayReady::INDStorageFileHelper* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* INDStorageFileHelper_GetFileURLs(py::wrapper::Windows::Media::Protection::PlayReady::INDStorageFileHelper* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Protection.PlayReady.INDStorageFileHelper", L"GetFileURLs", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFile>(args, 0);

                return py::convert(self->obj.GetFileURLs(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_INDStorageFileHelper(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Protection::PlayReady::INDStorageFileHelper>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_INDStorageFileHelper(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Protection::PlayReady::INDStorageFileHelper>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_INDStorageFileHelper[] = {
        { "get_file_u_r_ls", reinterpret_cast<PyCFunction>(INDStorageFileHelper_GetFileURLs), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_INDStorageFileHelper, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_INDStorageFileHelper), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_INDStorageFileHelper[] = {
        { }
    };

    static PyType_Slot _type_slots_INDStorageFileHelper[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_INDStorageFileHelper) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_INDStorageFileHelper) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_INDStorageFileHelper) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_INDStorageFileHelper) },
        { },
    };

    static PyType_Spec type_spec_INDStorageFileHelper =
    {
        "winrt._winrt_windows_media_protection_playready.INDStorageFileHelper",
        sizeof(py::wrapper::Windows::Media::Protection::PlayReady::INDStorageFileHelper),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_INDStorageFileHelper
    };

    // ----- INDStreamParser interface --------------------

    static PyObject* _new_INDStreamParser(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Protection::PlayReady::INDStreamParser>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Protection::PlayReady::INDStreamParser>::type_name);
        return nullptr;
    }

    static void _dealloc_INDStreamParser(py::wrapper::Windows::Media::Protection::PlayReady::INDStreamParser* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* INDStreamParser_BeginOfStream(py::wrapper::Windows::Media::Protection::PlayReady::INDStreamParser* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Protection.PlayReady.INDStreamParser", L"BeginOfStream", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.BeginOfStream();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* INDStreamParser_EndOfStream(py::wrapper::Windows::Media::Protection::PlayReady::INDStreamParser* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Protection.PlayReady.INDStreamParser", L"EndOfStream", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.EndOfStream();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* INDStreamParser_GetStreamInformation(py::wrapper::Windows::Media::Protection::PlayReady::INDStreamParser* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Protection.PlayReady.INDStreamParser", L"GetStreamInformation", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Media::Core::IMediaStreamDescriptor>(args, 0);
                winrt::Windows::Media::Protection::PlayReady::NDMediaStreamType param1 {  };

                auto return_value = self->obj.GetStreamInformation(param0, param1);

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out1{ py::convert(param1) };
                if (!out1)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out_return_value.get(), out1.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* INDStreamParser_ParseData(py::wrapper::Windows::Media::Protection::PlayReady::INDStreamParser* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Protection.PlayReady.INDStreamParser", L"ParseData", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<py::pybuf_view<uint8_t, false>>(args, 0);

                self->obj.ParseData(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* INDStreamParser_get_Notifier(py::wrapper::Windows::Media::Protection::PlayReady::INDStreamParser* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.INDStreamParser", L"Notifier"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Notifier());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_INDStreamParser(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Protection::PlayReady::INDStreamParser>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_INDStreamParser(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Protection::PlayReady::INDStreamParser>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_INDStreamParser[] = {
        { "begin_of_stream", reinterpret_cast<PyCFunction>(INDStreamParser_BeginOfStream), METH_VARARGS, nullptr },
        { "end_of_stream", reinterpret_cast<PyCFunction>(INDStreamParser_EndOfStream), METH_VARARGS, nullptr },
        { "get_stream_information", reinterpret_cast<PyCFunction>(INDStreamParser_GetStreamInformation), METH_VARARGS, nullptr },
        { "parse_data", reinterpret_cast<PyCFunction>(INDStreamParser_ParseData), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_INDStreamParser, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_INDStreamParser), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_INDStreamParser[] = {
        { "notifier", reinterpret_cast<getter>(INDStreamParser_get_Notifier), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_INDStreamParser[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_INDStreamParser) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_INDStreamParser) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_INDStreamParser) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_INDStreamParser) },
        { },
    };

    static PyType_Spec type_spec_INDStreamParser =
    {
        "winrt._winrt_windows_media_protection_playready.INDStreamParser",
        sizeof(py::wrapper::Windows::Media::Protection::PlayReady::INDStreamParser),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_INDStreamParser
    };

    // ----- INDStreamParserNotifier interface --------------------

    static PyObject* _new_INDStreamParserNotifier(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Protection::PlayReady::INDStreamParserNotifier>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Protection::PlayReady::INDStreamParserNotifier>::type_name);
        return nullptr;
    }

    static void _dealloc_INDStreamParserNotifier(py::wrapper::Windows::Media::Protection::PlayReady::INDStreamParserNotifier* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* INDStreamParserNotifier_OnBeginSetupDecryptor(py::wrapper::Windows::Media::Protection::PlayReady::INDStreamParserNotifier* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Protection.PlayReady.INDStreamParserNotifier", L"OnBeginSetupDecryptor", 3))
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Media::Core::IMediaStreamDescriptor>(args, 0);
                auto param1 = py::convert_to<winrt::guid>(args, 1);
                auto param2 = py::convert_to<py::pybuf_view<uint8_t, false>>(args, 2);

                self->obj.OnBeginSetupDecryptor(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* INDStreamParserNotifier_OnContentIDReceived(py::wrapper::Windows::Media::Protection::PlayReady::INDStreamParserNotifier* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Protection.PlayReady.INDStreamParserNotifier", L"OnContentIDReceived", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Media::Protection::PlayReady::INDLicenseFetchDescriptor>(args, 0);

                self->obj.OnContentIDReceived(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* INDStreamParserNotifier_OnMediaStreamDescriptorCreated(py::wrapper::Windows::Media::Protection::PlayReady::INDStreamParserNotifier* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Protection.PlayReady.INDStreamParserNotifier", L"OnMediaStreamDescriptorCreated", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IVector<winrt::Windows::Media::Core::AudioStreamDescriptor>>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IVector<winrt::Windows::Media::Core::VideoStreamDescriptor>>(args, 1);

                self->obj.OnMediaStreamDescriptorCreated(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* INDStreamParserNotifier_OnSampleParsed(py::wrapper::Windows::Media::Protection::PlayReady::INDStreamParserNotifier* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 6)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Protection.PlayReady.INDStreamParserNotifier", L"OnSampleParsed", 6))
                {
                    py::set_arg_count_version_error(6);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Media::Protection::PlayReady::NDMediaStreamType>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Media::Core::MediaStreamSample>(args, 2);
                auto param3 = py::convert_to<int64_t>(args, 3);
                auto param4 = py::convert_to<winrt::Windows::Media::Protection::PlayReady::NDClosedCaptionFormat>(args, 4);
                auto param5 = py::convert_to<py::pybuf_view<uint8_t, false>>(args, 5);

                self->obj.OnSampleParsed(param0, param1, param2, param3, param4, param5);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_INDStreamParserNotifier(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Protection::PlayReady::INDStreamParserNotifier>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_INDStreamParserNotifier(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Protection::PlayReady::INDStreamParserNotifier>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_INDStreamParserNotifier[] = {
        { "on_begin_setup_decryptor", reinterpret_cast<PyCFunction>(INDStreamParserNotifier_OnBeginSetupDecryptor), METH_VARARGS, nullptr },
        { "on_content_i_d_received", reinterpret_cast<PyCFunction>(INDStreamParserNotifier_OnContentIDReceived), METH_VARARGS, nullptr },
        { "on_media_stream_descriptor_created", reinterpret_cast<PyCFunction>(INDStreamParserNotifier_OnMediaStreamDescriptorCreated), METH_VARARGS, nullptr },
        { "on_sample_parsed", reinterpret_cast<PyCFunction>(INDStreamParserNotifier_OnSampleParsed), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_INDStreamParserNotifier, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_INDStreamParserNotifier), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_INDStreamParserNotifier[] = {
        { }
    };

    static PyType_Slot _type_slots_INDStreamParserNotifier[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_INDStreamParserNotifier) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_INDStreamParserNotifier) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_INDStreamParserNotifier) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_INDStreamParserNotifier) },
        { },
    };

    static PyType_Spec type_spec_INDStreamParserNotifier =
    {
        "winrt._winrt_windows_media_protection_playready.INDStreamParserNotifier",
        sizeof(py::wrapper::Windows::Media::Protection::PlayReady::INDStreamParserNotifier),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_INDStreamParserNotifier
    };

    // ----- INDTransmitterProperties interface --------------------

    static PyObject* _new_INDTransmitterProperties(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Protection::PlayReady::INDTransmitterProperties>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Protection::PlayReady::INDTransmitterProperties>::type_name);
        return nullptr;
    }

    static void _dealloc_INDTransmitterProperties(py::wrapper::Windows::Media::Protection::PlayReady::INDTransmitterProperties* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* INDTransmitterProperties_get_CertificateType(py::wrapper::Windows::Media::Protection::PlayReady::INDTransmitterProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.INDTransmitterProperties", L"CertificateType"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CertificateType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* INDTransmitterProperties_get_ClientID(py::wrapper::Windows::Media::Protection::PlayReady::INDTransmitterProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.INDTransmitterProperties", L"ClientID"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ClientID());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* INDTransmitterProperties_get_ExpirationDate(py::wrapper::Windows::Media::Protection::PlayReady::INDTransmitterProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.INDTransmitterProperties", L"ExpirationDate"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ExpirationDate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* INDTransmitterProperties_get_ModelDigest(py::wrapper::Windows::Media::Protection::PlayReady::INDTransmitterProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.INDTransmitterProperties", L"ModelDigest"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ModelDigest());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* INDTransmitterProperties_get_ModelManufacturerName(py::wrapper::Windows::Media::Protection::PlayReady::INDTransmitterProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.INDTransmitterProperties", L"ModelManufacturerName"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ModelManufacturerName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* INDTransmitterProperties_get_ModelName(py::wrapper::Windows::Media::Protection::PlayReady::INDTransmitterProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.INDTransmitterProperties", L"ModelName"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ModelName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* INDTransmitterProperties_get_ModelNumber(py::wrapper::Windows::Media::Protection::PlayReady::INDTransmitterProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.INDTransmitterProperties", L"ModelNumber"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ModelNumber());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* INDTransmitterProperties_get_PlatformIdentifier(py::wrapper::Windows::Media::Protection::PlayReady::INDTransmitterProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.INDTransmitterProperties", L"PlatformIdentifier"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.PlatformIdentifier());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* INDTransmitterProperties_get_SecurityLevel(py::wrapper::Windows::Media::Protection::PlayReady::INDTransmitterProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.INDTransmitterProperties", L"SecurityLevel"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SecurityLevel());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* INDTransmitterProperties_get_SecurityVersion(py::wrapper::Windows::Media::Protection::PlayReady::INDTransmitterProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.INDTransmitterProperties", L"SecurityVersion"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SecurityVersion());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* INDTransmitterProperties_get_SupportedFeatures(py::wrapper::Windows::Media::Protection::PlayReady::INDTransmitterProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.INDTransmitterProperties", L"SupportedFeatures"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SupportedFeatures());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_INDTransmitterProperties(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Protection::PlayReady::INDTransmitterProperties>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_INDTransmitterProperties(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Protection::PlayReady::INDTransmitterProperties>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_INDTransmitterProperties[] = {
        { "_assign_array_", _assign_array_INDTransmitterProperties, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_INDTransmitterProperties), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_INDTransmitterProperties[] = {
        { "certificate_type", reinterpret_cast<getter>(INDTransmitterProperties_get_CertificateType), nullptr, nullptr, nullptr },
        { "client_i_d", reinterpret_cast<getter>(INDTransmitterProperties_get_ClientID), nullptr, nullptr, nullptr },
        { "expiration_date", reinterpret_cast<getter>(INDTransmitterProperties_get_ExpirationDate), nullptr, nullptr, nullptr },
        { "model_digest", reinterpret_cast<getter>(INDTransmitterProperties_get_ModelDigest), nullptr, nullptr, nullptr },
        { "model_manufacturer_name", reinterpret_cast<getter>(INDTransmitterProperties_get_ModelManufacturerName), nullptr, nullptr, nullptr },
        { "model_name", reinterpret_cast<getter>(INDTransmitterProperties_get_ModelName), nullptr, nullptr, nullptr },
        { "model_number", reinterpret_cast<getter>(INDTransmitterProperties_get_ModelNumber), nullptr, nullptr, nullptr },
        { "platform_identifier", reinterpret_cast<getter>(INDTransmitterProperties_get_PlatformIdentifier), nullptr, nullptr, nullptr },
        { "security_level", reinterpret_cast<getter>(INDTransmitterProperties_get_SecurityLevel), nullptr, nullptr, nullptr },
        { "security_version", reinterpret_cast<getter>(INDTransmitterProperties_get_SecurityVersion), nullptr, nullptr, nullptr },
        { "supported_features", reinterpret_cast<getter>(INDTransmitterProperties_get_SupportedFeatures), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_INDTransmitterProperties[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_INDTransmitterProperties) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_INDTransmitterProperties) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_INDTransmitterProperties) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_INDTransmitterProperties) },
        { },
    };

    static PyType_Spec type_spec_INDTransmitterProperties =
    {
        "winrt._winrt_windows_media_protection_playready.INDTransmitterProperties",
        sizeof(py::wrapper::Windows::Media::Protection::PlayReady::INDTransmitterProperties),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_INDTransmitterProperties
    };

    // ----- IPlayReadyDomain interface --------------------

    static PyObject* _new_IPlayReadyDomain(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Protection::PlayReady::IPlayReadyDomain>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Protection::PlayReady::IPlayReadyDomain>::type_name);
        return nullptr;
    }

    static void _dealloc_IPlayReadyDomain(py::wrapper::Windows::Media::Protection::PlayReady::IPlayReadyDomain* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IPlayReadyDomain_get_AccountId(py::wrapper::Windows::Media::Protection::PlayReady::IPlayReadyDomain* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.IPlayReadyDomain", L"AccountId"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.AccountId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IPlayReadyDomain_get_DomainJoinUrl(py::wrapper::Windows::Media::Protection::PlayReady::IPlayReadyDomain* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.IPlayReadyDomain", L"DomainJoinUrl"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DomainJoinUrl());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IPlayReadyDomain_get_FriendlyName(py::wrapper::Windows::Media::Protection::PlayReady::IPlayReadyDomain* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.IPlayReadyDomain", L"FriendlyName"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.FriendlyName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IPlayReadyDomain_get_Revision(py::wrapper::Windows::Media::Protection::PlayReady::IPlayReadyDomain* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.IPlayReadyDomain", L"Revision"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Revision());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IPlayReadyDomain_get_ServiceId(py::wrapper::Windows::Media::Protection::PlayReady::IPlayReadyDomain* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.IPlayReadyDomain", L"ServiceId"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ServiceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_IPlayReadyDomain(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Protection::PlayReady::IPlayReadyDomain>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IPlayReadyDomain(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Protection::PlayReady::IPlayReadyDomain>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IPlayReadyDomain[] = {
        { "_assign_array_", _assign_array_IPlayReadyDomain, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IPlayReadyDomain), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IPlayReadyDomain[] = {
        { "account_id", reinterpret_cast<getter>(IPlayReadyDomain_get_AccountId), nullptr, nullptr, nullptr },
        { "domain_join_url", reinterpret_cast<getter>(IPlayReadyDomain_get_DomainJoinUrl), nullptr, nullptr, nullptr },
        { "friendly_name", reinterpret_cast<getter>(IPlayReadyDomain_get_FriendlyName), nullptr, nullptr, nullptr },
        { "revision", reinterpret_cast<getter>(IPlayReadyDomain_get_Revision), nullptr, nullptr, nullptr },
        { "service_id", reinterpret_cast<getter>(IPlayReadyDomain_get_ServiceId), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IPlayReadyDomain[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_IPlayReadyDomain) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IPlayReadyDomain) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IPlayReadyDomain) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IPlayReadyDomain) },
        { },
    };

    static PyType_Spec type_spec_IPlayReadyDomain =
    {
        "winrt._winrt_windows_media_protection_playready.IPlayReadyDomain",
        sizeof(py::wrapper::Windows::Media::Protection::PlayReady::IPlayReadyDomain),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IPlayReadyDomain
    };

    // ----- IPlayReadyLicense interface --------------------

    static PyObject* _new_IPlayReadyLicense(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Protection::PlayReady::IPlayReadyLicense>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Protection::PlayReady::IPlayReadyLicense>::type_name);
        return nullptr;
    }

    static void _dealloc_IPlayReadyLicense(py::wrapper::Windows::Media::Protection::PlayReady::IPlayReadyLicense* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IPlayReadyLicense_GetKIDAtChainDepth(py::wrapper::Windows::Media::Protection::PlayReady::IPlayReadyLicense* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Protection.PlayReady.IPlayReadyLicense", L"GetKIDAtChainDepth", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint32_t>(args, 0);

                return py::convert(self->obj.GetKIDAtChainDepth(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IPlayReadyLicense_get_ChainDepth(py::wrapper::Windows::Media::Protection::PlayReady::IPlayReadyLicense* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.IPlayReadyLicense", L"ChainDepth"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ChainDepth());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IPlayReadyLicense_get_DomainAccountID(py::wrapper::Windows::Media::Protection::PlayReady::IPlayReadyLicense* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.IPlayReadyLicense", L"DomainAccountID"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DomainAccountID());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IPlayReadyLicense_get_ExpirationDate(py::wrapper::Windows::Media::Protection::PlayReady::IPlayReadyLicense* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.IPlayReadyLicense", L"ExpirationDate"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ExpirationDate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IPlayReadyLicense_get_ExpireAfterFirstPlay(py::wrapper::Windows::Media::Protection::PlayReady::IPlayReadyLicense* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.IPlayReadyLicense", L"ExpireAfterFirstPlay"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ExpireAfterFirstPlay());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IPlayReadyLicense_get_FullyEvaluated(py::wrapper::Windows::Media::Protection::PlayReady::IPlayReadyLicense* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.IPlayReadyLicense", L"FullyEvaluated"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.FullyEvaluated());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IPlayReadyLicense_get_UsableForPlay(py::wrapper::Windows::Media::Protection::PlayReady::IPlayReadyLicense* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.IPlayReadyLicense", L"UsableForPlay"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.UsableForPlay());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_IPlayReadyLicense(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Protection::PlayReady::IPlayReadyLicense>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IPlayReadyLicense(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Protection::PlayReady::IPlayReadyLicense>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IPlayReadyLicense[] = {
        { "get_k_i_d_at_chain_depth", reinterpret_cast<PyCFunction>(IPlayReadyLicense_GetKIDAtChainDepth), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_IPlayReadyLicense, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IPlayReadyLicense), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IPlayReadyLicense[] = {
        { "chain_depth", reinterpret_cast<getter>(IPlayReadyLicense_get_ChainDepth), nullptr, nullptr, nullptr },
        { "domain_account_i_d", reinterpret_cast<getter>(IPlayReadyLicense_get_DomainAccountID), nullptr, nullptr, nullptr },
        { "expiration_date", reinterpret_cast<getter>(IPlayReadyLicense_get_ExpirationDate), nullptr, nullptr, nullptr },
        { "expire_after_first_play", reinterpret_cast<getter>(IPlayReadyLicense_get_ExpireAfterFirstPlay), nullptr, nullptr, nullptr },
        { "fully_evaluated", reinterpret_cast<getter>(IPlayReadyLicense_get_FullyEvaluated), nullptr, nullptr, nullptr },
        { "usable_for_play", reinterpret_cast<getter>(IPlayReadyLicense_get_UsableForPlay), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IPlayReadyLicense[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_IPlayReadyLicense) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IPlayReadyLicense) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IPlayReadyLicense) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IPlayReadyLicense) },
        { },
    };

    static PyType_Spec type_spec_IPlayReadyLicense =
    {
        "winrt._winrt_windows_media_protection_playready.IPlayReadyLicense",
        sizeof(py::wrapper::Windows::Media::Protection::PlayReady::IPlayReadyLicense),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IPlayReadyLicense
    };

    // ----- IPlayReadyLicenseAcquisitionServiceRequest interface --------------------

    static PyObject* _new_IPlayReadyLicenseAcquisitionServiceRequest(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Protection::PlayReady::IPlayReadyLicenseAcquisitionServiceRequest>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Protection::PlayReady::IPlayReadyLicenseAcquisitionServiceRequest>::type_name);
        return nullptr;
    }

    static void _dealloc_IPlayReadyLicenseAcquisitionServiceRequest(py::wrapper::Windows::Media::Protection::PlayReady::IPlayReadyLicenseAcquisitionServiceRequest* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IPlayReadyLicenseAcquisitionServiceRequest_BeginServiceRequest(py::wrapper::Windows::Media::Protection::PlayReady::IPlayReadyLicenseAcquisitionServiceRequest* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Protection.PlayReady.IPlayReadyServiceRequest", L"BeginServiceRequest", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.BeginServiceRequest());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IPlayReadyLicenseAcquisitionServiceRequest_GenerateManualEnablingChallenge(py::wrapper::Windows::Media::Protection::PlayReady::IPlayReadyLicenseAcquisitionServiceRequest* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Protection.PlayReady.IPlayReadyServiceRequest", L"GenerateManualEnablingChallenge", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GenerateManualEnablingChallenge());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IPlayReadyLicenseAcquisitionServiceRequest_NextServiceRequest(py::wrapper::Windows::Media::Protection::PlayReady::IPlayReadyLicenseAcquisitionServiceRequest* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Protection.PlayReady.IPlayReadyServiceRequest", L"NextServiceRequest", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.NextServiceRequest());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IPlayReadyLicenseAcquisitionServiceRequest_ProcessManualEnablingResponse(py::wrapper::Windows::Media::Protection::PlayReady::IPlayReadyLicenseAcquisitionServiceRequest* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Protection.PlayReady.IPlayReadyServiceRequest", L"ProcessManualEnablingResponse", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<py::pybuf_view<uint8_t, false>>(args, 0);

                return py::convert(self->obj.ProcessManualEnablingResponse(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IPlayReadyLicenseAcquisitionServiceRequest_get_ContentHeader(py::wrapper::Windows::Media::Protection::PlayReady::IPlayReadyLicenseAcquisitionServiceRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.IPlayReadyLicenseAcquisitionServiceRequest", L"ContentHeader"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ContentHeader());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IPlayReadyLicenseAcquisitionServiceRequest_put_ContentHeader(py::wrapper::Windows::Media::Protection::PlayReady::IPlayReadyLicenseAcquisitionServiceRequest* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.IPlayReadyLicenseAcquisitionServiceRequest", L"ContentHeader"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Media::Protection::PlayReady::PlayReadyContentHeader>(arg);

            self->obj.ContentHeader(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* IPlayReadyLicenseAcquisitionServiceRequest_get_DomainServiceId(py::wrapper::Windows::Media::Protection::PlayReady::IPlayReadyLicenseAcquisitionServiceRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.IPlayReadyLicenseAcquisitionServiceRequest", L"DomainServiceId"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DomainServiceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IPlayReadyLicenseAcquisitionServiceRequest_put_DomainServiceId(py::wrapper::Windows::Media::Protection::PlayReady::IPlayReadyLicenseAcquisitionServiceRequest* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.IPlayReadyLicenseAcquisitionServiceRequest", L"DomainServiceId"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::guid>(arg);

            self->obj.DomainServiceId(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* IPlayReadyLicenseAcquisitionServiceRequest_get_ChallengeCustomData(py::wrapper::Windows::Media::Protection::PlayReady::IPlayReadyLicenseAcquisitionServiceRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.IPlayReadyServiceRequest", L"ChallengeCustomData"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ChallengeCustomData());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IPlayReadyLicenseAcquisitionServiceRequest_put_ChallengeCustomData(py::wrapper::Windows::Media::Protection::PlayReady::IPlayReadyLicenseAcquisitionServiceRequest* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.IPlayReadyServiceRequest", L"ChallengeCustomData"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.ChallengeCustomData(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* IPlayReadyLicenseAcquisitionServiceRequest_get_ResponseCustomData(py::wrapper::Windows::Media::Protection::PlayReady::IPlayReadyLicenseAcquisitionServiceRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.IPlayReadyServiceRequest", L"ResponseCustomData"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ResponseCustomData());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IPlayReadyLicenseAcquisitionServiceRequest_get_Uri(py::wrapper::Windows::Media::Protection::PlayReady::IPlayReadyLicenseAcquisitionServiceRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.IPlayReadyServiceRequest", L"Uri"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Uri());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IPlayReadyLicenseAcquisitionServiceRequest_put_Uri(py::wrapper::Windows::Media::Protection::PlayReady::IPlayReadyLicenseAcquisitionServiceRequest* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.IPlayReadyServiceRequest", L"Uri"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(arg);

            self->obj.Uri(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* IPlayReadyLicenseAcquisitionServiceRequest_get_ProtectionSystem(py::wrapper::Windows::Media::Protection::PlayReady::IPlayReadyLicenseAcquisitionServiceRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.IMediaProtectionServiceRequest", L"ProtectionSystem"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ProtectionSystem());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IPlayReadyLicenseAcquisitionServiceRequest_get_Type(py::wrapper::Windows::Media::Protection::PlayReady::IPlayReadyLicenseAcquisitionServiceRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.IMediaProtectionServiceRequest", L"Type"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Type());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_IPlayReadyLicenseAcquisitionServiceRequest(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Protection::PlayReady::IPlayReadyLicenseAcquisitionServiceRequest>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IPlayReadyLicenseAcquisitionServiceRequest(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Protection::PlayReady::IPlayReadyLicenseAcquisitionServiceRequest>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IPlayReadyLicenseAcquisitionServiceRequest[] = {
        { "begin_service_request", reinterpret_cast<PyCFunction>(IPlayReadyLicenseAcquisitionServiceRequest_BeginServiceRequest), METH_VARARGS, nullptr },
        { "generate_manual_enabling_challenge", reinterpret_cast<PyCFunction>(IPlayReadyLicenseAcquisitionServiceRequest_GenerateManualEnablingChallenge), METH_VARARGS, nullptr },
        { "next_service_request", reinterpret_cast<PyCFunction>(IPlayReadyLicenseAcquisitionServiceRequest_NextServiceRequest), METH_VARARGS, nullptr },
        { "process_manual_enabling_response", reinterpret_cast<PyCFunction>(IPlayReadyLicenseAcquisitionServiceRequest_ProcessManualEnablingResponse), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_IPlayReadyLicenseAcquisitionServiceRequest, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IPlayReadyLicenseAcquisitionServiceRequest), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IPlayReadyLicenseAcquisitionServiceRequest[] = {
        { "content_header", reinterpret_cast<getter>(IPlayReadyLicenseAcquisitionServiceRequest_get_ContentHeader), reinterpret_cast<setter>(IPlayReadyLicenseAcquisitionServiceRequest_put_ContentHeader), nullptr, nullptr },
        { "domain_service_id", reinterpret_cast<getter>(IPlayReadyLicenseAcquisitionServiceRequest_get_DomainServiceId), reinterpret_cast<setter>(IPlayReadyLicenseAcquisitionServiceRequest_put_DomainServiceId), nullptr, nullptr },
        { "challenge_custom_data", reinterpret_cast<getter>(IPlayReadyLicenseAcquisitionServiceRequest_get_ChallengeCustomData), reinterpret_cast<setter>(IPlayReadyLicenseAcquisitionServiceRequest_put_ChallengeCustomData), nullptr, nullptr },
        { "response_custom_data", reinterpret_cast<getter>(IPlayReadyLicenseAcquisitionServiceRequest_get_ResponseCustomData), nullptr, nullptr, nullptr },
        { "uri", reinterpret_cast<getter>(IPlayReadyLicenseAcquisitionServiceRequest_get_Uri), reinterpret_cast<setter>(IPlayReadyLicenseAcquisitionServiceRequest_put_Uri), nullptr, nullptr },
        { "protection_system", reinterpret_cast<getter>(IPlayReadyLicenseAcquisitionServiceRequest_get_ProtectionSystem), nullptr, nullptr, nullptr },
        { "type", reinterpret_cast<getter>(IPlayReadyLicenseAcquisitionServiceRequest_get_Type), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IPlayReadyLicenseAcquisitionServiceRequest[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_IPlayReadyLicenseAcquisitionServiceRequest) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IPlayReadyLicenseAcquisitionServiceRequest) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IPlayReadyLicenseAcquisitionServiceRequest) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IPlayReadyLicenseAcquisitionServiceRequest) },
        { },
    };

    static PyType_Spec type_spec_IPlayReadyLicenseAcquisitionServiceRequest =
    {
        "winrt._winrt_windows_media_protection_playready.IPlayReadyLicenseAcquisitionServiceRequest",
        sizeof(py::wrapper::Windows::Media::Protection::PlayReady::IPlayReadyLicenseAcquisitionServiceRequest),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IPlayReadyLicenseAcquisitionServiceRequest
    };

    // ----- IPlayReadyLicenseSession interface --------------------

    static PyObject* _new_IPlayReadyLicenseSession(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Protection::PlayReady::IPlayReadyLicenseSession>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Protection::PlayReady::IPlayReadyLicenseSession>::type_name);
        return nullptr;
    }

    static void _dealloc_IPlayReadyLicenseSession(py::wrapper::Windows::Media::Protection::PlayReady::IPlayReadyLicenseSession* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IPlayReadyLicenseSession_ConfigureMediaProtectionManager(py::wrapper::Windows::Media::Protection::PlayReady::IPlayReadyLicenseSession* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Protection.PlayReady.IPlayReadyLicenseSession", L"ConfigureMediaProtectionManager", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Media::Protection::MediaProtectionManager>(args, 0);

                self->obj.ConfigureMediaProtectionManager(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IPlayReadyLicenseSession_CreateLAServiceRequest(py::wrapper::Windows::Media::Protection::PlayReady::IPlayReadyLicenseSession* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Protection.PlayReady.IPlayReadyLicenseSession", L"CreateLAServiceRequest", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.CreateLAServiceRequest());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_IPlayReadyLicenseSession(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Protection::PlayReady::IPlayReadyLicenseSession>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IPlayReadyLicenseSession(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Protection::PlayReady::IPlayReadyLicenseSession>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IPlayReadyLicenseSession[] = {
        { "configure_media_protection_manager", reinterpret_cast<PyCFunction>(IPlayReadyLicenseSession_ConfigureMediaProtectionManager), METH_VARARGS, nullptr },
        { "create_l_a_service_request", reinterpret_cast<PyCFunction>(IPlayReadyLicenseSession_CreateLAServiceRequest), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_IPlayReadyLicenseSession, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IPlayReadyLicenseSession), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IPlayReadyLicenseSession[] = {
        { }
    };

    static PyType_Slot _type_slots_IPlayReadyLicenseSession[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_IPlayReadyLicenseSession) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IPlayReadyLicenseSession) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IPlayReadyLicenseSession) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IPlayReadyLicenseSession) },
        { },
    };

    static PyType_Spec type_spec_IPlayReadyLicenseSession =
    {
        "winrt._winrt_windows_media_protection_playready.IPlayReadyLicenseSession",
        sizeof(py::wrapper::Windows::Media::Protection::PlayReady::IPlayReadyLicenseSession),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IPlayReadyLicenseSession
    };

    // ----- IPlayReadyLicenseSession2 interface --------------------

    static PyObject* _new_IPlayReadyLicenseSession2(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Protection::PlayReady::IPlayReadyLicenseSession2>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Protection::PlayReady::IPlayReadyLicenseSession2>::type_name);
        return nullptr;
    }

    static void _dealloc_IPlayReadyLicenseSession2(py::wrapper::Windows::Media::Protection::PlayReady::IPlayReadyLicenseSession2* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IPlayReadyLicenseSession2_ConfigureMediaProtectionManager(py::wrapper::Windows::Media::Protection::PlayReady::IPlayReadyLicenseSession2* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Protection.PlayReady.IPlayReadyLicenseSession", L"ConfigureMediaProtectionManager", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Media::Protection::MediaProtectionManager>(args, 0);

                self->obj.ConfigureMediaProtectionManager(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IPlayReadyLicenseSession2_CreateLAServiceRequest(py::wrapper::Windows::Media::Protection::PlayReady::IPlayReadyLicenseSession2* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Protection.PlayReady.IPlayReadyLicenseSession", L"CreateLAServiceRequest", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.CreateLAServiceRequest());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IPlayReadyLicenseSession2_CreateLicenseIterable(py::wrapper::Windows::Media::Protection::PlayReady::IPlayReadyLicenseSession2* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Protection.PlayReady.IPlayReadyLicenseSession2", L"CreateLicenseIterable", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Media::Protection::PlayReady::PlayReadyContentHeader>(args, 0);
                auto param1 = py::convert_to<bool>(args, 1);

                return py::convert(self->obj.CreateLicenseIterable(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_IPlayReadyLicenseSession2(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Protection::PlayReady::IPlayReadyLicenseSession2>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IPlayReadyLicenseSession2(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Protection::PlayReady::IPlayReadyLicenseSession2>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IPlayReadyLicenseSession2[] = {
        { "configure_media_protection_manager", reinterpret_cast<PyCFunction>(IPlayReadyLicenseSession2_ConfigureMediaProtectionManager), METH_VARARGS, nullptr },
        { "create_l_a_service_request", reinterpret_cast<PyCFunction>(IPlayReadyLicenseSession2_CreateLAServiceRequest), METH_VARARGS, nullptr },
        { "create_license_iterable", reinterpret_cast<PyCFunction>(IPlayReadyLicenseSession2_CreateLicenseIterable), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_IPlayReadyLicenseSession2, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IPlayReadyLicenseSession2), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IPlayReadyLicenseSession2[] = {
        { }
    };

    static PyType_Slot _type_slots_IPlayReadyLicenseSession2[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_IPlayReadyLicenseSession2) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IPlayReadyLicenseSession2) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IPlayReadyLicenseSession2) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IPlayReadyLicenseSession2) },
        { },
    };

    static PyType_Spec type_spec_IPlayReadyLicenseSession2 =
    {
        "winrt._winrt_windows_media_protection_playready.IPlayReadyLicenseSession2",
        sizeof(py::wrapper::Windows::Media::Protection::PlayReady::IPlayReadyLicenseSession2),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IPlayReadyLicenseSession2
    };

    // ----- IPlayReadySecureStopServiceRequest interface --------------------

    static PyObject* _new_IPlayReadySecureStopServiceRequest(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Protection::PlayReady::IPlayReadySecureStopServiceRequest>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Protection::PlayReady::IPlayReadySecureStopServiceRequest>::type_name);
        return nullptr;
    }

    static void _dealloc_IPlayReadySecureStopServiceRequest(py::wrapper::Windows::Media::Protection::PlayReady::IPlayReadySecureStopServiceRequest* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IPlayReadySecureStopServiceRequest_BeginServiceRequest(py::wrapper::Windows::Media::Protection::PlayReady::IPlayReadySecureStopServiceRequest* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Protection.PlayReady.IPlayReadyServiceRequest", L"BeginServiceRequest", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.BeginServiceRequest());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IPlayReadySecureStopServiceRequest_GenerateManualEnablingChallenge(py::wrapper::Windows::Media::Protection::PlayReady::IPlayReadySecureStopServiceRequest* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Protection.PlayReady.IPlayReadyServiceRequest", L"GenerateManualEnablingChallenge", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GenerateManualEnablingChallenge());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IPlayReadySecureStopServiceRequest_NextServiceRequest(py::wrapper::Windows::Media::Protection::PlayReady::IPlayReadySecureStopServiceRequest* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Protection.PlayReady.IPlayReadyServiceRequest", L"NextServiceRequest", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.NextServiceRequest());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IPlayReadySecureStopServiceRequest_ProcessManualEnablingResponse(py::wrapper::Windows::Media::Protection::PlayReady::IPlayReadySecureStopServiceRequest* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Protection.PlayReady.IPlayReadyServiceRequest", L"ProcessManualEnablingResponse", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<py::pybuf_view<uint8_t, false>>(args, 0);

                return py::convert(self->obj.ProcessManualEnablingResponse(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IPlayReadySecureStopServiceRequest_get_PublisherCertificate(py::wrapper::Windows::Media::Protection::PlayReady::IPlayReadySecureStopServiceRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.IPlayReadySecureStopServiceRequest", L"PublisherCertificate"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.PublisherCertificate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IPlayReadySecureStopServiceRequest_get_SessionID(py::wrapper::Windows::Media::Protection::PlayReady::IPlayReadySecureStopServiceRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.IPlayReadySecureStopServiceRequest", L"SessionID"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SessionID());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IPlayReadySecureStopServiceRequest_get_StartTime(py::wrapper::Windows::Media::Protection::PlayReady::IPlayReadySecureStopServiceRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.IPlayReadySecureStopServiceRequest", L"StartTime"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.StartTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IPlayReadySecureStopServiceRequest_get_Stopped(py::wrapper::Windows::Media::Protection::PlayReady::IPlayReadySecureStopServiceRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.IPlayReadySecureStopServiceRequest", L"Stopped"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Stopped());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IPlayReadySecureStopServiceRequest_get_UpdateTime(py::wrapper::Windows::Media::Protection::PlayReady::IPlayReadySecureStopServiceRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.IPlayReadySecureStopServiceRequest", L"UpdateTime"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.UpdateTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IPlayReadySecureStopServiceRequest_get_ChallengeCustomData(py::wrapper::Windows::Media::Protection::PlayReady::IPlayReadySecureStopServiceRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.IPlayReadyServiceRequest", L"ChallengeCustomData"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ChallengeCustomData());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IPlayReadySecureStopServiceRequest_put_ChallengeCustomData(py::wrapper::Windows::Media::Protection::PlayReady::IPlayReadySecureStopServiceRequest* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.IPlayReadyServiceRequest", L"ChallengeCustomData"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.ChallengeCustomData(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* IPlayReadySecureStopServiceRequest_get_ResponseCustomData(py::wrapper::Windows::Media::Protection::PlayReady::IPlayReadySecureStopServiceRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.IPlayReadyServiceRequest", L"ResponseCustomData"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ResponseCustomData());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IPlayReadySecureStopServiceRequest_get_Uri(py::wrapper::Windows::Media::Protection::PlayReady::IPlayReadySecureStopServiceRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.IPlayReadyServiceRequest", L"Uri"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Uri());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IPlayReadySecureStopServiceRequest_put_Uri(py::wrapper::Windows::Media::Protection::PlayReady::IPlayReadySecureStopServiceRequest* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.IPlayReadyServiceRequest", L"Uri"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(arg);

            self->obj.Uri(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* IPlayReadySecureStopServiceRequest_get_ProtectionSystem(py::wrapper::Windows::Media::Protection::PlayReady::IPlayReadySecureStopServiceRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.IMediaProtectionServiceRequest", L"ProtectionSystem"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ProtectionSystem());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IPlayReadySecureStopServiceRequest_get_Type(py::wrapper::Windows::Media::Protection::PlayReady::IPlayReadySecureStopServiceRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.IMediaProtectionServiceRequest", L"Type"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Type());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_IPlayReadySecureStopServiceRequest(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Protection::PlayReady::IPlayReadySecureStopServiceRequest>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IPlayReadySecureStopServiceRequest(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Protection::PlayReady::IPlayReadySecureStopServiceRequest>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IPlayReadySecureStopServiceRequest[] = {
        { "begin_service_request", reinterpret_cast<PyCFunction>(IPlayReadySecureStopServiceRequest_BeginServiceRequest), METH_VARARGS, nullptr },
        { "generate_manual_enabling_challenge", reinterpret_cast<PyCFunction>(IPlayReadySecureStopServiceRequest_GenerateManualEnablingChallenge), METH_VARARGS, nullptr },
        { "next_service_request", reinterpret_cast<PyCFunction>(IPlayReadySecureStopServiceRequest_NextServiceRequest), METH_VARARGS, nullptr },
        { "process_manual_enabling_response", reinterpret_cast<PyCFunction>(IPlayReadySecureStopServiceRequest_ProcessManualEnablingResponse), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_IPlayReadySecureStopServiceRequest, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IPlayReadySecureStopServiceRequest), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IPlayReadySecureStopServiceRequest[] = {
        { "publisher_certificate", reinterpret_cast<getter>(IPlayReadySecureStopServiceRequest_get_PublisherCertificate), nullptr, nullptr, nullptr },
        { "session_i_d", reinterpret_cast<getter>(IPlayReadySecureStopServiceRequest_get_SessionID), nullptr, nullptr, nullptr },
        { "start_time", reinterpret_cast<getter>(IPlayReadySecureStopServiceRequest_get_StartTime), nullptr, nullptr, nullptr },
        { "stopped", reinterpret_cast<getter>(IPlayReadySecureStopServiceRequest_get_Stopped), nullptr, nullptr, nullptr },
        { "update_time", reinterpret_cast<getter>(IPlayReadySecureStopServiceRequest_get_UpdateTime), nullptr, nullptr, nullptr },
        { "challenge_custom_data", reinterpret_cast<getter>(IPlayReadySecureStopServiceRequest_get_ChallengeCustomData), reinterpret_cast<setter>(IPlayReadySecureStopServiceRequest_put_ChallengeCustomData), nullptr, nullptr },
        { "response_custom_data", reinterpret_cast<getter>(IPlayReadySecureStopServiceRequest_get_ResponseCustomData), nullptr, nullptr, nullptr },
        { "uri", reinterpret_cast<getter>(IPlayReadySecureStopServiceRequest_get_Uri), reinterpret_cast<setter>(IPlayReadySecureStopServiceRequest_put_Uri), nullptr, nullptr },
        { "protection_system", reinterpret_cast<getter>(IPlayReadySecureStopServiceRequest_get_ProtectionSystem), nullptr, nullptr, nullptr },
        { "type", reinterpret_cast<getter>(IPlayReadySecureStopServiceRequest_get_Type), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IPlayReadySecureStopServiceRequest[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_IPlayReadySecureStopServiceRequest) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IPlayReadySecureStopServiceRequest) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IPlayReadySecureStopServiceRequest) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IPlayReadySecureStopServiceRequest) },
        { },
    };

    static PyType_Spec type_spec_IPlayReadySecureStopServiceRequest =
    {
        "winrt._winrt_windows_media_protection_playready.IPlayReadySecureStopServiceRequest",
        sizeof(py::wrapper::Windows::Media::Protection::PlayReady::IPlayReadySecureStopServiceRequest),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IPlayReadySecureStopServiceRequest
    };

    // ----- IPlayReadyServiceRequest interface --------------------

    static PyObject* _new_IPlayReadyServiceRequest(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Protection::PlayReady::IPlayReadyServiceRequest>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Protection::PlayReady::IPlayReadyServiceRequest>::type_name);
        return nullptr;
    }

    static void _dealloc_IPlayReadyServiceRequest(py::wrapper::Windows::Media::Protection::PlayReady::IPlayReadyServiceRequest* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IPlayReadyServiceRequest_BeginServiceRequest(py::wrapper::Windows::Media::Protection::PlayReady::IPlayReadyServiceRequest* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Protection.PlayReady.IPlayReadyServiceRequest", L"BeginServiceRequest", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.BeginServiceRequest());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IPlayReadyServiceRequest_GenerateManualEnablingChallenge(py::wrapper::Windows::Media::Protection::PlayReady::IPlayReadyServiceRequest* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Protection.PlayReady.IPlayReadyServiceRequest", L"GenerateManualEnablingChallenge", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GenerateManualEnablingChallenge());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IPlayReadyServiceRequest_NextServiceRequest(py::wrapper::Windows::Media::Protection::PlayReady::IPlayReadyServiceRequest* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Protection.PlayReady.IPlayReadyServiceRequest", L"NextServiceRequest", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.NextServiceRequest());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IPlayReadyServiceRequest_ProcessManualEnablingResponse(py::wrapper::Windows::Media::Protection::PlayReady::IPlayReadyServiceRequest* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Protection.PlayReady.IPlayReadyServiceRequest", L"ProcessManualEnablingResponse", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<py::pybuf_view<uint8_t, false>>(args, 0);

                return py::convert(self->obj.ProcessManualEnablingResponse(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IPlayReadyServiceRequest_get_ChallengeCustomData(py::wrapper::Windows::Media::Protection::PlayReady::IPlayReadyServiceRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.IPlayReadyServiceRequest", L"ChallengeCustomData"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ChallengeCustomData());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IPlayReadyServiceRequest_put_ChallengeCustomData(py::wrapper::Windows::Media::Protection::PlayReady::IPlayReadyServiceRequest* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.IPlayReadyServiceRequest", L"ChallengeCustomData"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.ChallengeCustomData(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* IPlayReadyServiceRequest_get_ResponseCustomData(py::wrapper::Windows::Media::Protection::PlayReady::IPlayReadyServiceRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.IPlayReadyServiceRequest", L"ResponseCustomData"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ResponseCustomData());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IPlayReadyServiceRequest_get_Uri(py::wrapper::Windows::Media::Protection::PlayReady::IPlayReadyServiceRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.IPlayReadyServiceRequest", L"Uri"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Uri());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IPlayReadyServiceRequest_put_Uri(py::wrapper::Windows::Media::Protection::PlayReady::IPlayReadyServiceRequest* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.IPlayReadyServiceRequest", L"Uri"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(arg);

            self->obj.Uri(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* IPlayReadyServiceRequest_get_ProtectionSystem(py::wrapper::Windows::Media::Protection::PlayReady::IPlayReadyServiceRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.IMediaProtectionServiceRequest", L"ProtectionSystem"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ProtectionSystem());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IPlayReadyServiceRequest_get_Type(py::wrapper::Windows::Media::Protection::PlayReady::IPlayReadyServiceRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.IMediaProtectionServiceRequest", L"Type"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Type());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_IPlayReadyServiceRequest(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Protection::PlayReady::IPlayReadyServiceRequest>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IPlayReadyServiceRequest(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Protection::PlayReady::IPlayReadyServiceRequest>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IPlayReadyServiceRequest[] = {
        { "begin_service_request", reinterpret_cast<PyCFunction>(IPlayReadyServiceRequest_BeginServiceRequest), METH_VARARGS, nullptr },
        { "generate_manual_enabling_challenge", reinterpret_cast<PyCFunction>(IPlayReadyServiceRequest_GenerateManualEnablingChallenge), METH_VARARGS, nullptr },
        { "next_service_request", reinterpret_cast<PyCFunction>(IPlayReadyServiceRequest_NextServiceRequest), METH_VARARGS, nullptr },
        { "process_manual_enabling_response", reinterpret_cast<PyCFunction>(IPlayReadyServiceRequest_ProcessManualEnablingResponse), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_IPlayReadyServiceRequest, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IPlayReadyServiceRequest), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IPlayReadyServiceRequest[] = {
        { "challenge_custom_data", reinterpret_cast<getter>(IPlayReadyServiceRequest_get_ChallengeCustomData), reinterpret_cast<setter>(IPlayReadyServiceRequest_put_ChallengeCustomData), nullptr, nullptr },
        { "response_custom_data", reinterpret_cast<getter>(IPlayReadyServiceRequest_get_ResponseCustomData), nullptr, nullptr, nullptr },
        { "uri", reinterpret_cast<getter>(IPlayReadyServiceRequest_get_Uri), reinterpret_cast<setter>(IPlayReadyServiceRequest_put_Uri), nullptr, nullptr },
        { "protection_system", reinterpret_cast<getter>(IPlayReadyServiceRequest_get_ProtectionSystem), nullptr, nullptr, nullptr },
        { "type", reinterpret_cast<getter>(IPlayReadyServiceRequest_get_Type), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IPlayReadyServiceRequest[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_IPlayReadyServiceRequest) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IPlayReadyServiceRequest) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IPlayReadyServiceRequest) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IPlayReadyServiceRequest) },
        { },
    };

    static PyType_Spec type_spec_IPlayReadyServiceRequest =
    {
        "winrt._winrt_windows_media_protection_playready.IPlayReadyServiceRequest",
        sizeof(py::wrapper::Windows::Media::Protection::PlayReady::IPlayReadyServiceRequest),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IPlayReadyServiceRequest
    };

    // ----- Windows.Media.Protection.PlayReady Initialization --------------------
    PyDoc_STRVAR(module_doc, "Windows::Media::Protection::PlayReady");


    static PyModuleDef module_def
        = {PyModuleDef_HEAD_INIT,
           "_winrt_windows_media_protection_playready",
           module_doc,
           0,
           nullptr,
           nullptr,
           nullptr,
           nullptr,
           nullptr};

} // py::cpp::Windows::Media::Protection::PlayReady

PyMODINIT_FUNC PyInit__winrt_windows_media_protection_playready(void) noexcept
{
    using namespace py::cpp::Windows::Media::Protection::PlayReady;

    if (py::import_winrt_runtime() == -1)
    {
        return nullptr;
    }

    py::pyobj_handle module{PyModule_Create(&module_def)};

    if (!module)
    {
        return nullptr;
    }

    auto object_type = py::get_object_type();
    if (!object_type)
    {
        return nullptr;
    }

    py::pyobj_handle object_bases{PyTuple_Pack(1, object_type)};

    if (!object_bases)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_NDClient, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_NDCustomData, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_NDDownloadEngineNotifier, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_NDLicenseFetchDescriptor, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_NDStorageFileHelper, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_NDStreamParserNotifier, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_NDTCPMessenger, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_PlayReadyContentHeader, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_PlayReadyContentResolver_Static{PyType_FromSpec(&type_spec_PlayReadyContentResolver_Static)};
    if (!type_PlayReadyContentResolver_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_PlayReadyContentResolver, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_PlayReadyContentResolver_Static.get())) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_PlayReadyDomain, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_PlayReadyDomainIterable, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_PlayReadyDomainIterator, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_PlayReadyDomainJoinServiceRequest, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_PlayReadyDomainLeaveServiceRequest, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_PlayReadyITADataGenerator, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_PlayReadyIndividualizationServiceRequest, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_PlayReadyLicense, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_PlayReadyLicenseAcquisitionServiceRequest, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_PlayReadyLicenseIterable, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_PlayReadyLicenseIterator, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_PlayReadyLicenseManagement_Static{PyType_FromSpec(&type_spec_PlayReadyLicenseManagement_Static)};
    if (!type_PlayReadyLicenseManagement_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_PlayReadyLicenseManagement, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_PlayReadyLicenseManagement_Static.get())) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_PlayReadyLicenseSession, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_PlayReadyMeteringReportServiceRequest, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_PlayReadyRevocationServiceRequest, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_PlayReadySecureStopIterable, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_PlayReadySecureStopIterator, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_PlayReadySecureStopServiceRequest, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_PlayReadySoapMessage, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_PlayReadyStatics_Static{PyType_FromSpec(&type_spec_PlayReadyStatics_Static)};
    if (!type_PlayReadyStatics_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_PlayReadyStatics, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_PlayReadyStatics_Static.get())) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_INDClosedCaptionDataReceivedEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_INDCustomData, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_INDDownloadEngine, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_INDDownloadEngineNotifier, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_INDLicenseFetchCompletedEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_INDLicenseFetchDescriptor, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_INDLicenseFetchResult, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_INDMessenger, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_INDProximityDetectionCompletedEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_INDRegistrationCompletedEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_INDSendResult, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_INDStartResult, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_INDStorageFileHelper, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_INDStreamParser, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_INDStreamParserNotifier, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_INDTransmitterProperties, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_IPlayReadyDomain, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_IPlayReadyLicense, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_IPlayReadyLicenseAcquisitionServiceRequest, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_IPlayReadyLicenseSession, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_IPlayReadyLicenseSession2, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_IPlayReadySecureStopServiceRequest, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_IPlayReadyServiceRequest, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }


    return module.detach();
}
