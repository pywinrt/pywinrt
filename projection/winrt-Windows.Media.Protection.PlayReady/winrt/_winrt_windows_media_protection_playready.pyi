# WARNING: Please don't edit this file. It was generated by Python/WinRT v2.0.0-beta.2

import datetime
import sys
import types
import typing
import uuid as _uuid
from builtins import property as _property

import winrt._winrt
import winrt.system
import winrt.windows.foundation
import winrt.windows.foundation.collections
import winrt.windows.media.core
import winrt.windows.media.protection
import winrt.windows.storage

from winrt.windows.media.protection.playready import NDCertificateFeature, NDCertificatePlatformID, NDCertificateType, NDClosedCaptionFormat, NDContentIDType, NDMediaStreamType, NDProximityDetectionType, NDStartAsyncOptions, PlayReadyDecryptorSetup, PlayReadyEncryptionAlgorithm, PlayReadyHardwareDRMFeatures, PlayReadyITADataFormat

Self = typing.TypeVar('Self')

@typing.final
class NDClient(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> NDClient: ...
    def __new__(cls: typing.Type[NDClient], download_engine: typing.Optional[INDDownloadEngine], stream_parser: typing.Optional[INDStreamParser], p_messenger: typing.Optional[INDMessenger]) -> NDClient:...
    def close(self) -> None: ...
    def license_fetch_async(self, license_fetch_descriptor: typing.Optional[INDLicenseFetchDescriptor], /) -> winrt.windows.foundation.IAsyncOperation[INDLicenseFetchResult]: ...
    def re_registration_async(self, registration_custom_data: typing.Optional[INDCustomData], /) -> winrt.windows.foundation.IAsyncAction: ...
    def start_async(self, content_url: typing.Optional[winrt.windows.foundation.Uri], start_async_options: winrt.system.UInt32, registration_custom_data: typing.Optional[INDCustomData], license_fetch_descriptor: typing.Optional[INDLicenseFetchDescriptor], /) -> winrt.windows.foundation.IAsyncOperation[INDStartResult]: ...
    def add_closed_caption_data_received(self, handler: winrt.windows.foundation.TypedEventHandler[NDClient, INDClosedCaptionDataReceivedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_closed_caption_data_received(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_license_fetch_completed(self, handler: winrt.windows.foundation.TypedEventHandler[NDClient, INDLicenseFetchCompletedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_license_fetch_completed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_proximity_detection_completed(self, handler: winrt.windows.foundation.TypedEventHandler[NDClient, INDProximityDetectionCompletedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_proximity_detection_completed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_re_registration_needed(self, handler: winrt.windows.foundation.TypedEventHandler[NDClient, winrt.system.Object], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_re_registration_needed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_registration_completed(self, handler: winrt.windows.foundation.TypedEventHandler[NDClient, INDRegistrationCompletedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_registration_completed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...

@typing.final
class NDCustomData(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> NDCustomData: ...
    def __new__(cls: typing.Type[NDCustomData], custom_data_type_i_d_bytes: winrt.system.Array[winrt.system.UInt8], custom_data_bytes: winrt.system.Array[winrt.system.UInt8]) -> NDCustomData:...
    @_property
    def custom_data(self) -> winrt.system.UInt8: ...
    @_property
    def custom_data_type_i_d(self) -> winrt.system.UInt8: ...

@typing.final
class NDDownloadEngineNotifier(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> NDDownloadEngineNotifier: ...
    def __new__(cls: typing.Type[NDDownloadEngineNotifier]) -> NDDownloadEngineNotifier:...
    def on_content_i_d_received(self, license_fetch_descriptor: typing.Optional[INDLicenseFetchDescriptor], /) -> None: ...
    def on_data_received(self, data_bytes: winrt.system.Array[winrt.system.UInt8], bytes_received: winrt.system.UInt32, /) -> None: ...
    def on_end_of_stream(self) -> None: ...
    def on_network_error(self) -> None: ...
    def on_play_ready_object_received(self, data_bytes: winrt.system.Array[winrt.system.UInt8], /) -> None: ...
    def on_stream_opened(self) -> None: ...

@typing.final
class NDLicenseFetchDescriptor(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> NDLicenseFetchDescriptor: ...
    def __new__(cls: typing.Type[NDLicenseFetchDescriptor], content_i_d_type: NDContentIDType, content_i_d_bytes: winrt.system.Array[winrt.system.UInt8], license_fetch_challenge_custom_data: typing.Optional[INDCustomData]) -> NDLicenseFetchDescriptor:...
    @_property
    def license_fetch_challenge_custom_data(self) -> typing.Optional[INDCustomData]: ...
    @license_fetch_challenge_custom_data.setter
    def license_fetch_challenge_custom_data(self, value: typing.Optional[INDCustomData]) -> None: ...
    @_property
    def content_i_d(self) -> winrt.system.UInt8: ...
    @_property
    def content_i_d_type(self) -> NDContentIDType: ...

@typing.final
class NDStorageFileHelper(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> NDStorageFileHelper: ...
    def __new__(cls: typing.Type[NDStorageFileHelper]) -> NDStorageFileHelper:...
    def get_file_u_r_ls(self, file: typing.Optional[winrt.windows.storage.IStorageFile], /) -> typing.Optional[winrt.windows.foundation.collections.IVector[str]]: ...

@typing.final
class NDStreamParserNotifier(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> NDStreamParserNotifier: ...
    def __new__(cls: typing.Type[NDStreamParserNotifier]) -> NDStreamParserNotifier:...
    def on_begin_setup_decryptor(self, descriptor: typing.Optional[winrt.windows.media.core.IMediaStreamDescriptor], key_i_d: _uuid.UUID, pro_bytes: winrt.system.Array[winrt.system.UInt8], /) -> None: ...
    def on_content_i_d_received(self, license_fetch_descriptor: typing.Optional[INDLicenseFetchDescriptor], /) -> None: ...
    def on_media_stream_descriptor_created(self, audio_stream_descriptors: winrt.windows.foundation.collections.IVector[winrt.windows.media.core.AudioStreamDescriptor], video_stream_descriptors: winrt.windows.foundation.collections.IVector[winrt.windows.media.core.VideoStreamDescriptor], /) -> None: ...
    def on_sample_parsed(self, stream_i_d: winrt.system.UInt32, stream_type: NDMediaStreamType, stream_sample: typing.Optional[winrt.windows.media.core.MediaStreamSample], pts: winrt.system.Int64, cc_format: NDClosedCaptionFormat, cc_data_bytes: winrt.system.Array[winrt.system.UInt8], /) -> None: ...

@typing.final
class NDTCPMessenger(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> NDTCPMessenger: ...
    def __new__(cls: typing.Type[NDTCPMessenger], remote_host_name: str, remote_host_port: winrt.system.UInt32) -> NDTCPMessenger:...
    def send_license_fetch_request_async(self, session_i_d_bytes: winrt.system.Array[winrt.system.UInt8], challenge_data_bytes: winrt.system.Array[winrt.system.UInt8], /) -> winrt.windows.foundation.IAsyncOperation[INDSendResult]: ...
    def send_proximity_detection_response_async(self, pd_type: NDProximityDetectionType, transmitter_channel_bytes: winrt.system.Array[winrt.system.UInt8], session_i_d_bytes: winrt.system.Array[winrt.system.UInt8], response_data_bytes: winrt.system.Array[winrt.system.UInt8], /) -> winrt.windows.foundation.IAsyncOperation[INDSendResult]: ...
    def send_proximity_detection_start_async(self, pd_type: NDProximityDetectionType, transmitter_channel_bytes: winrt.system.Array[winrt.system.UInt8], session_i_d_bytes: winrt.system.Array[winrt.system.UInt8], challenge_data_bytes: winrt.system.Array[winrt.system.UInt8], /) -> winrt.windows.foundation.IAsyncOperation[INDSendResult]: ...
    def send_registration_request_async(self, session_i_d_bytes: winrt.system.Array[winrt.system.UInt8], challenge_data_bytes: winrt.system.Array[winrt.system.UInt8], /) -> winrt.windows.foundation.IAsyncOperation[INDSendResult]: ...

@typing.final
class PlayReadyContentHeader(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> PlayReadyContentHeader: ...
    @typing.overload
    def __new__(cls: typing.Type[PlayReadyContentHeader], dw_flags: winrt.system.UInt32, content_key_ids: winrt.system.Array[_uuid.UUID], content_key_id_strings: winrt.system.Array[str], content_encryption_algorithm: PlayReadyEncryptionAlgorithm, license_acquisition_url: typing.Optional[winrt.windows.foundation.Uri], license_acquisition_user_interface_url: typing.Optional[winrt.windows.foundation.Uri], custom_attributes: str, domain_service_id: _uuid.UUID) -> PlayReadyContentHeader:...
    @typing.overload
    def __new__(cls: typing.Type[PlayReadyContentHeader], header_bytes: winrt.system.Array[winrt.system.UInt8], license_acquisition_url: typing.Optional[winrt.windows.foundation.Uri], license_acquisition_user_interface_url: typing.Optional[winrt.windows.foundation.Uri], custom_attributes: str, domain_service_id: _uuid.UUID) -> PlayReadyContentHeader:...
    @typing.overload
    def __new__(cls: typing.Type[PlayReadyContentHeader], content_key_id: _uuid.UUID, content_key_id_string: str, content_encryption_algorithm: PlayReadyEncryptionAlgorithm, license_acquisition_url: typing.Optional[winrt.windows.foundation.Uri], license_acquisition_user_interface_url: typing.Optional[winrt.windows.foundation.Uri], custom_attributes: str, domain_service_id: _uuid.UUID) -> PlayReadyContentHeader:...
    @typing.overload
    def __new__(cls: typing.Type[PlayReadyContentHeader], header_bytes: winrt.system.Array[winrt.system.UInt8]) -> PlayReadyContentHeader:...
    def get_serialized_header(self) -> winrt.system.UInt8: ...
    @_property
    def custom_attributes(self) -> str: ...
    @_property
    def decryptor_setup(self) -> PlayReadyDecryptorSetup: ...
    @_property
    def domain_service_id(self) -> _uuid.UUID: ...
    @_property
    def encryption_type(self) -> PlayReadyEncryptionAlgorithm: ...
    @_property
    def header_with_embedded_updates(self) -> typing.Optional[PlayReadyContentHeader]: ...
    @_property
    def key_id(self) -> _uuid.UUID: ...
    @_property
    def key_id_string(self) -> str: ...
    @_property
    def license_acquisition_url(self) -> typing.Optional[winrt.windows.foundation.Uri]: ...
    @_property
    def license_acquisition_user_interface_url(self) -> typing.Optional[winrt.windows.foundation.Uri]: ...
    @_property
    def key_id_strings(self) -> str: ...
    @_property
    def key_ids(self) -> _uuid.UUID: ...

@typing.final
class PlayReadyContentResolver_Static(type):
    def service_request(cls, content_header: typing.Optional[PlayReadyContentHeader], /) -> typing.Optional[IPlayReadyServiceRequest]: ...

@typing.final
class PlayReadyContentResolver(winrt.system.Object, metaclass=PlayReadyContentResolver_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> PlayReadyContentResolver: ...

@typing.final
class PlayReadyDomain(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> PlayReadyDomain: ...
    @_property
    def account_id(self) -> _uuid.UUID: ...
    @_property
    def domain_join_url(self) -> typing.Optional[winrt.windows.foundation.Uri]: ...
    @_property
    def friendly_name(self) -> str: ...
    @_property
    def revision(self) -> winrt.system.UInt32: ...
    @_property
    def service_id(self) -> _uuid.UUID: ...

@typing.final
class PlayReadyDomainIterable(winrt.system.Object):
    def __iter__(self) -> winrt.windows.foundation.collections.IIterator[IPlayReadyDomain]: ...
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> PlayReadyDomainIterable: ...
    def __new__(cls: typing.Type[PlayReadyDomainIterable], domain_account_id: _uuid.UUID) -> PlayReadyDomainIterable:...
    def first(self) -> typing.Optional[winrt.windows.foundation.collections.IIterator[IPlayReadyDomain]]: ...

@typing.final
class PlayReadyDomainIterator(winrt.system.Object):
    def __iter__(self: Self) -> Self: ...
    def __next__(self) -> IPlayReadyDomain: ...
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> PlayReadyDomainIterator: ...
    def get_many(self, items: winrt.system.Array[IPlayReadyDomain], /) -> winrt.system.UInt32: ...
    def move_next(self) -> bool: ...
    @_property
    def current(self) -> typing.Optional[IPlayReadyDomain]: ...
    @_property
    def has_current(self) -> bool: ...

@typing.final
class PlayReadyDomainJoinServiceRequest(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> PlayReadyDomainJoinServiceRequest: ...
    def __new__(cls: typing.Type[PlayReadyDomainJoinServiceRequest]) -> PlayReadyDomainJoinServiceRequest:...
    def begin_service_request(self) -> winrt.windows.foundation.IAsyncAction: ...
    def generate_manual_enabling_challenge(self) -> typing.Optional[PlayReadySoapMessage]: ...
    def next_service_request(self) -> typing.Optional[IPlayReadyServiceRequest]: ...
    def process_manual_enabling_response(self, response_bytes: winrt.system.Array[winrt.system.UInt8], /) -> winrt.windows.foundation.HResult: ...
    @_property
    def protection_system(self) -> _uuid.UUID: ...
    @_property
    def type(self) -> _uuid.UUID: ...
    @_property
    def domain_service_id(self) -> _uuid.UUID: ...
    @domain_service_id.setter
    def domain_service_id(self, value: _uuid.UUID) -> None: ...
    @_property
    def domain_friendly_name(self) -> str: ...
    @domain_friendly_name.setter
    def domain_friendly_name(self, value: str) -> None: ...
    @_property
    def domain_account_id(self) -> _uuid.UUID: ...
    @domain_account_id.setter
    def domain_account_id(self, value: _uuid.UUID) -> None: ...
    @_property
    def uri(self) -> typing.Optional[winrt.windows.foundation.Uri]: ...
    @uri.setter
    def uri(self, value: typing.Optional[winrt.windows.foundation.Uri]) -> None: ...
    @_property
    def challenge_custom_data(self) -> str: ...
    @challenge_custom_data.setter
    def challenge_custom_data(self, value: str) -> None: ...
    @_property
    def response_custom_data(self) -> str: ...

@typing.final
class PlayReadyDomainLeaveServiceRequest(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> PlayReadyDomainLeaveServiceRequest: ...
    def __new__(cls: typing.Type[PlayReadyDomainLeaveServiceRequest]) -> PlayReadyDomainLeaveServiceRequest:...
    def begin_service_request(self) -> winrt.windows.foundation.IAsyncAction: ...
    def generate_manual_enabling_challenge(self) -> typing.Optional[PlayReadySoapMessage]: ...
    def next_service_request(self) -> typing.Optional[IPlayReadyServiceRequest]: ...
    def process_manual_enabling_response(self, response_bytes: winrt.system.Array[winrt.system.UInt8], /) -> winrt.windows.foundation.HResult: ...
    @_property
    def protection_system(self) -> _uuid.UUID: ...
    @_property
    def type(self) -> _uuid.UUID: ...
    @_property
    def domain_service_id(self) -> _uuid.UUID: ...
    @domain_service_id.setter
    def domain_service_id(self, value: _uuid.UUID) -> None: ...
    @_property
    def domain_account_id(self) -> _uuid.UUID: ...
    @domain_account_id.setter
    def domain_account_id(self, value: _uuid.UUID) -> None: ...
    @_property
    def uri(self) -> typing.Optional[winrt.windows.foundation.Uri]: ...
    @uri.setter
    def uri(self, value: typing.Optional[winrt.windows.foundation.Uri]) -> None: ...
    @_property
    def challenge_custom_data(self) -> str: ...
    @challenge_custom_data.setter
    def challenge_custom_data(self, value: str) -> None: ...
    @_property
    def response_custom_data(self) -> str: ...

@typing.final
class PlayReadyITADataGenerator(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> PlayReadyITADataGenerator: ...
    def __new__(cls: typing.Type[PlayReadyITADataGenerator]) -> PlayReadyITADataGenerator:...
    def generate_data(self, guid_c_p_system_id: _uuid.UUID, count_of_streams: winrt.system.UInt32, configuration: typing.Optional[winrt.windows.foundation.collections.IPropertySet], format: PlayReadyITADataFormat, /) -> winrt.system.UInt8: ...

@typing.final
class PlayReadyIndividualizationServiceRequest(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> PlayReadyIndividualizationServiceRequest: ...
    def __new__(cls: typing.Type[PlayReadyIndividualizationServiceRequest]) -> PlayReadyIndividualizationServiceRequest:...
    def begin_service_request(self) -> winrt.windows.foundation.IAsyncAction: ...
    def generate_manual_enabling_challenge(self) -> typing.Optional[PlayReadySoapMessage]: ...
    def next_service_request(self) -> typing.Optional[IPlayReadyServiceRequest]: ...
    def process_manual_enabling_response(self, response_bytes: winrt.system.Array[winrt.system.UInt8], /) -> winrt.windows.foundation.HResult: ...
    @_property
    def protection_system(self) -> _uuid.UUID: ...
    @_property
    def type(self) -> _uuid.UUID: ...
    @_property
    def uri(self) -> typing.Optional[winrt.windows.foundation.Uri]: ...
    @uri.setter
    def uri(self, value: typing.Optional[winrt.windows.foundation.Uri]) -> None: ...
    @_property
    def challenge_custom_data(self) -> str: ...
    @challenge_custom_data.setter
    def challenge_custom_data(self, value: str) -> None: ...
    @_property
    def response_custom_data(self) -> str: ...

@typing.final
class PlayReadyLicense(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> PlayReadyLicense: ...
    def get_k_i_d_at_chain_depth(self, chain_depth: winrt.system.UInt32, /) -> _uuid.UUID: ...
    @_property
    def chain_depth(self) -> winrt.system.UInt32: ...
    @_property
    def domain_account_i_d(self) -> _uuid.UUID: ...
    @_property
    def expiration_date(self) -> typing.Optional[typing.Optional[datetime.datetime]]: ...
    @_property
    def expire_after_first_play(self) -> winrt.system.UInt32: ...
    @_property
    def fully_evaluated(self) -> bool: ...
    @_property
    def usable_for_play(self) -> bool: ...
    @_property
    def expires_in_real_time(self) -> bool: ...
    @_property
    def in_memory_only(self) -> bool: ...
    @_property
    def secure_stop_id(self) -> _uuid.UUID: ...
    @_property
    def security_level(self) -> winrt.system.UInt32: ...

@typing.final
class PlayReadyLicenseAcquisitionServiceRequest(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> PlayReadyLicenseAcquisitionServiceRequest: ...
    def __new__(cls: typing.Type[PlayReadyLicenseAcquisitionServiceRequest]) -> PlayReadyLicenseAcquisitionServiceRequest:...
    def begin_service_request(self) -> winrt.windows.foundation.IAsyncAction: ...
    def create_license_iterable(self, content_header: typing.Optional[PlayReadyContentHeader], fully_evaluated: bool, /) -> typing.Optional[PlayReadyLicenseIterable]: ...
    def generate_manual_enabling_challenge(self) -> typing.Optional[PlayReadySoapMessage]: ...
    def next_service_request(self) -> typing.Optional[IPlayReadyServiceRequest]: ...
    def process_manual_enabling_response(self, response_bytes: winrt.system.Array[winrt.system.UInt8], /) -> winrt.windows.foundation.HResult: ...
    @_property
    def protection_system(self) -> _uuid.UUID: ...
    @_property
    def type(self) -> _uuid.UUID: ...
    @_property
    def domain_service_id(self) -> _uuid.UUID: ...
    @domain_service_id.setter
    def domain_service_id(self, value: _uuid.UUID) -> None: ...
    @_property
    def content_header(self) -> typing.Optional[PlayReadyContentHeader]: ...
    @content_header.setter
    def content_header(self, value: typing.Optional[PlayReadyContentHeader]) -> None: ...
    @_property
    def session_id(self) -> _uuid.UUID: ...
    @_property
    def uri(self) -> typing.Optional[winrt.windows.foundation.Uri]: ...
    @uri.setter
    def uri(self, value: typing.Optional[winrt.windows.foundation.Uri]) -> None: ...
    @_property
    def challenge_custom_data(self) -> str: ...
    @challenge_custom_data.setter
    def challenge_custom_data(self, value: str) -> None: ...
    @_property
    def response_custom_data(self) -> str: ...

@typing.final
class PlayReadyLicenseIterable(winrt.system.Object):
    def __iter__(self) -> winrt.windows.foundation.collections.IIterator[IPlayReadyLicense]: ...
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> PlayReadyLicenseIterable: ...
    @typing.overload
    def __new__(cls: typing.Type[PlayReadyLicenseIterable]) -> PlayReadyLicenseIterable:...
    @typing.overload
    def __new__(cls: typing.Type[PlayReadyLicenseIterable], content_header: typing.Optional[PlayReadyContentHeader], fully_evaluated: bool) -> PlayReadyLicenseIterable:...
    def first(self) -> typing.Optional[winrt.windows.foundation.collections.IIterator[IPlayReadyLicense]]: ...

@typing.final
class PlayReadyLicenseIterator(winrt.system.Object):
    def __iter__(self: Self) -> Self: ...
    def __next__(self) -> IPlayReadyLicense: ...
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> PlayReadyLicenseIterator: ...
    def get_many(self, items: winrt.system.Array[IPlayReadyLicense], /) -> winrt.system.UInt32: ...
    def move_next(self) -> bool: ...
    @_property
    def current(self) -> typing.Optional[IPlayReadyLicense]: ...
    @_property
    def has_current(self) -> bool: ...

@typing.final
class PlayReadyLicenseManagement_Static(type):
    def delete_licenses(cls, content_header: typing.Optional[PlayReadyContentHeader], /) -> winrt.windows.foundation.IAsyncAction: ...

@typing.final
class PlayReadyLicenseManagement(winrt.system.Object, metaclass=PlayReadyLicenseManagement_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> PlayReadyLicenseManagement: ...

@typing.final
class PlayReadyLicenseSession(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> PlayReadyLicenseSession: ...
    def __new__(cls: typing.Type[PlayReadyLicenseSession], configuration: typing.Optional[winrt.windows.foundation.collections.IPropertySet]) -> PlayReadyLicenseSession:...
    def configure_media_protection_manager(self, mpm: typing.Optional[winrt.windows.media.protection.MediaProtectionManager], /) -> None: ...
    def create_l_a_service_request(self) -> typing.Optional[IPlayReadyLicenseAcquisitionServiceRequest]: ...
    def create_license_iterable(self, content_header: typing.Optional[PlayReadyContentHeader], fully_evaluated: bool, /) -> typing.Optional[PlayReadyLicenseIterable]: ...

@typing.final
class PlayReadyMeteringReportServiceRequest(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> PlayReadyMeteringReportServiceRequest: ...
    def __new__(cls: typing.Type[PlayReadyMeteringReportServiceRequest]) -> PlayReadyMeteringReportServiceRequest:...
    def begin_service_request(self) -> winrt.windows.foundation.IAsyncAction: ...
    def generate_manual_enabling_challenge(self) -> typing.Optional[PlayReadySoapMessage]: ...
    def next_service_request(self) -> typing.Optional[IPlayReadyServiceRequest]: ...
    def process_manual_enabling_response(self, response_bytes: winrt.system.Array[winrt.system.UInt8], /) -> winrt.windows.foundation.HResult: ...
    @_property
    def protection_system(self) -> _uuid.UUID: ...
    @_property
    def type(self) -> _uuid.UUID: ...
    @_property
    def metering_certificate(self) -> winrt.system.UInt8: ...
    @metering_certificate.setter
    def metering_certificate(self, value: winrt.system.UInt8) -> None: ...
    @_property
    def uri(self) -> typing.Optional[winrt.windows.foundation.Uri]: ...
    @uri.setter
    def uri(self, value: typing.Optional[winrt.windows.foundation.Uri]) -> None: ...
    @_property
    def challenge_custom_data(self) -> str: ...
    @challenge_custom_data.setter
    def challenge_custom_data(self, value: str) -> None: ...
    @_property
    def response_custom_data(self) -> str: ...

@typing.final
class PlayReadyRevocationServiceRequest(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> PlayReadyRevocationServiceRequest: ...
    def __new__(cls: typing.Type[PlayReadyRevocationServiceRequest]) -> PlayReadyRevocationServiceRequest:...
    def begin_service_request(self) -> winrt.windows.foundation.IAsyncAction: ...
    def generate_manual_enabling_challenge(self) -> typing.Optional[PlayReadySoapMessage]: ...
    def next_service_request(self) -> typing.Optional[IPlayReadyServiceRequest]: ...
    def process_manual_enabling_response(self, response_bytes: winrt.system.Array[winrt.system.UInt8], /) -> winrt.windows.foundation.HResult: ...
    @_property
    def protection_system(self) -> _uuid.UUID: ...
    @_property
    def type(self) -> _uuid.UUID: ...
    @_property
    def uri(self) -> typing.Optional[winrt.windows.foundation.Uri]: ...
    @uri.setter
    def uri(self, value: typing.Optional[winrt.windows.foundation.Uri]) -> None: ...
    @_property
    def challenge_custom_data(self) -> str: ...
    @challenge_custom_data.setter
    def challenge_custom_data(self, value: str) -> None: ...
    @_property
    def response_custom_data(self) -> str: ...

@typing.final
class PlayReadySecureStopIterable(winrt.system.Object):
    def __iter__(self) -> winrt.windows.foundation.collections.IIterator[IPlayReadySecureStopServiceRequest]: ...
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> PlayReadySecureStopIterable: ...
    def __new__(cls: typing.Type[PlayReadySecureStopIterable], publisher_cert_bytes: winrt.system.Array[winrt.system.UInt8]) -> PlayReadySecureStopIterable:...
    def first(self) -> typing.Optional[winrt.windows.foundation.collections.IIterator[IPlayReadySecureStopServiceRequest]]: ...

@typing.final
class PlayReadySecureStopIterator(winrt.system.Object):
    def __iter__(self: Self) -> Self: ...
    def __next__(self) -> IPlayReadySecureStopServiceRequest: ...
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> PlayReadySecureStopIterator: ...
    def get_many(self, items: winrt.system.Array[IPlayReadySecureStopServiceRequest], /) -> winrt.system.UInt32: ...
    def move_next(self) -> bool: ...
    @_property
    def current(self) -> typing.Optional[IPlayReadySecureStopServiceRequest]: ...
    @_property
    def has_current(self) -> bool: ...

@typing.final
class PlayReadySecureStopServiceRequest(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> PlayReadySecureStopServiceRequest: ...
    @typing.overload
    def __new__(cls: typing.Type[PlayReadySecureStopServiceRequest], publisher_cert_bytes: winrt.system.Array[winrt.system.UInt8]) -> PlayReadySecureStopServiceRequest:...
    @typing.overload
    def __new__(cls: typing.Type[PlayReadySecureStopServiceRequest], session_i_d: _uuid.UUID, publisher_cert_bytes: winrt.system.Array[winrt.system.UInt8]) -> PlayReadySecureStopServiceRequest:...
    def begin_service_request(self) -> winrt.windows.foundation.IAsyncAction: ...
    def generate_manual_enabling_challenge(self) -> typing.Optional[PlayReadySoapMessage]: ...
    def next_service_request(self) -> typing.Optional[IPlayReadyServiceRequest]: ...
    def process_manual_enabling_response(self, response_bytes: winrt.system.Array[winrt.system.UInt8], /) -> winrt.windows.foundation.HResult: ...
    @_property
    def protection_system(self) -> _uuid.UUID: ...
    @_property
    def type(self) -> _uuid.UUID: ...
    @_property
    def publisher_certificate(self) -> winrt.system.UInt8: ...
    @_property
    def session_i_d(self) -> _uuid.UUID: ...
    @_property
    def start_time(self) -> datetime.datetime: ...
    @_property
    def stopped(self) -> bool: ...
    @_property
    def update_time(self) -> datetime.datetime: ...
    @_property
    def uri(self) -> typing.Optional[winrt.windows.foundation.Uri]: ...
    @uri.setter
    def uri(self, value: typing.Optional[winrt.windows.foundation.Uri]) -> None: ...
    @_property
    def challenge_custom_data(self) -> str: ...
    @challenge_custom_data.setter
    def challenge_custom_data(self, value: str) -> None: ...
    @_property
    def response_custom_data(self) -> str: ...

@typing.final
class PlayReadySoapMessage(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> PlayReadySoapMessage: ...
    def get_message_body(self) -> winrt.system.UInt8: ...
    @_property
    def message_headers(self) -> typing.Optional[winrt.windows.foundation.collections.IPropertySet]: ...
    @_property
    def uri(self) -> typing.Optional[winrt.windows.foundation.Uri]: ...

@typing.final
class PlayReadyStatics_Static(type):
    def check_supported_hardware(cls, hwdrm_feature: PlayReadyHardwareDRMFeatures, /) -> bool: ...
    def reset_hardware_d_r_m_disabled(cls) -> None: ...
    @_property
    def domain_join_service_request_type(cls) -> _uuid.UUID: ...
    @_property
    def domain_leave_service_request_type(cls) -> _uuid.UUID: ...
    @_property
    def individualization_service_request_type(cls) -> _uuid.UUID: ...
    @_property
    def license_acquirer_service_request_type(cls) -> _uuid.UUID: ...
    @_property
    def media_protection_system_id(cls) -> _uuid.UUID: ...
    @_property
    def metering_report_service_request_type(cls) -> _uuid.UUID: ...
    @_property
    def play_ready_security_version(cls) -> winrt.system.UInt32: ...
    @_property
    def revocation_service_request_type(cls) -> _uuid.UUID: ...
    @_property
    def play_ready_certificate_security_level(cls) -> winrt.system.UInt32: ...
    @_property
    def secure_stop_service_request_type(cls) -> _uuid.UUID: ...
    @_property
    def protection_system_id(cls) -> _uuid.UUID: ...
    @_property
    def input_trust_authority_to_create(cls) -> str: ...
    @_property
    def hardware_d_r_m_disabled_until_time(cls) -> typing.Optional[typing.Optional[datetime.datetime]]: ...
    @_property
    def hardware_d_r_m_disabled_at_time(cls) -> typing.Optional[typing.Optional[datetime.datetime]]: ...

@typing.final
class PlayReadyStatics(winrt.system.Object, metaclass=PlayReadyStatics_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> PlayReadyStatics: ...

@typing.final
class INDClosedCaptionDataReceivedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> INDClosedCaptionDataReceivedEventArgs: ...
    @_property
    def closed_caption_data(self) -> winrt.system.UInt8: ...
    @_property
    def closed_caption_data_format(self) -> NDClosedCaptionFormat: ...
    @_property
    def presentation_timestamp(self) -> winrt.system.Int64: ...

@typing.final
class INDCustomData(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> INDCustomData: ...
    @_property
    def custom_data(self) -> winrt.system.UInt8: ...
    @_property
    def custom_data_type_i_d(self) -> winrt.system.UInt8: ...

@typing.final
class INDDownloadEngine(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> INDDownloadEngine: ...
    def close(self) -> None: ...
    def open(self, uri: typing.Optional[winrt.windows.foundation.Uri], session_i_d_bytes: winrt.system.Array[winrt.system.UInt8], /) -> None: ...
    def pause(self) -> None: ...
    def resume(self) -> None: ...
    def seek(self, start_position: datetime.timedelta, /) -> None: ...
    @_property
    def buffer_full_max_threshold_in_samples(self) -> winrt.system.UInt32: ...
    @_property
    def buffer_full_min_threshold_in_samples(self) -> winrt.system.UInt32: ...
    @_property
    def can_seek(self) -> bool: ...
    @_property
    def notifier(self) -> typing.Optional[NDDownloadEngineNotifier]: ...

@typing.final
class INDDownloadEngineNotifier(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> INDDownloadEngineNotifier: ...
    def on_content_i_d_received(self, license_fetch_descriptor: typing.Optional[INDLicenseFetchDescriptor], /) -> None: ...
    def on_data_received(self, data_bytes: winrt.system.Array[winrt.system.UInt8], bytes_received: winrt.system.UInt32, /) -> None: ...
    def on_end_of_stream(self) -> None: ...
    def on_network_error(self) -> None: ...
    def on_play_ready_object_received(self, data_bytes: winrt.system.Array[winrt.system.UInt8], /) -> None: ...
    def on_stream_opened(self) -> None: ...

@typing.final
class INDLicenseFetchCompletedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> INDLicenseFetchCompletedEventArgs: ...
    @_property
    def response_custom_data(self) -> typing.Optional[INDCustomData]: ...

@typing.final
class INDLicenseFetchDescriptor(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> INDLicenseFetchDescriptor: ...
    @_property
    def content_i_d(self) -> winrt.system.UInt8: ...
    @_property
    def content_i_d_type(self) -> NDContentIDType: ...
    @_property
    def license_fetch_challenge_custom_data(self) -> typing.Optional[INDCustomData]: ...
    @license_fetch_challenge_custom_data.setter
    def license_fetch_challenge_custom_data(self, value: typing.Optional[INDCustomData]) -> None: ...

@typing.final
class INDLicenseFetchResult(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> INDLicenseFetchResult: ...
    @_property
    def response_custom_data(self) -> typing.Optional[INDCustomData]: ...

@typing.final
class INDMessenger(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> INDMessenger: ...
    def send_license_fetch_request_async(self, session_i_d_bytes: winrt.system.Array[winrt.system.UInt8], challenge_data_bytes: winrt.system.Array[winrt.system.UInt8], /) -> winrt.windows.foundation.IAsyncOperation[INDSendResult]: ...
    def send_proximity_detection_response_async(self, pd_type: NDProximityDetectionType, transmitter_channel_bytes: winrt.system.Array[winrt.system.UInt8], session_i_d_bytes: winrt.system.Array[winrt.system.UInt8], response_data_bytes: winrt.system.Array[winrt.system.UInt8], /) -> winrt.windows.foundation.IAsyncOperation[INDSendResult]: ...
    def send_proximity_detection_start_async(self, pd_type: NDProximityDetectionType, transmitter_channel_bytes: winrt.system.Array[winrt.system.UInt8], session_i_d_bytes: winrt.system.Array[winrt.system.UInt8], challenge_data_bytes: winrt.system.Array[winrt.system.UInt8], /) -> winrt.windows.foundation.IAsyncOperation[INDSendResult]: ...
    def send_registration_request_async(self, session_i_d_bytes: winrt.system.Array[winrt.system.UInt8], challenge_data_bytes: winrt.system.Array[winrt.system.UInt8], /) -> winrt.windows.foundation.IAsyncOperation[INDSendResult]: ...

@typing.final
class INDProximityDetectionCompletedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> INDProximityDetectionCompletedEventArgs: ...
    @_property
    def proximity_detection_retry_count(self) -> winrt.system.UInt32: ...

@typing.final
class INDRegistrationCompletedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> INDRegistrationCompletedEventArgs: ...
    @_property
    def response_custom_data(self) -> typing.Optional[INDCustomData]: ...
    @_property
    def transmitter_certificate_accepted(self) -> bool: ...
    @transmitter_certificate_accepted.setter
    def transmitter_certificate_accepted(self, value: bool) -> None: ...
    @_property
    def transmitter_properties(self) -> typing.Optional[INDTransmitterProperties]: ...

@typing.final
class INDSendResult(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> INDSendResult: ...
    @_property
    def response(self) -> winrt.system.UInt8: ...

@typing.final
class INDStartResult(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> INDStartResult: ...
    @_property
    def media_stream_source(self) -> typing.Optional[winrt.windows.media.core.MediaStreamSource]: ...

@typing.final
class INDStorageFileHelper(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> INDStorageFileHelper: ...
    def get_file_u_r_ls(self, file: typing.Optional[winrt.windows.storage.IStorageFile], /) -> typing.Optional[winrt.windows.foundation.collections.IVector[str]]: ...

@typing.final
class INDStreamParser(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> INDStreamParser: ...
    def begin_of_stream(self) -> None: ...
    def end_of_stream(self) -> None: ...
    def get_stream_information(self, descriptor: typing.Optional[winrt.windows.media.core.IMediaStreamDescriptor], /) -> typing.Tuple[winrt.system.UInt32, NDMediaStreamType]: ...
    def parse_data(self, data_bytes: winrt.system.Array[winrt.system.UInt8], /) -> None: ...
    @_property
    def notifier(self) -> typing.Optional[NDStreamParserNotifier]: ...

@typing.final
class INDStreamParserNotifier(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> INDStreamParserNotifier: ...
    def on_begin_setup_decryptor(self, descriptor: typing.Optional[winrt.windows.media.core.IMediaStreamDescriptor], key_i_d: _uuid.UUID, pro_bytes: winrt.system.Array[winrt.system.UInt8], /) -> None: ...
    def on_content_i_d_received(self, license_fetch_descriptor: typing.Optional[INDLicenseFetchDescriptor], /) -> None: ...
    def on_media_stream_descriptor_created(self, audio_stream_descriptors: winrt.windows.foundation.collections.IVector[winrt.windows.media.core.AudioStreamDescriptor], video_stream_descriptors: winrt.windows.foundation.collections.IVector[winrt.windows.media.core.VideoStreamDescriptor], /) -> None: ...
    def on_sample_parsed(self, stream_i_d: winrt.system.UInt32, stream_type: NDMediaStreamType, stream_sample: typing.Optional[winrt.windows.media.core.MediaStreamSample], pts: winrt.system.Int64, cc_format: NDClosedCaptionFormat, cc_data_bytes: winrt.system.Array[winrt.system.UInt8], /) -> None: ...

@typing.final
class INDTransmitterProperties(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> INDTransmitterProperties: ...
    @_property
    def certificate_type(self) -> NDCertificateType: ...
    @_property
    def client_i_d(self) -> winrt.system.UInt8: ...
    @_property
    def expiration_date(self) -> datetime.datetime: ...
    @_property
    def model_digest(self) -> winrt.system.UInt8: ...
    @_property
    def model_manufacturer_name(self) -> str: ...
    @_property
    def model_name(self) -> str: ...
    @_property
    def model_number(self) -> str: ...
    @_property
    def platform_identifier(self) -> NDCertificatePlatformID: ...
    @_property
    def security_level(self) -> winrt.system.UInt32: ...
    @_property
    def security_version(self) -> winrt.system.UInt32: ...
    @_property
    def supported_features(self) -> NDCertificateFeature: ...

@typing.final
class IPlayReadyDomain(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> IPlayReadyDomain: ...
    @_property
    def account_id(self) -> _uuid.UUID: ...
    @_property
    def domain_join_url(self) -> typing.Optional[winrt.windows.foundation.Uri]: ...
    @_property
    def friendly_name(self) -> str: ...
    @_property
    def revision(self) -> winrt.system.UInt32: ...
    @_property
    def service_id(self) -> _uuid.UUID: ...

@typing.final
class IPlayReadyLicense(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> IPlayReadyLicense: ...
    def get_k_i_d_at_chain_depth(self, chain_depth: winrt.system.UInt32, /) -> _uuid.UUID: ...
    @_property
    def chain_depth(self) -> winrt.system.UInt32: ...
    @_property
    def domain_account_i_d(self) -> _uuid.UUID: ...
    @_property
    def expiration_date(self) -> typing.Optional[typing.Optional[datetime.datetime]]: ...
    @_property
    def expire_after_first_play(self) -> winrt.system.UInt32: ...
    @_property
    def fully_evaluated(self) -> bool: ...
    @_property
    def usable_for_play(self) -> bool: ...

@typing.final
class IPlayReadyLicenseAcquisitionServiceRequest(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> IPlayReadyLicenseAcquisitionServiceRequest: ...
    def begin_service_request(self) -> winrt.windows.foundation.IAsyncAction: ...
    def generate_manual_enabling_challenge(self) -> typing.Optional[PlayReadySoapMessage]: ...
    def next_service_request(self) -> typing.Optional[IPlayReadyServiceRequest]: ...
    def process_manual_enabling_response(self, response_bytes: winrt.system.Array[winrt.system.UInt8], /) -> winrt.windows.foundation.HResult: ...
    @_property
    def content_header(self) -> typing.Optional[PlayReadyContentHeader]: ...
    @content_header.setter
    def content_header(self, value: typing.Optional[PlayReadyContentHeader]) -> None: ...
    @_property
    def domain_service_id(self) -> _uuid.UUID: ...
    @domain_service_id.setter
    def domain_service_id(self, value: _uuid.UUID) -> None: ...
    @_property
    def challenge_custom_data(self) -> str: ...
    @challenge_custom_data.setter
    def challenge_custom_data(self, value: str) -> None: ...
    @_property
    def response_custom_data(self) -> str: ...
    @_property
    def uri(self) -> typing.Optional[winrt.windows.foundation.Uri]: ...
    @uri.setter
    def uri(self, value: typing.Optional[winrt.windows.foundation.Uri]) -> None: ...
    @_property
    def protection_system(self) -> _uuid.UUID: ...
    @_property
    def type(self) -> _uuid.UUID: ...

@typing.final
class IPlayReadyLicenseSession(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> IPlayReadyLicenseSession: ...
    def configure_media_protection_manager(self, mpm: typing.Optional[winrt.windows.media.protection.MediaProtectionManager], /) -> None: ...
    def create_l_a_service_request(self) -> typing.Optional[IPlayReadyLicenseAcquisitionServiceRequest]: ...

@typing.final
class IPlayReadyLicenseSession2(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> IPlayReadyLicenseSession2: ...
    def configure_media_protection_manager(self, mpm: typing.Optional[winrt.windows.media.protection.MediaProtectionManager], /) -> None: ...
    def create_l_a_service_request(self) -> typing.Optional[IPlayReadyLicenseAcquisitionServiceRequest]: ...
    def create_license_iterable(self, content_header: typing.Optional[PlayReadyContentHeader], fully_evaluated: bool, /) -> typing.Optional[PlayReadyLicenseIterable]: ...

@typing.final
class IPlayReadySecureStopServiceRequest(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> IPlayReadySecureStopServiceRequest: ...
    def begin_service_request(self) -> winrt.windows.foundation.IAsyncAction: ...
    def generate_manual_enabling_challenge(self) -> typing.Optional[PlayReadySoapMessage]: ...
    def next_service_request(self) -> typing.Optional[IPlayReadyServiceRequest]: ...
    def process_manual_enabling_response(self, response_bytes: winrt.system.Array[winrt.system.UInt8], /) -> winrt.windows.foundation.HResult: ...
    @_property
    def publisher_certificate(self) -> winrt.system.UInt8: ...
    @_property
    def session_i_d(self) -> _uuid.UUID: ...
    @_property
    def start_time(self) -> datetime.datetime: ...
    @_property
    def stopped(self) -> bool: ...
    @_property
    def update_time(self) -> datetime.datetime: ...
    @_property
    def challenge_custom_data(self) -> str: ...
    @challenge_custom_data.setter
    def challenge_custom_data(self, value: str) -> None: ...
    @_property
    def response_custom_data(self) -> str: ...
    @_property
    def uri(self) -> typing.Optional[winrt.windows.foundation.Uri]: ...
    @uri.setter
    def uri(self, value: typing.Optional[winrt.windows.foundation.Uri]) -> None: ...
    @_property
    def protection_system(self) -> _uuid.UUID: ...
    @_property
    def type(self) -> _uuid.UUID: ...

@typing.final
class IPlayReadyServiceRequest(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> IPlayReadyServiceRequest: ...
    def begin_service_request(self) -> winrt.windows.foundation.IAsyncAction: ...
    def generate_manual_enabling_challenge(self) -> typing.Optional[PlayReadySoapMessage]: ...
    def next_service_request(self) -> typing.Optional[IPlayReadyServiceRequest]: ...
    def process_manual_enabling_response(self, response_bytes: winrt.system.Array[winrt.system.UInt8], /) -> winrt.windows.foundation.HResult: ...
    @_property
    def challenge_custom_data(self) -> str: ...
    @challenge_custom_data.setter
    def challenge_custom_data(self, value: str) -> None: ...
    @_property
    def response_custom_data(self) -> str: ...
    @_property
    def uri(self) -> typing.Optional[winrt.windows.foundation.Uri]: ...
    @uri.setter
    def uri(self, value: typing.Optional[winrt.windows.foundation.Uri]) -> None: ...
    @_property
    def protection_system(self) -> _uuid.UUID: ...
    @_property
    def type(self) -> _uuid.UUID: ...

