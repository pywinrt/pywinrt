// WARNING: Please don't edit this file. It was generated by Python/WinRT v2.1.0

#include "py.Windows.Media.Capture.h"

namespace py::cpp::Windows::Media::Capture
{
    // ----- AdvancedCapturedPhoto class --------------------

    static PyObject* _new_AdvancedCapturedPhoto(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Capture::AdvancedCapturedPhoto>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Capture::AdvancedCapturedPhoto>::type_name);
        return nullptr;
    }

    static void _dealloc_AdvancedCapturedPhoto(py::wrapper::Windows::Media::Capture::AdvancedCapturedPhoto* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AdvancedCapturedPhoto_get_Context(py::wrapper::Windows::Media::Capture::AdvancedCapturedPhoto* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AdvancedCapturedPhoto", L"Context"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Context());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AdvancedCapturedPhoto_get_Frame(py::wrapper::Windows::Media::Capture::AdvancedCapturedPhoto* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AdvancedCapturedPhoto", L"Frame"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Frame());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AdvancedCapturedPhoto_get_Mode(py::wrapper::Windows::Media::Capture::AdvancedCapturedPhoto* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AdvancedCapturedPhoto", L"Mode"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Mode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AdvancedCapturedPhoto_get_FrameBoundsRelativeToReferencePhoto(py::wrapper::Windows::Media::Capture::AdvancedCapturedPhoto* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AdvancedCapturedPhoto", L"FrameBoundsRelativeToReferencePhoto"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.FrameBoundsRelativeToReferencePhoto());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AdvancedCapturedPhoto(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Capture::AdvancedCapturedPhoto>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AdvancedCapturedPhoto(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Capture::AdvancedCapturedPhoto>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AdvancedCapturedPhoto[] = {
        { "_assign_array_", _assign_array_AdvancedCapturedPhoto, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AdvancedCapturedPhoto), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AdvancedCapturedPhoto[] = {
        { "context", reinterpret_cast<getter>(AdvancedCapturedPhoto_get_Context), nullptr, nullptr, nullptr },
        { "frame", reinterpret_cast<getter>(AdvancedCapturedPhoto_get_Frame), nullptr, nullptr, nullptr },
        { "mode", reinterpret_cast<getter>(AdvancedCapturedPhoto_get_Mode), nullptr, nullptr, nullptr },
        { "frame_bounds_relative_to_reference_photo", reinterpret_cast<getter>(AdvancedCapturedPhoto_get_FrameBoundsRelativeToReferencePhoto), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AdvancedCapturedPhoto[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_AdvancedCapturedPhoto) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AdvancedCapturedPhoto) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AdvancedCapturedPhoto) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AdvancedCapturedPhoto) },
        { }
    };

    static PyType_Spec type_spec_AdvancedCapturedPhoto = {
        "winrt._winrt_windows_media_capture.AdvancedCapturedPhoto",
        sizeof(py::wrapper::Windows::Media::Capture::AdvancedCapturedPhoto),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AdvancedCapturedPhoto};

    // ----- AdvancedPhotoCapture class --------------------

    static PyObject* _new_AdvancedPhotoCapture(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Capture::AdvancedPhotoCapture>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Capture::AdvancedPhotoCapture>::type_name);
        return nullptr;
    }

    static void _dealloc_AdvancedPhotoCapture(py::wrapper::Windows::Media::Capture::AdvancedPhotoCapture* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AdvancedPhotoCapture_CaptureAsync(py::wrapper::Windows::Media::Capture::AdvancedPhotoCapture* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Capture.AdvancedPhotoCapture", L"CaptureAsync", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.CaptureAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Capture.AdvancedPhotoCapture", L"CaptureAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 0);

                return py::convert(self->obj.CaptureAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AdvancedPhotoCapture_FinishAsync(py::wrapper::Windows::Media::Capture::AdvancedPhotoCapture* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Capture.AdvancedPhotoCapture", L"FinishAsync", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.FinishAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AdvancedPhotoCapture_add_AllPhotosCaptured(py::wrapper::Windows::Media::Capture::AdvancedPhotoCapture* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Capture.AdvancedPhotoCapture", L"AllPhotosCaptured"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Capture::AdvancedPhotoCapture, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.AllPhotosCaptured(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AdvancedPhotoCapture_remove_AllPhotosCaptured(py::wrapper::Windows::Media::Capture::AdvancedPhotoCapture* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Capture.AdvancedPhotoCapture", L"AllPhotosCaptured"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.AllPhotosCaptured(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AdvancedPhotoCapture_add_OptionalReferencePhotoCaptured(py::wrapper::Windows::Media::Capture::AdvancedPhotoCapture* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Capture.AdvancedPhotoCapture", L"OptionalReferencePhotoCaptured"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Capture::AdvancedPhotoCapture, winrt::Windows::Media::Capture::OptionalReferencePhotoCapturedEventArgs>>(arg);

            return py::convert(self->obj.OptionalReferencePhotoCaptured(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AdvancedPhotoCapture_remove_OptionalReferencePhotoCaptured(py::wrapper::Windows::Media::Capture::AdvancedPhotoCapture* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Capture.AdvancedPhotoCapture", L"OptionalReferencePhotoCaptured"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.OptionalReferencePhotoCaptured(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AdvancedPhotoCapture(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Capture::AdvancedPhotoCapture>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AdvancedPhotoCapture(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Capture::AdvancedPhotoCapture>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AdvancedPhotoCapture[] = {
        { "capture_async", reinterpret_cast<PyCFunction>(AdvancedPhotoCapture_CaptureAsync), METH_VARARGS, nullptr },
        { "finish_async", reinterpret_cast<PyCFunction>(AdvancedPhotoCapture_FinishAsync), METH_VARARGS, nullptr },
        { "add_all_photos_captured", reinterpret_cast<PyCFunction>(AdvancedPhotoCapture_add_AllPhotosCaptured), METH_O, nullptr },
        { "remove_all_photos_captured", reinterpret_cast<PyCFunction>(AdvancedPhotoCapture_remove_AllPhotosCaptured), METH_O, nullptr },
        { "add_optional_reference_photo_captured", reinterpret_cast<PyCFunction>(AdvancedPhotoCapture_add_OptionalReferencePhotoCaptured), METH_O, nullptr },
        { "remove_optional_reference_photo_captured", reinterpret_cast<PyCFunction>(AdvancedPhotoCapture_remove_OptionalReferencePhotoCaptured), METH_O, nullptr },
        { "_assign_array_", _assign_array_AdvancedPhotoCapture, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AdvancedPhotoCapture), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AdvancedPhotoCapture[] = {
        { }
    };

    static PyType_Slot _type_slots_AdvancedPhotoCapture[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_AdvancedPhotoCapture) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AdvancedPhotoCapture) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AdvancedPhotoCapture) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AdvancedPhotoCapture) },
        { }
    };

    static PyType_Spec type_spec_AdvancedPhotoCapture = {
        "winrt._winrt_windows_media_capture.AdvancedPhotoCapture",
        sizeof(py::wrapper::Windows::Media::Capture::AdvancedPhotoCapture),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AdvancedPhotoCapture};

    // ----- AppBroadcastBackgroundService class --------------------

    static PyObject* _new_AppBroadcastBackgroundService(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Capture::AppBroadcastBackgroundService>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Capture::AppBroadcastBackgroundService>::type_name);
        return nullptr;
    }

    static void _dealloc_AppBroadcastBackgroundService(py::wrapper::Windows::Media::Capture::AppBroadcastBackgroundService* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AppBroadcastBackgroundService_TerminateBroadcast(py::wrapper::Windows::Media::Capture::AppBroadcastBackgroundService* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Capture.AppBroadcastBackgroundService", L"TerminateBroadcast", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Media::Capture::AppBroadcastTerminationReason>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);

                self->obj.TerminateBroadcast(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppBroadcastBackgroundService_get_ViewerCount(py::wrapper::Windows::Media::Capture::AppBroadcastBackgroundService* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastBackgroundService", L"ViewerCount"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ViewerCount());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppBroadcastBackgroundService_put_ViewerCount(py::wrapper::Windows::Media::Capture::AppBroadcastBackgroundService* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastBackgroundService", L"ViewerCount"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.ViewerCount(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppBroadcastBackgroundService_get_StreamInfo(py::wrapper::Windows::Media::Capture::AppBroadcastBackgroundService* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastBackgroundService", L"StreamInfo"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.StreamInfo());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppBroadcastBackgroundService_put_StreamInfo(py::wrapper::Windows::Media::Capture::AppBroadcastBackgroundService* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastBackgroundService", L"StreamInfo"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Media::Capture::AppBroadcastBackgroundServiceStreamInfo>(arg);

            self->obj.StreamInfo(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppBroadcastBackgroundService_get_SignInInfo(py::wrapper::Windows::Media::Capture::AppBroadcastBackgroundService* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastBackgroundService", L"SignInInfo"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SignInInfo());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppBroadcastBackgroundService_put_SignInInfo(py::wrapper::Windows::Media::Capture::AppBroadcastBackgroundService* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastBackgroundService", L"SignInInfo"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Media::Capture::AppBroadcastBackgroundServiceSignInInfo>(arg);

            self->obj.SignInInfo(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppBroadcastBackgroundService_get_PlugInState(py::wrapper::Windows::Media::Capture::AppBroadcastBackgroundService* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastBackgroundService", L"PlugInState"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.PlugInState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppBroadcastBackgroundService_put_PlugInState(py::wrapper::Windows::Media::Capture::AppBroadcastBackgroundService* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastBackgroundService", L"PlugInState"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Media::Capture::AppBroadcastPlugInState>(arg);

            self->obj.PlugInState(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppBroadcastBackgroundService_get_BroadcastTitle(py::wrapper::Windows::Media::Capture::AppBroadcastBackgroundService* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastBackgroundService", L"BroadcastTitle"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.BroadcastTitle());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppBroadcastBackgroundService_put_BroadcastTitle(py::wrapper::Windows::Media::Capture::AppBroadcastBackgroundService* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastBackgroundService", L"BroadcastTitle"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.BroadcastTitle(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppBroadcastBackgroundService_get_AppId(py::wrapper::Windows::Media::Capture::AppBroadcastBackgroundService* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastBackgroundService", L"AppId"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.AppId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBroadcastBackgroundService_get_TitleId(py::wrapper::Windows::Media::Capture::AppBroadcastBackgroundService* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastBackgroundService", L"TitleId"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.TitleId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBroadcastBackgroundService_get_BroadcastLanguage(py::wrapper::Windows::Media::Capture::AppBroadcastBackgroundService* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastBackgroundService", L"BroadcastLanguage"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.BroadcastLanguage());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppBroadcastBackgroundService_put_BroadcastLanguage(py::wrapper::Windows::Media::Capture::AppBroadcastBackgroundService* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastBackgroundService", L"BroadcastLanguage"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.BroadcastLanguage(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppBroadcastBackgroundService_get_BroadcastChannel(py::wrapper::Windows::Media::Capture::AppBroadcastBackgroundService* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastBackgroundService", L"BroadcastChannel"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.BroadcastChannel());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppBroadcastBackgroundService_put_BroadcastChannel(py::wrapper::Windows::Media::Capture::AppBroadcastBackgroundService* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastBackgroundService", L"BroadcastChannel"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.BroadcastChannel(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppBroadcastBackgroundService_add_HeartbeatRequested(py::wrapper::Windows::Media::Capture::AppBroadcastBackgroundService* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Capture.AppBroadcastBackgroundService", L"HeartbeatRequested"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Capture::AppBroadcastBackgroundService, winrt::Windows::Media::Capture::AppBroadcastHeartbeatRequestedEventArgs>>(arg);

            return py::convert(self->obj.HeartbeatRequested(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBroadcastBackgroundService_remove_HeartbeatRequested(py::wrapper::Windows::Media::Capture::AppBroadcastBackgroundService* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Capture.AppBroadcastBackgroundService", L"HeartbeatRequested"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.HeartbeatRequested(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBroadcastBackgroundService_add_BroadcastChannelChanged(py::wrapper::Windows::Media::Capture::AppBroadcastBackgroundService* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Capture.AppBroadcastBackgroundService", L"BroadcastChannelChanged"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Capture::AppBroadcastBackgroundService, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.BroadcastChannelChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBroadcastBackgroundService_remove_BroadcastChannelChanged(py::wrapper::Windows::Media::Capture::AppBroadcastBackgroundService* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Capture.AppBroadcastBackgroundService", L"BroadcastChannelChanged"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.BroadcastChannelChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBroadcastBackgroundService_add_BroadcastLanguageChanged(py::wrapper::Windows::Media::Capture::AppBroadcastBackgroundService* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Capture.AppBroadcastBackgroundService", L"BroadcastLanguageChanged"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Capture::AppBroadcastBackgroundService, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.BroadcastLanguageChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBroadcastBackgroundService_remove_BroadcastLanguageChanged(py::wrapper::Windows::Media::Capture::AppBroadcastBackgroundService* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Capture.AppBroadcastBackgroundService", L"BroadcastLanguageChanged"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.BroadcastLanguageChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBroadcastBackgroundService_add_BroadcastTitleChanged(py::wrapper::Windows::Media::Capture::AppBroadcastBackgroundService* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Capture.AppBroadcastBackgroundService", L"BroadcastTitleChanged"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Capture::AppBroadcastBackgroundService, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.BroadcastTitleChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBroadcastBackgroundService_remove_BroadcastTitleChanged(py::wrapper::Windows::Media::Capture::AppBroadcastBackgroundService* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Capture.AppBroadcastBackgroundService", L"BroadcastTitleChanged"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.BroadcastTitleChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AppBroadcastBackgroundService(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Capture::AppBroadcastBackgroundService>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AppBroadcastBackgroundService(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Capture::AppBroadcastBackgroundService>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AppBroadcastBackgroundService[] = {
        { "terminate_broadcast", reinterpret_cast<PyCFunction>(AppBroadcastBackgroundService_TerminateBroadcast), METH_VARARGS, nullptr },
        { "add_heartbeat_requested", reinterpret_cast<PyCFunction>(AppBroadcastBackgroundService_add_HeartbeatRequested), METH_O, nullptr },
        { "remove_heartbeat_requested", reinterpret_cast<PyCFunction>(AppBroadcastBackgroundService_remove_HeartbeatRequested), METH_O, nullptr },
        { "add_broadcast_channel_changed", reinterpret_cast<PyCFunction>(AppBroadcastBackgroundService_add_BroadcastChannelChanged), METH_O, nullptr },
        { "remove_broadcast_channel_changed", reinterpret_cast<PyCFunction>(AppBroadcastBackgroundService_remove_BroadcastChannelChanged), METH_O, nullptr },
        { "add_broadcast_language_changed", reinterpret_cast<PyCFunction>(AppBroadcastBackgroundService_add_BroadcastLanguageChanged), METH_O, nullptr },
        { "remove_broadcast_language_changed", reinterpret_cast<PyCFunction>(AppBroadcastBackgroundService_remove_BroadcastLanguageChanged), METH_O, nullptr },
        { "add_broadcast_title_changed", reinterpret_cast<PyCFunction>(AppBroadcastBackgroundService_add_BroadcastTitleChanged), METH_O, nullptr },
        { "remove_broadcast_title_changed", reinterpret_cast<PyCFunction>(AppBroadcastBackgroundService_remove_BroadcastTitleChanged), METH_O, nullptr },
        { "_assign_array_", _assign_array_AppBroadcastBackgroundService, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AppBroadcastBackgroundService), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AppBroadcastBackgroundService[] = {
        { "viewer_count", reinterpret_cast<getter>(AppBroadcastBackgroundService_get_ViewerCount), reinterpret_cast<setter>(AppBroadcastBackgroundService_put_ViewerCount), nullptr, nullptr },
        { "stream_info", reinterpret_cast<getter>(AppBroadcastBackgroundService_get_StreamInfo), reinterpret_cast<setter>(AppBroadcastBackgroundService_put_StreamInfo), nullptr, nullptr },
        { "sign_in_info", reinterpret_cast<getter>(AppBroadcastBackgroundService_get_SignInInfo), reinterpret_cast<setter>(AppBroadcastBackgroundService_put_SignInInfo), nullptr, nullptr },
        { "plug_in_state", reinterpret_cast<getter>(AppBroadcastBackgroundService_get_PlugInState), reinterpret_cast<setter>(AppBroadcastBackgroundService_put_PlugInState), nullptr, nullptr },
        { "broadcast_title", reinterpret_cast<getter>(AppBroadcastBackgroundService_get_BroadcastTitle), reinterpret_cast<setter>(AppBroadcastBackgroundService_put_BroadcastTitle), nullptr, nullptr },
        { "app_id", reinterpret_cast<getter>(AppBroadcastBackgroundService_get_AppId), nullptr, nullptr, nullptr },
        { "title_id", reinterpret_cast<getter>(AppBroadcastBackgroundService_get_TitleId), nullptr, nullptr, nullptr },
        { "broadcast_language", reinterpret_cast<getter>(AppBroadcastBackgroundService_get_BroadcastLanguage), reinterpret_cast<setter>(AppBroadcastBackgroundService_put_BroadcastLanguage), nullptr, nullptr },
        { "broadcast_channel", reinterpret_cast<getter>(AppBroadcastBackgroundService_get_BroadcastChannel), reinterpret_cast<setter>(AppBroadcastBackgroundService_put_BroadcastChannel), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AppBroadcastBackgroundService[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_AppBroadcastBackgroundService) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AppBroadcastBackgroundService) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AppBroadcastBackgroundService) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AppBroadcastBackgroundService) },
        { }
    };

    static PyType_Spec type_spec_AppBroadcastBackgroundService = {
        "winrt._winrt_windows_media_capture.AppBroadcastBackgroundService",
        sizeof(py::wrapper::Windows::Media::Capture::AppBroadcastBackgroundService),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AppBroadcastBackgroundService};

    // ----- AppBroadcastBackgroundServiceSignInInfo class --------------------

    static PyObject* _new_AppBroadcastBackgroundServiceSignInInfo(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Capture::AppBroadcastBackgroundServiceSignInInfo>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Capture::AppBroadcastBackgroundServiceSignInInfo>::type_name);
        return nullptr;
    }

    static void _dealloc_AppBroadcastBackgroundServiceSignInInfo(py::wrapper::Windows::Media::Capture::AppBroadcastBackgroundServiceSignInInfo* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AppBroadcastBackgroundServiceSignInInfo_get_UserName(py::wrapper::Windows::Media::Capture::AppBroadcastBackgroundServiceSignInInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastBackgroundServiceSignInInfo", L"UserName"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.UserName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppBroadcastBackgroundServiceSignInInfo_put_UserName(py::wrapper::Windows::Media::Capture::AppBroadcastBackgroundServiceSignInInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastBackgroundServiceSignInInfo", L"UserName"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.UserName(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppBroadcastBackgroundServiceSignInInfo_get_OAuthRequestUri(py::wrapper::Windows::Media::Capture::AppBroadcastBackgroundServiceSignInInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastBackgroundServiceSignInInfo", L"OAuthRequestUri"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.OAuthRequestUri());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppBroadcastBackgroundServiceSignInInfo_put_OAuthRequestUri(py::wrapper::Windows::Media::Capture::AppBroadcastBackgroundServiceSignInInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastBackgroundServiceSignInInfo", L"OAuthRequestUri"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(arg);

            self->obj.OAuthRequestUri(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppBroadcastBackgroundServiceSignInInfo_get_OAuthCallbackUri(py::wrapper::Windows::Media::Capture::AppBroadcastBackgroundServiceSignInInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastBackgroundServiceSignInInfo", L"OAuthCallbackUri"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.OAuthCallbackUri());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppBroadcastBackgroundServiceSignInInfo_put_OAuthCallbackUri(py::wrapper::Windows::Media::Capture::AppBroadcastBackgroundServiceSignInInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastBackgroundServiceSignInInfo", L"OAuthCallbackUri"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(arg);

            self->obj.OAuthCallbackUri(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppBroadcastBackgroundServiceSignInInfo_get_AuthenticationResult(py::wrapper::Windows::Media::Capture::AppBroadcastBackgroundServiceSignInInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastBackgroundServiceSignInInfo", L"AuthenticationResult"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.AuthenticationResult());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBroadcastBackgroundServiceSignInInfo_get_SignInState(py::wrapper::Windows::Media::Capture::AppBroadcastBackgroundServiceSignInInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastBackgroundServiceSignInInfo", L"SignInState"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SignInState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBroadcastBackgroundServiceSignInInfo_add_SignInStateChanged(py::wrapper::Windows::Media::Capture::AppBroadcastBackgroundServiceSignInInfo* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Capture.AppBroadcastBackgroundServiceSignInInfo", L"SignInStateChanged"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Capture::AppBroadcastBackgroundServiceSignInInfo, winrt::Windows::Media::Capture::AppBroadcastSignInStateChangedEventArgs>>(arg);

            return py::convert(self->obj.SignInStateChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBroadcastBackgroundServiceSignInInfo_remove_SignInStateChanged(py::wrapper::Windows::Media::Capture::AppBroadcastBackgroundServiceSignInInfo* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Capture.AppBroadcastBackgroundServiceSignInInfo", L"SignInStateChanged"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.SignInStateChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBroadcastBackgroundServiceSignInInfo_add_UserNameChanged(py::wrapper::Windows::Media::Capture::AppBroadcastBackgroundServiceSignInInfo* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Capture.AppBroadcastBackgroundServiceSignInInfo", L"UserNameChanged"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Capture::AppBroadcastBackgroundServiceSignInInfo, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.UserNameChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBroadcastBackgroundServiceSignInInfo_remove_UserNameChanged(py::wrapper::Windows::Media::Capture::AppBroadcastBackgroundServiceSignInInfo* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Capture.AppBroadcastBackgroundServiceSignInInfo", L"UserNameChanged"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.UserNameChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AppBroadcastBackgroundServiceSignInInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Capture::AppBroadcastBackgroundServiceSignInInfo>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AppBroadcastBackgroundServiceSignInInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Capture::AppBroadcastBackgroundServiceSignInInfo>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AppBroadcastBackgroundServiceSignInInfo[] = {
        { "add_sign_in_state_changed", reinterpret_cast<PyCFunction>(AppBroadcastBackgroundServiceSignInInfo_add_SignInStateChanged), METH_O, nullptr },
        { "remove_sign_in_state_changed", reinterpret_cast<PyCFunction>(AppBroadcastBackgroundServiceSignInInfo_remove_SignInStateChanged), METH_O, nullptr },
        { "add_user_name_changed", reinterpret_cast<PyCFunction>(AppBroadcastBackgroundServiceSignInInfo_add_UserNameChanged), METH_O, nullptr },
        { "remove_user_name_changed", reinterpret_cast<PyCFunction>(AppBroadcastBackgroundServiceSignInInfo_remove_UserNameChanged), METH_O, nullptr },
        { "_assign_array_", _assign_array_AppBroadcastBackgroundServiceSignInInfo, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AppBroadcastBackgroundServiceSignInInfo), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AppBroadcastBackgroundServiceSignInInfo[] = {
        { "user_name", reinterpret_cast<getter>(AppBroadcastBackgroundServiceSignInInfo_get_UserName), reinterpret_cast<setter>(AppBroadcastBackgroundServiceSignInInfo_put_UserName), nullptr, nullptr },
        { "o_auth_request_uri", reinterpret_cast<getter>(AppBroadcastBackgroundServiceSignInInfo_get_OAuthRequestUri), reinterpret_cast<setter>(AppBroadcastBackgroundServiceSignInInfo_put_OAuthRequestUri), nullptr, nullptr },
        { "o_auth_callback_uri", reinterpret_cast<getter>(AppBroadcastBackgroundServiceSignInInfo_get_OAuthCallbackUri), reinterpret_cast<setter>(AppBroadcastBackgroundServiceSignInInfo_put_OAuthCallbackUri), nullptr, nullptr },
        { "authentication_result", reinterpret_cast<getter>(AppBroadcastBackgroundServiceSignInInfo_get_AuthenticationResult), nullptr, nullptr, nullptr },
        { "sign_in_state", reinterpret_cast<getter>(AppBroadcastBackgroundServiceSignInInfo_get_SignInState), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AppBroadcastBackgroundServiceSignInInfo[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_AppBroadcastBackgroundServiceSignInInfo) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AppBroadcastBackgroundServiceSignInInfo) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AppBroadcastBackgroundServiceSignInInfo) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AppBroadcastBackgroundServiceSignInInfo) },
        { }
    };

    static PyType_Spec type_spec_AppBroadcastBackgroundServiceSignInInfo = {
        "winrt._winrt_windows_media_capture.AppBroadcastBackgroundServiceSignInInfo",
        sizeof(py::wrapper::Windows::Media::Capture::AppBroadcastBackgroundServiceSignInInfo),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AppBroadcastBackgroundServiceSignInInfo};

    // ----- AppBroadcastBackgroundServiceStreamInfo class --------------------

    static PyObject* _new_AppBroadcastBackgroundServiceStreamInfo(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Capture::AppBroadcastBackgroundServiceStreamInfo>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Capture::AppBroadcastBackgroundServiceStreamInfo>::type_name);
        return nullptr;
    }

    static void _dealloc_AppBroadcastBackgroundServiceStreamInfo(py::wrapper::Windows::Media::Capture::AppBroadcastBackgroundServiceStreamInfo* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AppBroadcastBackgroundServiceStreamInfo_ReportProblemWithStream(py::wrapper::Windows::Media::Capture::AppBroadcastBackgroundServiceStreamInfo* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Capture.AppBroadcastBackgroundServiceStreamInfo", L"ReportProblemWithStream", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.ReportProblemWithStream();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppBroadcastBackgroundServiceStreamInfo_get_DesiredVideoEncodingBitrate(py::wrapper::Windows::Media::Capture::AppBroadcastBackgroundServiceStreamInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastBackgroundServiceStreamInfo", L"DesiredVideoEncodingBitrate"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DesiredVideoEncodingBitrate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppBroadcastBackgroundServiceStreamInfo_put_DesiredVideoEncodingBitrate(py::wrapper::Windows::Media::Capture::AppBroadcastBackgroundServiceStreamInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastBackgroundServiceStreamInfo", L"DesiredVideoEncodingBitrate"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<uint64_t>(arg);

            self->obj.DesiredVideoEncodingBitrate(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppBroadcastBackgroundServiceStreamInfo_get_BandwidthTestBitrate(py::wrapper::Windows::Media::Capture::AppBroadcastBackgroundServiceStreamInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastBackgroundServiceStreamInfo", L"BandwidthTestBitrate"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.BandwidthTestBitrate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppBroadcastBackgroundServiceStreamInfo_put_BandwidthTestBitrate(py::wrapper::Windows::Media::Capture::AppBroadcastBackgroundServiceStreamInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastBackgroundServiceStreamInfo", L"BandwidthTestBitrate"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<uint64_t>(arg);

            self->obj.BandwidthTestBitrate(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppBroadcastBackgroundServiceStreamInfo_get_AudioCodec(py::wrapper::Windows::Media::Capture::AppBroadcastBackgroundServiceStreamInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastBackgroundServiceStreamInfo", L"AudioCodec"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.AudioCodec());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppBroadcastBackgroundServiceStreamInfo_put_AudioCodec(py::wrapper::Windows::Media::Capture::AppBroadcastBackgroundServiceStreamInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastBackgroundServiceStreamInfo", L"AudioCodec"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.AudioCodec(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppBroadcastBackgroundServiceStreamInfo_get_BroadcastStreamReader(py::wrapper::Windows::Media::Capture::AppBroadcastBackgroundServiceStreamInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastBackgroundServiceStreamInfo", L"BroadcastStreamReader"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.BroadcastStreamReader());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBroadcastBackgroundServiceStreamInfo_get_StreamState(py::wrapper::Windows::Media::Capture::AppBroadcastBackgroundServiceStreamInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastBackgroundServiceStreamInfo", L"StreamState"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.StreamState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBroadcastBackgroundServiceStreamInfo_add_StreamStateChanged(py::wrapper::Windows::Media::Capture::AppBroadcastBackgroundServiceStreamInfo* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Capture.AppBroadcastBackgroundServiceStreamInfo", L"StreamStateChanged"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Capture::AppBroadcastBackgroundServiceStreamInfo, winrt::Windows::Media::Capture::AppBroadcastStreamStateChangedEventArgs>>(arg);

            return py::convert(self->obj.StreamStateChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBroadcastBackgroundServiceStreamInfo_remove_StreamStateChanged(py::wrapper::Windows::Media::Capture::AppBroadcastBackgroundServiceStreamInfo* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Capture.AppBroadcastBackgroundServiceStreamInfo", L"StreamStateChanged"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.StreamStateChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBroadcastBackgroundServiceStreamInfo_add_VideoEncodingBitrateChanged(py::wrapper::Windows::Media::Capture::AppBroadcastBackgroundServiceStreamInfo* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Capture.AppBroadcastBackgroundServiceStreamInfo", L"VideoEncodingBitrateChanged"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Capture::AppBroadcastBackgroundServiceStreamInfo, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.VideoEncodingBitrateChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBroadcastBackgroundServiceStreamInfo_remove_VideoEncodingBitrateChanged(py::wrapper::Windows::Media::Capture::AppBroadcastBackgroundServiceStreamInfo* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Capture.AppBroadcastBackgroundServiceStreamInfo", L"VideoEncodingBitrateChanged"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.VideoEncodingBitrateChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBroadcastBackgroundServiceStreamInfo_add_VideoEncodingResolutionChanged(py::wrapper::Windows::Media::Capture::AppBroadcastBackgroundServiceStreamInfo* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Capture.AppBroadcastBackgroundServiceStreamInfo", L"VideoEncodingResolutionChanged"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Capture::AppBroadcastBackgroundServiceStreamInfo, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.VideoEncodingResolutionChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBroadcastBackgroundServiceStreamInfo_remove_VideoEncodingResolutionChanged(py::wrapper::Windows::Media::Capture::AppBroadcastBackgroundServiceStreamInfo* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Capture.AppBroadcastBackgroundServiceStreamInfo", L"VideoEncodingResolutionChanged"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.VideoEncodingResolutionChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AppBroadcastBackgroundServiceStreamInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Capture::AppBroadcastBackgroundServiceStreamInfo>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AppBroadcastBackgroundServiceStreamInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Capture::AppBroadcastBackgroundServiceStreamInfo>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AppBroadcastBackgroundServiceStreamInfo[] = {
        { "report_problem_with_stream", reinterpret_cast<PyCFunction>(AppBroadcastBackgroundServiceStreamInfo_ReportProblemWithStream), METH_VARARGS, nullptr },
        { "add_stream_state_changed", reinterpret_cast<PyCFunction>(AppBroadcastBackgroundServiceStreamInfo_add_StreamStateChanged), METH_O, nullptr },
        { "remove_stream_state_changed", reinterpret_cast<PyCFunction>(AppBroadcastBackgroundServiceStreamInfo_remove_StreamStateChanged), METH_O, nullptr },
        { "add_video_encoding_bitrate_changed", reinterpret_cast<PyCFunction>(AppBroadcastBackgroundServiceStreamInfo_add_VideoEncodingBitrateChanged), METH_O, nullptr },
        { "remove_video_encoding_bitrate_changed", reinterpret_cast<PyCFunction>(AppBroadcastBackgroundServiceStreamInfo_remove_VideoEncodingBitrateChanged), METH_O, nullptr },
        { "add_video_encoding_resolution_changed", reinterpret_cast<PyCFunction>(AppBroadcastBackgroundServiceStreamInfo_add_VideoEncodingResolutionChanged), METH_O, nullptr },
        { "remove_video_encoding_resolution_changed", reinterpret_cast<PyCFunction>(AppBroadcastBackgroundServiceStreamInfo_remove_VideoEncodingResolutionChanged), METH_O, nullptr },
        { "_assign_array_", _assign_array_AppBroadcastBackgroundServiceStreamInfo, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AppBroadcastBackgroundServiceStreamInfo), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AppBroadcastBackgroundServiceStreamInfo[] = {
        { "desired_video_encoding_bitrate", reinterpret_cast<getter>(AppBroadcastBackgroundServiceStreamInfo_get_DesiredVideoEncodingBitrate), reinterpret_cast<setter>(AppBroadcastBackgroundServiceStreamInfo_put_DesiredVideoEncodingBitrate), nullptr, nullptr },
        { "bandwidth_test_bitrate", reinterpret_cast<getter>(AppBroadcastBackgroundServiceStreamInfo_get_BandwidthTestBitrate), reinterpret_cast<setter>(AppBroadcastBackgroundServiceStreamInfo_put_BandwidthTestBitrate), nullptr, nullptr },
        { "audio_codec", reinterpret_cast<getter>(AppBroadcastBackgroundServiceStreamInfo_get_AudioCodec), reinterpret_cast<setter>(AppBroadcastBackgroundServiceStreamInfo_put_AudioCodec), nullptr, nullptr },
        { "broadcast_stream_reader", reinterpret_cast<getter>(AppBroadcastBackgroundServiceStreamInfo_get_BroadcastStreamReader), nullptr, nullptr, nullptr },
        { "stream_state", reinterpret_cast<getter>(AppBroadcastBackgroundServiceStreamInfo_get_StreamState), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AppBroadcastBackgroundServiceStreamInfo[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_AppBroadcastBackgroundServiceStreamInfo) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AppBroadcastBackgroundServiceStreamInfo) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AppBroadcastBackgroundServiceStreamInfo) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AppBroadcastBackgroundServiceStreamInfo) },
        { }
    };

    static PyType_Spec type_spec_AppBroadcastBackgroundServiceStreamInfo = {
        "winrt._winrt_windows_media_capture.AppBroadcastBackgroundServiceStreamInfo",
        sizeof(py::wrapper::Windows::Media::Capture::AppBroadcastBackgroundServiceStreamInfo),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AppBroadcastBackgroundServiceStreamInfo};

    // ----- AppBroadcastCameraCaptureStateChangedEventArgs class --------------------

    static PyObject* _new_AppBroadcastCameraCaptureStateChangedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Capture::AppBroadcastCameraCaptureStateChangedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Capture::AppBroadcastCameraCaptureStateChangedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_AppBroadcastCameraCaptureStateChangedEventArgs(py::wrapper::Windows::Media::Capture::AppBroadcastCameraCaptureStateChangedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AppBroadcastCameraCaptureStateChangedEventArgs_get_ErrorCode(py::wrapper::Windows::Media::Capture::AppBroadcastCameraCaptureStateChangedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastCameraCaptureStateChangedEventArgs", L"ErrorCode"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ErrorCode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBroadcastCameraCaptureStateChangedEventArgs_get_State(py::wrapper::Windows::Media::Capture::AppBroadcastCameraCaptureStateChangedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastCameraCaptureStateChangedEventArgs", L"State"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.State());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AppBroadcastCameraCaptureStateChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Capture::AppBroadcastCameraCaptureStateChangedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AppBroadcastCameraCaptureStateChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Capture::AppBroadcastCameraCaptureStateChangedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AppBroadcastCameraCaptureStateChangedEventArgs[] = {
        { "_assign_array_", _assign_array_AppBroadcastCameraCaptureStateChangedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AppBroadcastCameraCaptureStateChangedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AppBroadcastCameraCaptureStateChangedEventArgs[] = {
        { "error_code", reinterpret_cast<getter>(AppBroadcastCameraCaptureStateChangedEventArgs_get_ErrorCode), nullptr, nullptr, nullptr },
        { "state", reinterpret_cast<getter>(AppBroadcastCameraCaptureStateChangedEventArgs_get_State), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AppBroadcastCameraCaptureStateChangedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_AppBroadcastCameraCaptureStateChangedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AppBroadcastCameraCaptureStateChangedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AppBroadcastCameraCaptureStateChangedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AppBroadcastCameraCaptureStateChangedEventArgs) },
        { }
    };

    static PyType_Spec type_spec_AppBroadcastCameraCaptureStateChangedEventArgs = {
        "winrt._winrt_windows_media_capture.AppBroadcastCameraCaptureStateChangedEventArgs",
        sizeof(py::wrapper::Windows::Media::Capture::AppBroadcastCameraCaptureStateChangedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AppBroadcastCameraCaptureStateChangedEventArgs};

    // ----- AppBroadcastGlobalSettings class --------------------

    static PyObject* _new_AppBroadcastGlobalSettings(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Capture::AppBroadcastGlobalSettings>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Capture::AppBroadcastGlobalSettings>::type_name);
        return nullptr;
    }

    static void _dealloc_AppBroadcastGlobalSettings(py::wrapper::Windows::Media::Capture::AppBroadcastGlobalSettings* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AppBroadcastGlobalSettings_get_SystemAudioGain(py::wrapper::Windows::Media::Capture::AppBroadcastGlobalSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastGlobalSettings", L"SystemAudioGain"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SystemAudioGain());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppBroadcastGlobalSettings_put_SystemAudioGain(py::wrapper::Windows::Media::Capture::AppBroadcastGlobalSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastGlobalSettings", L"SystemAudioGain"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<double>(arg);

            self->obj.SystemAudioGain(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppBroadcastGlobalSettings_get_SelectedCameraId(py::wrapper::Windows::Media::Capture::AppBroadcastGlobalSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastGlobalSettings", L"SelectedCameraId"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SelectedCameraId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppBroadcastGlobalSettings_put_SelectedCameraId(py::wrapper::Windows::Media::Capture::AppBroadcastGlobalSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastGlobalSettings", L"SelectedCameraId"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.SelectedCameraId(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppBroadcastGlobalSettings_get_MicrophoneGain(py::wrapper::Windows::Media::Capture::AppBroadcastGlobalSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastGlobalSettings", L"MicrophoneGain"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.MicrophoneGain());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppBroadcastGlobalSettings_put_MicrophoneGain(py::wrapper::Windows::Media::Capture::AppBroadcastGlobalSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastGlobalSettings", L"MicrophoneGain"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<double>(arg);

            self->obj.MicrophoneGain(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppBroadcastGlobalSettings_get_IsMicrophoneCaptureEnabledByDefault(py::wrapper::Windows::Media::Capture::AppBroadcastGlobalSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastGlobalSettings", L"IsMicrophoneCaptureEnabledByDefault"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsMicrophoneCaptureEnabledByDefault());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppBroadcastGlobalSettings_put_IsMicrophoneCaptureEnabledByDefault(py::wrapper::Windows::Media::Capture::AppBroadcastGlobalSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastGlobalSettings", L"IsMicrophoneCaptureEnabledByDefault"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsMicrophoneCaptureEnabledByDefault(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppBroadcastGlobalSettings_get_IsEchoCancellationEnabled(py::wrapper::Windows::Media::Capture::AppBroadcastGlobalSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastGlobalSettings", L"IsEchoCancellationEnabled"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsEchoCancellationEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppBroadcastGlobalSettings_put_IsEchoCancellationEnabled(py::wrapper::Windows::Media::Capture::AppBroadcastGlobalSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastGlobalSettings", L"IsEchoCancellationEnabled"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsEchoCancellationEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppBroadcastGlobalSettings_get_IsCursorImageCaptureEnabled(py::wrapper::Windows::Media::Capture::AppBroadcastGlobalSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastGlobalSettings", L"IsCursorImageCaptureEnabled"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsCursorImageCaptureEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppBroadcastGlobalSettings_put_IsCursorImageCaptureEnabled(py::wrapper::Windows::Media::Capture::AppBroadcastGlobalSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastGlobalSettings", L"IsCursorImageCaptureEnabled"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsCursorImageCaptureEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppBroadcastGlobalSettings_get_IsCameraCaptureEnabledByDefault(py::wrapper::Windows::Media::Capture::AppBroadcastGlobalSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastGlobalSettings", L"IsCameraCaptureEnabledByDefault"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsCameraCaptureEnabledByDefault());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppBroadcastGlobalSettings_put_IsCameraCaptureEnabledByDefault(py::wrapper::Windows::Media::Capture::AppBroadcastGlobalSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastGlobalSettings", L"IsCameraCaptureEnabledByDefault"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsCameraCaptureEnabledByDefault(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppBroadcastGlobalSettings_get_IsAudioCaptureEnabled(py::wrapper::Windows::Media::Capture::AppBroadcastGlobalSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastGlobalSettings", L"IsAudioCaptureEnabled"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsAudioCaptureEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppBroadcastGlobalSettings_put_IsAudioCaptureEnabled(py::wrapper::Windows::Media::Capture::AppBroadcastGlobalSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastGlobalSettings", L"IsAudioCaptureEnabled"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsAudioCaptureEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppBroadcastGlobalSettings_get_CameraOverlaySize(py::wrapper::Windows::Media::Capture::AppBroadcastGlobalSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastGlobalSettings", L"CameraOverlaySize"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CameraOverlaySize());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppBroadcastGlobalSettings_put_CameraOverlaySize(py::wrapper::Windows::Media::Capture::AppBroadcastGlobalSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastGlobalSettings", L"CameraOverlaySize"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Media::Capture::AppBroadcastCameraOverlaySize>(arg);

            self->obj.CameraOverlaySize(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppBroadcastGlobalSettings_get_CameraOverlayLocation(py::wrapper::Windows::Media::Capture::AppBroadcastGlobalSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastGlobalSettings", L"CameraOverlayLocation"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CameraOverlayLocation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppBroadcastGlobalSettings_put_CameraOverlayLocation(py::wrapper::Windows::Media::Capture::AppBroadcastGlobalSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastGlobalSettings", L"CameraOverlayLocation"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Media::Capture::AppBroadcastCameraOverlayLocation>(arg);

            self->obj.CameraOverlayLocation(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppBroadcastGlobalSettings_get_HasHardwareEncoder(py::wrapper::Windows::Media::Capture::AppBroadcastGlobalSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastGlobalSettings", L"HasHardwareEncoder"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.HasHardwareEncoder());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBroadcastGlobalSettings_get_IsBroadcastEnabled(py::wrapper::Windows::Media::Capture::AppBroadcastGlobalSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastGlobalSettings", L"IsBroadcastEnabled"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsBroadcastEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBroadcastGlobalSettings_get_IsDisabledByPolicy(py::wrapper::Windows::Media::Capture::AppBroadcastGlobalSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastGlobalSettings", L"IsDisabledByPolicy"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsDisabledByPolicy());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBroadcastGlobalSettings_get_IsGpuConstrained(py::wrapper::Windows::Media::Capture::AppBroadcastGlobalSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastGlobalSettings", L"IsGpuConstrained"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsGpuConstrained());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AppBroadcastGlobalSettings(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Capture::AppBroadcastGlobalSettings>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AppBroadcastGlobalSettings(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Capture::AppBroadcastGlobalSettings>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AppBroadcastGlobalSettings[] = {
        { "_assign_array_", _assign_array_AppBroadcastGlobalSettings, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AppBroadcastGlobalSettings), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AppBroadcastGlobalSettings[] = {
        { "system_audio_gain", reinterpret_cast<getter>(AppBroadcastGlobalSettings_get_SystemAudioGain), reinterpret_cast<setter>(AppBroadcastGlobalSettings_put_SystemAudioGain), nullptr, nullptr },
        { "selected_camera_id", reinterpret_cast<getter>(AppBroadcastGlobalSettings_get_SelectedCameraId), reinterpret_cast<setter>(AppBroadcastGlobalSettings_put_SelectedCameraId), nullptr, nullptr },
        { "microphone_gain", reinterpret_cast<getter>(AppBroadcastGlobalSettings_get_MicrophoneGain), reinterpret_cast<setter>(AppBroadcastGlobalSettings_put_MicrophoneGain), nullptr, nullptr },
        { "is_microphone_capture_enabled_by_default", reinterpret_cast<getter>(AppBroadcastGlobalSettings_get_IsMicrophoneCaptureEnabledByDefault), reinterpret_cast<setter>(AppBroadcastGlobalSettings_put_IsMicrophoneCaptureEnabledByDefault), nullptr, nullptr },
        { "is_echo_cancellation_enabled", reinterpret_cast<getter>(AppBroadcastGlobalSettings_get_IsEchoCancellationEnabled), reinterpret_cast<setter>(AppBroadcastGlobalSettings_put_IsEchoCancellationEnabled), nullptr, nullptr },
        { "is_cursor_image_capture_enabled", reinterpret_cast<getter>(AppBroadcastGlobalSettings_get_IsCursorImageCaptureEnabled), reinterpret_cast<setter>(AppBroadcastGlobalSettings_put_IsCursorImageCaptureEnabled), nullptr, nullptr },
        { "is_camera_capture_enabled_by_default", reinterpret_cast<getter>(AppBroadcastGlobalSettings_get_IsCameraCaptureEnabledByDefault), reinterpret_cast<setter>(AppBroadcastGlobalSettings_put_IsCameraCaptureEnabledByDefault), nullptr, nullptr },
        { "is_audio_capture_enabled", reinterpret_cast<getter>(AppBroadcastGlobalSettings_get_IsAudioCaptureEnabled), reinterpret_cast<setter>(AppBroadcastGlobalSettings_put_IsAudioCaptureEnabled), nullptr, nullptr },
        { "camera_overlay_size", reinterpret_cast<getter>(AppBroadcastGlobalSettings_get_CameraOverlaySize), reinterpret_cast<setter>(AppBroadcastGlobalSettings_put_CameraOverlaySize), nullptr, nullptr },
        { "camera_overlay_location", reinterpret_cast<getter>(AppBroadcastGlobalSettings_get_CameraOverlayLocation), reinterpret_cast<setter>(AppBroadcastGlobalSettings_put_CameraOverlayLocation), nullptr, nullptr },
        { "has_hardware_encoder", reinterpret_cast<getter>(AppBroadcastGlobalSettings_get_HasHardwareEncoder), nullptr, nullptr, nullptr },
        { "is_broadcast_enabled", reinterpret_cast<getter>(AppBroadcastGlobalSettings_get_IsBroadcastEnabled), nullptr, nullptr, nullptr },
        { "is_disabled_by_policy", reinterpret_cast<getter>(AppBroadcastGlobalSettings_get_IsDisabledByPolicy), nullptr, nullptr, nullptr },
        { "is_gpu_constrained", reinterpret_cast<getter>(AppBroadcastGlobalSettings_get_IsGpuConstrained), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AppBroadcastGlobalSettings[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_AppBroadcastGlobalSettings) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AppBroadcastGlobalSettings) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AppBroadcastGlobalSettings) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AppBroadcastGlobalSettings) },
        { }
    };

    static PyType_Spec type_spec_AppBroadcastGlobalSettings = {
        "winrt._winrt_windows_media_capture.AppBroadcastGlobalSettings",
        sizeof(py::wrapper::Windows::Media::Capture::AppBroadcastGlobalSettings),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AppBroadcastGlobalSettings};

    // ----- AppBroadcastHeartbeatRequestedEventArgs class --------------------

    static PyObject* _new_AppBroadcastHeartbeatRequestedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Capture::AppBroadcastHeartbeatRequestedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Capture::AppBroadcastHeartbeatRequestedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_AppBroadcastHeartbeatRequestedEventArgs(py::wrapper::Windows::Media::Capture::AppBroadcastHeartbeatRequestedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AppBroadcastHeartbeatRequestedEventArgs_get_Handled(py::wrapper::Windows::Media::Capture::AppBroadcastHeartbeatRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastHeartbeatRequestedEventArgs", L"Handled"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Handled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppBroadcastHeartbeatRequestedEventArgs_put_Handled(py::wrapper::Windows::Media::Capture::AppBroadcastHeartbeatRequestedEventArgs* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastHeartbeatRequestedEventArgs", L"Handled"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.Handled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_AppBroadcastHeartbeatRequestedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Capture::AppBroadcastHeartbeatRequestedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AppBroadcastHeartbeatRequestedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Capture::AppBroadcastHeartbeatRequestedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AppBroadcastHeartbeatRequestedEventArgs[] = {
        { "_assign_array_", _assign_array_AppBroadcastHeartbeatRequestedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AppBroadcastHeartbeatRequestedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AppBroadcastHeartbeatRequestedEventArgs[] = {
        { "handled", reinterpret_cast<getter>(AppBroadcastHeartbeatRequestedEventArgs_get_Handled), reinterpret_cast<setter>(AppBroadcastHeartbeatRequestedEventArgs_put_Handled), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AppBroadcastHeartbeatRequestedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_AppBroadcastHeartbeatRequestedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AppBroadcastHeartbeatRequestedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AppBroadcastHeartbeatRequestedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AppBroadcastHeartbeatRequestedEventArgs) },
        { }
    };

    static PyType_Spec type_spec_AppBroadcastHeartbeatRequestedEventArgs = {
        "winrt._winrt_windows_media_capture.AppBroadcastHeartbeatRequestedEventArgs",
        sizeof(py::wrapper::Windows::Media::Capture::AppBroadcastHeartbeatRequestedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AppBroadcastHeartbeatRequestedEventArgs};

    // ----- AppBroadcastManager class --------------------

    static PyObject* _new_AppBroadcastManager(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Capture::AppBroadcastManager>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Capture::AppBroadcastManager>::type_name);
        return nullptr;
    }

    static PyObject* AppBroadcastManager_ApplyGlobalSettings(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Capture.AppBroadcastManager", L"ApplyGlobalSettings", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Media::Capture::AppBroadcastGlobalSettings>(args, 0);

                winrt::Windows::Media::Capture::AppBroadcastManager::ApplyGlobalSettings(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppBroadcastManager_ApplyProviderSettings(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Capture.AppBroadcastManager", L"ApplyProviderSettings", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Media::Capture::AppBroadcastProviderSettings>(args, 0);

                winrt::Windows::Media::Capture::AppBroadcastManager::ApplyProviderSettings(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppBroadcastManager_GetGlobalSettings(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Capture.AppBroadcastManager", L"GetGlobalSettings", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(winrt::Windows::Media::Capture::AppBroadcastManager::GetGlobalSettings());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppBroadcastManager_GetProviderSettings(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Capture.AppBroadcastManager", L"GetProviderSettings", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(winrt::Windows::Media::Capture::AppBroadcastManager::GetProviderSettings());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyMethodDef _methods_AppBroadcastManager[] = {
        { }
    };

    static PyGetSetDef _getset_AppBroadcastManager[] = {
        { }
    };

    static PyType_Slot _type_slots_AppBroadcastManager[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_AppBroadcastManager) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AppBroadcastManager) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AppBroadcastManager) },
        { }
    };

    static PyType_Spec type_spec_AppBroadcastManager = {
        "winrt._winrt_windows_media_capture.AppBroadcastManager",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AppBroadcastManager};

    static PyGetSetDef getset_AppBroadcastManager_Static[] = {
        { }
    };

    static PyMethodDef methods_AppBroadcastManager_Static[] = {
        { "apply_global_settings", reinterpret_cast<PyCFunction>(AppBroadcastManager_ApplyGlobalSettings), METH_VARARGS, nullptr },
        { "apply_provider_settings", reinterpret_cast<PyCFunction>(AppBroadcastManager_ApplyProviderSettings), METH_VARARGS, nullptr },
        { "get_global_settings", reinterpret_cast<PyCFunction>(AppBroadcastManager_GetGlobalSettings), METH_VARARGS, nullptr },
        { "get_provider_settings", reinterpret_cast<PyCFunction>(AppBroadcastManager_GetProviderSettings), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_AppBroadcastManager_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_AppBroadcastManager_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_AppBroadcastManager_Static) },
        { }
    };

    static PyType_Spec type_spec_AppBroadcastManager_Static =
    {
        "winrt._winrt_windows_media_capture.AppBroadcastManager_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_AppBroadcastManager_Static
    };

    // ----- AppBroadcastMicrophoneCaptureStateChangedEventArgs class --------------------

    static PyObject* _new_AppBroadcastMicrophoneCaptureStateChangedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Capture::AppBroadcastMicrophoneCaptureStateChangedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Capture::AppBroadcastMicrophoneCaptureStateChangedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_AppBroadcastMicrophoneCaptureStateChangedEventArgs(py::wrapper::Windows::Media::Capture::AppBroadcastMicrophoneCaptureStateChangedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AppBroadcastMicrophoneCaptureStateChangedEventArgs_get_ErrorCode(py::wrapper::Windows::Media::Capture::AppBroadcastMicrophoneCaptureStateChangedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastMicrophoneCaptureStateChangedEventArgs", L"ErrorCode"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ErrorCode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBroadcastMicrophoneCaptureStateChangedEventArgs_get_State(py::wrapper::Windows::Media::Capture::AppBroadcastMicrophoneCaptureStateChangedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastMicrophoneCaptureStateChangedEventArgs", L"State"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.State());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AppBroadcastMicrophoneCaptureStateChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Capture::AppBroadcastMicrophoneCaptureStateChangedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AppBroadcastMicrophoneCaptureStateChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Capture::AppBroadcastMicrophoneCaptureStateChangedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AppBroadcastMicrophoneCaptureStateChangedEventArgs[] = {
        { "_assign_array_", _assign_array_AppBroadcastMicrophoneCaptureStateChangedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AppBroadcastMicrophoneCaptureStateChangedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AppBroadcastMicrophoneCaptureStateChangedEventArgs[] = {
        { "error_code", reinterpret_cast<getter>(AppBroadcastMicrophoneCaptureStateChangedEventArgs_get_ErrorCode), nullptr, nullptr, nullptr },
        { "state", reinterpret_cast<getter>(AppBroadcastMicrophoneCaptureStateChangedEventArgs_get_State), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AppBroadcastMicrophoneCaptureStateChangedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_AppBroadcastMicrophoneCaptureStateChangedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AppBroadcastMicrophoneCaptureStateChangedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AppBroadcastMicrophoneCaptureStateChangedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AppBroadcastMicrophoneCaptureStateChangedEventArgs) },
        { }
    };

    static PyType_Spec type_spec_AppBroadcastMicrophoneCaptureStateChangedEventArgs = {
        "winrt._winrt_windows_media_capture.AppBroadcastMicrophoneCaptureStateChangedEventArgs",
        sizeof(py::wrapper::Windows::Media::Capture::AppBroadcastMicrophoneCaptureStateChangedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AppBroadcastMicrophoneCaptureStateChangedEventArgs};

    // ----- AppBroadcastPlugIn class --------------------

    static PyObject* _new_AppBroadcastPlugIn(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Capture::AppBroadcastPlugIn>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Capture::AppBroadcastPlugIn>::type_name);
        return nullptr;
    }

    static void _dealloc_AppBroadcastPlugIn(py::wrapper::Windows::Media::Capture::AppBroadcastPlugIn* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AppBroadcastPlugIn_get_AppId(py::wrapper::Windows::Media::Capture::AppBroadcastPlugIn* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastPlugIn", L"AppId"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.AppId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBroadcastPlugIn_get_DisplayName(py::wrapper::Windows::Media::Capture::AppBroadcastPlugIn* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastPlugIn", L"DisplayName"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DisplayName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBroadcastPlugIn_get_Logo(py::wrapper::Windows::Media::Capture::AppBroadcastPlugIn* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastPlugIn", L"Logo"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Logo());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBroadcastPlugIn_get_ProviderSettings(py::wrapper::Windows::Media::Capture::AppBroadcastPlugIn* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastPlugIn", L"ProviderSettings"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ProviderSettings());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AppBroadcastPlugIn(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Capture::AppBroadcastPlugIn>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AppBroadcastPlugIn(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Capture::AppBroadcastPlugIn>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AppBroadcastPlugIn[] = {
        { "_assign_array_", _assign_array_AppBroadcastPlugIn, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AppBroadcastPlugIn), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AppBroadcastPlugIn[] = {
        { "app_id", reinterpret_cast<getter>(AppBroadcastPlugIn_get_AppId), nullptr, nullptr, nullptr },
        { "display_name", reinterpret_cast<getter>(AppBroadcastPlugIn_get_DisplayName), nullptr, nullptr, nullptr },
        { "logo", reinterpret_cast<getter>(AppBroadcastPlugIn_get_Logo), nullptr, nullptr, nullptr },
        { "provider_settings", reinterpret_cast<getter>(AppBroadcastPlugIn_get_ProviderSettings), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AppBroadcastPlugIn[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_AppBroadcastPlugIn) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AppBroadcastPlugIn) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AppBroadcastPlugIn) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AppBroadcastPlugIn) },
        { }
    };

    static PyType_Spec type_spec_AppBroadcastPlugIn = {
        "winrt._winrt_windows_media_capture.AppBroadcastPlugIn",
        sizeof(py::wrapper::Windows::Media::Capture::AppBroadcastPlugIn),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AppBroadcastPlugIn};

    // ----- AppBroadcastPlugInManager class --------------------

    static PyObject* _new_AppBroadcastPlugInManager(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Capture::AppBroadcastPlugInManager>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Capture::AppBroadcastPlugInManager>::type_name);
        return nullptr;
    }

    static void _dealloc_AppBroadcastPlugInManager(py::wrapper::Windows::Media::Capture::AppBroadcastPlugInManager* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AppBroadcastPlugInManager_GetDefault(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Capture.AppBroadcastPlugInManager", L"GetDefault", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(winrt::Windows::Media::Capture::AppBroadcastPlugInManager::GetDefault());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppBroadcastPlugInManager_GetForUser(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Capture.AppBroadcastPlugInManager", L"GetForUser", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::System::User>(args, 0);

                return py::convert(winrt::Windows::Media::Capture::AppBroadcastPlugInManager::GetForUser(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppBroadcastPlugInManager_get_DefaultPlugIn(py::wrapper::Windows::Media::Capture::AppBroadcastPlugInManager* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastPlugInManager", L"DefaultPlugIn"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DefaultPlugIn());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppBroadcastPlugInManager_put_DefaultPlugIn(py::wrapper::Windows::Media::Capture::AppBroadcastPlugInManager* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastPlugInManager", L"DefaultPlugIn"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Media::Capture::AppBroadcastPlugIn>(arg);

            self->obj.DefaultPlugIn(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppBroadcastPlugInManager_get_IsBroadcastProviderAvailable(py::wrapper::Windows::Media::Capture::AppBroadcastPlugInManager* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastPlugInManager", L"IsBroadcastProviderAvailable"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsBroadcastProviderAvailable());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBroadcastPlugInManager_get_PlugInList(py::wrapper::Windows::Media::Capture::AppBroadcastPlugInManager* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastPlugInManager", L"PlugInList"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.PlugInList());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AppBroadcastPlugInManager(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Capture::AppBroadcastPlugInManager>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AppBroadcastPlugInManager(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Capture::AppBroadcastPlugInManager>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AppBroadcastPlugInManager[] = {
        { "_assign_array_", _assign_array_AppBroadcastPlugInManager, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AppBroadcastPlugInManager), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AppBroadcastPlugInManager[] = {
        { "default_plug_in", reinterpret_cast<getter>(AppBroadcastPlugInManager_get_DefaultPlugIn), reinterpret_cast<setter>(AppBroadcastPlugInManager_put_DefaultPlugIn), nullptr, nullptr },
        { "is_broadcast_provider_available", reinterpret_cast<getter>(AppBroadcastPlugInManager_get_IsBroadcastProviderAvailable), nullptr, nullptr, nullptr },
        { "plug_in_list", reinterpret_cast<getter>(AppBroadcastPlugInManager_get_PlugInList), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AppBroadcastPlugInManager[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_AppBroadcastPlugInManager) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AppBroadcastPlugInManager) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AppBroadcastPlugInManager) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AppBroadcastPlugInManager) },
        { }
    };

    static PyType_Spec type_spec_AppBroadcastPlugInManager = {
        "winrt._winrt_windows_media_capture.AppBroadcastPlugInManager",
        sizeof(py::wrapper::Windows::Media::Capture::AppBroadcastPlugInManager),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AppBroadcastPlugInManager};

    static PyGetSetDef getset_AppBroadcastPlugInManager_Static[] = {
        { }
    };

    static PyMethodDef methods_AppBroadcastPlugInManager_Static[] = {
        { "get_default", reinterpret_cast<PyCFunction>(AppBroadcastPlugInManager_GetDefault), METH_VARARGS, nullptr },
        { "get_for_user", reinterpret_cast<PyCFunction>(AppBroadcastPlugInManager_GetForUser), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_AppBroadcastPlugInManager_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_AppBroadcastPlugInManager_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_AppBroadcastPlugInManager_Static) },
        { }
    };

    static PyType_Spec type_spec_AppBroadcastPlugInManager_Static =
    {
        "winrt._winrt_windows_media_capture.AppBroadcastPlugInManager_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_AppBroadcastPlugInManager_Static
    };

    // ----- AppBroadcastPlugInStateChangedEventArgs class --------------------

    static PyObject* _new_AppBroadcastPlugInStateChangedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Capture::AppBroadcastPlugInStateChangedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Capture::AppBroadcastPlugInStateChangedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_AppBroadcastPlugInStateChangedEventArgs(py::wrapper::Windows::Media::Capture::AppBroadcastPlugInStateChangedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AppBroadcastPlugInStateChangedEventArgs_get_PlugInState(py::wrapper::Windows::Media::Capture::AppBroadcastPlugInStateChangedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastPlugInStateChangedEventArgs", L"PlugInState"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.PlugInState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AppBroadcastPlugInStateChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Capture::AppBroadcastPlugInStateChangedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AppBroadcastPlugInStateChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Capture::AppBroadcastPlugInStateChangedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AppBroadcastPlugInStateChangedEventArgs[] = {
        { "_assign_array_", _assign_array_AppBroadcastPlugInStateChangedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AppBroadcastPlugInStateChangedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AppBroadcastPlugInStateChangedEventArgs[] = {
        { "plug_in_state", reinterpret_cast<getter>(AppBroadcastPlugInStateChangedEventArgs_get_PlugInState), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AppBroadcastPlugInStateChangedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_AppBroadcastPlugInStateChangedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AppBroadcastPlugInStateChangedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AppBroadcastPlugInStateChangedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AppBroadcastPlugInStateChangedEventArgs) },
        { }
    };

    static PyType_Spec type_spec_AppBroadcastPlugInStateChangedEventArgs = {
        "winrt._winrt_windows_media_capture.AppBroadcastPlugInStateChangedEventArgs",
        sizeof(py::wrapper::Windows::Media::Capture::AppBroadcastPlugInStateChangedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AppBroadcastPlugInStateChangedEventArgs};

    // ----- AppBroadcastPreview class --------------------

    static PyObject* _new_AppBroadcastPreview(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Capture::AppBroadcastPreview>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Capture::AppBroadcastPreview>::type_name);
        return nullptr;
    }

    static void _dealloc_AppBroadcastPreview(py::wrapper::Windows::Media::Capture::AppBroadcastPreview* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AppBroadcastPreview_StopPreview(py::wrapper::Windows::Media::Capture::AppBroadcastPreview* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Capture.AppBroadcastPreview", L"StopPreview", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.StopPreview();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppBroadcastPreview_get_ErrorCode(py::wrapper::Windows::Media::Capture::AppBroadcastPreview* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastPreview", L"ErrorCode"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ErrorCode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBroadcastPreview_get_PreviewState(py::wrapper::Windows::Media::Capture::AppBroadcastPreview* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastPreview", L"PreviewState"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.PreviewState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBroadcastPreview_get_PreviewStreamReader(py::wrapper::Windows::Media::Capture::AppBroadcastPreview* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastPreview", L"PreviewStreamReader"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.PreviewStreamReader());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBroadcastPreview_add_PreviewStateChanged(py::wrapper::Windows::Media::Capture::AppBroadcastPreview* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Capture.AppBroadcastPreview", L"PreviewStateChanged"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Capture::AppBroadcastPreview, winrt::Windows::Media::Capture::AppBroadcastPreviewStateChangedEventArgs>>(arg);

            return py::convert(self->obj.PreviewStateChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBroadcastPreview_remove_PreviewStateChanged(py::wrapper::Windows::Media::Capture::AppBroadcastPreview* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Capture.AppBroadcastPreview", L"PreviewStateChanged"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.PreviewStateChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AppBroadcastPreview(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Capture::AppBroadcastPreview>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AppBroadcastPreview(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Capture::AppBroadcastPreview>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AppBroadcastPreview[] = {
        { "stop_preview", reinterpret_cast<PyCFunction>(AppBroadcastPreview_StopPreview), METH_VARARGS, nullptr },
        { "add_preview_state_changed", reinterpret_cast<PyCFunction>(AppBroadcastPreview_add_PreviewStateChanged), METH_O, nullptr },
        { "remove_preview_state_changed", reinterpret_cast<PyCFunction>(AppBroadcastPreview_remove_PreviewStateChanged), METH_O, nullptr },
        { "_assign_array_", _assign_array_AppBroadcastPreview, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AppBroadcastPreview), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AppBroadcastPreview[] = {
        { "error_code", reinterpret_cast<getter>(AppBroadcastPreview_get_ErrorCode), nullptr, nullptr, nullptr },
        { "preview_state", reinterpret_cast<getter>(AppBroadcastPreview_get_PreviewState), nullptr, nullptr, nullptr },
        { "preview_stream_reader", reinterpret_cast<getter>(AppBroadcastPreview_get_PreviewStreamReader), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AppBroadcastPreview[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_AppBroadcastPreview) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AppBroadcastPreview) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AppBroadcastPreview) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AppBroadcastPreview) },
        { }
    };

    static PyType_Spec type_spec_AppBroadcastPreview = {
        "winrt._winrt_windows_media_capture.AppBroadcastPreview",
        sizeof(py::wrapper::Windows::Media::Capture::AppBroadcastPreview),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AppBroadcastPreview};

    // ----- AppBroadcastPreviewStateChangedEventArgs class --------------------

    static PyObject* _new_AppBroadcastPreviewStateChangedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Capture::AppBroadcastPreviewStateChangedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Capture::AppBroadcastPreviewStateChangedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_AppBroadcastPreviewStateChangedEventArgs(py::wrapper::Windows::Media::Capture::AppBroadcastPreviewStateChangedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AppBroadcastPreviewStateChangedEventArgs_get_ErrorCode(py::wrapper::Windows::Media::Capture::AppBroadcastPreviewStateChangedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastPreviewStateChangedEventArgs", L"ErrorCode"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ErrorCode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBroadcastPreviewStateChangedEventArgs_get_PreviewState(py::wrapper::Windows::Media::Capture::AppBroadcastPreviewStateChangedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastPreviewStateChangedEventArgs", L"PreviewState"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.PreviewState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AppBroadcastPreviewStateChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Capture::AppBroadcastPreviewStateChangedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AppBroadcastPreviewStateChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Capture::AppBroadcastPreviewStateChangedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AppBroadcastPreviewStateChangedEventArgs[] = {
        { "_assign_array_", _assign_array_AppBroadcastPreviewStateChangedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AppBroadcastPreviewStateChangedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AppBroadcastPreviewStateChangedEventArgs[] = {
        { "error_code", reinterpret_cast<getter>(AppBroadcastPreviewStateChangedEventArgs_get_ErrorCode), nullptr, nullptr, nullptr },
        { "preview_state", reinterpret_cast<getter>(AppBroadcastPreviewStateChangedEventArgs_get_PreviewState), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AppBroadcastPreviewStateChangedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_AppBroadcastPreviewStateChangedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AppBroadcastPreviewStateChangedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AppBroadcastPreviewStateChangedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AppBroadcastPreviewStateChangedEventArgs) },
        { }
    };

    static PyType_Spec type_spec_AppBroadcastPreviewStateChangedEventArgs = {
        "winrt._winrt_windows_media_capture.AppBroadcastPreviewStateChangedEventArgs",
        sizeof(py::wrapper::Windows::Media::Capture::AppBroadcastPreviewStateChangedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AppBroadcastPreviewStateChangedEventArgs};

    // ----- AppBroadcastPreviewStreamReader class --------------------

    static PyObject* _new_AppBroadcastPreviewStreamReader(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Capture::AppBroadcastPreviewStreamReader>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Capture::AppBroadcastPreviewStreamReader>::type_name);
        return nullptr;
    }

    static void _dealloc_AppBroadcastPreviewStreamReader(py::wrapper::Windows::Media::Capture::AppBroadcastPreviewStreamReader* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AppBroadcastPreviewStreamReader_TryGetNextVideoFrame(py::wrapper::Windows::Media::Capture::AppBroadcastPreviewStreamReader* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Capture.AppBroadcastPreviewStreamReader", L"TryGetNextVideoFrame", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.TryGetNextVideoFrame());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppBroadcastPreviewStreamReader_get_VideoBitmapAlphaMode(py::wrapper::Windows::Media::Capture::AppBroadcastPreviewStreamReader* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastPreviewStreamReader", L"VideoBitmapAlphaMode"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.VideoBitmapAlphaMode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBroadcastPreviewStreamReader_get_VideoBitmapPixelFormat(py::wrapper::Windows::Media::Capture::AppBroadcastPreviewStreamReader* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastPreviewStreamReader", L"VideoBitmapPixelFormat"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.VideoBitmapPixelFormat());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBroadcastPreviewStreamReader_get_VideoHeight(py::wrapper::Windows::Media::Capture::AppBroadcastPreviewStreamReader* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastPreviewStreamReader", L"VideoHeight"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.VideoHeight());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBroadcastPreviewStreamReader_get_VideoStride(py::wrapper::Windows::Media::Capture::AppBroadcastPreviewStreamReader* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastPreviewStreamReader", L"VideoStride"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.VideoStride());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBroadcastPreviewStreamReader_get_VideoWidth(py::wrapper::Windows::Media::Capture::AppBroadcastPreviewStreamReader* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastPreviewStreamReader", L"VideoWidth"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.VideoWidth());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBroadcastPreviewStreamReader_add_VideoFrameArrived(py::wrapper::Windows::Media::Capture::AppBroadcastPreviewStreamReader* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Capture.AppBroadcastPreviewStreamReader", L"VideoFrameArrived"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Capture::AppBroadcastPreviewStreamReader, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.VideoFrameArrived(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBroadcastPreviewStreamReader_remove_VideoFrameArrived(py::wrapper::Windows::Media::Capture::AppBroadcastPreviewStreamReader* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Capture.AppBroadcastPreviewStreamReader", L"VideoFrameArrived"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.VideoFrameArrived(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AppBroadcastPreviewStreamReader(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Capture::AppBroadcastPreviewStreamReader>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AppBroadcastPreviewStreamReader(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Capture::AppBroadcastPreviewStreamReader>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AppBroadcastPreviewStreamReader[] = {
        { "try_get_next_video_frame", reinterpret_cast<PyCFunction>(AppBroadcastPreviewStreamReader_TryGetNextVideoFrame), METH_VARARGS, nullptr },
        { "add_video_frame_arrived", reinterpret_cast<PyCFunction>(AppBroadcastPreviewStreamReader_add_VideoFrameArrived), METH_O, nullptr },
        { "remove_video_frame_arrived", reinterpret_cast<PyCFunction>(AppBroadcastPreviewStreamReader_remove_VideoFrameArrived), METH_O, nullptr },
        { "_assign_array_", _assign_array_AppBroadcastPreviewStreamReader, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AppBroadcastPreviewStreamReader), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AppBroadcastPreviewStreamReader[] = {
        { "video_bitmap_alpha_mode", reinterpret_cast<getter>(AppBroadcastPreviewStreamReader_get_VideoBitmapAlphaMode), nullptr, nullptr, nullptr },
        { "video_bitmap_pixel_format", reinterpret_cast<getter>(AppBroadcastPreviewStreamReader_get_VideoBitmapPixelFormat), nullptr, nullptr, nullptr },
        { "video_height", reinterpret_cast<getter>(AppBroadcastPreviewStreamReader_get_VideoHeight), nullptr, nullptr, nullptr },
        { "video_stride", reinterpret_cast<getter>(AppBroadcastPreviewStreamReader_get_VideoStride), nullptr, nullptr, nullptr },
        { "video_width", reinterpret_cast<getter>(AppBroadcastPreviewStreamReader_get_VideoWidth), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AppBroadcastPreviewStreamReader[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_AppBroadcastPreviewStreamReader) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AppBroadcastPreviewStreamReader) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AppBroadcastPreviewStreamReader) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AppBroadcastPreviewStreamReader) },
        { }
    };

    static PyType_Spec type_spec_AppBroadcastPreviewStreamReader = {
        "winrt._winrt_windows_media_capture.AppBroadcastPreviewStreamReader",
        sizeof(py::wrapper::Windows::Media::Capture::AppBroadcastPreviewStreamReader),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AppBroadcastPreviewStreamReader};

    // ----- AppBroadcastPreviewStreamVideoFrame class --------------------

    static PyObject* _new_AppBroadcastPreviewStreamVideoFrame(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Capture::AppBroadcastPreviewStreamVideoFrame>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Capture::AppBroadcastPreviewStreamVideoFrame>::type_name);
        return nullptr;
    }

    static void _dealloc_AppBroadcastPreviewStreamVideoFrame(py::wrapper::Windows::Media::Capture::AppBroadcastPreviewStreamVideoFrame* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AppBroadcastPreviewStreamVideoFrame_get_VideoBuffer(py::wrapper::Windows::Media::Capture::AppBroadcastPreviewStreamVideoFrame* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastPreviewStreamVideoFrame", L"VideoBuffer"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.VideoBuffer());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBroadcastPreviewStreamVideoFrame_get_VideoHeader(py::wrapper::Windows::Media::Capture::AppBroadcastPreviewStreamVideoFrame* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastPreviewStreamVideoFrame", L"VideoHeader"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.VideoHeader());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AppBroadcastPreviewStreamVideoFrame(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Capture::AppBroadcastPreviewStreamVideoFrame>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AppBroadcastPreviewStreamVideoFrame(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Capture::AppBroadcastPreviewStreamVideoFrame>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AppBroadcastPreviewStreamVideoFrame[] = {
        { "_assign_array_", _assign_array_AppBroadcastPreviewStreamVideoFrame, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AppBroadcastPreviewStreamVideoFrame), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AppBroadcastPreviewStreamVideoFrame[] = {
        { "video_buffer", reinterpret_cast<getter>(AppBroadcastPreviewStreamVideoFrame_get_VideoBuffer), nullptr, nullptr, nullptr },
        { "video_header", reinterpret_cast<getter>(AppBroadcastPreviewStreamVideoFrame_get_VideoHeader), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AppBroadcastPreviewStreamVideoFrame[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_AppBroadcastPreviewStreamVideoFrame) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AppBroadcastPreviewStreamVideoFrame) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AppBroadcastPreviewStreamVideoFrame) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AppBroadcastPreviewStreamVideoFrame) },
        { }
    };

    static PyType_Spec type_spec_AppBroadcastPreviewStreamVideoFrame = {
        "winrt._winrt_windows_media_capture.AppBroadcastPreviewStreamVideoFrame",
        sizeof(py::wrapper::Windows::Media::Capture::AppBroadcastPreviewStreamVideoFrame),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AppBroadcastPreviewStreamVideoFrame};

    // ----- AppBroadcastPreviewStreamVideoHeader class --------------------

    static PyObject* _new_AppBroadcastPreviewStreamVideoHeader(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Capture::AppBroadcastPreviewStreamVideoHeader>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Capture::AppBroadcastPreviewStreamVideoHeader>::type_name);
        return nullptr;
    }

    static void _dealloc_AppBroadcastPreviewStreamVideoHeader(py::wrapper::Windows::Media::Capture::AppBroadcastPreviewStreamVideoHeader* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AppBroadcastPreviewStreamVideoHeader_get_AbsoluteTimestamp(py::wrapper::Windows::Media::Capture::AppBroadcastPreviewStreamVideoHeader* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastPreviewStreamVideoHeader", L"AbsoluteTimestamp"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.AbsoluteTimestamp());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBroadcastPreviewStreamVideoHeader_get_Duration(py::wrapper::Windows::Media::Capture::AppBroadcastPreviewStreamVideoHeader* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastPreviewStreamVideoHeader", L"Duration"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Duration());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBroadcastPreviewStreamVideoHeader_get_FrameId(py::wrapper::Windows::Media::Capture::AppBroadcastPreviewStreamVideoHeader* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastPreviewStreamVideoHeader", L"FrameId"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.FrameId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBroadcastPreviewStreamVideoHeader_get_RelativeTimestamp(py::wrapper::Windows::Media::Capture::AppBroadcastPreviewStreamVideoHeader* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastPreviewStreamVideoHeader", L"RelativeTimestamp"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.RelativeTimestamp());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AppBroadcastPreviewStreamVideoHeader(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Capture::AppBroadcastPreviewStreamVideoHeader>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AppBroadcastPreviewStreamVideoHeader(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Capture::AppBroadcastPreviewStreamVideoHeader>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AppBroadcastPreviewStreamVideoHeader[] = {
        { "_assign_array_", _assign_array_AppBroadcastPreviewStreamVideoHeader, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AppBroadcastPreviewStreamVideoHeader), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AppBroadcastPreviewStreamVideoHeader[] = {
        { "absolute_timestamp", reinterpret_cast<getter>(AppBroadcastPreviewStreamVideoHeader_get_AbsoluteTimestamp), nullptr, nullptr, nullptr },
        { "duration", reinterpret_cast<getter>(AppBroadcastPreviewStreamVideoHeader_get_Duration), nullptr, nullptr, nullptr },
        { "frame_id", reinterpret_cast<getter>(AppBroadcastPreviewStreamVideoHeader_get_FrameId), nullptr, nullptr, nullptr },
        { "relative_timestamp", reinterpret_cast<getter>(AppBroadcastPreviewStreamVideoHeader_get_RelativeTimestamp), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AppBroadcastPreviewStreamVideoHeader[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_AppBroadcastPreviewStreamVideoHeader) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AppBroadcastPreviewStreamVideoHeader) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AppBroadcastPreviewStreamVideoHeader) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AppBroadcastPreviewStreamVideoHeader) },
        { }
    };

    static PyType_Spec type_spec_AppBroadcastPreviewStreamVideoHeader = {
        "winrt._winrt_windows_media_capture.AppBroadcastPreviewStreamVideoHeader",
        sizeof(py::wrapper::Windows::Media::Capture::AppBroadcastPreviewStreamVideoHeader),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AppBroadcastPreviewStreamVideoHeader};

    // ----- AppBroadcastProviderSettings class --------------------

    static PyObject* _new_AppBroadcastProviderSettings(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Capture::AppBroadcastProviderSettings>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Capture::AppBroadcastProviderSettings>::type_name);
        return nullptr;
    }

    static void _dealloc_AppBroadcastProviderSettings(py::wrapper::Windows::Media::Capture::AppBroadcastProviderSettings* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AppBroadcastProviderSettings_get_VideoEncodingResolutionMode(py::wrapper::Windows::Media::Capture::AppBroadcastProviderSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastProviderSettings", L"VideoEncodingResolutionMode"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.VideoEncodingResolutionMode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppBroadcastProviderSettings_put_VideoEncodingResolutionMode(py::wrapper::Windows::Media::Capture::AppBroadcastProviderSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastProviderSettings", L"VideoEncodingResolutionMode"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Media::Capture::AppBroadcastVideoEncodingResolutionMode>(arg);

            self->obj.VideoEncodingResolutionMode(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppBroadcastProviderSettings_get_VideoEncodingBitrateMode(py::wrapper::Windows::Media::Capture::AppBroadcastProviderSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastProviderSettings", L"VideoEncodingBitrateMode"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.VideoEncodingBitrateMode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppBroadcastProviderSettings_put_VideoEncodingBitrateMode(py::wrapper::Windows::Media::Capture::AppBroadcastProviderSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastProviderSettings", L"VideoEncodingBitrateMode"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Media::Capture::AppBroadcastVideoEncodingBitrateMode>(arg);

            self->obj.VideoEncodingBitrateMode(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppBroadcastProviderSettings_get_DefaultBroadcastTitle(py::wrapper::Windows::Media::Capture::AppBroadcastProviderSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastProviderSettings", L"DefaultBroadcastTitle"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DefaultBroadcastTitle());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppBroadcastProviderSettings_put_DefaultBroadcastTitle(py::wrapper::Windows::Media::Capture::AppBroadcastProviderSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastProviderSettings", L"DefaultBroadcastTitle"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.DefaultBroadcastTitle(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppBroadcastProviderSettings_get_CustomVideoEncodingWidth(py::wrapper::Windows::Media::Capture::AppBroadcastProviderSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastProviderSettings", L"CustomVideoEncodingWidth"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CustomVideoEncodingWidth());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppBroadcastProviderSettings_put_CustomVideoEncodingWidth(py::wrapper::Windows::Media::Capture::AppBroadcastProviderSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastProviderSettings", L"CustomVideoEncodingWidth"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.CustomVideoEncodingWidth(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppBroadcastProviderSettings_get_CustomVideoEncodingHeight(py::wrapper::Windows::Media::Capture::AppBroadcastProviderSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastProviderSettings", L"CustomVideoEncodingHeight"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CustomVideoEncodingHeight());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppBroadcastProviderSettings_put_CustomVideoEncodingHeight(py::wrapper::Windows::Media::Capture::AppBroadcastProviderSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastProviderSettings", L"CustomVideoEncodingHeight"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.CustomVideoEncodingHeight(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppBroadcastProviderSettings_get_CustomVideoEncodingBitrate(py::wrapper::Windows::Media::Capture::AppBroadcastProviderSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastProviderSettings", L"CustomVideoEncodingBitrate"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CustomVideoEncodingBitrate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppBroadcastProviderSettings_put_CustomVideoEncodingBitrate(py::wrapper::Windows::Media::Capture::AppBroadcastProviderSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastProviderSettings", L"CustomVideoEncodingBitrate"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.CustomVideoEncodingBitrate(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppBroadcastProviderSettings_get_AudioEncodingBitrate(py::wrapper::Windows::Media::Capture::AppBroadcastProviderSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastProviderSettings", L"AudioEncodingBitrate"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.AudioEncodingBitrate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppBroadcastProviderSettings_put_AudioEncodingBitrate(py::wrapper::Windows::Media::Capture::AppBroadcastProviderSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastProviderSettings", L"AudioEncodingBitrate"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.AudioEncodingBitrate(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_AppBroadcastProviderSettings(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Capture::AppBroadcastProviderSettings>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AppBroadcastProviderSettings(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Capture::AppBroadcastProviderSettings>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AppBroadcastProviderSettings[] = {
        { "_assign_array_", _assign_array_AppBroadcastProviderSettings, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AppBroadcastProviderSettings), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AppBroadcastProviderSettings[] = {
        { "video_encoding_resolution_mode", reinterpret_cast<getter>(AppBroadcastProviderSettings_get_VideoEncodingResolutionMode), reinterpret_cast<setter>(AppBroadcastProviderSettings_put_VideoEncodingResolutionMode), nullptr, nullptr },
        { "video_encoding_bitrate_mode", reinterpret_cast<getter>(AppBroadcastProviderSettings_get_VideoEncodingBitrateMode), reinterpret_cast<setter>(AppBroadcastProviderSettings_put_VideoEncodingBitrateMode), nullptr, nullptr },
        { "default_broadcast_title", reinterpret_cast<getter>(AppBroadcastProviderSettings_get_DefaultBroadcastTitle), reinterpret_cast<setter>(AppBroadcastProviderSettings_put_DefaultBroadcastTitle), nullptr, nullptr },
        { "custom_video_encoding_width", reinterpret_cast<getter>(AppBroadcastProviderSettings_get_CustomVideoEncodingWidth), reinterpret_cast<setter>(AppBroadcastProviderSettings_put_CustomVideoEncodingWidth), nullptr, nullptr },
        { "custom_video_encoding_height", reinterpret_cast<getter>(AppBroadcastProviderSettings_get_CustomVideoEncodingHeight), reinterpret_cast<setter>(AppBroadcastProviderSettings_put_CustomVideoEncodingHeight), nullptr, nullptr },
        { "custom_video_encoding_bitrate", reinterpret_cast<getter>(AppBroadcastProviderSettings_get_CustomVideoEncodingBitrate), reinterpret_cast<setter>(AppBroadcastProviderSettings_put_CustomVideoEncodingBitrate), nullptr, nullptr },
        { "audio_encoding_bitrate", reinterpret_cast<getter>(AppBroadcastProviderSettings_get_AudioEncodingBitrate), reinterpret_cast<setter>(AppBroadcastProviderSettings_put_AudioEncodingBitrate), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AppBroadcastProviderSettings[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_AppBroadcastProviderSettings) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AppBroadcastProviderSettings) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AppBroadcastProviderSettings) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AppBroadcastProviderSettings) },
        { }
    };

    static PyType_Spec type_spec_AppBroadcastProviderSettings = {
        "winrt._winrt_windows_media_capture.AppBroadcastProviderSettings",
        sizeof(py::wrapper::Windows::Media::Capture::AppBroadcastProviderSettings),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AppBroadcastProviderSettings};

    // ----- AppBroadcastServices class --------------------

    static PyObject* _new_AppBroadcastServices(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Capture::AppBroadcastServices>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Capture::AppBroadcastServices>::type_name);
        return nullptr;
    }

    static void _dealloc_AppBroadcastServices(py::wrapper::Windows::Media::Capture::AppBroadcastServices* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AppBroadcastServices_EnterBroadcastModeAsync(py::wrapper::Windows::Media::Capture::AppBroadcastServices* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Capture.AppBroadcastServices", L"EnterBroadcastModeAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Media::Capture::AppBroadcastPlugIn>(args, 0);

                return py::convert(self->obj.EnterBroadcastModeAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppBroadcastServices_ExitBroadcastMode(py::wrapper::Windows::Media::Capture::AppBroadcastServices* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Capture.AppBroadcastServices", L"ExitBroadcastMode", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Media::Capture::AppBroadcastExitBroadcastModeReason>(args, 0);

                self->obj.ExitBroadcastMode(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppBroadcastServices_PauseBroadcast(py::wrapper::Windows::Media::Capture::AppBroadcastServices* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Capture.AppBroadcastServices", L"PauseBroadcast", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.PauseBroadcast();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppBroadcastServices_ResumeBroadcast(py::wrapper::Windows::Media::Capture::AppBroadcastServices* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Capture.AppBroadcastServices", L"ResumeBroadcast", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.ResumeBroadcast();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppBroadcastServices_StartBroadcast(py::wrapper::Windows::Media::Capture::AppBroadcastServices* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Capture.AppBroadcastServices", L"StartBroadcast", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.StartBroadcast();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppBroadcastServices_StartPreview(py::wrapper::Windows::Media::Capture::AppBroadcastServices* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Capture.AppBroadcastServices", L"StartPreview", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Size>(args, 0);

                return py::convert(self->obj.StartPreview(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppBroadcastServices_get_CaptureTargetType(py::wrapper::Windows::Media::Capture::AppBroadcastServices* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastServices", L"CaptureTargetType"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CaptureTargetType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppBroadcastServices_put_CaptureTargetType(py::wrapper::Windows::Media::Capture::AppBroadcastServices* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastServices", L"CaptureTargetType"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Media::Capture::AppBroadcastCaptureTargetType>(arg);

            self->obj.CaptureTargetType(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppBroadcastServices_get_BroadcastTitle(py::wrapper::Windows::Media::Capture::AppBroadcastServices* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastServices", L"BroadcastTitle"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.BroadcastTitle());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppBroadcastServices_put_BroadcastTitle(py::wrapper::Windows::Media::Capture::AppBroadcastServices* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastServices", L"BroadcastTitle"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.BroadcastTitle(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppBroadcastServices_get_BroadcastLanguage(py::wrapper::Windows::Media::Capture::AppBroadcastServices* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastServices", L"BroadcastLanguage"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.BroadcastLanguage());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppBroadcastServices_put_BroadcastLanguage(py::wrapper::Windows::Media::Capture::AppBroadcastServices* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastServices", L"BroadcastLanguage"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.BroadcastLanguage(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppBroadcastServices_get_CanCapture(py::wrapper::Windows::Media::Capture::AppBroadcastServices* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastServices", L"CanCapture"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CanCapture());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBroadcastServices_get_State(py::wrapper::Windows::Media::Capture::AppBroadcastServices* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastServices", L"State"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.State());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBroadcastServices_get_UserName(py::wrapper::Windows::Media::Capture::AppBroadcastServices* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastServices", L"UserName"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.UserName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AppBroadcastServices(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Capture::AppBroadcastServices>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AppBroadcastServices(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Capture::AppBroadcastServices>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AppBroadcastServices[] = {
        { "enter_broadcast_mode_async", reinterpret_cast<PyCFunction>(AppBroadcastServices_EnterBroadcastModeAsync), METH_VARARGS, nullptr },
        { "exit_broadcast_mode", reinterpret_cast<PyCFunction>(AppBroadcastServices_ExitBroadcastMode), METH_VARARGS, nullptr },
        { "pause_broadcast", reinterpret_cast<PyCFunction>(AppBroadcastServices_PauseBroadcast), METH_VARARGS, nullptr },
        { "resume_broadcast", reinterpret_cast<PyCFunction>(AppBroadcastServices_ResumeBroadcast), METH_VARARGS, nullptr },
        { "start_broadcast", reinterpret_cast<PyCFunction>(AppBroadcastServices_StartBroadcast), METH_VARARGS, nullptr },
        { "start_preview", reinterpret_cast<PyCFunction>(AppBroadcastServices_StartPreview), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_AppBroadcastServices, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AppBroadcastServices), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AppBroadcastServices[] = {
        { "capture_target_type", reinterpret_cast<getter>(AppBroadcastServices_get_CaptureTargetType), reinterpret_cast<setter>(AppBroadcastServices_put_CaptureTargetType), nullptr, nullptr },
        { "broadcast_title", reinterpret_cast<getter>(AppBroadcastServices_get_BroadcastTitle), reinterpret_cast<setter>(AppBroadcastServices_put_BroadcastTitle), nullptr, nullptr },
        { "broadcast_language", reinterpret_cast<getter>(AppBroadcastServices_get_BroadcastLanguage), reinterpret_cast<setter>(AppBroadcastServices_put_BroadcastLanguage), nullptr, nullptr },
        { "can_capture", reinterpret_cast<getter>(AppBroadcastServices_get_CanCapture), nullptr, nullptr, nullptr },
        { "state", reinterpret_cast<getter>(AppBroadcastServices_get_State), nullptr, nullptr, nullptr },
        { "user_name", reinterpret_cast<getter>(AppBroadcastServices_get_UserName), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AppBroadcastServices[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_AppBroadcastServices) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AppBroadcastServices) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AppBroadcastServices) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AppBroadcastServices) },
        { }
    };

    static PyType_Spec type_spec_AppBroadcastServices = {
        "winrt._winrt_windows_media_capture.AppBroadcastServices",
        sizeof(py::wrapper::Windows::Media::Capture::AppBroadcastServices),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AppBroadcastServices};

    // ----- AppBroadcastSignInStateChangedEventArgs class --------------------

    static PyObject* _new_AppBroadcastSignInStateChangedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Capture::AppBroadcastSignInStateChangedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Capture::AppBroadcastSignInStateChangedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_AppBroadcastSignInStateChangedEventArgs(py::wrapper::Windows::Media::Capture::AppBroadcastSignInStateChangedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AppBroadcastSignInStateChangedEventArgs_get_Result(py::wrapper::Windows::Media::Capture::AppBroadcastSignInStateChangedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastSignInStateChangedEventArgs", L"Result"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Result());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBroadcastSignInStateChangedEventArgs_get_SignInState(py::wrapper::Windows::Media::Capture::AppBroadcastSignInStateChangedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastSignInStateChangedEventArgs", L"SignInState"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SignInState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AppBroadcastSignInStateChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Capture::AppBroadcastSignInStateChangedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AppBroadcastSignInStateChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Capture::AppBroadcastSignInStateChangedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AppBroadcastSignInStateChangedEventArgs[] = {
        { "_assign_array_", _assign_array_AppBroadcastSignInStateChangedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AppBroadcastSignInStateChangedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AppBroadcastSignInStateChangedEventArgs[] = {
        { "result", reinterpret_cast<getter>(AppBroadcastSignInStateChangedEventArgs_get_Result), nullptr, nullptr, nullptr },
        { "sign_in_state", reinterpret_cast<getter>(AppBroadcastSignInStateChangedEventArgs_get_SignInState), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AppBroadcastSignInStateChangedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_AppBroadcastSignInStateChangedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AppBroadcastSignInStateChangedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AppBroadcastSignInStateChangedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AppBroadcastSignInStateChangedEventArgs) },
        { }
    };

    static PyType_Spec type_spec_AppBroadcastSignInStateChangedEventArgs = {
        "winrt._winrt_windows_media_capture.AppBroadcastSignInStateChangedEventArgs",
        sizeof(py::wrapper::Windows::Media::Capture::AppBroadcastSignInStateChangedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AppBroadcastSignInStateChangedEventArgs};

    // ----- AppBroadcastState class --------------------

    static PyObject* _new_AppBroadcastState(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Capture::AppBroadcastState>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Capture::AppBroadcastState>::type_name);
        return nullptr;
    }

    static void _dealloc_AppBroadcastState(py::wrapper::Windows::Media::Capture::AppBroadcastState* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AppBroadcastState_RestartCameraCapture(py::wrapper::Windows::Media::Capture::AppBroadcastState* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Capture.AppBroadcastState", L"RestartCameraCapture", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.RestartCameraCapture();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppBroadcastState_RestartMicrophoneCapture(py::wrapper::Windows::Media::Capture::AppBroadcastState* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Capture.AppBroadcastState", L"RestartMicrophoneCapture", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.RestartMicrophoneCapture();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppBroadcastState_get_SignInState(py::wrapper::Windows::Media::Capture::AppBroadcastState* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastState", L"SignInState"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SignInState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppBroadcastState_put_SignInState(py::wrapper::Windows::Media::Capture::AppBroadcastState* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastState", L"SignInState"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Media::Capture::AppBroadcastSignInState>(arg);

            self->obj.SignInState(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppBroadcastState_get_ShouldCaptureMicrophone(py::wrapper::Windows::Media::Capture::AppBroadcastState* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastState", L"ShouldCaptureMicrophone"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ShouldCaptureMicrophone());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppBroadcastState_put_ShouldCaptureMicrophone(py::wrapper::Windows::Media::Capture::AppBroadcastState* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastState", L"ShouldCaptureMicrophone"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.ShouldCaptureMicrophone(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppBroadcastState_get_ShouldCaptureCamera(py::wrapper::Windows::Media::Capture::AppBroadcastState* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastState", L"ShouldCaptureCamera"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ShouldCaptureCamera());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppBroadcastState_put_ShouldCaptureCamera(py::wrapper::Windows::Media::Capture::AppBroadcastState* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastState", L"ShouldCaptureCamera"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.ShouldCaptureCamera(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppBroadcastState_get_AuthenticationResult(py::wrapper::Windows::Media::Capture::AppBroadcastState* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastState", L"AuthenticationResult"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.AuthenticationResult());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppBroadcastState_put_AuthenticationResult(py::wrapper::Windows::Media::Capture::AppBroadcastState* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastState", L"AuthenticationResult"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Security::Authentication::Web::WebAuthenticationResult>(arg);

            self->obj.AuthenticationResult(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppBroadcastState_get_IsCaptureTargetRunning(py::wrapper::Windows::Media::Capture::AppBroadcastState* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastState", L"IsCaptureTargetRunning"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsCaptureTargetRunning());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBroadcastState_get_MicrophoneCaptureError(py::wrapper::Windows::Media::Capture::AppBroadcastState* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastState", L"MicrophoneCaptureError"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.MicrophoneCaptureError());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBroadcastState_get_MicrophoneCaptureState(py::wrapper::Windows::Media::Capture::AppBroadcastState* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastState", L"MicrophoneCaptureState"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.MicrophoneCaptureState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBroadcastState_get_OAuthCallbackUri(py::wrapper::Windows::Media::Capture::AppBroadcastState* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastState", L"OAuthCallbackUri"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.OAuthCallbackUri());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBroadcastState_get_OAuthRequestUri(py::wrapper::Windows::Media::Capture::AppBroadcastState* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastState", L"OAuthRequestUri"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.OAuthRequestUri());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBroadcastState_get_PlugInState(py::wrapper::Windows::Media::Capture::AppBroadcastState* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastState", L"PlugInState"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.PlugInState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBroadcastState_get_CameraCaptureError(py::wrapper::Windows::Media::Capture::AppBroadcastState* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastState", L"CameraCaptureError"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CameraCaptureError());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBroadcastState_get_CameraCaptureState(py::wrapper::Windows::Media::Capture::AppBroadcastState* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastState", L"CameraCaptureState"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CameraCaptureState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBroadcastState_get_EncodedVideoSize(py::wrapper::Windows::Media::Capture::AppBroadcastState* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastState", L"EncodedVideoSize"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.EncodedVideoSize());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBroadcastState_get_StreamState(py::wrapper::Windows::Media::Capture::AppBroadcastState* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastState", L"StreamState"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.StreamState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBroadcastState_get_TerminationReason(py::wrapper::Windows::Media::Capture::AppBroadcastState* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastState", L"TerminationReason"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.TerminationReason());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBroadcastState_get_TerminationReasonPlugInSpecific(py::wrapper::Windows::Media::Capture::AppBroadcastState* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastState", L"TerminationReasonPlugInSpecific"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.TerminationReasonPlugInSpecific());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBroadcastState_get_ViewerCount(py::wrapper::Windows::Media::Capture::AppBroadcastState* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastState", L"ViewerCount"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ViewerCount());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBroadcastState_add_CameraCaptureStateChanged(py::wrapper::Windows::Media::Capture::AppBroadcastState* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Capture.AppBroadcastState", L"CameraCaptureStateChanged"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Capture::AppBroadcastState, winrt::Windows::Media::Capture::AppBroadcastCameraCaptureStateChangedEventArgs>>(arg);

            return py::convert(self->obj.CameraCaptureStateChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBroadcastState_remove_CameraCaptureStateChanged(py::wrapper::Windows::Media::Capture::AppBroadcastState* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Capture.AppBroadcastState", L"CameraCaptureStateChanged"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.CameraCaptureStateChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBroadcastState_add_CaptureTargetClosed(py::wrapper::Windows::Media::Capture::AppBroadcastState* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Capture.AppBroadcastState", L"CaptureTargetClosed"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Capture::AppBroadcastState, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.CaptureTargetClosed(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBroadcastState_remove_CaptureTargetClosed(py::wrapper::Windows::Media::Capture::AppBroadcastState* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Capture.AppBroadcastState", L"CaptureTargetClosed"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.CaptureTargetClosed(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBroadcastState_add_MicrophoneCaptureStateChanged(py::wrapper::Windows::Media::Capture::AppBroadcastState* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Capture.AppBroadcastState", L"MicrophoneCaptureStateChanged"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Capture::AppBroadcastState, winrt::Windows::Media::Capture::AppBroadcastMicrophoneCaptureStateChangedEventArgs>>(arg);

            return py::convert(self->obj.MicrophoneCaptureStateChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBroadcastState_remove_MicrophoneCaptureStateChanged(py::wrapper::Windows::Media::Capture::AppBroadcastState* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Capture.AppBroadcastState", L"MicrophoneCaptureStateChanged"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.MicrophoneCaptureStateChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBroadcastState_add_PlugInStateChanged(py::wrapper::Windows::Media::Capture::AppBroadcastState* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Capture.AppBroadcastState", L"PlugInStateChanged"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Capture::AppBroadcastState, winrt::Windows::Media::Capture::AppBroadcastPlugInStateChangedEventArgs>>(arg);

            return py::convert(self->obj.PlugInStateChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBroadcastState_remove_PlugInStateChanged(py::wrapper::Windows::Media::Capture::AppBroadcastState* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Capture.AppBroadcastState", L"PlugInStateChanged"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.PlugInStateChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBroadcastState_add_StreamStateChanged(py::wrapper::Windows::Media::Capture::AppBroadcastState* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Capture.AppBroadcastState", L"StreamStateChanged"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Capture::AppBroadcastState, winrt::Windows::Media::Capture::AppBroadcastStreamStateChangedEventArgs>>(arg);

            return py::convert(self->obj.StreamStateChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBroadcastState_remove_StreamStateChanged(py::wrapper::Windows::Media::Capture::AppBroadcastState* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Capture.AppBroadcastState", L"StreamStateChanged"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.StreamStateChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBroadcastState_add_ViewerCountChanged(py::wrapper::Windows::Media::Capture::AppBroadcastState* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Capture.AppBroadcastState", L"ViewerCountChanged"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Capture::AppBroadcastState, winrt::Windows::Media::Capture::AppBroadcastViewerCountChangedEventArgs>>(arg);

            return py::convert(self->obj.ViewerCountChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBroadcastState_remove_ViewerCountChanged(py::wrapper::Windows::Media::Capture::AppBroadcastState* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Capture.AppBroadcastState", L"ViewerCountChanged"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ViewerCountChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AppBroadcastState(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Capture::AppBroadcastState>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AppBroadcastState(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Capture::AppBroadcastState>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AppBroadcastState[] = {
        { "restart_camera_capture", reinterpret_cast<PyCFunction>(AppBroadcastState_RestartCameraCapture), METH_VARARGS, nullptr },
        { "restart_microphone_capture", reinterpret_cast<PyCFunction>(AppBroadcastState_RestartMicrophoneCapture), METH_VARARGS, nullptr },
        { "add_camera_capture_state_changed", reinterpret_cast<PyCFunction>(AppBroadcastState_add_CameraCaptureStateChanged), METH_O, nullptr },
        { "remove_camera_capture_state_changed", reinterpret_cast<PyCFunction>(AppBroadcastState_remove_CameraCaptureStateChanged), METH_O, nullptr },
        { "add_capture_target_closed", reinterpret_cast<PyCFunction>(AppBroadcastState_add_CaptureTargetClosed), METH_O, nullptr },
        { "remove_capture_target_closed", reinterpret_cast<PyCFunction>(AppBroadcastState_remove_CaptureTargetClosed), METH_O, nullptr },
        { "add_microphone_capture_state_changed", reinterpret_cast<PyCFunction>(AppBroadcastState_add_MicrophoneCaptureStateChanged), METH_O, nullptr },
        { "remove_microphone_capture_state_changed", reinterpret_cast<PyCFunction>(AppBroadcastState_remove_MicrophoneCaptureStateChanged), METH_O, nullptr },
        { "add_plug_in_state_changed", reinterpret_cast<PyCFunction>(AppBroadcastState_add_PlugInStateChanged), METH_O, nullptr },
        { "remove_plug_in_state_changed", reinterpret_cast<PyCFunction>(AppBroadcastState_remove_PlugInStateChanged), METH_O, nullptr },
        { "add_stream_state_changed", reinterpret_cast<PyCFunction>(AppBroadcastState_add_StreamStateChanged), METH_O, nullptr },
        { "remove_stream_state_changed", reinterpret_cast<PyCFunction>(AppBroadcastState_remove_StreamStateChanged), METH_O, nullptr },
        { "add_viewer_count_changed", reinterpret_cast<PyCFunction>(AppBroadcastState_add_ViewerCountChanged), METH_O, nullptr },
        { "remove_viewer_count_changed", reinterpret_cast<PyCFunction>(AppBroadcastState_remove_ViewerCountChanged), METH_O, nullptr },
        { "_assign_array_", _assign_array_AppBroadcastState, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AppBroadcastState), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AppBroadcastState[] = {
        { "sign_in_state", reinterpret_cast<getter>(AppBroadcastState_get_SignInState), reinterpret_cast<setter>(AppBroadcastState_put_SignInState), nullptr, nullptr },
        { "should_capture_microphone", reinterpret_cast<getter>(AppBroadcastState_get_ShouldCaptureMicrophone), reinterpret_cast<setter>(AppBroadcastState_put_ShouldCaptureMicrophone), nullptr, nullptr },
        { "should_capture_camera", reinterpret_cast<getter>(AppBroadcastState_get_ShouldCaptureCamera), reinterpret_cast<setter>(AppBroadcastState_put_ShouldCaptureCamera), nullptr, nullptr },
        { "authentication_result", reinterpret_cast<getter>(AppBroadcastState_get_AuthenticationResult), reinterpret_cast<setter>(AppBroadcastState_put_AuthenticationResult), nullptr, nullptr },
        { "is_capture_target_running", reinterpret_cast<getter>(AppBroadcastState_get_IsCaptureTargetRunning), nullptr, nullptr, nullptr },
        { "microphone_capture_error", reinterpret_cast<getter>(AppBroadcastState_get_MicrophoneCaptureError), nullptr, nullptr, nullptr },
        { "microphone_capture_state", reinterpret_cast<getter>(AppBroadcastState_get_MicrophoneCaptureState), nullptr, nullptr, nullptr },
        { "o_auth_callback_uri", reinterpret_cast<getter>(AppBroadcastState_get_OAuthCallbackUri), nullptr, nullptr, nullptr },
        { "o_auth_request_uri", reinterpret_cast<getter>(AppBroadcastState_get_OAuthRequestUri), nullptr, nullptr, nullptr },
        { "plug_in_state", reinterpret_cast<getter>(AppBroadcastState_get_PlugInState), nullptr, nullptr, nullptr },
        { "camera_capture_error", reinterpret_cast<getter>(AppBroadcastState_get_CameraCaptureError), nullptr, nullptr, nullptr },
        { "camera_capture_state", reinterpret_cast<getter>(AppBroadcastState_get_CameraCaptureState), nullptr, nullptr, nullptr },
        { "encoded_video_size", reinterpret_cast<getter>(AppBroadcastState_get_EncodedVideoSize), nullptr, nullptr, nullptr },
        { "stream_state", reinterpret_cast<getter>(AppBroadcastState_get_StreamState), nullptr, nullptr, nullptr },
        { "termination_reason", reinterpret_cast<getter>(AppBroadcastState_get_TerminationReason), nullptr, nullptr, nullptr },
        { "termination_reason_plug_in_specific", reinterpret_cast<getter>(AppBroadcastState_get_TerminationReasonPlugInSpecific), nullptr, nullptr, nullptr },
        { "viewer_count", reinterpret_cast<getter>(AppBroadcastState_get_ViewerCount), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AppBroadcastState[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_AppBroadcastState) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AppBroadcastState) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AppBroadcastState) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AppBroadcastState) },
        { }
    };

    static PyType_Spec type_spec_AppBroadcastState = {
        "winrt._winrt_windows_media_capture.AppBroadcastState",
        sizeof(py::wrapper::Windows::Media::Capture::AppBroadcastState),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AppBroadcastState};

    // ----- AppBroadcastStreamAudioFrame class --------------------

    static PyObject* _new_AppBroadcastStreamAudioFrame(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Capture::AppBroadcastStreamAudioFrame>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Capture::AppBroadcastStreamAudioFrame>::type_name);
        return nullptr;
    }

    static void _dealloc_AppBroadcastStreamAudioFrame(py::wrapper::Windows::Media::Capture::AppBroadcastStreamAudioFrame* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AppBroadcastStreamAudioFrame_get_AudioBuffer(py::wrapper::Windows::Media::Capture::AppBroadcastStreamAudioFrame* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastStreamAudioFrame", L"AudioBuffer"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.AudioBuffer());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBroadcastStreamAudioFrame_get_AudioHeader(py::wrapper::Windows::Media::Capture::AppBroadcastStreamAudioFrame* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastStreamAudioFrame", L"AudioHeader"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.AudioHeader());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AppBroadcastStreamAudioFrame(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Capture::AppBroadcastStreamAudioFrame>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AppBroadcastStreamAudioFrame(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Capture::AppBroadcastStreamAudioFrame>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AppBroadcastStreamAudioFrame[] = {
        { "_assign_array_", _assign_array_AppBroadcastStreamAudioFrame, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AppBroadcastStreamAudioFrame), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AppBroadcastStreamAudioFrame[] = {
        { "audio_buffer", reinterpret_cast<getter>(AppBroadcastStreamAudioFrame_get_AudioBuffer), nullptr, nullptr, nullptr },
        { "audio_header", reinterpret_cast<getter>(AppBroadcastStreamAudioFrame_get_AudioHeader), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AppBroadcastStreamAudioFrame[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_AppBroadcastStreamAudioFrame) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AppBroadcastStreamAudioFrame) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AppBroadcastStreamAudioFrame) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AppBroadcastStreamAudioFrame) },
        { }
    };

    static PyType_Spec type_spec_AppBroadcastStreamAudioFrame = {
        "winrt._winrt_windows_media_capture.AppBroadcastStreamAudioFrame",
        sizeof(py::wrapper::Windows::Media::Capture::AppBroadcastStreamAudioFrame),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AppBroadcastStreamAudioFrame};

    // ----- AppBroadcastStreamAudioHeader class --------------------

    static PyObject* _new_AppBroadcastStreamAudioHeader(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Capture::AppBroadcastStreamAudioHeader>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Capture::AppBroadcastStreamAudioHeader>::type_name);
        return nullptr;
    }

    static void _dealloc_AppBroadcastStreamAudioHeader(py::wrapper::Windows::Media::Capture::AppBroadcastStreamAudioHeader* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AppBroadcastStreamAudioHeader_get_AbsoluteTimestamp(py::wrapper::Windows::Media::Capture::AppBroadcastStreamAudioHeader* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastStreamAudioHeader", L"AbsoluteTimestamp"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.AbsoluteTimestamp());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBroadcastStreamAudioHeader_get_Duration(py::wrapper::Windows::Media::Capture::AppBroadcastStreamAudioHeader* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastStreamAudioHeader", L"Duration"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Duration());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBroadcastStreamAudioHeader_get_FrameId(py::wrapper::Windows::Media::Capture::AppBroadcastStreamAudioHeader* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastStreamAudioHeader", L"FrameId"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.FrameId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBroadcastStreamAudioHeader_get_HasDiscontinuity(py::wrapper::Windows::Media::Capture::AppBroadcastStreamAudioHeader* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastStreamAudioHeader", L"HasDiscontinuity"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.HasDiscontinuity());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBroadcastStreamAudioHeader_get_RelativeTimestamp(py::wrapper::Windows::Media::Capture::AppBroadcastStreamAudioHeader* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastStreamAudioHeader", L"RelativeTimestamp"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.RelativeTimestamp());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AppBroadcastStreamAudioHeader(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Capture::AppBroadcastStreamAudioHeader>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AppBroadcastStreamAudioHeader(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Capture::AppBroadcastStreamAudioHeader>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AppBroadcastStreamAudioHeader[] = {
        { "_assign_array_", _assign_array_AppBroadcastStreamAudioHeader, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AppBroadcastStreamAudioHeader), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AppBroadcastStreamAudioHeader[] = {
        { "absolute_timestamp", reinterpret_cast<getter>(AppBroadcastStreamAudioHeader_get_AbsoluteTimestamp), nullptr, nullptr, nullptr },
        { "duration", reinterpret_cast<getter>(AppBroadcastStreamAudioHeader_get_Duration), nullptr, nullptr, nullptr },
        { "frame_id", reinterpret_cast<getter>(AppBroadcastStreamAudioHeader_get_FrameId), nullptr, nullptr, nullptr },
        { "has_discontinuity", reinterpret_cast<getter>(AppBroadcastStreamAudioHeader_get_HasDiscontinuity), nullptr, nullptr, nullptr },
        { "relative_timestamp", reinterpret_cast<getter>(AppBroadcastStreamAudioHeader_get_RelativeTimestamp), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AppBroadcastStreamAudioHeader[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_AppBroadcastStreamAudioHeader) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AppBroadcastStreamAudioHeader) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AppBroadcastStreamAudioHeader) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AppBroadcastStreamAudioHeader) },
        { }
    };

    static PyType_Spec type_spec_AppBroadcastStreamAudioHeader = {
        "winrt._winrt_windows_media_capture.AppBroadcastStreamAudioHeader",
        sizeof(py::wrapper::Windows::Media::Capture::AppBroadcastStreamAudioHeader),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AppBroadcastStreamAudioHeader};

    // ----- AppBroadcastStreamReader class --------------------

    static PyObject* _new_AppBroadcastStreamReader(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Capture::AppBroadcastStreamReader>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Capture::AppBroadcastStreamReader>::type_name);
        return nullptr;
    }

    static void _dealloc_AppBroadcastStreamReader(py::wrapper::Windows::Media::Capture::AppBroadcastStreamReader* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AppBroadcastStreamReader_TryGetNextAudioFrame(py::wrapper::Windows::Media::Capture::AppBroadcastStreamReader* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Capture.AppBroadcastStreamReader", L"TryGetNextAudioFrame", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.TryGetNextAudioFrame());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppBroadcastStreamReader_TryGetNextVideoFrame(py::wrapper::Windows::Media::Capture::AppBroadcastStreamReader* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Capture.AppBroadcastStreamReader", L"TryGetNextVideoFrame", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.TryGetNextVideoFrame());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppBroadcastStreamReader_get_AudioAacSequence(py::wrapper::Windows::Media::Capture::AppBroadcastStreamReader* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastStreamReader", L"AudioAacSequence"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.AudioAacSequence());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBroadcastStreamReader_get_AudioBitrate(py::wrapper::Windows::Media::Capture::AppBroadcastStreamReader* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastStreamReader", L"AudioBitrate"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.AudioBitrate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBroadcastStreamReader_get_AudioChannels(py::wrapper::Windows::Media::Capture::AppBroadcastStreamReader* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastStreamReader", L"AudioChannels"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.AudioChannels());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBroadcastStreamReader_get_AudioSampleRate(py::wrapper::Windows::Media::Capture::AppBroadcastStreamReader* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastStreamReader", L"AudioSampleRate"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.AudioSampleRate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBroadcastStreamReader_get_VideoBitrate(py::wrapper::Windows::Media::Capture::AppBroadcastStreamReader* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastStreamReader", L"VideoBitrate"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.VideoBitrate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBroadcastStreamReader_get_VideoHeight(py::wrapper::Windows::Media::Capture::AppBroadcastStreamReader* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastStreamReader", L"VideoHeight"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.VideoHeight());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBroadcastStreamReader_get_VideoWidth(py::wrapper::Windows::Media::Capture::AppBroadcastStreamReader* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastStreamReader", L"VideoWidth"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.VideoWidth());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBroadcastStreamReader_add_AudioFrameArrived(py::wrapper::Windows::Media::Capture::AppBroadcastStreamReader* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Capture.AppBroadcastStreamReader", L"AudioFrameArrived"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Capture::AppBroadcastStreamReader, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.AudioFrameArrived(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBroadcastStreamReader_remove_AudioFrameArrived(py::wrapper::Windows::Media::Capture::AppBroadcastStreamReader* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Capture.AppBroadcastStreamReader", L"AudioFrameArrived"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.AudioFrameArrived(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBroadcastStreamReader_add_VideoFrameArrived(py::wrapper::Windows::Media::Capture::AppBroadcastStreamReader* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Capture.AppBroadcastStreamReader", L"VideoFrameArrived"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Capture::AppBroadcastStreamReader, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.VideoFrameArrived(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBroadcastStreamReader_remove_VideoFrameArrived(py::wrapper::Windows::Media::Capture::AppBroadcastStreamReader* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Capture.AppBroadcastStreamReader", L"VideoFrameArrived"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.VideoFrameArrived(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AppBroadcastStreamReader(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Capture::AppBroadcastStreamReader>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AppBroadcastStreamReader(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Capture::AppBroadcastStreamReader>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AppBroadcastStreamReader[] = {
        { "try_get_next_audio_frame", reinterpret_cast<PyCFunction>(AppBroadcastStreamReader_TryGetNextAudioFrame), METH_VARARGS, nullptr },
        { "try_get_next_video_frame", reinterpret_cast<PyCFunction>(AppBroadcastStreamReader_TryGetNextVideoFrame), METH_VARARGS, nullptr },
        { "add_audio_frame_arrived", reinterpret_cast<PyCFunction>(AppBroadcastStreamReader_add_AudioFrameArrived), METH_O, nullptr },
        { "remove_audio_frame_arrived", reinterpret_cast<PyCFunction>(AppBroadcastStreamReader_remove_AudioFrameArrived), METH_O, nullptr },
        { "add_video_frame_arrived", reinterpret_cast<PyCFunction>(AppBroadcastStreamReader_add_VideoFrameArrived), METH_O, nullptr },
        { "remove_video_frame_arrived", reinterpret_cast<PyCFunction>(AppBroadcastStreamReader_remove_VideoFrameArrived), METH_O, nullptr },
        { "_assign_array_", _assign_array_AppBroadcastStreamReader, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AppBroadcastStreamReader), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AppBroadcastStreamReader[] = {
        { "audio_aac_sequence", reinterpret_cast<getter>(AppBroadcastStreamReader_get_AudioAacSequence), nullptr, nullptr, nullptr },
        { "audio_bitrate", reinterpret_cast<getter>(AppBroadcastStreamReader_get_AudioBitrate), nullptr, nullptr, nullptr },
        { "audio_channels", reinterpret_cast<getter>(AppBroadcastStreamReader_get_AudioChannels), nullptr, nullptr, nullptr },
        { "audio_sample_rate", reinterpret_cast<getter>(AppBroadcastStreamReader_get_AudioSampleRate), nullptr, nullptr, nullptr },
        { "video_bitrate", reinterpret_cast<getter>(AppBroadcastStreamReader_get_VideoBitrate), nullptr, nullptr, nullptr },
        { "video_height", reinterpret_cast<getter>(AppBroadcastStreamReader_get_VideoHeight), nullptr, nullptr, nullptr },
        { "video_width", reinterpret_cast<getter>(AppBroadcastStreamReader_get_VideoWidth), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AppBroadcastStreamReader[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_AppBroadcastStreamReader) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AppBroadcastStreamReader) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AppBroadcastStreamReader) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AppBroadcastStreamReader) },
        { }
    };

    static PyType_Spec type_spec_AppBroadcastStreamReader = {
        "winrt._winrt_windows_media_capture.AppBroadcastStreamReader",
        sizeof(py::wrapper::Windows::Media::Capture::AppBroadcastStreamReader),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AppBroadcastStreamReader};

    // ----- AppBroadcastStreamStateChangedEventArgs class --------------------

    static PyObject* _new_AppBroadcastStreamStateChangedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Capture::AppBroadcastStreamStateChangedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Capture::AppBroadcastStreamStateChangedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_AppBroadcastStreamStateChangedEventArgs(py::wrapper::Windows::Media::Capture::AppBroadcastStreamStateChangedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AppBroadcastStreamStateChangedEventArgs_get_StreamState(py::wrapper::Windows::Media::Capture::AppBroadcastStreamStateChangedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastStreamStateChangedEventArgs", L"StreamState"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.StreamState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AppBroadcastStreamStateChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Capture::AppBroadcastStreamStateChangedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AppBroadcastStreamStateChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Capture::AppBroadcastStreamStateChangedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AppBroadcastStreamStateChangedEventArgs[] = {
        { "_assign_array_", _assign_array_AppBroadcastStreamStateChangedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AppBroadcastStreamStateChangedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AppBroadcastStreamStateChangedEventArgs[] = {
        { "stream_state", reinterpret_cast<getter>(AppBroadcastStreamStateChangedEventArgs_get_StreamState), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AppBroadcastStreamStateChangedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_AppBroadcastStreamStateChangedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AppBroadcastStreamStateChangedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AppBroadcastStreamStateChangedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AppBroadcastStreamStateChangedEventArgs) },
        { }
    };

    static PyType_Spec type_spec_AppBroadcastStreamStateChangedEventArgs = {
        "winrt._winrt_windows_media_capture.AppBroadcastStreamStateChangedEventArgs",
        sizeof(py::wrapper::Windows::Media::Capture::AppBroadcastStreamStateChangedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AppBroadcastStreamStateChangedEventArgs};

    // ----- AppBroadcastStreamVideoFrame class --------------------

    static PyObject* _new_AppBroadcastStreamVideoFrame(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Capture::AppBroadcastStreamVideoFrame>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Capture::AppBroadcastStreamVideoFrame>::type_name);
        return nullptr;
    }

    static void _dealloc_AppBroadcastStreamVideoFrame(py::wrapper::Windows::Media::Capture::AppBroadcastStreamVideoFrame* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AppBroadcastStreamVideoFrame_get_VideoBuffer(py::wrapper::Windows::Media::Capture::AppBroadcastStreamVideoFrame* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastStreamVideoFrame", L"VideoBuffer"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.VideoBuffer());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBroadcastStreamVideoFrame_get_VideoHeader(py::wrapper::Windows::Media::Capture::AppBroadcastStreamVideoFrame* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastStreamVideoFrame", L"VideoHeader"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.VideoHeader());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AppBroadcastStreamVideoFrame(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Capture::AppBroadcastStreamVideoFrame>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AppBroadcastStreamVideoFrame(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Capture::AppBroadcastStreamVideoFrame>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AppBroadcastStreamVideoFrame[] = {
        { "_assign_array_", _assign_array_AppBroadcastStreamVideoFrame, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AppBroadcastStreamVideoFrame), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AppBroadcastStreamVideoFrame[] = {
        { "video_buffer", reinterpret_cast<getter>(AppBroadcastStreamVideoFrame_get_VideoBuffer), nullptr, nullptr, nullptr },
        { "video_header", reinterpret_cast<getter>(AppBroadcastStreamVideoFrame_get_VideoHeader), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AppBroadcastStreamVideoFrame[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_AppBroadcastStreamVideoFrame) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AppBroadcastStreamVideoFrame) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AppBroadcastStreamVideoFrame) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AppBroadcastStreamVideoFrame) },
        { }
    };

    static PyType_Spec type_spec_AppBroadcastStreamVideoFrame = {
        "winrt._winrt_windows_media_capture.AppBroadcastStreamVideoFrame",
        sizeof(py::wrapper::Windows::Media::Capture::AppBroadcastStreamVideoFrame),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AppBroadcastStreamVideoFrame};

    // ----- AppBroadcastStreamVideoHeader class --------------------

    static PyObject* _new_AppBroadcastStreamVideoHeader(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Capture::AppBroadcastStreamVideoHeader>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Capture::AppBroadcastStreamVideoHeader>::type_name);
        return nullptr;
    }

    static void _dealloc_AppBroadcastStreamVideoHeader(py::wrapper::Windows::Media::Capture::AppBroadcastStreamVideoHeader* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AppBroadcastStreamVideoHeader_get_AbsoluteTimestamp(py::wrapper::Windows::Media::Capture::AppBroadcastStreamVideoHeader* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastStreamVideoHeader", L"AbsoluteTimestamp"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.AbsoluteTimestamp());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBroadcastStreamVideoHeader_get_Duration(py::wrapper::Windows::Media::Capture::AppBroadcastStreamVideoHeader* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastStreamVideoHeader", L"Duration"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Duration());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBroadcastStreamVideoHeader_get_FrameId(py::wrapper::Windows::Media::Capture::AppBroadcastStreamVideoHeader* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastStreamVideoHeader", L"FrameId"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.FrameId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBroadcastStreamVideoHeader_get_HasDiscontinuity(py::wrapper::Windows::Media::Capture::AppBroadcastStreamVideoHeader* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastStreamVideoHeader", L"HasDiscontinuity"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.HasDiscontinuity());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBroadcastStreamVideoHeader_get_IsKeyFrame(py::wrapper::Windows::Media::Capture::AppBroadcastStreamVideoHeader* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastStreamVideoHeader", L"IsKeyFrame"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsKeyFrame());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBroadcastStreamVideoHeader_get_RelativeTimestamp(py::wrapper::Windows::Media::Capture::AppBroadcastStreamVideoHeader* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastStreamVideoHeader", L"RelativeTimestamp"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.RelativeTimestamp());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AppBroadcastStreamVideoHeader(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Capture::AppBroadcastStreamVideoHeader>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AppBroadcastStreamVideoHeader(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Capture::AppBroadcastStreamVideoHeader>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AppBroadcastStreamVideoHeader[] = {
        { "_assign_array_", _assign_array_AppBroadcastStreamVideoHeader, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AppBroadcastStreamVideoHeader), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AppBroadcastStreamVideoHeader[] = {
        { "absolute_timestamp", reinterpret_cast<getter>(AppBroadcastStreamVideoHeader_get_AbsoluteTimestamp), nullptr, nullptr, nullptr },
        { "duration", reinterpret_cast<getter>(AppBroadcastStreamVideoHeader_get_Duration), nullptr, nullptr, nullptr },
        { "frame_id", reinterpret_cast<getter>(AppBroadcastStreamVideoHeader_get_FrameId), nullptr, nullptr, nullptr },
        { "has_discontinuity", reinterpret_cast<getter>(AppBroadcastStreamVideoHeader_get_HasDiscontinuity), nullptr, nullptr, nullptr },
        { "is_key_frame", reinterpret_cast<getter>(AppBroadcastStreamVideoHeader_get_IsKeyFrame), nullptr, nullptr, nullptr },
        { "relative_timestamp", reinterpret_cast<getter>(AppBroadcastStreamVideoHeader_get_RelativeTimestamp), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AppBroadcastStreamVideoHeader[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_AppBroadcastStreamVideoHeader) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AppBroadcastStreamVideoHeader) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AppBroadcastStreamVideoHeader) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AppBroadcastStreamVideoHeader) },
        { }
    };

    static PyType_Spec type_spec_AppBroadcastStreamVideoHeader = {
        "winrt._winrt_windows_media_capture.AppBroadcastStreamVideoHeader",
        sizeof(py::wrapper::Windows::Media::Capture::AppBroadcastStreamVideoHeader),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AppBroadcastStreamVideoHeader};

    // ----- AppBroadcastTriggerDetails class --------------------

    static PyObject* _new_AppBroadcastTriggerDetails(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Capture::AppBroadcastTriggerDetails>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Capture::AppBroadcastTriggerDetails>::type_name);
        return nullptr;
    }

    static void _dealloc_AppBroadcastTriggerDetails(py::wrapper::Windows::Media::Capture::AppBroadcastTriggerDetails* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AppBroadcastTriggerDetails_get_BackgroundService(py::wrapper::Windows::Media::Capture::AppBroadcastTriggerDetails* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastTriggerDetails", L"BackgroundService"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.BackgroundService());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AppBroadcastTriggerDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Capture::AppBroadcastTriggerDetails>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AppBroadcastTriggerDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Capture::AppBroadcastTriggerDetails>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AppBroadcastTriggerDetails[] = {
        { "_assign_array_", _assign_array_AppBroadcastTriggerDetails, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AppBroadcastTriggerDetails), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AppBroadcastTriggerDetails[] = {
        { "background_service", reinterpret_cast<getter>(AppBroadcastTriggerDetails_get_BackgroundService), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AppBroadcastTriggerDetails[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_AppBroadcastTriggerDetails) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AppBroadcastTriggerDetails) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AppBroadcastTriggerDetails) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AppBroadcastTriggerDetails) },
        { }
    };

    static PyType_Spec type_spec_AppBroadcastTriggerDetails = {
        "winrt._winrt_windows_media_capture.AppBroadcastTriggerDetails",
        sizeof(py::wrapper::Windows::Media::Capture::AppBroadcastTriggerDetails),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AppBroadcastTriggerDetails};

    // ----- AppBroadcastViewerCountChangedEventArgs class --------------------

    static PyObject* _new_AppBroadcastViewerCountChangedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Capture::AppBroadcastViewerCountChangedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Capture::AppBroadcastViewerCountChangedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_AppBroadcastViewerCountChangedEventArgs(py::wrapper::Windows::Media::Capture::AppBroadcastViewerCountChangedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AppBroadcastViewerCountChangedEventArgs_get_ViewerCount(py::wrapper::Windows::Media::Capture::AppBroadcastViewerCountChangedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppBroadcastViewerCountChangedEventArgs", L"ViewerCount"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ViewerCount());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AppBroadcastViewerCountChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Capture::AppBroadcastViewerCountChangedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AppBroadcastViewerCountChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Capture::AppBroadcastViewerCountChangedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AppBroadcastViewerCountChangedEventArgs[] = {
        { "_assign_array_", _assign_array_AppBroadcastViewerCountChangedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AppBroadcastViewerCountChangedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AppBroadcastViewerCountChangedEventArgs[] = {
        { "viewer_count", reinterpret_cast<getter>(AppBroadcastViewerCountChangedEventArgs_get_ViewerCount), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AppBroadcastViewerCountChangedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_AppBroadcastViewerCountChangedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AppBroadcastViewerCountChangedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AppBroadcastViewerCountChangedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AppBroadcastViewerCountChangedEventArgs) },
        { }
    };

    static PyType_Spec type_spec_AppBroadcastViewerCountChangedEventArgs = {
        "winrt._winrt_windows_media_capture.AppBroadcastViewerCountChangedEventArgs",
        sizeof(py::wrapper::Windows::Media::Capture::AppBroadcastViewerCountChangedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AppBroadcastViewerCountChangedEventArgs};

    // ----- AppCapture class --------------------

    static PyObject* _new_AppCapture(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Capture::AppCapture>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Capture::AppCapture>::type_name);
        return nullptr;
    }

    static void _dealloc_AppCapture(py::wrapper::Windows::Media::Capture::AppCapture* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AppCapture_GetForCurrentView(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Capture.AppCapture", L"GetForCurrentView", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(winrt::Windows::Media::Capture::AppCapture::GetForCurrentView());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppCapture_SetAllowedAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Capture.AppCapture", L"SetAllowedAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<bool>(args, 0);

                return py::convert(winrt::Windows::Media::Capture::AppCapture::SetAllowedAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppCapture_get_IsCapturingAudio(py::wrapper::Windows::Media::Capture::AppCapture* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppCapture", L"IsCapturingAudio"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsCapturingAudio());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppCapture_get_IsCapturingVideo(py::wrapper::Windows::Media::Capture::AppCapture* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppCapture", L"IsCapturingVideo"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsCapturingVideo());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppCapture_add_CapturingChanged(py::wrapper::Windows::Media::Capture::AppCapture* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Capture.AppCapture", L"CapturingChanged"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Capture::AppCapture, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.CapturingChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppCapture_remove_CapturingChanged(py::wrapper::Windows::Media::Capture::AppCapture* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Capture.AppCapture", L"CapturingChanged"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.CapturingChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AppCapture(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Capture::AppCapture>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AppCapture(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Capture::AppCapture>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AppCapture[] = {
        { "add_capturing_changed", reinterpret_cast<PyCFunction>(AppCapture_add_CapturingChanged), METH_O, nullptr },
        { "remove_capturing_changed", reinterpret_cast<PyCFunction>(AppCapture_remove_CapturingChanged), METH_O, nullptr },
        { "_assign_array_", _assign_array_AppCapture, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AppCapture), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AppCapture[] = {
        { "is_capturing_audio", reinterpret_cast<getter>(AppCapture_get_IsCapturingAudio), nullptr, nullptr, nullptr },
        { "is_capturing_video", reinterpret_cast<getter>(AppCapture_get_IsCapturingVideo), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AppCapture[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_AppCapture) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AppCapture) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AppCapture) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AppCapture) },
        { }
    };

    static PyType_Spec type_spec_AppCapture = {
        "winrt._winrt_windows_media_capture.AppCapture",
        sizeof(py::wrapper::Windows::Media::Capture::AppCapture),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AppCapture};

    static PyGetSetDef getset_AppCapture_Static[] = {
        { }
    };

    static PyMethodDef methods_AppCapture_Static[] = {
        { "get_for_current_view", reinterpret_cast<PyCFunction>(AppCapture_GetForCurrentView), METH_VARARGS, nullptr },
        { "set_allowed_async", reinterpret_cast<PyCFunction>(AppCapture_SetAllowedAsync), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_AppCapture_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_AppCapture_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_AppCapture_Static) },
        { }
    };

    static PyType_Spec type_spec_AppCapture_Static =
    {
        "winrt._winrt_windows_media_capture.AppCapture_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_AppCapture_Static
    };

    // ----- AppCaptureAlternateShortcutKeys class --------------------

    static PyObject* _new_AppCaptureAlternateShortcutKeys(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Capture::AppCaptureAlternateShortcutKeys>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Capture::AppCaptureAlternateShortcutKeys>::type_name);
        return nullptr;
    }

    static void _dealloc_AppCaptureAlternateShortcutKeys(py::wrapper::Windows::Media::Capture::AppCaptureAlternateShortcutKeys* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AppCaptureAlternateShortcutKeys_get_ToggleRecordingKeyModifiers(py::wrapper::Windows::Media::Capture::AppCaptureAlternateShortcutKeys* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppCaptureAlternateShortcutKeys", L"ToggleRecordingKeyModifiers"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ToggleRecordingKeyModifiers());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppCaptureAlternateShortcutKeys_put_ToggleRecordingKeyModifiers(py::wrapper::Windows::Media::Capture::AppCaptureAlternateShortcutKeys* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppCaptureAlternateShortcutKeys", L"ToggleRecordingKeyModifiers"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::System::VirtualKeyModifiers>(arg);

            self->obj.ToggleRecordingKeyModifiers(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppCaptureAlternateShortcutKeys_get_ToggleRecordingKey(py::wrapper::Windows::Media::Capture::AppCaptureAlternateShortcutKeys* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppCaptureAlternateShortcutKeys", L"ToggleRecordingKey"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ToggleRecordingKey());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppCaptureAlternateShortcutKeys_put_ToggleRecordingKey(py::wrapper::Windows::Media::Capture::AppCaptureAlternateShortcutKeys* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppCaptureAlternateShortcutKeys", L"ToggleRecordingKey"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::System::VirtualKey>(arg);

            self->obj.ToggleRecordingKey(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppCaptureAlternateShortcutKeys_get_ToggleRecordingIndicatorKeyModifiers(py::wrapper::Windows::Media::Capture::AppCaptureAlternateShortcutKeys* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppCaptureAlternateShortcutKeys", L"ToggleRecordingIndicatorKeyModifiers"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ToggleRecordingIndicatorKeyModifiers());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppCaptureAlternateShortcutKeys_put_ToggleRecordingIndicatorKeyModifiers(py::wrapper::Windows::Media::Capture::AppCaptureAlternateShortcutKeys* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppCaptureAlternateShortcutKeys", L"ToggleRecordingIndicatorKeyModifiers"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::System::VirtualKeyModifiers>(arg);

            self->obj.ToggleRecordingIndicatorKeyModifiers(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppCaptureAlternateShortcutKeys_get_ToggleRecordingIndicatorKey(py::wrapper::Windows::Media::Capture::AppCaptureAlternateShortcutKeys* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppCaptureAlternateShortcutKeys", L"ToggleRecordingIndicatorKey"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ToggleRecordingIndicatorKey());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppCaptureAlternateShortcutKeys_put_ToggleRecordingIndicatorKey(py::wrapper::Windows::Media::Capture::AppCaptureAlternateShortcutKeys* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppCaptureAlternateShortcutKeys", L"ToggleRecordingIndicatorKey"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::System::VirtualKey>(arg);

            self->obj.ToggleRecordingIndicatorKey(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppCaptureAlternateShortcutKeys_get_ToggleGameBarKeyModifiers(py::wrapper::Windows::Media::Capture::AppCaptureAlternateShortcutKeys* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppCaptureAlternateShortcutKeys", L"ToggleGameBarKeyModifiers"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ToggleGameBarKeyModifiers());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppCaptureAlternateShortcutKeys_put_ToggleGameBarKeyModifiers(py::wrapper::Windows::Media::Capture::AppCaptureAlternateShortcutKeys* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppCaptureAlternateShortcutKeys", L"ToggleGameBarKeyModifiers"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::System::VirtualKeyModifiers>(arg);

            self->obj.ToggleGameBarKeyModifiers(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppCaptureAlternateShortcutKeys_get_ToggleGameBarKey(py::wrapper::Windows::Media::Capture::AppCaptureAlternateShortcutKeys* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppCaptureAlternateShortcutKeys", L"ToggleGameBarKey"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ToggleGameBarKey());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppCaptureAlternateShortcutKeys_put_ToggleGameBarKey(py::wrapper::Windows::Media::Capture::AppCaptureAlternateShortcutKeys* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppCaptureAlternateShortcutKeys", L"ToggleGameBarKey"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::System::VirtualKey>(arg);

            self->obj.ToggleGameBarKey(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppCaptureAlternateShortcutKeys_get_TakeScreenshotKeyModifiers(py::wrapper::Windows::Media::Capture::AppCaptureAlternateShortcutKeys* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppCaptureAlternateShortcutKeys", L"TakeScreenshotKeyModifiers"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.TakeScreenshotKeyModifiers());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppCaptureAlternateShortcutKeys_put_TakeScreenshotKeyModifiers(py::wrapper::Windows::Media::Capture::AppCaptureAlternateShortcutKeys* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppCaptureAlternateShortcutKeys", L"TakeScreenshotKeyModifiers"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::System::VirtualKeyModifiers>(arg);

            self->obj.TakeScreenshotKeyModifiers(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppCaptureAlternateShortcutKeys_get_TakeScreenshotKey(py::wrapper::Windows::Media::Capture::AppCaptureAlternateShortcutKeys* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppCaptureAlternateShortcutKeys", L"TakeScreenshotKey"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.TakeScreenshotKey());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppCaptureAlternateShortcutKeys_put_TakeScreenshotKey(py::wrapper::Windows::Media::Capture::AppCaptureAlternateShortcutKeys* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppCaptureAlternateShortcutKeys", L"TakeScreenshotKey"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::System::VirtualKey>(arg);

            self->obj.TakeScreenshotKey(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppCaptureAlternateShortcutKeys_get_SaveHistoricalVideoKeyModifiers(py::wrapper::Windows::Media::Capture::AppCaptureAlternateShortcutKeys* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppCaptureAlternateShortcutKeys", L"SaveHistoricalVideoKeyModifiers"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SaveHistoricalVideoKeyModifiers());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppCaptureAlternateShortcutKeys_put_SaveHistoricalVideoKeyModifiers(py::wrapper::Windows::Media::Capture::AppCaptureAlternateShortcutKeys* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppCaptureAlternateShortcutKeys", L"SaveHistoricalVideoKeyModifiers"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::System::VirtualKeyModifiers>(arg);

            self->obj.SaveHistoricalVideoKeyModifiers(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppCaptureAlternateShortcutKeys_get_SaveHistoricalVideoKey(py::wrapper::Windows::Media::Capture::AppCaptureAlternateShortcutKeys* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppCaptureAlternateShortcutKeys", L"SaveHistoricalVideoKey"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SaveHistoricalVideoKey());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppCaptureAlternateShortcutKeys_put_SaveHistoricalVideoKey(py::wrapper::Windows::Media::Capture::AppCaptureAlternateShortcutKeys* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppCaptureAlternateShortcutKeys", L"SaveHistoricalVideoKey"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::System::VirtualKey>(arg);

            self->obj.SaveHistoricalVideoKey(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppCaptureAlternateShortcutKeys_get_ToggleMicrophoneCaptureKeyModifiers(py::wrapper::Windows::Media::Capture::AppCaptureAlternateShortcutKeys* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppCaptureAlternateShortcutKeys", L"ToggleMicrophoneCaptureKeyModifiers"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ToggleMicrophoneCaptureKeyModifiers());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppCaptureAlternateShortcutKeys_put_ToggleMicrophoneCaptureKeyModifiers(py::wrapper::Windows::Media::Capture::AppCaptureAlternateShortcutKeys* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppCaptureAlternateShortcutKeys", L"ToggleMicrophoneCaptureKeyModifiers"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::System::VirtualKeyModifiers>(arg);

            self->obj.ToggleMicrophoneCaptureKeyModifiers(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppCaptureAlternateShortcutKeys_get_ToggleMicrophoneCaptureKey(py::wrapper::Windows::Media::Capture::AppCaptureAlternateShortcutKeys* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppCaptureAlternateShortcutKeys", L"ToggleMicrophoneCaptureKey"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ToggleMicrophoneCaptureKey());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppCaptureAlternateShortcutKeys_put_ToggleMicrophoneCaptureKey(py::wrapper::Windows::Media::Capture::AppCaptureAlternateShortcutKeys* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppCaptureAlternateShortcutKeys", L"ToggleMicrophoneCaptureKey"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::System::VirtualKey>(arg);

            self->obj.ToggleMicrophoneCaptureKey(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppCaptureAlternateShortcutKeys_get_ToggleCameraCaptureKeyModifiers(py::wrapper::Windows::Media::Capture::AppCaptureAlternateShortcutKeys* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppCaptureAlternateShortcutKeys", L"ToggleCameraCaptureKeyModifiers"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ToggleCameraCaptureKeyModifiers());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppCaptureAlternateShortcutKeys_put_ToggleCameraCaptureKeyModifiers(py::wrapper::Windows::Media::Capture::AppCaptureAlternateShortcutKeys* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppCaptureAlternateShortcutKeys", L"ToggleCameraCaptureKeyModifiers"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::System::VirtualKeyModifiers>(arg);

            self->obj.ToggleCameraCaptureKeyModifiers(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppCaptureAlternateShortcutKeys_get_ToggleCameraCaptureKey(py::wrapper::Windows::Media::Capture::AppCaptureAlternateShortcutKeys* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppCaptureAlternateShortcutKeys", L"ToggleCameraCaptureKey"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ToggleCameraCaptureKey());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppCaptureAlternateShortcutKeys_put_ToggleCameraCaptureKey(py::wrapper::Windows::Media::Capture::AppCaptureAlternateShortcutKeys* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppCaptureAlternateShortcutKeys", L"ToggleCameraCaptureKey"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::System::VirtualKey>(arg);

            self->obj.ToggleCameraCaptureKey(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppCaptureAlternateShortcutKeys_get_ToggleBroadcastKeyModifiers(py::wrapper::Windows::Media::Capture::AppCaptureAlternateShortcutKeys* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppCaptureAlternateShortcutKeys", L"ToggleBroadcastKeyModifiers"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ToggleBroadcastKeyModifiers());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppCaptureAlternateShortcutKeys_put_ToggleBroadcastKeyModifiers(py::wrapper::Windows::Media::Capture::AppCaptureAlternateShortcutKeys* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppCaptureAlternateShortcutKeys", L"ToggleBroadcastKeyModifiers"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::System::VirtualKeyModifiers>(arg);

            self->obj.ToggleBroadcastKeyModifiers(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppCaptureAlternateShortcutKeys_get_ToggleBroadcastKey(py::wrapper::Windows::Media::Capture::AppCaptureAlternateShortcutKeys* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppCaptureAlternateShortcutKeys", L"ToggleBroadcastKey"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ToggleBroadcastKey());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppCaptureAlternateShortcutKeys_put_ToggleBroadcastKey(py::wrapper::Windows::Media::Capture::AppCaptureAlternateShortcutKeys* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppCaptureAlternateShortcutKeys", L"ToggleBroadcastKey"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::System::VirtualKey>(arg);

            self->obj.ToggleBroadcastKey(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_AppCaptureAlternateShortcutKeys(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Capture::AppCaptureAlternateShortcutKeys>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AppCaptureAlternateShortcutKeys(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Capture::AppCaptureAlternateShortcutKeys>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AppCaptureAlternateShortcutKeys[] = {
        { "_assign_array_", _assign_array_AppCaptureAlternateShortcutKeys, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AppCaptureAlternateShortcutKeys), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AppCaptureAlternateShortcutKeys[] = {
        { "toggle_recording_key_modifiers", reinterpret_cast<getter>(AppCaptureAlternateShortcutKeys_get_ToggleRecordingKeyModifiers), reinterpret_cast<setter>(AppCaptureAlternateShortcutKeys_put_ToggleRecordingKeyModifiers), nullptr, nullptr },
        { "toggle_recording_key", reinterpret_cast<getter>(AppCaptureAlternateShortcutKeys_get_ToggleRecordingKey), reinterpret_cast<setter>(AppCaptureAlternateShortcutKeys_put_ToggleRecordingKey), nullptr, nullptr },
        { "toggle_recording_indicator_key_modifiers", reinterpret_cast<getter>(AppCaptureAlternateShortcutKeys_get_ToggleRecordingIndicatorKeyModifiers), reinterpret_cast<setter>(AppCaptureAlternateShortcutKeys_put_ToggleRecordingIndicatorKeyModifiers), nullptr, nullptr },
        { "toggle_recording_indicator_key", reinterpret_cast<getter>(AppCaptureAlternateShortcutKeys_get_ToggleRecordingIndicatorKey), reinterpret_cast<setter>(AppCaptureAlternateShortcutKeys_put_ToggleRecordingIndicatorKey), nullptr, nullptr },
        { "toggle_game_bar_key_modifiers", reinterpret_cast<getter>(AppCaptureAlternateShortcutKeys_get_ToggleGameBarKeyModifiers), reinterpret_cast<setter>(AppCaptureAlternateShortcutKeys_put_ToggleGameBarKeyModifiers), nullptr, nullptr },
        { "toggle_game_bar_key", reinterpret_cast<getter>(AppCaptureAlternateShortcutKeys_get_ToggleGameBarKey), reinterpret_cast<setter>(AppCaptureAlternateShortcutKeys_put_ToggleGameBarKey), nullptr, nullptr },
        { "take_screenshot_key_modifiers", reinterpret_cast<getter>(AppCaptureAlternateShortcutKeys_get_TakeScreenshotKeyModifiers), reinterpret_cast<setter>(AppCaptureAlternateShortcutKeys_put_TakeScreenshotKeyModifiers), nullptr, nullptr },
        { "take_screenshot_key", reinterpret_cast<getter>(AppCaptureAlternateShortcutKeys_get_TakeScreenshotKey), reinterpret_cast<setter>(AppCaptureAlternateShortcutKeys_put_TakeScreenshotKey), nullptr, nullptr },
        { "save_historical_video_key_modifiers", reinterpret_cast<getter>(AppCaptureAlternateShortcutKeys_get_SaveHistoricalVideoKeyModifiers), reinterpret_cast<setter>(AppCaptureAlternateShortcutKeys_put_SaveHistoricalVideoKeyModifiers), nullptr, nullptr },
        { "save_historical_video_key", reinterpret_cast<getter>(AppCaptureAlternateShortcutKeys_get_SaveHistoricalVideoKey), reinterpret_cast<setter>(AppCaptureAlternateShortcutKeys_put_SaveHistoricalVideoKey), nullptr, nullptr },
        { "toggle_microphone_capture_key_modifiers", reinterpret_cast<getter>(AppCaptureAlternateShortcutKeys_get_ToggleMicrophoneCaptureKeyModifiers), reinterpret_cast<setter>(AppCaptureAlternateShortcutKeys_put_ToggleMicrophoneCaptureKeyModifiers), nullptr, nullptr },
        { "toggle_microphone_capture_key", reinterpret_cast<getter>(AppCaptureAlternateShortcutKeys_get_ToggleMicrophoneCaptureKey), reinterpret_cast<setter>(AppCaptureAlternateShortcutKeys_put_ToggleMicrophoneCaptureKey), nullptr, nullptr },
        { "toggle_camera_capture_key_modifiers", reinterpret_cast<getter>(AppCaptureAlternateShortcutKeys_get_ToggleCameraCaptureKeyModifiers), reinterpret_cast<setter>(AppCaptureAlternateShortcutKeys_put_ToggleCameraCaptureKeyModifiers), nullptr, nullptr },
        { "toggle_camera_capture_key", reinterpret_cast<getter>(AppCaptureAlternateShortcutKeys_get_ToggleCameraCaptureKey), reinterpret_cast<setter>(AppCaptureAlternateShortcutKeys_put_ToggleCameraCaptureKey), nullptr, nullptr },
        { "toggle_broadcast_key_modifiers", reinterpret_cast<getter>(AppCaptureAlternateShortcutKeys_get_ToggleBroadcastKeyModifiers), reinterpret_cast<setter>(AppCaptureAlternateShortcutKeys_put_ToggleBroadcastKeyModifiers), nullptr, nullptr },
        { "toggle_broadcast_key", reinterpret_cast<getter>(AppCaptureAlternateShortcutKeys_get_ToggleBroadcastKey), reinterpret_cast<setter>(AppCaptureAlternateShortcutKeys_put_ToggleBroadcastKey), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AppCaptureAlternateShortcutKeys[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_AppCaptureAlternateShortcutKeys) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AppCaptureAlternateShortcutKeys) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AppCaptureAlternateShortcutKeys) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AppCaptureAlternateShortcutKeys) },
        { }
    };

    static PyType_Spec type_spec_AppCaptureAlternateShortcutKeys = {
        "winrt._winrt_windows_media_capture.AppCaptureAlternateShortcutKeys",
        sizeof(py::wrapper::Windows::Media::Capture::AppCaptureAlternateShortcutKeys),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AppCaptureAlternateShortcutKeys};

    // ----- AppCaptureDurationGeneratedEventArgs class --------------------

    static PyObject* _new_AppCaptureDurationGeneratedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Capture::AppCaptureDurationGeneratedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Capture::AppCaptureDurationGeneratedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_AppCaptureDurationGeneratedEventArgs(py::wrapper::Windows::Media::Capture::AppCaptureDurationGeneratedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AppCaptureDurationGeneratedEventArgs_get_Duration(py::wrapper::Windows::Media::Capture::AppCaptureDurationGeneratedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppCaptureDurationGeneratedEventArgs", L"Duration"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Duration());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AppCaptureDurationGeneratedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Capture::AppCaptureDurationGeneratedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AppCaptureDurationGeneratedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Capture::AppCaptureDurationGeneratedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AppCaptureDurationGeneratedEventArgs[] = {
        { "_assign_array_", _assign_array_AppCaptureDurationGeneratedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AppCaptureDurationGeneratedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AppCaptureDurationGeneratedEventArgs[] = {
        { "duration", reinterpret_cast<getter>(AppCaptureDurationGeneratedEventArgs_get_Duration), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AppCaptureDurationGeneratedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_AppCaptureDurationGeneratedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AppCaptureDurationGeneratedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AppCaptureDurationGeneratedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AppCaptureDurationGeneratedEventArgs) },
        { }
    };

    static PyType_Spec type_spec_AppCaptureDurationGeneratedEventArgs = {
        "winrt._winrt_windows_media_capture.AppCaptureDurationGeneratedEventArgs",
        sizeof(py::wrapper::Windows::Media::Capture::AppCaptureDurationGeneratedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AppCaptureDurationGeneratedEventArgs};

    // ----- AppCaptureFileGeneratedEventArgs class --------------------

    static PyObject* _new_AppCaptureFileGeneratedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Capture::AppCaptureFileGeneratedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Capture::AppCaptureFileGeneratedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_AppCaptureFileGeneratedEventArgs(py::wrapper::Windows::Media::Capture::AppCaptureFileGeneratedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AppCaptureFileGeneratedEventArgs_get_File(py::wrapper::Windows::Media::Capture::AppCaptureFileGeneratedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppCaptureFileGeneratedEventArgs", L"File"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.File());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AppCaptureFileGeneratedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Capture::AppCaptureFileGeneratedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AppCaptureFileGeneratedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Capture::AppCaptureFileGeneratedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AppCaptureFileGeneratedEventArgs[] = {
        { "_assign_array_", _assign_array_AppCaptureFileGeneratedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AppCaptureFileGeneratedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AppCaptureFileGeneratedEventArgs[] = {
        { "file", reinterpret_cast<getter>(AppCaptureFileGeneratedEventArgs_get_File), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AppCaptureFileGeneratedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_AppCaptureFileGeneratedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AppCaptureFileGeneratedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AppCaptureFileGeneratedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AppCaptureFileGeneratedEventArgs) },
        { }
    };

    static PyType_Spec type_spec_AppCaptureFileGeneratedEventArgs = {
        "winrt._winrt_windows_media_capture.AppCaptureFileGeneratedEventArgs",
        sizeof(py::wrapper::Windows::Media::Capture::AppCaptureFileGeneratedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AppCaptureFileGeneratedEventArgs};

    // ----- AppCaptureManager class --------------------

    static PyObject* _new_AppCaptureManager(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Capture::AppCaptureManager>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Capture::AppCaptureManager>::type_name);
        return nullptr;
    }

    static PyObject* AppCaptureManager_ApplySettings(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Capture.AppCaptureManager", L"ApplySettings", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Media::Capture::AppCaptureSettings>(args, 0);

                winrt::Windows::Media::Capture::AppCaptureManager::ApplySettings(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppCaptureManager_GetCurrentSettings(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Capture.AppCaptureManager", L"GetCurrentSettings", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(winrt::Windows::Media::Capture::AppCaptureManager::GetCurrentSettings());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyMethodDef _methods_AppCaptureManager[] = {
        { }
    };

    static PyGetSetDef _getset_AppCaptureManager[] = {
        { }
    };

    static PyType_Slot _type_slots_AppCaptureManager[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_AppCaptureManager) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AppCaptureManager) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AppCaptureManager) },
        { }
    };

    static PyType_Spec type_spec_AppCaptureManager = {
        "winrt._winrt_windows_media_capture.AppCaptureManager",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AppCaptureManager};

    static PyGetSetDef getset_AppCaptureManager_Static[] = {
        { }
    };

    static PyMethodDef methods_AppCaptureManager_Static[] = {
        { "apply_settings", reinterpret_cast<PyCFunction>(AppCaptureManager_ApplySettings), METH_VARARGS, nullptr },
        { "get_current_settings", reinterpret_cast<PyCFunction>(AppCaptureManager_GetCurrentSettings), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_AppCaptureManager_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_AppCaptureManager_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_AppCaptureManager_Static) },
        { }
    };

    static PyType_Spec type_spec_AppCaptureManager_Static =
    {
        "winrt._winrt_windows_media_capture.AppCaptureManager_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_AppCaptureManager_Static
    };

    // ----- AppCaptureMetadataWriter class --------------------

    static PyObject* _new_AppCaptureMetadataWriter(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Media::Capture::AppCaptureMetadataWriter instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_AppCaptureMetadataWriter(py::wrapper::Windows::Media::Capture::AppCaptureMetadataWriter* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AppCaptureMetadataWriter_AddDoubleEvent(py::wrapper::Windows::Media::Capture::AppCaptureMetadataWriter* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Capture.AppCaptureMetadataWriter", L"AddDoubleEvent", 3))
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<double>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Media::Capture::AppCaptureMetadataPriority>(args, 2);

                self->obj.AddDoubleEvent(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppCaptureMetadataWriter_AddInt32Event(py::wrapper::Windows::Media::Capture::AppCaptureMetadataWriter* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Capture.AppCaptureMetadataWriter", L"AddInt32Event", 3))
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<int32_t>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Media::Capture::AppCaptureMetadataPriority>(args, 2);

                self->obj.AddInt32Event(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppCaptureMetadataWriter_AddStringEvent(py::wrapper::Windows::Media::Capture::AppCaptureMetadataWriter* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Capture.AppCaptureMetadataWriter", L"AddStringEvent", 3))
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Media::Capture::AppCaptureMetadataPriority>(args, 2);

                self->obj.AddStringEvent(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppCaptureMetadataWriter_Close(py::wrapper::Windows::Media::Capture::AppCaptureMetadataWriter* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Capture.AppCaptureMetadataWriter", L"Close", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppCaptureMetadataWriter_StartDoubleState(py::wrapper::Windows::Media::Capture::AppCaptureMetadataWriter* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Capture.AppCaptureMetadataWriter", L"StartDoubleState", 3))
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<double>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Media::Capture::AppCaptureMetadataPriority>(args, 2);

                self->obj.StartDoubleState(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppCaptureMetadataWriter_StartInt32State(py::wrapper::Windows::Media::Capture::AppCaptureMetadataWriter* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Capture.AppCaptureMetadataWriter", L"StartInt32State", 3))
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<int32_t>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Media::Capture::AppCaptureMetadataPriority>(args, 2);

                self->obj.StartInt32State(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppCaptureMetadataWriter_StartStringState(py::wrapper::Windows::Media::Capture::AppCaptureMetadataWriter* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Capture.AppCaptureMetadataWriter", L"StartStringState", 3))
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Media::Capture::AppCaptureMetadataPriority>(args, 2);

                self->obj.StartStringState(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppCaptureMetadataWriter_StopAllStates(py::wrapper::Windows::Media::Capture::AppCaptureMetadataWriter* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Capture.AppCaptureMetadataWriter", L"StopAllStates", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.StopAllStates();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppCaptureMetadataWriter_StopState(py::wrapper::Windows::Media::Capture::AppCaptureMetadataWriter* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Capture.AppCaptureMetadataWriter", L"StopState", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                self->obj.StopState(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppCaptureMetadataWriter_get_RemainingStorageBytesAvailable(py::wrapper::Windows::Media::Capture::AppCaptureMetadataWriter* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppCaptureMetadataWriter", L"RemainingStorageBytesAvailable"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.RemainingStorageBytesAvailable());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppCaptureMetadataWriter_add_MetadataPurged(py::wrapper::Windows::Media::Capture::AppCaptureMetadataWriter* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Capture.AppCaptureMetadataWriter", L"MetadataPurged"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Capture::AppCaptureMetadataWriter, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.MetadataPurged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppCaptureMetadataWriter_remove_MetadataPurged(py::wrapper::Windows::Media::Capture::AppCaptureMetadataWriter* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Capture.AppCaptureMetadataWriter", L"MetadataPurged"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.MetadataPurged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AppCaptureMetadataWriter(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Capture::AppCaptureMetadataWriter>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AppCaptureMetadataWriter(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Capture::AppCaptureMetadataWriter>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_AppCaptureMetadataWriter(py::wrapper::Windows::Media::Capture::AppCaptureMetadataWriter* self, PyObject* /*unused*/) noexcept
    {
        return Py_NewRef(self);
    }

    static PyObject* _exit_AppCaptureMetadataWriter(py::wrapper::Windows::Media::Capture::AppCaptureMetadataWriter* self, PyObject* /*unused*/) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AppCaptureMetadataWriter[] = {
        { "add_double_event", reinterpret_cast<PyCFunction>(AppCaptureMetadataWriter_AddDoubleEvent), METH_VARARGS, nullptr },
        { "add_int32_event", reinterpret_cast<PyCFunction>(AppCaptureMetadataWriter_AddInt32Event), METH_VARARGS, nullptr },
        { "add_string_event", reinterpret_cast<PyCFunction>(AppCaptureMetadataWriter_AddStringEvent), METH_VARARGS, nullptr },
        { "close", reinterpret_cast<PyCFunction>(AppCaptureMetadataWriter_Close), METH_VARARGS, nullptr },
        { "start_double_state", reinterpret_cast<PyCFunction>(AppCaptureMetadataWriter_StartDoubleState), METH_VARARGS, nullptr },
        { "start_int32_state", reinterpret_cast<PyCFunction>(AppCaptureMetadataWriter_StartInt32State), METH_VARARGS, nullptr },
        { "start_string_state", reinterpret_cast<PyCFunction>(AppCaptureMetadataWriter_StartStringState), METH_VARARGS, nullptr },
        { "stop_all_states", reinterpret_cast<PyCFunction>(AppCaptureMetadataWriter_StopAllStates), METH_VARARGS, nullptr },
        { "stop_state", reinterpret_cast<PyCFunction>(AppCaptureMetadataWriter_StopState), METH_VARARGS, nullptr },
        { "add_metadata_purged", reinterpret_cast<PyCFunction>(AppCaptureMetadataWriter_add_MetadataPurged), METH_O, nullptr },
        { "remove_metadata_purged", reinterpret_cast<PyCFunction>(AppCaptureMetadataWriter_remove_MetadataPurged), METH_O, nullptr },
        { "_assign_array_", _assign_array_AppCaptureMetadataWriter, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AppCaptureMetadataWriter), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_AppCaptureMetadataWriter), METH_NOARGS, nullptr },
        { "__exit__", reinterpret_cast<PyCFunction>(_exit_AppCaptureMetadataWriter), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_AppCaptureMetadataWriter[] = {
        { "remaining_storage_bytes_available", reinterpret_cast<getter>(AppCaptureMetadataWriter_get_RemainingStorageBytesAvailable), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AppCaptureMetadataWriter[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_AppCaptureMetadataWriter) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AppCaptureMetadataWriter) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AppCaptureMetadataWriter) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AppCaptureMetadataWriter) },
        { }
    };

    static PyType_Spec type_spec_AppCaptureMetadataWriter = {
        "winrt._winrt_windows_media_capture.AppCaptureMetadataWriter",
        sizeof(py::wrapper::Windows::Media::Capture::AppCaptureMetadataWriter),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AppCaptureMetadataWriter};

    // ----- AppCaptureMicrophoneCaptureStateChangedEventArgs class --------------------

    static PyObject* _new_AppCaptureMicrophoneCaptureStateChangedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Capture::AppCaptureMicrophoneCaptureStateChangedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Capture::AppCaptureMicrophoneCaptureStateChangedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_AppCaptureMicrophoneCaptureStateChangedEventArgs(py::wrapper::Windows::Media::Capture::AppCaptureMicrophoneCaptureStateChangedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AppCaptureMicrophoneCaptureStateChangedEventArgs_get_ErrorCode(py::wrapper::Windows::Media::Capture::AppCaptureMicrophoneCaptureStateChangedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppCaptureMicrophoneCaptureStateChangedEventArgs", L"ErrorCode"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ErrorCode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppCaptureMicrophoneCaptureStateChangedEventArgs_get_State(py::wrapper::Windows::Media::Capture::AppCaptureMicrophoneCaptureStateChangedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppCaptureMicrophoneCaptureStateChangedEventArgs", L"State"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.State());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AppCaptureMicrophoneCaptureStateChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Capture::AppCaptureMicrophoneCaptureStateChangedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AppCaptureMicrophoneCaptureStateChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Capture::AppCaptureMicrophoneCaptureStateChangedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AppCaptureMicrophoneCaptureStateChangedEventArgs[] = {
        { "_assign_array_", _assign_array_AppCaptureMicrophoneCaptureStateChangedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AppCaptureMicrophoneCaptureStateChangedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AppCaptureMicrophoneCaptureStateChangedEventArgs[] = {
        { "error_code", reinterpret_cast<getter>(AppCaptureMicrophoneCaptureStateChangedEventArgs_get_ErrorCode), nullptr, nullptr, nullptr },
        { "state", reinterpret_cast<getter>(AppCaptureMicrophoneCaptureStateChangedEventArgs_get_State), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AppCaptureMicrophoneCaptureStateChangedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_AppCaptureMicrophoneCaptureStateChangedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AppCaptureMicrophoneCaptureStateChangedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AppCaptureMicrophoneCaptureStateChangedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AppCaptureMicrophoneCaptureStateChangedEventArgs) },
        { }
    };

    static PyType_Spec type_spec_AppCaptureMicrophoneCaptureStateChangedEventArgs = {
        "winrt._winrt_windows_media_capture.AppCaptureMicrophoneCaptureStateChangedEventArgs",
        sizeof(py::wrapper::Windows::Media::Capture::AppCaptureMicrophoneCaptureStateChangedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AppCaptureMicrophoneCaptureStateChangedEventArgs};

    // ----- AppCaptureRecordOperation class --------------------

    static PyObject* _new_AppCaptureRecordOperation(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Capture::AppCaptureRecordOperation>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Capture::AppCaptureRecordOperation>::type_name);
        return nullptr;
    }

    static void _dealloc_AppCaptureRecordOperation(py::wrapper::Windows::Media::Capture::AppCaptureRecordOperation* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AppCaptureRecordOperation_StopRecording(py::wrapper::Windows::Media::Capture::AppCaptureRecordOperation* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Capture.AppCaptureRecordOperation", L"StopRecording", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.StopRecording();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppCaptureRecordOperation_get_Duration(py::wrapper::Windows::Media::Capture::AppCaptureRecordOperation* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppCaptureRecordOperation", L"Duration"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Duration());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppCaptureRecordOperation_get_ErrorCode(py::wrapper::Windows::Media::Capture::AppCaptureRecordOperation* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppCaptureRecordOperation", L"ErrorCode"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ErrorCode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppCaptureRecordOperation_get_File(py::wrapper::Windows::Media::Capture::AppCaptureRecordOperation* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppCaptureRecordOperation", L"File"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.File());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppCaptureRecordOperation_get_IsFileTruncated(py::wrapper::Windows::Media::Capture::AppCaptureRecordOperation* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppCaptureRecordOperation", L"IsFileTruncated"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsFileTruncated());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppCaptureRecordOperation_get_State(py::wrapper::Windows::Media::Capture::AppCaptureRecordOperation* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppCaptureRecordOperation", L"State"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.State());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppCaptureRecordOperation_add_DurationGenerated(py::wrapper::Windows::Media::Capture::AppCaptureRecordOperation* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Capture.AppCaptureRecordOperation", L"DurationGenerated"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Capture::AppCaptureRecordOperation, winrt::Windows::Media::Capture::AppCaptureDurationGeneratedEventArgs>>(arg);

            return py::convert(self->obj.DurationGenerated(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppCaptureRecordOperation_remove_DurationGenerated(py::wrapper::Windows::Media::Capture::AppCaptureRecordOperation* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Capture.AppCaptureRecordOperation", L"DurationGenerated"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.DurationGenerated(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppCaptureRecordOperation_add_FileGenerated(py::wrapper::Windows::Media::Capture::AppCaptureRecordOperation* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Capture.AppCaptureRecordOperation", L"FileGenerated"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Capture::AppCaptureRecordOperation, winrt::Windows::Media::Capture::AppCaptureFileGeneratedEventArgs>>(arg);

            return py::convert(self->obj.FileGenerated(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppCaptureRecordOperation_remove_FileGenerated(py::wrapper::Windows::Media::Capture::AppCaptureRecordOperation* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Capture.AppCaptureRecordOperation", L"FileGenerated"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.FileGenerated(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppCaptureRecordOperation_add_StateChanged(py::wrapper::Windows::Media::Capture::AppCaptureRecordOperation* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Capture.AppCaptureRecordOperation", L"StateChanged"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Capture::AppCaptureRecordOperation, winrt::Windows::Media::Capture::AppCaptureRecordingStateChangedEventArgs>>(arg);

            return py::convert(self->obj.StateChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppCaptureRecordOperation_remove_StateChanged(py::wrapper::Windows::Media::Capture::AppCaptureRecordOperation* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Capture.AppCaptureRecordOperation", L"StateChanged"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.StateChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AppCaptureRecordOperation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Capture::AppCaptureRecordOperation>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AppCaptureRecordOperation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Capture::AppCaptureRecordOperation>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AppCaptureRecordOperation[] = {
        { "stop_recording", reinterpret_cast<PyCFunction>(AppCaptureRecordOperation_StopRecording), METH_VARARGS, nullptr },
        { "add_duration_generated", reinterpret_cast<PyCFunction>(AppCaptureRecordOperation_add_DurationGenerated), METH_O, nullptr },
        { "remove_duration_generated", reinterpret_cast<PyCFunction>(AppCaptureRecordOperation_remove_DurationGenerated), METH_O, nullptr },
        { "add_file_generated", reinterpret_cast<PyCFunction>(AppCaptureRecordOperation_add_FileGenerated), METH_O, nullptr },
        { "remove_file_generated", reinterpret_cast<PyCFunction>(AppCaptureRecordOperation_remove_FileGenerated), METH_O, nullptr },
        { "add_state_changed", reinterpret_cast<PyCFunction>(AppCaptureRecordOperation_add_StateChanged), METH_O, nullptr },
        { "remove_state_changed", reinterpret_cast<PyCFunction>(AppCaptureRecordOperation_remove_StateChanged), METH_O, nullptr },
        { "_assign_array_", _assign_array_AppCaptureRecordOperation, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AppCaptureRecordOperation), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AppCaptureRecordOperation[] = {
        { "duration", reinterpret_cast<getter>(AppCaptureRecordOperation_get_Duration), nullptr, nullptr, nullptr },
        { "error_code", reinterpret_cast<getter>(AppCaptureRecordOperation_get_ErrorCode), nullptr, nullptr, nullptr },
        { "file", reinterpret_cast<getter>(AppCaptureRecordOperation_get_File), nullptr, nullptr, nullptr },
        { "is_file_truncated", reinterpret_cast<getter>(AppCaptureRecordOperation_get_IsFileTruncated), nullptr, nullptr, nullptr },
        { "state", reinterpret_cast<getter>(AppCaptureRecordOperation_get_State), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AppCaptureRecordOperation[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_AppCaptureRecordOperation) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AppCaptureRecordOperation) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AppCaptureRecordOperation) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AppCaptureRecordOperation) },
        { }
    };

    static PyType_Spec type_spec_AppCaptureRecordOperation = {
        "winrt._winrt_windows_media_capture.AppCaptureRecordOperation",
        sizeof(py::wrapper::Windows::Media::Capture::AppCaptureRecordOperation),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AppCaptureRecordOperation};

    // ----- AppCaptureRecordingStateChangedEventArgs class --------------------

    static PyObject* _new_AppCaptureRecordingStateChangedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Capture::AppCaptureRecordingStateChangedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Capture::AppCaptureRecordingStateChangedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_AppCaptureRecordingStateChangedEventArgs(py::wrapper::Windows::Media::Capture::AppCaptureRecordingStateChangedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AppCaptureRecordingStateChangedEventArgs_get_ErrorCode(py::wrapper::Windows::Media::Capture::AppCaptureRecordingStateChangedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppCaptureRecordingStateChangedEventArgs", L"ErrorCode"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ErrorCode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppCaptureRecordingStateChangedEventArgs_get_State(py::wrapper::Windows::Media::Capture::AppCaptureRecordingStateChangedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppCaptureRecordingStateChangedEventArgs", L"State"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.State());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AppCaptureRecordingStateChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Capture::AppCaptureRecordingStateChangedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AppCaptureRecordingStateChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Capture::AppCaptureRecordingStateChangedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AppCaptureRecordingStateChangedEventArgs[] = {
        { "_assign_array_", _assign_array_AppCaptureRecordingStateChangedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AppCaptureRecordingStateChangedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AppCaptureRecordingStateChangedEventArgs[] = {
        { "error_code", reinterpret_cast<getter>(AppCaptureRecordingStateChangedEventArgs_get_ErrorCode), nullptr, nullptr, nullptr },
        { "state", reinterpret_cast<getter>(AppCaptureRecordingStateChangedEventArgs_get_State), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AppCaptureRecordingStateChangedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_AppCaptureRecordingStateChangedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AppCaptureRecordingStateChangedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AppCaptureRecordingStateChangedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AppCaptureRecordingStateChangedEventArgs) },
        { }
    };

    static PyType_Spec type_spec_AppCaptureRecordingStateChangedEventArgs = {
        "winrt._winrt_windows_media_capture.AppCaptureRecordingStateChangedEventArgs",
        sizeof(py::wrapper::Windows::Media::Capture::AppCaptureRecordingStateChangedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AppCaptureRecordingStateChangedEventArgs};

    // ----- AppCaptureServices class --------------------

    static PyObject* _new_AppCaptureServices(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Capture::AppCaptureServices>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Capture::AppCaptureServices>::type_name);
        return nullptr;
    }

    static void _dealloc_AppCaptureServices(py::wrapper::Windows::Media::Capture::AppCaptureServices* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AppCaptureServices_Record(py::wrapper::Windows::Media::Capture::AppCaptureServices* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Capture.AppCaptureServices", L"Record", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.Record());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppCaptureServices_RecordTimeSpan(py::wrapper::Windows::Media::Capture::AppCaptureServices* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Capture.AppCaptureServices", L"RecordTimeSpan", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::DateTime>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(args, 1);

                return py::convert(self->obj.RecordTimeSpan(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppCaptureServices_get_CanCapture(py::wrapper::Windows::Media::Capture::AppCaptureServices* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppCaptureServices", L"CanCapture"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CanCapture());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppCaptureServices_get_State(py::wrapper::Windows::Media::Capture::AppCaptureServices* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppCaptureServices", L"State"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.State());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AppCaptureServices(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Capture::AppCaptureServices>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AppCaptureServices(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Capture::AppCaptureServices>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AppCaptureServices[] = {
        { "record", reinterpret_cast<PyCFunction>(AppCaptureServices_Record), METH_VARARGS, nullptr },
        { "record_time_span", reinterpret_cast<PyCFunction>(AppCaptureServices_RecordTimeSpan), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_AppCaptureServices, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AppCaptureServices), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AppCaptureServices[] = {
        { "can_capture", reinterpret_cast<getter>(AppCaptureServices_get_CanCapture), nullptr, nullptr, nullptr },
        { "state", reinterpret_cast<getter>(AppCaptureServices_get_State), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AppCaptureServices[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_AppCaptureServices) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AppCaptureServices) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AppCaptureServices) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AppCaptureServices) },
        { }
    };

    static PyType_Spec type_spec_AppCaptureServices = {
        "winrt._winrt_windows_media_capture.AppCaptureServices",
        sizeof(py::wrapper::Windows::Media::Capture::AppCaptureServices),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AppCaptureServices};

    // ----- AppCaptureSettings class --------------------

    static PyObject* _new_AppCaptureSettings(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Capture::AppCaptureSettings>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Capture::AppCaptureSettings>::type_name);
        return nullptr;
    }

    static void _dealloc_AppCaptureSettings(py::wrapper::Windows::Media::Capture::AppCaptureSettings* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AppCaptureSettings_get_IsHistoricalCaptureOnWirelessDisplayAllowed(py::wrapper::Windows::Media::Capture::AppCaptureSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppCaptureSettings", L"IsHistoricalCaptureOnWirelessDisplayAllowed"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsHistoricalCaptureOnWirelessDisplayAllowed());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppCaptureSettings_put_IsHistoricalCaptureOnWirelessDisplayAllowed(py::wrapper::Windows::Media::Capture::AppCaptureSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppCaptureSettings", L"IsHistoricalCaptureOnWirelessDisplayAllowed"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsHistoricalCaptureOnWirelessDisplayAllowed(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppCaptureSettings_get_VideoEncodingBitrateMode(py::wrapper::Windows::Media::Capture::AppCaptureSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppCaptureSettings", L"VideoEncodingBitrateMode"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.VideoEncodingBitrateMode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppCaptureSettings_put_VideoEncodingBitrateMode(py::wrapper::Windows::Media::Capture::AppCaptureSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppCaptureSettings", L"VideoEncodingBitrateMode"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Media::Capture::AppCaptureVideoEncodingBitrateMode>(arg);

            self->obj.VideoEncodingBitrateMode(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppCaptureSettings_get_IsHistoricalCaptureOnBatteryAllowed(py::wrapper::Windows::Media::Capture::AppCaptureSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppCaptureSettings", L"IsHistoricalCaptureOnBatteryAllowed"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsHistoricalCaptureOnBatteryAllowed());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppCaptureSettings_put_IsHistoricalCaptureOnBatteryAllowed(py::wrapper::Windows::Media::Capture::AppCaptureSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppCaptureSettings", L"IsHistoricalCaptureOnBatteryAllowed"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsHistoricalCaptureOnBatteryAllowed(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppCaptureSettings_get_IsAudioCaptureEnabled(py::wrapper::Windows::Media::Capture::AppCaptureSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppCaptureSettings", L"IsAudioCaptureEnabled"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsAudioCaptureEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppCaptureSettings_put_IsAudioCaptureEnabled(py::wrapper::Windows::Media::Capture::AppCaptureSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppCaptureSettings", L"IsAudioCaptureEnabled"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsAudioCaptureEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppCaptureSettings_get_IsAppCaptureEnabled(py::wrapper::Windows::Media::Capture::AppCaptureSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppCaptureSettings", L"IsAppCaptureEnabled"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsAppCaptureEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppCaptureSettings_put_IsAppCaptureEnabled(py::wrapper::Windows::Media::Capture::AppCaptureSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppCaptureSettings", L"IsAppCaptureEnabled"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsAppCaptureEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppCaptureSettings_get_AppCaptureDestinationFolder(py::wrapper::Windows::Media::Capture::AppCaptureSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppCaptureSettings", L"AppCaptureDestinationFolder"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.AppCaptureDestinationFolder());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppCaptureSettings_put_AppCaptureDestinationFolder(py::wrapper::Windows::Media::Capture::AppCaptureSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppCaptureSettings", L"AppCaptureDestinationFolder"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Storage::StorageFolder>(arg);

            self->obj.AppCaptureDestinationFolder(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppCaptureSettings_get_HistoricalBufferLength(py::wrapper::Windows::Media::Capture::AppCaptureSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppCaptureSettings", L"HistoricalBufferLength"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.HistoricalBufferLength());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppCaptureSettings_put_HistoricalBufferLength(py::wrapper::Windows::Media::Capture::AppCaptureSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppCaptureSettings", L"HistoricalBufferLength"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.HistoricalBufferLength(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppCaptureSettings_get_IsHistoricalCaptureEnabled(py::wrapper::Windows::Media::Capture::AppCaptureSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppCaptureSettings", L"IsHistoricalCaptureEnabled"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsHistoricalCaptureEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppCaptureSettings_put_IsHistoricalCaptureEnabled(py::wrapper::Windows::Media::Capture::AppCaptureSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppCaptureSettings", L"IsHistoricalCaptureEnabled"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsHistoricalCaptureEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppCaptureSettings_get_CustomVideoEncodingWidth(py::wrapper::Windows::Media::Capture::AppCaptureSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppCaptureSettings", L"CustomVideoEncodingWidth"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CustomVideoEncodingWidth());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppCaptureSettings_put_CustomVideoEncodingWidth(py::wrapper::Windows::Media::Capture::AppCaptureSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppCaptureSettings", L"CustomVideoEncodingWidth"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.CustomVideoEncodingWidth(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppCaptureSettings_get_CustomVideoEncodingHeight(py::wrapper::Windows::Media::Capture::AppCaptureSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppCaptureSettings", L"CustomVideoEncodingHeight"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CustomVideoEncodingHeight());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppCaptureSettings_put_CustomVideoEncodingHeight(py::wrapper::Windows::Media::Capture::AppCaptureSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppCaptureSettings", L"CustomVideoEncodingHeight"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.CustomVideoEncodingHeight(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppCaptureSettings_get_CustomVideoEncodingBitrate(py::wrapper::Windows::Media::Capture::AppCaptureSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppCaptureSettings", L"CustomVideoEncodingBitrate"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CustomVideoEncodingBitrate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppCaptureSettings_put_CustomVideoEncodingBitrate(py::wrapper::Windows::Media::Capture::AppCaptureSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppCaptureSettings", L"CustomVideoEncodingBitrate"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.CustomVideoEncodingBitrate(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppCaptureSettings_get_AudioEncodingBitrate(py::wrapper::Windows::Media::Capture::AppCaptureSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppCaptureSettings", L"AudioEncodingBitrate"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.AudioEncodingBitrate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppCaptureSettings_put_AudioEncodingBitrate(py::wrapper::Windows::Media::Capture::AppCaptureSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppCaptureSettings", L"AudioEncodingBitrate"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.AudioEncodingBitrate(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppCaptureSettings_get_HistoricalBufferLengthUnit(py::wrapper::Windows::Media::Capture::AppCaptureSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppCaptureSettings", L"HistoricalBufferLengthUnit"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.HistoricalBufferLengthUnit());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppCaptureSettings_put_HistoricalBufferLengthUnit(py::wrapper::Windows::Media::Capture::AppCaptureSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppCaptureSettings", L"HistoricalBufferLengthUnit"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Media::Capture::AppCaptureHistoricalBufferLengthUnit>(arg);

            self->obj.HistoricalBufferLengthUnit(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppCaptureSettings_get_VideoEncodingResolutionMode(py::wrapper::Windows::Media::Capture::AppCaptureSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppCaptureSettings", L"VideoEncodingResolutionMode"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.VideoEncodingResolutionMode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppCaptureSettings_put_VideoEncodingResolutionMode(py::wrapper::Windows::Media::Capture::AppCaptureSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppCaptureSettings", L"VideoEncodingResolutionMode"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Media::Capture::AppCaptureVideoEncodingResolutionMode>(arg);

            self->obj.VideoEncodingResolutionMode(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppCaptureSettings_get_ScreenshotDestinationFolder(py::wrapper::Windows::Media::Capture::AppCaptureSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppCaptureSettings", L"ScreenshotDestinationFolder"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ScreenshotDestinationFolder());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppCaptureSettings_put_ScreenshotDestinationFolder(py::wrapper::Windows::Media::Capture::AppCaptureSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppCaptureSettings", L"ScreenshotDestinationFolder"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Storage::StorageFolder>(arg);

            self->obj.ScreenshotDestinationFolder(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppCaptureSettings_get_MaximumRecordLength(py::wrapper::Windows::Media::Capture::AppCaptureSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppCaptureSettings", L"MaximumRecordLength"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.MaximumRecordLength());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppCaptureSettings_put_MaximumRecordLength(py::wrapper::Windows::Media::Capture::AppCaptureSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppCaptureSettings", L"MaximumRecordLength"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(arg);

            self->obj.MaximumRecordLength(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppCaptureSettings_get_HasHardwareEncoder(py::wrapper::Windows::Media::Capture::AppCaptureSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppCaptureSettings", L"HasHardwareEncoder"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.HasHardwareEncoder());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppCaptureSettings_get_IsCpuConstrained(py::wrapper::Windows::Media::Capture::AppCaptureSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppCaptureSettings", L"IsCpuConstrained"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsCpuConstrained());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppCaptureSettings_get_IsMemoryConstrained(py::wrapper::Windows::Media::Capture::AppCaptureSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppCaptureSettings", L"IsMemoryConstrained"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsMemoryConstrained());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppCaptureSettings_get_IsDisabledByPolicy(py::wrapper::Windows::Media::Capture::AppCaptureSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppCaptureSettings", L"IsDisabledByPolicy"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsDisabledByPolicy());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppCaptureSettings_get_AlternateShortcutKeys(py::wrapper::Windows::Media::Capture::AppCaptureSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppCaptureSettings", L"AlternateShortcutKeys"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.AlternateShortcutKeys());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppCaptureSettings_get_IsGpuConstrained(py::wrapper::Windows::Media::Capture::AppCaptureSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppCaptureSettings", L"IsGpuConstrained"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsGpuConstrained());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppCaptureSettings_get_IsMicrophoneCaptureEnabled(py::wrapper::Windows::Media::Capture::AppCaptureSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppCaptureSettings", L"IsMicrophoneCaptureEnabled"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsMicrophoneCaptureEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppCaptureSettings_put_IsMicrophoneCaptureEnabled(py::wrapper::Windows::Media::Capture::AppCaptureSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppCaptureSettings", L"IsMicrophoneCaptureEnabled"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsMicrophoneCaptureEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppCaptureSettings_get_VideoEncodingFrameRateMode(py::wrapper::Windows::Media::Capture::AppCaptureSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppCaptureSettings", L"VideoEncodingFrameRateMode"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.VideoEncodingFrameRateMode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppCaptureSettings_put_VideoEncodingFrameRateMode(py::wrapper::Windows::Media::Capture::AppCaptureSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppCaptureSettings", L"VideoEncodingFrameRateMode"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Media::Capture::AppCaptureVideoEncodingFrameRateMode>(arg);

            self->obj.VideoEncodingFrameRateMode(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppCaptureSettings_get_SystemAudioGain(py::wrapper::Windows::Media::Capture::AppCaptureSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppCaptureSettings", L"SystemAudioGain"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SystemAudioGain());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppCaptureSettings_put_SystemAudioGain(py::wrapper::Windows::Media::Capture::AppCaptureSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppCaptureSettings", L"SystemAudioGain"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<double>(arg);

            self->obj.SystemAudioGain(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppCaptureSettings_get_MicrophoneGain(py::wrapper::Windows::Media::Capture::AppCaptureSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppCaptureSettings", L"MicrophoneGain"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.MicrophoneGain());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppCaptureSettings_put_MicrophoneGain(py::wrapper::Windows::Media::Capture::AppCaptureSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppCaptureSettings", L"MicrophoneGain"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<double>(arg);

            self->obj.MicrophoneGain(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppCaptureSettings_get_IsMicrophoneCaptureEnabledByDefault(py::wrapper::Windows::Media::Capture::AppCaptureSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppCaptureSettings", L"IsMicrophoneCaptureEnabledByDefault"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsMicrophoneCaptureEnabledByDefault());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppCaptureSettings_put_IsMicrophoneCaptureEnabledByDefault(py::wrapper::Windows::Media::Capture::AppCaptureSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppCaptureSettings", L"IsMicrophoneCaptureEnabledByDefault"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsMicrophoneCaptureEnabledByDefault(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppCaptureSettings_get_IsEchoCancellationEnabled(py::wrapper::Windows::Media::Capture::AppCaptureSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppCaptureSettings", L"IsEchoCancellationEnabled"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsEchoCancellationEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppCaptureSettings_put_IsEchoCancellationEnabled(py::wrapper::Windows::Media::Capture::AppCaptureSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppCaptureSettings", L"IsEchoCancellationEnabled"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsEchoCancellationEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppCaptureSettings_get_IsCursorImageCaptureEnabled(py::wrapper::Windows::Media::Capture::AppCaptureSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppCaptureSettings", L"IsCursorImageCaptureEnabled"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsCursorImageCaptureEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppCaptureSettings_put_IsCursorImageCaptureEnabled(py::wrapper::Windows::Media::Capture::AppCaptureSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppCaptureSettings", L"IsCursorImageCaptureEnabled"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsCursorImageCaptureEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_AppCaptureSettings(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Capture::AppCaptureSettings>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AppCaptureSettings(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Capture::AppCaptureSettings>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AppCaptureSettings[] = {
        { "_assign_array_", _assign_array_AppCaptureSettings, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AppCaptureSettings), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AppCaptureSettings[] = {
        { "is_historical_capture_on_wireless_display_allowed", reinterpret_cast<getter>(AppCaptureSettings_get_IsHistoricalCaptureOnWirelessDisplayAllowed), reinterpret_cast<setter>(AppCaptureSettings_put_IsHistoricalCaptureOnWirelessDisplayAllowed), nullptr, nullptr },
        { "video_encoding_bitrate_mode", reinterpret_cast<getter>(AppCaptureSettings_get_VideoEncodingBitrateMode), reinterpret_cast<setter>(AppCaptureSettings_put_VideoEncodingBitrateMode), nullptr, nullptr },
        { "is_historical_capture_on_battery_allowed", reinterpret_cast<getter>(AppCaptureSettings_get_IsHistoricalCaptureOnBatteryAllowed), reinterpret_cast<setter>(AppCaptureSettings_put_IsHistoricalCaptureOnBatteryAllowed), nullptr, nullptr },
        { "is_audio_capture_enabled", reinterpret_cast<getter>(AppCaptureSettings_get_IsAudioCaptureEnabled), reinterpret_cast<setter>(AppCaptureSettings_put_IsAudioCaptureEnabled), nullptr, nullptr },
        { "is_app_capture_enabled", reinterpret_cast<getter>(AppCaptureSettings_get_IsAppCaptureEnabled), reinterpret_cast<setter>(AppCaptureSettings_put_IsAppCaptureEnabled), nullptr, nullptr },
        { "app_capture_destination_folder", reinterpret_cast<getter>(AppCaptureSettings_get_AppCaptureDestinationFolder), reinterpret_cast<setter>(AppCaptureSettings_put_AppCaptureDestinationFolder), nullptr, nullptr },
        { "historical_buffer_length", reinterpret_cast<getter>(AppCaptureSettings_get_HistoricalBufferLength), reinterpret_cast<setter>(AppCaptureSettings_put_HistoricalBufferLength), nullptr, nullptr },
        { "is_historical_capture_enabled", reinterpret_cast<getter>(AppCaptureSettings_get_IsHistoricalCaptureEnabled), reinterpret_cast<setter>(AppCaptureSettings_put_IsHistoricalCaptureEnabled), nullptr, nullptr },
        { "custom_video_encoding_width", reinterpret_cast<getter>(AppCaptureSettings_get_CustomVideoEncodingWidth), reinterpret_cast<setter>(AppCaptureSettings_put_CustomVideoEncodingWidth), nullptr, nullptr },
        { "custom_video_encoding_height", reinterpret_cast<getter>(AppCaptureSettings_get_CustomVideoEncodingHeight), reinterpret_cast<setter>(AppCaptureSettings_put_CustomVideoEncodingHeight), nullptr, nullptr },
        { "custom_video_encoding_bitrate", reinterpret_cast<getter>(AppCaptureSettings_get_CustomVideoEncodingBitrate), reinterpret_cast<setter>(AppCaptureSettings_put_CustomVideoEncodingBitrate), nullptr, nullptr },
        { "audio_encoding_bitrate", reinterpret_cast<getter>(AppCaptureSettings_get_AudioEncodingBitrate), reinterpret_cast<setter>(AppCaptureSettings_put_AudioEncodingBitrate), nullptr, nullptr },
        { "historical_buffer_length_unit", reinterpret_cast<getter>(AppCaptureSettings_get_HistoricalBufferLengthUnit), reinterpret_cast<setter>(AppCaptureSettings_put_HistoricalBufferLengthUnit), nullptr, nullptr },
        { "video_encoding_resolution_mode", reinterpret_cast<getter>(AppCaptureSettings_get_VideoEncodingResolutionMode), reinterpret_cast<setter>(AppCaptureSettings_put_VideoEncodingResolutionMode), nullptr, nullptr },
        { "screenshot_destination_folder", reinterpret_cast<getter>(AppCaptureSettings_get_ScreenshotDestinationFolder), reinterpret_cast<setter>(AppCaptureSettings_put_ScreenshotDestinationFolder), nullptr, nullptr },
        { "maximum_record_length", reinterpret_cast<getter>(AppCaptureSettings_get_MaximumRecordLength), reinterpret_cast<setter>(AppCaptureSettings_put_MaximumRecordLength), nullptr, nullptr },
        { "has_hardware_encoder", reinterpret_cast<getter>(AppCaptureSettings_get_HasHardwareEncoder), nullptr, nullptr, nullptr },
        { "is_cpu_constrained", reinterpret_cast<getter>(AppCaptureSettings_get_IsCpuConstrained), nullptr, nullptr, nullptr },
        { "is_memory_constrained", reinterpret_cast<getter>(AppCaptureSettings_get_IsMemoryConstrained), nullptr, nullptr, nullptr },
        { "is_disabled_by_policy", reinterpret_cast<getter>(AppCaptureSettings_get_IsDisabledByPolicy), nullptr, nullptr, nullptr },
        { "alternate_shortcut_keys", reinterpret_cast<getter>(AppCaptureSettings_get_AlternateShortcutKeys), nullptr, nullptr, nullptr },
        { "is_gpu_constrained", reinterpret_cast<getter>(AppCaptureSettings_get_IsGpuConstrained), nullptr, nullptr, nullptr },
        { "is_microphone_capture_enabled", reinterpret_cast<getter>(AppCaptureSettings_get_IsMicrophoneCaptureEnabled), reinterpret_cast<setter>(AppCaptureSettings_put_IsMicrophoneCaptureEnabled), nullptr, nullptr },
        { "video_encoding_frame_rate_mode", reinterpret_cast<getter>(AppCaptureSettings_get_VideoEncodingFrameRateMode), reinterpret_cast<setter>(AppCaptureSettings_put_VideoEncodingFrameRateMode), nullptr, nullptr },
        { "system_audio_gain", reinterpret_cast<getter>(AppCaptureSettings_get_SystemAudioGain), reinterpret_cast<setter>(AppCaptureSettings_put_SystemAudioGain), nullptr, nullptr },
        { "microphone_gain", reinterpret_cast<getter>(AppCaptureSettings_get_MicrophoneGain), reinterpret_cast<setter>(AppCaptureSettings_put_MicrophoneGain), nullptr, nullptr },
        { "is_microphone_capture_enabled_by_default", reinterpret_cast<getter>(AppCaptureSettings_get_IsMicrophoneCaptureEnabledByDefault), reinterpret_cast<setter>(AppCaptureSettings_put_IsMicrophoneCaptureEnabledByDefault), nullptr, nullptr },
        { "is_echo_cancellation_enabled", reinterpret_cast<getter>(AppCaptureSettings_get_IsEchoCancellationEnabled), reinterpret_cast<setter>(AppCaptureSettings_put_IsEchoCancellationEnabled), nullptr, nullptr },
        { "is_cursor_image_capture_enabled", reinterpret_cast<getter>(AppCaptureSettings_get_IsCursorImageCaptureEnabled), reinterpret_cast<setter>(AppCaptureSettings_put_IsCursorImageCaptureEnabled), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AppCaptureSettings[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_AppCaptureSettings) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AppCaptureSettings) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AppCaptureSettings) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AppCaptureSettings) },
        { }
    };

    static PyType_Spec type_spec_AppCaptureSettings = {
        "winrt._winrt_windows_media_capture.AppCaptureSettings",
        sizeof(py::wrapper::Windows::Media::Capture::AppCaptureSettings),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AppCaptureSettings};

    // ----- AppCaptureState class --------------------

    static PyObject* _new_AppCaptureState(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Capture::AppCaptureState>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Capture::AppCaptureState>::type_name);
        return nullptr;
    }

    static void _dealloc_AppCaptureState(py::wrapper::Windows::Media::Capture::AppCaptureState* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AppCaptureState_RestartMicrophoneCapture(py::wrapper::Windows::Media::Capture::AppCaptureState* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Capture.AppCaptureState", L"RestartMicrophoneCapture", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.RestartMicrophoneCapture();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppCaptureState_get_ShouldCaptureMicrophone(py::wrapper::Windows::Media::Capture::AppCaptureState* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppCaptureState", L"ShouldCaptureMicrophone"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ShouldCaptureMicrophone());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppCaptureState_put_ShouldCaptureMicrophone(py::wrapper::Windows::Media::Capture::AppCaptureState* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppCaptureState", L"ShouldCaptureMicrophone"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.ShouldCaptureMicrophone(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppCaptureState_get_IsHistoricalCaptureEnabled(py::wrapper::Windows::Media::Capture::AppCaptureState* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppCaptureState", L"IsHistoricalCaptureEnabled"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsHistoricalCaptureEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppCaptureState_get_IsTargetRunning(py::wrapper::Windows::Media::Capture::AppCaptureState* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppCaptureState", L"IsTargetRunning"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsTargetRunning());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppCaptureState_get_MicrophoneCaptureError(py::wrapper::Windows::Media::Capture::AppCaptureState* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppCaptureState", L"MicrophoneCaptureError"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.MicrophoneCaptureError());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppCaptureState_get_MicrophoneCaptureState(py::wrapper::Windows::Media::Capture::AppCaptureState* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.AppCaptureState", L"MicrophoneCaptureState"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.MicrophoneCaptureState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppCaptureState_add_CaptureTargetClosed(py::wrapper::Windows::Media::Capture::AppCaptureState* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Capture.AppCaptureState", L"CaptureTargetClosed"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Capture::AppCaptureState, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.CaptureTargetClosed(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppCaptureState_remove_CaptureTargetClosed(py::wrapper::Windows::Media::Capture::AppCaptureState* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Capture.AppCaptureState", L"CaptureTargetClosed"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.CaptureTargetClosed(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppCaptureState_add_MicrophoneCaptureStateChanged(py::wrapper::Windows::Media::Capture::AppCaptureState* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Capture.AppCaptureState", L"MicrophoneCaptureStateChanged"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Capture::AppCaptureState, winrt::Windows::Media::Capture::AppCaptureMicrophoneCaptureStateChangedEventArgs>>(arg);

            return py::convert(self->obj.MicrophoneCaptureStateChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppCaptureState_remove_MicrophoneCaptureStateChanged(py::wrapper::Windows::Media::Capture::AppCaptureState* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Capture.AppCaptureState", L"MicrophoneCaptureStateChanged"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.MicrophoneCaptureStateChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AppCaptureState(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Capture::AppCaptureState>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AppCaptureState(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Capture::AppCaptureState>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AppCaptureState[] = {
        { "restart_microphone_capture", reinterpret_cast<PyCFunction>(AppCaptureState_RestartMicrophoneCapture), METH_VARARGS, nullptr },
        { "add_capture_target_closed", reinterpret_cast<PyCFunction>(AppCaptureState_add_CaptureTargetClosed), METH_O, nullptr },
        { "remove_capture_target_closed", reinterpret_cast<PyCFunction>(AppCaptureState_remove_CaptureTargetClosed), METH_O, nullptr },
        { "add_microphone_capture_state_changed", reinterpret_cast<PyCFunction>(AppCaptureState_add_MicrophoneCaptureStateChanged), METH_O, nullptr },
        { "remove_microphone_capture_state_changed", reinterpret_cast<PyCFunction>(AppCaptureState_remove_MicrophoneCaptureStateChanged), METH_O, nullptr },
        { "_assign_array_", _assign_array_AppCaptureState, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AppCaptureState), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AppCaptureState[] = {
        { "should_capture_microphone", reinterpret_cast<getter>(AppCaptureState_get_ShouldCaptureMicrophone), reinterpret_cast<setter>(AppCaptureState_put_ShouldCaptureMicrophone), nullptr, nullptr },
        { "is_historical_capture_enabled", reinterpret_cast<getter>(AppCaptureState_get_IsHistoricalCaptureEnabled), nullptr, nullptr, nullptr },
        { "is_target_running", reinterpret_cast<getter>(AppCaptureState_get_IsTargetRunning), nullptr, nullptr, nullptr },
        { "microphone_capture_error", reinterpret_cast<getter>(AppCaptureState_get_MicrophoneCaptureError), nullptr, nullptr, nullptr },
        { "microphone_capture_state", reinterpret_cast<getter>(AppCaptureState_get_MicrophoneCaptureState), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AppCaptureState[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_AppCaptureState) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AppCaptureState) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AppCaptureState) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AppCaptureState) },
        { }
    };

    static PyType_Spec type_spec_AppCaptureState = {
        "winrt._winrt_windows_media_capture.AppCaptureState",
        sizeof(py::wrapper::Windows::Media::Capture::AppCaptureState),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AppCaptureState};

    // ----- CameraCaptureUI class --------------------

    static PyObject* _new_CameraCaptureUI(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Media::Capture::CameraCaptureUI instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_CameraCaptureUI(py::wrapper::Windows::Media::Capture::CameraCaptureUI* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CameraCaptureUI_CaptureFileAsync(py::wrapper::Windows::Media::Capture::CameraCaptureUI* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Capture.CameraCaptureUI", L"CaptureFileAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Media::Capture::CameraCaptureUIMode>(args, 0);

                return py::convert(self->obj.CaptureFileAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CameraCaptureUI_get_PhotoSettings(py::wrapper::Windows::Media::Capture::CameraCaptureUI* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.CameraCaptureUI", L"PhotoSettings"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.PhotoSettings());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CameraCaptureUI_get_VideoSettings(py::wrapper::Windows::Media::Capture::CameraCaptureUI* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.CameraCaptureUI", L"VideoSettings"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.VideoSettings());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_CameraCaptureUI(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Capture::CameraCaptureUI>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CameraCaptureUI(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Capture::CameraCaptureUI>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CameraCaptureUI[] = {
        { "capture_file_async", reinterpret_cast<PyCFunction>(CameraCaptureUI_CaptureFileAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_CameraCaptureUI, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CameraCaptureUI), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CameraCaptureUI[] = {
        { "photo_settings", reinterpret_cast<getter>(CameraCaptureUI_get_PhotoSettings), nullptr, nullptr, nullptr },
        { "video_settings", reinterpret_cast<getter>(CameraCaptureUI_get_VideoSettings), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CameraCaptureUI[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_CameraCaptureUI) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CameraCaptureUI) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CameraCaptureUI) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CameraCaptureUI) },
        { }
    };

    static PyType_Spec type_spec_CameraCaptureUI = {
        "winrt._winrt_windows_media_capture.CameraCaptureUI",
        sizeof(py::wrapper::Windows::Media::Capture::CameraCaptureUI),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CameraCaptureUI};

    // ----- CameraCaptureUIPhotoCaptureSettings class --------------------

    static PyObject* _new_CameraCaptureUIPhotoCaptureSettings(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Capture::CameraCaptureUIPhotoCaptureSettings>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Capture::CameraCaptureUIPhotoCaptureSettings>::type_name);
        return nullptr;
    }

    static void _dealloc_CameraCaptureUIPhotoCaptureSettings(py::wrapper::Windows::Media::Capture::CameraCaptureUIPhotoCaptureSettings* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CameraCaptureUIPhotoCaptureSettings_get_MaxResolution(py::wrapper::Windows::Media::Capture::CameraCaptureUIPhotoCaptureSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.CameraCaptureUIPhotoCaptureSettings", L"MaxResolution"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.MaxResolution());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CameraCaptureUIPhotoCaptureSettings_put_MaxResolution(py::wrapper::Windows::Media::Capture::CameraCaptureUIPhotoCaptureSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.CameraCaptureUIPhotoCaptureSettings", L"MaxResolution"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Media::Capture::CameraCaptureUIMaxPhotoResolution>(arg);

            self->obj.MaxResolution(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CameraCaptureUIPhotoCaptureSettings_get_Format(py::wrapper::Windows::Media::Capture::CameraCaptureUIPhotoCaptureSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.CameraCaptureUIPhotoCaptureSettings", L"Format"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Format());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CameraCaptureUIPhotoCaptureSettings_put_Format(py::wrapper::Windows::Media::Capture::CameraCaptureUIPhotoCaptureSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.CameraCaptureUIPhotoCaptureSettings", L"Format"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Media::Capture::CameraCaptureUIPhotoFormat>(arg);

            self->obj.Format(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CameraCaptureUIPhotoCaptureSettings_get_CroppedSizeInPixels(py::wrapper::Windows::Media::Capture::CameraCaptureUIPhotoCaptureSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.CameraCaptureUIPhotoCaptureSettings", L"CroppedSizeInPixels"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CroppedSizeInPixels());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CameraCaptureUIPhotoCaptureSettings_put_CroppedSizeInPixels(py::wrapper::Windows::Media::Capture::CameraCaptureUIPhotoCaptureSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.CameraCaptureUIPhotoCaptureSettings", L"CroppedSizeInPixels"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::Size>(arg);

            self->obj.CroppedSizeInPixels(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CameraCaptureUIPhotoCaptureSettings_get_CroppedAspectRatio(py::wrapper::Windows::Media::Capture::CameraCaptureUIPhotoCaptureSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.CameraCaptureUIPhotoCaptureSettings", L"CroppedAspectRatio"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CroppedAspectRatio());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CameraCaptureUIPhotoCaptureSettings_put_CroppedAspectRatio(py::wrapper::Windows::Media::Capture::CameraCaptureUIPhotoCaptureSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.CameraCaptureUIPhotoCaptureSettings", L"CroppedAspectRatio"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::Size>(arg);

            self->obj.CroppedAspectRatio(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CameraCaptureUIPhotoCaptureSettings_get_AllowCropping(py::wrapper::Windows::Media::Capture::CameraCaptureUIPhotoCaptureSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.CameraCaptureUIPhotoCaptureSettings", L"AllowCropping"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.AllowCropping());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CameraCaptureUIPhotoCaptureSettings_put_AllowCropping(py::wrapper::Windows::Media::Capture::CameraCaptureUIPhotoCaptureSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.CameraCaptureUIPhotoCaptureSettings", L"AllowCropping"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.AllowCropping(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_CameraCaptureUIPhotoCaptureSettings(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Capture::CameraCaptureUIPhotoCaptureSettings>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CameraCaptureUIPhotoCaptureSettings(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Capture::CameraCaptureUIPhotoCaptureSettings>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CameraCaptureUIPhotoCaptureSettings[] = {
        { "_assign_array_", _assign_array_CameraCaptureUIPhotoCaptureSettings, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CameraCaptureUIPhotoCaptureSettings), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CameraCaptureUIPhotoCaptureSettings[] = {
        { "max_resolution", reinterpret_cast<getter>(CameraCaptureUIPhotoCaptureSettings_get_MaxResolution), reinterpret_cast<setter>(CameraCaptureUIPhotoCaptureSettings_put_MaxResolution), nullptr, nullptr },
        { "format", reinterpret_cast<getter>(CameraCaptureUIPhotoCaptureSettings_get_Format), reinterpret_cast<setter>(CameraCaptureUIPhotoCaptureSettings_put_Format), nullptr, nullptr },
        { "cropped_size_in_pixels", reinterpret_cast<getter>(CameraCaptureUIPhotoCaptureSettings_get_CroppedSizeInPixels), reinterpret_cast<setter>(CameraCaptureUIPhotoCaptureSettings_put_CroppedSizeInPixels), nullptr, nullptr },
        { "cropped_aspect_ratio", reinterpret_cast<getter>(CameraCaptureUIPhotoCaptureSettings_get_CroppedAspectRatio), reinterpret_cast<setter>(CameraCaptureUIPhotoCaptureSettings_put_CroppedAspectRatio), nullptr, nullptr },
        { "allow_cropping", reinterpret_cast<getter>(CameraCaptureUIPhotoCaptureSettings_get_AllowCropping), reinterpret_cast<setter>(CameraCaptureUIPhotoCaptureSettings_put_AllowCropping), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CameraCaptureUIPhotoCaptureSettings[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_CameraCaptureUIPhotoCaptureSettings) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CameraCaptureUIPhotoCaptureSettings) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CameraCaptureUIPhotoCaptureSettings) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CameraCaptureUIPhotoCaptureSettings) },
        { }
    };

    static PyType_Spec type_spec_CameraCaptureUIPhotoCaptureSettings = {
        "winrt._winrt_windows_media_capture.CameraCaptureUIPhotoCaptureSettings",
        sizeof(py::wrapper::Windows::Media::Capture::CameraCaptureUIPhotoCaptureSettings),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CameraCaptureUIPhotoCaptureSettings};

    // ----- CameraCaptureUIVideoCaptureSettings class --------------------

    static PyObject* _new_CameraCaptureUIVideoCaptureSettings(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Capture::CameraCaptureUIVideoCaptureSettings>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Capture::CameraCaptureUIVideoCaptureSettings>::type_name);
        return nullptr;
    }

    static void _dealloc_CameraCaptureUIVideoCaptureSettings(py::wrapper::Windows::Media::Capture::CameraCaptureUIVideoCaptureSettings* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CameraCaptureUIVideoCaptureSettings_get_MaxResolution(py::wrapper::Windows::Media::Capture::CameraCaptureUIVideoCaptureSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.CameraCaptureUIVideoCaptureSettings", L"MaxResolution"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.MaxResolution());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CameraCaptureUIVideoCaptureSettings_put_MaxResolution(py::wrapper::Windows::Media::Capture::CameraCaptureUIVideoCaptureSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.CameraCaptureUIVideoCaptureSettings", L"MaxResolution"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Media::Capture::CameraCaptureUIMaxVideoResolution>(arg);

            self->obj.MaxResolution(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CameraCaptureUIVideoCaptureSettings_get_MaxDurationInSeconds(py::wrapper::Windows::Media::Capture::CameraCaptureUIVideoCaptureSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.CameraCaptureUIVideoCaptureSettings", L"MaxDurationInSeconds"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.MaxDurationInSeconds());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CameraCaptureUIVideoCaptureSettings_put_MaxDurationInSeconds(py::wrapper::Windows::Media::Capture::CameraCaptureUIVideoCaptureSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.CameraCaptureUIVideoCaptureSettings", L"MaxDurationInSeconds"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<float>(arg);

            self->obj.MaxDurationInSeconds(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CameraCaptureUIVideoCaptureSettings_get_Format(py::wrapper::Windows::Media::Capture::CameraCaptureUIVideoCaptureSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.CameraCaptureUIVideoCaptureSettings", L"Format"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Format());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CameraCaptureUIVideoCaptureSettings_put_Format(py::wrapper::Windows::Media::Capture::CameraCaptureUIVideoCaptureSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.CameraCaptureUIVideoCaptureSettings", L"Format"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Media::Capture::CameraCaptureUIVideoFormat>(arg);

            self->obj.Format(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CameraCaptureUIVideoCaptureSettings_get_AllowTrimming(py::wrapper::Windows::Media::Capture::CameraCaptureUIVideoCaptureSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.CameraCaptureUIVideoCaptureSettings", L"AllowTrimming"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.AllowTrimming());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CameraCaptureUIVideoCaptureSettings_put_AllowTrimming(py::wrapper::Windows::Media::Capture::CameraCaptureUIVideoCaptureSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.CameraCaptureUIVideoCaptureSettings", L"AllowTrimming"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.AllowTrimming(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_CameraCaptureUIVideoCaptureSettings(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Capture::CameraCaptureUIVideoCaptureSettings>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CameraCaptureUIVideoCaptureSettings(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Capture::CameraCaptureUIVideoCaptureSettings>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CameraCaptureUIVideoCaptureSettings[] = {
        { "_assign_array_", _assign_array_CameraCaptureUIVideoCaptureSettings, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CameraCaptureUIVideoCaptureSettings), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CameraCaptureUIVideoCaptureSettings[] = {
        { "max_resolution", reinterpret_cast<getter>(CameraCaptureUIVideoCaptureSettings_get_MaxResolution), reinterpret_cast<setter>(CameraCaptureUIVideoCaptureSettings_put_MaxResolution), nullptr, nullptr },
        { "max_duration_in_seconds", reinterpret_cast<getter>(CameraCaptureUIVideoCaptureSettings_get_MaxDurationInSeconds), reinterpret_cast<setter>(CameraCaptureUIVideoCaptureSettings_put_MaxDurationInSeconds), nullptr, nullptr },
        { "format", reinterpret_cast<getter>(CameraCaptureUIVideoCaptureSettings_get_Format), reinterpret_cast<setter>(CameraCaptureUIVideoCaptureSettings_put_Format), nullptr, nullptr },
        { "allow_trimming", reinterpret_cast<getter>(CameraCaptureUIVideoCaptureSettings_get_AllowTrimming), reinterpret_cast<setter>(CameraCaptureUIVideoCaptureSettings_put_AllowTrimming), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CameraCaptureUIVideoCaptureSettings[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_CameraCaptureUIVideoCaptureSettings) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CameraCaptureUIVideoCaptureSettings) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CameraCaptureUIVideoCaptureSettings) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CameraCaptureUIVideoCaptureSettings) },
        { }
    };

    static PyType_Spec type_spec_CameraCaptureUIVideoCaptureSettings = {
        "winrt._winrt_windows_media_capture.CameraCaptureUIVideoCaptureSettings",
        sizeof(py::wrapper::Windows::Media::Capture::CameraCaptureUIVideoCaptureSettings),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CameraCaptureUIVideoCaptureSettings};

    // ----- CameraOptionsUI class --------------------

    static PyObject* _new_CameraOptionsUI(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Capture::CameraOptionsUI>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Capture::CameraOptionsUI>::type_name);
        return nullptr;
    }

    static PyObject* CameraOptionsUI_Show(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Capture.CameraOptionsUI", L"Show", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Media::Capture::MediaCapture>(args, 0);

                winrt::Windows::Media::Capture::CameraOptionsUI::Show(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyMethodDef _methods_CameraOptionsUI[] = {
        { }
    };

    static PyGetSetDef _getset_CameraOptionsUI[] = {
        { }
    };

    static PyType_Slot _type_slots_CameraOptionsUI[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_CameraOptionsUI) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CameraOptionsUI) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CameraOptionsUI) },
        { }
    };

    static PyType_Spec type_spec_CameraOptionsUI = {
        "winrt._winrt_windows_media_capture.CameraOptionsUI",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CameraOptionsUI};

    static PyGetSetDef getset_CameraOptionsUI_Static[] = {
        { }
    };

    static PyMethodDef methods_CameraOptionsUI_Static[] = {
        { "show", reinterpret_cast<PyCFunction>(CameraOptionsUI_Show), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_CameraOptionsUI_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_CameraOptionsUI_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_CameraOptionsUI_Static) },
        { }
    };

    static PyType_Spec type_spec_CameraOptionsUI_Static =
    {
        "winrt._winrt_windows_media_capture.CameraOptionsUI_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_CameraOptionsUI_Static
    };

    // ----- CapturedFrame class --------------------

    static PyObject* _new_CapturedFrame(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Capture::CapturedFrame>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Capture::CapturedFrame>::type_name);
        return nullptr;
    }

    static void _dealloc_CapturedFrame(py::wrapper::Windows::Media::Capture::CapturedFrame* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CapturedFrame_CloneStream(py::wrapper::Windows::Media::Capture::CapturedFrame* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Capture.CapturedFrame", L"CloneStream", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.CloneStream());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CapturedFrame_Close(py::wrapper::Windows::Media::Capture::CapturedFrame* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Capture.CapturedFrame", L"Close", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CapturedFrame_FlushAsync(py::wrapper::Windows::Media::Capture::CapturedFrame* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Capture.CapturedFrame", L"FlushAsync", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.FlushAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CapturedFrame_GetInputStreamAt(py::wrapper::Windows::Media::Capture::CapturedFrame* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Capture.CapturedFrame", L"GetInputStreamAt", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint64_t>(args, 0);

                return py::convert(self->obj.GetInputStreamAt(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CapturedFrame_GetOutputStreamAt(py::wrapper::Windows::Media::Capture::CapturedFrame* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Capture.CapturedFrame", L"GetOutputStreamAt", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint64_t>(args, 0);

                return py::convert(self->obj.GetOutputStreamAt(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CapturedFrame_ReadAsync(py::wrapper::Windows::Media::Capture::CapturedFrame* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Capture.CapturedFrame", L"ReadAsync", 3))
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Storage::Streams::InputStreamOptions>(args, 2);

                return py::convert(self->obj.ReadAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CapturedFrame_Seek(py::wrapper::Windows::Media::Capture::CapturedFrame* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Capture.CapturedFrame", L"Seek", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint64_t>(args, 0);

                self->obj.Seek(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CapturedFrame_WriteAsync(py::wrapper::Windows::Media::Capture::CapturedFrame* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Capture.CapturedFrame", L"WriteAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 0);

                return py::convert(self->obj.WriteAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CapturedFrame_get_Height(py::wrapper::Windows::Media::Capture::CapturedFrame* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.CapturedFrame", L"Height"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Height());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CapturedFrame_get_Width(py::wrapper::Windows::Media::Capture::CapturedFrame* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.CapturedFrame", L"Width"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Width());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CapturedFrame_get_BitmapProperties(py::wrapper::Windows::Media::Capture::CapturedFrame* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.CapturedFrame", L"BitmapProperties"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.BitmapProperties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CapturedFrame_get_ControlValues(py::wrapper::Windows::Media::Capture::CapturedFrame* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.CapturedFrame", L"ControlValues"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ControlValues());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CapturedFrame_get_SoftwareBitmap(py::wrapper::Windows::Media::Capture::CapturedFrame* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.CapturedFrame", L"SoftwareBitmap"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SoftwareBitmap());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CapturedFrame_get_ContentType(py::wrapper::Windows::Media::Capture::CapturedFrame* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.CapturedFrame", L"ContentType"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ContentType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CapturedFrame_get_Size(py::wrapper::Windows::Media::Capture::CapturedFrame* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.CapturedFrame", L"Size"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CapturedFrame_put_Size(py::wrapper::Windows::Media::Capture::CapturedFrame* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.CapturedFrame", L"Size"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<uint64_t>(arg);

            self->obj.Size(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CapturedFrame_get_CanRead(py::wrapper::Windows::Media::Capture::CapturedFrame* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.CapturedFrame", L"CanRead"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CanRead());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CapturedFrame_get_CanWrite(py::wrapper::Windows::Media::Capture::CapturedFrame* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.CapturedFrame", L"CanWrite"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CanWrite());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CapturedFrame_get_Position(py::wrapper::Windows::Media::Capture::CapturedFrame* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.CapturedFrame", L"Position"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Position());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_CapturedFrame(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Capture::CapturedFrame>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CapturedFrame(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Capture::CapturedFrame>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_CapturedFrame(py::wrapper::Windows::Media::Capture::CapturedFrame* self, PyObject* /*unused*/) noexcept
    {
        return Py_NewRef(self);
    }

    static PyObject* _exit_CapturedFrame(py::wrapper::Windows::Media::Capture::CapturedFrame* self, PyObject* /*unused*/) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CapturedFrame[] = {
        { "clone_stream", reinterpret_cast<PyCFunction>(CapturedFrame_CloneStream), METH_VARARGS, nullptr },
        { "close", reinterpret_cast<PyCFunction>(CapturedFrame_Close), METH_VARARGS, nullptr },
        { "flush_async", reinterpret_cast<PyCFunction>(CapturedFrame_FlushAsync), METH_VARARGS, nullptr },
        { "get_input_stream_at", reinterpret_cast<PyCFunction>(CapturedFrame_GetInputStreamAt), METH_VARARGS, nullptr },
        { "get_output_stream_at", reinterpret_cast<PyCFunction>(CapturedFrame_GetOutputStreamAt), METH_VARARGS, nullptr },
        { "read_async", reinterpret_cast<PyCFunction>(CapturedFrame_ReadAsync), METH_VARARGS, nullptr },
        { "seek", reinterpret_cast<PyCFunction>(CapturedFrame_Seek), METH_VARARGS, nullptr },
        { "write_async", reinterpret_cast<PyCFunction>(CapturedFrame_WriteAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_CapturedFrame, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CapturedFrame), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_CapturedFrame), METH_NOARGS, nullptr },
        { "__exit__", reinterpret_cast<PyCFunction>(_exit_CapturedFrame), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_CapturedFrame[] = {
        { "height", reinterpret_cast<getter>(CapturedFrame_get_Height), nullptr, nullptr, nullptr },
        { "width", reinterpret_cast<getter>(CapturedFrame_get_Width), nullptr, nullptr, nullptr },
        { "bitmap_properties", reinterpret_cast<getter>(CapturedFrame_get_BitmapProperties), nullptr, nullptr, nullptr },
        { "control_values", reinterpret_cast<getter>(CapturedFrame_get_ControlValues), nullptr, nullptr, nullptr },
        { "software_bitmap", reinterpret_cast<getter>(CapturedFrame_get_SoftwareBitmap), nullptr, nullptr, nullptr },
        { "content_type", reinterpret_cast<getter>(CapturedFrame_get_ContentType), nullptr, nullptr, nullptr },
        { "size", reinterpret_cast<getter>(CapturedFrame_get_Size), reinterpret_cast<setter>(CapturedFrame_put_Size), nullptr, nullptr },
        { "can_read", reinterpret_cast<getter>(CapturedFrame_get_CanRead), nullptr, nullptr, nullptr },
        { "can_write", reinterpret_cast<getter>(CapturedFrame_get_CanWrite), nullptr, nullptr, nullptr },
        { "position", reinterpret_cast<getter>(CapturedFrame_get_Position), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CapturedFrame[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_CapturedFrame) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CapturedFrame) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CapturedFrame) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CapturedFrame) },
        { }
    };

    static PyType_Spec type_spec_CapturedFrame = {
        "winrt._winrt_windows_media_capture.CapturedFrame",
        sizeof(py::wrapper::Windows::Media::Capture::CapturedFrame),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CapturedFrame};

    // ----- CapturedFrameControlValues class --------------------

    static PyObject* _new_CapturedFrameControlValues(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Capture::CapturedFrameControlValues>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Capture::CapturedFrameControlValues>::type_name);
        return nullptr;
    }

    static void _dealloc_CapturedFrameControlValues(py::wrapper::Windows::Media::Capture::CapturedFrameControlValues* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CapturedFrameControlValues_get_Exposure(py::wrapper::Windows::Media::Capture::CapturedFrameControlValues* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.CapturedFrameControlValues", L"Exposure"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Exposure());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CapturedFrameControlValues_get_ExposureCompensation(py::wrapper::Windows::Media::Capture::CapturedFrameControlValues* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.CapturedFrameControlValues", L"ExposureCompensation"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ExposureCompensation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CapturedFrameControlValues_get_FlashPowerPercent(py::wrapper::Windows::Media::Capture::CapturedFrameControlValues* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.CapturedFrameControlValues", L"FlashPowerPercent"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.FlashPowerPercent());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CapturedFrameControlValues_get_Flashed(py::wrapper::Windows::Media::Capture::CapturedFrameControlValues* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.CapturedFrameControlValues", L"Flashed"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Flashed());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CapturedFrameControlValues_get_Focus(py::wrapper::Windows::Media::Capture::CapturedFrameControlValues* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.CapturedFrameControlValues", L"Focus"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Focus());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CapturedFrameControlValues_get_IsoSpeed(py::wrapper::Windows::Media::Capture::CapturedFrameControlValues* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.CapturedFrameControlValues", L"IsoSpeed"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsoSpeed());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CapturedFrameControlValues_get_SceneMode(py::wrapper::Windows::Media::Capture::CapturedFrameControlValues* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.CapturedFrameControlValues", L"SceneMode"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SceneMode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CapturedFrameControlValues_get_WhiteBalance(py::wrapper::Windows::Media::Capture::CapturedFrameControlValues* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.CapturedFrameControlValues", L"WhiteBalance"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.WhiteBalance());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CapturedFrameControlValues_get_ZoomFactor(py::wrapper::Windows::Media::Capture::CapturedFrameControlValues* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.CapturedFrameControlValues", L"ZoomFactor"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ZoomFactor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CapturedFrameControlValues_get_FocusState(py::wrapper::Windows::Media::Capture::CapturedFrameControlValues* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.CapturedFrameControlValues", L"FocusState"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.FocusState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CapturedFrameControlValues_get_IsoAnalogGain(py::wrapper::Windows::Media::Capture::CapturedFrameControlValues* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.CapturedFrameControlValues", L"IsoAnalogGain"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsoAnalogGain());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CapturedFrameControlValues_get_IsoDigitalGain(py::wrapper::Windows::Media::Capture::CapturedFrameControlValues* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.CapturedFrameControlValues", L"IsoDigitalGain"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsoDigitalGain());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CapturedFrameControlValues_get_SensorFrameRate(py::wrapper::Windows::Media::Capture::CapturedFrameControlValues* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.CapturedFrameControlValues", L"SensorFrameRate"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SensorFrameRate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CapturedFrameControlValues_get_WhiteBalanceGain(py::wrapper::Windows::Media::Capture::CapturedFrameControlValues* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.CapturedFrameControlValues", L"WhiteBalanceGain"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.WhiteBalanceGain());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_CapturedFrameControlValues(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Capture::CapturedFrameControlValues>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CapturedFrameControlValues(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Capture::CapturedFrameControlValues>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CapturedFrameControlValues[] = {
        { "_assign_array_", _assign_array_CapturedFrameControlValues, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CapturedFrameControlValues), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CapturedFrameControlValues[] = {
        { "exposure", reinterpret_cast<getter>(CapturedFrameControlValues_get_Exposure), nullptr, nullptr, nullptr },
        { "exposure_compensation", reinterpret_cast<getter>(CapturedFrameControlValues_get_ExposureCompensation), nullptr, nullptr, nullptr },
        { "flash_power_percent", reinterpret_cast<getter>(CapturedFrameControlValues_get_FlashPowerPercent), nullptr, nullptr, nullptr },
        { "flashed", reinterpret_cast<getter>(CapturedFrameControlValues_get_Flashed), nullptr, nullptr, nullptr },
        { "focus", reinterpret_cast<getter>(CapturedFrameControlValues_get_Focus), nullptr, nullptr, nullptr },
        { "iso_speed", reinterpret_cast<getter>(CapturedFrameControlValues_get_IsoSpeed), nullptr, nullptr, nullptr },
        { "scene_mode", reinterpret_cast<getter>(CapturedFrameControlValues_get_SceneMode), nullptr, nullptr, nullptr },
        { "white_balance", reinterpret_cast<getter>(CapturedFrameControlValues_get_WhiteBalance), nullptr, nullptr, nullptr },
        { "zoom_factor", reinterpret_cast<getter>(CapturedFrameControlValues_get_ZoomFactor), nullptr, nullptr, nullptr },
        { "focus_state", reinterpret_cast<getter>(CapturedFrameControlValues_get_FocusState), nullptr, nullptr, nullptr },
        { "iso_analog_gain", reinterpret_cast<getter>(CapturedFrameControlValues_get_IsoAnalogGain), nullptr, nullptr, nullptr },
        { "iso_digital_gain", reinterpret_cast<getter>(CapturedFrameControlValues_get_IsoDigitalGain), nullptr, nullptr, nullptr },
        { "sensor_frame_rate", reinterpret_cast<getter>(CapturedFrameControlValues_get_SensorFrameRate), nullptr, nullptr, nullptr },
        { "white_balance_gain", reinterpret_cast<getter>(CapturedFrameControlValues_get_WhiteBalanceGain), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CapturedFrameControlValues[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_CapturedFrameControlValues) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CapturedFrameControlValues) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CapturedFrameControlValues) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CapturedFrameControlValues) },
        { }
    };

    static PyType_Spec type_spec_CapturedFrameControlValues = {
        "winrt._winrt_windows_media_capture.CapturedFrameControlValues",
        sizeof(py::wrapper::Windows::Media::Capture::CapturedFrameControlValues),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CapturedFrameControlValues};

    // ----- CapturedPhoto class --------------------

    static PyObject* _new_CapturedPhoto(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Capture::CapturedPhoto>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Capture::CapturedPhoto>::type_name);
        return nullptr;
    }

    static void _dealloc_CapturedPhoto(py::wrapper::Windows::Media::Capture::CapturedPhoto* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CapturedPhoto_get_Frame(py::wrapper::Windows::Media::Capture::CapturedPhoto* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.CapturedPhoto", L"Frame"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Frame());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CapturedPhoto_get_Thumbnail(py::wrapper::Windows::Media::Capture::CapturedPhoto* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.CapturedPhoto", L"Thumbnail"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Thumbnail());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_CapturedPhoto(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Capture::CapturedPhoto>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CapturedPhoto(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Capture::CapturedPhoto>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CapturedPhoto[] = {
        { "_assign_array_", _assign_array_CapturedPhoto, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CapturedPhoto), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CapturedPhoto[] = {
        { "frame", reinterpret_cast<getter>(CapturedPhoto_get_Frame), nullptr, nullptr, nullptr },
        { "thumbnail", reinterpret_cast<getter>(CapturedPhoto_get_Thumbnail), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CapturedPhoto[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_CapturedPhoto) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CapturedPhoto) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CapturedPhoto) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CapturedPhoto) },
        { }
    };

    static PyType_Spec type_spec_CapturedPhoto = {
        "winrt._winrt_windows_media_capture.CapturedPhoto",
        sizeof(py::wrapper::Windows::Media::Capture::CapturedPhoto),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CapturedPhoto};

    // ----- GameBarServices class --------------------

    static PyObject* _new_GameBarServices(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Capture::GameBarServices>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Capture::GameBarServices>::type_name);
        return nullptr;
    }

    static void _dealloc_GameBarServices(py::wrapper::Windows::Media::Capture::GameBarServices* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* GameBarServices_DisableCapture(py::wrapper::Windows::Media::Capture::GameBarServices* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Capture.GameBarServices", L"DisableCapture", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.DisableCapture();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* GameBarServices_EnableCapture(py::wrapper::Windows::Media::Capture::GameBarServices* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Capture.GameBarServices", L"EnableCapture", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.EnableCapture();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* GameBarServices_get_AppBroadcastServices(py::wrapper::Windows::Media::Capture::GameBarServices* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.GameBarServices", L"AppBroadcastServices"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.AppBroadcastServices());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GameBarServices_get_AppCaptureServices(py::wrapper::Windows::Media::Capture::GameBarServices* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.GameBarServices", L"AppCaptureServices"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.AppCaptureServices());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GameBarServices_get_SessionId(py::wrapper::Windows::Media::Capture::GameBarServices* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.GameBarServices", L"SessionId"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SessionId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GameBarServices_get_TargetCapturePolicy(py::wrapper::Windows::Media::Capture::GameBarServices* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.GameBarServices", L"TargetCapturePolicy"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.TargetCapturePolicy());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GameBarServices_get_TargetInfo(py::wrapper::Windows::Media::Capture::GameBarServices* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.GameBarServices", L"TargetInfo"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.TargetInfo());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GameBarServices_add_CommandReceived(py::wrapper::Windows::Media::Capture::GameBarServices* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Capture.GameBarServices", L"CommandReceived"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Capture::GameBarServices, winrt::Windows::Media::Capture::GameBarServicesCommandEventArgs>>(arg);

            return py::convert(self->obj.CommandReceived(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GameBarServices_remove_CommandReceived(py::wrapper::Windows::Media::Capture::GameBarServices* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Capture.GameBarServices", L"CommandReceived"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.CommandReceived(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_GameBarServices(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Capture::GameBarServices>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_GameBarServices(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Capture::GameBarServices>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_GameBarServices[] = {
        { "disable_capture", reinterpret_cast<PyCFunction>(GameBarServices_DisableCapture), METH_VARARGS, nullptr },
        { "enable_capture", reinterpret_cast<PyCFunction>(GameBarServices_EnableCapture), METH_VARARGS, nullptr },
        { "add_command_received", reinterpret_cast<PyCFunction>(GameBarServices_add_CommandReceived), METH_O, nullptr },
        { "remove_command_received", reinterpret_cast<PyCFunction>(GameBarServices_remove_CommandReceived), METH_O, nullptr },
        { "_assign_array_", _assign_array_GameBarServices, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_GameBarServices), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_GameBarServices[] = {
        { "app_broadcast_services", reinterpret_cast<getter>(GameBarServices_get_AppBroadcastServices), nullptr, nullptr, nullptr },
        { "app_capture_services", reinterpret_cast<getter>(GameBarServices_get_AppCaptureServices), nullptr, nullptr, nullptr },
        { "session_id", reinterpret_cast<getter>(GameBarServices_get_SessionId), nullptr, nullptr, nullptr },
        { "target_capture_policy", reinterpret_cast<getter>(GameBarServices_get_TargetCapturePolicy), nullptr, nullptr, nullptr },
        { "target_info", reinterpret_cast<getter>(GameBarServices_get_TargetInfo), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_GameBarServices[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_GameBarServices) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_GameBarServices) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_GameBarServices) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_GameBarServices) },
        { }
    };

    static PyType_Spec type_spec_GameBarServices = {
        "winrt._winrt_windows_media_capture.GameBarServices",
        sizeof(py::wrapper::Windows::Media::Capture::GameBarServices),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_GameBarServices};

    // ----- GameBarServicesCommandEventArgs class --------------------

    static PyObject* _new_GameBarServicesCommandEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Capture::GameBarServicesCommandEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Capture::GameBarServicesCommandEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_GameBarServicesCommandEventArgs(py::wrapper::Windows::Media::Capture::GameBarServicesCommandEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* GameBarServicesCommandEventArgs_get_Command(py::wrapper::Windows::Media::Capture::GameBarServicesCommandEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.GameBarServicesCommandEventArgs", L"Command"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Command());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GameBarServicesCommandEventArgs_get_Origin(py::wrapper::Windows::Media::Capture::GameBarServicesCommandEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.GameBarServicesCommandEventArgs", L"Origin"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Origin());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_GameBarServicesCommandEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Capture::GameBarServicesCommandEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_GameBarServicesCommandEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Capture::GameBarServicesCommandEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_GameBarServicesCommandEventArgs[] = {
        { "_assign_array_", _assign_array_GameBarServicesCommandEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_GameBarServicesCommandEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_GameBarServicesCommandEventArgs[] = {
        { "command", reinterpret_cast<getter>(GameBarServicesCommandEventArgs_get_Command), nullptr, nullptr, nullptr },
        { "origin", reinterpret_cast<getter>(GameBarServicesCommandEventArgs_get_Origin), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_GameBarServicesCommandEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_GameBarServicesCommandEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_GameBarServicesCommandEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_GameBarServicesCommandEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_GameBarServicesCommandEventArgs) },
        { }
    };

    static PyType_Spec type_spec_GameBarServicesCommandEventArgs = {
        "winrt._winrt_windows_media_capture.GameBarServicesCommandEventArgs",
        sizeof(py::wrapper::Windows::Media::Capture::GameBarServicesCommandEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_GameBarServicesCommandEventArgs};

    // ----- GameBarServicesManager class --------------------

    static PyObject* _new_GameBarServicesManager(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Capture::GameBarServicesManager>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Capture::GameBarServicesManager>::type_name);
        return nullptr;
    }

    static void _dealloc_GameBarServicesManager(py::wrapper::Windows::Media::Capture::GameBarServicesManager* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* GameBarServicesManager_GetDefault(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Capture.GameBarServicesManager", L"GetDefault", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(winrt::Windows::Media::Capture::GameBarServicesManager::GetDefault());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* GameBarServicesManager_add_GameBarServicesCreated(py::wrapper::Windows::Media::Capture::GameBarServicesManager* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Capture.GameBarServicesManager", L"GameBarServicesCreated"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Capture::GameBarServicesManager, winrt::Windows::Media::Capture::GameBarServicesManagerGameBarServicesCreatedEventArgs>>(arg);

            return py::convert(self->obj.GameBarServicesCreated(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GameBarServicesManager_remove_GameBarServicesCreated(py::wrapper::Windows::Media::Capture::GameBarServicesManager* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Capture.GameBarServicesManager", L"GameBarServicesCreated"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.GameBarServicesCreated(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_GameBarServicesManager(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Capture::GameBarServicesManager>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_GameBarServicesManager(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Capture::GameBarServicesManager>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_GameBarServicesManager[] = {
        { "add_game_bar_services_created", reinterpret_cast<PyCFunction>(GameBarServicesManager_add_GameBarServicesCreated), METH_O, nullptr },
        { "remove_game_bar_services_created", reinterpret_cast<PyCFunction>(GameBarServicesManager_remove_GameBarServicesCreated), METH_O, nullptr },
        { "_assign_array_", _assign_array_GameBarServicesManager, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_GameBarServicesManager), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_GameBarServicesManager[] = {
        { }
    };

    static PyType_Slot _type_slots_GameBarServicesManager[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_GameBarServicesManager) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_GameBarServicesManager) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_GameBarServicesManager) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_GameBarServicesManager) },
        { }
    };

    static PyType_Spec type_spec_GameBarServicesManager = {
        "winrt._winrt_windows_media_capture.GameBarServicesManager",
        sizeof(py::wrapper::Windows::Media::Capture::GameBarServicesManager),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_GameBarServicesManager};

    static PyGetSetDef getset_GameBarServicesManager_Static[] = {
        { }
    };

    static PyMethodDef methods_GameBarServicesManager_Static[] = {
        { "get_default", reinterpret_cast<PyCFunction>(GameBarServicesManager_GetDefault), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_GameBarServicesManager_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_GameBarServicesManager_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_GameBarServicesManager_Static) },
        { }
    };

    static PyType_Spec type_spec_GameBarServicesManager_Static =
    {
        "winrt._winrt_windows_media_capture.GameBarServicesManager_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_GameBarServicesManager_Static
    };

    // ----- GameBarServicesManagerGameBarServicesCreatedEventArgs class --------------------

    static PyObject* _new_GameBarServicesManagerGameBarServicesCreatedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Capture::GameBarServicesManagerGameBarServicesCreatedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Capture::GameBarServicesManagerGameBarServicesCreatedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_GameBarServicesManagerGameBarServicesCreatedEventArgs(py::wrapper::Windows::Media::Capture::GameBarServicesManagerGameBarServicesCreatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* GameBarServicesManagerGameBarServicesCreatedEventArgs_get_GameBarServices(py::wrapper::Windows::Media::Capture::GameBarServicesManagerGameBarServicesCreatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.GameBarServicesManagerGameBarServicesCreatedEventArgs", L"GameBarServices"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.GameBarServices());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_GameBarServicesManagerGameBarServicesCreatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Capture::GameBarServicesManagerGameBarServicesCreatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_GameBarServicesManagerGameBarServicesCreatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Capture::GameBarServicesManagerGameBarServicesCreatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_GameBarServicesManagerGameBarServicesCreatedEventArgs[] = {
        { "_assign_array_", _assign_array_GameBarServicesManagerGameBarServicesCreatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_GameBarServicesManagerGameBarServicesCreatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_GameBarServicesManagerGameBarServicesCreatedEventArgs[] = {
        { "game_bar_services", reinterpret_cast<getter>(GameBarServicesManagerGameBarServicesCreatedEventArgs_get_GameBarServices), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_GameBarServicesManagerGameBarServicesCreatedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_GameBarServicesManagerGameBarServicesCreatedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_GameBarServicesManagerGameBarServicesCreatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_GameBarServicesManagerGameBarServicesCreatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_GameBarServicesManagerGameBarServicesCreatedEventArgs) },
        { }
    };

    static PyType_Spec type_spec_GameBarServicesManagerGameBarServicesCreatedEventArgs = {
        "winrt._winrt_windows_media_capture.GameBarServicesManagerGameBarServicesCreatedEventArgs",
        sizeof(py::wrapper::Windows::Media::Capture::GameBarServicesManagerGameBarServicesCreatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_GameBarServicesManagerGameBarServicesCreatedEventArgs};

    // ----- GameBarServicesTargetInfo class --------------------

    static PyObject* _new_GameBarServicesTargetInfo(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Capture::GameBarServicesTargetInfo>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Capture::GameBarServicesTargetInfo>::type_name);
        return nullptr;
    }

    static void _dealloc_GameBarServicesTargetInfo(py::wrapper::Windows::Media::Capture::GameBarServicesTargetInfo* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* GameBarServicesTargetInfo_get_AppId(py::wrapper::Windows::Media::Capture::GameBarServicesTargetInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.GameBarServicesTargetInfo", L"AppId"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.AppId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GameBarServicesTargetInfo_get_DisplayMode(py::wrapper::Windows::Media::Capture::GameBarServicesTargetInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.GameBarServicesTargetInfo", L"DisplayMode"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DisplayMode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GameBarServicesTargetInfo_get_DisplayName(py::wrapper::Windows::Media::Capture::GameBarServicesTargetInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.GameBarServicesTargetInfo", L"DisplayName"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DisplayName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GameBarServicesTargetInfo_get_TitleId(py::wrapper::Windows::Media::Capture::GameBarServicesTargetInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.GameBarServicesTargetInfo", L"TitleId"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.TitleId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_GameBarServicesTargetInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Capture::GameBarServicesTargetInfo>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_GameBarServicesTargetInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Capture::GameBarServicesTargetInfo>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_GameBarServicesTargetInfo[] = {
        { "_assign_array_", _assign_array_GameBarServicesTargetInfo, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_GameBarServicesTargetInfo), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_GameBarServicesTargetInfo[] = {
        { "app_id", reinterpret_cast<getter>(GameBarServicesTargetInfo_get_AppId), nullptr, nullptr, nullptr },
        { "display_mode", reinterpret_cast<getter>(GameBarServicesTargetInfo_get_DisplayMode), nullptr, nullptr, nullptr },
        { "display_name", reinterpret_cast<getter>(GameBarServicesTargetInfo_get_DisplayName), nullptr, nullptr, nullptr },
        { "title_id", reinterpret_cast<getter>(GameBarServicesTargetInfo_get_TitleId), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_GameBarServicesTargetInfo[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_GameBarServicesTargetInfo) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_GameBarServicesTargetInfo) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_GameBarServicesTargetInfo) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_GameBarServicesTargetInfo) },
        { }
    };

    static PyType_Spec type_spec_GameBarServicesTargetInfo = {
        "winrt._winrt_windows_media_capture.GameBarServicesTargetInfo",
        sizeof(py::wrapper::Windows::Media::Capture::GameBarServicesTargetInfo),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_GameBarServicesTargetInfo};

    // ----- LowLagMediaRecording class --------------------

    static PyObject* _new_LowLagMediaRecording(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Capture::LowLagMediaRecording>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Capture::LowLagMediaRecording>::type_name);
        return nullptr;
    }

    static void _dealloc_LowLagMediaRecording(py::wrapper::Windows::Media::Capture::LowLagMediaRecording* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* LowLagMediaRecording_FinishAsync(py::wrapper::Windows::Media::Capture::LowLagMediaRecording* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Capture.LowLagMediaRecording", L"FinishAsync", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.FinishAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LowLagMediaRecording_PauseAsync(py::wrapper::Windows::Media::Capture::LowLagMediaRecording* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Capture.LowLagMediaRecording", L"PauseAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Media::Devices::MediaCapturePauseBehavior>(args, 0);

                return py::convert(self->obj.PauseAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LowLagMediaRecording_PauseWithResultAsync(py::wrapper::Windows::Media::Capture::LowLagMediaRecording* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Capture.LowLagMediaRecording", L"PauseWithResultAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Media::Devices::MediaCapturePauseBehavior>(args, 0);

                return py::convert(self->obj.PauseWithResultAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LowLagMediaRecording_ResumeAsync(py::wrapper::Windows::Media::Capture::LowLagMediaRecording* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Capture.LowLagMediaRecording", L"ResumeAsync", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.ResumeAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LowLagMediaRecording_StartAsync(py::wrapper::Windows::Media::Capture::LowLagMediaRecording* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Capture.LowLagMediaRecording", L"StartAsync", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.StartAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LowLagMediaRecording_StopAsync(py::wrapper::Windows::Media::Capture::LowLagMediaRecording* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Capture.LowLagMediaRecording", L"StopAsync", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.StopAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LowLagMediaRecording_StopWithResultAsync(py::wrapper::Windows::Media::Capture::LowLagMediaRecording* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Capture.LowLagMediaRecording", L"StopWithResultAsync", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.StopWithResultAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_LowLagMediaRecording(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Capture::LowLagMediaRecording>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_LowLagMediaRecording(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Capture::LowLagMediaRecording>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_LowLagMediaRecording[] = {
        { "finish_async", reinterpret_cast<PyCFunction>(LowLagMediaRecording_FinishAsync), METH_VARARGS, nullptr },
        { "pause_async", reinterpret_cast<PyCFunction>(LowLagMediaRecording_PauseAsync), METH_VARARGS, nullptr },
        { "pause_with_result_async", reinterpret_cast<PyCFunction>(LowLagMediaRecording_PauseWithResultAsync), METH_VARARGS, nullptr },
        { "resume_async", reinterpret_cast<PyCFunction>(LowLagMediaRecording_ResumeAsync), METH_VARARGS, nullptr },
        { "start_async", reinterpret_cast<PyCFunction>(LowLagMediaRecording_StartAsync), METH_VARARGS, nullptr },
        { "stop_async", reinterpret_cast<PyCFunction>(LowLagMediaRecording_StopAsync), METH_VARARGS, nullptr },
        { "stop_with_result_async", reinterpret_cast<PyCFunction>(LowLagMediaRecording_StopWithResultAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_LowLagMediaRecording, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_LowLagMediaRecording), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_LowLagMediaRecording[] = {
        { }
    };

    static PyType_Slot _type_slots_LowLagMediaRecording[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_LowLagMediaRecording) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_LowLagMediaRecording) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_LowLagMediaRecording) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_LowLagMediaRecording) },
        { }
    };

    static PyType_Spec type_spec_LowLagMediaRecording = {
        "winrt._winrt_windows_media_capture.LowLagMediaRecording",
        sizeof(py::wrapper::Windows::Media::Capture::LowLagMediaRecording),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_LowLagMediaRecording};

    // ----- LowLagPhotoCapture class --------------------

    static PyObject* _new_LowLagPhotoCapture(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Capture::LowLagPhotoCapture>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Capture::LowLagPhotoCapture>::type_name);
        return nullptr;
    }

    static void _dealloc_LowLagPhotoCapture(py::wrapper::Windows::Media::Capture::LowLagPhotoCapture* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* LowLagPhotoCapture_CaptureAsync(py::wrapper::Windows::Media::Capture::LowLagPhotoCapture* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Capture.LowLagPhotoCapture", L"CaptureAsync", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.CaptureAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LowLagPhotoCapture_FinishAsync(py::wrapper::Windows::Media::Capture::LowLagPhotoCapture* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Capture.LowLagPhotoCapture", L"FinishAsync", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.FinishAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_LowLagPhotoCapture(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Capture::LowLagPhotoCapture>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_LowLagPhotoCapture(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Capture::LowLagPhotoCapture>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_LowLagPhotoCapture[] = {
        { "capture_async", reinterpret_cast<PyCFunction>(LowLagPhotoCapture_CaptureAsync), METH_VARARGS, nullptr },
        { "finish_async", reinterpret_cast<PyCFunction>(LowLagPhotoCapture_FinishAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_LowLagPhotoCapture, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_LowLagPhotoCapture), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_LowLagPhotoCapture[] = {
        { }
    };

    static PyType_Slot _type_slots_LowLagPhotoCapture[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_LowLagPhotoCapture) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_LowLagPhotoCapture) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_LowLagPhotoCapture) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_LowLagPhotoCapture) },
        { }
    };

    static PyType_Spec type_spec_LowLagPhotoCapture = {
        "winrt._winrt_windows_media_capture.LowLagPhotoCapture",
        sizeof(py::wrapper::Windows::Media::Capture::LowLagPhotoCapture),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_LowLagPhotoCapture};

    // ----- LowLagPhotoSequenceCapture class --------------------

    static PyObject* _new_LowLagPhotoSequenceCapture(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Capture::LowLagPhotoSequenceCapture>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Capture::LowLagPhotoSequenceCapture>::type_name);
        return nullptr;
    }

    static void _dealloc_LowLagPhotoSequenceCapture(py::wrapper::Windows::Media::Capture::LowLagPhotoSequenceCapture* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* LowLagPhotoSequenceCapture_FinishAsync(py::wrapper::Windows::Media::Capture::LowLagPhotoSequenceCapture* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Capture.LowLagPhotoSequenceCapture", L"FinishAsync", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.FinishAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LowLagPhotoSequenceCapture_StartAsync(py::wrapper::Windows::Media::Capture::LowLagPhotoSequenceCapture* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Capture.LowLagPhotoSequenceCapture", L"StartAsync", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.StartAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LowLagPhotoSequenceCapture_StopAsync(py::wrapper::Windows::Media::Capture::LowLagPhotoSequenceCapture* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Capture.LowLagPhotoSequenceCapture", L"StopAsync", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.StopAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LowLagPhotoSequenceCapture_add_PhotoCaptured(py::wrapper::Windows::Media::Capture::LowLagPhotoSequenceCapture* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Capture.LowLagPhotoSequenceCapture", L"PhotoCaptured"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Capture::LowLagPhotoSequenceCapture, winrt::Windows::Media::Capture::PhotoCapturedEventArgs>>(arg);

            return py::convert(self->obj.PhotoCaptured(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LowLagPhotoSequenceCapture_remove_PhotoCaptured(py::wrapper::Windows::Media::Capture::LowLagPhotoSequenceCapture* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Capture.LowLagPhotoSequenceCapture", L"PhotoCaptured"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.PhotoCaptured(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_LowLagPhotoSequenceCapture(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Capture::LowLagPhotoSequenceCapture>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_LowLagPhotoSequenceCapture(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Capture::LowLagPhotoSequenceCapture>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_LowLagPhotoSequenceCapture[] = {
        { "finish_async", reinterpret_cast<PyCFunction>(LowLagPhotoSequenceCapture_FinishAsync), METH_VARARGS, nullptr },
        { "start_async", reinterpret_cast<PyCFunction>(LowLagPhotoSequenceCapture_StartAsync), METH_VARARGS, nullptr },
        { "stop_async", reinterpret_cast<PyCFunction>(LowLagPhotoSequenceCapture_StopAsync), METH_VARARGS, nullptr },
        { "add_photo_captured", reinterpret_cast<PyCFunction>(LowLagPhotoSequenceCapture_add_PhotoCaptured), METH_O, nullptr },
        { "remove_photo_captured", reinterpret_cast<PyCFunction>(LowLagPhotoSequenceCapture_remove_PhotoCaptured), METH_O, nullptr },
        { "_assign_array_", _assign_array_LowLagPhotoSequenceCapture, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_LowLagPhotoSequenceCapture), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_LowLagPhotoSequenceCapture[] = {
        { }
    };

    static PyType_Slot _type_slots_LowLagPhotoSequenceCapture[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_LowLagPhotoSequenceCapture) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_LowLagPhotoSequenceCapture) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_LowLagPhotoSequenceCapture) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_LowLagPhotoSequenceCapture) },
        { }
    };

    static PyType_Spec type_spec_LowLagPhotoSequenceCapture = {
        "winrt._winrt_windows_media_capture.LowLagPhotoSequenceCapture",
        sizeof(py::wrapper::Windows::Media::Capture::LowLagPhotoSequenceCapture),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_LowLagPhotoSequenceCapture};

    // ----- MediaCapture class --------------------

    static PyObject* _new_MediaCapture(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Media::Capture::MediaCapture instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_MediaCapture(py::wrapper::Windows::Media::Capture::MediaCapture* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MediaCapture_AddAudioEffectAsync(py::wrapper::Windows::Media::Capture::MediaCapture* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Capture.MediaCapture", L"AddAudioEffectAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Media::Effects::IAudioEffectDefinition>(args, 0);

                return py::convert(self->obj.AddAudioEffectAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaCapture_AddEffectAsync(py::wrapper::Windows::Media::Capture::MediaCapture* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Capture.MediaCapture", L"AddEffectAsync", 3))
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Media::Capture::MediaStreamType>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Collections::IPropertySet>(args, 2);

                return py::convert(self->obj.AddEffectAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaCapture_AddVideoEffectAsync(py::wrapper::Windows::Media::Capture::MediaCapture* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Capture.MediaCapture", L"AddVideoEffectAsync", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Media::Effects::IVideoEffectDefinition>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Media::Capture::MediaStreamType>(args, 1);

                return py::convert(self->obj.AddVideoEffectAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaCapture_CapturePhotoToStorageFileAsync(py::wrapper::Windows::Media::Capture::MediaCapture* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Capture.MediaCapture", L"CapturePhotoToStorageFileAsync", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Media::MediaProperties::ImageEncodingProperties>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::IStorageFile>(args, 1);

                return py::convert(self->obj.CapturePhotoToStorageFileAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaCapture_CapturePhotoToStreamAsync(py::wrapper::Windows::Media::Capture::MediaCapture* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Capture.MediaCapture", L"CapturePhotoToStreamAsync", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Media::MediaProperties::ImageEncodingProperties>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::Streams::IRandomAccessStream>(args, 1);

                return py::convert(self->obj.CapturePhotoToStreamAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaCapture_ClearEffectsAsync(py::wrapper::Windows::Media::Capture::MediaCapture* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Capture.MediaCapture", L"ClearEffectsAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Media::Capture::MediaStreamType>(args, 0);

                return py::convert(self->obj.ClearEffectsAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaCapture_Close(py::wrapper::Windows::Media::Capture::MediaCapture* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Capture.MediaCapture", L"Close", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaCapture_CreateFrameReaderAsync(py::wrapper::Windows::Media::Capture::MediaCapture* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Capture.MediaCapture", L"CreateFrameReaderAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Media::Capture::Frames::MediaFrameSource>(args, 0);

                return py::convert(self->obj.CreateFrameReaderAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Capture.MediaCapture", L"CreateFrameReaderAsync", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Media::Capture::Frames::MediaFrameSource>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert(self->obj.CreateFrameReaderAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Capture.MediaCapture", L"CreateFrameReaderAsync", 3))
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Media::Capture::Frames::MediaFrameSource>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapSize>(args, 2);

                return py::convert(self->obj.CreateFrameReaderAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaCapture_CreateMultiSourceFrameReaderAsync(py::wrapper::Windows::Media::Capture::MediaCapture* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Capture.MediaCapture", L"CreateMultiSourceFrameReaderAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Media::Capture::Frames::MediaFrameSource>>(args, 0);

                return py::convert(self->obj.CreateMultiSourceFrameReaderAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaCapture_CreateRelativePanelWatcher(py::wrapper::Windows::Media::Capture::MediaCapture* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Capture.MediaCapture", L"CreateRelativePanelWatcher", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Media::Capture::StreamingCaptureMode>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::WindowManagement::DisplayRegion>(args, 1);

                return py::convert(self->obj.CreateRelativePanelWatcher(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaCapture_FindAllVideoProfiles(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Capture.MediaCapture", L"FindAllVideoProfiles", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Media::Capture::MediaCapture::FindAllVideoProfiles(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaCapture_FindConcurrentProfiles(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Capture.MediaCapture", L"FindConcurrentProfiles", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Media::Capture::MediaCapture::FindConcurrentProfiles(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaCapture_FindKnownVideoProfiles(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Capture.MediaCapture", L"FindKnownVideoProfiles", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Media::Capture::KnownVideoProfile>(args, 1);

                return py::convert(winrt::Windows::Media::Capture::MediaCapture::FindKnownVideoProfiles(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaCapture_GetEncoderProperty(py::wrapper::Windows::Media::Capture::MediaCapture* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Capture.MediaCapture", L"GetEncoderProperty", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Media::Capture::MediaStreamType>(args, 0);
                auto param1 = py::convert_to<winrt::guid>(args, 1);

                return py::convert(self->obj.GetEncoderProperty(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaCapture_GetPreviewFrameAsync(py::wrapper::Windows::Media::Capture::MediaCapture* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Capture.MediaCapture", L"GetPreviewFrameAsync", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetPreviewFrameAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Capture.MediaCapture", L"GetPreviewFrameAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Media::VideoFrame>(args, 0);

                return py::convert(self->obj.GetPreviewFrameAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaCapture_GetPreviewMirroring(py::wrapper::Windows::Media::Capture::MediaCapture* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Capture.MediaCapture", L"GetPreviewMirroring", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetPreviewMirroring());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaCapture_GetPreviewRotation(py::wrapper::Windows::Media::Capture::MediaCapture* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Capture.MediaCapture", L"GetPreviewRotation", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetPreviewRotation());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaCapture_GetRecordRotation(py::wrapper::Windows::Media::Capture::MediaCapture* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Capture.MediaCapture", L"GetRecordRotation", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetRecordRotation());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaCapture_InitializeAsync(py::wrapper::Windows::Media::Capture::MediaCapture* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Capture.MediaCapture", L"InitializeAsync", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.InitializeAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Capture.MediaCapture", L"InitializeAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Media::Capture::MediaCaptureInitializationSettings>(args, 0);

                return py::convert(self->obj.InitializeAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaCapture_IsVideoProfileSupported(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Capture.MediaCapture", L"IsVideoProfileSupported", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Media::Capture::MediaCapture::IsVideoProfileSupported(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaCapture_PauseRecordAsync(py::wrapper::Windows::Media::Capture::MediaCapture* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Capture.MediaCapture", L"PauseRecordAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Media::Devices::MediaCapturePauseBehavior>(args, 0);

                return py::convert(self->obj.PauseRecordAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaCapture_PauseRecordWithResultAsync(py::wrapper::Windows::Media::Capture::MediaCapture* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Capture.MediaCapture", L"PauseRecordWithResultAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Media::Devices::MediaCapturePauseBehavior>(args, 0);

                return py::convert(self->obj.PauseRecordWithResultAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaCapture_PrepareAdvancedPhotoCaptureAsync(py::wrapper::Windows::Media::Capture::MediaCapture* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Capture.MediaCapture", L"PrepareAdvancedPhotoCaptureAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Media::MediaProperties::ImageEncodingProperties>(args, 0);

                return py::convert(self->obj.PrepareAdvancedPhotoCaptureAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaCapture_PrepareLowLagPhotoCaptureAsync(py::wrapper::Windows::Media::Capture::MediaCapture* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Capture.MediaCapture", L"PrepareLowLagPhotoCaptureAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Media::MediaProperties::ImageEncodingProperties>(args, 0);

                return py::convert(self->obj.PrepareLowLagPhotoCaptureAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaCapture_PrepareLowLagPhotoSequenceCaptureAsync(py::wrapper::Windows::Media::Capture::MediaCapture* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Capture.MediaCapture", L"PrepareLowLagPhotoSequenceCaptureAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Media::MediaProperties::ImageEncodingProperties>(args, 0);

                return py::convert(self->obj.PrepareLowLagPhotoSequenceCaptureAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaCapture_PrepareLowLagRecordToCustomSinkAsync(py::wrapper::Windows::Media::Capture::MediaCapture* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Capture.MediaCapture", L"PrepareLowLagRecordToCustomSinkAsync", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Media::MediaProperties::MediaEncodingProfile>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Media::IMediaExtension>(args, 1);

                return py::convert(self->obj.PrepareLowLagRecordToCustomSinkAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Capture.MediaCapture", L"PrepareLowLagRecordToCustomSinkAsync", 3))
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Media::MediaProperties::MediaEncodingProfile>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Collections::IPropertySet>(args, 2);

                return py::convert(self->obj.PrepareLowLagRecordToCustomSinkAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaCapture_PrepareLowLagRecordToStorageFileAsync(py::wrapper::Windows::Media::Capture::MediaCapture* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Capture.MediaCapture", L"PrepareLowLagRecordToStorageFileAsync", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Media::MediaProperties::MediaEncodingProfile>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::IStorageFile>(args, 1);

                return py::convert(self->obj.PrepareLowLagRecordToStorageFileAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaCapture_PrepareLowLagRecordToStreamAsync(py::wrapper::Windows::Media::Capture::MediaCapture* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Capture.MediaCapture", L"PrepareLowLagRecordToStreamAsync", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Media::MediaProperties::MediaEncodingProfile>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::Streams::IRandomAccessStream>(args, 1);

                return py::convert(self->obj.PrepareLowLagRecordToStreamAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaCapture_PrepareVariablePhotoSequenceCaptureAsync(py::wrapper::Windows::Media::Capture::MediaCapture* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Capture.MediaCapture", L"PrepareVariablePhotoSequenceCaptureAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Media::MediaProperties::ImageEncodingProperties>(args, 0);

                return py::convert(self->obj.PrepareVariablePhotoSequenceCaptureAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaCapture_RemoveEffectAsync(py::wrapper::Windows::Media::Capture::MediaCapture* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Capture.MediaCapture", L"RemoveEffectAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Media::IMediaExtension>(args, 0);

                return py::convert(self->obj.RemoveEffectAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaCapture_ResumeRecordAsync(py::wrapper::Windows::Media::Capture::MediaCapture* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Capture.MediaCapture", L"ResumeRecordAsync", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.ResumeRecordAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaCapture_SetEncoderProperty(py::wrapper::Windows::Media::Capture::MediaCapture* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Capture.MediaCapture", L"SetEncoderProperty", 3))
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Media::Capture::MediaStreamType>(args, 0);
                auto param1 = py::convert_to<winrt::guid>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 2);

                self->obj.SetEncoderProperty(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaCapture_SetEncodingPropertiesAsync(py::wrapper::Windows::Media::Capture::MediaCapture* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Capture.MediaCapture", L"SetEncodingPropertiesAsync", 3))
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Media::Capture::MediaStreamType>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Media::MediaProperties::IMediaEncodingProperties>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Media::MediaProperties::MediaPropertySet>(args, 2);

                return py::convert(self->obj.SetEncodingPropertiesAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaCapture_SetPreviewMirroring(py::wrapper::Windows::Media::Capture::MediaCapture* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Capture.MediaCapture", L"SetPreviewMirroring", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<bool>(args, 0);

                self->obj.SetPreviewMirroring(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaCapture_SetPreviewRotation(py::wrapper::Windows::Media::Capture::MediaCapture* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Capture.MediaCapture", L"SetPreviewRotation", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Media::Capture::VideoRotation>(args, 0);

                self->obj.SetPreviewRotation(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaCapture_SetRecordRotation(py::wrapper::Windows::Media::Capture::MediaCapture* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Capture.MediaCapture", L"SetRecordRotation", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Media::Capture::VideoRotation>(args, 0);

                self->obj.SetRecordRotation(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaCapture_StartPreviewAsync(py::wrapper::Windows::Media::Capture::MediaCapture* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Capture.MediaCapture", L"StartPreviewAsync", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.StartPreviewAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaCapture_StartPreviewToCustomSinkAsync(py::wrapper::Windows::Media::Capture::MediaCapture* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Capture.MediaCapture", L"StartPreviewToCustomSinkAsync", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Media::MediaProperties::MediaEncodingProfile>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Media::IMediaExtension>(args, 1);

                return py::convert(self->obj.StartPreviewToCustomSinkAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Capture.MediaCapture", L"StartPreviewToCustomSinkAsync", 3))
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Media::MediaProperties::MediaEncodingProfile>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Collections::IPropertySet>(args, 2);

                return py::convert(self->obj.StartPreviewToCustomSinkAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaCapture_StartRecordToCustomSinkAsync(py::wrapper::Windows::Media::Capture::MediaCapture* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Capture.MediaCapture", L"StartRecordToCustomSinkAsync", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Media::MediaProperties::MediaEncodingProfile>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Media::IMediaExtension>(args, 1);

                return py::convert(self->obj.StartRecordToCustomSinkAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Capture.MediaCapture", L"StartRecordToCustomSinkAsync", 3))
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Media::MediaProperties::MediaEncodingProfile>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Collections::IPropertySet>(args, 2);

                return py::convert(self->obj.StartRecordToCustomSinkAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaCapture_StartRecordToStorageFileAsync(py::wrapper::Windows::Media::Capture::MediaCapture* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Capture.MediaCapture", L"StartRecordToStorageFileAsync", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Media::MediaProperties::MediaEncodingProfile>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::IStorageFile>(args, 1);

                return py::convert(self->obj.StartRecordToStorageFileAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaCapture_StartRecordToStreamAsync(py::wrapper::Windows::Media::Capture::MediaCapture* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Capture.MediaCapture", L"StartRecordToStreamAsync", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Media::MediaProperties::MediaEncodingProfile>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::Streams::IRandomAccessStream>(args, 1);

                return py::convert(self->obj.StartRecordToStreamAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaCapture_StopPreviewAsync(py::wrapper::Windows::Media::Capture::MediaCapture* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Capture.MediaCapture", L"StopPreviewAsync", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.StopPreviewAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaCapture_StopRecordAsync(py::wrapper::Windows::Media::Capture::MediaCapture* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Capture.MediaCapture", L"StopRecordAsync", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.StopRecordAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaCapture_StopRecordWithResultAsync(py::wrapper::Windows::Media::Capture::MediaCapture* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Capture.MediaCapture", L"StopRecordWithResultAsync", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.StopRecordWithResultAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaCapture_get_AudioDeviceController(py::wrapper::Windows::Media::Capture::MediaCapture* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.MediaCapture", L"AudioDeviceController"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.AudioDeviceController());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaCapture_get_MediaCaptureSettings(py::wrapper::Windows::Media::Capture::MediaCapture* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.MediaCapture", L"MediaCaptureSettings"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.MediaCaptureSettings());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaCapture_get_VideoDeviceController(py::wrapper::Windows::Media::Capture::MediaCapture* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.MediaCapture", L"VideoDeviceController"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.VideoDeviceController());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaCapture_get_CameraStreamState(py::wrapper::Windows::Media::Capture::MediaCapture* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.MediaCapture", L"CameraStreamState"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CameraStreamState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaCapture_get_ThermalStatus(py::wrapper::Windows::Media::Capture::MediaCapture* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.MediaCapture", L"ThermalStatus"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ThermalStatus());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaCapture_get_FrameSources(py::wrapper::Windows::Media::Capture::MediaCapture* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.MediaCapture", L"FrameSources"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.FrameSources());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaCapture_add_Failed(py::wrapper::Windows::Media::Capture::MediaCapture* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Capture.MediaCapture", L"Failed"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Media::Capture::MediaCaptureFailedEventHandler>(arg);

            return py::convert(self->obj.Failed(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaCapture_remove_Failed(py::wrapper::Windows::Media::Capture::MediaCapture* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Capture.MediaCapture", L"Failed"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Failed(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaCapture_add_RecordLimitationExceeded(py::wrapper::Windows::Media::Capture::MediaCapture* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Capture.MediaCapture", L"RecordLimitationExceeded"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Media::Capture::RecordLimitationExceededEventHandler>(arg);

            return py::convert(self->obj.RecordLimitationExceeded(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaCapture_remove_RecordLimitationExceeded(py::wrapper::Windows::Media::Capture::MediaCapture* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Capture.MediaCapture", L"RecordLimitationExceeded"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.RecordLimitationExceeded(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaCapture_add_FocusChanged(py::wrapper::Windows::Media::Capture::MediaCapture* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Capture.MediaCapture", L"FocusChanged"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Capture::MediaCapture, winrt::Windows::Media::Capture::MediaCaptureFocusChangedEventArgs>>(arg);

            return py::convert(self->obj.FocusChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaCapture_remove_FocusChanged(py::wrapper::Windows::Media::Capture::MediaCapture* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Capture.MediaCapture", L"FocusChanged"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.FocusChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaCapture_add_PhotoConfirmationCaptured(py::wrapper::Windows::Media::Capture::MediaCapture* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Capture.MediaCapture", L"PhotoConfirmationCaptured"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Capture::MediaCapture, winrt::Windows::Media::Capture::PhotoConfirmationCapturedEventArgs>>(arg);

            return py::convert(self->obj.PhotoConfirmationCaptured(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaCapture_remove_PhotoConfirmationCaptured(py::wrapper::Windows::Media::Capture::MediaCapture* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Capture.MediaCapture", L"PhotoConfirmationCaptured"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.PhotoConfirmationCaptured(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaCapture_add_CameraStreamStateChanged(py::wrapper::Windows::Media::Capture::MediaCapture* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Capture.MediaCapture", L"CameraStreamStateChanged"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Capture::MediaCapture, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.CameraStreamStateChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaCapture_remove_CameraStreamStateChanged(py::wrapper::Windows::Media::Capture::MediaCapture* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Capture.MediaCapture", L"CameraStreamStateChanged"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.CameraStreamStateChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaCapture_add_ThermalStatusChanged(py::wrapper::Windows::Media::Capture::MediaCapture* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Capture.MediaCapture", L"ThermalStatusChanged"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Capture::MediaCapture, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.ThermalStatusChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaCapture_remove_ThermalStatusChanged(py::wrapper::Windows::Media::Capture::MediaCapture* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Capture.MediaCapture", L"ThermalStatusChanged"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ThermalStatusChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaCapture_add_CaptureDeviceExclusiveControlStatusChanged(py::wrapper::Windows::Media::Capture::MediaCapture* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Capture.MediaCapture", L"CaptureDeviceExclusiveControlStatusChanged"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Capture::MediaCapture, winrt::Windows::Media::Capture::MediaCaptureDeviceExclusiveControlStatusChangedEventArgs>>(arg);

            return py::convert(self->obj.CaptureDeviceExclusiveControlStatusChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaCapture_remove_CaptureDeviceExclusiveControlStatusChanged(py::wrapper::Windows::Media::Capture::MediaCapture* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Capture.MediaCapture", L"CaptureDeviceExclusiveControlStatusChanged"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.CaptureDeviceExclusiveControlStatusChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MediaCapture(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Capture::MediaCapture>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MediaCapture(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Capture::MediaCapture>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_MediaCapture(py::wrapper::Windows::Media::Capture::MediaCapture* self, PyObject* /*unused*/) noexcept
    {
        return Py_NewRef(self);
    }

    static PyObject* _exit_MediaCapture(py::wrapper::Windows::Media::Capture::MediaCapture* self, PyObject* /*unused*/) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MediaCapture[] = {
        { "add_audio_effect_async", reinterpret_cast<PyCFunction>(MediaCapture_AddAudioEffectAsync), METH_VARARGS, nullptr },
        { "add_effect_async", reinterpret_cast<PyCFunction>(MediaCapture_AddEffectAsync), METH_VARARGS, nullptr },
        { "add_video_effect_async", reinterpret_cast<PyCFunction>(MediaCapture_AddVideoEffectAsync), METH_VARARGS, nullptr },
        { "capture_photo_to_storage_file_async", reinterpret_cast<PyCFunction>(MediaCapture_CapturePhotoToStorageFileAsync), METH_VARARGS, nullptr },
        { "capture_photo_to_stream_async", reinterpret_cast<PyCFunction>(MediaCapture_CapturePhotoToStreamAsync), METH_VARARGS, nullptr },
        { "clear_effects_async", reinterpret_cast<PyCFunction>(MediaCapture_ClearEffectsAsync), METH_VARARGS, nullptr },
        { "close", reinterpret_cast<PyCFunction>(MediaCapture_Close), METH_VARARGS, nullptr },
        { "create_frame_reader_async", reinterpret_cast<PyCFunction>(MediaCapture_CreateFrameReaderAsync), METH_VARARGS, nullptr },
        { "create_multi_source_frame_reader_async", reinterpret_cast<PyCFunction>(MediaCapture_CreateMultiSourceFrameReaderAsync), METH_VARARGS, nullptr },
        { "create_relative_panel_watcher", reinterpret_cast<PyCFunction>(MediaCapture_CreateRelativePanelWatcher), METH_VARARGS, nullptr },
        { "get_encoder_property", reinterpret_cast<PyCFunction>(MediaCapture_GetEncoderProperty), METH_VARARGS, nullptr },
        { "get_preview_frame_async", reinterpret_cast<PyCFunction>(MediaCapture_GetPreviewFrameAsync), METH_VARARGS, nullptr },
        { "get_preview_mirroring", reinterpret_cast<PyCFunction>(MediaCapture_GetPreviewMirroring), METH_VARARGS, nullptr },
        { "get_preview_rotation", reinterpret_cast<PyCFunction>(MediaCapture_GetPreviewRotation), METH_VARARGS, nullptr },
        { "get_record_rotation", reinterpret_cast<PyCFunction>(MediaCapture_GetRecordRotation), METH_VARARGS, nullptr },
        { "initialize_async", reinterpret_cast<PyCFunction>(MediaCapture_InitializeAsync), METH_VARARGS, nullptr },
        { "pause_record_async", reinterpret_cast<PyCFunction>(MediaCapture_PauseRecordAsync), METH_VARARGS, nullptr },
        { "pause_record_with_result_async", reinterpret_cast<PyCFunction>(MediaCapture_PauseRecordWithResultAsync), METH_VARARGS, nullptr },
        { "prepare_advanced_photo_capture_async", reinterpret_cast<PyCFunction>(MediaCapture_PrepareAdvancedPhotoCaptureAsync), METH_VARARGS, nullptr },
        { "prepare_low_lag_photo_capture_async", reinterpret_cast<PyCFunction>(MediaCapture_PrepareLowLagPhotoCaptureAsync), METH_VARARGS, nullptr },
        { "prepare_low_lag_photo_sequence_capture_async", reinterpret_cast<PyCFunction>(MediaCapture_PrepareLowLagPhotoSequenceCaptureAsync), METH_VARARGS, nullptr },
        { "prepare_low_lag_record_to_custom_sink_async", reinterpret_cast<PyCFunction>(MediaCapture_PrepareLowLagRecordToCustomSinkAsync), METH_VARARGS, nullptr },
        { "prepare_low_lag_record_to_storage_file_async", reinterpret_cast<PyCFunction>(MediaCapture_PrepareLowLagRecordToStorageFileAsync), METH_VARARGS, nullptr },
        { "prepare_low_lag_record_to_stream_async", reinterpret_cast<PyCFunction>(MediaCapture_PrepareLowLagRecordToStreamAsync), METH_VARARGS, nullptr },
        { "prepare_variable_photo_sequence_capture_async", reinterpret_cast<PyCFunction>(MediaCapture_PrepareVariablePhotoSequenceCaptureAsync), METH_VARARGS, nullptr },
        { "remove_effect_async", reinterpret_cast<PyCFunction>(MediaCapture_RemoveEffectAsync), METH_VARARGS, nullptr },
        { "resume_record_async", reinterpret_cast<PyCFunction>(MediaCapture_ResumeRecordAsync), METH_VARARGS, nullptr },
        { "set_encoder_property", reinterpret_cast<PyCFunction>(MediaCapture_SetEncoderProperty), METH_VARARGS, nullptr },
        { "set_encoding_properties_async", reinterpret_cast<PyCFunction>(MediaCapture_SetEncodingPropertiesAsync), METH_VARARGS, nullptr },
        { "set_preview_mirroring", reinterpret_cast<PyCFunction>(MediaCapture_SetPreviewMirroring), METH_VARARGS, nullptr },
        { "set_preview_rotation", reinterpret_cast<PyCFunction>(MediaCapture_SetPreviewRotation), METH_VARARGS, nullptr },
        { "set_record_rotation", reinterpret_cast<PyCFunction>(MediaCapture_SetRecordRotation), METH_VARARGS, nullptr },
        { "start_preview_async", reinterpret_cast<PyCFunction>(MediaCapture_StartPreviewAsync), METH_VARARGS, nullptr },
        { "start_preview_to_custom_sink_async", reinterpret_cast<PyCFunction>(MediaCapture_StartPreviewToCustomSinkAsync), METH_VARARGS, nullptr },
        { "start_record_to_custom_sink_async", reinterpret_cast<PyCFunction>(MediaCapture_StartRecordToCustomSinkAsync), METH_VARARGS, nullptr },
        { "start_record_to_storage_file_async", reinterpret_cast<PyCFunction>(MediaCapture_StartRecordToStorageFileAsync), METH_VARARGS, nullptr },
        { "start_record_to_stream_async", reinterpret_cast<PyCFunction>(MediaCapture_StartRecordToStreamAsync), METH_VARARGS, nullptr },
        { "stop_preview_async", reinterpret_cast<PyCFunction>(MediaCapture_StopPreviewAsync), METH_VARARGS, nullptr },
        { "stop_record_async", reinterpret_cast<PyCFunction>(MediaCapture_StopRecordAsync), METH_VARARGS, nullptr },
        { "stop_record_with_result_async", reinterpret_cast<PyCFunction>(MediaCapture_StopRecordWithResultAsync), METH_VARARGS, nullptr },
        { "add_failed", reinterpret_cast<PyCFunction>(MediaCapture_add_Failed), METH_O, nullptr },
        { "remove_failed", reinterpret_cast<PyCFunction>(MediaCapture_remove_Failed), METH_O, nullptr },
        { "add_record_limitation_exceeded", reinterpret_cast<PyCFunction>(MediaCapture_add_RecordLimitationExceeded), METH_O, nullptr },
        { "remove_record_limitation_exceeded", reinterpret_cast<PyCFunction>(MediaCapture_remove_RecordLimitationExceeded), METH_O, nullptr },
        { "add_focus_changed", reinterpret_cast<PyCFunction>(MediaCapture_add_FocusChanged), METH_O, nullptr },
        { "remove_focus_changed", reinterpret_cast<PyCFunction>(MediaCapture_remove_FocusChanged), METH_O, nullptr },
        { "add_photo_confirmation_captured", reinterpret_cast<PyCFunction>(MediaCapture_add_PhotoConfirmationCaptured), METH_O, nullptr },
        { "remove_photo_confirmation_captured", reinterpret_cast<PyCFunction>(MediaCapture_remove_PhotoConfirmationCaptured), METH_O, nullptr },
        { "add_camera_stream_state_changed", reinterpret_cast<PyCFunction>(MediaCapture_add_CameraStreamStateChanged), METH_O, nullptr },
        { "remove_camera_stream_state_changed", reinterpret_cast<PyCFunction>(MediaCapture_remove_CameraStreamStateChanged), METH_O, nullptr },
        { "add_thermal_status_changed", reinterpret_cast<PyCFunction>(MediaCapture_add_ThermalStatusChanged), METH_O, nullptr },
        { "remove_thermal_status_changed", reinterpret_cast<PyCFunction>(MediaCapture_remove_ThermalStatusChanged), METH_O, nullptr },
        { "add_capture_device_exclusive_control_status_changed", reinterpret_cast<PyCFunction>(MediaCapture_add_CaptureDeviceExclusiveControlStatusChanged), METH_O, nullptr },
        { "remove_capture_device_exclusive_control_status_changed", reinterpret_cast<PyCFunction>(MediaCapture_remove_CaptureDeviceExclusiveControlStatusChanged), METH_O, nullptr },
        { "_assign_array_", _assign_array_MediaCapture, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MediaCapture), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_MediaCapture), METH_NOARGS, nullptr },
        { "__exit__", reinterpret_cast<PyCFunction>(_exit_MediaCapture), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_MediaCapture[] = {
        { "audio_device_controller", reinterpret_cast<getter>(MediaCapture_get_AudioDeviceController), nullptr, nullptr, nullptr },
        { "media_capture_settings", reinterpret_cast<getter>(MediaCapture_get_MediaCaptureSettings), nullptr, nullptr, nullptr },
        { "video_device_controller", reinterpret_cast<getter>(MediaCapture_get_VideoDeviceController), nullptr, nullptr, nullptr },
        { "camera_stream_state", reinterpret_cast<getter>(MediaCapture_get_CameraStreamState), nullptr, nullptr, nullptr },
        { "thermal_status", reinterpret_cast<getter>(MediaCapture_get_ThermalStatus), nullptr, nullptr, nullptr },
        { "frame_sources", reinterpret_cast<getter>(MediaCapture_get_FrameSources), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MediaCapture[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_MediaCapture) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MediaCapture) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MediaCapture) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MediaCapture) },
        { }
    };

    static PyType_Spec type_spec_MediaCapture = {
        "winrt._winrt_windows_media_capture.MediaCapture",
        sizeof(py::wrapper::Windows::Media::Capture::MediaCapture),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MediaCapture};

    static PyGetSetDef getset_MediaCapture_Static[] = {
        { }
    };

    static PyMethodDef methods_MediaCapture_Static[] = {
        { "find_all_video_profiles", reinterpret_cast<PyCFunction>(MediaCapture_FindAllVideoProfiles), METH_VARARGS, nullptr },
        { "find_concurrent_profiles", reinterpret_cast<PyCFunction>(MediaCapture_FindConcurrentProfiles), METH_VARARGS, nullptr },
        { "find_known_video_profiles", reinterpret_cast<PyCFunction>(MediaCapture_FindKnownVideoProfiles), METH_VARARGS, nullptr },
        { "is_video_profile_supported", reinterpret_cast<PyCFunction>(MediaCapture_IsVideoProfileSupported), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_MediaCapture_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_MediaCapture_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_MediaCapture_Static) },
        { }
    };

    static PyType_Spec type_spec_MediaCapture_Static =
    {
        "winrt._winrt_windows_media_capture.MediaCapture_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_MediaCapture_Static
    };

    // ----- MediaCaptureDeviceExclusiveControlStatusChangedEventArgs class --------------------

    static PyObject* _new_MediaCaptureDeviceExclusiveControlStatusChangedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Capture::MediaCaptureDeviceExclusiveControlStatusChangedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Capture::MediaCaptureDeviceExclusiveControlStatusChangedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_MediaCaptureDeviceExclusiveControlStatusChangedEventArgs(py::wrapper::Windows::Media::Capture::MediaCaptureDeviceExclusiveControlStatusChangedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MediaCaptureDeviceExclusiveControlStatusChangedEventArgs_get_DeviceId(py::wrapper::Windows::Media::Capture::MediaCaptureDeviceExclusiveControlStatusChangedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.MediaCaptureDeviceExclusiveControlStatusChangedEventArgs", L"DeviceId"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DeviceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaCaptureDeviceExclusiveControlStatusChangedEventArgs_get_Status(py::wrapper::Windows::Media::Capture::MediaCaptureDeviceExclusiveControlStatusChangedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.MediaCaptureDeviceExclusiveControlStatusChangedEventArgs", L"Status"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MediaCaptureDeviceExclusiveControlStatusChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Capture::MediaCaptureDeviceExclusiveControlStatusChangedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MediaCaptureDeviceExclusiveControlStatusChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Capture::MediaCaptureDeviceExclusiveControlStatusChangedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MediaCaptureDeviceExclusiveControlStatusChangedEventArgs[] = {
        { "_assign_array_", _assign_array_MediaCaptureDeviceExclusiveControlStatusChangedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MediaCaptureDeviceExclusiveControlStatusChangedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MediaCaptureDeviceExclusiveControlStatusChangedEventArgs[] = {
        { "device_id", reinterpret_cast<getter>(MediaCaptureDeviceExclusiveControlStatusChangedEventArgs_get_DeviceId), nullptr, nullptr, nullptr },
        { "status", reinterpret_cast<getter>(MediaCaptureDeviceExclusiveControlStatusChangedEventArgs_get_Status), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MediaCaptureDeviceExclusiveControlStatusChangedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_MediaCaptureDeviceExclusiveControlStatusChangedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MediaCaptureDeviceExclusiveControlStatusChangedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MediaCaptureDeviceExclusiveControlStatusChangedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MediaCaptureDeviceExclusiveControlStatusChangedEventArgs) },
        { }
    };

    static PyType_Spec type_spec_MediaCaptureDeviceExclusiveControlStatusChangedEventArgs = {
        "winrt._winrt_windows_media_capture.MediaCaptureDeviceExclusiveControlStatusChangedEventArgs",
        sizeof(py::wrapper::Windows::Media::Capture::MediaCaptureDeviceExclusiveControlStatusChangedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MediaCaptureDeviceExclusiveControlStatusChangedEventArgs};

    // ----- MediaCaptureFailedEventArgs class --------------------

    static PyObject* _new_MediaCaptureFailedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Capture::MediaCaptureFailedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Capture::MediaCaptureFailedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_MediaCaptureFailedEventArgs(py::wrapper::Windows::Media::Capture::MediaCaptureFailedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MediaCaptureFailedEventArgs_get_Code(py::wrapper::Windows::Media::Capture::MediaCaptureFailedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.MediaCaptureFailedEventArgs", L"Code"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Code());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaCaptureFailedEventArgs_get_Message(py::wrapper::Windows::Media::Capture::MediaCaptureFailedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.MediaCaptureFailedEventArgs", L"Message"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Message());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MediaCaptureFailedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Capture::MediaCaptureFailedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MediaCaptureFailedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Capture::MediaCaptureFailedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MediaCaptureFailedEventArgs[] = {
        { "_assign_array_", _assign_array_MediaCaptureFailedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MediaCaptureFailedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MediaCaptureFailedEventArgs[] = {
        { "code", reinterpret_cast<getter>(MediaCaptureFailedEventArgs_get_Code), nullptr, nullptr, nullptr },
        { "message", reinterpret_cast<getter>(MediaCaptureFailedEventArgs_get_Message), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MediaCaptureFailedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_MediaCaptureFailedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MediaCaptureFailedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MediaCaptureFailedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MediaCaptureFailedEventArgs) },
        { }
    };

    static PyType_Spec type_spec_MediaCaptureFailedEventArgs = {
        "winrt._winrt_windows_media_capture.MediaCaptureFailedEventArgs",
        sizeof(py::wrapper::Windows::Media::Capture::MediaCaptureFailedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MediaCaptureFailedEventArgs};

    // ----- MediaCaptureFocusChangedEventArgs class --------------------

    static PyObject* _new_MediaCaptureFocusChangedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Capture::MediaCaptureFocusChangedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Capture::MediaCaptureFocusChangedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_MediaCaptureFocusChangedEventArgs(py::wrapper::Windows::Media::Capture::MediaCaptureFocusChangedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MediaCaptureFocusChangedEventArgs_get_FocusState(py::wrapper::Windows::Media::Capture::MediaCaptureFocusChangedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.MediaCaptureFocusChangedEventArgs", L"FocusState"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.FocusState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MediaCaptureFocusChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Capture::MediaCaptureFocusChangedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MediaCaptureFocusChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Capture::MediaCaptureFocusChangedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MediaCaptureFocusChangedEventArgs[] = {
        { "_assign_array_", _assign_array_MediaCaptureFocusChangedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MediaCaptureFocusChangedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MediaCaptureFocusChangedEventArgs[] = {
        { "focus_state", reinterpret_cast<getter>(MediaCaptureFocusChangedEventArgs_get_FocusState), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MediaCaptureFocusChangedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_MediaCaptureFocusChangedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MediaCaptureFocusChangedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MediaCaptureFocusChangedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MediaCaptureFocusChangedEventArgs) },
        { }
    };

    static PyType_Spec type_spec_MediaCaptureFocusChangedEventArgs = {
        "winrt._winrt_windows_media_capture.MediaCaptureFocusChangedEventArgs",
        sizeof(py::wrapper::Windows::Media::Capture::MediaCaptureFocusChangedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MediaCaptureFocusChangedEventArgs};

    // ----- MediaCaptureInitializationSettings class --------------------

    static PyObject* _new_MediaCaptureInitializationSettings(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Media::Capture::MediaCaptureInitializationSettings instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_MediaCaptureInitializationSettings(py::wrapper::Windows::Media::Capture::MediaCaptureInitializationSettings* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MediaCaptureInitializationSettings_get_VideoDeviceId(py::wrapper::Windows::Media::Capture::MediaCaptureInitializationSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.MediaCaptureInitializationSettings", L"VideoDeviceId"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.VideoDeviceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaCaptureInitializationSettings_put_VideoDeviceId(py::wrapper::Windows::Media::Capture::MediaCaptureInitializationSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.MediaCaptureInitializationSettings", L"VideoDeviceId"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.VideoDeviceId(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MediaCaptureInitializationSettings_get_StreamingCaptureMode(py::wrapper::Windows::Media::Capture::MediaCaptureInitializationSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.MediaCaptureInitializationSettings", L"StreamingCaptureMode"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.StreamingCaptureMode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaCaptureInitializationSettings_put_StreamingCaptureMode(py::wrapper::Windows::Media::Capture::MediaCaptureInitializationSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.MediaCaptureInitializationSettings", L"StreamingCaptureMode"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Media::Capture::StreamingCaptureMode>(arg);

            self->obj.StreamingCaptureMode(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MediaCaptureInitializationSettings_get_PhotoCaptureSource(py::wrapper::Windows::Media::Capture::MediaCaptureInitializationSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.MediaCaptureInitializationSettings", L"PhotoCaptureSource"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.PhotoCaptureSource());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaCaptureInitializationSettings_put_PhotoCaptureSource(py::wrapper::Windows::Media::Capture::MediaCaptureInitializationSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.MediaCaptureInitializationSettings", L"PhotoCaptureSource"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Media::Capture::PhotoCaptureSource>(arg);

            self->obj.PhotoCaptureSource(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MediaCaptureInitializationSettings_get_AudioDeviceId(py::wrapper::Windows::Media::Capture::MediaCaptureInitializationSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.MediaCaptureInitializationSettings", L"AudioDeviceId"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.AudioDeviceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaCaptureInitializationSettings_put_AudioDeviceId(py::wrapper::Windows::Media::Capture::MediaCaptureInitializationSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.MediaCaptureInitializationSettings", L"AudioDeviceId"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.AudioDeviceId(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MediaCaptureInitializationSettings_get_MediaCategory(py::wrapper::Windows::Media::Capture::MediaCaptureInitializationSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.MediaCaptureInitializationSettings", L"MediaCategory"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.MediaCategory());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaCaptureInitializationSettings_put_MediaCategory(py::wrapper::Windows::Media::Capture::MediaCaptureInitializationSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.MediaCaptureInitializationSettings", L"MediaCategory"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Media::Capture::MediaCategory>(arg);

            self->obj.MediaCategory(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MediaCaptureInitializationSettings_get_AudioProcessing(py::wrapper::Windows::Media::Capture::MediaCaptureInitializationSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.MediaCaptureInitializationSettings", L"AudioProcessing"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.AudioProcessing());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaCaptureInitializationSettings_put_AudioProcessing(py::wrapper::Windows::Media::Capture::MediaCaptureInitializationSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.MediaCaptureInitializationSettings", L"AudioProcessing"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Media::AudioProcessing>(arg);

            self->obj.AudioProcessing(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MediaCaptureInitializationSettings_get_VideoSource(py::wrapper::Windows::Media::Capture::MediaCaptureInitializationSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.MediaCaptureInitializationSettings", L"VideoSource"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.VideoSource());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaCaptureInitializationSettings_put_VideoSource(py::wrapper::Windows::Media::Capture::MediaCaptureInitializationSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.MediaCaptureInitializationSettings", L"VideoSource"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Media::Core::IMediaSource>(arg);

            self->obj.VideoSource(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MediaCaptureInitializationSettings_get_AudioSource(py::wrapper::Windows::Media::Capture::MediaCaptureInitializationSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.MediaCaptureInitializationSettings", L"AudioSource"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.AudioSource());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaCaptureInitializationSettings_put_AudioSource(py::wrapper::Windows::Media::Capture::MediaCaptureInitializationSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.MediaCaptureInitializationSettings", L"AudioSource"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Media::Core::IMediaSource>(arg);

            self->obj.AudioSource(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MediaCaptureInitializationSettings_get_VideoProfile(py::wrapper::Windows::Media::Capture::MediaCaptureInitializationSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.MediaCaptureInitializationSettings", L"VideoProfile"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.VideoProfile());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaCaptureInitializationSettings_put_VideoProfile(py::wrapper::Windows::Media::Capture::MediaCaptureInitializationSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.MediaCaptureInitializationSettings", L"VideoProfile"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Media::Capture::MediaCaptureVideoProfile>(arg);

            self->obj.VideoProfile(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MediaCaptureInitializationSettings_get_RecordMediaDescription(py::wrapper::Windows::Media::Capture::MediaCaptureInitializationSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.MediaCaptureInitializationSettings", L"RecordMediaDescription"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.RecordMediaDescription());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaCaptureInitializationSettings_put_RecordMediaDescription(py::wrapper::Windows::Media::Capture::MediaCaptureInitializationSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.MediaCaptureInitializationSettings", L"RecordMediaDescription"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Media::Capture::MediaCaptureVideoProfileMediaDescription>(arg);

            self->obj.RecordMediaDescription(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MediaCaptureInitializationSettings_get_PreviewMediaDescription(py::wrapper::Windows::Media::Capture::MediaCaptureInitializationSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.MediaCaptureInitializationSettings", L"PreviewMediaDescription"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.PreviewMediaDescription());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaCaptureInitializationSettings_put_PreviewMediaDescription(py::wrapper::Windows::Media::Capture::MediaCaptureInitializationSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.MediaCaptureInitializationSettings", L"PreviewMediaDescription"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Media::Capture::MediaCaptureVideoProfileMediaDescription>(arg);

            self->obj.PreviewMediaDescription(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MediaCaptureInitializationSettings_get_PhotoMediaDescription(py::wrapper::Windows::Media::Capture::MediaCaptureInitializationSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.MediaCaptureInitializationSettings", L"PhotoMediaDescription"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.PhotoMediaDescription());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaCaptureInitializationSettings_put_PhotoMediaDescription(py::wrapper::Windows::Media::Capture::MediaCaptureInitializationSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.MediaCaptureInitializationSettings", L"PhotoMediaDescription"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Media::Capture::MediaCaptureVideoProfileMediaDescription>(arg);

            self->obj.PhotoMediaDescription(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MediaCaptureInitializationSettings_get_SourceGroup(py::wrapper::Windows::Media::Capture::MediaCaptureInitializationSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.MediaCaptureInitializationSettings", L"SourceGroup"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SourceGroup());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaCaptureInitializationSettings_put_SourceGroup(py::wrapper::Windows::Media::Capture::MediaCaptureInitializationSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.MediaCaptureInitializationSettings", L"SourceGroup"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Media::Capture::Frames::MediaFrameSourceGroup>(arg);

            self->obj.SourceGroup(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MediaCaptureInitializationSettings_get_SharingMode(py::wrapper::Windows::Media::Capture::MediaCaptureInitializationSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.MediaCaptureInitializationSettings", L"SharingMode"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SharingMode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaCaptureInitializationSettings_put_SharingMode(py::wrapper::Windows::Media::Capture::MediaCaptureInitializationSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.MediaCaptureInitializationSettings", L"SharingMode"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Media::Capture::MediaCaptureSharingMode>(arg);

            self->obj.SharingMode(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MediaCaptureInitializationSettings_get_MemoryPreference(py::wrapper::Windows::Media::Capture::MediaCaptureInitializationSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.MediaCaptureInitializationSettings", L"MemoryPreference"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.MemoryPreference());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaCaptureInitializationSettings_put_MemoryPreference(py::wrapper::Windows::Media::Capture::MediaCaptureInitializationSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.MediaCaptureInitializationSettings", L"MemoryPreference"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Media::Capture::MediaCaptureMemoryPreference>(arg);

            self->obj.MemoryPreference(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MediaCaptureInitializationSettings_get_AlwaysPlaySystemShutterSound(py::wrapper::Windows::Media::Capture::MediaCaptureInitializationSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.MediaCaptureInitializationSettings", L"AlwaysPlaySystemShutterSound"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.AlwaysPlaySystemShutterSound());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaCaptureInitializationSettings_put_AlwaysPlaySystemShutterSound(py::wrapper::Windows::Media::Capture::MediaCaptureInitializationSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.MediaCaptureInitializationSettings", L"AlwaysPlaySystemShutterSound"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.AlwaysPlaySystemShutterSound(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MediaCaptureInitializationSettings_get_DeviceUriPasswordCredential(py::wrapper::Windows::Media::Capture::MediaCaptureInitializationSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.MediaCaptureInitializationSettings", L"DeviceUriPasswordCredential"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DeviceUriPasswordCredential());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaCaptureInitializationSettings_put_DeviceUriPasswordCredential(py::wrapper::Windows::Media::Capture::MediaCaptureInitializationSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.MediaCaptureInitializationSettings", L"DeviceUriPasswordCredential"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Security::Credentials::PasswordCredential>(arg);

            self->obj.DeviceUriPasswordCredential(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MediaCaptureInitializationSettings_get_DeviceUri(py::wrapper::Windows::Media::Capture::MediaCaptureInitializationSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.MediaCaptureInitializationSettings", L"DeviceUri"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DeviceUri());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaCaptureInitializationSettings_put_DeviceUri(py::wrapper::Windows::Media::Capture::MediaCaptureInitializationSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.MediaCaptureInitializationSettings", L"DeviceUri"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(arg);

            self->obj.DeviceUri(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_MediaCaptureInitializationSettings(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Capture::MediaCaptureInitializationSettings>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MediaCaptureInitializationSettings(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Capture::MediaCaptureInitializationSettings>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MediaCaptureInitializationSettings[] = {
        { "_assign_array_", _assign_array_MediaCaptureInitializationSettings, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MediaCaptureInitializationSettings), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MediaCaptureInitializationSettings[] = {
        { "video_device_id", reinterpret_cast<getter>(MediaCaptureInitializationSettings_get_VideoDeviceId), reinterpret_cast<setter>(MediaCaptureInitializationSettings_put_VideoDeviceId), nullptr, nullptr },
        { "streaming_capture_mode", reinterpret_cast<getter>(MediaCaptureInitializationSettings_get_StreamingCaptureMode), reinterpret_cast<setter>(MediaCaptureInitializationSettings_put_StreamingCaptureMode), nullptr, nullptr },
        { "photo_capture_source", reinterpret_cast<getter>(MediaCaptureInitializationSettings_get_PhotoCaptureSource), reinterpret_cast<setter>(MediaCaptureInitializationSettings_put_PhotoCaptureSource), nullptr, nullptr },
        { "audio_device_id", reinterpret_cast<getter>(MediaCaptureInitializationSettings_get_AudioDeviceId), reinterpret_cast<setter>(MediaCaptureInitializationSettings_put_AudioDeviceId), nullptr, nullptr },
        { "media_category", reinterpret_cast<getter>(MediaCaptureInitializationSettings_get_MediaCategory), reinterpret_cast<setter>(MediaCaptureInitializationSettings_put_MediaCategory), nullptr, nullptr },
        { "audio_processing", reinterpret_cast<getter>(MediaCaptureInitializationSettings_get_AudioProcessing), reinterpret_cast<setter>(MediaCaptureInitializationSettings_put_AudioProcessing), nullptr, nullptr },
        { "video_source", reinterpret_cast<getter>(MediaCaptureInitializationSettings_get_VideoSource), reinterpret_cast<setter>(MediaCaptureInitializationSettings_put_VideoSource), nullptr, nullptr },
        { "audio_source", reinterpret_cast<getter>(MediaCaptureInitializationSettings_get_AudioSource), reinterpret_cast<setter>(MediaCaptureInitializationSettings_put_AudioSource), nullptr, nullptr },
        { "video_profile", reinterpret_cast<getter>(MediaCaptureInitializationSettings_get_VideoProfile), reinterpret_cast<setter>(MediaCaptureInitializationSettings_put_VideoProfile), nullptr, nullptr },
        { "record_media_description", reinterpret_cast<getter>(MediaCaptureInitializationSettings_get_RecordMediaDescription), reinterpret_cast<setter>(MediaCaptureInitializationSettings_put_RecordMediaDescription), nullptr, nullptr },
        { "preview_media_description", reinterpret_cast<getter>(MediaCaptureInitializationSettings_get_PreviewMediaDescription), reinterpret_cast<setter>(MediaCaptureInitializationSettings_put_PreviewMediaDescription), nullptr, nullptr },
        { "photo_media_description", reinterpret_cast<getter>(MediaCaptureInitializationSettings_get_PhotoMediaDescription), reinterpret_cast<setter>(MediaCaptureInitializationSettings_put_PhotoMediaDescription), nullptr, nullptr },
        { "source_group", reinterpret_cast<getter>(MediaCaptureInitializationSettings_get_SourceGroup), reinterpret_cast<setter>(MediaCaptureInitializationSettings_put_SourceGroup), nullptr, nullptr },
        { "sharing_mode", reinterpret_cast<getter>(MediaCaptureInitializationSettings_get_SharingMode), reinterpret_cast<setter>(MediaCaptureInitializationSettings_put_SharingMode), nullptr, nullptr },
        { "memory_preference", reinterpret_cast<getter>(MediaCaptureInitializationSettings_get_MemoryPreference), reinterpret_cast<setter>(MediaCaptureInitializationSettings_put_MemoryPreference), nullptr, nullptr },
        { "always_play_system_shutter_sound", reinterpret_cast<getter>(MediaCaptureInitializationSettings_get_AlwaysPlaySystemShutterSound), reinterpret_cast<setter>(MediaCaptureInitializationSettings_put_AlwaysPlaySystemShutterSound), nullptr, nullptr },
        { "device_uri_password_credential", reinterpret_cast<getter>(MediaCaptureInitializationSettings_get_DeviceUriPasswordCredential), reinterpret_cast<setter>(MediaCaptureInitializationSettings_put_DeviceUriPasswordCredential), nullptr, nullptr },
        { "device_uri", reinterpret_cast<getter>(MediaCaptureInitializationSettings_get_DeviceUri), reinterpret_cast<setter>(MediaCaptureInitializationSettings_put_DeviceUri), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MediaCaptureInitializationSettings[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_MediaCaptureInitializationSettings) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MediaCaptureInitializationSettings) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MediaCaptureInitializationSettings) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MediaCaptureInitializationSettings) },
        { }
    };

    static PyType_Spec type_spec_MediaCaptureInitializationSettings = {
        "winrt._winrt_windows_media_capture.MediaCaptureInitializationSettings",
        sizeof(py::wrapper::Windows::Media::Capture::MediaCaptureInitializationSettings),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MediaCaptureInitializationSettings};

    // ----- MediaCapturePauseResult class --------------------

    static PyObject* _new_MediaCapturePauseResult(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Capture::MediaCapturePauseResult>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Capture::MediaCapturePauseResult>::type_name);
        return nullptr;
    }

    static void _dealloc_MediaCapturePauseResult(py::wrapper::Windows::Media::Capture::MediaCapturePauseResult* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MediaCapturePauseResult_Close(py::wrapper::Windows::Media::Capture::MediaCapturePauseResult* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Capture.MediaCapturePauseResult", L"Close", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaCapturePauseResult_get_LastFrame(py::wrapper::Windows::Media::Capture::MediaCapturePauseResult* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.MediaCapturePauseResult", L"LastFrame"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.LastFrame());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaCapturePauseResult_get_RecordDuration(py::wrapper::Windows::Media::Capture::MediaCapturePauseResult* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.MediaCapturePauseResult", L"RecordDuration"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.RecordDuration());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MediaCapturePauseResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Capture::MediaCapturePauseResult>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MediaCapturePauseResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Capture::MediaCapturePauseResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_MediaCapturePauseResult(py::wrapper::Windows::Media::Capture::MediaCapturePauseResult* self, PyObject* /*unused*/) noexcept
    {
        return Py_NewRef(self);
    }

    static PyObject* _exit_MediaCapturePauseResult(py::wrapper::Windows::Media::Capture::MediaCapturePauseResult* self, PyObject* /*unused*/) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MediaCapturePauseResult[] = {
        { "close", reinterpret_cast<PyCFunction>(MediaCapturePauseResult_Close), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_MediaCapturePauseResult, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MediaCapturePauseResult), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_MediaCapturePauseResult), METH_NOARGS, nullptr },
        { "__exit__", reinterpret_cast<PyCFunction>(_exit_MediaCapturePauseResult), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_MediaCapturePauseResult[] = {
        { "last_frame", reinterpret_cast<getter>(MediaCapturePauseResult_get_LastFrame), nullptr, nullptr, nullptr },
        { "record_duration", reinterpret_cast<getter>(MediaCapturePauseResult_get_RecordDuration), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MediaCapturePauseResult[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_MediaCapturePauseResult) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MediaCapturePauseResult) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MediaCapturePauseResult) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MediaCapturePauseResult) },
        { }
    };

    static PyType_Spec type_spec_MediaCapturePauseResult = {
        "winrt._winrt_windows_media_capture.MediaCapturePauseResult",
        sizeof(py::wrapper::Windows::Media::Capture::MediaCapturePauseResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MediaCapturePauseResult};

    // ----- MediaCaptureRelativePanelWatcher class --------------------

    static PyObject* _new_MediaCaptureRelativePanelWatcher(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Capture::MediaCaptureRelativePanelWatcher>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Capture::MediaCaptureRelativePanelWatcher>::type_name);
        return nullptr;
    }

    static void _dealloc_MediaCaptureRelativePanelWatcher(py::wrapper::Windows::Media::Capture::MediaCaptureRelativePanelWatcher* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MediaCaptureRelativePanelWatcher_Close(py::wrapper::Windows::Media::Capture::MediaCaptureRelativePanelWatcher* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Capture.MediaCaptureRelativePanelWatcher", L"Close", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaCaptureRelativePanelWatcher_Start(py::wrapper::Windows::Media::Capture::MediaCaptureRelativePanelWatcher* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Capture.MediaCaptureRelativePanelWatcher", L"Start", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Start();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaCaptureRelativePanelWatcher_Stop(py::wrapper::Windows::Media::Capture::MediaCaptureRelativePanelWatcher* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Capture.MediaCaptureRelativePanelWatcher", L"Stop", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Stop();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaCaptureRelativePanelWatcher_get_RelativePanel(py::wrapper::Windows::Media::Capture::MediaCaptureRelativePanelWatcher* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.MediaCaptureRelativePanelWatcher", L"RelativePanel"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.RelativePanel());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaCaptureRelativePanelWatcher_add_Changed(py::wrapper::Windows::Media::Capture::MediaCaptureRelativePanelWatcher* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Capture.MediaCaptureRelativePanelWatcher", L"Changed"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Capture::MediaCaptureRelativePanelWatcher, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.Changed(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaCaptureRelativePanelWatcher_remove_Changed(py::wrapper::Windows::Media::Capture::MediaCaptureRelativePanelWatcher* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Capture.MediaCaptureRelativePanelWatcher", L"Changed"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Changed(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MediaCaptureRelativePanelWatcher(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Capture::MediaCaptureRelativePanelWatcher>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MediaCaptureRelativePanelWatcher(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Capture::MediaCaptureRelativePanelWatcher>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_MediaCaptureRelativePanelWatcher(py::wrapper::Windows::Media::Capture::MediaCaptureRelativePanelWatcher* self, PyObject* /*unused*/) noexcept
    {
        return Py_NewRef(self);
    }

    static PyObject* _exit_MediaCaptureRelativePanelWatcher(py::wrapper::Windows::Media::Capture::MediaCaptureRelativePanelWatcher* self, PyObject* /*unused*/) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MediaCaptureRelativePanelWatcher[] = {
        { "close", reinterpret_cast<PyCFunction>(MediaCaptureRelativePanelWatcher_Close), METH_VARARGS, nullptr },
        { "start", reinterpret_cast<PyCFunction>(MediaCaptureRelativePanelWatcher_Start), METH_VARARGS, nullptr },
        { "stop", reinterpret_cast<PyCFunction>(MediaCaptureRelativePanelWatcher_Stop), METH_VARARGS, nullptr },
        { "add_changed", reinterpret_cast<PyCFunction>(MediaCaptureRelativePanelWatcher_add_Changed), METH_O, nullptr },
        { "remove_changed", reinterpret_cast<PyCFunction>(MediaCaptureRelativePanelWatcher_remove_Changed), METH_O, nullptr },
        { "_assign_array_", _assign_array_MediaCaptureRelativePanelWatcher, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MediaCaptureRelativePanelWatcher), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_MediaCaptureRelativePanelWatcher), METH_NOARGS, nullptr },
        { "__exit__", reinterpret_cast<PyCFunction>(_exit_MediaCaptureRelativePanelWatcher), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_MediaCaptureRelativePanelWatcher[] = {
        { "relative_panel", reinterpret_cast<getter>(MediaCaptureRelativePanelWatcher_get_RelativePanel), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MediaCaptureRelativePanelWatcher[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_MediaCaptureRelativePanelWatcher) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MediaCaptureRelativePanelWatcher) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MediaCaptureRelativePanelWatcher) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MediaCaptureRelativePanelWatcher) },
        { }
    };

    static PyType_Spec type_spec_MediaCaptureRelativePanelWatcher = {
        "winrt._winrt_windows_media_capture.MediaCaptureRelativePanelWatcher",
        sizeof(py::wrapper::Windows::Media::Capture::MediaCaptureRelativePanelWatcher),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MediaCaptureRelativePanelWatcher};

    // ----- MediaCaptureSettings class --------------------

    static PyObject* _new_MediaCaptureSettings(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Capture::MediaCaptureSettings>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Capture::MediaCaptureSettings>::type_name);
        return nullptr;
    }

    static void _dealloc_MediaCaptureSettings(py::wrapper::Windows::Media::Capture::MediaCaptureSettings* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MediaCaptureSettings_get_AudioDeviceId(py::wrapper::Windows::Media::Capture::MediaCaptureSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.MediaCaptureSettings", L"AudioDeviceId"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.AudioDeviceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaCaptureSettings_get_PhotoCaptureSource(py::wrapper::Windows::Media::Capture::MediaCaptureSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.MediaCaptureSettings", L"PhotoCaptureSource"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.PhotoCaptureSource());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaCaptureSettings_get_StreamingCaptureMode(py::wrapper::Windows::Media::Capture::MediaCaptureSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.MediaCaptureSettings", L"StreamingCaptureMode"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.StreamingCaptureMode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaCaptureSettings_get_VideoDeviceCharacteristic(py::wrapper::Windows::Media::Capture::MediaCaptureSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.MediaCaptureSettings", L"VideoDeviceCharacteristic"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.VideoDeviceCharacteristic());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaCaptureSettings_get_VideoDeviceId(py::wrapper::Windows::Media::Capture::MediaCaptureSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.MediaCaptureSettings", L"VideoDeviceId"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.VideoDeviceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaCaptureSettings_get_AudioProcessing(py::wrapper::Windows::Media::Capture::MediaCaptureSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.MediaCaptureSettings", L"AudioProcessing"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.AudioProcessing());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaCaptureSettings_get_CameraSoundRequiredForRegion(py::wrapper::Windows::Media::Capture::MediaCaptureSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.MediaCaptureSettings", L"CameraSoundRequiredForRegion"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CameraSoundRequiredForRegion());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaCaptureSettings_get_ConcurrentRecordAndPhotoSequenceSupported(py::wrapper::Windows::Media::Capture::MediaCaptureSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.MediaCaptureSettings", L"ConcurrentRecordAndPhotoSequenceSupported"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ConcurrentRecordAndPhotoSequenceSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaCaptureSettings_get_ConcurrentRecordAndPhotoSupported(py::wrapper::Windows::Media::Capture::MediaCaptureSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.MediaCaptureSettings", L"ConcurrentRecordAndPhotoSupported"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ConcurrentRecordAndPhotoSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaCaptureSettings_get_Horizontal35mmEquivalentFocalLength(py::wrapper::Windows::Media::Capture::MediaCaptureSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.MediaCaptureSettings", L"Horizontal35mmEquivalentFocalLength"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Horizontal35mmEquivalentFocalLength());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaCaptureSettings_get_MediaCategory(py::wrapper::Windows::Media::Capture::MediaCaptureSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.MediaCaptureSettings", L"MediaCategory"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.MediaCategory());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaCaptureSettings_get_PitchOffsetDegrees(py::wrapper::Windows::Media::Capture::MediaCaptureSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.MediaCaptureSettings", L"PitchOffsetDegrees"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.PitchOffsetDegrees());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaCaptureSettings_get_Vertical35mmEquivalentFocalLength(py::wrapper::Windows::Media::Capture::MediaCaptureSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.MediaCaptureSettings", L"Vertical35mmEquivalentFocalLength"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Vertical35mmEquivalentFocalLength());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaCaptureSettings_get_Direct3D11Device(py::wrapper::Windows::Media::Capture::MediaCaptureSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.MediaCaptureSettings", L"Direct3D11Device"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Direct3D11Device());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MediaCaptureSettings(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Capture::MediaCaptureSettings>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MediaCaptureSettings(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Capture::MediaCaptureSettings>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MediaCaptureSettings[] = {
        { "_assign_array_", _assign_array_MediaCaptureSettings, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MediaCaptureSettings), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MediaCaptureSettings[] = {
        { "audio_device_id", reinterpret_cast<getter>(MediaCaptureSettings_get_AudioDeviceId), nullptr, nullptr, nullptr },
        { "photo_capture_source", reinterpret_cast<getter>(MediaCaptureSettings_get_PhotoCaptureSource), nullptr, nullptr, nullptr },
        { "streaming_capture_mode", reinterpret_cast<getter>(MediaCaptureSettings_get_StreamingCaptureMode), nullptr, nullptr, nullptr },
        { "video_device_characteristic", reinterpret_cast<getter>(MediaCaptureSettings_get_VideoDeviceCharacteristic), nullptr, nullptr, nullptr },
        { "video_device_id", reinterpret_cast<getter>(MediaCaptureSettings_get_VideoDeviceId), nullptr, nullptr, nullptr },
        { "audio_processing", reinterpret_cast<getter>(MediaCaptureSettings_get_AudioProcessing), nullptr, nullptr, nullptr },
        { "camera_sound_required_for_region", reinterpret_cast<getter>(MediaCaptureSettings_get_CameraSoundRequiredForRegion), nullptr, nullptr, nullptr },
        { "concurrent_record_and_photo_sequence_supported", reinterpret_cast<getter>(MediaCaptureSettings_get_ConcurrentRecordAndPhotoSequenceSupported), nullptr, nullptr, nullptr },
        { "concurrent_record_and_photo_supported", reinterpret_cast<getter>(MediaCaptureSettings_get_ConcurrentRecordAndPhotoSupported), nullptr, nullptr, nullptr },
        { "horizontal35mm_equivalent_focal_length", reinterpret_cast<getter>(MediaCaptureSettings_get_Horizontal35mmEquivalentFocalLength), nullptr, nullptr, nullptr },
        { "media_category", reinterpret_cast<getter>(MediaCaptureSettings_get_MediaCategory), nullptr, nullptr, nullptr },
        { "pitch_offset_degrees", reinterpret_cast<getter>(MediaCaptureSettings_get_PitchOffsetDegrees), nullptr, nullptr, nullptr },
        { "vertical35mm_equivalent_focal_length", reinterpret_cast<getter>(MediaCaptureSettings_get_Vertical35mmEquivalentFocalLength), nullptr, nullptr, nullptr },
        { "direct3_d11_device", reinterpret_cast<getter>(MediaCaptureSettings_get_Direct3D11Device), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MediaCaptureSettings[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_MediaCaptureSettings) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MediaCaptureSettings) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MediaCaptureSettings) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MediaCaptureSettings) },
        { }
    };

    static PyType_Spec type_spec_MediaCaptureSettings = {
        "winrt._winrt_windows_media_capture.MediaCaptureSettings",
        sizeof(py::wrapper::Windows::Media::Capture::MediaCaptureSettings),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MediaCaptureSettings};

    // ----- MediaCaptureStopResult class --------------------

    static PyObject* _new_MediaCaptureStopResult(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Capture::MediaCaptureStopResult>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Capture::MediaCaptureStopResult>::type_name);
        return nullptr;
    }

    static void _dealloc_MediaCaptureStopResult(py::wrapper::Windows::Media::Capture::MediaCaptureStopResult* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MediaCaptureStopResult_Close(py::wrapper::Windows::Media::Capture::MediaCaptureStopResult* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Capture.MediaCaptureStopResult", L"Close", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaCaptureStopResult_get_LastFrame(py::wrapper::Windows::Media::Capture::MediaCaptureStopResult* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.MediaCaptureStopResult", L"LastFrame"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.LastFrame());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaCaptureStopResult_get_RecordDuration(py::wrapper::Windows::Media::Capture::MediaCaptureStopResult* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.MediaCaptureStopResult", L"RecordDuration"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.RecordDuration());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MediaCaptureStopResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Capture::MediaCaptureStopResult>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MediaCaptureStopResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Capture::MediaCaptureStopResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_MediaCaptureStopResult(py::wrapper::Windows::Media::Capture::MediaCaptureStopResult* self, PyObject* /*unused*/) noexcept
    {
        return Py_NewRef(self);
    }

    static PyObject* _exit_MediaCaptureStopResult(py::wrapper::Windows::Media::Capture::MediaCaptureStopResult* self, PyObject* /*unused*/) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MediaCaptureStopResult[] = {
        { "close", reinterpret_cast<PyCFunction>(MediaCaptureStopResult_Close), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_MediaCaptureStopResult, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MediaCaptureStopResult), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_MediaCaptureStopResult), METH_NOARGS, nullptr },
        { "__exit__", reinterpret_cast<PyCFunction>(_exit_MediaCaptureStopResult), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_MediaCaptureStopResult[] = {
        { "last_frame", reinterpret_cast<getter>(MediaCaptureStopResult_get_LastFrame), nullptr, nullptr, nullptr },
        { "record_duration", reinterpret_cast<getter>(MediaCaptureStopResult_get_RecordDuration), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MediaCaptureStopResult[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_MediaCaptureStopResult) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MediaCaptureStopResult) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MediaCaptureStopResult) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MediaCaptureStopResult) },
        { }
    };

    static PyType_Spec type_spec_MediaCaptureStopResult = {
        "winrt._winrt_windows_media_capture.MediaCaptureStopResult",
        sizeof(py::wrapper::Windows::Media::Capture::MediaCaptureStopResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MediaCaptureStopResult};

    // ----- MediaCaptureVideoProfile class --------------------

    static PyObject* _new_MediaCaptureVideoProfile(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Capture::MediaCaptureVideoProfile>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Capture::MediaCaptureVideoProfile>::type_name);
        return nullptr;
    }

    static void _dealloc_MediaCaptureVideoProfile(py::wrapper::Windows::Media::Capture::MediaCaptureVideoProfile* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MediaCaptureVideoProfile_GetConcurrency(py::wrapper::Windows::Media::Capture::MediaCaptureVideoProfile* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Capture.MediaCaptureVideoProfile", L"GetConcurrency", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetConcurrency());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaCaptureVideoProfile_get_Id(py::wrapper::Windows::Media::Capture::MediaCaptureVideoProfile* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.MediaCaptureVideoProfile", L"Id"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Id());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaCaptureVideoProfile_get_SupportedPhotoMediaDescription(py::wrapper::Windows::Media::Capture::MediaCaptureVideoProfile* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.MediaCaptureVideoProfile", L"SupportedPhotoMediaDescription"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SupportedPhotoMediaDescription());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaCaptureVideoProfile_get_SupportedPreviewMediaDescription(py::wrapper::Windows::Media::Capture::MediaCaptureVideoProfile* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.MediaCaptureVideoProfile", L"SupportedPreviewMediaDescription"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SupportedPreviewMediaDescription());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaCaptureVideoProfile_get_SupportedRecordMediaDescription(py::wrapper::Windows::Media::Capture::MediaCaptureVideoProfile* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.MediaCaptureVideoProfile", L"SupportedRecordMediaDescription"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SupportedRecordMediaDescription());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaCaptureVideoProfile_get_VideoDeviceId(py::wrapper::Windows::Media::Capture::MediaCaptureVideoProfile* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.MediaCaptureVideoProfile", L"VideoDeviceId"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.VideoDeviceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaCaptureVideoProfile_get_FrameSourceInfos(py::wrapper::Windows::Media::Capture::MediaCaptureVideoProfile* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.MediaCaptureVideoProfile", L"FrameSourceInfos"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.FrameSourceInfos());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaCaptureVideoProfile_get_Properties(py::wrapper::Windows::Media::Capture::MediaCaptureVideoProfile* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.MediaCaptureVideoProfile", L"Properties"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Properties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MediaCaptureVideoProfile(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Capture::MediaCaptureVideoProfile>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MediaCaptureVideoProfile(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Capture::MediaCaptureVideoProfile>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MediaCaptureVideoProfile[] = {
        { "get_concurrency", reinterpret_cast<PyCFunction>(MediaCaptureVideoProfile_GetConcurrency), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_MediaCaptureVideoProfile, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MediaCaptureVideoProfile), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MediaCaptureVideoProfile[] = {
        { "id", reinterpret_cast<getter>(MediaCaptureVideoProfile_get_Id), nullptr, nullptr, nullptr },
        { "supported_photo_media_description", reinterpret_cast<getter>(MediaCaptureVideoProfile_get_SupportedPhotoMediaDescription), nullptr, nullptr, nullptr },
        { "supported_preview_media_description", reinterpret_cast<getter>(MediaCaptureVideoProfile_get_SupportedPreviewMediaDescription), nullptr, nullptr, nullptr },
        { "supported_record_media_description", reinterpret_cast<getter>(MediaCaptureVideoProfile_get_SupportedRecordMediaDescription), nullptr, nullptr, nullptr },
        { "video_device_id", reinterpret_cast<getter>(MediaCaptureVideoProfile_get_VideoDeviceId), nullptr, nullptr, nullptr },
        { "frame_source_infos", reinterpret_cast<getter>(MediaCaptureVideoProfile_get_FrameSourceInfos), nullptr, nullptr, nullptr },
        { "properties", reinterpret_cast<getter>(MediaCaptureVideoProfile_get_Properties), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MediaCaptureVideoProfile[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_MediaCaptureVideoProfile) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MediaCaptureVideoProfile) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MediaCaptureVideoProfile) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MediaCaptureVideoProfile) },
        { }
    };

    static PyType_Spec type_spec_MediaCaptureVideoProfile = {
        "winrt._winrt_windows_media_capture.MediaCaptureVideoProfile",
        sizeof(py::wrapper::Windows::Media::Capture::MediaCaptureVideoProfile),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MediaCaptureVideoProfile};

    // ----- MediaCaptureVideoProfileMediaDescription class --------------------

    static PyObject* _new_MediaCaptureVideoProfileMediaDescription(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Capture::MediaCaptureVideoProfileMediaDescription>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Capture::MediaCaptureVideoProfileMediaDescription>::type_name);
        return nullptr;
    }

    static void _dealloc_MediaCaptureVideoProfileMediaDescription(py::wrapper::Windows::Media::Capture::MediaCaptureVideoProfileMediaDescription* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MediaCaptureVideoProfileMediaDescription_get_FrameRate(py::wrapper::Windows::Media::Capture::MediaCaptureVideoProfileMediaDescription* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.MediaCaptureVideoProfileMediaDescription", L"FrameRate"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.FrameRate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaCaptureVideoProfileMediaDescription_get_Height(py::wrapper::Windows::Media::Capture::MediaCaptureVideoProfileMediaDescription* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.MediaCaptureVideoProfileMediaDescription", L"Height"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Height());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaCaptureVideoProfileMediaDescription_get_IsHdrVideoSupported(py::wrapper::Windows::Media::Capture::MediaCaptureVideoProfileMediaDescription* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.MediaCaptureVideoProfileMediaDescription", L"IsHdrVideoSupported"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsHdrVideoSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaCaptureVideoProfileMediaDescription_get_IsVariablePhotoSequenceSupported(py::wrapper::Windows::Media::Capture::MediaCaptureVideoProfileMediaDescription* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.MediaCaptureVideoProfileMediaDescription", L"IsVariablePhotoSequenceSupported"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsVariablePhotoSequenceSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaCaptureVideoProfileMediaDescription_get_Width(py::wrapper::Windows::Media::Capture::MediaCaptureVideoProfileMediaDescription* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.MediaCaptureVideoProfileMediaDescription", L"Width"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Width());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaCaptureVideoProfileMediaDescription_get_Properties(py::wrapper::Windows::Media::Capture::MediaCaptureVideoProfileMediaDescription* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.MediaCaptureVideoProfileMediaDescription", L"Properties"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Properties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaCaptureVideoProfileMediaDescription_get_Subtype(py::wrapper::Windows::Media::Capture::MediaCaptureVideoProfileMediaDescription* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.MediaCaptureVideoProfileMediaDescription", L"Subtype"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Subtype());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MediaCaptureVideoProfileMediaDescription(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Capture::MediaCaptureVideoProfileMediaDescription>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MediaCaptureVideoProfileMediaDescription(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Capture::MediaCaptureVideoProfileMediaDescription>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MediaCaptureVideoProfileMediaDescription[] = {
        { "_assign_array_", _assign_array_MediaCaptureVideoProfileMediaDescription, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MediaCaptureVideoProfileMediaDescription), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MediaCaptureVideoProfileMediaDescription[] = {
        { "frame_rate", reinterpret_cast<getter>(MediaCaptureVideoProfileMediaDescription_get_FrameRate), nullptr, nullptr, nullptr },
        { "height", reinterpret_cast<getter>(MediaCaptureVideoProfileMediaDescription_get_Height), nullptr, nullptr, nullptr },
        { "is_hdr_video_supported", reinterpret_cast<getter>(MediaCaptureVideoProfileMediaDescription_get_IsHdrVideoSupported), nullptr, nullptr, nullptr },
        { "is_variable_photo_sequence_supported", reinterpret_cast<getter>(MediaCaptureVideoProfileMediaDescription_get_IsVariablePhotoSequenceSupported), nullptr, nullptr, nullptr },
        { "width", reinterpret_cast<getter>(MediaCaptureVideoProfileMediaDescription_get_Width), nullptr, nullptr, nullptr },
        { "properties", reinterpret_cast<getter>(MediaCaptureVideoProfileMediaDescription_get_Properties), nullptr, nullptr, nullptr },
        { "subtype", reinterpret_cast<getter>(MediaCaptureVideoProfileMediaDescription_get_Subtype), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MediaCaptureVideoProfileMediaDescription[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_MediaCaptureVideoProfileMediaDescription) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MediaCaptureVideoProfileMediaDescription) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MediaCaptureVideoProfileMediaDescription) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MediaCaptureVideoProfileMediaDescription) },
        { }
    };

    static PyType_Spec type_spec_MediaCaptureVideoProfileMediaDescription = {
        "winrt._winrt_windows_media_capture.MediaCaptureVideoProfileMediaDescription",
        sizeof(py::wrapper::Windows::Media::Capture::MediaCaptureVideoProfileMediaDescription),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MediaCaptureVideoProfileMediaDescription};

    // ----- OptionalReferencePhotoCapturedEventArgs class --------------------

    static PyObject* _new_OptionalReferencePhotoCapturedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Capture::OptionalReferencePhotoCapturedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Capture::OptionalReferencePhotoCapturedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_OptionalReferencePhotoCapturedEventArgs(py::wrapper::Windows::Media::Capture::OptionalReferencePhotoCapturedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* OptionalReferencePhotoCapturedEventArgs_get_Context(py::wrapper::Windows::Media::Capture::OptionalReferencePhotoCapturedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.OptionalReferencePhotoCapturedEventArgs", L"Context"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Context());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* OptionalReferencePhotoCapturedEventArgs_get_Frame(py::wrapper::Windows::Media::Capture::OptionalReferencePhotoCapturedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.OptionalReferencePhotoCapturedEventArgs", L"Frame"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Frame());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_OptionalReferencePhotoCapturedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Capture::OptionalReferencePhotoCapturedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_OptionalReferencePhotoCapturedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Capture::OptionalReferencePhotoCapturedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_OptionalReferencePhotoCapturedEventArgs[] = {
        { "_assign_array_", _assign_array_OptionalReferencePhotoCapturedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_OptionalReferencePhotoCapturedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_OptionalReferencePhotoCapturedEventArgs[] = {
        { "context", reinterpret_cast<getter>(OptionalReferencePhotoCapturedEventArgs_get_Context), nullptr, nullptr, nullptr },
        { "frame", reinterpret_cast<getter>(OptionalReferencePhotoCapturedEventArgs_get_Frame), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_OptionalReferencePhotoCapturedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_OptionalReferencePhotoCapturedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_OptionalReferencePhotoCapturedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_OptionalReferencePhotoCapturedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_OptionalReferencePhotoCapturedEventArgs) },
        { }
    };

    static PyType_Spec type_spec_OptionalReferencePhotoCapturedEventArgs = {
        "winrt._winrt_windows_media_capture.OptionalReferencePhotoCapturedEventArgs",
        sizeof(py::wrapper::Windows::Media::Capture::OptionalReferencePhotoCapturedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_OptionalReferencePhotoCapturedEventArgs};

    // ----- PhotoCapturedEventArgs class --------------------

    static PyObject* _new_PhotoCapturedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Capture::PhotoCapturedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Capture::PhotoCapturedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_PhotoCapturedEventArgs(py::wrapper::Windows::Media::Capture::PhotoCapturedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PhotoCapturedEventArgs_get_CaptureTimeOffset(py::wrapper::Windows::Media::Capture::PhotoCapturedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.PhotoCapturedEventArgs", L"CaptureTimeOffset"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CaptureTimeOffset());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhotoCapturedEventArgs_get_Frame(py::wrapper::Windows::Media::Capture::PhotoCapturedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.PhotoCapturedEventArgs", L"Frame"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Frame());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhotoCapturedEventArgs_get_Thumbnail(py::wrapper::Windows::Media::Capture::PhotoCapturedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.PhotoCapturedEventArgs", L"Thumbnail"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Thumbnail());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PhotoCapturedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Capture::PhotoCapturedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PhotoCapturedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Capture::PhotoCapturedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PhotoCapturedEventArgs[] = {
        { "_assign_array_", _assign_array_PhotoCapturedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PhotoCapturedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PhotoCapturedEventArgs[] = {
        { "capture_time_offset", reinterpret_cast<getter>(PhotoCapturedEventArgs_get_CaptureTimeOffset), nullptr, nullptr, nullptr },
        { "frame", reinterpret_cast<getter>(PhotoCapturedEventArgs_get_Frame), nullptr, nullptr, nullptr },
        { "thumbnail", reinterpret_cast<getter>(PhotoCapturedEventArgs_get_Thumbnail), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PhotoCapturedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_PhotoCapturedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PhotoCapturedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PhotoCapturedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PhotoCapturedEventArgs) },
        { }
    };

    static PyType_Spec type_spec_PhotoCapturedEventArgs = {
        "winrt._winrt_windows_media_capture.PhotoCapturedEventArgs",
        sizeof(py::wrapper::Windows::Media::Capture::PhotoCapturedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PhotoCapturedEventArgs};

    // ----- PhotoConfirmationCapturedEventArgs class --------------------

    static PyObject* _new_PhotoConfirmationCapturedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Capture::PhotoConfirmationCapturedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Capture::PhotoConfirmationCapturedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_PhotoConfirmationCapturedEventArgs(py::wrapper::Windows::Media::Capture::PhotoConfirmationCapturedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PhotoConfirmationCapturedEventArgs_get_CaptureTimeOffset(py::wrapper::Windows::Media::Capture::PhotoConfirmationCapturedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.PhotoConfirmationCapturedEventArgs", L"CaptureTimeOffset"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CaptureTimeOffset());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhotoConfirmationCapturedEventArgs_get_Frame(py::wrapper::Windows::Media::Capture::PhotoConfirmationCapturedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.PhotoConfirmationCapturedEventArgs", L"Frame"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Frame());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PhotoConfirmationCapturedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Capture::PhotoConfirmationCapturedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PhotoConfirmationCapturedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Capture::PhotoConfirmationCapturedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PhotoConfirmationCapturedEventArgs[] = {
        { "_assign_array_", _assign_array_PhotoConfirmationCapturedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PhotoConfirmationCapturedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PhotoConfirmationCapturedEventArgs[] = {
        { "capture_time_offset", reinterpret_cast<getter>(PhotoConfirmationCapturedEventArgs_get_CaptureTimeOffset), nullptr, nullptr, nullptr },
        { "frame", reinterpret_cast<getter>(PhotoConfirmationCapturedEventArgs_get_Frame), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PhotoConfirmationCapturedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_PhotoConfirmationCapturedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PhotoConfirmationCapturedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PhotoConfirmationCapturedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PhotoConfirmationCapturedEventArgs) },
        { }
    };

    static PyType_Spec type_spec_PhotoConfirmationCapturedEventArgs = {
        "winrt._winrt_windows_media_capture.PhotoConfirmationCapturedEventArgs",
        sizeof(py::wrapper::Windows::Media::Capture::PhotoConfirmationCapturedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PhotoConfirmationCapturedEventArgs};

    // ----- ScreenCapture class --------------------

    static PyObject* _new_ScreenCapture(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Capture::ScreenCapture>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Capture::ScreenCapture>::type_name);
        return nullptr;
    }

    static void _dealloc_ScreenCapture(py::wrapper::Windows::Media::Capture::ScreenCapture* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ScreenCapture_GetForCurrentView(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Capture.ScreenCapture", L"GetForCurrentView", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(winrt::Windows::Media::Capture::ScreenCapture::GetForCurrentView());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ScreenCapture_get_AudioSource(py::wrapper::Windows::Media::Capture::ScreenCapture* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.ScreenCapture", L"AudioSource"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.AudioSource());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ScreenCapture_get_IsAudioSuspended(py::wrapper::Windows::Media::Capture::ScreenCapture* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.ScreenCapture", L"IsAudioSuspended"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsAudioSuspended());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ScreenCapture_get_IsVideoSuspended(py::wrapper::Windows::Media::Capture::ScreenCapture* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.ScreenCapture", L"IsVideoSuspended"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsVideoSuspended());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ScreenCapture_get_VideoSource(py::wrapper::Windows::Media::Capture::ScreenCapture* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.ScreenCapture", L"VideoSource"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.VideoSource());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ScreenCapture_add_SourceSuspensionChanged(py::wrapper::Windows::Media::Capture::ScreenCapture* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Capture.ScreenCapture", L"SourceSuspensionChanged"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Capture::ScreenCapture, winrt::Windows::Media::Capture::SourceSuspensionChangedEventArgs>>(arg);

            return py::convert(self->obj.SourceSuspensionChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ScreenCapture_remove_SourceSuspensionChanged(py::wrapper::Windows::Media::Capture::ScreenCapture* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Capture.ScreenCapture", L"SourceSuspensionChanged"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.SourceSuspensionChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ScreenCapture(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Capture::ScreenCapture>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ScreenCapture(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Capture::ScreenCapture>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ScreenCapture[] = {
        { "add_source_suspension_changed", reinterpret_cast<PyCFunction>(ScreenCapture_add_SourceSuspensionChanged), METH_O, nullptr },
        { "remove_source_suspension_changed", reinterpret_cast<PyCFunction>(ScreenCapture_remove_SourceSuspensionChanged), METH_O, nullptr },
        { "_assign_array_", _assign_array_ScreenCapture, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ScreenCapture), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ScreenCapture[] = {
        { "audio_source", reinterpret_cast<getter>(ScreenCapture_get_AudioSource), nullptr, nullptr, nullptr },
        { "is_audio_suspended", reinterpret_cast<getter>(ScreenCapture_get_IsAudioSuspended), nullptr, nullptr, nullptr },
        { "is_video_suspended", reinterpret_cast<getter>(ScreenCapture_get_IsVideoSuspended), nullptr, nullptr, nullptr },
        { "video_source", reinterpret_cast<getter>(ScreenCapture_get_VideoSource), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ScreenCapture[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ScreenCapture) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ScreenCapture) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ScreenCapture) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ScreenCapture) },
        { }
    };

    static PyType_Spec type_spec_ScreenCapture = {
        "winrt._winrt_windows_media_capture.ScreenCapture",
        sizeof(py::wrapper::Windows::Media::Capture::ScreenCapture),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ScreenCapture};

    static PyGetSetDef getset_ScreenCapture_Static[] = {
        { }
    };

    static PyMethodDef methods_ScreenCapture_Static[] = {
        { "get_for_current_view", reinterpret_cast<PyCFunction>(ScreenCapture_GetForCurrentView), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_ScreenCapture_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_ScreenCapture_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_ScreenCapture_Static) },
        { }
    };

    static PyType_Spec type_spec_ScreenCapture_Static =
    {
        "winrt._winrt_windows_media_capture.ScreenCapture_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_ScreenCapture_Static
    };

    // ----- SourceSuspensionChangedEventArgs class --------------------

    static PyObject* _new_SourceSuspensionChangedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Capture::SourceSuspensionChangedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Capture::SourceSuspensionChangedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_SourceSuspensionChangedEventArgs(py::wrapper::Windows::Media::Capture::SourceSuspensionChangedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SourceSuspensionChangedEventArgs_get_IsAudioSuspended(py::wrapper::Windows::Media::Capture::SourceSuspensionChangedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.SourceSuspensionChangedEventArgs", L"IsAudioSuspended"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsAudioSuspended());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SourceSuspensionChangedEventArgs_get_IsVideoSuspended(py::wrapper::Windows::Media::Capture::SourceSuspensionChangedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.SourceSuspensionChangedEventArgs", L"IsVideoSuspended"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsVideoSuspended());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SourceSuspensionChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Capture::SourceSuspensionChangedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SourceSuspensionChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Capture::SourceSuspensionChangedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SourceSuspensionChangedEventArgs[] = {
        { "_assign_array_", _assign_array_SourceSuspensionChangedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SourceSuspensionChangedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SourceSuspensionChangedEventArgs[] = {
        { "is_audio_suspended", reinterpret_cast<getter>(SourceSuspensionChangedEventArgs_get_IsAudioSuspended), nullptr, nullptr, nullptr },
        { "is_video_suspended", reinterpret_cast<getter>(SourceSuspensionChangedEventArgs_get_IsVideoSuspended), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SourceSuspensionChangedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_SourceSuspensionChangedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SourceSuspensionChangedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SourceSuspensionChangedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SourceSuspensionChangedEventArgs) },
        { }
    };

    static PyType_Spec type_spec_SourceSuspensionChangedEventArgs = {
        "winrt._winrt_windows_media_capture.SourceSuspensionChangedEventArgs",
        sizeof(py::wrapper::Windows::Media::Capture::SourceSuspensionChangedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SourceSuspensionChangedEventArgs};

    // ----- VideoStreamConfiguration class --------------------

    static PyObject* _new_VideoStreamConfiguration(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Capture::VideoStreamConfiguration>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Capture::VideoStreamConfiguration>::type_name);
        return nullptr;
    }

    static void _dealloc_VideoStreamConfiguration(py::wrapper::Windows::Media::Capture::VideoStreamConfiguration* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* VideoStreamConfiguration_get_InputProperties(py::wrapper::Windows::Media::Capture::VideoStreamConfiguration* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.VideoStreamConfiguration", L"InputProperties"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.InputProperties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VideoStreamConfiguration_get_OutputProperties(py::wrapper::Windows::Media::Capture::VideoStreamConfiguration* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Capture.VideoStreamConfiguration", L"OutputProperties"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.OutputProperties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_VideoStreamConfiguration(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Capture::VideoStreamConfiguration>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_VideoStreamConfiguration(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Capture::VideoStreamConfiguration>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_VideoStreamConfiguration[] = {
        { "_assign_array_", _assign_array_VideoStreamConfiguration, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_VideoStreamConfiguration), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_VideoStreamConfiguration[] = {
        { "input_properties", reinterpret_cast<getter>(VideoStreamConfiguration_get_InputProperties), nullptr, nullptr, nullptr },
        { "output_properties", reinterpret_cast<getter>(VideoStreamConfiguration_get_OutputProperties), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_VideoStreamConfiguration[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_VideoStreamConfiguration) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_VideoStreamConfiguration) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_VideoStreamConfiguration) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_VideoStreamConfiguration) },
        { }
    };

    static PyType_Spec type_spec_VideoStreamConfiguration = {
        "winrt._winrt_windows_media_capture.VideoStreamConfiguration",
        sizeof(py::wrapper::Windows::Media::Capture::VideoStreamConfiguration),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_VideoStreamConfiguration};

    // ----- WhiteBalanceGain struct --------------------

    winrt_struct_wrapper<winrt::Windows::Media::Capture::WhiteBalanceGain>* _new_WhiteBalanceGain(PyTypeObject* subclass, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        auto self = reinterpret_cast<winrt_struct_wrapper<winrt::Windows::Media::Capture::WhiteBalanceGain>*>(subclass->tp_alloc(subclass, 0));

        if (!self)
        {
            return nullptr;
        }

        std::construct_at(&self->obj);

        return self;
    }

    int _init_WhiteBalanceGain(winrt_struct_wrapper<winrt::Windows::Media::Capture::WhiteBalanceGain>* self, PyObject* args, PyObject* kwds) noexcept
    {
        auto tuple_size = PyTuple_Size(args);

        if ((tuple_size == 0) && (kwds == nullptr))
        {
            self->obj = {};
            return 0;
        }

        double _R{};
        double _G{};
        double _B{};

        static const char* kwlist[] = {"r", "g", "b", nullptr};
        if (!PyArg_ParseTupleAndKeywords(args, kwds, "ddd", const_cast<char**>(kwlist), &_R, &_G, &_B))
        {
            return -1;
        }

        try
        {
            self->obj.R = _R;
            self->obj.G = _G;
            self->obj.B = _B;

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static void _dealloc_WhiteBalanceGain(py::wrapper::Windows::Media::Capture::WhiteBalanceGain* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_WhiteBalanceGain(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Capture::WhiteBalanceGain>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyMethodDef _methods_WhiteBalanceGain[] = {
        { "_assign_array_", _assign_array_WhiteBalanceGain, METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyObject* WhiteBalanceGain_get_R(py::wrapper::Windows::Media::Capture::WhiteBalanceGain* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.R);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int WhiteBalanceGain_set_R(py::wrapper::Windows::Media::Capture::WhiteBalanceGain* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.R = py::converter<double>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* WhiteBalanceGain_get_G(py::wrapper::Windows::Media::Capture::WhiteBalanceGain* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.G);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int WhiteBalanceGain_set_G(py::wrapper::Windows::Media::Capture::WhiteBalanceGain* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.G = py::converter<double>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* WhiteBalanceGain_get_B(py::wrapper::Windows::Media::Capture::WhiteBalanceGain* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.B);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int WhiteBalanceGain_set_B(py::wrapper::Windows::Media::Capture::WhiteBalanceGain* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.B = py::converter<double>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyGetSetDef _getset_WhiteBalanceGain[] = {
        { "r", reinterpret_cast<getter>(WhiteBalanceGain_get_R), reinterpret_cast<setter>(WhiteBalanceGain_set_R), nullptr, nullptr },
        { "g", reinterpret_cast<getter>(WhiteBalanceGain_get_G), reinterpret_cast<setter>(WhiteBalanceGain_set_G), nullptr, nullptr },
        { "b", reinterpret_cast<getter>(WhiteBalanceGain_get_B), reinterpret_cast<setter>(WhiteBalanceGain_set_B), nullptr, nullptr },
        { }
    };

    static PyObject* _richcompare_WhiteBalanceGain(py::wrapper::Windows::Media::Capture::WhiteBalanceGain* self, PyObject* other, int op) noexcept
    {
        try
        {
            auto _other = py::converter<winrt::Windows::Media::Capture::WhiteBalanceGain>::convert_to(other);

            if (op == Py_EQ)
            {
                if (self->obj == _other)
                {
                    Py_RETURN_TRUE;
                }

                Py_RETURN_FALSE;
            }

            if (op == Py_NE)
            {
                if (self->obj != _other)
                {
                    Py_RETURN_TRUE;
                }

                Py_RETURN_FALSE;
            }

            Py_RETURN_NOTIMPLEMENTED;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyType_Slot _type_slots_WhiteBalanceGain[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_WhiteBalanceGain) },
        { Py_tp_init, reinterpret_cast<void*>(_init_WhiteBalanceGain) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_WhiteBalanceGain) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_WhiteBalanceGain) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_WhiteBalanceGain) },
        { Py_tp_richcompare, reinterpret_cast<void*>(_richcompare_WhiteBalanceGain) },
        { }
    };

    static PyType_Spec type_spec_WhiteBalanceGain = {
        "winrt._winrt_windows_media_capture.WhiteBalanceGain",
        sizeof(py::wrapper::Windows::Media::Capture::WhiteBalanceGain),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_WhiteBalanceGain};

    // ----- Windows.Media.Capture Initialization --------------------

    PyDoc_STRVAR(module_doc, "Windows.Media.Capture");

    static PyModuleDef module_def = {
        PyModuleDef_HEAD_INIT,
        "_winrt_windows_media_capture",
        module_doc,
        0,
        nullptr,
        nullptr,
        nullptr,
        nullptr,
        nullptr};
} // py::cpp::Windows::Media::Capture

PyMODINIT_FUNC PyInit__winrt_windows_media_capture(void) noexcept
{
    using namespace py::cpp::Windows::Media::Capture;

    if (py::import_winrt_runtime() == -1)
    {
        return nullptr;
    }

    py::pyobj_handle module{PyModule_Create(&module_def)};

    if (!module)
    {
        return nullptr;
    }

    auto object_type = py::get_object_type();
    if (!object_type)
    {
        return nullptr;
    }

    py::pyobj_handle object_bases{PyTuple_Pack(1, object_type)};

    if (!object_bases)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_AdvancedCapturedPhoto, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_AdvancedPhotoCapture, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_AppBroadcastBackgroundService, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_AppBroadcastBackgroundServiceSignInInfo, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_AppBroadcastBackgroundServiceStreamInfo, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_AppBroadcastCameraCaptureStateChangedEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_AppBroadcastGlobalSettings, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_AppBroadcastHeartbeatRequestedEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_AppBroadcastManager_Static{PyType_FromSpec(&type_spec_AppBroadcastManager_Static)};
    if (!type_AppBroadcastManager_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_AppBroadcastManager, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_AppBroadcastManager_Static.get())) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_AppBroadcastMicrophoneCaptureStateChangedEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_AppBroadcastPlugIn, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_AppBroadcastPlugInManager_Static{PyType_FromSpec(&type_spec_AppBroadcastPlugInManager_Static)};
    if (!type_AppBroadcastPlugInManager_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_AppBroadcastPlugInManager, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_AppBroadcastPlugInManager_Static.get())) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_AppBroadcastPlugInStateChangedEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_AppBroadcastPreview, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_AppBroadcastPreviewStateChangedEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_AppBroadcastPreviewStreamReader, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_AppBroadcastPreviewStreamVideoFrame, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_AppBroadcastPreviewStreamVideoHeader, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_AppBroadcastProviderSettings, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_AppBroadcastServices, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_AppBroadcastSignInStateChangedEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_AppBroadcastState, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_AppBroadcastStreamAudioFrame, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_AppBroadcastStreamAudioHeader, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_AppBroadcastStreamReader, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_AppBroadcastStreamStateChangedEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_AppBroadcastStreamVideoFrame, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_AppBroadcastStreamVideoHeader, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_AppBroadcastTriggerDetails, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_AppBroadcastViewerCountChangedEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_AppCapture_Static{PyType_FromSpec(&type_spec_AppCapture_Static)};
    if (!type_AppCapture_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_AppCapture, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_AppCapture_Static.get())) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_AppCaptureAlternateShortcutKeys, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_AppCaptureDurationGeneratedEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_AppCaptureFileGeneratedEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_AppCaptureManager_Static{PyType_FromSpec(&type_spec_AppCaptureManager_Static)};
    if (!type_AppCaptureManager_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_AppCaptureManager, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_AppCaptureManager_Static.get())) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_AppCaptureMetadataWriter, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_AppCaptureMicrophoneCaptureStateChangedEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_AppCaptureRecordOperation, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_AppCaptureRecordingStateChangedEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_AppCaptureServices, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_AppCaptureSettings, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_AppCaptureState, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_CameraCaptureUI, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_CameraCaptureUIPhotoCaptureSettings, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_CameraCaptureUIVideoCaptureSettings, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_CameraOptionsUI_Static{PyType_FromSpec(&type_spec_CameraOptionsUI_Static)};
    if (!type_CameraOptionsUI_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_CameraOptionsUI, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_CameraOptionsUI_Static.get())) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_CapturedFrame, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_CapturedFrameControlValues, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_CapturedPhoto, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_GameBarServices, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_GameBarServicesCommandEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_GameBarServicesManager_Static{PyType_FromSpec(&type_spec_GameBarServicesManager_Static)};
    if (!type_GameBarServicesManager_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_GameBarServicesManager, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_GameBarServicesManager_Static.get())) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_GameBarServicesManagerGameBarServicesCreatedEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_GameBarServicesTargetInfo, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_LowLagMediaRecording, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_LowLagPhotoCapture, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_LowLagPhotoSequenceCapture, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_MediaCapture_Static{PyType_FromSpec(&type_spec_MediaCapture_Static)};
    if (!type_MediaCapture_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_MediaCapture, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_MediaCapture_Static.get())) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_MediaCaptureDeviceExclusiveControlStatusChangedEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_MediaCaptureFailedEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_MediaCaptureFocusChangedEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_MediaCaptureInitializationSettings, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_MediaCapturePauseResult, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_MediaCaptureRelativePanelWatcher, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_MediaCaptureSettings, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_MediaCaptureStopResult, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_MediaCaptureVideoProfile, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_MediaCaptureVideoProfileMediaDescription, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_OptionalReferencePhotoCapturedEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_PhotoCapturedEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_PhotoConfirmationCapturedEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_ScreenCapture_Static{PyType_FromSpec(&type_spec_ScreenCapture_Static)};
    if (!type_ScreenCapture_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ScreenCapture, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_ScreenCapture_Static.get())) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_SourceSuspensionChangedEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_VideoStreamConfiguration, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_WhiteBalanceGain, nullptr, nullptr) == -1)
    {
        return nullptr;
    }


    return module.detach();
}
