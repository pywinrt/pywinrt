// WARNING: Please don't edit this file. It was generated by Python/WinRT v2.0.0-beta.2

#include "py.Windows.Management.Update.h"


namespace py::cpp::Windows::Management::Update
{
    // ----- PreviewBuildsManager class --------------------

    static PyObject* _new_PreviewBuildsManager(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Management::Update::PreviewBuildsManager>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Management::Update::PreviewBuildsManager>::type_name);
        return nullptr;
    }

    static void _dealloc_PreviewBuildsManager(py::wrapper::Windows::Management::Update::PreviewBuildsManager* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PreviewBuildsManager_GetCurrentState(py::wrapper::Windows::Management::Update::PreviewBuildsManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Management.Update.PreviewBuildsManager", L"GetCurrentState", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetCurrentState());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PreviewBuildsManager_GetDefault(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Management.Update.PreviewBuildsManager", L"GetDefault", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(winrt::Windows::Management::Update::PreviewBuildsManager::GetDefault());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PreviewBuildsManager_IsSupported(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Management.Update.PreviewBuildsManager", L"IsSupported", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(winrt::Windows::Management::Update::PreviewBuildsManager::IsSupported());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PreviewBuildsManager_SyncAsync(py::wrapper::Windows::Management::Update::PreviewBuildsManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Management.Update.PreviewBuildsManager", L"SyncAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.SyncAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PreviewBuildsManager_get_ArePreviewBuildsAllowed(py::wrapper::Windows::Management::Update::PreviewBuildsManager* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Update.PreviewBuildsManager", L"ArePreviewBuildsAllowed"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ArePreviewBuildsAllowed());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PreviewBuildsManager_put_ArePreviewBuildsAllowed(py::wrapper::Windows::Management::Update::PreviewBuildsManager* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Update.PreviewBuildsManager", L"ArePreviewBuildsAllowed"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.ArePreviewBuildsAllowed(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_PreviewBuildsManager(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Management::Update::PreviewBuildsManager>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PreviewBuildsManager(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Management::Update::PreviewBuildsManager>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PreviewBuildsManager[] = {
        { "get_current_state", reinterpret_cast<PyCFunction>(PreviewBuildsManager_GetCurrentState), METH_VARARGS, nullptr },
        { "sync_async", reinterpret_cast<PyCFunction>(PreviewBuildsManager_SyncAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_PreviewBuildsManager, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PreviewBuildsManager), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PreviewBuildsManager[] = {
        { "are_preview_builds_allowed", reinterpret_cast<getter>(PreviewBuildsManager_get_ArePreviewBuildsAllowed), reinterpret_cast<setter>(PreviewBuildsManager_put_ArePreviewBuildsAllowed), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PreviewBuildsManager[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PreviewBuildsManager) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PreviewBuildsManager) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PreviewBuildsManager) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PreviewBuildsManager) },
        { },
    };

    static PyType_Spec type_spec_PreviewBuildsManager =
    {
        "winrt._winrt_windows_management_update.PreviewBuildsManager",
        sizeof(py::wrapper::Windows::Management::Update::PreviewBuildsManager),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PreviewBuildsManager
    };

    static PyGetSetDef getset_PreviewBuildsManager_Static[] = {
        { }
    };

    static PyMethodDef methods_PreviewBuildsManager_Static[] = {
        { "get_default", reinterpret_cast<PyCFunction>(PreviewBuildsManager_GetDefault), METH_VARARGS, nullptr },
        { "is_supported", reinterpret_cast<PyCFunction>(PreviewBuildsManager_IsSupported), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_PreviewBuildsManager_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_PreviewBuildsManager_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_PreviewBuildsManager_Static) },
        { }
    };

    static PyType_Spec type_spec_PreviewBuildsManager_Static =
    {
        "winrt._winrt_windows_management_update.PreviewBuildsManager_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_PreviewBuildsManager_Static
    };

    // ----- PreviewBuildsState class --------------------

    static PyObject* _new_PreviewBuildsState(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Management::Update::PreviewBuildsState>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Management::Update::PreviewBuildsState>::type_name);
        return nullptr;
    }

    static void _dealloc_PreviewBuildsState(py::wrapper::Windows::Management::Update::PreviewBuildsState* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PreviewBuildsState_get_Properties(py::wrapper::Windows::Management::Update::PreviewBuildsState* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Update.PreviewBuildsState", L"Properties"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Properties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PreviewBuildsState(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Management::Update::PreviewBuildsState>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PreviewBuildsState(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Management::Update::PreviewBuildsState>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PreviewBuildsState[] = {
        { "_assign_array_", _assign_array_PreviewBuildsState, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PreviewBuildsState), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PreviewBuildsState[] = {
        { "properties", reinterpret_cast<getter>(PreviewBuildsState_get_Properties), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PreviewBuildsState[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PreviewBuildsState) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PreviewBuildsState) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PreviewBuildsState) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PreviewBuildsState) },
        { },
    };

    static PyType_Spec type_spec_PreviewBuildsState =
    {
        "winrt._winrt_windows_management_update.PreviewBuildsState",
        sizeof(py::wrapper::Windows::Management::Update::PreviewBuildsState),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PreviewBuildsState
    };

    // ----- WindowsUpdate class --------------------

    static PyObject* _new_WindowsUpdate(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Management::Update::WindowsUpdate>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Management::Update::WindowsUpdate>::type_name);
        return nullptr;
    }

    static void _dealloc_WindowsUpdate(py::wrapper::Windows::Management::Update::WindowsUpdate* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* WindowsUpdate_AcceptEula(py::wrapper::Windows::Management::Update::WindowsUpdate* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Management.Update.WindowsUpdate", L"AcceptEula", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.AcceptEula();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* WindowsUpdate_GetPropertyValue(py::wrapper::Windows::Management::Update::WindowsUpdate* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Management.Update.WindowsUpdate", L"GetPropertyValue", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.GetPropertyValue(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* WindowsUpdate_get_ActionProgress(py::wrapper::Windows::Management::Update::WindowsUpdate* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Update.WindowsUpdate", L"ActionProgress"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ActionProgress());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WindowsUpdate_get_ActionResult(py::wrapper::Windows::Management::Update::WindowsUpdate* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Update.WindowsUpdate", L"ActionResult"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ActionResult());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WindowsUpdate_get_AttentionRequiredInfo(py::wrapper::Windows::Management::Update::WindowsUpdate* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Update.WindowsUpdate", L"AttentionRequiredInfo"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AttentionRequiredInfo());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WindowsUpdate_get_CurrentAction(py::wrapper::Windows::Management::Update::WindowsUpdate* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Update.WindowsUpdate", L"CurrentAction"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CurrentAction());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WindowsUpdate_get_Deadline(py::wrapper::Windows::Management::Update::WindowsUpdate* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Update.WindowsUpdate", L"Deadline"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Deadline());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WindowsUpdate_get_Description(py::wrapper::Windows::Management::Update::WindowsUpdate* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Update.WindowsUpdate", L"Description"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Description());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WindowsUpdate_get_EulaText(py::wrapper::Windows::Management::Update::WindowsUpdate* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Update.WindowsUpdate", L"EulaText"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.EulaText());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WindowsUpdate_get_IsCritical(py::wrapper::Windows::Management::Update::WindowsUpdate* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Update.WindowsUpdate", L"IsCritical"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsCritical());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WindowsUpdate_get_IsDriver(py::wrapper::Windows::Management::Update::WindowsUpdate* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Update.WindowsUpdate", L"IsDriver"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsDriver());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WindowsUpdate_get_IsEulaAccepted(py::wrapper::Windows::Management::Update::WindowsUpdate* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Update.WindowsUpdate", L"IsEulaAccepted"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsEulaAccepted());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WindowsUpdate_get_IsFeatureUpdate(py::wrapper::Windows::Management::Update::WindowsUpdate* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Update.WindowsUpdate", L"IsFeatureUpdate"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsFeatureUpdate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WindowsUpdate_get_IsForOS(py::wrapper::Windows::Management::Update::WindowsUpdate* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Update.WindowsUpdate", L"IsForOS"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsForOS());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WindowsUpdate_get_IsMandatory(py::wrapper::Windows::Management::Update::WindowsUpdate* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Update.WindowsUpdate", L"IsMandatory"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsMandatory());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WindowsUpdate_get_IsMinorImpact(py::wrapper::Windows::Management::Update::WindowsUpdate* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Update.WindowsUpdate", L"IsMinorImpact"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsMinorImpact());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WindowsUpdate_get_IsSecurity(py::wrapper::Windows::Management::Update::WindowsUpdate* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Update.WindowsUpdate", L"IsSecurity"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsSecurity());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WindowsUpdate_get_IsSeeker(py::wrapper::Windows::Management::Update::WindowsUpdate* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Update.WindowsUpdate", L"IsSeeker"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsSeeker());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WindowsUpdate_get_IsUrgent(py::wrapper::Windows::Management::Update::WindowsUpdate* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Update.WindowsUpdate", L"IsUrgent"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsUrgent());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WindowsUpdate_get_MoreInfoUrl(py::wrapper::Windows::Management::Update::WindowsUpdate* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Update.WindowsUpdate", L"MoreInfoUrl"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MoreInfoUrl());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WindowsUpdate_get_ProviderId(py::wrapper::Windows::Management::Update::WindowsUpdate* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Update.WindowsUpdate", L"ProviderId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ProviderId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WindowsUpdate_get_SupportUrl(py::wrapper::Windows::Management::Update::WindowsUpdate* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Update.WindowsUpdate", L"SupportUrl"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SupportUrl());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WindowsUpdate_get_Title(py::wrapper::Windows::Management::Update::WindowsUpdate* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Update.WindowsUpdate", L"Title"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Title());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WindowsUpdate_get_UpdateId(py::wrapper::Windows::Management::Update::WindowsUpdate* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Update.WindowsUpdate", L"UpdateId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.UpdateId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_WindowsUpdate(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Management::Update::WindowsUpdate>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_WindowsUpdate(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Management::Update::WindowsUpdate>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_WindowsUpdate[] = {
        { "accept_eula", reinterpret_cast<PyCFunction>(WindowsUpdate_AcceptEula), METH_VARARGS, nullptr },
        { "get_property_value", reinterpret_cast<PyCFunction>(WindowsUpdate_GetPropertyValue), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_WindowsUpdate, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_WindowsUpdate), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_WindowsUpdate[] = {
        { "action_progress", reinterpret_cast<getter>(WindowsUpdate_get_ActionProgress), nullptr, nullptr, nullptr },
        { "action_result", reinterpret_cast<getter>(WindowsUpdate_get_ActionResult), nullptr, nullptr, nullptr },
        { "attention_required_info", reinterpret_cast<getter>(WindowsUpdate_get_AttentionRequiredInfo), nullptr, nullptr, nullptr },
        { "current_action", reinterpret_cast<getter>(WindowsUpdate_get_CurrentAction), nullptr, nullptr, nullptr },
        { "deadline", reinterpret_cast<getter>(WindowsUpdate_get_Deadline), nullptr, nullptr, nullptr },
        { "description", reinterpret_cast<getter>(WindowsUpdate_get_Description), nullptr, nullptr, nullptr },
        { "eula_text", reinterpret_cast<getter>(WindowsUpdate_get_EulaText), nullptr, nullptr, nullptr },
        { "is_critical", reinterpret_cast<getter>(WindowsUpdate_get_IsCritical), nullptr, nullptr, nullptr },
        { "is_driver", reinterpret_cast<getter>(WindowsUpdate_get_IsDriver), nullptr, nullptr, nullptr },
        { "is_eula_accepted", reinterpret_cast<getter>(WindowsUpdate_get_IsEulaAccepted), nullptr, nullptr, nullptr },
        { "is_feature_update", reinterpret_cast<getter>(WindowsUpdate_get_IsFeatureUpdate), nullptr, nullptr, nullptr },
        { "is_for_o_s", reinterpret_cast<getter>(WindowsUpdate_get_IsForOS), nullptr, nullptr, nullptr },
        { "is_mandatory", reinterpret_cast<getter>(WindowsUpdate_get_IsMandatory), nullptr, nullptr, nullptr },
        { "is_minor_impact", reinterpret_cast<getter>(WindowsUpdate_get_IsMinorImpact), nullptr, nullptr, nullptr },
        { "is_security", reinterpret_cast<getter>(WindowsUpdate_get_IsSecurity), nullptr, nullptr, nullptr },
        { "is_seeker", reinterpret_cast<getter>(WindowsUpdate_get_IsSeeker), nullptr, nullptr, nullptr },
        { "is_urgent", reinterpret_cast<getter>(WindowsUpdate_get_IsUrgent), nullptr, nullptr, nullptr },
        { "more_info_url", reinterpret_cast<getter>(WindowsUpdate_get_MoreInfoUrl), nullptr, nullptr, nullptr },
        { "provider_id", reinterpret_cast<getter>(WindowsUpdate_get_ProviderId), nullptr, nullptr, nullptr },
        { "support_url", reinterpret_cast<getter>(WindowsUpdate_get_SupportUrl), nullptr, nullptr, nullptr },
        { "title", reinterpret_cast<getter>(WindowsUpdate_get_Title), nullptr, nullptr, nullptr },
        { "update_id", reinterpret_cast<getter>(WindowsUpdate_get_UpdateId), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_WindowsUpdate[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_WindowsUpdate) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_WindowsUpdate) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_WindowsUpdate) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_WindowsUpdate) },
        { },
    };

    static PyType_Spec type_spec_WindowsUpdate =
    {
        "winrt._winrt_windows_management_update.WindowsUpdate",
        sizeof(py::wrapper::Windows::Management::Update::WindowsUpdate),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_WindowsUpdate
    };

    // ----- WindowsUpdateActionCompletedEventArgs class --------------------

    static PyObject* _new_WindowsUpdateActionCompletedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Management::Update::WindowsUpdateActionCompletedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Management::Update::WindowsUpdateActionCompletedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_WindowsUpdateActionCompletedEventArgs(py::wrapper::Windows::Management::Update::WindowsUpdateActionCompletedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* WindowsUpdateActionCompletedEventArgs_get_Action(py::wrapper::Windows::Management::Update::WindowsUpdateActionCompletedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Update.WindowsUpdateActionCompletedEventArgs", L"Action"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Action());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WindowsUpdateActionCompletedEventArgs_get_ExtendedError(py::wrapper::Windows::Management::Update::WindowsUpdateActionCompletedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Update.WindowsUpdateActionCompletedEventArgs", L"ExtendedError"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ExtendedError());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WindowsUpdateActionCompletedEventArgs_get_Succeeded(py::wrapper::Windows::Management::Update::WindowsUpdateActionCompletedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Update.WindowsUpdateActionCompletedEventArgs", L"Succeeded"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Succeeded());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WindowsUpdateActionCompletedEventArgs_get_Update(py::wrapper::Windows::Management::Update::WindowsUpdateActionCompletedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Update.WindowsUpdateActionCompletedEventArgs", L"Update"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Update());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_WindowsUpdateActionCompletedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Management::Update::WindowsUpdateActionCompletedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_WindowsUpdateActionCompletedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Management::Update::WindowsUpdateActionCompletedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_WindowsUpdateActionCompletedEventArgs[] = {
        { "_assign_array_", _assign_array_WindowsUpdateActionCompletedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_WindowsUpdateActionCompletedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_WindowsUpdateActionCompletedEventArgs[] = {
        { "action", reinterpret_cast<getter>(WindowsUpdateActionCompletedEventArgs_get_Action), nullptr, nullptr, nullptr },
        { "extended_error", reinterpret_cast<getter>(WindowsUpdateActionCompletedEventArgs_get_ExtendedError), nullptr, nullptr, nullptr },
        { "succeeded", reinterpret_cast<getter>(WindowsUpdateActionCompletedEventArgs_get_Succeeded), nullptr, nullptr, nullptr },
        { "update", reinterpret_cast<getter>(WindowsUpdateActionCompletedEventArgs_get_Update), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_WindowsUpdateActionCompletedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_WindowsUpdateActionCompletedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_WindowsUpdateActionCompletedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_WindowsUpdateActionCompletedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_WindowsUpdateActionCompletedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_WindowsUpdateActionCompletedEventArgs =
    {
        "winrt._winrt_windows_management_update.WindowsUpdateActionCompletedEventArgs",
        sizeof(py::wrapper::Windows::Management::Update::WindowsUpdateActionCompletedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_WindowsUpdateActionCompletedEventArgs
    };

    // ----- WindowsUpdateActionProgress class --------------------

    static PyObject* _new_WindowsUpdateActionProgress(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Management::Update::WindowsUpdateActionProgress>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Management::Update::WindowsUpdateActionProgress>::type_name);
        return nullptr;
    }

    static void _dealloc_WindowsUpdateActionProgress(py::wrapper::Windows::Management::Update::WindowsUpdateActionProgress* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* WindowsUpdateActionProgress_get_Action(py::wrapper::Windows::Management::Update::WindowsUpdateActionProgress* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Update.WindowsUpdateActionProgress", L"Action"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Action());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WindowsUpdateActionProgress_get_Progress(py::wrapper::Windows::Management::Update::WindowsUpdateActionProgress* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Update.WindowsUpdateActionProgress", L"Progress"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Progress());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_WindowsUpdateActionProgress(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Management::Update::WindowsUpdateActionProgress>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_WindowsUpdateActionProgress(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Management::Update::WindowsUpdateActionProgress>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_WindowsUpdateActionProgress[] = {
        { "_assign_array_", _assign_array_WindowsUpdateActionProgress, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_WindowsUpdateActionProgress), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_WindowsUpdateActionProgress[] = {
        { "action", reinterpret_cast<getter>(WindowsUpdateActionProgress_get_Action), nullptr, nullptr, nullptr },
        { "progress", reinterpret_cast<getter>(WindowsUpdateActionProgress_get_Progress), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_WindowsUpdateActionProgress[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_WindowsUpdateActionProgress) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_WindowsUpdateActionProgress) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_WindowsUpdateActionProgress) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_WindowsUpdateActionProgress) },
        { },
    };

    static PyType_Spec type_spec_WindowsUpdateActionProgress =
    {
        "winrt._winrt_windows_management_update.WindowsUpdateActionProgress",
        sizeof(py::wrapper::Windows::Management::Update::WindowsUpdateActionProgress),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_WindowsUpdateActionProgress
    };

    // ----- WindowsUpdateActionResult class --------------------

    static PyObject* _new_WindowsUpdateActionResult(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Management::Update::WindowsUpdateActionResult>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Management::Update::WindowsUpdateActionResult>::type_name);
        return nullptr;
    }

    static void _dealloc_WindowsUpdateActionResult(py::wrapper::Windows::Management::Update::WindowsUpdateActionResult* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* WindowsUpdateActionResult_get_Action(py::wrapper::Windows::Management::Update::WindowsUpdateActionResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Update.WindowsUpdateActionResult", L"Action"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Action());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WindowsUpdateActionResult_get_ExtendedError(py::wrapper::Windows::Management::Update::WindowsUpdateActionResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Update.WindowsUpdateActionResult", L"ExtendedError"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ExtendedError());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WindowsUpdateActionResult_get_Succeeded(py::wrapper::Windows::Management::Update::WindowsUpdateActionResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Update.WindowsUpdateActionResult", L"Succeeded"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Succeeded());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WindowsUpdateActionResult_get_Timestamp(py::wrapper::Windows::Management::Update::WindowsUpdateActionResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Update.WindowsUpdateActionResult", L"Timestamp"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Timestamp());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_WindowsUpdateActionResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Management::Update::WindowsUpdateActionResult>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_WindowsUpdateActionResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Management::Update::WindowsUpdateActionResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_WindowsUpdateActionResult[] = {
        { "_assign_array_", _assign_array_WindowsUpdateActionResult, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_WindowsUpdateActionResult), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_WindowsUpdateActionResult[] = {
        { "action", reinterpret_cast<getter>(WindowsUpdateActionResult_get_Action), nullptr, nullptr, nullptr },
        { "extended_error", reinterpret_cast<getter>(WindowsUpdateActionResult_get_ExtendedError), nullptr, nullptr, nullptr },
        { "succeeded", reinterpret_cast<getter>(WindowsUpdateActionResult_get_Succeeded), nullptr, nullptr, nullptr },
        { "timestamp", reinterpret_cast<getter>(WindowsUpdateActionResult_get_Timestamp), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_WindowsUpdateActionResult[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_WindowsUpdateActionResult) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_WindowsUpdateActionResult) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_WindowsUpdateActionResult) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_WindowsUpdateActionResult) },
        { },
    };

    static PyType_Spec type_spec_WindowsUpdateActionResult =
    {
        "winrt._winrt_windows_management_update.WindowsUpdateActionResult",
        sizeof(py::wrapper::Windows::Management::Update::WindowsUpdateActionResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_WindowsUpdateActionResult
    };

    // ----- WindowsUpdateAdministrator class --------------------

    static PyObject* _new_WindowsUpdateAdministrator(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Management::Update::WindowsUpdateAdministrator>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Management::Update::WindowsUpdateAdministrator>::type_name);
        return nullptr;
    }

    static void _dealloc_WindowsUpdateAdministrator(py::wrapper::Windows::Management::Update::WindowsUpdateAdministrator* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* WindowsUpdateAdministrator_ApproveWindowsUpdate(py::wrapper::Windows::Management::Update::WindowsUpdateAdministrator* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Management.Update.WindowsUpdateAdministrator", L"ApproveWindowsUpdate", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Management::Update::WindowsUpdateApprovalData>(args, 1);

                self->obj.ApproveWindowsUpdate(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* WindowsUpdateAdministrator_ApproveWindowsUpdateAction(py::wrapper::Windows::Management::Update::WindowsUpdateAdministrator* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Management.Update.WindowsUpdateAdministrator", L"ApproveWindowsUpdateAction", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                self->obj.ApproveWindowsUpdateAction(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* WindowsUpdateAdministrator_CancelRestartRequest(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Management.Update.WindowsUpdateAdministrator", L"CancelRestartRequest", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                winrt::Windows::Management::Update::WindowsUpdateAdministrator::CancelRestartRequest(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* WindowsUpdateAdministrator_GetRegisteredAdministrator(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Management.Update.WindowsUpdateAdministrator", L"GetRegisteredAdministrator", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Management::Update::WindowsUpdateAdministrator::GetRegisteredAdministrator(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* WindowsUpdateAdministrator_GetRegisteredAdministratorName(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Management.Update.WindowsUpdateAdministrator", L"GetRegisteredAdministratorName", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(winrt::Windows::Management::Update::WindowsUpdateAdministrator::GetRegisteredAdministratorName());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* WindowsUpdateAdministrator_GetUpdates(py::wrapper::Windows::Management::Update::WindowsUpdateAdministrator* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Management.Update.WindowsUpdateAdministrator", L"GetUpdates", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetUpdates());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* WindowsUpdateAdministrator_RegisterForAdministration(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Management.Update.WindowsUpdateAdministrator", L"RegisterForAdministration", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Management::Update::WindowsUpdateAdministratorOptions>(args, 1);

                return py::convert(winrt::Windows::Management::Update::WindowsUpdateAdministrator::RegisterForAdministration(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* WindowsUpdateAdministrator_RequestRestart(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Management.Update.WindowsUpdateAdministrator", L"RequestRestart", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Management::Update::WindowsUpdateRestartRequestOptions>(args, 0);

                return py::convert(winrt::Windows::Management::Update::WindowsUpdateAdministrator::RequestRestart(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* WindowsUpdateAdministrator_RevokeWindowsUpdateActionApproval(py::wrapper::Windows::Management::Update::WindowsUpdateAdministrator* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Management.Update.WindowsUpdateAdministrator", L"RevokeWindowsUpdateActionApproval", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                self->obj.RevokeWindowsUpdateActionApproval(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* WindowsUpdateAdministrator_RevokeWindowsUpdateApproval(py::wrapper::Windows::Management::Update::WindowsUpdateAdministrator* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Management.Update.WindowsUpdateAdministrator", L"RevokeWindowsUpdateApproval", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                self->obj.RevokeWindowsUpdateApproval(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* WindowsUpdateAdministrator_StartAdministratorScan(py::wrapper::Windows::Management::Update::WindowsUpdateAdministrator* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Management.Update.WindowsUpdateAdministrator", L"StartAdministratorScan", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.StartAdministratorScan();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* WindowsUpdateAdministrator_UnregisterForAdministration(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Management.Update.WindowsUpdateAdministrator", L"UnregisterForAdministration", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Management::Update::WindowsUpdateAdministrator::UnregisterForAdministration(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_WindowsUpdateAdministrator(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Management::Update::WindowsUpdateAdministrator>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_WindowsUpdateAdministrator(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Management::Update::WindowsUpdateAdministrator>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_WindowsUpdateAdministrator[] = {
        { "approve_windows_update", reinterpret_cast<PyCFunction>(WindowsUpdateAdministrator_ApproveWindowsUpdate), METH_VARARGS, nullptr },
        { "approve_windows_update_action", reinterpret_cast<PyCFunction>(WindowsUpdateAdministrator_ApproveWindowsUpdateAction), METH_VARARGS, nullptr },
        { "get_updates", reinterpret_cast<PyCFunction>(WindowsUpdateAdministrator_GetUpdates), METH_VARARGS, nullptr },
        { "revoke_windows_update_action_approval", reinterpret_cast<PyCFunction>(WindowsUpdateAdministrator_RevokeWindowsUpdateActionApproval), METH_VARARGS, nullptr },
        { "revoke_windows_update_approval", reinterpret_cast<PyCFunction>(WindowsUpdateAdministrator_RevokeWindowsUpdateApproval), METH_VARARGS, nullptr },
        { "start_administrator_scan", reinterpret_cast<PyCFunction>(WindowsUpdateAdministrator_StartAdministratorScan), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_WindowsUpdateAdministrator, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_WindowsUpdateAdministrator), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_WindowsUpdateAdministrator[] = {
        { }
    };

    static PyType_Slot _type_slots_WindowsUpdateAdministrator[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_WindowsUpdateAdministrator) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_WindowsUpdateAdministrator) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_WindowsUpdateAdministrator) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_WindowsUpdateAdministrator) },
        { },
    };

    static PyType_Spec type_spec_WindowsUpdateAdministrator =
    {
        "winrt._winrt_windows_management_update.WindowsUpdateAdministrator",
        sizeof(py::wrapper::Windows::Management::Update::WindowsUpdateAdministrator),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_WindowsUpdateAdministrator
    };

    static PyGetSetDef getset_WindowsUpdateAdministrator_Static[] = {
        { }
    };

    static PyMethodDef methods_WindowsUpdateAdministrator_Static[] = {
        { "cancel_restart_request", reinterpret_cast<PyCFunction>(WindowsUpdateAdministrator_CancelRestartRequest), METH_VARARGS, nullptr },
        { "get_registered_administrator", reinterpret_cast<PyCFunction>(WindowsUpdateAdministrator_GetRegisteredAdministrator), METH_VARARGS, nullptr },
        { "get_registered_administrator_name", reinterpret_cast<PyCFunction>(WindowsUpdateAdministrator_GetRegisteredAdministratorName), METH_VARARGS, nullptr },
        { "register_for_administration", reinterpret_cast<PyCFunction>(WindowsUpdateAdministrator_RegisterForAdministration), METH_VARARGS, nullptr },
        { "request_restart", reinterpret_cast<PyCFunction>(WindowsUpdateAdministrator_RequestRestart), METH_VARARGS, nullptr },
        { "unregister_for_administration", reinterpret_cast<PyCFunction>(WindowsUpdateAdministrator_UnregisterForAdministration), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_WindowsUpdateAdministrator_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_WindowsUpdateAdministrator_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_WindowsUpdateAdministrator_Static) },
        { }
    };

    static PyType_Spec type_spec_WindowsUpdateAdministrator_Static =
    {
        "winrt._winrt_windows_management_update.WindowsUpdateAdministrator_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_WindowsUpdateAdministrator_Static
    };

    // ----- WindowsUpdateApprovalData class --------------------

    static PyObject* _new_WindowsUpdateApprovalData(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Management::Update::WindowsUpdateApprovalData instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_WindowsUpdateApprovalData(py::wrapper::Windows::Management::Update::WindowsUpdateApprovalData* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* WindowsUpdateApprovalData_get_Seeker(py::wrapper::Windows::Management::Update::WindowsUpdateApprovalData* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Update.WindowsUpdateApprovalData", L"Seeker"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Seeker());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int WindowsUpdateApprovalData_put_Seeker(py::wrapper::Windows::Management::Update::WindowsUpdateApprovalData* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Update.WindowsUpdateApprovalData", L"Seeker"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<bool>>(arg);

            self->obj.Seeker(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* WindowsUpdateApprovalData_get_OptOutOfAutoReboot(py::wrapper::Windows::Management::Update::WindowsUpdateApprovalData* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Update.WindowsUpdateApprovalData", L"OptOutOfAutoReboot"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.OptOutOfAutoReboot());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int WindowsUpdateApprovalData_put_OptOutOfAutoReboot(py::wrapper::Windows::Management::Update::WindowsUpdateApprovalData* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Update.WindowsUpdateApprovalData", L"OptOutOfAutoReboot"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<bool>>(arg);

            self->obj.OptOutOfAutoReboot(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* WindowsUpdateApprovalData_get_ComplianceGracePeriodInDays(py::wrapper::Windows::Management::Update::WindowsUpdateApprovalData* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Update.WindowsUpdateApprovalData", L"ComplianceGracePeriodInDays"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ComplianceGracePeriodInDays());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int WindowsUpdateApprovalData_put_ComplianceGracePeriodInDays(py::wrapper::Windows::Management::Update::WindowsUpdateApprovalData* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Update.WindowsUpdateApprovalData", L"ComplianceGracePeriodInDays"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<int32_t>>(arg);

            self->obj.ComplianceGracePeriodInDays(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* WindowsUpdateApprovalData_get_ComplianceDeadlineInDays(py::wrapper::Windows::Management::Update::WindowsUpdateApprovalData* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Update.WindowsUpdateApprovalData", L"ComplianceDeadlineInDays"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ComplianceDeadlineInDays());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int WindowsUpdateApprovalData_put_ComplianceDeadlineInDays(py::wrapper::Windows::Management::Update::WindowsUpdateApprovalData* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Update.WindowsUpdateApprovalData", L"ComplianceDeadlineInDays"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<int32_t>>(arg);

            self->obj.ComplianceDeadlineInDays(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* WindowsUpdateApprovalData_get_AllowDownloadOnMetered(py::wrapper::Windows::Management::Update::WindowsUpdateApprovalData* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Update.WindowsUpdateApprovalData", L"AllowDownloadOnMetered"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AllowDownloadOnMetered());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int WindowsUpdateApprovalData_put_AllowDownloadOnMetered(py::wrapper::Windows::Management::Update::WindowsUpdateApprovalData* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Update.WindowsUpdateApprovalData", L"AllowDownloadOnMetered"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<bool>>(arg);

            self->obj.AllowDownloadOnMetered(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_WindowsUpdateApprovalData(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Management::Update::WindowsUpdateApprovalData>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_WindowsUpdateApprovalData(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Management::Update::WindowsUpdateApprovalData>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_WindowsUpdateApprovalData[] = {
        { "_assign_array_", _assign_array_WindowsUpdateApprovalData, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_WindowsUpdateApprovalData), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_WindowsUpdateApprovalData[] = {
        { "seeker", reinterpret_cast<getter>(WindowsUpdateApprovalData_get_Seeker), reinterpret_cast<setter>(WindowsUpdateApprovalData_put_Seeker), nullptr, nullptr },
        { "opt_out_of_auto_reboot", reinterpret_cast<getter>(WindowsUpdateApprovalData_get_OptOutOfAutoReboot), reinterpret_cast<setter>(WindowsUpdateApprovalData_put_OptOutOfAutoReboot), nullptr, nullptr },
        { "compliance_grace_period_in_days", reinterpret_cast<getter>(WindowsUpdateApprovalData_get_ComplianceGracePeriodInDays), reinterpret_cast<setter>(WindowsUpdateApprovalData_put_ComplianceGracePeriodInDays), nullptr, nullptr },
        { "compliance_deadline_in_days", reinterpret_cast<getter>(WindowsUpdateApprovalData_get_ComplianceDeadlineInDays), reinterpret_cast<setter>(WindowsUpdateApprovalData_put_ComplianceDeadlineInDays), nullptr, nullptr },
        { "allow_download_on_metered", reinterpret_cast<getter>(WindowsUpdateApprovalData_get_AllowDownloadOnMetered), reinterpret_cast<setter>(WindowsUpdateApprovalData_put_AllowDownloadOnMetered), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_WindowsUpdateApprovalData[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_WindowsUpdateApprovalData) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_WindowsUpdateApprovalData) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_WindowsUpdateApprovalData) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_WindowsUpdateApprovalData) },
        { },
    };

    static PyType_Spec type_spec_WindowsUpdateApprovalData =
    {
        "winrt._winrt_windows_management_update.WindowsUpdateApprovalData",
        sizeof(py::wrapper::Windows::Management::Update::WindowsUpdateApprovalData),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_WindowsUpdateApprovalData
    };

    // ----- WindowsUpdateAttentionRequiredInfo class --------------------

    static PyObject* _new_WindowsUpdateAttentionRequiredInfo(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Management::Update::WindowsUpdateAttentionRequiredInfo>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Management::Update::WindowsUpdateAttentionRequiredInfo>::type_name);
        return nullptr;
    }

    static void _dealloc_WindowsUpdateAttentionRequiredInfo(py::wrapper::Windows::Management::Update::WindowsUpdateAttentionRequiredInfo* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* WindowsUpdateAttentionRequiredInfo_get_Reason(py::wrapper::Windows::Management::Update::WindowsUpdateAttentionRequiredInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Update.WindowsUpdateAttentionRequiredInfo", L"Reason"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Reason());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WindowsUpdateAttentionRequiredInfo_get_Timestamp(py::wrapper::Windows::Management::Update::WindowsUpdateAttentionRequiredInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Update.WindowsUpdateAttentionRequiredInfo", L"Timestamp"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Timestamp());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_WindowsUpdateAttentionRequiredInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Management::Update::WindowsUpdateAttentionRequiredInfo>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_WindowsUpdateAttentionRequiredInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Management::Update::WindowsUpdateAttentionRequiredInfo>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_WindowsUpdateAttentionRequiredInfo[] = {
        { "_assign_array_", _assign_array_WindowsUpdateAttentionRequiredInfo, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_WindowsUpdateAttentionRequiredInfo), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_WindowsUpdateAttentionRequiredInfo[] = {
        { "reason", reinterpret_cast<getter>(WindowsUpdateAttentionRequiredInfo_get_Reason), nullptr, nullptr, nullptr },
        { "timestamp", reinterpret_cast<getter>(WindowsUpdateAttentionRequiredInfo_get_Timestamp), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_WindowsUpdateAttentionRequiredInfo[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_WindowsUpdateAttentionRequiredInfo) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_WindowsUpdateAttentionRequiredInfo) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_WindowsUpdateAttentionRequiredInfo) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_WindowsUpdateAttentionRequiredInfo) },
        { },
    };

    static PyType_Spec type_spec_WindowsUpdateAttentionRequiredInfo =
    {
        "winrt._winrt_windows_management_update.WindowsUpdateAttentionRequiredInfo",
        sizeof(py::wrapper::Windows::Management::Update::WindowsUpdateAttentionRequiredInfo),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_WindowsUpdateAttentionRequiredInfo
    };

    // ----- WindowsUpdateAttentionRequiredReasonChangedEventArgs class --------------------

    static PyObject* _new_WindowsUpdateAttentionRequiredReasonChangedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Management::Update::WindowsUpdateAttentionRequiredReasonChangedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Management::Update::WindowsUpdateAttentionRequiredReasonChangedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_WindowsUpdateAttentionRequiredReasonChangedEventArgs(py::wrapper::Windows::Management::Update::WindowsUpdateAttentionRequiredReasonChangedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* WindowsUpdateAttentionRequiredReasonChangedEventArgs_get_Reason(py::wrapper::Windows::Management::Update::WindowsUpdateAttentionRequiredReasonChangedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Update.WindowsUpdateAttentionRequiredReasonChangedEventArgs", L"Reason"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Reason());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WindowsUpdateAttentionRequiredReasonChangedEventArgs_get_Update(py::wrapper::Windows::Management::Update::WindowsUpdateAttentionRequiredReasonChangedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Update.WindowsUpdateAttentionRequiredReasonChangedEventArgs", L"Update"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Update());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_WindowsUpdateAttentionRequiredReasonChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Management::Update::WindowsUpdateAttentionRequiredReasonChangedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_WindowsUpdateAttentionRequiredReasonChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Management::Update::WindowsUpdateAttentionRequiredReasonChangedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_WindowsUpdateAttentionRequiredReasonChangedEventArgs[] = {
        { "_assign_array_", _assign_array_WindowsUpdateAttentionRequiredReasonChangedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_WindowsUpdateAttentionRequiredReasonChangedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_WindowsUpdateAttentionRequiredReasonChangedEventArgs[] = {
        { "reason", reinterpret_cast<getter>(WindowsUpdateAttentionRequiredReasonChangedEventArgs_get_Reason), nullptr, nullptr, nullptr },
        { "update", reinterpret_cast<getter>(WindowsUpdateAttentionRequiredReasonChangedEventArgs_get_Update), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_WindowsUpdateAttentionRequiredReasonChangedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_WindowsUpdateAttentionRequiredReasonChangedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_WindowsUpdateAttentionRequiredReasonChangedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_WindowsUpdateAttentionRequiredReasonChangedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_WindowsUpdateAttentionRequiredReasonChangedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_WindowsUpdateAttentionRequiredReasonChangedEventArgs =
    {
        "winrt._winrt_windows_management_update.WindowsUpdateAttentionRequiredReasonChangedEventArgs",
        sizeof(py::wrapper::Windows::Management::Update::WindowsUpdateAttentionRequiredReasonChangedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_WindowsUpdateAttentionRequiredReasonChangedEventArgs
    };

    // ----- WindowsUpdateGetAdministratorResult class --------------------

    static PyObject* _new_WindowsUpdateGetAdministratorResult(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Management::Update::WindowsUpdateGetAdministratorResult>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Management::Update::WindowsUpdateGetAdministratorResult>::type_name);
        return nullptr;
    }

    static void _dealloc_WindowsUpdateGetAdministratorResult(py::wrapper::Windows::Management::Update::WindowsUpdateGetAdministratorResult* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* WindowsUpdateGetAdministratorResult_get_Administrator(py::wrapper::Windows::Management::Update::WindowsUpdateGetAdministratorResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Update.WindowsUpdateGetAdministratorResult", L"Administrator"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Administrator());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WindowsUpdateGetAdministratorResult_get_Status(py::wrapper::Windows::Management::Update::WindowsUpdateGetAdministratorResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Update.WindowsUpdateGetAdministratorResult", L"Status"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_WindowsUpdateGetAdministratorResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Management::Update::WindowsUpdateGetAdministratorResult>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_WindowsUpdateGetAdministratorResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Management::Update::WindowsUpdateGetAdministratorResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_WindowsUpdateGetAdministratorResult[] = {
        { "_assign_array_", _assign_array_WindowsUpdateGetAdministratorResult, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_WindowsUpdateGetAdministratorResult), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_WindowsUpdateGetAdministratorResult[] = {
        { "administrator", reinterpret_cast<getter>(WindowsUpdateGetAdministratorResult_get_Administrator), nullptr, nullptr, nullptr },
        { "status", reinterpret_cast<getter>(WindowsUpdateGetAdministratorResult_get_Status), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_WindowsUpdateGetAdministratorResult[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_WindowsUpdateGetAdministratorResult) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_WindowsUpdateGetAdministratorResult) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_WindowsUpdateGetAdministratorResult) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_WindowsUpdateGetAdministratorResult) },
        { },
    };

    static PyType_Spec type_spec_WindowsUpdateGetAdministratorResult =
    {
        "winrt._winrt_windows_management_update.WindowsUpdateGetAdministratorResult",
        sizeof(py::wrapper::Windows::Management::Update::WindowsUpdateGetAdministratorResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_WindowsUpdateGetAdministratorResult
    };

    // ----- WindowsUpdateItem class --------------------

    static PyObject* _new_WindowsUpdateItem(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Management::Update::WindowsUpdateItem>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Management::Update::WindowsUpdateItem>::type_name);
        return nullptr;
    }

    static void _dealloc_WindowsUpdateItem(py::wrapper::Windows::Management::Update::WindowsUpdateItem* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* WindowsUpdateItem_get_Category(py::wrapper::Windows::Management::Update::WindowsUpdateItem* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Update.WindowsUpdateItem", L"Category"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Category());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WindowsUpdateItem_get_Description(py::wrapper::Windows::Management::Update::WindowsUpdateItem* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Update.WindowsUpdateItem", L"Description"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Description());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WindowsUpdateItem_get_MoreInfoUrl(py::wrapper::Windows::Management::Update::WindowsUpdateItem* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Update.WindowsUpdateItem", L"MoreInfoUrl"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MoreInfoUrl());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WindowsUpdateItem_get_Operation(py::wrapper::Windows::Management::Update::WindowsUpdateItem* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Update.WindowsUpdateItem", L"Operation"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Operation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WindowsUpdateItem_get_ProviderId(py::wrapper::Windows::Management::Update::WindowsUpdateItem* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Update.WindowsUpdateItem", L"ProviderId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ProviderId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WindowsUpdateItem_get_Timestamp(py::wrapper::Windows::Management::Update::WindowsUpdateItem* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Update.WindowsUpdateItem", L"Timestamp"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Timestamp());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WindowsUpdateItem_get_Title(py::wrapper::Windows::Management::Update::WindowsUpdateItem* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Update.WindowsUpdateItem", L"Title"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Title());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WindowsUpdateItem_get_UpdateId(py::wrapper::Windows::Management::Update::WindowsUpdateItem* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Update.WindowsUpdateItem", L"UpdateId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.UpdateId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_WindowsUpdateItem(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Management::Update::WindowsUpdateItem>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_WindowsUpdateItem(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Management::Update::WindowsUpdateItem>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_WindowsUpdateItem[] = {
        { "_assign_array_", _assign_array_WindowsUpdateItem, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_WindowsUpdateItem), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_WindowsUpdateItem[] = {
        { "category", reinterpret_cast<getter>(WindowsUpdateItem_get_Category), nullptr, nullptr, nullptr },
        { "description", reinterpret_cast<getter>(WindowsUpdateItem_get_Description), nullptr, nullptr, nullptr },
        { "more_info_url", reinterpret_cast<getter>(WindowsUpdateItem_get_MoreInfoUrl), nullptr, nullptr, nullptr },
        { "operation", reinterpret_cast<getter>(WindowsUpdateItem_get_Operation), nullptr, nullptr, nullptr },
        { "provider_id", reinterpret_cast<getter>(WindowsUpdateItem_get_ProviderId), nullptr, nullptr, nullptr },
        { "timestamp", reinterpret_cast<getter>(WindowsUpdateItem_get_Timestamp), nullptr, nullptr, nullptr },
        { "title", reinterpret_cast<getter>(WindowsUpdateItem_get_Title), nullptr, nullptr, nullptr },
        { "update_id", reinterpret_cast<getter>(WindowsUpdateItem_get_UpdateId), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_WindowsUpdateItem[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_WindowsUpdateItem) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_WindowsUpdateItem) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_WindowsUpdateItem) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_WindowsUpdateItem) },
        { },
    };

    static PyType_Spec type_spec_WindowsUpdateItem =
    {
        "winrt._winrt_windows_management_update.WindowsUpdateItem",
        sizeof(py::wrapper::Windows::Management::Update::WindowsUpdateItem),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_WindowsUpdateItem
    };

    // ----- WindowsUpdateManager class --------------------

    static PyObject* _new_WindowsUpdateManager(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                winrt::Windows::Management::Update::WindowsUpdateManager instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_WindowsUpdateManager(py::wrapper::Windows::Management::Update::WindowsUpdateManager* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* WindowsUpdateManager_GetApplicableUpdates(py::wrapper::Windows::Management::Update::WindowsUpdateManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Management.Update.WindowsUpdateManager", L"GetApplicableUpdates", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetApplicableUpdates());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* WindowsUpdateManager_GetMostRecentCompletedUpdates(py::wrapper::Windows::Management::Update::WindowsUpdateManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Management.Update.WindowsUpdateManager", L"GetMostRecentCompletedUpdates", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<int32_t>(args, 0);

                return py::convert(self->obj.GetMostRecentCompletedUpdates(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* WindowsUpdateManager_GetMostRecentCompletedUpdatesAsync(py::wrapper::Windows::Management::Update::WindowsUpdateManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Management.Update.WindowsUpdateManager", L"GetMostRecentCompletedUpdatesAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<int32_t>(args, 0);

                return py::convert(self->obj.GetMostRecentCompletedUpdatesAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* WindowsUpdateManager_StartScan(py::wrapper::Windows::Management::Update::WindowsUpdateManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Management.Update.WindowsUpdateManager", L"StartScan", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<bool>(args, 0);

                self->obj.StartScan(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* WindowsUpdateManager_get_IsScanning(py::wrapper::Windows::Management::Update::WindowsUpdateManager* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Update.WindowsUpdateManager", L"IsScanning"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsScanning());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WindowsUpdateManager_get_IsWorking(py::wrapper::Windows::Management::Update::WindowsUpdateManager* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Update.WindowsUpdateManager", L"IsWorking"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsWorking());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WindowsUpdateManager_get_LastSuccessfulScanTimestamp(py::wrapper::Windows::Management::Update::WindowsUpdateManager* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Update.WindowsUpdateManager", L"LastSuccessfulScanTimestamp"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.LastSuccessfulScanTimestamp());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WindowsUpdateManager_add_ActionCompleted(py::wrapper::Windows::Management::Update::WindowsUpdateManager* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Management.Update.WindowsUpdateManager", L"ActionCompleted"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Management::Update::WindowsUpdateManager, winrt::Windows::Management::Update::WindowsUpdateActionCompletedEventArgs>>(arg);

            return py::convert(self->obj.ActionCompleted(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WindowsUpdateManager_remove_ActionCompleted(py::wrapper::Windows::Management::Update::WindowsUpdateManager* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Management.Update.WindowsUpdateManager", L"ActionCompleted"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ActionCompleted(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WindowsUpdateManager_add_AttentionRequiredReasonChanged(py::wrapper::Windows::Management::Update::WindowsUpdateManager* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Management.Update.WindowsUpdateManager", L"AttentionRequiredReasonChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Management::Update::WindowsUpdateManager, winrt::Windows::Management::Update::WindowsUpdateAttentionRequiredReasonChangedEventArgs>>(arg);

            return py::convert(self->obj.AttentionRequiredReasonChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WindowsUpdateManager_remove_AttentionRequiredReasonChanged(py::wrapper::Windows::Management::Update::WindowsUpdateManager* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Management.Update.WindowsUpdateManager", L"AttentionRequiredReasonChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.AttentionRequiredReasonChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WindowsUpdateManager_add_ProgressChanged(py::wrapper::Windows::Management::Update::WindowsUpdateManager* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Management.Update.WindowsUpdateManager", L"ProgressChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Management::Update::WindowsUpdateManager, winrt::Windows::Management::Update::WindowsUpdateProgressChangedEventArgs>>(arg);

            return py::convert(self->obj.ProgressChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WindowsUpdateManager_remove_ProgressChanged(py::wrapper::Windows::Management::Update::WindowsUpdateManager* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Management.Update.WindowsUpdateManager", L"ProgressChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ProgressChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WindowsUpdateManager_add_ScanCompleted(py::wrapper::Windows::Management::Update::WindowsUpdateManager* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Management.Update.WindowsUpdateManager", L"ScanCompleted"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Management::Update::WindowsUpdateManager, winrt::Windows::Management::Update::WindowsUpdateScanCompletedEventArgs>>(arg);

            return py::convert(self->obj.ScanCompleted(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WindowsUpdateManager_remove_ScanCompleted(py::wrapper::Windows::Management::Update::WindowsUpdateManager* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Management.Update.WindowsUpdateManager", L"ScanCompleted"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ScanCompleted(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WindowsUpdateManager_add_ScanningStateChanged(py::wrapper::Windows::Management::Update::WindowsUpdateManager* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Management.Update.WindowsUpdateManager", L"ScanningStateChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Management::Update::WindowsUpdateManager, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.ScanningStateChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WindowsUpdateManager_remove_ScanningStateChanged(py::wrapper::Windows::Management::Update::WindowsUpdateManager* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Management.Update.WindowsUpdateManager", L"ScanningStateChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ScanningStateChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WindowsUpdateManager_add_WorkingStateChanged(py::wrapper::Windows::Management::Update::WindowsUpdateManager* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Management.Update.WindowsUpdateManager", L"WorkingStateChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Management::Update::WindowsUpdateManager, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.WorkingStateChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WindowsUpdateManager_remove_WorkingStateChanged(py::wrapper::Windows::Management::Update::WindowsUpdateManager* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Management.Update.WindowsUpdateManager", L"WorkingStateChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.WorkingStateChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_WindowsUpdateManager(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Management::Update::WindowsUpdateManager>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_WindowsUpdateManager(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Management::Update::WindowsUpdateManager>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_WindowsUpdateManager[] = {
        { "get_applicable_updates", reinterpret_cast<PyCFunction>(WindowsUpdateManager_GetApplicableUpdates), METH_VARARGS, nullptr },
        { "get_most_recent_completed_updates", reinterpret_cast<PyCFunction>(WindowsUpdateManager_GetMostRecentCompletedUpdates), METH_VARARGS, nullptr },
        { "get_most_recent_completed_updates_async", reinterpret_cast<PyCFunction>(WindowsUpdateManager_GetMostRecentCompletedUpdatesAsync), METH_VARARGS, nullptr },
        { "start_scan", reinterpret_cast<PyCFunction>(WindowsUpdateManager_StartScan), METH_VARARGS, nullptr },
        { "add_action_completed", reinterpret_cast<PyCFunction>(WindowsUpdateManager_add_ActionCompleted), METH_O, nullptr },
        { "remove_action_completed", reinterpret_cast<PyCFunction>(WindowsUpdateManager_remove_ActionCompleted), METH_O, nullptr },
        { "add_attention_required_reason_changed", reinterpret_cast<PyCFunction>(WindowsUpdateManager_add_AttentionRequiredReasonChanged), METH_O, nullptr },
        { "remove_attention_required_reason_changed", reinterpret_cast<PyCFunction>(WindowsUpdateManager_remove_AttentionRequiredReasonChanged), METH_O, nullptr },
        { "add_progress_changed", reinterpret_cast<PyCFunction>(WindowsUpdateManager_add_ProgressChanged), METH_O, nullptr },
        { "remove_progress_changed", reinterpret_cast<PyCFunction>(WindowsUpdateManager_remove_ProgressChanged), METH_O, nullptr },
        { "add_scan_completed", reinterpret_cast<PyCFunction>(WindowsUpdateManager_add_ScanCompleted), METH_O, nullptr },
        { "remove_scan_completed", reinterpret_cast<PyCFunction>(WindowsUpdateManager_remove_ScanCompleted), METH_O, nullptr },
        { "add_scanning_state_changed", reinterpret_cast<PyCFunction>(WindowsUpdateManager_add_ScanningStateChanged), METH_O, nullptr },
        { "remove_scanning_state_changed", reinterpret_cast<PyCFunction>(WindowsUpdateManager_remove_ScanningStateChanged), METH_O, nullptr },
        { "add_working_state_changed", reinterpret_cast<PyCFunction>(WindowsUpdateManager_add_WorkingStateChanged), METH_O, nullptr },
        { "remove_working_state_changed", reinterpret_cast<PyCFunction>(WindowsUpdateManager_remove_WorkingStateChanged), METH_O, nullptr },
        { "_assign_array_", _assign_array_WindowsUpdateManager, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_WindowsUpdateManager), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_WindowsUpdateManager[] = {
        { "is_scanning", reinterpret_cast<getter>(WindowsUpdateManager_get_IsScanning), nullptr, nullptr, nullptr },
        { "is_working", reinterpret_cast<getter>(WindowsUpdateManager_get_IsWorking), nullptr, nullptr, nullptr },
        { "last_successful_scan_timestamp", reinterpret_cast<getter>(WindowsUpdateManager_get_LastSuccessfulScanTimestamp), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_WindowsUpdateManager[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_WindowsUpdateManager) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_WindowsUpdateManager) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_WindowsUpdateManager) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_WindowsUpdateManager) },
        { },
    };

    static PyType_Spec type_spec_WindowsUpdateManager =
    {
        "winrt._winrt_windows_management_update.WindowsUpdateManager",
        sizeof(py::wrapper::Windows::Management::Update::WindowsUpdateManager),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_WindowsUpdateManager
    };

    // ----- WindowsUpdateProgressChangedEventArgs class --------------------

    static PyObject* _new_WindowsUpdateProgressChangedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Management::Update::WindowsUpdateProgressChangedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Management::Update::WindowsUpdateProgressChangedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_WindowsUpdateProgressChangedEventArgs(py::wrapper::Windows::Management::Update::WindowsUpdateProgressChangedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* WindowsUpdateProgressChangedEventArgs_get_ActionProgress(py::wrapper::Windows::Management::Update::WindowsUpdateProgressChangedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Update.WindowsUpdateProgressChangedEventArgs", L"ActionProgress"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ActionProgress());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WindowsUpdateProgressChangedEventArgs_get_Update(py::wrapper::Windows::Management::Update::WindowsUpdateProgressChangedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Update.WindowsUpdateProgressChangedEventArgs", L"Update"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Update());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_WindowsUpdateProgressChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Management::Update::WindowsUpdateProgressChangedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_WindowsUpdateProgressChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Management::Update::WindowsUpdateProgressChangedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_WindowsUpdateProgressChangedEventArgs[] = {
        { "_assign_array_", _assign_array_WindowsUpdateProgressChangedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_WindowsUpdateProgressChangedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_WindowsUpdateProgressChangedEventArgs[] = {
        { "action_progress", reinterpret_cast<getter>(WindowsUpdateProgressChangedEventArgs_get_ActionProgress), nullptr, nullptr, nullptr },
        { "update", reinterpret_cast<getter>(WindowsUpdateProgressChangedEventArgs_get_Update), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_WindowsUpdateProgressChangedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_WindowsUpdateProgressChangedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_WindowsUpdateProgressChangedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_WindowsUpdateProgressChangedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_WindowsUpdateProgressChangedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_WindowsUpdateProgressChangedEventArgs =
    {
        "winrt._winrt_windows_management_update.WindowsUpdateProgressChangedEventArgs",
        sizeof(py::wrapper::Windows::Management::Update::WindowsUpdateProgressChangedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_WindowsUpdateProgressChangedEventArgs
    };

    // ----- WindowsUpdateRestartRequestOptions class --------------------

    static PyObject* _new_WindowsUpdateRestartRequestOptions(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 5)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 2);
                auto param3 = py::convert_to<int32_t>(args, 3);
                auto param4 = py::convert_to<int32_t>(args, 4);

                winrt::Windows::Management::Update::WindowsUpdateRestartRequestOptions instance{ param0, param1, param2, param3, param4 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Management::Update::WindowsUpdateRestartRequestOptions instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_WindowsUpdateRestartRequestOptions(py::wrapper::Windows::Management::Update::WindowsUpdateRestartRequestOptions* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* WindowsUpdateRestartRequestOptions_get_Title(py::wrapper::Windows::Management::Update::WindowsUpdateRestartRequestOptions* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Update.WindowsUpdateRestartRequestOptions", L"Title"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Title());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int WindowsUpdateRestartRequestOptions_put_Title(py::wrapper::Windows::Management::Update::WindowsUpdateRestartRequestOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Update.WindowsUpdateRestartRequestOptions", L"Title"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Title(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* WindowsUpdateRestartRequestOptions_get_OrganizationName(py::wrapper::Windows::Management::Update::WindowsUpdateRestartRequestOptions* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Update.WindowsUpdateRestartRequestOptions", L"OrganizationName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.OrganizationName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int WindowsUpdateRestartRequestOptions_put_OrganizationName(py::wrapper::Windows::Management::Update::WindowsUpdateRestartRequestOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Update.WindowsUpdateRestartRequestOptions", L"OrganizationName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.OrganizationName(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* WindowsUpdateRestartRequestOptions_get_OptOutOfAutoReboot(py::wrapper::Windows::Management::Update::WindowsUpdateRestartRequestOptions* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Update.WindowsUpdateRestartRequestOptions", L"OptOutOfAutoReboot"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.OptOutOfAutoReboot());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int WindowsUpdateRestartRequestOptions_put_OptOutOfAutoReboot(py::wrapper::Windows::Management::Update::WindowsUpdateRestartRequestOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Update.WindowsUpdateRestartRequestOptions", L"OptOutOfAutoReboot"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.OptOutOfAutoReboot(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* WindowsUpdateRestartRequestOptions_get_MoreInfoUrl(py::wrapper::Windows::Management::Update::WindowsUpdateRestartRequestOptions* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Update.WindowsUpdateRestartRequestOptions", L"MoreInfoUrl"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MoreInfoUrl());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int WindowsUpdateRestartRequestOptions_put_MoreInfoUrl(py::wrapper::Windows::Management::Update::WindowsUpdateRestartRequestOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Update.WindowsUpdateRestartRequestOptions", L"MoreInfoUrl"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(arg);

            self->obj.MoreInfoUrl(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* WindowsUpdateRestartRequestOptions_get_Description(py::wrapper::Windows::Management::Update::WindowsUpdateRestartRequestOptions* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Update.WindowsUpdateRestartRequestOptions", L"Description"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Description());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int WindowsUpdateRestartRequestOptions_put_Description(py::wrapper::Windows::Management::Update::WindowsUpdateRestartRequestOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Update.WindowsUpdateRestartRequestOptions", L"Description"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Description(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* WindowsUpdateRestartRequestOptions_get_ComplianceGracePeriodInDays(py::wrapper::Windows::Management::Update::WindowsUpdateRestartRequestOptions* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Update.WindowsUpdateRestartRequestOptions", L"ComplianceGracePeriodInDays"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ComplianceGracePeriodInDays());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int WindowsUpdateRestartRequestOptions_put_ComplianceGracePeriodInDays(py::wrapper::Windows::Management::Update::WindowsUpdateRestartRequestOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Update.WindowsUpdateRestartRequestOptions", L"ComplianceGracePeriodInDays"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<int32_t>(arg);

            self->obj.ComplianceGracePeriodInDays(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* WindowsUpdateRestartRequestOptions_get_ComplianceDeadlineInDays(py::wrapper::Windows::Management::Update::WindowsUpdateRestartRequestOptions* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Update.WindowsUpdateRestartRequestOptions", L"ComplianceDeadlineInDays"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ComplianceDeadlineInDays());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int WindowsUpdateRestartRequestOptions_put_ComplianceDeadlineInDays(py::wrapper::Windows::Management::Update::WindowsUpdateRestartRequestOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Update.WindowsUpdateRestartRequestOptions", L"ComplianceDeadlineInDays"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<int32_t>(arg);

            self->obj.ComplianceDeadlineInDays(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_WindowsUpdateRestartRequestOptions(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Management::Update::WindowsUpdateRestartRequestOptions>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_WindowsUpdateRestartRequestOptions(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Management::Update::WindowsUpdateRestartRequestOptions>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_WindowsUpdateRestartRequestOptions[] = {
        { "_assign_array_", _assign_array_WindowsUpdateRestartRequestOptions, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_WindowsUpdateRestartRequestOptions), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_WindowsUpdateRestartRequestOptions[] = {
        { "title", reinterpret_cast<getter>(WindowsUpdateRestartRequestOptions_get_Title), reinterpret_cast<setter>(WindowsUpdateRestartRequestOptions_put_Title), nullptr, nullptr },
        { "organization_name", reinterpret_cast<getter>(WindowsUpdateRestartRequestOptions_get_OrganizationName), reinterpret_cast<setter>(WindowsUpdateRestartRequestOptions_put_OrganizationName), nullptr, nullptr },
        { "opt_out_of_auto_reboot", reinterpret_cast<getter>(WindowsUpdateRestartRequestOptions_get_OptOutOfAutoReboot), reinterpret_cast<setter>(WindowsUpdateRestartRequestOptions_put_OptOutOfAutoReboot), nullptr, nullptr },
        { "more_info_url", reinterpret_cast<getter>(WindowsUpdateRestartRequestOptions_get_MoreInfoUrl), reinterpret_cast<setter>(WindowsUpdateRestartRequestOptions_put_MoreInfoUrl), nullptr, nullptr },
        { "description", reinterpret_cast<getter>(WindowsUpdateRestartRequestOptions_get_Description), reinterpret_cast<setter>(WindowsUpdateRestartRequestOptions_put_Description), nullptr, nullptr },
        { "compliance_grace_period_in_days", reinterpret_cast<getter>(WindowsUpdateRestartRequestOptions_get_ComplianceGracePeriodInDays), reinterpret_cast<setter>(WindowsUpdateRestartRequestOptions_put_ComplianceGracePeriodInDays), nullptr, nullptr },
        { "compliance_deadline_in_days", reinterpret_cast<getter>(WindowsUpdateRestartRequestOptions_get_ComplianceDeadlineInDays), reinterpret_cast<setter>(WindowsUpdateRestartRequestOptions_put_ComplianceDeadlineInDays), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_WindowsUpdateRestartRequestOptions[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_WindowsUpdateRestartRequestOptions) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_WindowsUpdateRestartRequestOptions) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_WindowsUpdateRestartRequestOptions) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_WindowsUpdateRestartRequestOptions) },
        { },
    };

    static PyType_Spec type_spec_WindowsUpdateRestartRequestOptions =
    {
        "winrt._winrt_windows_management_update.WindowsUpdateRestartRequestOptions",
        sizeof(py::wrapper::Windows::Management::Update::WindowsUpdateRestartRequestOptions),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_WindowsUpdateRestartRequestOptions
    };

    // ----- WindowsUpdateScanCompletedEventArgs class --------------------

    static PyObject* _new_WindowsUpdateScanCompletedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Management::Update::WindowsUpdateScanCompletedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Management::Update::WindowsUpdateScanCompletedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_WindowsUpdateScanCompletedEventArgs(py::wrapper::Windows::Management::Update::WindowsUpdateScanCompletedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* WindowsUpdateScanCompletedEventArgs_get_ExtendedError(py::wrapper::Windows::Management::Update::WindowsUpdateScanCompletedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Update.WindowsUpdateScanCompletedEventArgs", L"ExtendedError"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ExtendedError());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WindowsUpdateScanCompletedEventArgs_get_ProviderId(py::wrapper::Windows::Management::Update::WindowsUpdateScanCompletedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Update.WindowsUpdateScanCompletedEventArgs", L"ProviderId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ProviderId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WindowsUpdateScanCompletedEventArgs_get_Succeeded(py::wrapper::Windows::Management::Update::WindowsUpdateScanCompletedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Update.WindowsUpdateScanCompletedEventArgs", L"Succeeded"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Succeeded());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WindowsUpdateScanCompletedEventArgs_get_Updates(py::wrapper::Windows::Management::Update::WindowsUpdateScanCompletedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Update.WindowsUpdateScanCompletedEventArgs", L"Updates"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Updates());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_WindowsUpdateScanCompletedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Management::Update::WindowsUpdateScanCompletedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_WindowsUpdateScanCompletedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Management::Update::WindowsUpdateScanCompletedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_WindowsUpdateScanCompletedEventArgs[] = {
        { "_assign_array_", _assign_array_WindowsUpdateScanCompletedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_WindowsUpdateScanCompletedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_WindowsUpdateScanCompletedEventArgs[] = {
        { "extended_error", reinterpret_cast<getter>(WindowsUpdateScanCompletedEventArgs_get_ExtendedError), nullptr, nullptr, nullptr },
        { "provider_id", reinterpret_cast<getter>(WindowsUpdateScanCompletedEventArgs_get_ProviderId), nullptr, nullptr, nullptr },
        { "succeeded", reinterpret_cast<getter>(WindowsUpdateScanCompletedEventArgs_get_Succeeded), nullptr, nullptr, nullptr },
        { "updates", reinterpret_cast<getter>(WindowsUpdateScanCompletedEventArgs_get_Updates), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_WindowsUpdateScanCompletedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_WindowsUpdateScanCompletedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_WindowsUpdateScanCompletedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_WindowsUpdateScanCompletedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_WindowsUpdateScanCompletedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_WindowsUpdateScanCompletedEventArgs =
    {
        "winrt._winrt_windows_management_update.WindowsUpdateScanCompletedEventArgs",
        sizeof(py::wrapper::Windows::Management::Update::WindowsUpdateScanCompletedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_WindowsUpdateScanCompletedEventArgs
    };

    // ----- Windows.Management.Update Initialization --------------------
    PyDoc_STRVAR(module_doc, "Windows::Management::Update");


    static PyModuleDef module_def
        = {PyModuleDef_HEAD_INIT,
           "_winrt_windows_management_update",
           module_doc,
           0,
           nullptr,
           nullptr,
           nullptr,
           nullptr,
           nullptr};

} // py::cpp::Windows::Management::Update

PyMODINIT_FUNC PyInit__winrt_windows_management_update(void) noexcept
{
    using namespace py::cpp::Windows::Management::Update;

    if (py::import_winrt_runtime() == -1)
    {
        return nullptr;
    }

    py::pyobj_handle module{PyModule_Create(&module_def)};

    if (!module)
    {
        return nullptr;
    }

    auto object_type = py::get_object_type();
    if (!object_type)
    {
        return nullptr;
    }

    py::pyobj_handle object_bases{PyTuple_Pack(1, object_type)};

    if (!object_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_PreviewBuildsManager_Static{PyType_FromSpec(&type_spec_PreviewBuildsManager_Static)};
    if (!type_PreviewBuildsManager_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_PreviewBuildsManager, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_PreviewBuildsManager_Static.get())) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_PreviewBuildsState, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_WindowsUpdate, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_WindowsUpdateActionCompletedEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_WindowsUpdateActionProgress, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_WindowsUpdateActionResult, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_WindowsUpdateAdministrator_Static{PyType_FromSpec(&type_spec_WindowsUpdateAdministrator_Static)};
    if (!type_WindowsUpdateAdministrator_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_WindowsUpdateAdministrator, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_WindowsUpdateAdministrator_Static.get())) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_WindowsUpdateApprovalData, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_WindowsUpdateAttentionRequiredInfo, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_WindowsUpdateAttentionRequiredReasonChangedEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_WindowsUpdateGetAdministratorResult, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_WindowsUpdateItem, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_WindowsUpdateManager, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_WindowsUpdateProgressChangedEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_WindowsUpdateRestartRequestOptions, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_WindowsUpdateScanCompletedEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }


    return module.detach();
}
