# WARNING: Please don't edit this file. It was generated by Python/WinRT v2.0.0-beta.2

import datetime
import sys
import types
import typing
import uuid as _uuid
from builtins import property as _property

import winrt._winrt
import winrt.system
import winrt.windows.applicationmodel.activation
import winrt.windows.applicationmodel.calls.background
import winrt.windows.devices.bluetooth
import winrt.windows.devices.bluetooth.advertisement
import winrt.windows.devices.bluetooth.background
import winrt.windows.devices.bluetooth.genericattributeprofile
import winrt.windows.devices.geolocation
import winrt.windows.devices.sensors
import winrt.windows.devices.smartcards
import winrt.windows.devices.sms
import winrt.windows.foundation
import winrt.windows.foundation.collections
import winrt.windows.networking
import winrt.windows.networking.sockets
import winrt.windows.storage
import winrt.windows.storage.provider
import winrt.windows.system
import winrt.windows.ui.notifications

from winrt.windows.applicationmodel.background import AlarmAccessStatus, ApplicationTriggerResult, BackgroundAccessRequestKind, BackgroundAccessStatus, BackgroundTaskCancellationReason, BackgroundTaskThrottleCounter, BackgroundWorkCostValue, CustomSystemEventTriggerRecurrence, DeviceTriggerResult, LocationTriggerType, MediaProcessingTriggerResult, SystemConditionType, SystemTriggerType
from winrt.windows.applicationmodel.background import BackgroundTaskCanceledEventHandler, BackgroundTaskCompletedEventHandler, BackgroundTaskProgressEventHandler

Self = typing.TypeVar('Self')

@typing.final
class ActivitySensorTrigger(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ActivitySensorTrigger: ...
    def __new__(cls: typing.Type[ActivitySensorTrigger], report_interval_in_milliseconds: winrt.system.UInt32) -> ActivitySensorTrigger:...
    @_property
    def minimum_report_interval(self) -> winrt.system.UInt32: ...
    @_property
    def report_interval(self) -> winrt.system.UInt32: ...
    @_property
    def subscribed_activities(self) -> typing.Optional[winrt.windows.foundation.collections.IVector[winrt.windows.devices.sensors.ActivityType]]: ...
    @_property
    def supported_activities(self) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[winrt.windows.devices.sensors.ActivityType]]: ...

@typing.final
class AlarmApplicationManager_Static(type):
    def get_access_status(cls) -> AlarmAccessStatus: ...
    def request_access_async(cls) -> winrt.windows.foundation.IAsyncOperation[AlarmAccessStatus]: ...

@typing.final
class AlarmApplicationManager(winrt.system.Object, metaclass=AlarmApplicationManager_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> AlarmApplicationManager: ...

@typing.final
class AppBroadcastTrigger(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> AppBroadcastTrigger: ...
    def __new__(cls: typing.Type[AppBroadcastTrigger], provider_key: str) -> AppBroadcastTrigger:...
    @_property
    def provider_info(self) -> typing.Optional[AppBroadcastTriggerProviderInfo]: ...
    @provider_info.setter
    def provider_info(self, value: typing.Optional[AppBroadcastTriggerProviderInfo]) -> None: ...

@typing.final
class AppBroadcastTriggerProviderInfo(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> AppBroadcastTriggerProviderInfo: ...
    @_property
    def video_key_frame_interval(self) -> datetime.timedelta: ...
    @video_key_frame_interval.setter
    def video_key_frame_interval(self, value: datetime.timedelta) -> None: ...
    @_property
    def max_video_width(self) -> winrt.system.UInt32: ...
    @max_video_width.setter
    def max_video_width(self, value: winrt.system.UInt32) -> None: ...
    @_property
    def max_video_height(self) -> winrt.system.UInt32: ...
    @max_video_height.setter
    def max_video_height(self, value: winrt.system.UInt32) -> None: ...
    @_property
    def max_video_bitrate(self) -> winrt.system.UInt32: ...
    @max_video_bitrate.setter
    def max_video_bitrate(self, value: winrt.system.UInt32) -> None: ...
    @_property
    def logo_resource(self) -> str: ...
    @logo_resource.setter
    def logo_resource(self, value: str) -> None: ...
    @_property
    def display_name_resource(self) -> str: ...
    @display_name_resource.setter
    def display_name_resource(self, value: str) -> None: ...

@typing.final
class ApplicationTrigger(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ApplicationTrigger: ...
    def __new__(cls: typing.Type[ApplicationTrigger]) -> ApplicationTrigger:...
    @typing.overload
    def request_async(self) -> winrt.windows.foundation.IAsyncOperation[ApplicationTriggerResult]: ...
    @typing.overload
    def request_async(self, arguments: typing.Optional[winrt.windows.foundation.collections.ValueSet], /) -> winrt.windows.foundation.IAsyncOperation[ApplicationTriggerResult]: ...

@typing.final
class ApplicationTriggerDetails(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ApplicationTriggerDetails: ...
    @_property
    def arguments(self) -> typing.Optional[winrt.windows.foundation.collections.ValueSet]: ...

@typing.final
class AppointmentStoreNotificationTrigger(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> AppointmentStoreNotificationTrigger: ...
    def __new__(cls: typing.Type[AppointmentStoreNotificationTrigger]) -> AppointmentStoreNotificationTrigger:...

@typing.final
class BackgroundExecutionManager_Static(type):
    @typing.overload
    def get_access_status(cls) -> BackgroundAccessStatus: ...
    @typing.overload
    def get_access_status(cls, application_id: str, /) -> BackgroundAccessStatus: ...
    @typing.overload
    def get_access_status_for_modern_standby(cls) -> BackgroundAccessStatus: ...
    @typing.overload
    def get_access_status_for_modern_standby(cls, application_id: str, /) -> BackgroundAccessStatus: ...
    @typing.overload
    def remove_access(cls) -> None: ...
    @typing.overload
    def remove_access(cls, application_id: str, /) -> None: ...
    @typing.overload
    def request_access_async(cls) -> winrt.windows.foundation.IAsyncOperation[BackgroundAccessStatus]: ...
    @typing.overload
    def request_access_async(cls, application_id: str, /) -> winrt.windows.foundation.IAsyncOperation[BackgroundAccessStatus]: ...
    def request_access_kind_async(cls, requested_access: BackgroundAccessRequestKind, reason: str, /) -> winrt.windows.foundation.IAsyncOperation[bool]: ...
    def request_access_kind_for_modern_standby_async(cls, requested_access: BackgroundAccessRequestKind, reason: str, /) -> winrt.windows.foundation.IAsyncOperation[bool]: ...

@typing.final
class BackgroundExecutionManager(winrt.system.Object, metaclass=BackgroundExecutionManager_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> BackgroundExecutionManager: ...

@typing.final
class BackgroundTaskBuilder(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> BackgroundTaskBuilder: ...
    def __new__(cls: typing.Type[BackgroundTaskBuilder]) -> BackgroundTaskBuilder:...
    def add_condition(self, condition: typing.Optional[IBackgroundCondition], /) -> None: ...
    def register(self) -> typing.Optional[BackgroundTaskRegistration]: ...
    def set_task_entry_point_clsid(self, task_entry_point: _uuid.UUID, /) -> None: ...
    def set_trigger(self, trigger: typing.Optional[IBackgroundTrigger], /) -> None: ...
    @_property
    def task_entry_point(self) -> str: ...
    @task_entry_point.setter
    def task_entry_point(self, value: str) -> None: ...
    @_property
    def name(self) -> str: ...
    @name.setter
    def name(self, value: str) -> None: ...
    @_property
    def cancel_on_condition_loss(self) -> bool: ...
    @cancel_on_condition_loss.setter
    def cancel_on_condition_loss(self, value: bool) -> None: ...
    @_property
    def is_network_requested(self) -> bool: ...
    @is_network_requested.setter
    def is_network_requested(self, value: bool) -> None: ...
    @_property
    def task_group(self) -> typing.Optional[BackgroundTaskRegistrationGroup]: ...
    @task_group.setter
    def task_group(self, value: typing.Optional[BackgroundTaskRegistrationGroup]) -> None: ...

@typing.final
class BackgroundTaskCompletedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> BackgroundTaskCompletedEventArgs: ...
    def check_result(self) -> None: ...
    @_property
    def instance_id(self) -> _uuid.UUID: ...

@typing.final
class BackgroundTaskDeferral(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> BackgroundTaskDeferral: ...
    def complete(self) -> None: ...

@typing.final
class BackgroundTaskProgressEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> BackgroundTaskProgressEventArgs: ...
    @_property
    def instance_id(self) -> _uuid.UUID: ...
    @_property
    def progress(self) -> winrt.system.UInt32: ...

@typing.final
class BackgroundTaskRegistration_Static(type):
    def get_task_group(cls, group_id: str, /) -> typing.Optional[BackgroundTaskRegistrationGroup]: ...
    @_property
    def all_tasks(cls) -> typing.Optional[winrt.windows.foundation.collections.IMapView[_uuid.UUID, IBackgroundTaskRegistration]]: ...
    @_property
    def all_task_groups(cls) -> typing.Optional[winrt.windows.foundation.collections.IMapView[str, BackgroundTaskRegistrationGroup]]: ...

@typing.final
class BackgroundTaskRegistration(winrt.system.Object, metaclass=BackgroundTaskRegistration_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> BackgroundTaskRegistration: ...
    def unregister(self, cancel_task: bool, /) -> None: ...
    def add_completed(self, handler: typing.Optional[BackgroundTaskCompletedEventHandler], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_completed(self, cookie: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_progress(self, handler: typing.Optional[BackgroundTaskProgressEventHandler], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_progress(self, cookie: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    @_property
    def name(self) -> str: ...
    @_property
    def task_id(self) -> _uuid.UUID: ...
    @_property
    def trigger(self) -> typing.Optional[IBackgroundTrigger]: ...
    @_property
    def task_group(self) -> typing.Optional[BackgroundTaskRegistrationGroup]: ...

@typing.final
class BackgroundTaskRegistrationGroup(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> BackgroundTaskRegistrationGroup: ...
    @typing.overload
    def __new__(cls: typing.Type[BackgroundTaskRegistrationGroup], id: str) -> BackgroundTaskRegistrationGroup:...
    @typing.overload
    def __new__(cls: typing.Type[BackgroundTaskRegistrationGroup], id: str, name: str) -> BackgroundTaskRegistrationGroup:...
    def add_background_activated(self, handler: winrt.windows.foundation.TypedEventHandler[BackgroundTaskRegistrationGroup, winrt.windows.applicationmodel.activation.BackgroundActivatedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_background_activated(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    @_property
    def all_tasks(self) -> typing.Optional[winrt.windows.foundation.collections.IMapView[_uuid.UUID, BackgroundTaskRegistration]]: ...
    @_property
    def id(self) -> str: ...
    @_property
    def name(self) -> str: ...

@typing.final
class BackgroundWorkCost_Static(type):
    @_property
    def current_background_work_cost(cls) -> BackgroundWorkCostValue: ...

@typing.final
class BackgroundWorkCost(winrt.system.Object, metaclass=BackgroundWorkCost_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> BackgroundWorkCost: ...

@typing.final
class BluetoothLEAdvertisementPublisherTrigger(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> BluetoothLEAdvertisementPublisherTrigger: ...
    def __new__(cls: typing.Type[BluetoothLEAdvertisementPublisherTrigger]) -> BluetoothLEAdvertisementPublisherTrigger:...
    @_property
    def advertisement(self) -> typing.Optional[winrt.windows.devices.bluetooth.advertisement.BluetoothLEAdvertisement]: ...
    @_property
    def use_extended_format(self) -> bool: ...
    @use_extended_format.setter
    def use_extended_format(self, value: bool) -> None: ...
    @_property
    def preferred_transmit_power_level_in_d_bm(self) -> typing.Optional[typing.Optional[winrt.system.Int16]]: ...
    @preferred_transmit_power_level_in_d_bm.setter
    def preferred_transmit_power_level_in_d_bm(self, value: typing.Optional[typing.Optional[winrt.system.Int16]]) -> None: ...
    @_property
    def is_anonymous(self) -> bool: ...
    @is_anonymous.setter
    def is_anonymous(self, value: bool) -> None: ...
    @_property
    def include_transmit_power_level(self) -> bool: ...
    @include_transmit_power_level.setter
    def include_transmit_power_level(self, value: bool) -> None: ...

@typing.final
class BluetoothLEAdvertisementWatcherTrigger(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> BluetoothLEAdvertisementWatcherTrigger: ...
    def __new__(cls: typing.Type[BluetoothLEAdvertisementWatcherTrigger]) -> BluetoothLEAdvertisementWatcherTrigger:...
    @_property
    def signal_strength_filter(self) -> typing.Optional[winrt.windows.devices.bluetooth.BluetoothSignalStrengthFilter]: ...
    @signal_strength_filter.setter
    def signal_strength_filter(self, value: typing.Optional[winrt.windows.devices.bluetooth.BluetoothSignalStrengthFilter]) -> None: ...
    @_property
    def advertisement_filter(self) -> typing.Optional[winrt.windows.devices.bluetooth.advertisement.BluetoothLEAdvertisementFilter]: ...
    @advertisement_filter.setter
    def advertisement_filter(self, value: typing.Optional[winrt.windows.devices.bluetooth.advertisement.BluetoothLEAdvertisementFilter]) -> None: ...
    @_property
    def max_out_of_range_timeout(self) -> datetime.timedelta: ...
    @_property
    def max_sampling_interval(self) -> datetime.timedelta: ...
    @_property
    def min_out_of_range_timeout(self) -> datetime.timedelta: ...
    @_property
    def min_sampling_interval(self) -> datetime.timedelta: ...
    @_property
    def allow_extended_advertisements(self) -> bool: ...
    @allow_extended_advertisements.setter
    def allow_extended_advertisements(self, value: bool) -> None: ...

@typing.final
class CachedFileUpdaterTrigger(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> CachedFileUpdaterTrigger: ...
    def __new__(cls: typing.Type[CachedFileUpdaterTrigger]) -> CachedFileUpdaterTrigger:...

@typing.final
class CachedFileUpdaterTriggerDetails(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> CachedFileUpdaterTriggerDetails: ...
    @_property
    def can_request_user_input(self) -> bool: ...
    @_property
    def update_request(self) -> typing.Optional[winrt.windows.storage.provider.FileUpdateRequest]: ...
    @_property
    def update_target(self) -> winrt.windows.storage.provider.CachedFileTarget: ...

@typing.final
class ChatMessageNotificationTrigger(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ChatMessageNotificationTrigger: ...
    def __new__(cls: typing.Type[ChatMessageNotificationTrigger]) -> ChatMessageNotificationTrigger:...

@typing.final
class ChatMessageReceivedNotificationTrigger(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ChatMessageReceivedNotificationTrigger: ...
    def __new__(cls: typing.Type[ChatMessageReceivedNotificationTrigger]) -> ChatMessageReceivedNotificationTrigger:...

@typing.final
class CommunicationBlockingAppSetAsActiveTrigger(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> CommunicationBlockingAppSetAsActiveTrigger: ...
    def __new__(cls: typing.Type[CommunicationBlockingAppSetAsActiveTrigger]) -> CommunicationBlockingAppSetAsActiveTrigger:...

@typing.final
class ContactStoreNotificationTrigger(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ContactStoreNotificationTrigger: ...
    def __new__(cls: typing.Type[ContactStoreNotificationTrigger]) -> ContactStoreNotificationTrigger:...

@typing.final
class ContentPrefetchTrigger(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ContentPrefetchTrigger: ...
    @typing.overload
    def __new__(cls: typing.Type[ContentPrefetchTrigger], wait_interval: datetime.timedelta) -> ContentPrefetchTrigger:...
    @typing.overload
    def __new__(cls: typing.Type[ContentPrefetchTrigger]) -> ContentPrefetchTrigger:...
    @_property
    def wait_interval(self) -> datetime.timedelta: ...

@typing.final
class ConversationalAgentTrigger(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ConversationalAgentTrigger: ...
    def __new__(cls: typing.Type[ConversationalAgentTrigger]) -> ConversationalAgentTrigger:...

@typing.final
class CustomSystemEventTrigger(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> CustomSystemEventTrigger: ...
    def __new__(cls: typing.Type[CustomSystemEventTrigger], trigger_id: str, recurrence: CustomSystemEventTriggerRecurrence) -> CustomSystemEventTrigger:...
    @_property
    def recurrence(self) -> CustomSystemEventTriggerRecurrence: ...
    @_property
    def trigger_id(self) -> str: ...

@typing.final
class DeviceConnectionChangeTrigger_Static(type):
    def from_id_async(cls, device_id: str, /) -> winrt.windows.foundation.IAsyncOperation[DeviceConnectionChangeTrigger]: ...

@typing.final
class DeviceConnectionChangeTrigger(winrt.system.Object, metaclass=DeviceConnectionChangeTrigger_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> DeviceConnectionChangeTrigger: ...
    @_property
    def maintain_connection(self) -> bool: ...
    @maintain_connection.setter
    def maintain_connection(self, value: bool) -> None: ...
    @_property
    def can_maintain_connection(self) -> bool: ...
    @_property
    def device_id(self) -> str: ...

@typing.final
class DeviceManufacturerNotificationTrigger(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> DeviceManufacturerNotificationTrigger: ...
    def __new__(cls: typing.Type[DeviceManufacturerNotificationTrigger], trigger_qualifier: str, one_shot: bool) -> DeviceManufacturerNotificationTrigger:...
    @_property
    def one_shot(self) -> bool: ...
    @_property
    def trigger_qualifier(self) -> str: ...

@typing.final
class DeviceServicingTrigger(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> DeviceServicingTrigger: ...
    def __new__(cls: typing.Type[DeviceServicingTrigger]) -> DeviceServicingTrigger:...
    @typing.overload
    def request_async(self, device_id: str, expected_duration: datetime.timedelta, /) -> winrt.windows.foundation.IAsyncOperation[DeviceTriggerResult]: ...
    @typing.overload
    def request_async(self, device_id: str, expected_duration: datetime.timedelta, arguments: str, /) -> winrt.windows.foundation.IAsyncOperation[DeviceTriggerResult]: ...

@typing.final
class DeviceUseTrigger(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> DeviceUseTrigger: ...
    def __new__(cls: typing.Type[DeviceUseTrigger]) -> DeviceUseTrigger:...
    @typing.overload
    def request_async(self, device_id: str, /) -> winrt.windows.foundation.IAsyncOperation[DeviceTriggerResult]: ...
    @typing.overload
    def request_async(self, device_id: str, arguments: str, /) -> winrt.windows.foundation.IAsyncOperation[DeviceTriggerResult]: ...

@typing.final
class DeviceWatcherTrigger(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> DeviceWatcherTrigger: ...

@typing.final
class EmailStoreNotificationTrigger(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> EmailStoreNotificationTrigger: ...
    def __new__(cls: typing.Type[EmailStoreNotificationTrigger]) -> EmailStoreNotificationTrigger:...

@typing.final
class GattCharacteristicNotificationTrigger(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> GattCharacteristicNotificationTrigger: ...
    @typing.overload
    def __new__(cls: typing.Type[GattCharacteristicNotificationTrigger], characteristic: typing.Optional[winrt.windows.devices.bluetooth.genericattributeprofile.GattCharacteristic], event_triggering_mode: winrt.windows.devices.bluetooth.background.BluetoothEventTriggeringMode) -> GattCharacteristicNotificationTrigger:...
    @typing.overload
    def __new__(cls: typing.Type[GattCharacteristicNotificationTrigger], characteristic: typing.Optional[winrt.windows.devices.bluetooth.genericattributeprofile.GattCharacteristic]) -> GattCharacteristicNotificationTrigger:...
    @_property
    def characteristic(self) -> typing.Optional[winrt.windows.devices.bluetooth.genericattributeprofile.GattCharacteristic]: ...
    @_property
    def event_triggering_mode(self) -> winrt.windows.devices.bluetooth.background.BluetoothEventTriggeringMode: ...

@typing.final
class GattServiceProviderTrigger_Static(type):
    def create_async(cls, trigger_id: str, service_uuid: _uuid.UUID, /) -> winrt.windows.foundation.IAsyncOperation[GattServiceProviderTriggerResult]: ...

@typing.final
class GattServiceProviderTrigger(winrt.system.Object, metaclass=GattServiceProviderTrigger_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> GattServiceProviderTrigger: ...
    @_property
    def advertising_parameters(self) -> typing.Optional[winrt.windows.devices.bluetooth.genericattributeprofile.GattServiceProviderAdvertisingParameters]: ...
    @advertising_parameters.setter
    def advertising_parameters(self, value: typing.Optional[winrt.windows.devices.bluetooth.genericattributeprofile.GattServiceProviderAdvertisingParameters]) -> None: ...
    @_property
    def service(self) -> typing.Optional[winrt.windows.devices.bluetooth.genericattributeprofile.GattLocalService]: ...
    @_property
    def trigger_id(self) -> str: ...

@typing.final
class GattServiceProviderTriggerResult(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> GattServiceProviderTriggerResult: ...
    @_property
    def error(self) -> winrt.windows.devices.bluetooth.BluetoothError: ...
    @_property
    def trigger(self) -> typing.Optional[GattServiceProviderTrigger]: ...

@typing.final
class GeovisitTrigger(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> GeovisitTrigger: ...
    def __new__(cls: typing.Type[GeovisitTrigger]) -> GeovisitTrigger:...
    @_property
    def monitoring_scope(self) -> winrt.windows.devices.geolocation.VisitMonitoringScope: ...
    @monitoring_scope.setter
    def monitoring_scope(self, value: winrt.windows.devices.geolocation.VisitMonitoringScope) -> None: ...

@typing.final
class LocationTrigger(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> LocationTrigger: ...
    def __new__(cls: typing.Type[LocationTrigger], trigger_type: LocationTriggerType) -> LocationTrigger:...
    @_property
    def trigger_type(self) -> LocationTriggerType: ...

@typing.final
class MaintenanceTrigger(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MaintenanceTrigger: ...
    def __new__(cls: typing.Type[MaintenanceTrigger], freshness_time: winrt.system.UInt32, one_shot: bool) -> MaintenanceTrigger:...
    @_property
    def freshness_time(self) -> winrt.system.UInt32: ...
    @_property
    def one_shot(self) -> bool: ...

@typing.final
class MediaProcessingTrigger(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MediaProcessingTrigger: ...
    def __new__(cls: typing.Type[MediaProcessingTrigger]) -> MediaProcessingTrigger:...
    @typing.overload
    def request_async(self) -> winrt.windows.foundation.IAsyncOperation[MediaProcessingTriggerResult]: ...
    @typing.overload
    def request_async(self, arguments: typing.Optional[winrt.windows.foundation.collections.ValueSet], /) -> winrt.windows.foundation.IAsyncOperation[MediaProcessingTriggerResult]: ...

@typing.final
class MobileBroadbandDeviceServiceNotificationTrigger(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MobileBroadbandDeviceServiceNotificationTrigger: ...
    def __new__(cls: typing.Type[MobileBroadbandDeviceServiceNotificationTrigger]) -> MobileBroadbandDeviceServiceNotificationTrigger:...

@typing.final
class MobileBroadbandPcoDataChangeTrigger(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MobileBroadbandPcoDataChangeTrigger: ...
    def __new__(cls: typing.Type[MobileBroadbandPcoDataChangeTrigger]) -> MobileBroadbandPcoDataChangeTrigger:...

@typing.final
class MobileBroadbandPinLockStateChangeTrigger(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MobileBroadbandPinLockStateChangeTrigger: ...
    def __new__(cls: typing.Type[MobileBroadbandPinLockStateChangeTrigger]) -> MobileBroadbandPinLockStateChangeTrigger:...

@typing.final
class MobileBroadbandRadioStateChangeTrigger(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MobileBroadbandRadioStateChangeTrigger: ...
    def __new__(cls: typing.Type[MobileBroadbandRadioStateChangeTrigger]) -> MobileBroadbandRadioStateChangeTrigger:...

@typing.final
class MobileBroadbandRegistrationStateChangeTrigger(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MobileBroadbandRegistrationStateChangeTrigger: ...
    def __new__(cls: typing.Type[MobileBroadbandRegistrationStateChangeTrigger]) -> MobileBroadbandRegistrationStateChangeTrigger:...

@typing.final
class NetworkOperatorDataUsageTrigger(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> NetworkOperatorDataUsageTrigger: ...
    def __new__(cls: typing.Type[NetworkOperatorDataUsageTrigger]) -> NetworkOperatorDataUsageTrigger:...

@typing.final
class NetworkOperatorHotspotAuthenticationTrigger(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> NetworkOperatorHotspotAuthenticationTrigger: ...
    def __new__(cls: typing.Type[NetworkOperatorHotspotAuthenticationTrigger]) -> NetworkOperatorHotspotAuthenticationTrigger:...

@typing.final
class NetworkOperatorNotificationTrigger(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> NetworkOperatorNotificationTrigger: ...
    def __new__(cls: typing.Type[NetworkOperatorNotificationTrigger], network_account_id: str) -> NetworkOperatorNotificationTrigger:...
    @_property
    def network_account_id(self) -> str: ...

@typing.final
class PaymentAppCanMakePaymentTrigger(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> PaymentAppCanMakePaymentTrigger: ...
    def __new__(cls: typing.Type[PaymentAppCanMakePaymentTrigger]) -> PaymentAppCanMakePaymentTrigger:...

@typing.final
class PhoneTrigger(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> PhoneTrigger: ...
    def __new__(cls: typing.Type[PhoneTrigger], type: winrt.windows.applicationmodel.calls.background.PhoneTriggerType, one_shot: bool) -> PhoneTrigger:...
    @_property
    def one_shot(self) -> bool: ...
    @_property
    def trigger_type(self) -> winrt.windows.applicationmodel.calls.background.PhoneTriggerType: ...

@typing.final
class PushNotificationTrigger(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> PushNotificationTrigger: ...
    @typing.overload
    def __new__(cls: typing.Type[PushNotificationTrigger], application_id: str) -> PushNotificationTrigger:...
    @typing.overload
    def __new__(cls: typing.Type[PushNotificationTrigger]) -> PushNotificationTrigger:...

@typing.final
class RcsEndUserMessageAvailableTrigger(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> RcsEndUserMessageAvailableTrigger: ...
    def __new__(cls: typing.Type[RcsEndUserMessageAvailableTrigger]) -> RcsEndUserMessageAvailableTrigger:...

@typing.final
class RfcommConnectionTrigger(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> RfcommConnectionTrigger: ...
    def __new__(cls: typing.Type[RfcommConnectionTrigger]) -> RfcommConnectionTrigger:...
    @_property
    def remote_host_name(self) -> typing.Optional[winrt.windows.networking.HostName]: ...
    @remote_host_name.setter
    def remote_host_name(self, value: typing.Optional[winrt.windows.networking.HostName]) -> None: ...
    @_property
    def protection_level(self) -> winrt.windows.networking.sockets.SocketProtectionLevel: ...
    @protection_level.setter
    def protection_level(self, value: winrt.windows.networking.sockets.SocketProtectionLevel) -> None: ...
    @_property
    def allow_multiple_connections(self) -> bool: ...
    @allow_multiple_connections.setter
    def allow_multiple_connections(self, value: bool) -> None: ...
    @_property
    def inbound_connection(self) -> typing.Optional[winrt.windows.devices.bluetooth.background.RfcommInboundConnectionInformation]: ...
    @_property
    def outbound_connection(self) -> typing.Optional[winrt.windows.devices.bluetooth.background.RfcommOutboundConnectionInformation]: ...

@typing.final
class SecondaryAuthenticationFactorAuthenticationTrigger(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> SecondaryAuthenticationFactorAuthenticationTrigger: ...
    def __new__(cls: typing.Type[SecondaryAuthenticationFactorAuthenticationTrigger]) -> SecondaryAuthenticationFactorAuthenticationTrigger:...

@typing.final
class SensorDataThresholdTrigger(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> SensorDataThresholdTrigger: ...
    def __new__(cls: typing.Type[SensorDataThresholdTrigger], threshold: typing.Optional[winrt.windows.devices.sensors.ISensorDataThreshold]) -> SensorDataThresholdTrigger:...

@typing.final
class SmartCardTrigger(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> SmartCardTrigger: ...
    def __new__(cls: typing.Type[SmartCardTrigger], trigger_type: winrt.windows.devices.smartcards.SmartCardTriggerType) -> SmartCardTrigger:...
    @_property
    def trigger_type(self) -> winrt.windows.devices.smartcards.SmartCardTriggerType: ...

@typing.final
class SmsMessageReceivedTrigger(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> SmsMessageReceivedTrigger: ...
    def __new__(cls: typing.Type[SmsMessageReceivedTrigger], filter_rules: typing.Optional[winrt.windows.devices.sms.SmsFilterRules]) -> SmsMessageReceivedTrigger:...

@typing.final
class SocketActivityTrigger(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> SocketActivityTrigger: ...
    def __new__(cls: typing.Type[SocketActivityTrigger]) -> SocketActivityTrigger:...
    @_property
    def is_wake_from_low_power_supported(self) -> bool: ...

@typing.final
class StorageLibraryChangeTrackerTrigger(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> StorageLibraryChangeTrackerTrigger: ...
    def __new__(cls: typing.Type[StorageLibraryChangeTrackerTrigger], tracker: typing.Optional[winrt.windows.storage.StorageLibraryChangeTracker]) -> StorageLibraryChangeTrackerTrigger:...

@typing.final
class StorageLibraryContentChangedTrigger_Static(type):
    def create(cls, storage_library: typing.Optional[winrt.windows.storage.StorageLibrary], /) -> typing.Optional[StorageLibraryContentChangedTrigger]: ...
    def create_from_libraries(cls, storage_libraries: typing.Iterable[winrt.windows.storage.StorageLibrary], /) -> typing.Optional[StorageLibraryContentChangedTrigger]: ...

@typing.final
class StorageLibraryContentChangedTrigger(winrt.system.Object, metaclass=StorageLibraryContentChangedTrigger_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> StorageLibraryContentChangedTrigger: ...

@typing.final
class SystemCondition(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> SystemCondition: ...
    def __new__(cls: typing.Type[SystemCondition], condition_type: SystemConditionType) -> SystemCondition:...
    @_property
    def condition_type(self) -> SystemConditionType: ...

@typing.final
class SystemTrigger(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> SystemTrigger: ...
    def __new__(cls: typing.Type[SystemTrigger], trigger_type: SystemTriggerType, one_shot: bool) -> SystemTrigger:...
    @_property
    def one_shot(self) -> bool: ...
    @_property
    def trigger_type(self) -> SystemTriggerType: ...

@typing.final
class TetheringEntitlementCheckTrigger(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> TetheringEntitlementCheckTrigger: ...
    def __new__(cls: typing.Type[TetheringEntitlementCheckTrigger]) -> TetheringEntitlementCheckTrigger:...

@typing.final
class TimeTrigger(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> TimeTrigger: ...
    def __new__(cls: typing.Type[TimeTrigger], freshness_time: winrt.system.UInt32, one_shot: bool) -> TimeTrigger:...
    @_property
    def freshness_time(self) -> winrt.system.UInt32: ...
    @_property
    def one_shot(self) -> bool: ...

@typing.final
class ToastNotificationActionTrigger(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ToastNotificationActionTrigger: ...
    @typing.overload
    def __new__(cls: typing.Type[ToastNotificationActionTrigger], application_id: str) -> ToastNotificationActionTrigger:...
    @typing.overload
    def __new__(cls: typing.Type[ToastNotificationActionTrigger]) -> ToastNotificationActionTrigger:...

@typing.final
class ToastNotificationHistoryChangedTrigger(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ToastNotificationHistoryChangedTrigger: ...
    @typing.overload
    def __new__(cls: typing.Type[ToastNotificationHistoryChangedTrigger], application_id: str) -> ToastNotificationHistoryChangedTrigger:...
    @typing.overload
    def __new__(cls: typing.Type[ToastNotificationHistoryChangedTrigger]) -> ToastNotificationHistoryChangedTrigger:...

@typing.final
class UserNotificationChangedTrigger(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> UserNotificationChangedTrigger: ...
    def __new__(cls: typing.Type[UserNotificationChangedTrigger], notification_kinds: winrt.windows.ui.notifications.NotificationKinds) -> UserNotificationChangedTrigger:...

@typing.final
class WiFiOnDemandHotspotConnectTrigger(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> WiFiOnDemandHotspotConnectTrigger: ...
    def __new__(cls: typing.Type[WiFiOnDemandHotspotConnectTrigger]) -> WiFiOnDemandHotspotConnectTrigger:...

@typing.final
class WiFiOnDemandHotspotUpdateMetadataTrigger(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> WiFiOnDemandHotspotUpdateMetadataTrigger: ...
    def __new__(cls: typing.Type[WiFiOnDemandHotspotUpdateMetadataTrigger]) -> WiFiOnDemandHotspotUpdateMetadataTrigger:...

@typing.final
class IBackgroundCondition(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> IBackgroundCondition: ...

@typing.final
class IBackgroundTask(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> IBackgroundTask: ...
    def run(self, task_instance: typing.Optional[IBackgroundTaskInstance], /) -> None: ...

@typing.final
class IBackgroundTaskInstance(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> IBackgroundTaskInstance: ...
    def get_deferral(self) -> typing.Optional[BackgroundTaskDeferral]: ...
    def add_canceled(self, cancel_handler: typing.Optional[BackgroundTaskCanceledEventHandler], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_canceled(self, cookie: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    @_property
    def instance_id(self) -> _uuid.UUID: ...
    @_property
    def progress(self) -> winrt.system.UInt32: ...
    @progress.setter
    def progress(self, value: winrt.system.UInt32) -> None: ...
    @_property
    def suspended_count(self) -> winrt.system.UInt32: ...
    @_property
    def task(self) -> typing.Optional[BackgroundTaskRegistration]: ...
    @_property
    def trigger_details(self) -> typing.Optional[winrt.system.Object]: ...

@typing.final
class IBackgroundTaskInstance2(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> IBackgroundTaskInstance2: ...
    def get_deferral(self) -> typing.Optional[BackgroundTaskDeferral]: ...
    def get_throttle_count(self, counter: BackgroundTaskThrottleCounter, /) -> winrt.system.UInt32: ...
    def add_canceled(self, cancel_handler: typing.Optional[BackgroundTaskCanceledEventHandler], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_canceled(self, cookie: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    @_property
    def instance_id(self) -> _uuid.UUID: ...
    @_property
    def progress(self) -> winrt.system.UInt32: ...
    @progress.setter
    def progress(self, value: winrt.system.UInt32) -> None: ...
    @_property
    def suspended_count(self) -> winrt.system.UInt32: ...
    @_property
    def task(self) -> typing.Optional[BackgroundTaskRegistration]: ...
    @_property
    def trigger_details(self) -> typing.Optional[winrt.system.Object]: ...

@typing.final
class IBackgroundTaskInstance4(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> IBackgroundTaskInstance4: ...
    def get_deferral(self) -> typing.Optional[BackgroundTaskDeferral]: ...
    def add_canceled(self, cancel_handler: typing.Optional[BackgroundTaskCanceledEventHandler], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_canceled(self, cookie: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    @_property
    def user(self) -> typing.Optional[winrt.windows.system.User]: ...
    @_property
    def instance_id(self) -> _uuid.UUID: ...
    @_property
    def progress(self) -> winrt.system.UInt32: ...
    @progress.setter
    def progress(self, value: winrt.system.UInt32) -> None: ...
    @_property
    def suspended_count(self) -> winrt.system.UInt32: ...
    @_property
    def task(self) -> typing.Optional[BackgroundTaskRegistration]: ...
    @_property
    def trigger_details(self) -> typing.Optional[winrt.system.Object]: ...

@typing.final
class IBackgroundTaskRegistration(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> IBackgroundTaskRegistration: ...
    def unregister(self, cancel_task: bool, /) -> None: ...
    def add_completed(self, handler: typing.Optional[BackgroundTaskCompletedEventHandler], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_completed(self, cookie: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_progress(self, handler: typing.Optional[BackgroundTaskProgressEventHandler], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_progress(self, cookie: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    @_property
    def name(self) -> str: ...
    @_property
    def task_id(self) -> _uuid.UUID: ...

@typing.final
class IBackgroundTaskRegistration2(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> IBackgroundTaskRegistration2: ...
    def unregister(self, cancel_task: bool, /) -> None: ...
    def add_completed(self, handler: typing.Optional[BackgroundTaskCompletedEventHandler], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_completed(self, cookie: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_progress(self, handler: typing.Optional[BackgroundTaskProgressEventHandler], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_progress(self, cookie: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    @_property
    def trigger(self) -> typing.Optional[IBackgroundTrigger]: ...
    @_property
    def name(self) -> str: ...
    @_property
    def task_id(self) -> _uuid.UUID: ...

@typing.final
class IBackgroundTaskRegistration3(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> IBackgroundTaskRegistration3: ...
    def unregister(self, cancel_task: bool, /) -> None: ...
    def add_completed(self, handler: typing.Optional[BackgroundTaskCompletedEventHandler], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_completed(self, cookie: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_progress(self, handler: typing.Optional[BackgroundTaskProgressEventHandler], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_progress(self, cookie: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    @_property
    def task_group(self) -> typing.Optional[BackgroundTaskRegistrationGroup]: ...
    @_property
    def name(self) -> str: ...
    @_property
    def task_id(self) -> _uuid.UUID: ...

@typing.final
class IBackgroundTrigger(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> IBackgroundTrigger: ...

