# WARNING: Please don't edit this file. It was generated by Python/WinRT v2.1.0

import datetime
import sys
import types
import typing
import uuid as _uuid
from builtins import property as _property

import winrt._winrt
import winrt.system
import winrt.windows.applicationmodel.activation as windows_applicationmodel_activation
import winrt.windows.applicationmodel.calls.background as windows_applicationmodel_calls_background
import winrt.windows.devices.bluetooth as windows_devices_bluetooth
import winrt.windows.devices.bluetooth.advertisement as windows_devices_bluetooth_advertisement
import winrt.windows.devices.bluetooth.background as windows_devices_bluetooth_background
import winrt.windows.devices.bluetooth.genericattributeprofile as windows_devices_bluetooth_genericattributeprofile
import winrt.windows.devices.geolocation as windows_devices_geolocation
import winrt.windows.devices.sensors as windows_devices_sensors
import winrt.windows.devices.smartcards as windows_devices_smartcards
import winrt.windows.devices.sms as windows_devices_sms
import winrt.windows.foundation as windows_foundation
import winrt.windows.foundation.collections as windows_foundation_collections
import winrt.windows.networking as windows_networking
import winrt.windows.networking.sockets as windows_networking_sockets
import winrt.windows.storage as windows_storage
import winrt.windows.storage.provider as windows_storage_provider
import winrt.windows.system as windows_system
import winrt.windows.ui.notifications as windows_ui_notifications

from winrt.windows.applicationmodel.background import AlarmAccessStatus, ApplicationTriggerResult, BackgroundAccessRequestKind, BackgroundAccessStatus, BackgroundTaskCancellationReason, BackgroundTaskThrottleCounter, BackgroundWorkCostValue, CustomSystemEventTriggerRecurrence, DeviceTriggerResult, LocationTriggerType, MediaProcessingTriggerResult, SystemConditionType, SystemTriggerType
from winrt.windows.applicationmodel.background import BackgroundTaskCanceledEventHandler, BackgroundTaskCompletedEventHandler, BackgroundTaskProgressEventHandler

Self = typing.TypeVar('Self')

@typing.final
class ActivitySensorTrigger(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ActivitySensorTrigger: ...
    def __new__(cls: typing.Type[ActivitySensorTrigger], report_interval_in_milliseconds: winrt.system.UInt32) -> ActivitySensorTrigger: ...
    @_property
    def minimum_report_interval(self) -> winrt.system.UInt32: ...
    @_property
    def report_interval(self) -> winrt.system.UInt32: ...
    @_property
    def subscribed_activities(self) -> typing.Optional[windows_foundation_collections.IVector[windows_devices_sensors.ActivityType]]: ...
    @_property
    def supported_activities(self) -> typing.Optional[windows_foundation_collections.IVectorView[windows_devices_sensors.ActivityType]]: ...

@typing.final
class AlarmApplicationManager_Static(type):
    def get_access_status(cls) -> AlarmAccessStatus: ...
    def request_access_async(cls) -> windows_foundation.IAsyncOperation[AlarmAccessStatus]: ...

@typing.final
class AlarmApplicationManager(winrt.system.Object, metaclass=AlarmApplicationManager_Static):
    pass

@typing.final
class AppBroadcastTrigger(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> AppBroadcastTrigger: ...
    def __new__(cls: typing.Type[AppBroadcastTrigger], provider_key: str) -> AppBroadcastTrigger: ...
    @_property
    def provider_info(self) -> typing.Optional[AppBroadcastTriggerProviderInfo]: ...
    @provider_info.setter
    def provider_info(self, value: typing.Optional[AppBroadcastTriggerProviderInfo]) -> None: ...

@typing.final
class AppBroadcastTriggerProviderInfo(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> AppBroadcastTriggerProviderInfo: ...
    @_property
    def video_key_frame_interval(self) -> datetime.timedelta: ...
    @video_key_frame_interval.setter
    def video_key_frame_interval(self, value: datetime.timedelta) -> None: ...
    @_property
    def max_video_width(self) -> winrt.system.UInt32: ...
    @max_video_width.setter
    def max_video_width(self, value: winrt.system.UInt32) -> None: ...
    @_property
    def max_video_height(self) -> winrt.system.UInt32: ...
    @max_video_height.setter
    def max_video_height(self, value: winrt.system.UInt32) -> None: ...
    @_property
    def max_video_bitrate(self) -> winrt.system.UInt32: ...
    @max_video_bitrate.setter
    def max_video_bitrate(self, value: winrt.system.UInt32) -> None: ...
    @_property
    def logo_resource(self) -> str: ...
    @logo_resource.setter
    def logo_resource(self, value: str) -> None: ...
    @_property
    def display_name_resource(self) -> str: ...
    @display_name_resource.setter
    def display_name_resource(self, value: str) -> None: ...

@typing.final
class ApplicationTrigger(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ApplicationTrigger: ...
    def __new__(cls: typing.Type[ApplicationTrigger]) -> ApplicationTrigger: ...
    @typing.overload
    def request_async(self) -> windows_foundation.IAsyncOperation[ApplicationTriggerResult]: ...
    @typing.overload
    def request_async(self, arguments: typing.Optional[windows_foundation_collections.ValueSet], /) -> windows_foundation.IAsyncOperation[ApplicationTriggerResult]: ...

@typing.final
class ApplicationTriggerDetails(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ApplicationTriggerDetails: ...
    @_property
    def arguments(self) -> typing.Optional[windows_foundation_collections.ValueSet]: ...

@typing.final
class AppointmentStoreNotificationTrigger(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> AppointmentStoreNotificationTrigger: ...
    def __new__(cls: typing.Type[AppointmentStoreNotificationTrigger]) -> AppointmentStoreNotificationTrigger: ...

@typing.final
class BackgroundExecutionManager_Static(type):
    @typing.overload
    def get_access_status(cls) -> BackgroundAccessStatus: ...
    @typing.overload
    def get_access_status(cls, application_id: str, /) -> BackgroundAccessStatus: ...
    @typing.overload
    def get_access_status_for_modern_standby(cls) -> BackgroundAccessStatus: ...
    @typing.overload
    def get_access_status_for_modern_standby(cls, application_id: str, /) -> BackgroundAccessStatus: ...
    @typing.overload
    def remove_access(cls) -> None: ...
    @typing.overload
    def remove_access(cls, application_id: str, /) -> None: ...
    @typing.overload
    def request_access_async(cls) -> windows_foundation.IAsyncOperation[BackgroundAccessStatus]: ...
    @typing.overload
    def request_access_async(cls, application_id: str, /) -> windows_foundation.IAsyncOperation[BackgroundAccessStatus]: ...
    def request_access_kind_async(cls, requested_access: BackgroundAccessRequestKind, reason: str, /) -> windows_foundation.IAsyncOperation[bool]: ...
    def request_access_kind_for_modern_standby_async(cls, requested_access: BackgroundAccessRequestKind, reason: str, /) -> windows_foundation.IAsyncOperation[bool]: ...

@typing.final
class BackgroundExecutionManager(winrt.system.Object, metaclass=BackgroundExecutionManager_Static):
    pass

@typing.final
class BackgroundTaskBuilder(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> BackgroundTaskBuilder: ...
    def __new__(cls: typing.Type[BackgroundTaskBuilder]) -> BackgroundTaskBuilder: ...
    def add_condition(self, condition: typing.Optional[IBackgroundCondition], /) -> None: ...
    def register(self) -> typing.Optional[BackgroundTaskRegistration]: ...
    def set_task_entry_point_clsid(self, task_entry_point: _uuid.UUID, /) -> None: ...
    def set_trigger(self, trigger: typing.Optional[IBackgroundTrigger], /) -> None: ...
    @_property
    def task_entry_point(self) -> str: ...
    @task_entry_point.setter
    def task_entry_point(self, value: str) -> None: ...
    @_property
    def name(self) -> str: ...
    @name.setter
    def name(self, value: str) -> None: ...
    @_property
    def cancel_on_condition_loss(self) -> bool: ...
    @cancel_on_condition_loss.setter
    def cancel_on_condition_loss(self, value: bool) -> None: ...
    @_property
    def is_network_requested(self) -> bool: ...
    @is_network_requested.setter
    def is_network_requested(self, value: bool) -> None: ...
    @_property
    def task_group(self) -> typing.Optional[BackgroundTaskRegistrationGroup]: ...
    @task_group.setter
    def task_group(self, value: typing.Optional[BackgroundTaskRegistrationGroup]) -> None: ...

@typing.final
class BackgroundTaskCompletedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> BackgroundTaskCompletedEventArgs: ...
    def check_result(self) -> None: ...
    @_property
    def instance_id(self) -> _uuid.UUID: ...

@typing.final
class BackgroundTaskDeferral(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> BackgroundTaskDeferral: ...
    def complete(self) -> None: ...

@typing.final
class BackgroundTaskProgressEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> BackgroundTaskProgressEventArgs: ...
    @_property
    def instance_id(self) -> _uuid.UUID: ...
    @_property
    def progress(self) -> winrt.system.UInt32: ...

@typing.final
class BackgroundTaskRegistration_Static(type):
    def get_task_group(cls, group_id: str, /) -> typing.Optional[BackgroundTaskRegistrationGroup]: ...
    @_property
    def all_tasks(cls) -> typing.Optional[windows_foundation_collections.IMapView[_uuid.UUID, IBackgroundTaskRegistration]]: ...
    @_property
    def all_task_groups(cls) -> typing.Optional[windows_foundation_collections.IMapView[str, BackgroundTaskRegistrationGroup]]: ...

@typing.final
class BackgroundTaskRegistration(winrt.system.Object, metaclass=BackgroundTaskRegistration_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> BackgroundTaskRegistration: ...
    def unregister(self, cancel_task: bool, /) -> None: ...
    def add_completed(self, handler: typing.Optional[BackgroundTaskCompletedEventHandler], /) -> windows_foundation.EventRegistrationToken: ...
    def remove_completed(self, cookie: windows_foundation.EventRegistrationToken, /) -> None: ...
    def add_progress(self, handler: typing.Optional[BackgroundTaskProgressEventHandler], /) -> windows_foundation.EventRegistrationToken: ...
    def remove_progress(self, cookie: windows_foundation.EventRegistrationToken, /) -> None: ...
    @_property
    def name(self) -> str: ...
    @_property
    def task_id(self) -> _uuid.UUID: ...
    @_property
    def trigger(self) -> typing.Optional[IBackgroundTrigger]: ...
    @_property
    def task_group(self) -> typing.Optional[BackgroundTaskRegistrationGroup]: ...

@typing.final
class BackgroundTaskRegistrationGroup(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> BackgroundTaskRegistrationGroup: ...
    @typing.overload
    def __new__(cls: typing.Type[BackgroundTaskRegistrationGroup], id: str) -> BackgroundTaskRegistrationGroup: ...
    @typing.overload
    def __new__(cls: typing.Type[BackgroundTaskRegistrationGroup], id: str, name: str) -> BackgroundTaskRegistrationGroup: ...
    def add_background_activated(self, handler: windows_foundation.TypedEventHandler[BackgroundTaskRegistrationGroup, windows_applicationmodel_activation.BackgroundActivatedEventArgs], /) -> windows_foundation.EventRegistrationToken: ...
    def remove_background_activated(self, token: windows_foundation.EventRegistrationToken, /) -> None: ...
    @_property
    def all_tasks(self) -> typing.Optional[windows_foundation_collections.IMapView[_uuid.UUID, BackgroundTaskRegistration]]: ...
    @_property
    def id(self) -> str: ...
    @_property
    def name(self) -> str: ...

@typing.final
class BackgroundWorkCost_Static(type):
    @_property
    def current_background_work_cost(cls) -> BackgroundWorkCostValue: ...

@typing.final
class BackgroundWorkCost(winrt.system.Object, metaclass=BackgroundWorkCost_Static):
    pass

@typing.final
class BluetoothLEAdvertisementPublisherTrigger(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> BluetoothLEAdvertisementPublisherTrigger: ...
    def __new__(cls: typing.Type[BluetoothLEAdvertisementPublisherTrigger]) -> BluetoothLEAdvertisementPublisherTrigger: ...
    @_property
    def advertisement(self) -> typing.Optional[windows_devices_bluetooth_advertisement.BluetoothLEAdvertisement]: ...
    @_property
    def use_extended_format(self) -> bool: ...
    @use_extended_format.setter
    def use_extended_format(self, value: bool) -> None: ...
    @_property
    def preferred_transmit_power_level_in_d_bm(self) -> typing.Optional[typing.Optional[winrt.system.Int16]]: ...
    @preferred_transmit_power_level_in_d_bm.setter
    def preferred_transmit_power_level_in_d_bm(self, value: typing.Optional[typing.Optional[winrt.system.Int16]]) -> None: ...
    @_property
    def is_anonymous(self) -> bool: ...
    @is_anonymous.setter
    def is_anonymous(self, value: bool) -> None: ...
    @_property
    def include_transmit_power_level(self) -> bool: ...
    @include_transmit_power_level.setter
    def include_transmit_power_level(self, value: bool) -> None: ...

@typing.final
class BluetoothLEAdvertisementWatcherTrigger(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> BluetoothLEAdvertisementWatcherTrigger: ...
    def __new__(cls: typing.Type[BluetoothLEAdvertisementWatcherTrigger]) -> BluetoothLEAdvertisementWatcherTrigger: ...
    @_property
    def signal_strength_filter(self) -> typing.Optional[windows_devices_bluetooth.BluetoothSignalStrengthFilter]: ...
    @signal_strength_filter.setter
    def signal_strength_filter(self, value: typing.Optional[windows_devices_bluetooth.BluetoothSignalStrengthFilter]) -> None: ...
    @_property
    def advertisement_filter(self) -> typing.Optional[windows_devices_bluetooth_advertisement.BluetoothLEAdvertisementFilter]: ...
    @advertisement_filter.setter
    def advertisement_filter(self, value: typing.Optional[windows_devices_bluetooth_advertisement.BluetoothLEAdvertisementFilter]) -> None: ...
    @_property
    def max_out_of_range_timeout(self) -> datetime.timedelta: ...
    @_property
    def max_sampling_interval(self) -> datetime.timedelta: ...
    @_property
    def min_out_of_range_timeout(self) -> datetime.timedelta: ...
    @_property
    def min_sampling_interval(self) -> datetime.timedelta: ...
    @_property
    def allow_extended_advertisements(self) -> bool: ...
    @allow_extended_advertisements.setter
    def allow_extended_advertisements(self, value: bool) -> None: ...

@typing.final
class CachedFileUpdaterTrigger(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> CachedFileUpdaterTrigger: ...
    def __new__(cls: typing.Type[CachedFileUpdaterTrigger]) -> CachedFileUpdaterTrigger: ...

@typing.final
class CachedFileUpdaterTriggerDetails(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> CachedFileUpdaterTriggerDetails: ...
    @_property
    def can_request_user_input(self) -> bool: ...
    @_property
    def update_request(self) -> typing.Optional[windows_storage_provider.FileUpdateRequest]: ...
    @_property
    def update_target(self) -> windows_storage_provider.CachedFileTarget: ...

@typing.final
class ChatMessageNotificationTrigger(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ChatMessageNotificationTrigger: ...
    def __new__(cls: typing.Type[ChatMessageNotificationTrigger]) -> ChatMessageNotificationTrigger: ...

@typing.final
class ChatMessageReceivedNotificationTrigger(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ChatMessageReceivedNotificationTrigger: ...
    def __new__(cls: typing.Type[ChatMessageReceivedNotificationTrigger]) -> ChatMessageReceivedNotificationTrigger: ...

@typing.final
class CommunicationBlockingAppSetAsActiveTrigger(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> CommunicationBlockingAppSetAsActiveTrigger: ...
    def __new__(cls: typing.Type[CommunicationBlockingAppSetAsActiveTrigger]) -> CommunicationBlockingAppSetAsActiveTrigger: ...

@typing.final
class ContactStoreNotificationTrigger(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ContactStoreNotificationTrigger: ...
    def __new__(cls: typing.Type[ContactStoreNotificationTrigger]) -> ContactStoreNotificationTrigger: ...

@typing.final
class ContentPrefetchTrigger(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ContentPrefetchTrigger: ...
    @typing.overload
    def __new__(cls: typing.Type[ContentPrefetchTrigger], wait_interval: datetime.timedelta) -> ContentPrefetchTrigger: ...
    @typing.overload
    def __new__(cls: typing.Type[ContentPrefetchTrigger]) -> ContentPrefetchTrigger: ...
    @_property
    def wait_interval(self) -> datetime.timedelta: ...

@typing.final
class ConversationalAgentTrigger(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ConversationalAgentTrigger: ...
    def __new__(cls: typing.Type[ConversationalAgentTrigger]) -> ConversationalAgentTrigger: ...

@typing.final
class CustomSystemEventTrigger(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> CustomSystemEventTrigger: ...
    def __new__(cls: typing.Type[CustomSystemEventTrigger], trigger_id: str, recurrence: CustomSystemEventTriggerRecurrence) -> CustomSystemEventTrigger: ...
    @_property
    def recurrence(self) -> CustomSystemEventTriggerRecurrence: ...
    @_property
    def trigger_id(self) -> str: ...

@typing.final
class DeviceConnectionChangeTrigger_Static(type):
    def from_id_async(cls, device_id: str, /) -> windows_foundation.IAsyncOperation[DeviceConnectionChangeTrigger]: ...

@typing.final
class DeviceConnectionChangeTrigger(winrt.system.Object, metaclass=DeviceConnectionChangeTrigger_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> DeviceConnectionChangeTrigger: ...
    @_property
    def maintain_connection(self) -> bool: ...
    @maintain_connection.setter
    def maintain_connection(self, value: bool) -> None: ...
    @_property
    def can_maintain_connection(self) -> bool: ...
    @_property
    def device_id(self) -> str: ...

@typing.final
class DeviceManufacturerNotificationTrigger(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> DeviceManufacturerNotificationTrigger: ...
    def __new__(cls: typing.Type[DeviceManufacturerNotificationTrigger], trigger_qualifier: str, one_shot: bool) -> DeviceManufacturerNotificationTrigger: ...
    @_property
    def one_shot(self) -> bool: ...
    @_property
    def trigger_qualifier(self) -> str: ...

@typing.final
class DeviceServicingTrigger(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> DeviceServicingTrigger: ...
    def __new__(cls: typing.Type[DeviceServicingTrigger]) -> DeviceServicingTrigger: ...
    @typing.overload
    def request_async(self, device_id: str, expected_duration: datetime.timedelta, /) -> windows_foundation.IAsyncOperation[DeviceTriggerResult]: ...
    @typing.overload
    def request_async(self, device_id: str, expected_duration: datetime.timedelta, arguments: str, /) -> windows_foundation.IAsyncOperation[DeviceTriggerResult]: ...

@typing.final
class DeviceUseTrigger(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> DeviceUseTrigger: ...
    def __new__(cls: typing.Type[DeviceUseTrigger]) -> DeviceUseTrigger: ...
    @typing.overload
    def request_async(self, device_id: str, /) -> windows_foundation.IAsyncOperation[DeviceTriggerResult]: ...
    @typing.overload
    def request_async(self, device_id: str, arguments: str, /) -> windows_foundation.IAsyncOperation[DeviceTriggerResult]: ...

@typing.final
class DeviceWatcherTrigger(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> DeviceWatcherTrigger: ...

@typing.final
class EmailStoreNotificationTrigger(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> EmailStoreNotificationTrigger: ...
    def __new__(cls: typing.Type[EmailStoreNotificationTrigger]) -> EmailStoreNotificationTrigger: ...

@typing.final
class GattCharacteristicNotificationTrigger(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> GattCharacteristicNotificationTrigger: ...
    @typing.overload
    def __new__(cls: typing.Type[GattCharacteristicNotificationTrigger], characteristic: typing.Optional[windows_devices_bluetooth_genericattributeprofile.GattCharacteristic], event_triggering_mode: windows_devices_bluetooth_background.BluetoothEventTriggeringMode) -> GattCharacteristicNotificationTrigger: ...
    @typing.overload
    def __new__(cls: typing.Type[GattCharacteristicNotificationTrigger], characteristic: typing.Optional[windows_devices_bluetooth_genericattributeprofile.GattCharacteristic]) -> GattCharacteristicNotificationTrigger: ...
    @_property
    def characteristic(self) -> typing.Optional[windows_devices_bluetooth_genericattributeprofile.GattCharacteristic]: ...
    @_property
    def event_triggering_mode(self) -> windows_devices_bluetooth_background.BluetoothEventTriggeringMode: ...

@typing.final
class GattServiceProviderTrigger_Static(type):
    def create_async(cls, trigger_id: str, service_uuid: _uuid.UUID, /) -> windows_foundation.IAsyncOperation[GattServiceProviderTriggerResult]: ...

@typing.final
class GattServiceProviderTrigger(winrt.system.Object, metaclass=GattServiceProviderTrigger_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> GattServiceProviderTrigger: ...
    @_property
    def advertising_parameters(self) -> typing.Optional[windows_devices_bluetooth_genericattributeprofile.GattServiceProviderAdvertisingParameters]: ...
    @advertising_parameters.setter
    def advertising_parameters(self, value: typing.Optional[windows_devices_bluetooth_genericattributeprofile.GattServiceProviderAdvertisingParameters]) -> None: ...
    @_property
    def service(self) -> typing.Optional[windows_devices_bluetooth_genericattributeprofile.GattLocalService]: ...
    @_property
    def trigger_id(self) -> str: ...

@typing.final
class GattServiceProviderTriggerResult(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> GattServiceProviderTriggerResult: ...
    @_property
    def error(self) -> windows_devices_bluetooth.BluetoothError: ...
    @_property
    def trigger(self) -> typing.Optional[GattServiceProviderTrigger]: ...

@typing.final
class GeovisitTrigger(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> GeovisitTrigger: ...
    def __new__(cls: typing.Type[GeovisitTrigger]) -> GeovisitTrigger: ...
    @_property
    def monitoring_scope(self) -> windows_devices_geolocation.VisitMonitoringScope: ...
    @monitoring_scope.setter
    def monitoring_scope(self, value: windows_devices_geolocation.VisitMonitoringScope) -> None: ...

@typing.final
class LocationTrigger(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> LocationTrigger: ...
    def __new__(cls: typing.Type[LocationTrigger], trigger_type: LocationTriggerType) -> LocationTrigger: ...
    @_property
    def trigger_type(self) -> LocationTriggerType: ...

@typing.final
class MaintenanceTrigger(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MaintenanceTrigger: ...
    def __new__(cls: typing.Type[MaintenanceTrigger], freshness_time: winrt.system.UInt32, one_shot: bool) -> MaintenanceTrigger: ...
    @_property
    def freshness_time(self) -> winrt.system.UInt32: ...
    @_property
    def one_shot(self) -> bool: ...

@typing.final
class MediaProcessingTrigger(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MediaProcessingTrigger: ...
    def __new__(cls: typing.Type[MediaProcessingTrigger]) -> MediaProcessingTrigger: ...
    @typing.overload
    def request_async(self) -> windows_foundation.IAsyncOperation[MediaProcessingTriggerResult]: ...
    @typing.overload
    def request_async(self, arguments: typing.Optional[windows_foundation_collections.ValueSet], /) -> windows_foundation.IAsyncOperation[MediaProcessingTriggerResult]: ...

@typing.final
class MobileBroadbandDeviceServiceNotificationTrigger(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MobileBroadbandDeviceServiceNotificationTrigger: ...
    def __new__(cls: typing.Type[MobileBroadbandDeviceServiceNotificationTrigger]) -> MobileBroadbandDeviceServiceNotificationTrigger: ...

@typing.final
class MobileBroadbandPcoDataChangeTrigger(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MobileBroadbandPcoDataChangeTrigger: ...
    def __new__(cls: typing.Type[MobileBroadbandPcoDataChangeTrigger]) -> MobileBroadbandPcoDataChangeTrigger: ...

@typing.final
class MobileBroadbandPinLockStateChangeTrigger(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MobileBroadbandPinLockStateChangeTrigger: ...
    def __new__(cls: typing.Type[MobileBroadbandPinLockStateChangeTrigger]) -> MobileBroadbandPinLockStateChangeTrigger: ...

@typing.final
class MobileBroadbandRadioStateChangeTrigger(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MobileBroadbandRadioStateChangeTrigger: ...
    def __new__(cls: typing.Type[MobileBroadbandRadioStateChangeTrigger]) -> MobileBroadbandRadioStateChangeTrigger: ...

@typing.final
class MobileBroadbandRegistrationStateChangeTrigger(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MobileBroadbandRegistrationStateChangeTrigger: ...
    def __new__(cls: typing.Type[MobileBroadbandRegistrationStateChangeTrigger]) -> MobileBroadbandRegistrationStateChangeTrigger: ...

@typing.final
class NetworkOperatorDataUsageTrigger(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> NetworkOperatorDataUsageTrigger: ...
    def __new__(cls: typing.Type[NetworkOperatorDataUsageTrigger]) -> NetworkOperatorDataUsageTrigger: ...

@typing.final
class NetworkOperatorHotspotAuthenticationTrigger(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> NetworkOperatorHotspotAuthenticationTrigger: ...
    def __new__(cls: typing.Type[NetworkOperatorHotspotAuthenticationTrigger]) -> NetworkOperatorHotspotAuthenticationTrigger: ...

@typing.final
class NetworkOperatorNotificationTrigger(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> NetworkOperatorNotificationTrigger: ...
    def __new__(cls: typing.Type[NetworkOperatorNotificationTrigger], network_account_id: str) -> NetworkOperatorNotificationTrigger: ...
    @_property
    def network_account_id(self) -> str: ...

@typing.final
class PaymentAppCanMakePaymentTrigger(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> PaymentAppCanMakePaymentTrigger: ...
    def __new__(cls: typing.Type[PaymentAppCanMakePaymentTrigger]) -> PaymentAppCanMakePaymentTrigger: ...

@typing.final
class PhoneTrigger(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> PhoneTrigger: ...
    def __new__(cls: typing.Type[PhoneTrigger], type: windows_applicationmodel_calls_background.PhoneTriggerType, one_shot: bool) -> PhoneTrigger: ...
    @_property
    def one_shot(self) -> bool: ...
    @_property
    def trigger_type(self) -> windows_applicationmodel_calls_background.PhoneTriggerType: ...

@typing.final
class PushNotificationTrigger(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> PushNotificationTrigger: ...
    @typing.overload
    def __new__(cls: typing.Type[PushNotificationTrigger], application_id: str) -> PushNotificationTrigger: ...
    @typing.overload
    def __new__(cls: typing.Type[PushNotificationTrigger]) -> PushNotificationTrigger: ...

@typing.final
class RcsEndUserMessageAvailableTrigger(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> RcsEndUserMessageAvailableTrigger: ...
    def __new__(cls: typing.Type[RcsEndUserMessageAvailableTrigger]) -> RcsEndUserMessageAvailableTrigger: ...

@typing.final
class RfcommConnectionTrigger(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> RfcommConnectionTrigger: ...
    def __new__(cls: typing.Type[RfcommConnectionTrigger]) -> RfcommConnectionTrigger: ...
    @_property
    def remote_host_name(self) -> typing.Optional[windows_networking.HostName]: ...
    @remote_host_name.setter
    def remote_host_name(self, value: typing.Optional[windows_networking.HostName]) -> None: ...
    @_property
    def protection_level(self) -> windows_networking_sockets.SocketProtectionLevel: ...
    @protection_level.setter
    def protection_level(self, value: windows_networking_sockets.SocketProtectionLevel) -> None: ...
    @_property
    def allow_multiple_connections(self) -> bool: ...
    @allow_multiple_connections.setter
    def allow_multiple_connections(self, value: bool) -> None: ...
    @_property
    def inbound_connection(self) -> typing.Optional[windows_devices_bluetooth_background.RfcommInboundConnectionInformation]: ...
    @_property
    def outbound_connection(self) -> typing.Optional[windows_devices_bluetooth_background.RfcommOutboundConnectionInformation]: ...

@typing.final
class SecondaryAuthenticationFactorAuthenticationTrigger(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> SecondaryAuthenticationFactorAuthenticationTrigger: ...
    def __new__(cls: typing.Type[SecondaryAuthenticationFactorAuthenticationTrigger]) -> SecondaryAuthenticationFactorAuthenticationTrigger: ...

@typing.final
class SensorDataThresholdTrigger(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> SensorDataThresholdTrigger: ...
    def __new__(cls: typing.Type[SensorDataThresholdTrigger], threshold: typing.Optional[windows_devices_sensors.ISensorDataThreshold]) -> SensorDataThresholdTrigger: ...

@typing.final
class SmartCardTrigger(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> SmartCardTrigger: ...
    def __new__(cls: typing.Type[SmartCardTrigger], trigger_type: windows_devices_smartcards.SmartCardTriggerType) -> SmartCardTrigger: ...
    @_property
    def trigger_type(self) -> windows_devices_smartcards.SmartCardTriggerType: ...

@typing.final
class SmsMessageReceivedTrigger(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> SmsMessageReceivedTrigger: ...
    def __new__(cls: typing.Type[SmsMessageReceivedTrigger], filter_rules: typing.Optional[windows_devices_sms.SmsFilterRules]) -> SmsMessageReceivedTrigger: ...

@typing.final
class SocketActivityTrigger(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> SocketActivityTrigger: ...
    def __new__(cls: typing.Type[SocketActivityTrigger]) -> SocketActivityTrigger: ...
    @_property
    def is_wake_from_low_power_supported(self) -> bool: ...

@typing.final
class StorageLibraryChangeTrackerTrigger(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> StorageLibraryChangeTrackerTrigger: ...
    def __new__(cls: typing.Type[StorageLibraryChangeTrackerTrigger], tracker: typing.Optional[windows_storage.StorageLibraryChangeTracker]) -> StorageLibraryChangeTrackerTrigger: ...

@typing.final
class StorageLibraryContentChangedTrigger_Static(type):
    def create(cls, storage_library: typing.Optional[windows_storage.StorageLibrary], /) -> typing.Optional[StorageLibraryContentChangedTrigger]: ...
    def create_from_libraries(cls, storage_libraries: typing.Iterable[windows_storage.StorageLibrary], /) -> typing.Optional[StorageLibraryContentChangedTrigger]: ...

@typing.final
class StorageLibraryContentChangedTrigger(winrt.system.Object, metaclass=StorageLibraryContentChangedTrigger_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> StorageLibraryContentChangedTrigger: ...

@typing.final
class SystemCondition(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> SystemCondition: ...
    def __new__(cls: typing.Type[SystemCondition], condition_type: SystemConditionType) -> SystemCondition: ...
    @_property
    def condition_type(self) -> SystemConditionType: ...

@typing.final
class SystemTrigger(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> SystemTrigger: ...
    def __new__(cls: typing.Type[SystemTrigger], trigger_type: SystemTriggerType, one_shot: bool) -> SystemTrigger: ...
    @_property
    def one_shot(self) -> bool: ...
    @_property
    def trigger_type(self) -> SystemTriggerType: ...

@typing.final
class TetheringEntitlementCheckTrigger(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> TetheringEntitlementCheckTrigger: ...
    def __new__(cls: typing.Type[TetheringEntitlementCheckTrigger]) -> TetheringEntitlementCheckTrigger: ...

@typing.final
class TimeTrigger(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> TimeTrigger: ...
    def __new__(cls: typing.Type[TimeTrigger], freshness_time: winrt.system.UInt32, one_shot: bool) -> TimeTrigger: ...
    @_property
    def freshness_time(self) -> winrt.system.UInt32: ...
    @_property
    def one_shot(self) -> bool: ...

@typing.final
class ToastNotificationActionTrigger(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ToastNotificationActionTrigger: ...
    @typing.overload
    def __new__(cls: typing.Type[ToastNotificationActionTrigger], application_id: str) -> ToastNotificationActionTrigger: ...
    @typing.overload
    def __new__(cls: typing.Type[ToastNotificationActionTrigger]) -> ToastNotificationActionTrigger: ...

@typing.final
class ToastNotificationHistoryChangedTrigger(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ToastNotificationHistoryChangedTrigger: ...
    @typing.overload
    def __new__(cls: typing.Type[ToastNotificationHistoryChangedTrigger], application_id: str) -> ToastNotificationHistoryChangedTrigger: ...
    @typing.overload
    def __new__(cls: typing.Type[ToastNotificationHistoryChangedTrigger]) -> ToastNotificationHistoryChangedTrigger: ...

@typing.final
class UserNotificationChangedTrigger(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> UserNotificationChangedTrigger: ...
    def __new__(cls: typing.Type[UserNotificationChangedTrigger], notification_kinds: windows_ui_notifications.NotificationKinds) -> UserNotificationChangedTrigger: ...

@typing.final
class WiFiOnDemandHotspotConnectTrigger(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> WiFiOnDemandHotspotConnectTrigger: ...
    def __new__(cls: typing.Type[WiFiOnDemandHotspotConnectTrigger]) -> WiFiOnDemandHotspotConnectTrigger: ...

@typing.final
class WiFiOnDemandHotspotUpdateMetadataTrigger(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> WiFiOnDemandHotspotUpdateMetadataTrigger: ...
    def __new__(cls: typing.Type[WiFiOnDemandHotspotUpdateMetadataTrigger]) -> WiFiOnDemandHotspotUpdateMetadataTrigger: ...

@typing.final
class IBackgroundCondition(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> IBackgroundCondition: ...

@typing.final
class IBackgroundTask(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> IBackgroundTask: ...
    def run(self, task_instance: typing.Optional[IBackgroundTaskInstance], /) -> None: ...

@typing.final
class IBackgroundTaskInstance(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> IBackgroundTaskInstance: ...
    def get_deferral(self) -> typing.Optional[BackgroundTaskDeferral]: ...
    def add_canceled(self, cancel_handler: typing.Optional[BackgroundTaskCanceledEventHandler], /) -> windows_foundation.EventRegistrationToken: ...
    def remove_canceled(self, cookie: windows_foundation.EventRegistrationToken, /) -> None: ...
    @_property
    def instance_id(self) -> _uuid.UUID: ...
    @_property
    def progress(self) -> winrt.system.UInt32: ...
    @progress.setter
    def progress(self, value: winrt.system.UInt32) -> None: ...
    @_property
    def suspended_count(self) -> winrt.system.UInt32: ...
    @_property
    def task(self) -> typing.Optional[BackgroundTaskRegistration]: ...
    @_property
    def trigger_details(self) -> typing.Optional[winrt.system.Object]: ...

@typing.final
class IBackgroundTaskInstance2(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> IBackgroundTaskInstance2: ...
    def get_deferral(self) -> typing.Optional[BackgroundTaskDeferral]: ...
    def get_throttle_count(self, counter: BackgroundTaskThrottleCounter, /) -> winrt.system.UInt32: ...
    def add_canceled(self, cancel_handler: typing.Optional[BackgroundTaskCanceledEventHandler], /) -> windows_foundation.EventRegistrationToken: ...
    def remove_canceled(self, cookie: windows_foundation.EventRegistrationToken, /) -> None: ...
    @_property
    def instance_id(self) -> _uuid.UUID: ...
    @_property
    def progress(self) -> winrt.system.UInt32: ...
    @progress.setter
    def progress(self, value: winrt.system.UInt32) -> None: ...
    @_property
    def suspended_count(self) -> winrt.system.UInt32: ...
    @_property
    def task(self) -> typing.Optional[BackgroundTaskRegistration]: ...
    @_property
    def trigger_details(self) -> typing.Optional[winrt.system.Object]: ...

@typing.final
class IBackgroundTaskInstance4(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> IBackgroundTaskInstance4: ...
    def get_deferral(self) -> typing.Optional[BackgroundTaskDeferral]: ...
    def add_canceled(self, cancel_handler: typing.Optional[BackgroundTaskCanceledEventHandler], /) -> windows_foundation.EventRegistrationToken: ...
    def remove_canceled(self, cookie: windows_foundation.EventRegistrationToken, /) -> None: ...
    @_property
    def user(self) -> typing.Optional[windows_system.User]: ...
    @_property
    def instance_id(self) -> _uuid.UUID: ...
    @_property
    def progress(self) -> winrt.system.UInt32: ...
    @progress.setter
    def progress(self, value: winrt.system.UInt32) -> None: ...
    @_property
    def suspended_count(self) -> winrt.system.UInt32: ...
    @_property
    def task(self) -> typing.Optional[BackgroundTaskRegistration]: ...
    @_property
    def trigger_details(self) -> typing.Optional[winrt.system.Object]: ...

@typing.final
class IBackgroundTaskRegistration(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> IBackgroundTaskRegistration: ...
    def unregister(self, cancel_task: bool, /) -> None: ...
    def add_completed(self, handler: typing.Optional[BackgroundTaskCompletedEventHandler], /) -> windows_foundation.EventRegistrationToken: ...
    def remove_completed(self, cookie: windows_foundation.EventRegistrationToken, /) -> None: ...
    def add_progress(self, handler: typing.Optional[BackgroundTaskProgressEventHandler], /) -> windows_foundation.EventRegistrationToken: ...
    def remove_progress(self, cookie: windows_foundation.EventRegistrationToken, /) -> None: ...
    @_property
    def name(self) -> str: ...
    @_property
    def task_id(self) -> _uuid.UUID: ...

@typing.final
class IBackgroundTaskRegistration2(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> IBackgroundTaskRegistration2: ...
    def unregister(self, cancel_task: bool, /) -> None: ...
    def add_completed(self, handler: typing.Optional[BackgroundTaskCompletedEventHandler], /) -> windows_foundation.EventRegistrationToken: ...
    def remove_completed(self, cookie: windows_foundation.EventRegistrationToken, /) -> None: ...
    def add_progress(self, handler: typing.Optional[BackgroundTaskProgressEventHandler], /) -> windows_foundation.EventRegistrationToken: ...
    def remove_progress(self, cookie: windows_foundation.EventRegistrationToken, /) -> None: ...
    @_property
    def trigger(self) -> typing.Optional[IBackgroundTrigger]: ...
    @_property
    def name(self) -> str: ...
    @_property
    def task_id(self) -> _uuid.UUID: ...

@typing.final
class IBackgroundTaskRegistration3(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> IBackgroundTaskRegistration3: ...
    def unregister(self, cancel_task: bool, /) -> None: ...
    def add_completed(self, handler: typing.Optional[BackgroundTaskCompletedEventHandler], /) -> windows_foundation.EventRegistrationToken: ...
    def remove_completed(self, cookie: windows_foundation.EventRegistrationToken, /) -> None: ...
    def add_progress(self, handler: typing.Optional[BackgroundTaskProgressEventHandler], /) -> windows_foundation.EventRegistrationToken: ...
    def remove_progress(self, cookie: windows_foundation.EventRegistrationToken, /) -> None: ...
    @_property
    def task_group(self) -> typing.Optional[BackgroundTaskRegistrationGroup]: ...
    @_property
    def name(self) -> str: ...
    @_property
    def task_id(self) -> _uuid.UUID: ...

@typing.final
class IBackgroundTrigger(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> IBackgroundTrigger: ...

