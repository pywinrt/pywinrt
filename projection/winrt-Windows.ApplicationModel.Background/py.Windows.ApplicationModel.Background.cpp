// WARNING: Please don't edit this file. It was generated by Python/WinRT v2.0.1

#include "py.Windows.ApplicationModel.Background.h"


namespace py::cpp::Windows::ApplicationModel::Background
{
    // ----- ActivitySensorTrigger class --------------------

    static PyObject* _new_ActivitySensorTrigger(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);

                winrt::Windows::ApplicationModel::Background::ActivitySensorTrigger instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ActivitySensorTrigger(py::wrapper::Windows::ApplicationModel::Background::ActivitySensorTrigger* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ActivitySensorTrigger_get_MinimumReportInterval(py::wrapper::Windows::ApplicationModel::Background::ActivitySensorTrigger* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Background.ActivitySensorTrigger", L"MinimumReportInterval"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MinimumReportInterval());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ActivitySensorTrigger_get_ReportInterval(py::wrapper::Windows::ApplicationModel::Background::ActivitySensorTrigger* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Background.ActivitySensorTrigger", L"ReportInterval"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ReportInterval());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ActivitySensorTrigger_get_SubscribedActivities(py::wrapper::Windows::ApplicationModel::Background::ActivitySensorTrigger* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Background.ActivitySensorTrigger", L"SubscribedActivities"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SubscribedActivities());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ActivitySensorTrigger_get_SupportedActivities(py::wrapper::Windows::ApplicationModel::Background::ActivitySensorTrigger* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Background.ActivitySensorTrigger", L"SupportedActivities"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SupportedActivities());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ActivitySensorTrigger(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Background::ActivitySensorTrigger>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ActivitySensorTrigger(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Background::ActivitySensorTrigger>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ActivitySensorTrigger[] = {
        { "_assign_array_", _assign_array_ActivitySensorTrigger, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ActivitySensorTrigger), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ActivitySensorTrigger[] = {
        { "minimum_report_interval", reinterpret_cast<getter>(ActivitySensorTrigger_get_MinimumReportInterval), nullptr, nullptr, nullptr },
        { "report_interval", reinterpret_cast<getter>(ActivitySensorTrigger_get_ReportInterval), nullptr, nullptr, nullptr },
        { "subscribed_activities", reinterpret_cast<getter>(ActivitySensorTrigger_get_SubscribedActivities), nullptr, nullptr, nullptr },
        { "supported_activities", reinterpret_cast<getter>(ActivitySensorTrigger_get_SupportedActivities), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ActivitySensorTrigger[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ActivitySensorTrigger) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ActivitySensorTrigger) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ActivitySensorTrigger) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ActivitySensorTrigger) },
        { },
    };

    static PyType_Spec type_spec_ActivitySensorTrigger =
    {
        "winrt._winrt_windows_applicationmodel_background.ActivitySensorTrigger",
        sizeof(py::wrapper::Windows::ApplicationModel::Background::ActivitySensorTrigger),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ActivitySensorTrigger
    };

    // ----- AlarmApplicationManager class --------------------

    static PyObject* _new_AlarmApplicationManager(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Background::AlarmApplicationManager>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Background::AlarmApplicationManager>::type_name);
        return nullptr;
    }

    static PyObject* AlarmApplicationManager_GetAccessStatus(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Background.AlarmApplicationManager", L"GetAccessStatus", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(winrt::Windows::ApplicationModel::Background::AlarmApplicationManager::GetAccessStatus());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AlarmApplicationManager_RequestAccessAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Background.AlarmApplicationManager", L"RequestAccessAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(winrt::Windows::ApplicationModel::Background::AlarmApplicationManager::RequestAccessAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyMethodDef _methods_AlarmApplicationManager[] = {
        { }
    };

    static PyGetSetDef _getset_AlarmApplicationManager[] = {
        { }
    };

    static PyType_Slot _type_slots_AlarmApplicationManager[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_AlarmApplicationManager) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AlarmApplicationManager) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AlarmApplicationManager) },
        { },
    };

    static PyType_Spec type_spec_AlarmApplicationManager =
    {
        "winrt._winrt_windows_applicationmodel_background.AlarmApplicationManager",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AlarmApplicationManager
    };

    static PyGetSetDef getset_AlarmApplicationManager_Static[] = {
        { }
    };

    static PyMethodDef methods_AlarmApplicationManager_Static[] = {
        { "get_access_status", reinterpret_cast<PyCFunction>(AlarmApplicationManager_GetAccessStatus), METH_VARARGS, nullptr },
        { "request_access_async", reinterpret_cast<PyCFunction>(AlarmApplicationManager_RequestAccessAsync), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_AlarmApplicationManager_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_AlarmApplicationManager_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_AlarmApplicationManager_Static) },
        { }
    };

    static PyType_Spec type_spec_AlarmApplicationManager_Static =
    {
        "winrt._winrt_windows_applicationmodel_background.AlarmApplicationManager_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_AlarmApplicationManager_Static
    };

    // ----- AppBroadcastTrigger class --------------------

    static PyObject* _new_AppBroadcastTrigger(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                winrt::Windows::ApplicationModel::Background::AppBroadcastTrigger instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_AppBroadcastTrigger(py::wrapper::Windows::ApplicationModel::Background::AppBroadcastTrigger* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AppBroadcastTrigger_get_ProviderInfo(py::wrapper::Windows::ApplicationModel::Background::AppBroadcastTrigger* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Background.AppBroadcastTrigger", L"ProviderInfo"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ProviderInfo());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppBroadcastTrigger_put_ProviderInfo(py::wrapper::Windows::ApplicationModel::Background::AppBroadcastTrigger* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Background.AppBroadcastTrigger", L"ProviderInfo"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Background::AppBroadcastTriggerProviderInfo>(arg);

            self->obj.ProviderInfo(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_AppBroadcastTrigger(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Background::AppBroadcastTrigger>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AppBroadcastTrigger(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Background::AppBroadcastTrigger>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AppBroadcastTrigger[] = {
        { "_assign_array_", _assign_array_AppBroadcastTrigger, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AppBroadcastTrigger), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AppBroadcastTrigger[] = {
        { "provider_info", reinterpret_cast<getter>(AppBroadcastTrigger_get_ProviderInfo), reinterpret_cast<setter>(AppBroadcastTrigger_put_ProviderInfo), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AppBroadcastTrigger[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_AppBroadcastTrigger) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AppBroadcastTrigger) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AppBroadcastTrigger) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AppBroadcastTrigger) },
        { },
    };

    static PyType_Spec type_spec_AppBroadcastTrigger =
    {
        "winrt._winrt_windows_applicationmodel_background.AppBroadcastTrigger",
        sizeof(py::wrapper::Windows::ApplicationModel::Background::AppBroadcastTrigger),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AppBroadcastTrigger
    };

    // ----- AppBroadcastTriggerProviderInfo class --------------------

    static PyObject* _new_AppBroadcastTriggerProviderInfo(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Background::AppBroadcastTriggerProviderInfo>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Background::AppBroadcastTriggerProviderInfo>::type_name);
        return nullptr;
    }

    static void _dealloc_AppBroadcastTriggerProviderInfo(py::wrapper::Windows::ApplicationModel::Background::AppBroadcastTriggerProviderInfo* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AppBroadcastTriggerProviderInfo_get_VideoKeyFrameInterval(py::wrapper::Windows::ApplicationModel::Background::AppBroadcastTriggerProviderInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Background.AppBroadcastTriggerProviderInfo", L"VideoKeyFrameInterval"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.VideoKeyFrameInterval());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppBroadcastTriggerProviderInfo_put_VideoKeyFrameInterval(py::wrapper::Windows::ApplicationModel::Background::AppBroadcastTriggerProviderInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Background.AppBroadcastTriggerProviderInfo", L"VideoKeyFrameInterval"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(arg);

            self->obj.VideoKeyFrameInterval(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppBroadcastTriggerProviderInfo_get_MaxVideoWidth(py::wrapper::Windows::ApplicationModel::Background::AppBroadcastTriggerProviderInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Background.AppBroadcastTriggerProviderInfo", L"MaxVideoWidth"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MaxVideoWidth());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppBroadcastTriggerProviderInfo_put_MaxVideoWidth(py::wrapper::Windows::ApplicationModel::Background::AppBroadcastTriggerProviderInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Background.AppBroadcastTriggerProviderInfo", L"MaxVideoWidth"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.MaxVideoWidth(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppBroadcastTriggerProviderInfo_get_MaxVideoHeight(py::wrapper::Windows::ApplicationModel::Background::AppBroadcastTriggerProviderInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Background.AppBroadcastTriggerProviderInfo", L"MaxVideoHeight"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MaxVideoHeight());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppBroadcastTriggerProviderInfo_put_MaxVideoHeight(py::wrapper::Windows::ApplicationModel::Background::AppBroadcastTriggerProviderInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Background.AppBroadcastTriggerProviderInfo", L"MaxVideoHeight"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.MaxVideoHeight(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppBroadcastTriggerProviderInfo_get_MaxVideoBitrate(py::wrapper::Windows::ApplicationModel::Background::AppBroadcastTriggerProviderInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Background.AppBroadcastTriggerProviderInfo", L"MaxVideoBitrate"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MaxVideoBitrate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppBroadcastTriggerProviderInfo_put_MaxVideoBitrate(py::wrapper::Windows::ApplicationModel::Background::AppBroadcastTriggerProviderInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Background.AppBroadcastTriggerProviderInfo", L"MaxVideoBitrate"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.MaxVideoBitrate(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppBroadcastTriggerProviderInfo_get_LogoResource(py::wrapper::Windows::ApplicationModel::Background::AppBroadcastTriggerProviderInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Background.AppBroadcastTriggerProviderInfo", L"LogoResource"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.LogoResource());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppBroadcastTriggerProviderInfo_put_LogoResource(py::wrapper::Windows::ApplicationModel::Background::AppBroadcastTriggerProviderInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Background.AppBroadcastTriggerProviderInfo", L"LogoResource"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.LogoResource(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppBroadcastTriggerProviderInfo_get_DisplayNameResource(py::wrapper::Windows::ApplicationModel::Background::AppBroadcastTriggerProviderInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Background.AppBroadcastTriggerProviderInfo", L"DisplayNameResource"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DisplayNameResource());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppBroadcastTriggerProviderInfo_put_DisplayNameResource(py::wrapper::Windows::ApplicationModel::Background::AppBroadcastTriggerProviderInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Background.AppBroadcastTriggerProviderInfo", L"DisplayNameResource"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.DisplayNameResource(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_AppBroadcastTriggerProviderInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Background::AppBroadcastTriggerProviderInfo>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AppBroadcastTriggerProviderInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Background::AppBroadcastTriggerProviderInfo>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AppBroadcastTriggerProviderInfo[] = {
        { "_assign_array_", _assign_array_AppBroadcastTriggerProviderInfo, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AppBroadcastTriggerProviderInfo), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AppBroadcastTriggerProviderInfo[] = {
        { "video_key_frame_interval", reinterpret_cast<getter>(AppBroadcastTriggerProviderInfo_get_VideoKeyFrameInterval), reinterpret_cast<setter>(AppBroadcastTriggerProviderInfo_put_VideoKeyFrameInterval), nullptr, nullptr },
        { "max_video_width", reinterpret_cast<getter>(AppBroadcastTriggerProviderInfo_get_MaxVideoWidth), reinterpret_cast<setter>(AppBroadcastTriggerProviderInfo_put_MaxVideoWidth), nullptr, nullptr },
        { "max_video_height", reinterpret_cast<getter>(AppBroadcastTriggerProviderInfo_get_MaxVideoHeight), reinterpret_cast<setter>(AppBroadcastTriggerProviderInfo_put_MaxVideoHeight), nullptr, nullptr },
        { "max_video_bitrate", reinterpret_cast<getter>(AppBroadcastTriggerProviderInfo_get_MaxVideoBitrate), reinterpret_cast<setter>(AppBroadcastTriggerProviderInfo_put_MaxVideoBitrate), nullptr, nullptr },
        { "logo_resource", reinterpret_cast<getter>(AppBroadcastTriggerProviderInfo_get_LogoResource), reinterpret_cast<setter>(AppBroadcastTriggerProviderInfo_put_LogoResource), nullptr, nullptr },
        { "display_name_resource", reinterpret_cast<getter>(AppBroadcastTriggerProviderInfo_get_DisplayNameResource), reinterpret_cast<setter>(AppBroadcastTriggerProviderInfo_put_DisplayNameResource), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AppBroadcastTriggerProviderInfo[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_AppBroadcastTriggerProviderInfo) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AppBroadcastTriggerProviderInfo) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AppBroadcastTriggerProviderInfo) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AppBroadcastTriggerProviderInfo) },
        { },
    };

    static PyType_Spec type_spec_AppBroadcastTriggerProviderInfo =
    {
        "winrt._winrt_windows_applicationmodel_background.AppBroadcastTriggerProviderInfo",
        sizeof(py::wrapper::Windows::ApplicationModel::Background::AppBroadcastTriggerProviderInfo),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AppBroadcastTriggerProviderInfo
    };

    // ----- ApplicationTrigger class --------------------

    static PyObject* _new_ApplicationTrigger(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::ApplicationModel::Background::ApplicationTrigger instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ApplicationTrigger(py::wrapper::Windows::ApplicationModel::Background::ApplicationTrigger* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ApplicationTrigger_RequestAsync(py::wrapper::Windows::ApplicationModel::Background::ApplicationTrigger* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Background.ApplicationTrigger", L"RequestAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.RequestAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Background.ApplicationTrigger", L"RequestAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::ValueSet>(args, 0);

                return py::convert(self->obj.RequestAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_ApplicationTrigger(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Background::ApplicationTrigger>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ApplicationTrigger(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Background::ApplicationTrigger>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ApplicationTrigger[] = {
        { "request_async", reinterpret_cast<PyCFunction>(ApplicationTrigger_RequestAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_ApplicationTrigger, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ApplicationTrigger), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ApplicationTrigger[] = {
        { }
    };

    static PyType_Slot _type_slots_ApplicationTrigger[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ApplicationTrigger) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ApplicationTrigger) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ApplicationTrigger) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ApplicationTrigger) },
        { },
    };

    static PyType_Spec type_spec_ApplicationTrigger =
    {
        "winrt._winrt_windows_applicationmodel_background.ApplicationTrigger",
        sizeof(py::wrapper::Windows::ApplicationModel::Background::ApplicationTrigger),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ApplicationTrigger
    };

    // ----- ApplicationTriggerDetails class --------------------

    static PyObject* _new_ApplicationTriggerDetails(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Background::ApplicationTriggerDetails>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Background::ApplicationTriggerDetails>::type_name);
        return nullptr;
    }

    static void _dealloc_ApplicationTriggerDetails(py::wrapper::Windows::ApplicationModel::Background::ApplicationTriggerDetails* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ApplicationTriggerDetails_get_Arguments(py::wrapper::Windows::ApplicationModel::Background::ApplicationTriggerDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Background.ApplicationTriggerDetails", L"Arguments"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Arguments());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ApplicationTriggerDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Background::ApplicationTriggerDetails>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ApplicationTriggerDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Background::ApplicationTriggerDetails>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ApplicationTriggerDetails[] = {
        { "_assign_array_", _assign_array_ApplicationTriggerDetails, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ApplicationTriggerDetails), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ApplicationTriggerDetails[] = {
        { "arguments", reinterpret_cast<getter>(ApplicationTriggerDetails_get_Arguments), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ApplicationTriggerDetails[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ApplicationTriggerDetails) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ApplicationTriggerDetails) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ApplicationTriggerDetails) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ApplicationTriggerDetails) },
        { },
    };

    static PyType_Spec type_spec_ApplicationTriggerDetails =
    {
        "winrt._winrt_windows_applicationmodel_background.ApplicationTriggerDetails",
        sizeof(py::wrapper::Windows::ApplicationModel::Background::ApplicationTriggerDetails),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ApplicationTriggerDetails
    };

    // ----- AppointmentStoreNotificationTrigger class --------------------

    static PyObject* _new_AppointmentStoreNotificationTrigger(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::ApplicationModel::Background::AppointmentStoreNotificationTrigger instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_AppointmentStoreNotificationTrigger(py::wrapper::Windows::ApplicationModel::Background::AppointmentStoreNotificationTrigger* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_AppointmentStoreNotificationTrigger(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Background::AppointmentStoreNotificationTrigger>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AppointmentStoreNotificationTrigger(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Background::AppointmentStoreNotificationTrigger>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AppointmentStoreNotificationTrigger[] = {
        { "_assign_array_", _assign_array_AppointmentStoreNotificationTrigger, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AppointmentStoreNotificationTrigger), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AppointmentStoreNotificationTrigger[] = {
        { }
    };

    static PyType_Slot _type_slots_AppointmentStoreNotificationTrigger[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_AppointmentStoreNotificationTrigger) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AppointmentStoreNotificationTrigger) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AppointmentStoreNotificationTrigger) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AppointmentStoreNotificationTrigger) },
        { },
    };

    static PyType_Spec type_spec_AppointmentStoreNotificationTrigger =
    {
        "winrt._winrt_windows_applicationmodel_background.AppointmentStoreNotificationTrigger",
        sizeof(py::wrapper::Windows::ApplicationModel::Background::AppointmentStoreNotificationTrigger),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AppointmentStoreNotificationTrigger
    };

    // ----- BackgroundExecutionManager class --------------------

    static PyObject* _new_BackgroundExecutionManager(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Background::BackgroundExecutionManager>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Background::BackgroundExecutionManager>::type_name);
        return nullptr;
    }

    static PyObject* BackgroundExecutionManager_GetAccessStatus(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Background.BackgroundExecutionManager", L"GetAccessStatus", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(winrt::Windows::ApplicationModel::Background::BackgroundExecutionManager::GetAccessStatus());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Background.BackgroundExecutionManager", L"GetAccessStatus", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::ApplicationModel::Background::BackgroundExecutionManager::GetAccessStatus(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BackgroundExecutionManager_GetAccessStatusForModernStandby(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Background.BackgroundExecutionManager", L"GetAccessStatusForModernStandby", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(winrt::Windows::ApplicationModel::Background::BackgroundExecutionManager::GetAccessStatusForModernStandby());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Background.BackgroundExecutionManager", L"GetAccessStatusForModernStandby", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::ApplicationModel::Background::BackgroundExecutionManager::GetAccessStatusForModernStandby(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BackgroundExecutionManager_RemoveAccess(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Background.BackgroundExecutionManager", L"RemoveAccess", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                winrt::Windows::ApplicationModel::Background::BackgroundExecutionManager::RemoveAccess();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Background.BackgroundExecutionManager", L"RemoveAccess", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                winrt::Windows::ApplicationModel::Background::BackgroundExecutionManager::RemoveAccess(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BackgroundExecutionManager_RequestAccessAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Background.BackgroundExecutionManager", L"RequestAccessAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(winrt::Windows::ApplicationModel::Background::BackgroundExecutionManager::RequestAccessAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Background.BackgroundExecutionManager", L"RequestAccessAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::ApplicationModel::Background::BackgroundExecutionManager::RequestAccessAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BackgroundExecutionManager_RequestAccessKindAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Background.BackgroundExecutionManager", L"RequestAccessKindAsync", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Background::BackgroundAccessRequestKind>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert(winrt::Windows::ApplicationModel::Background::BackgroundExecutionManager::RequestAccessKindAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BackgroundExecutionManager_RequestAccessKindForModernStandbyAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Background.BackgroundExecutionManager", L"RequestAccessKindForModernStandbyAsync", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Background::BackgroundAccessRequestKind>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert(winrt::Windows::ApplicationModel::Background::BackgroundExecutionManager::RequestAccessKindForModernStandbyAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyMethodDef _methods_BackgroundExecutionManager[] = {
        { }
    };

    static PyGetSetDef _getset_BackgroundExecutionManager[] = {
        { }
    };

    static PyType_Slot _type_slots_BackgroundExecutionManager[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_BackgroundExecutionManager) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_BackgroundExecutionManager) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_BackgroundExecutionManager) },
        { },
    };

    static PyType_Spec type_spec_BackgroundExecutionManager =
    {
        "winrt._winrt_windows_applicationmodel_background.BackgroundExecutionManager",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_BackgroundExecutionManager
    };

    static PyGetSetDef getset_BackgroundExecutionManager_Static[] = {
        { }
    };

    static PyMethodDef methods_BackgroundExecutionManager_Static[] = {
        { "get_access_status", reinterpret_cast<PyCFunction>(BackgroundExecutionManager_GetAccessStatus), METH_VARARGS, nullptr },
        { "get_access_status_for_modern_standby", reinterpret_cast<PyCFunction>(BackgroundExecutionManager_GetAccessStatusForModernStandby), METH_VARARGS, nullptr },
        { "remove_access", reinterpret_cast<PyCFunction>(BackgroundExecutionManager_RemoveAccess), METH_VARARGS, nullptr },
        { "request_access_async", reinterpret_cast<PyCFunction>(BackgroundExecutionManager_RequestAccessAsync), METH_VARARGS, nullptr },
        { "request_access_kind_async", reinterpret_cast<PyCFunction>(BackgroundExecutionManager_RequestAccessKindAsync), METH_VARARGS, nullptr },
        { "request_access_kind_for_modern_standby_async", reinterpret_cast<PyCFunction>(BackgroundExecutionManager_RequestAccessKindForModernStandbyAsync), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_BackgroundExecutionManager_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_BackgroundExecutionManager_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_BackgroundExecutionManager_Static) },
        { }
    };

    static PyType_Spec type_spec_BackgroundExecutionManager_Static =
    {
        "winrt._winrt_windows_applicationmodel_background.BackgroundExecutionManager_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_BackgroundExecutionManager_Static
    };

    // ----- BackgroundTaskBuilder class --------------------

    static PyObject* _new_BackgroundTaskBuilder(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::ApplicationModel::Background::BackgroundTaskBuilder instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_BackgroundTaskBuilder(py::wrapper::Windows::ApplicationModel::Background::BackgroundTaskBuilder* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* BackgroundTaskBuilder_AddCondition(py::wrapper::Windows::ApplicationModel::Background::BackgroundTaskBuilder* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Background.BackgroundTaskBuilder", L"AddCondition", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Background::IBackgroundCondition>(args, 0);

                self->obj.AddCondition(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BackgroundTaskBuilder_Register(py::wrapper::Windows::ApplicationModel::Background::BackgroundTaskBuilder* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Background.BackgroundTaskBuilder", L"Register", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.Register());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BackgroundTaskBuilder_SetTaskEntryPointClsid(py::wrapper::Windows::ApplicationModel::Background::BackgroundTaskBuilder* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Background.BackgroundTaskBuilder", L"SetTaskEntryPointClsid", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::guid>(args, 0);

                self->obj.SetTaskEntryPointClsid(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BackgroundTaskBuilder_SetTrigger(py::wrapper::Windows::ApplicationModel::Background::BackgroundTaskBuilder* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Background.BackgroundTaskBuilder", L"SetTrigger", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Background::IBackgroundTrigger>(args, 0);

                self->obj.SetTrigger(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BackgroundTaskBuilder_get_TaskEntryPoint(py::wrapper::Windows::ApplicationModel::Background::BackgroundTaskBuilder* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Background.BackgroundTaskBuilder", L"TaskEntryPoint"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.TaskEntryPoint());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BackgroundTaskBuilder_put_TaskEntryPoint(py::wrapper::Windows::ApplicationModel::Background::BackgroundTaskBuilder* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Background.BackgroundTaskBuilder", L"TaskEntryPoint"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.TaskEntryPoint(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BackgroundTaskBuilder_get_Name(py::wrapper::Windows::ApplicationModel::Background::BackgroundTaskBuilder* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Background.BackgroundTaskBuilder", L"Name"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Name());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BackgroundTaskBuilder_put_Name(py::wrapper::Windows::ApplicationModel::Background::BackgroundTaskBuilder* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Background.BackgroundTaskBuilder", L"Name"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Name(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BackgroundTaskBuilder_get_CancelOnConditionLoss(py::wrapper::Windows::ApplicationModel::Background::BackgroundTaskBuilder* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Background.BackgroundTaskBuilder", L"CancelOnConditionLoss"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CancelOnConditionLoss());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BackgroundTaskBuilder_put_CancelOnConditionLoss(py::wrapper::Windows::ApplicationModel::Background::BackgroundTaskBuilder* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Background.BackgroundTaskBuilder", L"CancelOnConditionLoss"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.CancelOnConditionLoss(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BackgroundTaskBuilder_get_IsNetworkRequested(py::wrapper::Windows::ApplicationModel::Background::BackgroundTaskBuilder* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Background.BackgroundTaskBuilder", L"IsNetworkRequested"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsNetworkRequested());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BackgroundTaskBuilder_put_IsNetworkRequested(py::wrapper::Windows::ApplicationModel::Background::BackgroundTaskBuilder* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Background.BackgroundTaskBuilder", L"IsNetworkRequested"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsNetworkRequested(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BackgroundTaskBuilder_get_TaskGroup(py::wrapper::Windows::ApplicationModel::Background::BackgroundTaskBuilder* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Background.BackgroundTaskBuilder", L"TaskGroup"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.TaskGroup());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BackgroundTaskBuilder_put_TaskGroup(py::wrapper::Windows::ApplicationModel::Background::BackgroundTaskBuilder* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Background.BackgroundTaskBuilder", L"TaskGroup"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Background::BackgroundTaskRegistrationGroup>(arg);

            self->obj.TaskGroup(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_BackgroundTaskBuilder(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Background::BackgroundTaskBuilder>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_BackgroundTaskBuilder(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Background::BackgroundTaskBuilder>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_BackgroundTaskBuilder[] = {
        { "add_condition", reinterpret_cast<PyCFunction>(BackgroundTaskBuilder_AddCondition), METH_VARARGS, nullptr },
        { "register", reinterpret_cast<PyCFunction>(BackgroundTaskBuilder_Register), METH_VARARGS, nullptr },
        { "set_task_entry_point_clsid", reinterpret_cast<PyCFunction>(BackgroundTaskBuilder_SetTaskEntryPointClsid), METH_VARARGS, nullptr },
        { "set_trigger", reinterpret_cast<PyCFunction>(BackgroundTaskBuilder_SetTrigger), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_BackgroundTaskBuilder, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_BackgroundTaskBuilder), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_BackgroundTaskBuilder[] = {
        { "task_entry_point", reinterpret_cast<getter>(BackgroundTaskBuilder_get_TaskEntryPoint), reinterpret_cast<setter>(BackgroundTaskBuilder_put_TaskEntryPoint), nullptr, nullptr },
        { "name", reinterpret_cast<getter>(BackgroundTaskBuilder_get_Name), reinterpret_cast<setter>(BackgroundTaskBuilder_put_Name), nullptr, nullptr },
        { "cancel_on_condition_loss", reinterpret_cast<getter>(BackgroundTaskBuilder_get_CancelOnConditionLoss), reinterpret_cast<setter>(BackgroundTaskBuilder_put_CancelOnConditionLoss), nullptr, nullptr },
        { "is_network_requested", reinterpret_cast<getter>(BackgroundTaskBuilder_get_IsNetworkRequested), reinterpret_cast<setter>(BackgroundTaskBuilder_put_IsNetworkRequested), nullptr, nullptr },
        { "task_group", reinterpret_cast<getter>(BackgroundTaskBuilder_get_TaskGroup), reinterpret_cast<setter>(BackgroundTaskBuilder_put_TaskGroup), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_BackgroundTaskBuilder[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_BackgroundTaskBuilder) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_BackgroundTaskBuilder) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_BackgroundTaskBuilder) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_BackgroundTaskBuilder) },
        { },
    };

    static PyType_Spec type_spec_BackgroundTaskBuilder =
    {
        "winrt._winrt_windows_applicationmodel_background.BackgroundTaskBuilder",
        sizeof(py::wrapper::Windows::ApplicationModel::Background::BackgroundTaskBuilder),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_BackgroundTaskBuilder
    };

    // ----- BackgroundTaskCompletedEventArgs class --------------------

    static PyObject* _new_BackgroundTaskCompletedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Background::BackgroundTaskCompletedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Background::BackgroundTaskCompletedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_BackgroundTaskCompletedEventArgs(py::wrapper::Windows::ApplicationModel::Background::BackgroundTaskCompletedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* BackgroundTaskCompletedEventArgs_CheckResult(py::wrapper::Windows::ApplicationModel::Background::BackgroundTaskCompletedEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Background.BackgroundTaskCompletedEventArgs", L"CheckResult", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.CheckResult();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BackgroundTaskCompletedEventArgs_get_InstanceId(py::wrapper::Windows::ApplicationModel::Background::BackgroundTaskCompletedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Background.BackgroundTaskCompletedEventArgs", L"InstanceId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.InstanceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_BackgroundTaskCompletedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Background::BackgroundTaskCompletedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_BackgroundTaskCompletedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Background::BackgroundTaskCompletedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_BackgroundTaskCompletedEventArgs[] = {
        { "check_result", reinterpret_cast<PyCFunction>(BackgroundTaskCompletedEventArgs_CheckResult), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_BackgroundTaskCompletedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_BackgroundTaskCompletedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_BackgroundTaskCompletedEventArgs[] = {
        { "instance_id", reinterpret_cast<getter>(BackgroundTaskCompletedEventArgs_get_InstanceId), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_BackgroundTaskCompletedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_BackgroundTaskCompletedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_BackgroundTaskCompletedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_BackgroundTaskCompletedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_BackgroundTaskCompletedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_BackgroundTaskCompletedEventArgs =
    {
        "winrt._winrt_windows_applicationmodel_background.BackgroundTaskCompletedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Background::BackgroundTaskCompletedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_BackgroundTaskCompletedEventArgs
    };

    // ----- BackgroundTaskDeferral class --------------------

    static PyObject* _new_BackgroundTaskDeferral(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Background::BackgroundTaskDeferral>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Background::BackgroundTaskDeferral>::type_name);
        return nullptr;
    }

    static void _dealloc_BackgroundTaskDeferral(py::wrapper::Windows::ApplicationModel::Background::BackgroundTaskDeferral* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* BackgroundTaskDeferral_Complete(py::wrapper::Windows::ApplicationModel::Background::BackgroundTaskDeferral* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Background.BackgroundTaskDeferral", L"Complete", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Complete();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_BackgroundTaskDeferral(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Background::BackgroundTaskDeferral>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_BackgroundTaskDeferral(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Background::BackgroundTaskDeferral>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_BackgroundTaskDeferral[] = {
        { "complete", reinterpret_cast<PyCFunction>(BackgroundTaskDeferral_Complete), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_BackgroundTaskDeferral, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_BackgroundTaskDeferral), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_BackgroundTaskDeferral[] = {
        { }
    };

    static PyType_Slot _type_slots_BackgroundTaskDeferral[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_BackgroundTaskDeferral) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_BackgroundTaskDeferral) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_BackgroundTaskDeferral) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_BackgroundTaskDeferral) },
        { },
    };

    static PyType_Spec type_spec_BackgroundTaskDeferral =
    {
        "winrt._winrt_windows_applicationmodel_background.BackgroundTaskDeferral",
        sizeof(py::wrapper::Windows::ApplicationModel::Background::BackgroundTaskDeferral),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_BackgroundTaskDeferral
    };

    // ----- BackgroundTaskProgressEventArgs class --------------------

    static PyObject* _new_BackgroundTaskProgressEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Background::BackgroundTaskProgressEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Background::BackgroundTaskProgressEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_BackgroundTaskProgressEventArgs(py::wrapper::Windows::ApplicationModel::Background::BackgroundTaskProgressEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* BackgroundTaskProgressEventArgs_get_InstanceId(py::wrapper::Windows::ApplicationModel::Background::BackgroundTaskProgressEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Background.BackgroundTaskProgressEventArgs", L"InstanceId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.InstanceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BackgroundTaskProgressEventArgs_get_Progress(py::wrapper::Windows::ApplicationModel::Background::BackgroundTaskProgressEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Background.BackgroundTaskProgressEventArgs", L"Progress"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Progress());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_BackgroundTaskProgressEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Background::BackgroundTaskProgressEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_BackgroundTaskProgressEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Background::BackgroundTaskProgressEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_BackgroundTaskProgressEventArgs[] = {
        { "_assign_array_", _assign_array_BackgroundTaskProgressEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_BackgroundTaskProgressEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_BackgroundTaskProgressEventArgs[] = {
        { "instance_id", reinterpret_cast<getter>(BackgroundTaskProgressEventArgs_get_InstanceId), nullptr, nullptr, nullptr },
        { "progress", reinterpret_cast<getter>(BackgroundTaskProgressEventArgs_get_Progress), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_BackgroundTaskProgressEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_BackgroundTaskProgressEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_BackgroundTaskProgressEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_BackgroundTaskProgressEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_BackgroundTaskProgressEventArgs) },
        { },
    };

    static PyType_Spec type_spec_BackgroundTaskProgressEventArgs =
    {
        "winrt._winrt_windows_applicationmodel_background.BackgroundTaskProgressEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Background::BackgroundTaskProgressEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_BackgroundTaskProgressEventArgs
    };

    // ----- BackgroundTaskRegistration class --------------------

    static PyObject* _new_BackgroundTaskRegistration(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Background::BackgroundTaskRegistration>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Background::BackgroundTaskRegistration>::type_name);
        return nullptr;
    }

    static void _dealloc_BackgroundTaskRegistration(py::wrapper::Windows::ApplicationModel::Background::BackgroundTaskRegistration* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* BackgroundTaskRegistration_GetTaskGroup(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Background.BackgroundTaskRegistration", L"GetTaskGroup", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::ApplicationModel::Background::BackgroundTaskRegistration::GetTaskGroup(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BackgroundTaskRegistration_Unregister(py::wrapper::Windows::ApplicationModel::Background::BackgroundTaskRegistration* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Background.BackgroundTaskRegistration", L"Unregister", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<bool>(args, 0);

                self->obj.Unregister(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BackgroundTaskRegistration_get_Name(py::wrapper::Windows::ApplicationModel::Background::BackgroundTaskRegistration* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Background.BackgroundTaskRegistration", L"Name"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Name());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BackgroundTaskRegistration_get_TaskId(py::wrapper::Windows::ApplicationModel::Background::BackgroundTaskRegistration* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Background.BackgroundTaskRegistration", L"TaskId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.TaskId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BackgroundTaskRegistration_get_Trigger(py::wrapper::Windows::ApplicationModel::Background::BackgroundTaskRegistration* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Background.BackgroundTaskRegistration", L"Trigger"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Trigger());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BackgroundTaskRegistration_get_TaskGroup(py::wrapper::Windows::ApplicationModel::Background::BackgroundTaskRegistration* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Background.BackgroundTaskRegistration", L"TaskGroup"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.TaskGroup());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BackgroundTaskRegistration_get_AllTasks(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Background.BackgroundTaskRegistration", L"AllTasks"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::ApplicationModel::Background::BackgroundTaskRegistration::AllTasks());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BackgroundTaskRegistration_get_AllTaskGroups(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Background.BackgroundTaskRegistration", L"AllTaskGroups"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::ApplicationModel::Background::BackgroundTaskRegistration::AllTaskGroups());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BackgroundTaskRegistration_add_Completed(py::wrapper::Windows::ApplicationModel::Background::BackgroundTaskRegistration* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.Background.BackgroundTaskRegistration", L"Completed"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Background::BackgroundTaskCompletedEventHandler>(arg);

            return py::convert(self->obj.Completed(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BackgroundTaskRegistration_remove_Completed(py::wrapper::Windows::ApplicationModel::Background::BackgroundTaskRegistration* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.Background.BackgroundTaskRegistration", L"Completed"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Completed(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BackgroundTaskRegistration_add_Progress(py::wrapper::Windows::ApplicationModel::Background::BackgroundTaskRegistration* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.Background.BackgroundTaskRegistration", L"Progress"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Background::BackgroundTaskProgressEventHandler>(arg);

            return py::convert(self->obj.Progress(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BackgroundTaskRegistration_remove_Progress(py::wrapper::Windows::ApplicationModel::Background::BackgroundTaskRegistration* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.Background.BackgroundTaskRegistration", L"Progress"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Progress(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_BackgroundTaskRegistration(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Background::BackgroundTaskRegistration>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_BackgroundTaskRegistration(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Background::BackgroundTaskRegistration>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_BackgroundTaskRegistration[] = {
        { "unregister", reinterpret_cast<PyCFunction>(BackgroundTaskRegistration_Unregister), METH_VARARGS, nullptr },
        { "add_completed", reinterpret_cast<PyCFunction>(BackgroundTaskRegistration_add_Completed), METH_O, nullptr },
        { "remove_completed", reinterpret_cast<PyCFunction>(BackgroundTaskRegistration_remove_Completed), METH_O, nullptr },
        { "add_progress", reinterpret_cast<PyCFunction>(BackgroundTaskRegistration_add_Progress), METH_O, nullptr },
        { "remove_progress", reinterpret_cast<PyCFunction>(BackgroundTaskRegistration_remove_Progress), METH_O, nullptr },
        { "_assign_array_", _assign_array_BackgroundTaskRegistration, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_BackgroundTaskRegistration), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_BackgroundTaskRegistration[] = {
        { "name", reinterpret_cast<getter>(BackgroundTaskRegistration_get_Name), nullptr, nullptr, nullptr },
        { "task_id", reinterpret_cast<getter>(BackgroundTaskRegistration_get_TaskId), nullptr, nullptr, nullptr },
        { "trigger", reinterpret_cast<getter>(BackgroundTaskRegistration_get_Trigger), nullptr, nullptr, nullptr },
        { "task_group", reinterpret_cast<getter>(BackgroundTaskRegistration_get_TaskGroup), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_BackgroundTaskRegistration[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_BackgroundTaskRegistration) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_BackgroundTaskRegistration) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_BackgroundTaskRegistration) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_BackgroundTaskRegistration) },
        { },
    };

    static PyType_Spec type_spec_BackgroundTaskRegistration =
    {
        "winrt._winrt_windows_applicationmodel_background.BackgroundTaskRegistration",
        sizeof(py::wrapper::Windows::ApplicationModel::Background::BackgroundTaskRegistration),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_BackgroundTaskRegistration
    };

    static PyGetSetDef getset_BackgroundTaskRegistration_Static[] = {
        { "all_tasks", reinterpret_cast<getter>(BackgroundTaskRegistration_get_AllTasks), nullptr, nullptr, nullptr },
        { "all_task_groups", reinterpret_cast<getter>(BackgroundTaskRegistration_get_AllTaskGroups), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_BackgroundTaskRegistration_Static[] = {
        { "get_task_group", reinterpret_cast<PyCFunction>(BackgroundTaskRegistration_GetTaskGroup), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_BackgroundTaskRegistration_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_BackgroundTaskRegistration_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_BackgroundTaskRegistration_Static) },
        { }
    };

    static PyType_Spec type_spec_BackgroundTaskRegistration_Static =
    {
        "winrt._winrt_windows_applicationmodel_background.BackgroundTaskRegistration_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_BackgroundTaskRegistration_Static
    };

    // ----- BackgroundTaskRegistrationGroup class --------------------

    static PyObject* _new_BackgroundTaskRegistrationGroup(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                winrt::Windows::ApplicationModel::Background::BackgroundTaskRegistrationGroup instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                winrt::Windows::ApplicationModel::Background::BackgroundTaskRegistrationGroup instance{ param0, param1 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_BackgroundTaskRegistrationGroup(py::wrapper::Windows::ApplicationModel::Background::BackgroundTaskRegistrationGroup* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* BackgroundTaskRegistrationGroup_get_AllTasks(py::wrapper::Windows::ApplicationModel::Background::BackgroundTaskRegistrationGroup* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Background.BackgroundTaskRegistrationGroup", L"AllTasks"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AllTasks());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BackgroundTaskRegistrationGroup_get_Id(py::wrapper::Windows::ApplicationModel::Background::BackgroundTaskRegistrationGroup* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Background.BackgroundTaskRegistrationGroup", L"Id"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Id());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BackgroundTaskRegistrationGroup_get_Name(py::wrapper::Windows::ApplicationModel::Background::BackgroundTaskRegistrationGroup* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Background.BackgroundTaskRegistrationGroup", L"Name"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Name());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BackgroundTaskRegistrationGroup_add_BackgroundActivated(py::wrapper::Windows::ApplicationModel::Background::BackgroundTaskRegistrationGroup* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.Background.BackgroundTaskRegistrationGroup", L"BackgroundActivated"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::ApplicationModel::Background::BackgroundTaskRegistrationGroup, winrt::Windows::ApplicationModel::Activation::BackgroundActivatedEventArgs>>(arg);

            return py::convert(self->obj.BackgroundActivated(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BackgroundTaskRegistrationGroup_remove_BackgroundActivated(py::wrapper::Windows::ApplicationModel::Background::BackgroundTaskRegistrationGroup* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.Background.BackgroundTaskRegistrationGroup", L"BackgroundActivated"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.BackgroundActivated(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_BackgroundTaskRegistrationGroup(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Background::BackgroundTaskRegistrationGroup>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_BackgroundTaskRegistrationGroup(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Background::BackgroundTaskRegistrationGroup>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_BackgroundTaskRegistrationGroup[] = {
        { "add_background_activated", reinterpret_cast<PyCFunction>(BackgroundTaskRegistrationGroup_add_BackgroundActivated), METH_O, nullptr },
        { "remove_background_activated", reinterpret_cast<PyCFunction>(BackgroundTaskRegistrationGroup_remove_BackgroundActivated), METH_O, nullptr },
        { "_assign_array_", _assign_array_BackgroundTaskRegistrationGroup, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_BackgroundTaskRegistrationGroup), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_BackgroundTaskRegistrationGroup[] = {
        { "all_tasks", reinterpret_cast<getter>(BackgroundTaskRegistrationGroup_get_AllTasks), nullptr, nullptr, nullptr },
        { "id", reinterpret_cast<getter>(BackgroundTaskRegistrationGroup_get_Id), nullptr, nullptr, nullptr },
        { "name", reinterpret_cast<getter>(BackgroundTaskRegistrationGroup_get_Name), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_BackgroundTaskRegistrationGroup[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_BackgroundTaskRegistrationGroup) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_BackgroundTaskRegistrationGroup) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_BackgroundTaskRegistrationGroup) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_BackgroundTaskRegistrationGroup) },
        { },
    };

    static PyType_Spec type_spec_BackgroundTaskRegistrationGroup =
    {
        "winrt._winrt_windows_applicationmodel_background.BackgroundTaskRegistrationGroup",
        sizeof(py::wrapper::Windows::ApplicationModel::Background::BackgroundTaskRegistrationGroup),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_BackgroundTaskRegistrationGroup
    };

    // ----- BackgroundWorkCost class --------------------

    static PyObject* _new_BackgroundWorkCost(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Background::BackgroundWorkCost>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Background::BackgroundWorkCost>::type_name);
        return nullptr;
    }

    static PyObject* BackgroundWorkCost_get_CurrentBackgroundWorkCost(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Background.BackgroundWorkCost", L"CurrentBackgroundWorkCost"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::ApplicationModel::Background::BackgroundWorkCost::CurrentBackgroundWorkCost());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_BackgroundWorkCost[] = {
        { }
    };

    static PyGetSetDef _getset_BackgroundWorkCost[] = {
        { }
    };

    static PyType_Slot _type_slots_BackgroundWorkCost[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_BackgroundWorkCost) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_BackgroundWorkCost) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_BackgroundWorkCost) },
        { },
    };

    static PyType_Spec type_spec_BackgroundWorkCost =
    {
        "winrt._winrt_windows_applicationmodel_background.BackgroundWorkCost",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_BackgroundWorkCost
    };

    static PyGetSetDef getset_BackgroundWorkCost_Static[] = {
        { "current_background_work_cost", reinterpret_cast<getter>(BackgroundWorkCost_get_CurrentBackgroundWorkCost), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_BackgroundWorkCost_Static[] = {
        { }
    };

    static PyType_Slot type_slots_BackgroundWorkCost_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_BackgroundWorkCost_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_BackgroundWorkCost_Static) },
        { }
    };

    static PyType_Spec type_spec_BackgroundWorkCost_Static =
    {
        "winrt._winrt_windows_applicationmodel_background.BackgroundWorkCost_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_BackgroundWorkCost_Static
    };

    // ----- BluetoothLEAdvertisementPublisherTrigger class --------------------

    static PyObject* _new_BluetoothLEAdvertisementPublisherTrigger(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::ApplicationModel::Background::BluetoothLEAdvertisementPublisherTrigger instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_BluetoothLEAdvertisementPublisherTrigger(py::wrapper::Windows::ApplicationModel::Background::BluetoothLEAdvertisementPublisherTrigger* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* BluetoothLEAdvertisementPublisherTrigger_get_Advertisement(py::wrapper::Windows::ApplicationModel::Background::BluetoothLEAdvertisementPublisherTrigger* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Background.BluetoothLEAdvertisementPublisherTrigger", L"Advertisement"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Advertisement());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEAdvertisementPublisherTrigger_get_UseExtendedFormat(py::wrapper::Windows::ApplicationModel::Background::BluetoothLEAdvertisementPublisherTrigger* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Background.BluetoothLEAdvertisementPublisherTrigger", L"UseExtendedFormat"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.UseExtendedFormat());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BluetoothLEAdvertisementPublisherTrigger_put_UseExtendedFormat(py::wrapper::Windows::ApplicationModel::Background::BluetoothLEAdvertisementPublisherTrigger* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Background.BluetoothLEAdvertisementPublisherTrigger", L"UseExtendedFormat"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.UseExtendedFormat(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BluetoothLEAdvertisementPublisherTrigger_get_PreferredTransmitPowerLevelInDBm(py::wrapper::Windows::ApplicationModel::Background::BluetoothLEAdvertisementPublisherTrigger* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Background.BluetoothLEAdvertisementPublisherTrigger", L"PreferredTransmitPowerLevelInDBm"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PreferredTransmitPowerLevelInDBm());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BluetoothLEAdvertisementPublisherTrigger_put_PreferredTransmitPowerLevelInDBm(py::wrapper::Windows::ApplicationModel::Background::BluetoothLEAdvertisementPublisherTrigger* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Background.BluetoothLEAdvertisementPublisherTrigger", L"PreferredTransmitPowerLevelInDBm"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<int16_t>>(arg);

            self->obj.PreferredTransmitPowerLevelInDBm(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BluetoothLEAdvertisementPublisherTrigger_get_IsAnonymous(py::wrapper::Windows::ApplicationModel::Background::BluetoothLEAdvertisementPublisherTrigger* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Background.BluetoothLEAdvertisementPublisherTrigger", L"IsAnonymous"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsAnonymous());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BluetoothLEAdvertisementPublisherTrigger_put_IsAnonymous(py::wrapper::Windows::ApplicationModel::Background::BluetoothLEAdvertisementPublisherTrigger* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Background.BluetoothLEAdvertisementPublisherTrigger", L"IsAnonymous"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsAnonymous(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BluetoothLEAdvertisementPublisherTrigger_get_IncludeTransmitPowerLevel(py::wrapper::Windows::ApplicationModel::Background::BluetoothLEAdvertisementPublisherTrigger* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Background.BluetoothLEAdvertisementPublisherTrigger", L"IncludeTransmitPowerLevel"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IncludeTransmitPowerLevel());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BluetoothLEAdvertisementPublisherTrigger_put_IncludeTransmitPowerLevel(py::wrapper::Windows::ApplicationModel::Background::BluetoothLEAdvertisementPublisherTrigger* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Background.BluetoothLEAdvertisementPublisherTrigger", L"IncludeTransmitPowerLevel"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IncludeTransmitPowerLevel(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_BluetoothLEAdvertisementPublisherTrigger(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Background::BluetoothLEAdvertisementPublisherTrigger>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_BluetoothLEAdvertisementPublisherTrigger(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Background::BluetoothLEAdvertisementPublisherTrigger>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_BluetoothLEAdvertisementPublisherTrigger[] = {
        { "_assign_array_", _assign_array_BluetoothLEAdvertisementPublisherTrigger, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_BluetoothLEAdvertisementPublisherTrigger), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_BluetoothLEAdvertisementPublisherTrigger[] = {
        { "advertisement", reinterpret_cast<getter>(BluetoothLEAdvertisementPublisherTrigger_get_Advertisement), nullptr, nullptr, nullptr },
        { "use_extended_format", reinterpret_cast<getter>(BluetoothLEAdvertisementPublisherTrigger_get_UseExtendedFormat), reinterpret_cast<setter>(BluetoothLEAdvertisementPublisherTrigger_put_UseExtendedFormat), nullptr, nullptr },
        { "preferred_transmit_power_level_in_d_bm", reinterpret_cast<getter>(BluetoothLEAdvertisementPublisherTrigger_get_PreferredTransmitPowerLevelInDBm), reinterpret_cast<setter>(BluetoothLEAdvertisementPublisherTrigger_put_PreferredTransmitPowerLevelInDBm), nullptr, nullptr },
        { "is_anonymous", reinterpret_cast<getter>(BluetoothLEAdvertisementPublisherTrigger_get_IsAnonymous), reinterpret_cast<setter>(BluetoothLEAdvertisementPublisherTrigger_put_IsAnonymous), nullptr, nullptr },
        { "include_transmit_power_level", reinterpret_cast<getter>(BluetoothLEAdvertisementPublisherTrigger_get_IncludeTransmitPowerLevel), reinterpret_cast<setter>(BluetoothLEAdvertisementPublisherTrigger_put_IncludeTransmitPowerLevel), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_BluetoothLEAdvertisementPublisherTrigger[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_BluetoothLEAdvertisementPublisherTrigger) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_BluetoothLEAdvertisementPublisherTrigger) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_BluetoothLEAdvertisementPublisherTrigger) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_BluetoothLEAdvertisementPublisherTrigger) },
        { },
    };

    static PyType_Spec type_spec_BluetoothLEAdvertisementPublisherTrigger =
    {
        "winrt._winrt_windows_applicationmodel_background.BluetoothLEAdvertisementPublisherTrigger",
        sizeof(py::wrapper::Windows::ApplicationModel::Background::BluetoothLEAdvertisementPublisherTrigger),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_BluetoothLEAdvertisementPublisherTrigger
    };

    // ----- BluetoothLEAdvertisementWatcherTrigger class --------------------

    static PyObject* _new_BluetoothLEAdvertisementWatcherTrigger(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::ApplicationModel::Background::BluetoothLEAdvertisementWatcherTrigger instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_BluetoothLEAdvertisementWatcherTrigger(py::wrapper::Windows::ApplicationModel::Background::BluetoothLEAdvertisementWatcherTrigger* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* BluetoothLEAdvertisementWatcherTrigger_get_SignalStrengthFilter(py::wrapper::Windows::ApplicationModel::Background::BluetoothLEAdvertisementWatcherTrigger* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Background.BluetoothLEAdvertisementWatcherTrigger", L"SignalStrengthFilter"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SignalStrengthFilter());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BluetoothLEAdvertisementWatcherTrigger_put_SignalStrengthFilter(py::wrapper::Windows::ApplicationModel::Background::BluetoothLEAdvertisementWatcherTrigger* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Background.BluetoothLEAdvertisementWatcherTrigger", L"SignalStrengthFilter"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Devices::Bluetooth::BluetoothSignalStrengthFilter>(arg);

            self->obj.SignalStrengthFilter(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BluetoothLEAdvertisementWatcherTrigger_get_AdvertisementFilter(py::wrapper::Windows::ApplicationModel::Background::BluetoothLEAdvertisementWatcherTrigger* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Background.BluetoothLEAdvertisementWatcherTrigger", L"AdvertisementFilter"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AdvertisementFilter());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BluetoothLEAdvertisementWatcherTrigger_put_AdvertisementFilter(py::wrapper::Windows::ApplicationModel::Background::BluetoothLEAdvertisementWatcherTrigger* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Background.BluetoothLEAdvertisementWatcherTrigger", L"AdvertisementFilter"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementFilter>(arg);

            self->obj.AdvertisementFilter(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BluetoothLEAdvertisementWatcherTrigger_get_MaxOutOfRangeTimeout(py::wrapper::Windows::ApplicationModel::Background::BluetoothLEAdvertisementWatcherTrigger* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Background.BluetoothLEAdvertisementWatcherTrigger", L"MaxOutOfRangeTimeout"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MaxOutOfRangeTimeout());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEAdvertisementWatcherTrigger_get_MaxSamplingInterval(py::wrapper::Windows::ApplicationModel::Background::BluetoothLEAdvertisementWatcherTrigger* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Background.BluetoothLEAdvertisementWatcherTrigger", L"MaxSamplingInterval"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MaxSamplingInterval());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEAdvertisementWatcherTrigger_get_MinOutOfRangeTimeout(py::wrapper::Windows::ApplicationModel::Background::BluetoothLEAdvertisementWatcherTrigger* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Background.BluetoothLEAdvertisementWatcherTrigger", L"MinOutOfRangeTimeout"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MinOutOfRangeTimeout());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEAdvertisementWatcherTrigger_get_MinSamplingInterval(py::wrapper::Windows::ApplicationModel::Background::BluetoothLEAdvertisementWatcherTrigger* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Background.BluetoothLEAdvertisementWatcherTrigger", L"MinSamplingInterval"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MinSamplingInterval());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEAdvertisementWatcherTrigger_get_AllowExtendedAdvertisements(py::wrapper::Windows::ApplicationModel::Background::BluetoothLEAdvertisementWatcherTrigger* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Background.BluetoothLEAdvertisementWatcherTrigger", L"AllowExtendedAdvertisements"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AllowExtendedAdvertisements());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BluetoothLEAdvertisementWatcherTrigger_put_AllowExtendedAdvertisements(py::wrapper::Windows::ApplicationModel::Background::BluetoothLEAdvertisementWatcherTrigger* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Background.BluetoothLEAdvertisementWatcherTrigger", L"AllowExtendedAdvertisements"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.AllowExtendedAdvertisements(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_BluetoothLEAdvertisementWatcherTrigger(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Background::BluetoothLEAdvertisementWatcherTrigger>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_BluetoothLEAdvertisementWatcherTrigger(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Background::BluetoothLEAdvertisementWatcherTrigger>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_BluetoothLEAdvertisementWatcherTrigger[] = {
        { "_assign_array_", _assign_array_BluetoothLEAdvertisementWatcherTrigger, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_BluetoothLEAdvertisementWatcherTrigger), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_BluetoothLEAdvertisementWatcherTrigger[] = {
        { "signal_strength_filter", reinterpret_cast<getter>(BluetoothLEAdvertisementWatcherTrigger_get_SignalStrengthFilter), reinterpret_cast<setter>(BluetoothLEAdvertisementWatcherTrigger_put_SignalStrengthFilter), nullptr, nullptr },
        { "advertisement_filter", reinterpret_cast<getter>(BluetoothLEAdvertisementWatcherTrigger_get_AdvertisementFilter), reinterpret_cast<setter>(BluetoothLEAdvertisementWatcherTrigger_put_AdvertisementFilter), nullptr, nullptr },
        { "max_out_of_range_timeout", reinterpret_cast<getter>(BluetoothLEAdvertisementWatcherTrigger_get_MaxOutOfRangeTimeout), nullptr, nullptr, nullptr },
        { "max_sampling_interval", reinterpret_cast<getter>(BluetoothLEAdvertisementWatcherTrigger_get_MaxSamplingInterval), nullptr, nullptr, nullptr },
        { "min_out_of_range_timeout", reinterpret_cast<getter>(BluetoothLEAdvertisementWatcherTrigger_get_MinOutOfRangeTimeout), nullptr, nullptr, nullptr },
        { "min_sampling_interval", reinterpret_cast<getter>(BluetoothLEAdvertisementWatcherTrigger_get_MinSamplingInterval), nullptr, nullptr, nullptr },
        { "allow_extended_advertisements", reinterpret_cast<getter>(BluetoothLEAdvertisementWatcherTrigger_get_AllowExtendedAdvertisements), reinterpret_cast<setter>(BluetoothLEAdvertisementWatcherTrigger_put_AllowExtendedAdvertisements), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_BluetoothLEAdvertisementWatcherTrigger[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_BluetoothLEAdvertisementWatcherTrigger) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_BluetoothLEAdvertisementWatcherTrigger) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_BluetoothLEAdvertisementWatcherTrigger) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_BluetoothLEAdvertisementWatcherTrigger) },
        { },
    };

    static PyType_Spec type_spec_BluetoothLEAdvertisementWatcherTrigger =
    {
        "winrt._winrt_windows_applicationmodel_background.BluetoothLEAdvertisementWatcherTrigger",
        sizeof(py::wrapper::Windows::ApplicationModel::Background::BluetoothLEAdvertisementWatcherTrigger),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_BluetoothLEAdvertisementWatcherTrigger
    };

    // ----- CachedFileUpdaterTrigger class --------------------

    static PyObject* _new_CachedFileUpdaterTrigger(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::ApplicationModel::Background::CachedFileUpdaterTrigger instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_CachedFileUpdaterTrigger(py::wrapper::Windows::ApplicationModel::Background::CachedFileUpdaterTrigger* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_CachedFileUpdaterTrigger(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Background::CachedFileUpdaterTrigger>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CachedFileUpdaterTrigger(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Background::CachedFileUpdaterTrigger>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CachedFileUpdaterTrigger[] = {
        { "_assign_array_", _assign_array_CachedFileUpdaterTrigger, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CachedFileUpdaterTrigger), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CachedFileUpdaterTrigger[] = {
        { }
    };

    static PyType_Slot _type_slots_CachedFileUpdaterTrigger[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_CachedFileUpdaterTrigger) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CachedFileUpdaterTrigger) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CachedFileUpdaterTrigger) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CachedFileUpdaterTrigger) },
        { },
    };

    static PyType_Spec type_spec_CachedFileUpdaterTrigger =
    {
        "winrt._winrt_windows_applicationmodel_background.CachedFileUpdaterTrigger",
        sizeof(py::wrapper::Windows::ApplicationModel::Background::CachedFileUpdaterTrigger),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CachedFileUpdaterTrigger
    };

    // ----- CachedFileUpdaterTriggerDetails class --------------------

    static PyObject* _new_CachedFileUpdaterTriggerDetails(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Background::CachedFileUpdaterTriggerDetails>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Background::CachedFileUpdaterTriggerDetails>::type_name);
        return nullptr;
    }

    static void _dealloc_CachedFileUpdaterTriggerDetails(py::wrapper::Windows::ApplicationModel::Background::CachedFileUpdaterTriggerDetails* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CachedFileUpdaterTriggerDetails_get_CanRequestUserInput(py::wrapper::Windows::ApplicationModel::Background::CachedFileUpdaterTriggerDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Background.CachedFileUpdaterTriggerDetails", L"CanRequestUserInput"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CanRequestUserInput());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CachedFileUpdaterTriggerDetails_get_UpdateRequest(py::wrapper::Windows::ApplicationModel::Background::CachedFileUpdaterTriggerDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Background.CachedFileUpdaterTriggerDetails", L"UpdateRequest"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.UpdateRequest());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CachedFileUpdaterTriggerDetails_get_UpdateTarget(py::wrapper::Windows::ApplicationModel::Background::CachedFileUpdaterTriggerDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Background.CachedFileUpdaterTriggerDetails", L"UpdateTarget"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.UpdateTarget());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_CachedFileUpdaterTriggerDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Background::CachedFileUpdaterTriggerDetails>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CachedFileUpdaterTriggerDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Background::CachedFileUpdaterTriggerDetails>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CachedFileUpdaterTriggerDetails[] = {
        { "_assign_array_", _assign_array_CachedFileUpdaterTriggerDetails, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CachedFileUpdaterTriggerDetails), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CachedFileUpdaterTriggerDetails[] = {
        { "can_request_user_input", reinterpret_cast<getter>(CachedFileUpdaterTriggerDetails_get_CanRequestUserInput), nullptr, nullptr, nullptr },
        { "update_request", reinterpret_cast<getter>(CachedFileUpdaterTriggerDetails_get_UpdateRequest), nullptr, nullptr, nullptr },
        { "update_target", reinterpret_cast<getter>(CachedFileUpdaterTriggerDetails_get_UpdateTarget), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CachedFileUpdaterTriggerDetails[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_CachedFileUpdaterTriggerDetails) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CachedFileUpdaterTriggerDetails) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CachedFileUpdaterTriggerDetails) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CachedFileUpdaterTriggerDetails) },
        { },
    };

    static PyType_Spec type_spec_CachedFileUpdaterTriggerDetails =
    {
        "winrt._winrt_windows_applicationmodel_background.CachedFileUpdaterTriggerDetails",
        sizeof(py::wrapper::Windows::ApplicationModel::Background::CachedFileUpdaterTriggerDetails),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CachedFileUpdaterTriggerDetails
    };

    // ----- ChatMessageNotificationTrigger class --------------------

    static PyObject* _new_ChatMessageNotificationTrigger(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::ApplicationModel::Background::ChatMessageNotificationTrigger instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ChatMessageNotificationTrigger(py::wrapper::Windows::ApplicationModel::Background::ChatMessageNotificationTrigger* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_ChatMessageNotificationTrigger(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Background::ChatMessageNotificationTrigger>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ChatMessageNotificationTrigger(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Background::ChatMessageNotificationTrigger>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ChatMessageNotificationTrigger[] = {
        { "_assign_array_", _assign_array_ChatMessageNotificationTrigger, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ChatMessageNotificationTrigger), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ChatMessageNotificationTrigger[] = {
        { }
    };

    static PyType_Slot _type_slots_ChatMessageNotificationTrigger[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ChatMessageNotificationTrigger) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ChatMessageNotificationTrigger) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ChatMessageNotificationTrigger) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ChatMessageNotificationTrigger) },
        { },
    };

    static PyType_Spec type_spec_ChatMessageNotificationTrigger =
    {
        "winrt._winrt_windows_applicationmodel_background.ChatMessageNotificationTrigger",
        sizeof(py::wrapper::Windows::ApplicationModel::Background::ChatMessageNotificationTrigger),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ChatMessageNotificationTrigger
    };

    // ----- ChatMessageReceivedNotificationTrigger class --------------------

    static PyObject* _new_ChatMessageReceivedNotificationTrigger(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::ApplicationModel::Background::ChatMessageReceivedNotificationTrigger instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ChatMessageReceivedNotificationTrigger(py::wrapper::Windows::ApplicationModel::Background::ChatMessageReceivedNotificationTrigger* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_ChatMessageReceivedNotificationTrigger(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Background::ChatMessageReceivedNotificationTrigger>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ChatMessageReceivedNotificationTrigger(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Background::ChatMessageReceivedNotificationTrigger>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ChatMessageReceivedNotificationTrigger[] = {
        { "_assign_array_", _assign_array_ChatMessageReceivedNotificationTrigger, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ChatMessageReceivedNotificationTrigger), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ChatMessageReceivedNotificationTrigger[] = {
        { }
    };

    static PyType_Slot _type_slots_ChatMessageReceivedNotificationTrigger[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ChatMessageReceivedNotificationTrigger) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ChatMessageReceivedNotificationTrigger) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ChatMessageReceivedNotificationTrigger) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ChatMessageReceivedNotificationTrigger) },
        { },
    };

    static PyType_Spec type_spec_ChatMessageReceivedNotificationTrigger =
    {
        "winrt._winrt_windows_applicationmodel_background.ChatMessageReceivedNotificationTrigger",
        sizeof(py::wrapper::Windows::ApplicationModel::Background::ChatMessageReceivedNotificationTrigger),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ChatMessageReceivedNotificationTrigger
    };

    // ----- CommunicationBlockingAppSetAsActiveTrigger class --------------------

    static PyObject* _new_CommunicationBlockingAppSetAsActiveTrigger(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::ApplicationModel::Background::CommunicationBlockingAppSetAsActiveTrigger instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_CommunicationBlockingAppSetAsActiveTrigger(py::wrapper::Windows::ApplicationModel::Background::CommunicationBlockingAppSetAsActiveTrigger* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_CommunicationBlockingAppSetAsActiveTrigger(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Background::CommunicationBlockingAppSetAsActiveTrigger>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CommunicationBlockingAppSetAsActiveTrigger(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Background::CommunicationBlockingAppSetAsActiveTrigger>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CommunicationBlockingAppSetAsActiveTrigger[] = {
        { "_assign_array_", _assign_array_CommunicationBlockingAppSetAsActiveTrigger, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CommunicationBlockingAppSetAsActiveTrigger), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CommunicationBlockingAppSetAsActiveTrigger[] = {
        { }
    };

    static PyType_Slot _type_slots_CommunicationBlockingAppSetAsActiveTrigger[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_CommunicationBlockingAppSetAsActiveTrigger) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CommunicationBlockingAppSetAsActiveTrigger) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CommunicationBlockingAppSetAsActiveTrigger) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CommunicationBlockingAppSetAsActiveTrigger) },
        { },
    };

    static PyType_Spec type_spec_CommunicationBlockingAppSetAsActiveTrigger =
    {
        "winrt._winrt_windows_applicationmodel_background.CommunicationBlockingAppSetAsActiveTrigger",
        sizeof(py::wrapper::Windows::ApplicationModel::Background::CommunicationBlockingAppSetAsActiveTrigger),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CommunicationBlockingAppSetAsActiveTrigger
    };

    // ----- ContactStoreNotificationTrigger class --------------------

    static PyObject* _new_ContactStoreNotificationTrigger(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::ApplicationModel::Background::ContactStoreNotificationTrigger instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ContactStoreNotificationTrigger(py::wrapper::Windows::ApplicationModel::Background::ContactStoreNotificationTrigger* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_ContactStoreNotificationTrigger(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Background::ContactStoreNotificationTrigger>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ContactStoreNotificationTrigger(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Background::ContactStoreNotificationTrigger>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ContactStoreNotificationTrigger[] = {
        { "_assign_array_", _assign_array_ContactStoreNotificationTrigger, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ContactStoreNotificationTrigger), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ContactStoreNotificationTrigger[] = {
        { }
    };

    static PyType_Slot _type_slots_ContactStoreNotificationTrigger[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ContactStoreNotificationTrigger) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ContactStoreNotificationTrigger) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ContactStoreNotificationTrigger) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ContactStoreNotificationTrigger) },
        { },
    };

    static PyType_Spec type_spec_ContactStoreNotificationTrigger =
    {
        "winrt._winrt_windows_applicationmodel_background.ContactStoreNotificationTrigger",
        sizeof(py::wrapper::Windows::ApplicationModel::Background::ContactStoreNotificationTrigger),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ContactStoreNotificationTrigger
    };

    // ----- ContentPrefetchTrigger class --------------------

    static PyObject* _new_ContentPrefetchTrigger(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(args, 0);

                winrt::Windows::ApplicationModel::Background::ContentPrefetchTrigger instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 0)
        {
            try
            {
                winrt::Windows::ApplicationModel::Background::ContentPrefetchTrigger instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ContentPrefetchTrigger(py::wrapper::Windows::ApplicationModel::Background::ContentPrefetchTrigger* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ContentPrefetchTrigger_get_WaitInterval(py::wrapper::Windows::ApplicationModel::Background::ContentPrefetchTrigger* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Background.ContentPrefetchTrigger", L"WaitInterval"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.WaitInterval());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ContentPrefetchTrigger(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Background::ContentPrefetchTrigger>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ContentPrefetchTrigger(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Background::ContentPrefetchTrigger>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ContentPrefetchTrigger[] = {
        { "_assign_array_", _assign_array_ContentPrefetchTrigger, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ContentPrefetchTrigger), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ContentPrefetchTrigger[] = {
        { "wait_interval", reinterpret_cast<getter>(ContentPrefetchTrigger_get_WaitInterval), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ContentPrefetchTrigger[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ContentPrefetchTrigger) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ContentPrefetchTrigger) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ContentPrefetchTrigger) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ContentPrefetchTrigger) },
        { },
    };

    static PyType_Spec type_spec_ContentPrefetchTrigger =
    {
        "winrt._winrt_windows_applicationmodel_background.ContentPrefetchTrigger",
        sizeof(py::wrapper::Windows::ApplicationModel::Background::ContentPrefetchTrigger),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ContentPrefetchTrigger
    };

    // ----- ConversationalAgentTrigger class --------------------

    static PyObject* _new_ConversationalAgentTrigger(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::ApplicationModel::Background::ConversationalAgentTrigger instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ConversationalAgentTrigger(py::wrapper::Windows::ApplicationModel::Background::ConversationalAgentTrigger* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_ConversationalAgentTrigger(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Background::ConversationalAgentTrigger>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ConversationalAgentTrigger(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Background::ConversationalAgentTrigger>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ConversationalAgentTrigger[] = {
        { "_assign_array_", _assign_array_ConversationalAgentTrigger, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ConversationalAgentTrigger), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ConversationalAgentTrigger[] = {
        { }
    };

    static PyType_Slot _type_slots_ConversationalAgentTrigger[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ConversationalAgentTrigger) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ConversationalAgentTrigger) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ConversationalAgentTrigger) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ConversationalAgentTrigger) },
        { },
    };

    static PyType_Spec type_spec_ConversationalAgentTrigger =
    {
        "winrt._winrt_windows_applicationmodel_background.ConversationalAgentTrigger",
        sizeof(py::wrapper::Windows::ApplicationModel::Background::ConversationalAgentTrigger),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ConversationalAgentTrigger
    };

    // ----- CustomSystemEventTrigger class --------------------

    static PyObject* _new_CustomSystemEventTrigger(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::ApplicationModel::Background::CustomSystemEventTriggerRecurrence>(args, 1);

                winrt::Windows::ApplicationModel::Background::CustomSystemEventTrigger instance{ param0, param1 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_CustomSystemEventTrigger(py::wrapper::Windows::ApplicationModel::Background::CustomSystemEventTrigger* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CustomSystemEventTrigger_get_Recurrence(py::wrapper::Windows::ApplicationModel::Background::CustomSystemEventTrigger* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Background.CustomSystemEventTrigger", L"Recurrence"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Recurrence());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CustomSystemEventTrigger_get_TriggerId(py::wrapper::Windows::ApplicationModel::Background::CustomSystemEventTrigger* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Background.CustomSystemEventTrigger", L"TriggerId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.TriggerId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_CustomSystemEventTrigger(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Background::CustomSystemEventTrigger>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CustomSystemEventTrigger(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Background::CustomSystemEventTrigger>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CustomSystemEventTrigger[] = {
        { "_assign_array_", _assign_array_CustomSystemEventTrigger, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CustomSystemEventTrigger), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CustomSystemEventTrigger[] = {
        { "recurrence", reinterpret_cast<getter>(CustomSystemEventTrigger_get_Recurrence), nullptr, nullptr, nullptr },
        { "trigger_id", reinterpret_cast<getter>(CustomSystemEventTrigger_get_TriggerId), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CustomSystemEventTrigger[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_CustomSystemEventTrigger) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CustomSystemEventTrigger) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CustomSystemEventTrigger) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CustomSystemEventTrigger) },
        { },
    };

    static PyType_Spec type_spec_CustomSystemEventTrigger =
    {
        "winrt._winrt_windows_applicationmodel_background.CustomSystemEventTrigger",
        sizeof(py::wrapper::Windows::ApplicationModel::Background::CustomSystemEventTrigger),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CustomSystemEventTrigger
    };

    // ----- DeviceConnectionChangeTrigger class --------------------

    static PyObject* _new_DeviceConnectionChangeTrigger(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Background::DeviceConnectionChangeTrigger>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Background::DeviceConnectionChangeTrigger>::type_name);
        return nullptr;
    }

    static void _dealloc_DeviceConnectionChangeTrigger(py::wrapper::Windows::ApplicationModel::Background::DeviceConnectionChangeTrigger* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* DeviceConnectionChangeTrigger_FromIdAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Background.DeviceConnectionChangeTrigger", L"FromIdAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::ApplicationModel::Background::DeviceConnectionChangeTrigger::FromIdAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DeviceConnectionChangeTrigger_get_MaintainConnection(py::wrapper::Windows::ApplicationModel::Background::DeviceConnectionChangeTrigger* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Background.DeviceConnectionChangeTrigger", L"MaintainConnection"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MaintainConnection());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DeviceConnectionChangeTrigger_put_MaintainConnection(py::wrapper::Windows::ApplicationModel::Background::DeviceConnectionChangeTrigger* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Background.DeviceConnectionChangeTrigger", L"MaintainConnection"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.MaintainConnection(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DeviceConnectionChangeTrigger_get_CanMaintainConnection(py::wrapper::Windows::ApplicationModel::Background::DeviceConnectionChangeTrigger* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Background.DeviceConnectionChangeTrigger", L"CanMaintainConnection"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CanMaintainConnection());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DeviceConnectionChangeTrigger_get_DeviceId(py::wrapper::Windows::ApplicationModel::Background::DeviceConnectionChangeTrigger* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Background.DeviceConnectionChangeTrigger", L"DeviceId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DeviceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_DeviceConnectionChangeTrigger(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Background::DeviceConnectionChangeTrigger>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_DeviceConnectionChangeTrigger(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Background::DeviceConnectionChangeTrigger>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DeviceConnectionChangeTrigger[] = {
        { "_assign_array_", _assign_array_DeviceConnectionChangeTrigger, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_DeviceConnectionChangeTrigger), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_DeviceConnectionChangeTrigger[] = {
        { "maintain_connection", reinterpret_cast<getter>(DeviceConnectionChangeTrigger_get_MaintainConnection), reinterpret_cast<setter>(DeviceConnectionChangeTrigger_put_MaintainConnection), nullptr, nullptr },
        { "can_maintain_connection", reinterpret_cast<getter>(DeviceConnectionChangeTrigger_get_CanMaintainConnection), nullptr, nullptr, nullptr },
        { "device_id", reinterpret_cast<getter>(DeviceConnectionChangeTrigger_get_DeviceId), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_DeviceConnectionChangeTrigger[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_DeviceConnectionChangeTrigger) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_DeviceConnectionChangeTrigger) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_DeviceConnectionChangeTrigger) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_DeviceConnectionChangeTrigger) },
        { },
    };

    static PyType_Spec type_spec_DeviceConnectionChangeTrigger =
    {
        "winrt._winrt_windows_applicationmodel_background.DeviceConnectionChangeTrigger",
        sizeof(py::wrapper::Windows::ApplicationModel::Background::DeviceConnectionChangeTrigger),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DeviceConnectionChangeTrigger
    };

    static PyGetSetDef getset_DeviceConnectionChangeTrigger_Static[] = {
        { }
    };

    static PyMethodDef methods_DeviceConnectionChangeTrigger_Static[] = {
        { "from_id_async", reinterpret_cast<PyCFunction>(DeviceConnectionChangeTrigger_FromIdAsync), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_DeviceConnectionChangeTrigger_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_DeviceConnectionChangeTrigger_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_DeviceConnectionChangeTrigger_Static) },
        { }
    };

    static PyType_Spec type_spec_DeviceConnectionChangeTrigger_Static =
    {
        "winrt._winrt_windows_applicationmodel_background.DeviceConnectionChangeTrigger_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_DeviceConnectionChangeTrigger_Static
    };

    // ----- DeviceManufacturerNotificationTrigger class --------------------

    static PyObject* _new_DeviceManufacturerNotificationTrigger(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<bool>(args, 1);

                winrt::Windows::ApplicationModel::Background::DeviceManufacturerNotificationTrigger instance{ param0, param1 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_DeviceManufacturerNotificationTrigger(py::wrapper::Windows::ApplicationModel::Background::DeviceManufacturerNotificationTrigger* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* DeviceManufacturerNotificationTrigger_get_OneShot(py::wrapper::Windows::ApplicationModel::Background::DeviceManufacturerNotificationTrigger* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Background.DeviceManufacturerNotificationTrigger", L"OneShot"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.OneShot());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DeviceManufacturerNotificationTrigger_get_TriggerQualifier(py::wrapper::Windows::ApplicationModel::Background::DeviceManufacturerNotificationTrigger* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Background.DeviceManufacturerNotificationTrigger", L"TriggerQualifier"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.TriggerQualifier());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_DeviceManufacturerNotificationTrigger(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Background::DeviceManufacturerNotificationTrigger>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_DeviceManufacturerNotificationTrigger(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Background::DeviceManufacturerNotificationTrigger>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DeviceManufacturerNotificationTrigger[] = {
        { "_assign_array_", _assign_array_DeviceManufacturerNotificationTrigger, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_DeviceManufacturerNotificationTrigger), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_DeviceManufacturerNotificationTrigger[] = {
        { "one_shot", reinterpret_cast<getter>(DeviceManufacturerNotificationTrigger_get_OneShot), nullptr, nullptr, nullptr },
        { "trigger_qualifier", reinterpret_cast<getter>(DeviceManufacturerNotificationTrigger_get_TriggerQualifier), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_DeviceManufacturerNotificationTrigger[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_DeviceManufacturerNotificationTrigger) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_DeviceManufacturerNotificationTrigger) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_DeviceManufacturerNotificationTrigger) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_DeviceManufacturerNotificationTrigger) },
        { },
    };

    static PyType_Spec type_spec_DeviceManufacturerNotificationTrigger =
    {
        "winrt._winrt_windows_applicationmodel_background.DeviceManufacturerNotificationTrigger",
        sizeof(py::wrapper::Windows::ApplicationModel::Background::DeviceManufacturerNotificationTrigger),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DeviceManufacturerNotificationTrigger
    };

    // ----- DeviceServicingTrigger class --------------------

    static PyObject* _new_DeviceServicingTrigger(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::ApplicationModel::Background::DeviceServicingTrigger instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_DeviceServicingTrigger(py::wrapper::Windows::ApplicationModel::Background::DeviceServicingTrigger* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* DeviceServicingTrigger_RequestAsync(py::wrapper::Windows::ApplicationModel::Background::DeviceServicingTrigger* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Background.DeviceServicingTrigger", L"RequestAsync", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(args, 1);

                return py::convert(self->obj.RequestAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Background.DeviceServicingTrigger", L"RequestAsync", 3))
            {
                py::set_arg_count_version_error(3);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(args, 1);
                auto param2 = py::convert_to<winrt::hstring>(args, 2);

                return py::convert(self->obj.RequestAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_DeviceServicingTrigger(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Background::DeviceServicingTrigger>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_DeviceServicingTrigger(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Background::DeviceServicingTrigger>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DeviceServicingTrigger[] = {
        { "request_async", reinterpret_cast<PyCFunction>(DeviceServicingTrigger_RequestAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_DeviceServicingTrigger, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_DeviceServicingTrigger), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_DeviceServicingTrigger[] = {
        { }
    };

    static PyType_Slot _type_slots_DeviceServicingTrigger[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_DeviceServicingTrigger) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_DeviceServicingTrigger) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_DeviceServicingTrigger) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_DeviceServicingTrigger) },
        { },
    };

    static PyType_Spec type_spec_DeviceServicingTrigger =
    {
        "winrt._winrt_windows_applicationmodel_background.DeviceServicingTrigger",
        sizeof(py::wrapper::Windows::ApplicationModel::Background::DeviceServicingTrigger),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DeviceServicingTrigger
    };

    // ----- DeviceUseTrigger class --------------------

    static PyObject* _new_DeviceUseTrigger(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::ApplicationModel::Background::DeviceUseTrigger instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_DeviceUseTrigger(py::wrapper::Windows::ApplicationModel::Background::DeviceUseTrigger* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* DeviceUseTrigger_RequestAsync(py::wrapper::Windows::ApplicationModel::Background::DeviceUseTrigger* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Background.DeviceUseTrigger", L"RequestAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.RequestAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Background.DeviceUseTrigger", L"RequestAsync", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert(self->obj.RequestAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_DeviceUseTrigger(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Background::DeviceUseTrigger>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_DeviceUseTrigger(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Background::DeviceUseTrigger>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DeviceUseTrigger[] = {
        { "request_async", reinterpret_cast<PyCFunction>(DeviceUseTrigger_RequestAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_DeviceUseTrigger, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_DeviceUseTrigger), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_DeviceUseTrigger[] = {
        { }
    };

    static PyType_Slot _type_slots_DeviceUseTrigger[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_DeviceUseTrigger) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_DeviceUseTrigger) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_DeviceUseTrigger) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_DeviceUseTrigger) },
        { },
    };

    static PyType_Spec type_spec_DeviceUseTrigger =
    {
        "winrt._winrt_windows_applicationmodel_background.DeviceUseTrigger",
        sizeof(py::wrapper::Windows::ApplicationModel::Background::DeviceUseTrigger),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DeviceUseTrigger
    };

    // ----- DeviceWatcherTrigger class --------------------

    static PyObject* _new_DeviceWatcherTrigger(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Background::DeviceWatcherTrigger>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Background::DeviceWatcherTrigger>::type_name);
        return nullptr;
    }

    static void _dealloc_DeviceWatcherTrigger(py::wrapper::Windows::ApplicationModel::Background::DeviceWatcherTrigger* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_DeviceWatcherTrigger(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Background::DeviceWatcherTrigger>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_DeviceWatcherTrigger(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Background::DeviceWatcherTrigger>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DeviceWatcherTrigger[] = {
        { "_assign_array_", _assign_array_DeviceWatcherTrigger, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_DeviceWatcherTrigger), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_DeviceWatcherTrigger[] = {
        { }
    };

    static PyType_Slot _type_slots_DeviceWatcherTrigger[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_DeviceWatcherTrigger) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_DeviceWatcherTrigger) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_DeviceWatcherTrigger) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_DeviceWatcherTrigger) },
        { },
    };

    static PyType_Spec type_spec_DeviceWatcherTrigger =
    {
        "winrt._winrt_windows_applicationmodel_background.DeviceWatcherTrigger",
        sizeof(py::wrapper::Windows::ApplicationModel::Background::DeviceWatcherTrigger),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DeviceWatcherTrigger
    };

    // ----- EmailStoreNotificationTrigger class --------------------

    static PyObject* _new_EmailStoreNotificationTrigger(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::ApplicationModel::Background::EmailStoreNotificationTrigger instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_EmailStoreNotificationTrigger(py::wrapper::Windows::ApplicationModel::Background::EmailStoreNotificationTrigger* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_EmailStoreNotificationTrigger(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Background::EmailStoreNotificationTrigger>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_EmailStoreNotificationTrigger(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Background::EmailStoreNotificationTrigger>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_EmailStoreNotificationTrigger[] = {
        { "_assign_array_", _assign_array_EmailStoreNotificationTrigger, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_EmailStoreNotificationTrigger), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_EmailStoreNotificationTrigger[] = {
        { }
    };

    static PyType_Slot _type_slots_EmailStoreNotificationTrigger[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_EmailStoreNotificationTrigger) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_EmailStoreNotificationTrigger) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_EmailStoreNotificationTrigger) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_EmailStoreNotificationTrigger) },
        { },
    };

    static PyType_Spec type_spec_EmailStoreNotificationTrigger =
    {
        "winrt._winrt_windows_applicationmodel_background.EmailStoreNotificationTrigger",
        sizeof(py::wrapper::Windows::ApplicationModel::Background::EmailStoreNotificationTrigger),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_EmailStoreNotificationTrigger
    };

    // ----- GattCharacteristicNotificationTrigger class --------------------

    static PyObject* _new_GattCharacteristicNotificationTrigger(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristic>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Devices::Bluetooth::Background::BluetoothEventTriggeringMode>(args, 1);

                winrt::Windows::ApplicationModel::Background::GattCharacteristicNotificationTrigger instance{ param0, param1 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristic>(args, 0);

                winrt::Windows::ApplicationModel::Background::GattCharacteristicNotificationTrigger instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_GattCharacteristicNotificationTrigger(py::wrapper::Windows::ApplicationModel::Background::GattCharacteristicNotificationTrigger* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* GattCharacteristicNotificationTrigger_get_Characteristic(py::wrapper::Windows::ApplicationModel::Background::GattCharacteristicNotificationTrigger* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Background.GattCharacteristicNotificationTrigger", L"Characteristic"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Characteristic());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GattCharacteristicNotificationTrigger_get_EventTriggeringMode(py::wrapper::Windows::ApplicationModel::Background::GattCharacteristicNotificationTrigger* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Background.GattCharacteristicNotificationTrigger", L"EventTriggeringMode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.EventTriggeringMode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_GattCharacteristicNotificationTrigger(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Background::GattCharacteristicNotificationTrigger>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_GattCharacteristicNotificationTrigger(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Background::GattCharacteristicNotificationTrigger>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_GattCharacteristicNotificationTrigger[] = {
        { "_assign_array_", _assign_array_GattCharacteristicNotificationTrigger, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_GattCharacteristicNotificationTrigger), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_GattCharacteristicNotificationTrigger[] = {
        { "characteristic", reinterpret_cast<getter>(GattCharacteristicNotificationTrigger_get_Characteristic), nullptr, nullptr, nullptr },
        { "event_triggering_mode", reinterpret_cast<getter>(GattCharacteristicNotificationTrigger_get_EventTriggeringMode), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_GattCharacteristicNotificationTrigger[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_GattCharacteristicNotificationTrigger) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_GattCharacteristicNotificationTrigger) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_GattCharacteristicNotificationTrigger) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_GattCharacteristicNotificationTrigger) },
        { },
    };

    static PyType_Spec type_spec_GattCharacteristicNotificationTrigger =
    {
        "winrt._winrt_windows_applicationmodel_background.GattCharacteristicNotificationTrigger",
        sizeof(py::wrapper::Windows::ApplicationModel::Background::GattCharacteristicNotificationTrigger),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_GattCharacteristicNotificationTrigger
    };

    // ----- GattServiceProviderTrigger class --------------------

    static PyObject* _new_GattServiceProviderTrigger(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Background::GattServiceProviderTrigger>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Background::GattServiceProviderTrigger>::type_name);
        return nullptr;
    }

    static void _dealloc_GattServiceProviderTrigger(py::wrapper::Windows::ApplicationModel::Background::GattServiceProviderTrigger* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* GattServiceProviderTrigger_CreateAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Background.GattServiceProviderTrigger", L"CreateAsync", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::guid>(args, 1);

                return py::convert(winrt::Windows::ApplicationModel::Background::GattServiceProviderTrigger::CreateAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* GattServiceProviderTrigger_get_AdvertisingParameters(py::wrapper::Windows::ApplicationModel::Background::GattServiceProviderTrigger* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Background.GattServiceProviderTrigger", L"AdvertisingParameters"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AdvertisingParameters());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int GattServiceProviderTrigger_put_AdvertisingParameters(py::wrapper::Windows::ApplicationModel::Background::GattServiceProviderTrigger* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Background.GattServiceProviderTrigger", L"AdvertisingParameters"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattServiceProviderAdvertisingParameters>(arg);

            self->obj.AdvertisingParameters(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* GattServiceProviderTrigger_get_Service(py::wrapper::Windows::ApplicationModel::Background::GattServiceProviderTrigger* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Background.GattServiceProviderTrigger", L"Service"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Service());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GattServiceProviderTrigger_get_TriggerId(py::wrapper::Windows::ApplicationModel::Background::GattServiceProviderTrigger* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Background.GattServiceProviderTrigger", L"TriggerId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.TriggerId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_GattServiceProviderTrigger(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Background::GattServiceProviderTrigger>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_GattServiceProviderTrigger(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Background::GattServiceProviderTrigger>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_GattServiceProviderTrigger[] = {
        { "_assign_array_", _assign_array_GattServiceProviderTrigger, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_GattServiceProviderTrigger), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_GattServiceProviderTrigger[] = {
        { "advertising_parameters", reinterpret_cast<getter>(GattServiceProviderTrigger_get_AdvertisingParameters), reinterpret_cast<setter>(GattServiceProviderTrigger_put_AdvertisingParameters), nullptr, nullptr },
        { "service", reinterpret_cast<getter>(GattServiceProviderTrigger_get_Service), nullptr, nullptr, nullptr },
        { "trigger_id", reinterpret_cast<getter>(GattServiceProviderTrigger_get_TriggerId), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_GattServiceProviderTrigger[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_GattServiceProviderTrigger) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_GattServiceProviderTrigger) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_GattServiceProviderTrigger) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_GattServiceProviderTrigger) },
        { },
    };

    static PyType_Spec type_spec_GattServiceProviderTrigger =
    {
        "winrt._winrt_windows_applicationmodel_background.GattServiceProviderTrigger",
        sizeof(py::wrapper::Windows::ApplicationModel::Background::GattServiceProviderTrigger),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_GattServiceProviderTrigger
    };

    static PyGetSetDef getset_GattServiceProviderTrigger_Static[] = {
        { }
    };

    static PyMethodDef methods_GattServiceProviderTrigger_Static[] = {
        { "create_async", reinterpret_cast<PyCFunction>(GattServiceProviderTrigger_CreateAsync), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_GattServiceProviderTrigger_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_GattServiceProviderTrigger_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_GattServiceProviderTrigger_Static) },
        { }
    };

    static PyType_Spec type_spec_GattServiceProviderTrigger_Static =
    {
        "winrt._winrt_windows_applicationmodel_background.GattServiceProviderTrigger_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_GattServiceProviderTrigger_Static
    };

    // ----- GattServiceProviderTriggerResult class --------------------

    static PyObject* _new_GattServiceProviderTriggerResult(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Background::GattServiceProviderTriggerResult>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Background::GattServiceProviderTriggerResult>::type_name);
        return nullptr;
    }

    static void _dealloc_GattServiceProviderTriggerResult(py::wrapper::Windows::ApplicationModel::Background::GattServiceProviderTriggerResult* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* GattServiceProviderTriggerResult_get_Error(py::wrapper::Windows::ApplicationModel::Background::GattServiceProviderTriggerResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Background.GattServiceProviderTriggerResult", L"Error"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Error());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GattServiceProviderTriggerResult_get_Trigger(py::wrapper::Windows::ApplicationModel::Background::GattServiceProviderTriggerResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Background.GattServiceProviderTriggerResult", L"Trigger"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Trigger());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_GattServiceProviderTriggerResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Background::GattServiceProviderTriggerResult>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_GattServiceProviderTriggerResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Background::GattServiceProviderTriggerResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_GattServiceProviderTriggerResult[] = {
        { "_assign_array_", _assign_array_GattServiceProviderTriggerResult, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_GattServiceProviderTriggerResult), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_GattServiceProviderTriggerResult[] = {
        { "error", reinterpret_cast<getter>(GattServiceProviderTriggerResult_get_Error), nullptr, nullptr, nullptr },
        { "trigger", reinterpret_cast<getter>(GattServiceProviderTriggerResult_get_Trigger), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_GattServiceProviderTriggerResult[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_GattServiceProviderTriggerResult) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_GattServiceProviderTriggerResult) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_GattServiceProviderTriggerResult) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_GattServiceProviderTriggerResult) },
        { },
    };

    static PyType_Spec type_spec_GattServiceProviderTriggerResult =
    {
        "winrt._winrt_windows_applicationmodel_background.GattServiceProviderTriggerResult",
        sizeof(py::wrapper::Windows::ApplicationModel::Background::GattServiceProviderTriggerResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_GattServiceProviderTriggerResult
    };

    // ----- GeovisitTrigger class --------------------

    static PyObject* _new_GeovisitTrigger(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::ApplicationModel::Background::GeovisitTrigger instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_GeovisitTrigger(py::wrapper::Windows::ApplicationModel::Background::GeovisitTrigger* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* GeovisitTrigger_get_MonitoringScope(py::wrapper::Windows::ApplicationModel::Background::GeovisitTrigger* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Background.GeovisitTrigger", L"MonitoringScope"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MonitoringScope());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int GeovisitTrigger_put_MonitoringScope(py::wrapper::Windows::ApplicationModel::Background::GeovisitTrigger* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Background.GeovisitTrigger", L"MonitoringScope"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Devices::Geolocation::VisitMonitoringScope>(arg);

            self->obj.MonitoringScope(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_GeovisitTrigger(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Background::GeovisitTrigger>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_GeovisitTrigger(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Background::GeovisitTrigger>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_GeovisitTrigger[] = {
        { "_assign_array_", _assign_array_GeovisitTrigger, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_GeovisitTrigger), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_GeovisitTrigger[] = {
        { "monitoring_scope", reinterpret_cast<getter>(GeovisitTrigger_get_MonitoringScope), reinterpret_cast<setter>(GeovisitTrigger_put_MonitoringScope), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_GeovisitTrigger[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_GeovisitTrigger) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_GeovisitTrigger) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_GeovisitTrigger) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_GeovisitTrigger) },
        { },
    };

    static PyType_Spec type_spec_GeovisitTrigger =
    {
        "winrt._winrt_windows_applicationmodel_background.GeovisitTrigger",
        sizeof(py::wrapper::Windows::ApplicationModel::Background::GeovisitTrigger),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_GeovisitTrigger
    };

    // ----- LocationTrigger class --------------------

    static PyObject* _new_LocationTrigger(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Background::LocationTriggerType>(args, 0);

                winrt::Windows::ApplicationModel::Background::LocationTrigger instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_LocationTrigger(py::wrapper::Windows::ApplicationModel::Background::LocationTrigger* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* LocationTrigger_get_TriggerType(py::wrapper::Windows::ApplicationModel::Background::LocationTrigger* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Background.LocationTrigger", L"TriggerType"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.TriggerType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_LocationTrigger(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Background::LocationTrigger>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_LocationTrigger(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Background::LocationTrigger>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_LocationTrigger[] = {
        { "_assign_array_", _assign_array_LocationTrigger, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_LocationTrigger), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_LocationTrigger[] = {
        { "trigger_type", reinterpret_cast<getter>(LocationTrigger_get_TriggerType), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_LocationTrigger[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_LocationTrigger) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_LocationTrigger) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_LocationTrigger) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_LocationTrigger) },
        { },
    };

    static PyType_Spec type_spec_LocationTrigger =
    {
        "winrt._winrt_windows_applicationmodel_background.LocationTrigger",
        sizeof(py::wrapper::Windows::ApplicationModel::Background::LocationTrigger),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_LocationTrigger
    };

    // ----- MaintenanceTrigger class --------------------

    static PyObject* _new_MaintenanceTrigger(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<bool>(args, 1);

                winrt::Windows::ApplicationModel::Background::MaintenanceTrigger instance{ param0, param1 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_MaintenanceTrigger(py::wrapper::Windows::ApplicationModel::Background::MaintenanceTrigger* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MaintenanceTrigger_get_FreshnessTime(py::wrapper::Windows::ApplicationModel::Background::MaintenanceTrigger* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Background.MaintenanceTrigger", L"FreshnessTime"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.FreshnessTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MaintenanceTrigger_get_OneShot(py::wrapper::Windows::ApplicationModel::Background::MaintenanceTrigger* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Background.MaintenanceTrigger", L"OneShot"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.OneShot());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MaintenanceTrigger(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Background::MaintenanceTrigger>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MaintenanceTrigger(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Background::MaintenanceTrigger>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MaintenanceTrigger[] = {
        { "_assign_array_", _assign_array_MaintenanceTrigger, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MaintenanceTrigger), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MaintenanceTrigger[] = {
        { "freshness_time", reinterpret_cast<getter>(MaintenanceTrigger_get_FreshnessTime), nullptr, nullptr, nullptr },
        { "one_shot", reinterpret_cast<getter>(MaintenanceTrigger_get_OneShot), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MaintenanceTrigger[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MaintenanceTrigger) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MaintenanceTrigger) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MaintenanceTrigger) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MaintenanceTrigger) },
        { },
    };

    static PyType_Spec type_spec_MaintenanceTrigger =
    {
        "winrt._winrt_windows_applicationmodel_background.MaintenanceTrigger",
        sizeof(py::wrapper::Windows::ApplicationModel::Background::MaintenanceTrigger),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MaintenanceTrigger
    };

    // ----- MediaProcessingTrigger class --------------------

    static PyObject* _new_MediaProcessingTrigger(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::ApplicationModel::Background::MediaProcessingTrigger instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_MediaProcessingTrigger(py::wrapper::Windows::ApplicationModel::Background::MediaProcessingTrigger* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MediaProcessingTrigger_RequestAsync(py::wrapper::Windows::ApplicationModel::Background::MediaProcessingTrigger* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Background.MediaProcessingTrigger", L"RequestAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.RequestAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Background.MediaProcessingTrigger", L"RequestAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::ValueSet>(args, 0);

                return py::convert(self->obj.RequestAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_MediaProcessingTrigger(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Background::MediaProcessingTrigger>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MediaProcessingTrigger(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Background::MediaProcessingTrigger>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MediaProcessingTrigger[] = {
        { "request_async", reinterpret_cast<PyCFunction>(MediaProcessingTrigger_RequestAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_MediaProcessingTrigger, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MediaProcessingTrigger), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MediaProcessingTrigger[] = {
        { }
    };

    static PyType_Slot _type_slots_MediaProcessingTrigger[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MediaProcessingTrigger) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MediaProcessingTrigger) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MediaProcessingTrigger) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MediaProcessingTrigger) },
        { },
    };

    static PyType_Spec type_spec_MediaProcessingTrigger =
    {
        "winrt._winrt_windows_applicationmodel_background.MediaProcessingTrigger",
        sizeof(py::wrapper::Windows::ApplicationModel::Background::MediaProcessingTrigger),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MediaProcessingTrigger
    };

    // ----- MobileBroadbandDeviceServiceNotificationTrigger class --------------------

    static PyObject* _new_MobileBroadbandDeviceServiceNotificationTrigger(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::ApplicationModel::Background::MobileBroadbandDeviceServiceNotificationTrigger instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_MobileBroadbandDeviceServiceNotificationTrigger(py::wrapper::Windows::ApplicationModel::Background::MobileBroadbandDeviceServiceNotificationTrigger* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_MobileBroadbandDeviceServiceNotificationTrigger(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Background::MobileBroadbandDeviceServiceNotificationTrigger>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MobileBroadbandDeviceServiceNotificationTrigger(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Background::MobileBroadbandDeviceServiceNotificationTrigger>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MobileBroadbandDeviceServiceNotificationTrigger[] = {
        { "_assign_array_", _assign_array_MobileBroadbandDeviceServiceNotificationTrigger, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MobileBroadbandDeviceServiceNotificationTrigger), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MobileBroadbandDeviceServiceNotificationTrigger[] = {
        { }
    };

    static PyType_Slot _type_slots_MobileBroadbandDeviceServiceNotificationTrigger[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MobileBroadbandDeviceServiceNotificationTrigger) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MobileBroadbandDeviceServiceNotificationTrigger) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MobileBroadbandDeviceServiceNotificationTrigger) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MobileBroadbandDeviceServiceNotificationTrigger) },
        { },
    };

    static PyType_Spec type_spec_MobileBroadbandDeviceServiceNotificationTrigger =
    {
        "winrt._winrt_windows_applicationmodel_background.MobileBroadbandDeviceServiceNotificationTrigger",
        sizeof(py::wrapper::Windows::ApplicationModel::Background::MobileBroadbandDeviceServiceNotificationTrigger),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MobileBroadbandDeviceServiceNotificationTrigger
    };

    // ----- MobileBroadbandPcoDataChangeTrigger class --------------------

    static PyObject* _new_MobileBroadbandPcoDataChangeTrigger(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::ApplicationModel::Background::MobileBroadbandPcoDataChangeTrigger instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_MobileBroadbandPcoDataChangeTrigger(py::wrapper::Windows::ApplicationModel::Background::MobileBroadbandPcoDataChangeTrigger* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_MobileBroadbandPcoDataChangeTrigger(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Background::MobileBroadbandPcoDataChangeTrigger>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MobileBroadbandPcoDataChangeTrigger(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Background::MobileBroadbandPcoDataChangeTrigger>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MobileBroadbandPcoDataChangeTrigger[] = {
        { "_assign_array_", _assign_array_MobileBroadbandPcoDataChangeTrigger, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MobileBroadbandPcoDataChangeTrigger), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MobileBroadbandPcoDataChangeTrigger[] = {
        { }
    };

    static PyType_Slot _type_slots_MobileBroadbandPcoDataChangeTrigger[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MobileBroadbandPcoDataChangeTrigger) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MobileBroadbandPcoDataChangeTrigger) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MobileBroadbandPcoDataChangeTrigger) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MobileBroadbandPcoDataChangeTrigger) },
        { },
    };

    static PyType_Spec type_spec_MobileBroadbandPcoDataChangeTrigger =
    {
        "winrt._winrt_windows_applicationmodel_background.MobileBroadbandPcoDataChangeTrigger",
        sizeof(py::wrapper::Windows::ApplicationModel::Background::MobileBroadbandPcoDataChangeTrigger),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MobileBroadbandPcoDataChangeTrigger
    };

    // ----- MobileBroadbandPinLockStateChangeTrigger class --------------------

    static PyObject* _new_MobileBroadbandPinLockStateChangeTrigger(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::ApplicationModel::Background::MobileBroadbandPinLockStateChangeTrigger instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_MobileBroadbandPinLockStateChangeTrigger(py::wrapper::Windows::ApplicationModel::Background::MobileBroadbandPinLockStateChangeTrigger* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_MobileBroadbandPinLockStateChangeTrigger(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Background::MobileBroadbandPinLockStateChangeTrigger>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MobileBroadbandPinLockStateChangeTrigger(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Background::MobileBroadbandPinLockStateChangeTrigger>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MobileBroadbandPinLockStateChangeTrigger[] = {
        { "_assign_array_", _assign_array_MobileBroadbandPinLockStateChangeTrigger, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MobileBroadbandPinLockStateChangeTrigger), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MobileBroadbandPinLockStateChangeTrigger[] = {
        { }
    };

    static PyType_Slot _type_slots_MobileBroadbandPinLockStateChangeTrigger[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MobileBroadbandPinLockStateChangeTrigger) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MobileBroadbandPinLockStateChangeTrigger) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MobileBroadbandPinLockStateChangeTrigger) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MobileBroadbandPinLockStateChangeTrigger) },
        { },
    };

    static PyType_Spec type_spec_MobileBroadbandPinLockStateChangeTrigger =
    {
        "winrt._winrt_windows_applicationmodel_background.MobileBroadbandPinLockStateChangeTrigger",
        sizeof(py::wrapper::Windows::ApplicationModel::Background::MobileBroadbandPinLockStateChangeTrigger),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MobileBroadbandPinLockStateChangeTrigger
    };

    // ----- MobileBroadbandRadioStateChangeTrigger class --------------------

    static PyObject* _new_MobileBroadbandRadioStateChangeTrigger(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::ApplicationModel::Background::MobileBroadbandRadioStateChangeTrigger instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_MobileBroadbandRadioStateChangeTrigger(py::wrapper::Windows::ApplicationModel::Background::MobileBroadbandRadioStateChangeTrigger* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_MobileBroadbandRadioStateChangeTrigger(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Background::MobileBroadbandRadioStateChangeTrigger>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MobileBroadbandRadioStateChangeTrigger(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Background::MobileBroadbandRadioStateChangeTrigger>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MobileBroadbandRadioStateChangeTrigger[] = {
        { "_assign_array_", _assign_array_MobileBroadbandRadioStateChangeTrigger, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MobileBroadbandRadioStateChangeTrigger), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MobileBroadbandRadioStateChangeTrigger[] = {
        { }
    };

    static PyType_Slot _type_slots_MobileBroadbandRadioStateChangeTrigger[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MobileBroadbandRadioStateChangeTrigger) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MobileBroadbandRadioStateChangeTrigger) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MobileBroadbandRadioStateChangeTrigger) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MobileBroadbandRadioStateChangeTrigger) },
        { },
    };

    static PyType_Spec type_spec_MobileBroadbandRadioStateChangeTrigger =
    {
        "winrt._winrt_windows_applicationmodel_background.MobileBroadbandRadioStateChangeTrigger",
        sizeof(py::wrapper::Windows::ApplicationModel::Background::MobileBroadbandRadioStateChangeTrigger),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MobileBroadbandRadioStateChangeTrigger
    };

    // ----- MobileBroadbandRegistrationStateChangeTrigger class --------------------

    static PyObject* _new_MobileBroadbandRegistrationStateChangeTrigger(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::ApplicationModel::Background::MobileBroadbandRegistrationStateChangeTrigger instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_MobileBroadbandRegistrationStateChangeTrigger(py::wrapper::Windows::ApplicationModel::Background::MobileBroadbandRegistrationStateChangeTrigger* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_MobileBroadbandRegistrationStateChangeTrigger(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Background::MobileBroadbandRegistrationStateChangeTrigger>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MobileBroadbandRegistrationStateChangeTrigger(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Background::MobileBroadbandRegistrationStateChangeTrigger>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MobileBroadbandRegistrationStateChangeTrigger[] = {
        { "_assign_array_", _assign_array_MobileBroadbandRegistrationStateChangeTrigger, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MobileBroadbandRegistrationStateChangeTrigger), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MobileBroadbandRegistrationStateChangeTrigger[] = {
        { }
    };

    static PyType_Slot _type_slots_MobileBroadbandRegistrationStateChangeTrigger[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MobileBroadbandRegistrationStateChangeTrigger) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MobileBroadbandRegistrationStateChangeTrigger) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MobileBroadbandRegistrationStateChangeTrigger) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MobileBroadbandRegistrationStateChangeTrigger) },
        { },
    };

    static PyType_Spec type_spec_MobileBroadbandRegistrationStateChangeTrigger =
    {
        "winrt._winrt_windows_applicationmodel_background.MobileBroadbandRegistrationStateChangeTrigger",
        sizeof(py::wrapper::Windows::ApplicationModel::Background::MobileBroadbandRegistrationStateChangeTrigger),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MobileBroadbandRegistrationStateChangeTrigger
    };

    // ----- NetworkOperatorDataUsageTrigger class --------------------

    static PyObject* _new_NetworkOperatorDataUsageTrigger(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::ApplicationModel::Background::NetworkOperatorDataUsageTrigger instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_NetworkOperatorDataUsageTrigger(py::wrapper::Windows::ApplicationModel::Background::NetworkOperatorDataUsageTrigger* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_NetworkOperatorDataUsageTrigger(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Background::NetworkOperatorDataUsageTrigger>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_NetworkOperatorDataUsageTrigger(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Background::NetworkOperatorDataUsageTrigger>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_NetworkOperatorDataUsageTrigger[] = {
        { "_assign_array_", _assign_array_NetworkOperatorDataUsageTrigger, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_NetworkOperatorDataUsageTrigger), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_NetworkOperatorDataUsageTrigger[] = {
        { }
    };

    static PyType_Slot _type_slots_NetworkOperatorDataUsageTrigger[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_NetworkOperatorDataUsageTrigger) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_NetworkOperatorDataUsageTrigger) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_NetworkOperatorDataUsageTrigger) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_NetworkOperatorDataUsageTrigger) },
        { },
    };

    static PyType_Spec type_spec_NetworkOperatorDataUsageTrigger =
    {
        "winrt._winrt_windows_applicationmodel_background.NetworkOperatorDataUsageTrigger",
        sizeof(py::wrapper::Windows::ApplicationModel::Background::NetworkOperatorDataUsageTrigger),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_NetworkOperatorDataUsageTrigger
    };

    // ----- NetworkOperatorHotspotAuthenticationTrigger class --------------------

    static PyObject* _new_NetworkOperatorHotspotAuthenticationTrigger(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::ApplicationModel::Background::NetworkOperatorHotspotAuthenticationTrigger instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_NetworkOperatorHotspotAuthenticationTrigger(py::wrapper::Windows::ApplicationModel::Background::NetworkOperatorHotspotAuthenticationTrigger* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_NetworkOperatorHotspotAuthenticationTrigger(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Background::NetworkOperatorHotspotAuthenticationTrigger>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_NetworkOperatorHotspotAuthenticationTrigger(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Background::NetworkOperatorHotspotAuthenticationTrigger>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_NetworkOperatorHotspotAuthenticationTrigger[] = {
        { "_assign_array_", _assign_array_NetworkOperatorHotspotAuthenticationTrigger, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_NetworkOperatorHotspotAuthenticationTrigger), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_NetworkOperatorHotspotAuthenticationTrigger[] = {
        { }
    };

    static PyType_Slot _type_slots_NetworkOperatorHotspotAuthenticationTrigger[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_NetworkOperatorHotspotAuthenticationTrigger) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_NetworkOperatorHotspotAuthenticationTrigger) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_NetworkOperatorHotspotAuthenticationTrigger) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_NetworkOperatorHotspotAuthenticationTrigger) },
        { },
    };

    static PyType_Spec type_spec_NetworkOperatorHotspotAuthenticationTrigger =
    {
        "winrt._winrt_windows_applicationmodel_background.NetworkOperatorHotspotAuthenticationTrigger",
        sizeof(py::wrapper::Windows::ApplicationModel::Background::NetworkOperatorHotspotAuthenticationTrigger),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_NetworkOperatorHotspotAuthenticationTrigger
    };

    // ----- NetworkOperatorNotificationTrigger class --------------------

    static PyObject* _new_NetworkOperatorNotificationTrigger(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                winrt::Windows::ApplicationModel::Background::NetworkOperatorNotificationTrigger instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_NetworkOperatorNotificationTrigger(py::wrapper::Windows::ApplicationModel::Background::NetworkOperatorNotificationTrigger* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* NetworkOperatorNotificationTrigger_get_NetworkAccountId(py::wrapper::Windows::ApplicationModel::Background::NetworkOperatorNotificationTrigger* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Background.NetworkOperatorNotificationTrigger", L"NetworkAccountId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.NetworkAccountId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_NetworkOperatorNotificationTrigger(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Background::NetworkOperatorNotificationTrigger>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_NetworkOperatorNotificationTrigger(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Background::NetworkOperatorNotificationTrigger>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_NetworkOperatorNotificationTrigger[] = {
        { "_assign_array_", _assign_array_NetworkOperatorNotificationTrigger, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_NetworkOperatorNotificationTrigger), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_NetworkOperatorNotificationTrigger[] = {
        { "network_account_id", reinterpret_cast<getter>(NetworkOperatorNotificationTrigger_get_NetworkAccountId), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_NetworkOperatorNotificationTrigger[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_NetworkOperatorNotificationTrigger) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_NetworkOperatorNotificationTrigger) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_NetworkOperatorNotificationTrigger) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_NetworkOperatorNotificationTrigger) },
        { },
    };

    static PyType_Spec type_spec_NetworkOperatorNotificationTrigger =
    {
        "winrt._winrt_windows_applicationmodel_background.NetworkOperatorNotificationTrigger",
        sizeof(py::wrapper::Windows::ApplicationModel::Background::NetworkOperatorNotificationTrigger),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_NetworkOperatorNotificationTrigger
    };

    // ----- PaymentAppCanMakePaymentTrigger class --------------------

    static PyObject* _new_PaymentAppCanMakePaymentTrigger(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::ApplicationModel::Background::PaymentAppCanMakePaymentTrigger instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_PaymentAppCanMakePaymentTrigger(py::wrapper::Windows::ApplicationModel::Background::PaymentAppCanMakePaymentTrigger* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_PaymentAppCanMakePaymentTrigger(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Background::PaymentAppCanMakePaymentTrigger>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PaymentAppCanMakePaymentTrigger(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Background::PaymentAppCanMakePaymentTrigger>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PaymentAppCanMakePaymentTrigger[] = {
        { "_assign_array_", _assign_array_PaymentAppCanMakePaymentTrigger, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PaymentAppCanMakePaymentTrigger), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PaymentAppCanMakePaymentTrigger[] = {
        { }
    };

    static PyType_Slot _type_slots_PaymentAppCanMakePaymentTrigger[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PaymentAppCanMakePaymentTrigger) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PaymentAppCanMakePaymentTrigger) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PaymentAppCanMakePaymentTrigger) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PaymentAppCanMakePaymentTrigger) },
        { },
    };

    static PyType_Spec type_spec_PaymentAppCanMakePaymentTrigger =
    {
        "winrt._winrt_windows_applicationmodel_background.PaymentAppCanMakePaymentTrigger",
        sizeof(py::wrapper::Windows::ApplicationModel::Background::PaymentAppCanMakePaymentTrigger),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PaymentAppCanMakePaymentTrigger
    };

    // ----- PhoneTrigger class --------------------

    static PyObject* _new_PhoneTrigger(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Calls::Background::PhoneTriggerType>(args, 0);
                auto param1 = py::convert_to<bool>(args, 1);

                winrt::Windows::ApplicationModel::Background::PhoneTrigger instance{ param0, param1 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_PhoneTrigger(py::wrapper::Windows::ApplicationModel::Background::PhoneTrigger* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PhoneTrigger_get_OneShot(py::wrapper::Windows::ApplicationModel::Background::PhoneTrigger* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Background.PhoneTrigger", L"OneShot"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.OneShot());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneTrigger_get_TriggerType(py::wrapper::Windows::ApplicationModel::Background::PhoneTrigger* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Background.PhoneTrigger", L"TriggerType"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.TriggerType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PhoneTrigger(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Background::PhoneTrigger>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PhoneTrigger(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Background::PhoneTrigger>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PhoneTrigger[] = {
        { "_assign_array_", _assign_array_PhoneTrigger, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PhoneTrigger), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PhoneTrigger[] = {
        { "one_shot", reinterpret_cast<getter>(PhoneTrigger_get_OneShot), nullptr, nullptr, nullptr },
        { "trigger_type", reinterpret_cast<getter>(PhoneTrigger_get_TriggerType), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PhoneTrigger[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PhoneTrigger) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PhoneTrigger) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PhoneTrigger) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PhoneTrigger) },
        { },
    };

    static PyType_Spec type_spec_PhoneTrigger =
    {
        "winrt._winrt_windows_applicationmodel_background.PhoneTrigger",
        sizeof(py::wrapper::Windows::ApplicationModel::Background::PhoneTrigger),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PhoneTrigger
    };

    // ----- PushNotificationTrigger class --------------------

    static PyObject* _new_PushNotificationTrigger(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                winrt::Windows::ApplicationModel::Background::PushNotificationTrigger instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 0)
        {
            try
            {
                winrt::Windows::ApplicationModel::Background::PushNotificationTrigger instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_PushNotificationTrigger(py::wrapper::Windows::ApplicationModel::Background::PushNotificationTrigger* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_PushNotificationTrigger(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Background::PushNotificationTrigger>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PushNotificationTrigger(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Background::PushNotificationTrigger>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PushNotificationTrigger[] = {
        { "_assign_array_", _assign_array_PushNotificationTrigger, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PushNotificationTrigger), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PushNotificationTrigger[] = {
        { }
    };

    static PyType_Slot _type_slots_PushNotificationTrigger[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PushNotificationTrigger) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PushNotificationTrigger) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PushNotificationTrigger) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PushNotificationTrigger) },
        { },
    };

    static PyType_Spec type_spec_PushNotificationTrigger =
    {
        "winrt._winrt_windows_applicationmodel_background.PushNotificationTrigger",
        sizeof(py::wrapper::Windows::ApplicationModel::Background::PushNotificationTrigger),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PushNotificationTrigger
    };

    // ----- RcsEndUserMessageAvailableTrigger class --------------------

    static PyObject* _new_RcsEndUserMessageAvailableTrigger(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::ApplicationModel::Background::RcsEndUserMessageAvailableTrigger instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_RcsEndUserMessageAvailableTrigger(py::wrapper::Windows::ApplicationModel::Background::RcsEndUserMessageAvailableTrigger* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_RcsEndUserMessageAvailableTrigger(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Background::RcsEndUserMessageAvailableTrigger>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_RcsEndUserMessageAvailableTrigger(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Background::RcsEndUserMessageAvailableTrigger>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_RcsEndUserMessageAvailableTrigger[] = {
        { "_assign_array_", _assign_array_RcsEndUserMessageAvailableTrigger, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_RcsEndUserMessageAvailableTrigger), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_RcsEndUserMessageAvailableTrigger[] = {
        { }
    };

    static PyType_Slot _type_slots_RcsEndUserMessageAvailableTrigger[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_RcsEndUserMessageAvailableTrigger) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_RcsEndUserMessageAvailableTrigger) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_RcsEndUserMessageAvailableTrigger) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_RcsEndUserMessageAvailableTrigger) },
        { },
    };

    static PyType_Spec type_spec_RcsEndUserMessageAvailableTrigger =
    {
        "winrt._winrt_windows_applicationmodel_background.RcsEndUserMessageAvailableTrigger",
        sizeof(py::wrapper::Windows::ApplicationModel::Background::RcsEndUserMessageAvailableTrigger),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_RcsEndUserMessageAvailableTrigger
    };

    // ----- RfcommConnectionTrigger class --------------------

    static PyObject* _new_RfcommConnectionTrigger(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::ApplicationModel::Background::RfcommConnectionTrigger instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_RfcommConnectionTrigger(py::wrapper::Windows::ApplicationModel::Background::RfcommConnectionTrigger* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* RfcommConnectionTrigger_get_RemoteHostName(py::wrapper::Windows::ApplicationModel::Background::RfcommConnectionTrigger* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Background.RfcommConnectionTrigger", L"RemoteHostName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.RemoteHostName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int RfcommConnectionTrigger_put_RemoteHostName(py::wrapper::Windows::ApplicationModel::Background::RfcommConnectionTrigger* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Background.RfcommConnectionTrigger", L"RemoteHostName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Networking::HostName>(arg);

            self->obj.RemoteHostName(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* RfcommConnectionTrigger_get_ProtectionLevel(py::wrapper::Windows::ApplicationModel::Background::RfcommConnectionTrigger* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Background.RfcommConnectionTrigger", L"ProtectionLevel"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ProtectionLevel());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int RfcommConnectionTrigger_put_ProtectionLevel(py::wrapper::Windows::ApplicationModel::Background::RfcommConnectionTrigger* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Background.RfcommConnectionTrigger", L"ProtectionLevel"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Networking::Sockets::SocketProtectionLevel>(arg);

            self->obj.ProtectionLevel(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* RfcommConnectionTrigger_get_AllowMultipleConnections(py::wrapper::Windows::ApplicationModel::Background::RfcommConnectionTrigger* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Background.RfcommConnectionTrigger", L"AllowMultipleConnections"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AllowMultipleConnections());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int RfcommConnectionTrigger_put_AllowMultipleConnections(py::wrapper::Windows::ApplicationModel::Background::RfcommConnectionTrigger* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Background.RfcommConnectionTrigger", L"AllowMultipleConnections"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.AllowMultipleConnections(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* RfcommConnectionTrigger_get_InboundConnection(py::wrapper::Windows::ApplicationModel::Background::RfcommConnectionTrigger* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Background.RfcommConnectionTrigger", L"InboundConnection"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.InboundConnection());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RfcommConnectionTrigger_get_OutboundConnection(py::wrapper::Windows::ApplicationModel::Background::RfcommConnectionTrigger* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Background.RfcommConnectionTrigger", L"OutboundConnection"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.OutboundConnection());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_RfcommConnectionTrigger(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Background::RfcommConnectionTrigger>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_RfcommConnectionTrigger(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Background::RfcommConnectionTrigger>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_RfcommConnectionTrigger[] = {
        { "_assign_array_", _assign_array_RfcommConnectionTrigger, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_RfcommConnectionTrigger), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_RfcommConnectionTrigger[] = {
        { "remote_host_name", reinterpret_cast<getter>(RfcommConnectionTrigger_get_RemoteHostName), reinterpret_cast<setter>(RfcommConnectionTrigger_put_RemoteHostName), nullptr, nullptr },
        { "protection_level", reinterpret_cast<getter>(RfcommConnectionTrigger_get_ProtectionLevel), reinterpret_cast<setter>(RfcommConnectionTrigger_put_ProtectionLevel), nullptr, nullptr },
        { "allow_multiple_connections", reinterpret_cast<getter>(RfcommConnectionTrigger_get_AllowMultipleConnections), reinterpret_cast<setter>(RfcommConnectionTrigger_put_AllowMultipleConnections), nullptr, nullptr },
        { "inbound_connection", reinterpret_cast<getter>(RfcommConnectionTrigger_get_InboundConnection), nullptr, nullptr, nullptr },
        { "outbound_connection", reinterpret_cast<getter>(RfcommConnectionTrigger_get_OutboundConnection), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_RfcommConnectionTrigger[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_RfcommConnectionTrigger) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_RfcommConnectionTrigger) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_RfcommConnectionTrigger) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_RfcommConnectionTrigger) },
        { },
    };

    static PyType_Spec type_spec_RfcommConnectionTrigger =
    {
        "winrt._winrt_windows_applicationmodel_background.RfcommConnectionTrigger",
        sizeof(py::wrapper::Windows::ApplicationModel::Background::RfcommConnectionTrigger),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_RfcommConnectionTrigger
    };

    // ----- SecondaryAuthenticationFactorAuthenticationTrigger class --------------------

    static PyObject* _new_SecondaryAuthenticationFactorAuthenticationTrigger(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::ApplicationModel::Background::SecondaryAuthenticationFactorAuthenticationTrigger instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_SecondaryAuthenticationFactorAuthenticationTrigger(py::wrapper::Windows::ApplicationModel::Background::SecondaryAuthenticationFactorAuthenticationTrigger* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_SecondaryAuthenticationFactorAuthenticationTrigger(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Background::SecondaryAuthenticationFactorAuthenticationTrigger>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SecondaryAuthenticationFactorAuthenticationTrigger(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Background::SecondaryAuthenticationFactorAuthenticationTrigger>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SecondaryAuthenticationFactorAuthenticationTrigger[] = {
        { "_assign_array_", _assign_array_SecondaryAuthenticationFactorAuthenticationTrigger, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SecondaryAuthenticationFactorAuthenticationTrigger), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SecondaryAuthenticationFactorAuthenticationTrigger[] = {
        { }
    };

    static PyType_Slot _type_slots_SecondaryAuthenticationFactorAuthenticationTrigger[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_SecondaryAuthenticationFactorAuthenticationTrigger) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SecondaryAuthenticationFactorAuthenticationTrigger) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SecondaryAuthenticationFactorAuthenticationTrigger) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SecondaryAuthenticationFactorAuthenticationTrigger) },
        { },
    };

    static PyType_Spec type_spec_SecondaryAuthenticationFactorAuthenticationTrigger =
    {
        "winrt._winrt_windows_applicationmodel_background.SecondaryAuthenticationFactorAuthenticationTrigger",
        sizeof(py::wrapper::Windows::ApplicationModel::Background::SecondaryAuthenticationFactorAuthenticationTrigger),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SecondaryAuthenticationFactorAuthenticationTrigger
    };

    // ----- SensorDataThresholdTrigger class --------------------

    static PyObject* _new_SensorDataThresholdTrigger(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Sensors::ISensorDataThreshold>(args, 0);

                winrt::Windows::ApplicationModel::Background::SensorDataThresholdTrigger instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_SensorDataThresholdTrigger(py::wrapper::Windows::ApplicationModel::Background::SensorDataThresholdTrigger* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_SensorDataThresholdTrigger(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Background::SensorDataThresholdTrigger>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SensorDataThresholdTrigger(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Background::SensorDataThresholdTrigger>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SensorDataThresholdTrigger[] = {
        { "_assign_array_", _assign_array_SensorDataThresholdTrigger, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SensorDataThresholdTrigger), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SensorDataThresholdTrigger[] = {
        { }
    };

    static PyType_Slot _type_slots_SensorDataThresholdTrigger[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_SensorDataThresholdTrigger) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SensorDataThresholdTrigger) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SensorDataThresholdTrigger) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SensorDataThresholdTrigger) },
        { },
    };

    static PyType_Spec type_spec_SensorDataThresholdTrigger =
    {
        "winrt._winrt_windows_applicationmodel_background.SensorDataThresholdTrigger",
        sizeof(py::wrapper::Windows::ApplicationModel::Background::SensorDataThresholdTrigger),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SensorDataThresholdTrigger
    };

    // ----- SmartCardTrigger class --------------------

    static PyObject* _new_SmartCardTrigger(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::SmartCards::SmartCardTriggerType>(args, 0);

                winrt::Windows::ApplicationModel::Background::SmartCardTrigger instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_SmartCardTrigger(py::wrapper::Windows::ApplicationModel::Background::SmartCardTrigger* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SmartCardTrigger_get_TriggerType(py::wrapper::Windows::ApplicationModel::Background::SmartCardTrigger* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Background.SmartCardTrigger", L"TriggerType"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.TriggerType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SmartCardTrigger(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Background::SmartCardTrigger>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SmartCardTrigger(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Background::SmartCardTrigger>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SmartCardTrigger[] = {
        { "_assign_array_", _assign_array_SmartCardTrigger, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SmartCardTrigger), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SmartCardTrigger[] = {
        { "trigger_type", reinterpret_cast<getter>(SmartCardTrigger_get_TriggerType), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SmartCardTrigger[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_SmartCardTrigger) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SmartCardTrigger) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SmartCardTrigger) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SmartCardTrigger) },
        { },
    };

    static PyType_Spec type_spec_SmartCardTrigger =
    {
        "winrt._winrt_windows_applicationmodel_background.SmartCardTrigger",
        sizeof(py::wrapper::Windows::ApplicationModel::Background::SmartCardTrigger),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SmartCardTrigger
    };

    // ----- SmsMessageReceivedTrigger class --------------------

    static PyObject* _new_SmsMessageReceivedTrigger(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Sms::SmsFilterRules>(args, 0);

                winrt::Windows::ApplicationModel::Background::SmsMessageReceivedTrigger instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_SmsMessageReceivedTrigger(py::wrapper::Windows::ApplicationModel::Background::SmsMessageReceivedTrigger* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_SmsMessageReceivedTrigger(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Background::SmsMessageReceivedTrigger>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SmsMessageReceivedTrigger(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Background::SmsMessageReceivedTrigger>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SmsMessageReceivedTrigger[] = {
        { "_assign_array_", _assign_array_SmsMessageReceivedTrigger, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SmsMessageReceivedTrigger), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SmsMessageReceivedTrigger[] = {
        { }
    };

    static PyType_Slot _type_slots_SmsMessageReceivedTrigger[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_SmsMessageReceivedTrigger) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SmsMessageReceivedTrigger) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SmsMessageReceivedTrigger) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SmsMessageReceivedTrigger) },
        { },
    };

    static PyType_Spec type_spec_SmsMessageReceivedTrigger =
    {
        "winrt._winrt_windows_applicationmodel_background.SmsMessageReceivedTrigger",
        sizeof(py::wrapper::Windows::ApplicationModel::Background::SmsMessageReceivedTrigger),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SmsMessageReceivedTrigger
    };

    // ----- SocketActivityTrigger class --------------------

    static PyObject* _new_SocketActivityTrigger(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::ApplicationModel::Background::SocketActivityTrigger instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_SocketActivityTrigger(py::wrapper::Windows::ApplicationModel::Background::SocketActivityTrigger* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SocketActivityTrigger_get_IsWakeFromLowPowerSupported(py::wrapper::Windows::ApplicationModel::Background::SocketActivityTrigger* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Background.SocketActivityTrigger", L"IsWakeFromLowPowerSupported"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsWakeFromLowPowerSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SocketActivityTrigger(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Background::SocketActivityTrigger>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SocketActivityTrigger(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Background::SocketActivityTrigger>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SocketActivityTrigger[] = {
        { "_assign_array_", _assign_array_SocketActivityTrigger, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SocketActivityTrigger), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SocketActivityTrigger[] = {
        { "is_wake_from_low_power_supported", reinterpret_cast<getter>(SocketActivityTrigger_get_IsWakeFromLowPowerSupported), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SocketActivityTrigger[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_SocketActivityTrigger) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SocketActivityTrigger) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SocketActivityTrigger) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SocketActivityTrigger) },
        { },
    };

    static PyType_Spec type_spec_SocketActivityTrigger =
    {
        "winrt._winrt_windows_applicationmodel_background.SocketActivityTrigger",
        sizeof(py::wrapper::Windows::ApplicationModel::Background::SocketActivityTrigger),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SocketActivityTrigger
    };

    // ----- StorageLibraryChangeTrackerTrigger class --------------------

    static PyObject* _new_StorageLibraryChangeTrackerTrigger(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::StorageLibraryChangeTracker>(args, 0);

                winrt::Windows::ApplicationModel::Background::StorageLibraryChangeTrackerTrigger instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_StorageLibraryChangeTrackerTrigger(py::wrapper::Windows::ApplicationModel::Background::StorageLibraryChangeTrackerTrigger* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_StorageLibraryChangeTrackerTrigger(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Background::StorageLibraryChangeTrackerTrigger>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_StorageLibraryChangeTrackerTrigger(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Background::StorageLibraryChangeTrackerTrigger>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StorageLibraryChangeTrackerTrigger[] = {
        { "_assign_array_", _assign_array_StorageLibraryChangeTrackerTrigger, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_StorageLibraryChangeTrackerTrigger), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_StorageLibraryChangeTrackerTrigger[] = {
        { }
    };

    static PyType_Slot _type_slots_StorageLibraryChangeTrackerTrigger[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_StorageLibraryChangeTrackerTrigger) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_StorageLibraryChangeTrackerTrigger) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_StorageLibraryChangeTrackerTrigger) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_StorageLibraryChangeTrackerTrigger) },
        { },
    };

    static PyType_Spec type_spec_StorageLibraryChangeTrackerTrigger =
    {
        "winrt._winrt_windows_applicationmodel_background.StorageLibraryChangeTrackerTrigger",
        sizeof(py::wrapper::Windows::ApplicationModel::Background::StorageLibraryChangeTrackerTrigger),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StorageLibraryChangeTrackerTrigger
    };

    // ----- StorageLibraryContentChangedTrigger class --------------------

    static PyObject* _new_StorageLibraryContentChangedTrigger(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Background::StorageLibraryContentChangedTrigger>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Background::StorageLibraryContentChangedTrigger>::type_name);
        return nullptr;
    }

    static void _dealloc_StorageLibraryContentChangedTrigger(py::wrapper::Windows::ApplicationModel::Background::StorageLibraryContentChangedTrigger* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* StorageLibraryContentChangedTrigger_Create(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Background.StorageLibraryContentChangedTrigger", L"Create", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::StorageLibrary>(args, 0);

                return py::convert(winrt::Windows::ApplicationModel::Background::StorageLibraryContentChangedTrigger::Create(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageLibraryContentChangedTrigger_CreateFromLibraries(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Background.StorageLibraryContentChangedTrigger", L"CreateFromLibraries", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Storage::StorageLibrary>>(args, 0);

                return py::convert(winrt::Windows::ApplicationModel::Background::StorageLibraryContentChangedTrigger::CreateFromLibraries(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_StorageLibraryContentChangedTrigger(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Background::StorageLibraryContentChangedTrigger>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_StorageLibraryContentChangedTrigger(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Background::StorageLibraryContentChangedTrigger>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StorageLibraryContentChangedTrigger[] = {
        { "_assign_array_", _assign_array_StorageLibraryContentChangedTrigger, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_StorageLibraryContentChangedTrigger), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_StorageLibraryContentChangedTrigger[] = {
        { }
    };

    static PyType_Slot _type_slots_StorageLibraryContentChangedTrigger[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_StorageLibraryContentChangedTrigger) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_StorageLibraryContentChangedTrigger) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_StorageLibraryContentChangedTrigger) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_StorageLibraryContentChangedTrigger) },
        { },
    };

    static PyType_Spec type_spec_StorageLibraryContentChangedTrigger =
    {
        "winrt._winrt_windows_applicationmodel_background.StorageLibraryContentChangedTrigger",
        sizeof(py::wrapper::Windows::ApplicationModel::Background::StorageLibraryContentChangedTrigger),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StorageLibraryContentChangedTrigger
    };

    static PyGetSetDef getset_StorageLibraryContentChangedTrigger_Static[] = {
        { }
    };

    static PyMethodDef methods_StorageLibraryContentChangedTrigger_Static[] = {
        { "create", reinterpret_cast<PyCFunction>(StorageLibraryContentChangedTrigger_Create), METH_VARARGS, nullptr },
        { "create_from_libraries", reinterpret_cast<PyCFunction>(StorageLibraryContentChangedTrigger_CreateFromLibraries), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_StorageLibraryContentChangedTrigger_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_StorageLibraryContentChangedTrigger_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_StorageLibraryContentChangedTrigger_Static) },
        { }
    };

    static PyType_Spec type_spec_StorageLibraryContentChangedTrigger_Static =
    {
        "winrt._winrt_windows_applicationmodel_background.StorageLibraryContentChangedTrigger_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_StorageLibraryContentChangedTrigger_Static
    };

    // ----- SystemCondition class --------------------

    static PyObject* _new_SystemCondition(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Background::SystemConditionType>(args, 0);

                winrt::Windows::ApplicationModel::Background::SystemCondition instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_SystemCondition(py::wrapper::Windows::ApplicationModel::Background::SystemCondition* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SystemCondition_get_ConditionType(py::wrapper::Windows::ApplicationModel::Background::SystemCondition* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Background.SystemCondition", L"ConditionType"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ConditionType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SystemCondition(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Background::SystemCondition>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SystemCondition(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Background::SystemCondition>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SystemCondition[] = {
        { "_assign_array_", _assign_array_SystemCondition, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SystemCondition), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SystemCondition[] = {
        { "condition_type", reinterpret_cast<getter>(SystemCondition_get_ConditionType), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SystemCondition[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_SystemCondition) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SystemCondition) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SystemCondition) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SystemCondition) },
        { },
    };

    static PyType_Spec type_spec_SystemCondition =
    {
        "winrt._winrt_windows_applicationmodel_background.SystemCondition",
        sizeof(py::wrapper::Windows::ApplicationModel::Background::SystemCondition),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SystemCondition
    };

    // ----- SystemTrigger class --------------------

    static PyObject* _new_SystemTrigger(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Background::SystemTriggerType>(args, 0);
                auto param1 = py::convert_to<bool>(args, 1);

                winrt::Windows::ApplicationModel::Background::SystemTrigger instance{ param0, param1 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_SystemTrigger(py::wrapper::Windows::ApplicationModel::Background::SystemTrigger* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SystemTrigger_get_OneShot(py::wrapper::Windows::ApplicationModel::Background::SystemTrigger* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Background.SystemTrigger", L"OneShot"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.OneShot());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SystemTrigger_get_TriggerType(py::wrapper::Windows::ApplicationModel::Background::SystemTrigger* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Background.SystemTrigger", L"TriggerType"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.TriggerType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SystemTrigger(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Background::SystemTrigger>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SystemTrigger(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Background::SystemTrigger>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SystemTrigger[] = {
        { "_assign_array_", _assign_array_SystemTrigger, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SystemTrigger), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SystemTrigger[] = {
        { "one_shot", reinterpret_cast<getter>(SystemTrigger_get_OneShot), nullptr, nullptr, nullptr },
        { "trigger_type", reinterpret_cast<getter>(SystemTrigger_get_TriggerType), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SystemTrigger[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_SystemTrigger) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SystemTrigger) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SystemTrigger) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SystemTrigger) },
        { },
    };

    static PyType_Spec type_spec_SystemTrigger =
    {
        "winrt._winrt_windows_applicationmodel_background.SystemTrigger",
        sizeof(py::wrapper::Windows::ApplicationModel::Background::SystemTrigger),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SystemTrigger
    };

    // ----- TetheringEntitlementCheckTrigger class --------------------

    static PyObject* _new_TetheringEntitlementCheckTrigger(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::ApplicationModel::Background::TetheringEntitlementCheckTrigger instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_TetheringEntitlementCheckTrigger(py::wrapper::Windows::ApplicationModel::Background::TetheringEntitlementCheckTrigger* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_TetheringEntitlementCheckTrigger(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Background::TetheringEntitlementCheckTrigger>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_TetheringEntitlementCheckTrigger(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Background::TetheringEntitlementCheckTrigger>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_TetheringEntitlementCheckTrigger[] = {
        { "_assign_array_", _assign_array_TetheringEntitlementCheckTrigger, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_TetheringEntitlementCheckTrigger), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_TetheringEntitlementCheckTrigger[] = {
        { }
    };

    static PyType_Slot _type_slots_TetheringEntitlementCheckTrigger[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_TetheringEntitlementCheckTrigger) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_TetheringEntitlementCheckTrigger) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_TetheringEntitlementCheckTrigger) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_TetheringEntitlementCheckTrigger) },
        { },
    };

    static PyType_Spec type_spec_TetheringEntitlementCheckTrigger =
    {
        "winrt._winrt_windows_applicationmodel_background.TetheringEntitlementCheckTrigger",
        sizeof(py::wrapper::Windows::ApplicationModel::Background::TetheringEntitlementCheckTrigger),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TetheringEntitlementCheckTrigger
    };

    // ----- TimeTrigger class --------------------

    static PyObject* _new_TimeTrigger(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<bool>(args, 1);

                winrt::Windows::ApplicationModel::Background::TimeTrigger instance{ param0, param1 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_TimeTrigger(py::wrapper::Windows::ApplicationModel::Background::TimeTrigger* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* TimeTrigger_get_FreshnessTime(py::wrapper::Windows::ApplicationModel::Background::TimeTrigger* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Background.TimeTrigger", L"FreshnessTime"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.FreshnessTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TimeTrigger_get_OneShot(py::wrapper::Windows::ApplicationModel::Background::TimeTrigger* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Background.TimeTrigger", L"OneShot"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.OneShot());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_TimeTrigger(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Background::TimeTrigger>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_TimeTrigger(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Background::TimeTrigger>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_TimeTrigger[] = {
        { "_assign_array_", _assign_array_TimeTrigger, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_TimeTrigger), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_TimeTrigger[] = {
        { "freshness_time", reinterpret_cast<getter>(TimeTrigger_get_FreshnessTime), nullptr, nullptr, nullptr },
        { "one_shot", reinterpret_cast<getter>(TimeTrigger_get_OneShot), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_TimeTrigger[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_TimeTrigger) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_TimeTrigger) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_TimeTrigger) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_TimeTrigger) },
        { },
    };

    static PyType_Spec type_spec_TimeTrigger =
    {
        "winrt._winrt_windows_applicationmodel_background.TimeTrigger",
        sizeof(py::wrapper::Windows::ApplicationModel::Background::TimeTrigger),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TimeTrigger
    };

    // ----- ToastNotificationActionTrigger class --------------------

    static PyObject* _new_ToastNotificationActionTrigger(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                winrt::Windows::ApplicationModel::Background::ToastNotificationActionTrigger instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 0)
        {
            try
            {
                winrt::Windows::ApplicationModel::Background::ToastNotificationActionTrigger instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ToastNotificationActionTrigger(py::wrapper::Windows::ApplicationModel::Background::ToastNotificationActionTrigger* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_ToastNotificationActionTrigger(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Background::ToastNotificationActionTrigger>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ToastNotificationActionTrigger(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Background::ToastNotificationActionTrigger>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ToastNotificationActionTrigger[] = {
        { "_assign_array_", _assign_array_ToastNotificationActionTrigger, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ToastNotificationActionTrigger), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ToastNotificationActionTrigger[] = {
        { }
    };

    static PyType_Slot _type_slots_ToastNotificationActionTrigger[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ToastNotificationActionTrigger) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ToastNotificationActionTrigger) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ToastNotificationActionTrigger) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ToastNotificationActionTrigger) },
        { },
    };

    static PyType_Spec type_spec_ToastNotificationActionTrigger =
    {
        "winrt._winrt_windows_applicationmodel_background.ToastNotificationActionTrigger",
        sizeof(py::wrapper::Windows::ApplicationModel::Background::ToastNotificationActionTrigger),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ToastNotificationActionTrigger
    };

    // ----- ToastNotificationHistoryChangedTrigger class --------------------

    static PyObject* _new_ToastNotificationHistoryChangedTrigger(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                winrt::Windows::ApplicationModel::Background::ToastNotificationHistoryChangedTrigger instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 0)
        {
            try
            {
                winrt::Windows::ApplicationModel::Background::ToastNotificationHistoryChangedTrigger instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ToastNotificationHistoryChangedTrigger(py::wrapper::Windows::ApplicationModel::Background::ToastNotificationHistoryChangedTrigger* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_ToastNotificationHistoryChangedTrigger(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Background::ToastNotificationHistoryChangedTrigger>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ToastNotificationHistoryChangedTrigger(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Background::ToastNotificationHistoryChangedTrigger>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ToastNotificationHistoryChangedTrigger[] = {
        { "_assign_array_", _assign_array_ToastNotificationHistoryChangedTrigger, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ToastNotificationHistoryChangedTrigger), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ToastNotificationHistoryChangedTrigger[] = {
        { }
    };

    static PyType_Slot _type_slots_ToastNotificationHistoryChangedTrigger[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ToastNotificationHistoryChangedTrigger) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ToastNotificationHistoryChangedTrigger) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ToastNotificationHistoryChangedTrigger) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ToastNotificationHistoryChangedTrigger) },
        { },
    };

    static PyType_Spec type_spec_ToastNotificationHistoryChangedTrigger =
    {
        "winrt._winrt_windows_applicationmodel_background.ToastNotificationHistoryChangedTrigger",
        sizeof(py::wrapper::Windows::ApplicationModel::Background::ToastNotificationHistoryChangedTrigger),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ToastNotificationHistoryChangedTrigger
    };

    // ----- UserNotificationChangedTrigger class --------------------

    static PyObject* _new_UserNotificationChangedTrigger(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Notifications::NotificationKinds>(args, 0);

                winrt::Windows::ApplicationModel::Background::UserNotificationChangedTrigger instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_UserNotificationChangedTrigger(py::wrapper::Windows::ApplicationModel::Background::UserNotificationChangedTrigger* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_UserNotificationChangedTrigger(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Background::UserNotificationChangedTrigger>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_UserNotificationChangedTrigger(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Background::UserNotificationChangedTrigger>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_UserNotificationChangedTrigger[] = {
        { "_assign_array_", _assign_array_UserNotificationChangedTrigger, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_UserNotificationChangedTrigger), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_UserNotificationChangedTrigger[] = {
        { }
    };

    static PyType_Slot _type_slots_UserNotificationChangedTrigger[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_UserNotificationChangedTrigger) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_UserNotificationChangedTrigger) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_UserNotificationChangedTrigger) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_UserNotificationChangedTrigger) },
        { },
    };

    static PyType_Spec type_spec_UserNotificationChangedTrigger =
    {
        "winrt._winrt_windows_applicationmodel_background.UserNotificationChangedTrigger",
        sizeof(py::wrapper::Windows::ApplicationModel::Background::UserNotificationChangedTrigger),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_UserNotificationChangedTrigger
    };

    // ----- WiFiOnDemandHotspotConnectTrigger class --------------------

    static PyObject* _new_WiFiOnDemandHotspotConnectTrigger(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::ApplicationModel::Background::WiFiOnDemandHotspotConnectTrigger instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_WiFiOnDemandHotspotConnectTrigger(py::wrapper::Windows::ApplicationModel::Background::WiFiOnDemandHotspotConnectTrigger* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_WiFiOnDemandHotspotConnectTrigger(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Background::WiFiOnDemandHotspotConnectTrigger>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_WiFiOnDemandHotspotConnectTrigger(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Background::WiFiOnDemandHotspotConnectTrigger>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_WiFiOnDemandHotspotConnectTrigger[] = {
        { "_assign_array_", _assign_array_WiFiOnDemandHotspotConnectTrigger, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_WiFiOnDemandHotspotConnectTrigger), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_WiFiOnDemandHotspotConnectTrigger[] = {
        { }
    };

    static PyType_Slot _type_slots_WiFiOnDemandHotspotConnectTrigger[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_WiFiOnDemandHotspotConnectTrigger) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_WiFiOnDemandHotspotConnectTrigger) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_WiFiOnDemandHotspotConnectTrigger) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_WiFiOnDemandHotspotConnectTrigger) },
        { },
    };

    static PyType_Spec type_spec_WiFiOnDemandHotspotConnectTrigger =
    {
        "winrt._winrt_windows_applicationmodel_background.WiFiOnDemandHotspotConnectTrigger",
        sizeof(py::wrapper::Windows::ApplicationModel::Background::WiFiOnDemandHotspotConnectTrigger),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_WiFiOnDemandHotspotConnectTrigger
    };

    // ----- WiFiOnDemandHotspotUpdateMetadataTrigger class --------------------

    static PyObject* _new_WiFiOnDemandHotspotUpdateMetadataTrigger(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::ApplicationModel::Background::WiFiOnDemandHotspotUpdateMetadataTrigger instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_WiFiOnDemandHotspotUpdateMetadataTrigger(py::wrapper::Windows::ApplicationModel::Background::WiFiOnDemandHotspotUpdateMetadataTrigger* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_WiFiOnDemandHotspotUpdateMetadataTrigger(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Background::WiFiOnDemandHotspotUpdateMetadataTrigger>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_WiFiOnDemandHotspotUpdateMetadataTrigger(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Background::WiFiOnDemandHotspotUpdateMetadataTrigger>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_WiFiOnDemandHotspotUpdateMetadataTrigger[] = {
        { "_assign_array_", _assign_array_WiFiOnDemandHotspotUpdateMetadataTrigger, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_WiFiOnDemandHotspotUpdateMetadataTrigger), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_WiFiOnDemandHotspotUpdateMetadataTrigger[] = {
        { }
    };

    static PyType_Slot _type_slots_WiFiOnDemandHotspotUpdateMetadataTrigger[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_WiFiOnDemandHotspotUpdateMetadataTrigger) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_WiFiOnDemandHotspotUpdateMetadataTrigger) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_WiFiOnDemandHotspotUpdateMetadataTrigger) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_WiFiOnDemandHotspotUpdateMetadataTrigger) },
        { },
    };

    static PyType_Spec type_spec_WiFiOnDemandHotspotUpdateMetadataTrigger =
    {
        "winrt._winrt_windows_applicationmodel_background.WiFiOnDemandHotspotUpdateMetadataTrigger",
        sizeof(py::wrapper::Windows::ApplicationModel::Background::WiFiOnDemandHotspotUpdateMetadataTrigger),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_WiFiOnDemandHotspotUpdateMetadataTrigger
    };

    // ----- IBackgroundCondition interface --------------------

    static PyObject* _new_IBackgroundCondition(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Background::IBackgroundCondition>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Background::IBackgroundCondition>::type_name);
        return nullptr;
    }

    static void _dealloc_IBackgroundCondition(py::wrapper::Windows::ApplicationModel::Background::IBackgroundCondition* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_IBackgroundCondition(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Background::IBackgroundCondition>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IBackgroundCondition(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Background::IBackgroundCondition>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IBackgroundCondition[] = {
        { "_assign_array_", _assign_array_IBackgroundCondition, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IBackgroundCondition), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IBackgroundCondition[] = {
        { }
    };

    static PyType_Slot _type_slots_IBackgroundCondition[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_IBackgroundCondition) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IBackgroundCondition) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IBackgroundCondition) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IBackgroundCondition) },
        { },
    };

    static PyType_Spec type_spec_IBackgroundCondition =
    {
        "winrt._winrt_windows_applicationmodel_background.IBackgroundCondition",
        sizeof(py::wrapper::Windows::ApplicationModel::Background::IBackgroundCondition),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IBackgroundCondition
    };

    // ----- IBackgroundTask interface --------------------

    static PyObject* _new_IBackgroundTask(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Background::IBackgroundTask>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Background::IBackgroundTask>::type_name);
        return nullptr;
    }

    static void _dealloc_IBackgroundTask(py::wrapper::Windows::ApplicationModel::Background::IBackgroundTask* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IBackgroundTask_Run(py::wrapper::Windows::ApplicationModel::Background::IBackgroundTask* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Background.IBackgroundTask", L"Run", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Background::IBackgroundTaskInstance>(args, 0);

                self->obj.Run(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_IBackgroundTask(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Background::IBackgroundTask>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IBackgroundTask(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Background::IBackgroundTask>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IBackgroundTask[] = {
        { "run", reinterpret_cast<PyCFunction>(IBackgroundTask_Run), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_IBackgroundTask, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IBackgroundTask), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IBackgroundTask[] = {
        { }
    };

    static PyType_Slot _type_slots_IBackgroundTask[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_IBackgroundTask) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IBackgroundTask) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IBackgroundTask) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IBackgroundTask) },
        { },
    };

    static PyType_Spec type_spec_IBackgroundTask =
    {
        "winrt._winrt_windows_applicationmodel_background.IBackgroundTask",
        sizeof(py::wrapper::Windows::ApplicationModel::Background::IBackgroundTask),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IBackgroundTask
    };

    // ----- IBackgroundTaskInstance interface --------------------

    static PyObject* _new_IBackgroundTaskInstance(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Background::IBackgroundTaskInstance>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Background::IBackgroundTaskInstance>::type_name);
        return nullptr;
    }

    static void _dealloc_IBackgroundTaskInstance(py::wrapper::Windows::ApplicationModel::Background::IBackgroundTaskInstance* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IBackgroundTaskInstance_GetDeferral(py::wrapper::Windows::ApplicationModel::Background::IBackgroundTaskInstance* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Background.IBackgroundTaskInstance", L"GetDeferral", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetDeferral());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IBackgroundTaskInstance_get_InstanceId(py::wrapper::Windows::ApplicationModel::Background::IBackgroundTaskInstance* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Background.IBackgroundTaskInstance", L"InstanceId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.InstanceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IBackgroundTaskInstance_get_Progress(py::wrapper::Windows::ApplicationModel::Background::IBackgroundTaskInstance* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Background.IBackgroundTaskInstance", L"Progress"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Progress());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IBackgroundTaskInstance_put_Progress(py::wrapper::Windows::ApplicationModel::Background::IBackgroundTaskInstance* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Background.IBackgroundTaskInstance", L"Progress"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.Progress(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* IBackgroundTaskInstance_get_SuspendedCount(py::wrapper::Windows::ApplicationModel::Background::IBackgroundTaskInstance* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Background.IBackgroundTaskInstance", L"SuspendedCount"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SuspendedCount());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IBackgroundTaskInstance_get_Task(py::wrapper::Windows::ApplicationModel::Background::IBackgroundTaskInstance* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Background.IBackgroundTaskInstance", L"Task"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Task());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IBackgroundTaskInstance_get_TriggerDetails(py::wrapper::Windows::ApplicationModel::Background::IBackgroundTaskInstance* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Background.IBackgroundTaskInstance", L"TriggerDetails"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.TriggerDetails());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IBackgroundTaskInstance_add_Canceled(py::wrapper::Windows::ApplicationModel::Background::IBackgroundTaskInstance* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.Background.IBackgroundTaskInstance", L"Canceled"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Background::BackgroundTaskCanceledEventHandler>(arg);

            return py::convert(self->obj.Canceled(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IBackgroundTaskInstance_remove_Canceled(py::wrapper::Windows::ApplicationModel::Background::IBackgroundTaskInstance* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.Background.IBackgroundTaskInstance", L"Canceled"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Canceled(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_IBackgroundTaskInstance(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Background::IBackgroundTaskInstance>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IBackgroundTaskInstance(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Background::IBackgroundTaskInstance>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IBackgroundTaskInstance[] = {
        { "get_deferral", reinterpret_cast<PyCFunction>(IBackgroundTaskInstance_GetDeferral), METH_VARARGS, nullptr },
        { "add_canceled", reinterpret_cast<PyCFunction>(IBackgroundTaskInstance_add_Canceled), METH_O, nullptr },
        { "remove_canceled", reinterpret_cast<PyCFunction>(IBackgroundTaskInstance_remove_Canceled), METH_O, nullptr },
        { "_assign_array_", _assign_array_IBackgroundTaskInstance, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IBackgroundTaskInstance), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IBackgroundTaskInstance[] = {
        { "instance_id", reinterpret_cast<getter>(IBackgroundTaskInstance_get_InstanceId), nullptr, nullptr, nullptr },
        { "progress", reinterpret_cast<getter>(IBackgroundTaskInstance_get_Progress), reinterpret_cast<setter>(IBackgroundTaskInstance_put_Progress), nullptr, nullptr },
        { "suspended_count", reinterpret_cast<getter>(IBackgroundTaskInstance_get_SuspendedCount), nullptr, nullptr, nullptr },
        { "task", reinterpret_cast<getter>(IBackgroundTaskInstance_get_Task), nullptr, nullptr, nullptr },
        { "trigger_details", reinterpret_cast<getter>(IBackgroundTaskInstance_get_TriggerDetails), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IBackgroundTaskInstance[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_IBackgroundTaskInstance) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IBackgroundTaskInstance) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IBackgroundTaskInstance) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IBackgroundTaskInstance) },
        { },
    };

    static PyType_Spec type_spec_IBackgroundTaskInstance =
    {
        "winrt._winrt_windows_applicationmodel_background.IBackgroundTaskInstance",
        sizeof(py::wrapper::Windows::ApplicationModel::Background::IBackgroundTaskInstance),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IBackgroundTaskInstance
    };

    // ----- IBackgroundTaskInstance2 interface --------------------

    static PyObject* _new_IBackgroundTaskInstance2(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Background::IBackgroundTaskInstance2>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Background::IBackgroundTaskInstance2>::type_name);
        return nullptr;
    }

    static void _dealloc_IBackgroundTaskInstance2(py::wrapper::Windows::ApplicationModel::Background::IBackgroundTaskInstance2* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IBackgroundTaskInstance2_GetDeferral(py::wrapper::Windows::ApplicationModel::Background::IBackgroundTaskInstance2* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Background.IBackgroundTaskInstance", L"GetDeferral", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetDeferral());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IBackgroundTaskInstance2_GetThrottleCount(py::wrapper::Windows::ApplicationModel::Background::IBackgroundTaskInstance2* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Background.IBackgroundTaskInstance2", L"GetThrottleCount", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Background::BackgroundTaskThrottleCounter>(args, 0);

                return py::convert(self->obj.GetThrottleCount(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IBackgroundTaskInstance2_get_InstanceId(py::wrapper::Windows::ApplicationModel::Background::IBackgroundTaskInstance2* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Background.IBackgroundTaskInstance", L"InstanceId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.InstanceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IBackgroundTaskInstance2_get_Progress(py::wrapper::Windows::ApplicationModel::Background::IBackgroundTaskInstance2* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Background.IBackgroundTaskInstance", L"Progress"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Progress());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IBackgroundTaskInstance2_put_Progress(py::wrapper::Windows::ApplicationModel::Background::IBackgroundTaskInstance2* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Background.IBackgroundTaskInstance", L"Progress"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.Progress(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* IBackgroundTaskInstance2_get_SuspendedCount(py::wrapper::Windows::ApplicationModel::Background::IBackgroundTaskInstance2* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Background.IBackgroundTaskInstance", L"SuspendedCount"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SuspendedCount());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IBackgroundTaskInstance2_get_Task(py::wrapper::Windows::ApplicationModel::Background::IBackgroundTaskInstance2* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Background.IBackgroundTaskInstance", L"Task"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Task());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IBackgroundTaskInstance2_get_TriggerDetails(py::wrapper::Windows::ApplicationModel::Background::IBackgroundTaskInstance2* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Background.IBackgroundTaskInstance", L"TriggerDetails"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.TriggerDetails());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IBackgroundTaskInstance2_add_Canceled(py::wrapper::Windows::ApplicationModel::Background::IBackgroundTaskInstance2* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.Background.IBackgroundTaskInstance", L"Canceled"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Background::BackgroundTaskCanceledEventHandler>(arg);

            return py::convert(self->obj.Canceled(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IBackgroundTaskInstance2_remove_Canceled(py::wrapper::Windows::ApplicationModel::Background::IBackgroundTaskInstance2* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.Background.IBackgroundTaskInstance", L"Canceled"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Canceled(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_IBackgroundTaskInstance2(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Background::IBackgroundTaskInstance2>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IBackgroundTaskInstance2(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Background::IBackgroundTaskInstance2>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IBackgroundTaskInstance2[] = {
        { "get_deferral", reinterpret_cast<PyCFunction>(IBackgroundTaskInstance2_GetDeferral), METH_VARARGS, nullptr },
        { "get_throttle_count", reinterpret_cast<PyCFunction>(IBackgroundTaskInstance2_GetThrottleCount), METH_VARARGS, nullptr },
        { "add_canceled", reinterpret_cast<PyCFunction>(IBackgroundTaskInstance2_add_Canceled), METH_O, nullptr },
        { "remove_canceled", reinterpret_cast<PyCFunction>(IBackgroundTaskInstance2_remove_Canceled), METH_O, nullptr },
        { "_assign_array_", _assign_array_IBackgroundTaskInstance2, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IBackgroundTaskInstance2), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IBackgroundTaskInstance2[] = {
        { "instance_id", reinterpret_cast<getter>(IBackgroundTaskInstance2_get_InstanceId), nullptr, nullptr, nullptr },
        { "progress", reinterpret_cast<getter>(IBackgroundTaskInstance2_get_Progress), reinterpret_cast<setter>(IBackgroundTaskInstance2_put_Progress), nullptr, nullptr },
        { "suspended_count", reinterpret_cast<getter>(IBackgroundTaskInstance2_get_SuspendedCount), nullptr, nullptr, nullptr },
        { "task", reinterpret_cast<getter>(IBackgroundTaskInstance2_get_Task), nullptr, nullptr, nullptr },
        { "trigger_details", reinterpret_cast<getter>(IBackgroundTaskInstance2_get_TriggerDetails), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IBackgroundTaskInstance2[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_IBackgroundTaskInstance2) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IBackgroundTaskInstance2) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IBackgroundTaskInstance2) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IBackgroundTaskInstance2) },
        { },
    };

    static PyType_Spec type_spec_IBackgroundTaskInstance2 =
    {
        "winrt._winrt_windows_applicationmodel_background.IBackgroundTaskInstance2",
        sizeof(py::wrapper::Windows::ApplicationModel::Background::IBackgroundTaskInstance2),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IBackgroundTaskInstance2
    };

    // ----- IBackgroundTaskInstance4 interface --------------------

    static PyObject* _new_IBackgroundTaskInstance4(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Background::IBackgroundTaskInstance4>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Background::IBackgroundTaskInstance4>::type_name);
        return nullptr;
    }

    static void _dealloc_IBackgroundTaskInstance4(py::wrapper::Windows::ApplicationModel::Background::IBackgroundTaskInstance4* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IBackgroundTaskInstance4_GetDeferral(py::wrapper::Windows::ApplicationModel::Background::IBackgroundTaskInstance4* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Background.IBackgroundTaskInstance", L"GetDeferral", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetDeferral());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IBackgroundTaskInstance4_get_User(py::wrapper::Windows::ApplicationModel::Background::IBackgroundTaskInstance4* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Background.IBackgroundTaskInstance4", L"User"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.User());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IBackgroundTaskInstance4_get_InstanceId(py::wrapper::Windows::ApplicationModel::Background::IBackgroundTaskInstance4* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Background.IBackgroundTaskInstance", L"InstanceId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.InstanceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IBackgroundTaskInstance4_get_Progress(py::wrapper::Windows::ApplicationModel::Background::IBackgroundTaskInstance4* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Background.IBackgroundTaskInstance", L"Progress"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Progress());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IBackgroundTaskInstance4_put_Progress(py::wrapper::Windows::ApplicationModel::Background::IBackgroundTaskInstance4* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Background.IBackgroundTaskInstance", L"Progress"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.Progress(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* IBackgroundTaskInstance4_get_SuspendedCount(py::wrapper::Windows::ApplicationModel::Background::IBackgroundTaskInstance4* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Background.IBackgroundTaskInstance", L"SuspendedCount"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SuspendedCount());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IBackgroundTaskInstance4_get_Task(py::wrapper::Windows::ApplicationModel::Background::IBackgroundTaskInstance4* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Background.IBackgroundTaskInstance", L"Task"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Task());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IBackgroundTaskInstance4_get_TriggerDetails(py::wrapper::Windows::ApplicationModel::Background::IBackgroundTaskInstance4* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Background.IBackgroundTaskInstance", L"TriggerDetails"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.TriggerDetails());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IBackgroundTaskInstance4_add_Canceled(py::wrapper::Windows::ApplicationModel::Background::IBackgroundTaskInstance4* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.Background.IBackgroundTaskInstance", L"Canceled"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Background::BackgroundTaskCanceledEventHandler>(arg);

            return py::convert(self->obj.Canceled(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IBackgroundTaskInstance4_remove_Canceled(py::wrapper::Windows::ApplicationModel::Background::IBackgroundTaskInstance4* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.Background.IBackgroundTaskInstance", L"Canceled"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Canceled(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_IBackgroundTaskInstance4(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Background::IBackgroundTaskInstance4>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IBackgroundTaskInstance4(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Background::IBackgroundTaskInstance4>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IBackgroundTaskInstance4[] = {
        { "get_deferral", reinterpret_cast<PyCFunction>(IBackgroundTaskInstance4_GetDeferral), METH_VARARGS, nullptr },
        { "add_canceled", reinterpret_cast<PyCFunction>(IBackgroundTaskInstance4_add_Canceled), METH_O, nullptr },
        { "remove_canceled", reinterpret_cast<PyCFunction>(IBackgroundTaskInstance4_remove_Canceled), METH_O, nullptr },
        { "_assign_array_", _assign_array_IBackgroundTaskInstance4, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IBackgroundTaskInstance4), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IBackgroundTaskInstance4[] = {
        { "user", reinterpret_cast<getter>(IBackgroundTaskInstance4_get_User), nullptr, nullptr, nullptr },
        { "instance_id", reinterpret_cast<getter>(IBackgroundTaskInstance4_get_InstanceId), nullptr, nullptr, nullptr },
        { "progress", reinterpret_cast<getter>(IBackgroundTaskInstance4_get_Progress), reinterpret_cast<setter>(IBackgroundTaskInstance4_put_Progress), nullptr, nullptr },
        { "suspended_count", reinterpret_cast<getter>(IBackgroundTaskInstance4_get_SuspendedCount), nullptr, nullptr, nullptr },
        { "task", reinterpret_cast<getter>(IBackgroundTaskInstance4_get_Task), nullptr, nullptr, nullptr },
        { "trigger_details", reinterpret_cast<getter>(IBackgroundTaskInstance4_get_TriggerDetails), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IBackgroundTaskInstance4[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_IBackgroundTaskInstance4) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IBackgroundTaskInstance4) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IBackgroundTaskInstance4) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IBackgroundTaskInstance4) },
        { },
    };

    static PyType_Spec type_spec_IBackgroundTaskInstance4 =
    {
        "winrt._winrt_windows_applicationmodel_background.IBackgroundTaskInstance4",
        sizeof(py::wrapper::Windows::ApplicationModel::Background::IBackgroundTaskInstance4),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IBackgroundTaskInstance4
    };

    // ----- IBackgroundTaskRegistration interface --------------------

    static PyObject* _new_IBackgroundTaskRegistration(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Background::IBackgroundTaskRegistration>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Background::IBackgroundTaskRegistration>::type_name);
        return nullptr;
    }

    static void _dealloc_IBackgroundTaskRegistration(py::wrapper::Windows::ApplicationModel::Background::IBackgroundTaskRegistration* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IBackgroundTaskRegistration_Unregister(py::wrapper::Windows::ApplicationModel::Background::IBackgroundTaskRegistration* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Background.IBackgroundTaskRegistration", L"Unregister", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<bool>(args, 0);

                self->obj.Unregister(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IBackgroundTaskRegistration_get_Name(py::wrapper::Windows::ApplicationModel::Background::IBackgroundTaskRegistration* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Background.IBackgroundTaskRegistration", L"Name"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Name());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IBackgroundTaskRegistration_get_TaskId(py::wrapper::Windows::ApplicationModel::Background::IBackgroundTaskRegistration* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Background.IBackgroundTaskRegistration", L"TaskId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.TaskId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IBackgroundTaskRegistration_add_Completed(py::wrapper::Windows::ApplicationModel::Background::IBackgroundTaskRegistration* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.Background.IBackgroundTaskRegistration", L"Completed"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Background::BackgroundTaskCompletedEventHandler>(arg);

            return py::convert(self->obj.Completed(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IBackgroundTaskRegistration_remove_Completed(py::wrapper::Windows::ApplicationModel::Background::IBackgroundTaskRegistration* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.Background.IBackgroundTaskRegistration", L"Completed"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Completed(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IBackgroundTaskRegistration_add_Progress(py::wrapper::Windows::ApplicationModel::Background::IBackgroundTaskRegistration* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.Background.IBackgroundTaskRegistration", L"Progress"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Background::BackgroundTaskProgressEventHandler>(arg);

            return py::convert(self->obj.Progress(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IBackgroundTaskRegistration_remove_Progress(py::wrapper::Windows::ApplicationModel::Background::IBackgroundTaskRegistration* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.Background.IBackgroundTaskRegistration", L"Progress"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Progress(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_IBackgroundTaskRegistration(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Background::IBackgroundTaskRegistration>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IBackgroundTaskRegistration(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Background::IBackgroundTaskRegistration>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IBackgroundTaskRegistration[] = {
        { "unregister", reinterpret_cast<PyCFunction>(IBackgroundTaskRegistration_Unregister), METH_VARARGS, nullptr },
        { "add_completed", reinterpret_cast<PyCFunction>(IBackgroundTaskRegistration_add_Completed), METH_O, nullptr },
        { "remove_completed", reinterpret_cast<PyCFunction>(IBackgroundTaskRegistration_remove_Completed), METH_O, nullptr },
        { "add_progress", reinterpret_cast<PyCFunction>(IBackgroundTaskRegistration_add_Progress), METH_O, nullptr },
        { "remove_progress", reinterpret_cast<PyCFunction>(IBackgroundTaskRegistration_remove_Progress), METH_O, nullptr },
        { "_assign_array_", _assign_array_IBackgroundTaskRegistration, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IBackgroundTaskRegistration), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IBackgroundTaskRegistration[] = {
        { "name", reinterpret_cast<getter>(IBackgroundTaskRegistration_get_Name), nullptr, nullptr, nullptr },
        { "task_id", reinterpret_cast<getter>(IBackgroundTaskRegistration_get_TaskId), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IBackgroundTaskRegistration[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_IBackgroundTaskRegistration) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IBackgroundTaskRegistration) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IBackgroundTaskRegistration) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IBackgroundTaskRegistration) },
        { },
    };

    static PyType_Spec type_spec_IBackgroundTaskRegistration =
    {
        "winrt._winrt_windows_applicationmodel_background.IBackgroundTaskRegistration",
        sizeof(py::wrapper::Windows::ApplicationModel::Background::IBackgroundTaskRegistration),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IBackgroundTaskRegistration
    };

    // ----- IBackgroundTaskRegistration2 interface --------------------

    static PyObject* _new_IBackgroundTaskRegistration2(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Background::IBackgroundTaskRegistration2>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Background::IBackgroundTaskRegistration2>::type_name);
        return nullptr;
    }

    static void _dealloc_IBackgroundTaskRegistration2(py::wrapper::Windows::ApplicationModel::Background::IBackgroundTaskRegistration2* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IBackgroundTaskRegistration2_Unregister(py::wrapper::Windows::ApplicationModel::Background::IBackgroundTaskRegistration2* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Background.IBackgroundTaskRegistration", L"Unregister", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<bool>(args, 0);

                self->obj.Unregister(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IBackgroundTaskRegistration2_get_Trigger(py::wrapper::Windows::ApplicationModel::Background::IBackgroundTaskRegistration2* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Background.IBackgroundTaskRegistration2", L"Trigger"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Trigger());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IBackgroundTaskRegistration2_get_Name(py::wrapper::Windows::ApplicationModel::Background::IBackgroundTaskRegistration2* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Background.IBackgroundTaskRegistration", L"Name"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Name());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IBackgroundTaskRegistration2_get_TaskId(py::wrapper::Windows::ApplicationModel::Background::IBackgroundTaskRegistration2* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Background.IBackgroundTaskRegistration", L"TaskId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.TaskId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IBackgroundTaskRegistration2_add_Completed(py::wrapper::Windows::ApplicationModel::Background::IBackgroundTaskRegistration2* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.Background.IBackgroundTaskRegistration", L"Completed"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Background::BackgroundTaskCompletedEventHandler>(arg);

            return py::convert(self->obj.Completed(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IBackgroundTaskRegistration2_remove_Completed(py::wrapper::Windows::ApplicationModel::Background::IBackgroundTaskRegistration2* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.Background.IBackgroundTaskRegistration", L"Completed"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Completed(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IBackgroundTaskRegistration2_add_Progress(py::wrapper::Windows::ApplicationModel::Background::IBackgroundTaskRegistration2* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.Background.IBackgroundTaskRegistration", L"Progress"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Background::BackgroundTaskProgressEventHandler>(arg);

            return py::convert(self->obj.Progress(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IBackgroundTaskRegistration2_remove_Progress(py::wrapper::Windows::ApplicationModel::Background::IBackgroundTaskRegistration2* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.Background.IBackgroundTaskRegistration", L"Progress"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Progress(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_IBackgroundTaskRegistration2(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Background::IBackgroundTaskRegistration2>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IBackgroundTaskRegistration2(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Background::IBackgroundTaskRegistration2>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IBackgroundTaskRegistration2[] = {
        { "unregister", reinterpret_cast<PyCFunction>(IBackgroundTaskRegistration2_Unregister), METH_VARARGS, nullptr },
        { "add_completed", reinterpret_cast<PyCFunction>(IBackgroundTaskRegistration2_add_Completed), METH_O, nullptr },
        { "remove_completed", reinterpret_cast<PyCFunction>(IBackgroundTaskRegistration2_remove_Completed), METH_O, nullptr },
        { "add_progress", reinterpret_cast<PyCFunction>(IBackgroundTaskRegistration2_add_Progress), METH_O, nullptr },
        { "remove_progress", reinterpret_cast<PyCFunction>(IBackgroundTaskRegistration2_remove_Progress), METH_O, nullptr },
        { "_assign_array_", _assign_array_IBackgroundTaskRegistration2, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IBackgroundTaskRegistration2), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IBackgroundTaskRegistration2[] = {
        { "trigger", reinterpret_cast<getter>(IBackgroundTaskRegistration2_get_Trigger), nullptr, nullptr, nullptr },
        { "name", reinterpret_cast<getter>(IBackgroundTaskRegistration2_get_Name), nullptr, nullptr, nullptr },
        { "task_id", reinterpret_cast<getter>(IBackgroundTaskRegistration2_get_TaskId), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IBackgroundTaskRegistration2[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_IBackgroundTaskRegistration2) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IBackgroundTaskRegistration2) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IBackgroundTaskRegistration2) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IBackgroundTaskRegistration2) },
        { },
    };

    static PyType_Spec type_spec_IBackgroundTaskRegistration2 =
    {
        "winrt._winrt_windows_applicationmodel_background.IBackgroundTaskRegistration2",
        sizeof(py::wrapper::Windows::ApplicationModel::Background::IBackgroundTaskRegistration2),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IBackgroundTaskRegistration2
    };

    // ----- IBackgroundTaskRegistration3 interface --------------------

    static PyObject* _new_IBackgroundTaskRegistration3(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Background::IBackgroundTaskRegistration3>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Background::IBackgroundTaskRegistration3>::type_name);
        return nullptr;
    }

    static void _dealloc_IBackgroundTaskRegistration3(py::wrapper::Windows::ApplicationModel::Background::IBackgroundTaskRegistration3* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IBackgroundTaskRegistration3_Unregister(py::wrapper::Windows::ApplicationModel::Background::IBackgroundTaskRegistration3* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Background.IBackgroundTaskRegistration", L"Unregister", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<bool>(args, 0);

                self->obj.Unregister(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IBackgroundTaskRegistration3_get_TaskGroup(py::wrapper::Windows::ApplicationModel::Background::IBackgroundTaskRegistration3* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Background.IBackgroundTaskRegistration3", L"TaskGroup"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.TaskGroup());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IBackgroundTaskRegistration3_get_Name(py::wrapper::Windows::ApplicationModel::Background::IBackgroundTaskRegistration3* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Background.IBackgroundTaskRegistration", L"Name"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Name());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IBackgroundTaskRegistration3_get_TaskId(py::wrapper::Windows::ApplicationModel::Background::IBackgroundTaskRegistration3* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Background.IBackgroundTaskRegistration", L"TaskId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.TaskId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IBackgroundTaskRegistration3_add_Completed(py::wrapper::Windows::ApplicationModel::Background::IBackgroundTaskRegistration3* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.Background.IBackgroundTaskRegistration", L"Completed"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Background::BackgroundTaskCompletedEventHandler>(arg);

            return py::convert(self->obj.Completed(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IBackgroundTaskRegistration3_remove_Completed(py::wrapper::Windows::ApplicationModel::Background::IBackgroundTaskRegistration3* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.Background.IBackgroundTaskRegistration", L"Completed"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Completed(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IBackgroundTaskRegistration3_add_Progress(py::wrapper::Windows::ApplicationModel::Background::IBackgroundTaskRegistration3* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.Background.IBackgroundTaskRegistration", L"Progress"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Background::BackgroundTaskProgressEventHandler>(arg);

            return py::convert(self->obj.Progress(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IBackgroundTaskRegistration3_remove_Progress(py::wrapper::Windows::ApplicationModel::Background::IBackgroundTaskRegistration3* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.Background.IBackgroundTaskRegistration", L"Progress"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Progress(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_IBackgroundTaskRegistration3(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Background::IBackgroundTaskRegistration3>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IBackgroundTaskRegistration3(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Background::IBackgroundTaskRegistration3>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IBackgroundTaskRegistration3[] = {
        { "unregister", reinterpret_cast<PyCFunction>(IBackgroundTaskRegistration3_Unregister), METH_VARARGS, nullptr },
        { "add_completed", reinterpret_cast<PyCFunction>(IBackgroundTaskRegistration3_add_Completed), METH_O, nullptr },
        { "remove_completed", reinterpret_cast<PyCFunction>(IBackgroundTaskRegistration3_remove_Completed), METH_O, nullptr },
        { "add_progress", reinterpret_cast<PyCFunction>(IBackgroundTaskRegistration3_add_Progress), METH_O, nullptr },
        { "remove_progress", reinterpret_cast<PyCFunction>(IBackgroundTaskRegistration3_remove_Progress), METH_O, nullptr },
        { "_assign_array_", _assign_array_IBackgroundTaskRegistration3, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IBackgroundTaskRegistration3), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IBackgroundTaskRegistration3[] = {
        { "task_group", reinterpret_cast<getter>(IBackgroundTaskRegistration3_get_TaskGroup), nullptr, nullptr, nullptr },
        { "name", reinterpret_cast<getter>(IBackgroundTaskRegistration3_get_Name), nullptr, nullptr, nullptr },
        { "task_id", reinterpret_cast<getter>(IBackgroundTaskRegistration3_get_TaskId), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IBackgroundTaskRegistration3[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_IBackgroundTaskRegistration3) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IBackgroundTaskRegistration3) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IBackgroundTaskRegistration3) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IBackgroundTaskRegistration3) },
        { },
    };

    static PyType_Spec type_spec_IBackgroundTaskRegistration3 =
    {
        "winrt._winrt_windows_applicationmodel_background.IBackgroundTaskRegistration3",
        sizeof(py::wrapper::Windows::ApplicationModel::Background::IBackgroundTaskRegistration3),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IBackgroundTaskRegistration3
    };

    // ----- IBackgroundTrigger interface --------------------

    static PyObject* _new_IBackgroundTrigger(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Background::IBackgroundTrigger>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Background::IBackgroundTrigger>::type_name);
        return nullptr;
    }

    static void _dealloc_IBackgroundTrigger(py::wrapper::Windows::ApplicationModel::Background::IBackgroundTrigger* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_IBackgroundTrigger(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Background::IBackgroundTrigger>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IBackgroundTrigger(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Background::IBackgroundTrigger>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IBackgroundTrigger[] = {
        { "_assign_array_", _assign_array_IBackgroundTrigger, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IBackgroundTrigger), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IBackgroundTrigger[] = {
        { }
    };

    static PyType_Slot _type_slots_IBackgroundTrigger[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_IBackgroundTrigger) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IBackgroundTrigger) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IBackgroundTrigger) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IBackgroundTrigger) },
        { },
    };

    static PyType_Spec type_spec_IBackgroundTrigger =
    {
        "winrt._winrt_windows_applicationmodel_background.IBackgroundTrigger",
        sizeof(py::wrapper::Windows::ApplicationModel::Background::IBackgroundTrigger),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IBackgroundTrigger
    };

    // ----- Windows.ApplicationModel.Background Initialization --------------------
    PyDoc_STRVAR(module_doc, "Windows::ApplicationModel::Background");


    static PyModuleDef module_def
        = {PyModuleDef_HEAD_INIT,
           "_winrt_windows_applicationmodel_background",
           module_doc,
           0,
           nullptr,
           nullptr,
           nullptr,
           nullptr,
           nullptr};

} // py::cpp::Windows::ApplicationModel::Background

PyMODINIT_FUNC PyInit__winrt_windows_applicationmodel_background(void) noexcept
{
    using namespace py::cpp::Windows::ApplicationModel::Background;

    if (py::import_winrt_runtime() == -1)
    {
        return nullptr;
    }

    py::pyobj_handle module{PyModule_Create(&module_def)};

    if (!module)
    {
        return nullptr;
    }

    auto object_type = py::get_object_type();
    if (!object_type)
    {
        return nullptr;
    }

    py::pyobj_handle object_bases{PyTuple_Pack(1, object_type)};

    if (!object_bases)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ActivitySensorTrigger, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_AlarmApplicationManager_Static{PyType_FromSpec(&type_spec_AlarmApplicationManager_Static)};
    if (!type_AlarmApplicationManager_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_AlarmApplicationManager, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_AlarmApplicationManager_Static.get())) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_AppBroadcastTrigger, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_AppBroadcastTriggerProviderInfo, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ApplicationTrigger, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ApplicationTriggerDetails, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_AppointmentStoreNotificationTrigger, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_BackgroundExecutionManager_Static{PyType_FromSpec(&type_spec_BackgroundExecutionManager_Static)};
    if (!type_BackgroundExecutionManager_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_BackgroundExecutionManager, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_BackgroundExecutionManager_Static.get())) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_BackgroundTaskBuilder, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_BackgroundTaskCompletedEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_BackgroundTaskDeferral, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_BackgroundTaskProgressEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_BackgroundTaskRegistration_Static{PyType_FromSpec(&type_spec_BackgroundTaskRegistration_Static)};
    if (!type_BackgroundTaskRegistration_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_BackgroundTaskRegistration, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_BackgroundTaskRegistration_Static.get())) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_BackgroundTaskRegistrationGroup, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_BackgroundWorkCost_Static{PyType_FromSpec(&type_spec_BackgroundWorkCost_Static)};
    if (!type_BackgroundWorkCost_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_BackgroundWorkCost, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_BackgroundWorkCost_Static.get())) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_BluetoothLEAdvertisementPublisherTrigger, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_BluetoothLEAdvertisementWatcherTrigger, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_CachedFileUpdaterTrigger, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_CachedFileUpdaterTriggerDetails, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ChatMessageNotificationTrigger, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ChatMessageReceivedNotificationTrigger, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_CommunicationBlockingAppSetAsActiveTrigger, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ContactStoreNotificationTrigger, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ContentPrefetchTrigger, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ConversationalAgentTrigger, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_CustomSystemEventTrigger, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_DeviceConnectionChangeTrigger_Static{PyType_FromSpec(&type_spec_DeviceConnectionChangeTrigger_Static)};
    if (!type_DeviceConnectionChangeTrigger_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_DeviceConnectionChangeTrigger, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_DeviceConnectionChangeTrigger_Static.get())) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_DeviceManufacturerNotificationTrigger, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_DeviceServicingTrigger, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_DeviceUseTrigger, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_DeviceWatcherTrigger, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_EmailStoreNotificationTrigger, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_GattCharacteristicNotificationTrigger, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_GattServiceProviderTrigger_Static{PyType_FromSpec(&type_spec_GattServiceProviderTrigger_Static)};
    if (!type_GattServiceProviderTrigger_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_GattServiceProviderTrigger, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_GattServiceProviderTrigger_Static.get())) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_GattServiceProviderTriggerResult, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_GeovisitTrigger, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_LocationTrigger, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_MaintenanceTrigger, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_MediaProcessingTrigger, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_MobileBroadbandDeviceServiceNotificationTrigger, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_MobileBroadbandPcoDataChangeTrigger, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_MobileBroadbandPinLockStateChangeTrigger, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_MobileBroadbandRadioStateChangeTrigger, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_MobileBroadbandRegistrationStateChangeTrigger, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_NetworkOperatorDataUsageTrigger, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_NetworkOperatorHotspotAuthenticationTrigger, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_NetworkOperatorNotificationTrigger, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_PaymentAppCanMakePaymentTrigger, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_PhoneTrigger, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_PushNotificationTrigger, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_RcsEndUserMessageAvailableTrigger, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_RfcommConnectionTrigger, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_SecondaryAuthenticationFactorAuthenticationTrigger, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_SensorDataThresholdTrigger, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_SmartCardTrigger, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_SmsMessageReceivedTrigger, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_SocketActivityTrigger, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_StorageLibraryChangeTrackerTrigger, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_StorageLibraryContentChangedTrigger_Static{PyType_FromSpec(&type_spec_StorageLibraryContentChangedTrigger_Static)};
    if (!type_StorageLibraryContentChangedTrigger_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_StorageLibraryContentChangedTrigger, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_StorageLibraryContentChangedTrigger_Static.get())) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_SystemCondition, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_SystemTrigger, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_TetheringEntitlementCheckTrigger, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_TimeTrigger, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ToastNotificationActionTrigger, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ToastNotificationHistoryChangedTrigger, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_UserNotificationChangedTrigger, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_WiFiOnDemandHotspotConnectTrigger, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_WiFiOnDemandHotspotUpdateMetadataTrigger, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_IBackgroundCondition, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_IBackgroundTask, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_IBackgroundTaskInstance, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_IBackgroundTaskInstance2, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_IBackgroundTaskInstance4, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_IBackgroundTaskRegistration, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_IBackgroundTaskRegistration2, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_IBackgroundTaskRegistration3, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_IBackgroundTrigger, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }


    return module.detach();
}
