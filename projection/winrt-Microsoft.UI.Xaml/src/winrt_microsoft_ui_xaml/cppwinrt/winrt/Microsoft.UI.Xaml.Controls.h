// WARNING: Please don't edit this file. It was generated by C++/WinRT v2.0.250303.1

#pragma once
#ifndef WINRT_Microsoft_UI_Xaml_Controls_H
#define WINRT_Microsoft_UI_Xaml_Controls_H
#include "winrt/base.h"
static_assert(winrt::check_version(CPPWINRT_VERSION, "2.0.250303.1"), "Mismatched C++/WinRT headers.");
#define CPPWINRT_VERSION "2.0.250303.1"
#include "winrt/impl/Microsoft.Web.WebView2.Core.2.h"
#include "winrt/impl/Windows.ApplicationModel.Contacts.2.h"
#include "winrt/impl/Windows.ApplicationModel.DataTransfer.2.h"
#include "winrt/impl/Windows.Foundation.2.h"
#include "winrt/impl/Windows.Foundation.Collections.2.h"
#include "winrt/impl/Windows.Foundation.Numerics.2.h"
#include "winrt/impl/Windows.Globalization.NumberFormatting.2.h"
#include "winrt/impl/Windows.UI.2.h"
#include "winrt/impl/Windows.UI.Composition.2.h"
#include "winrt/impl/Windows.UI.Text.2.h"
#include "winrt/impl/Windows.UI.Xaml.2.h"
#include "winrt/impl/Windows.UI.Xaml.Controls.2.h"
#include "winrt/impl/Windows.UI.Xaml.Controls.Primitives.2.h"
#include "winrt/impl/Windows.UI.Xaml.Input.2.h"
#include "winrt/impl/Windows.UI.Xaml.Interop.2.h"
#include "winrt/impl/Windows.UI.Xaml.Media.2.h"
#include "winrt/impl/Windows.UI.Xaml.Media.Animation.2.h"
#include "winrt/impl/Microsoft.UI.Xaml.Controls.2.h"
namespace winrt::impl
{
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IAnimatedIcon<D>::Source() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IAnimatedIcon>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IAnimatedIcon, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IAnimatedIcon>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Source(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IAnimatedIcon>**)this;
            check_hresult(_winrt_abi_type->get_Source(&value));
        }
        return winrt::Microsoft::UI::Xaml::Controls::IAnimatedVisualSource2{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IAnimatedIcon<D>::Source(winrt::Microsoft::UI::Xaml::Controls::IAnimatedVisualSource2 const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IAnimatedIcon>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IAnimatedIcon, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IAnimatedIcon>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_Source(*(void**)(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IAnimatedIcon>**)this;
            check_hresult(_winrt_abi_type->put_Source(*(void**)(&value)));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IAnimatedIcon<D>::FallbackIconSource() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IAnimatedIcon>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IAnimatedIcon, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IAnimatedIcon>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_FallbackIconSource(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IAnimatedIcon>**)this;
            check_hresult(_winrt_abi_type->get_FallbackIconSource(&value));
        }
        return winrt::Microsoft::UI::Xaml::Controls::IconSource{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IAnimatedIcon<D>::FallbackIconSource(winrt::Microsoft::UI::Xaml::Controls::IconSource const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IAnimatedIcon>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IAnimatedIcon, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IAnimatedIcon>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_FallbackIconSource(*(void**)(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IAnimatedIcon>**)this;
            check_hresult(_winrt_abi_type->put_FallbackIconSource(*(void**)(&value)));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IAnimatedIcon<D>::MirroredWhenRightToLeft() const
    {
        bool value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IAnimatedIcon>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IAnimatedIcon, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IAnimatedIcon>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_MirroredWhenRightToLeft(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IAnimatedIcon>**)this;
            check_hresult(_winrt_abi_type->get_MirroredWhenRightToLeft(&value));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IAnimatedIcon<D>::MirroredWhenRightToLeft(bool value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IAnimatedIcon>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IAnimatedIcon, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IAnimatedIcon>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_MirroredWhenRightToLeft(value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IAnimatedIcon>**)this;
            check_hresult(_winrt_abi_type->put_MirroredWhenRightToLeft(value));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IAnimatedIconFactory<D>::CreateInstance(winrt::Windows::Foundation::IInspectable const& baseInterface, winrt::Windows::Foundation::IInspectable& innerInterface) const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IAnimatedIconFactory>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IAnimatedIconFactory, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IAnimatedIconFactory>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->CreateInstance(*(void**)(&baseInterface), impl::bind_out(innerInterface), &value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IAnimatedIconFactory>**)this;
            check_hresult(_winrt_abi_type->CreateInstance(*(void**)(&baseInterface), impl::bind_out(innerInterface), &value));
        }
        return winrt::Microsoft::UI::Xaml::Controls::AnimatedIcon{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IAnimatedIconSource<D>::Source() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IAnimatedIconSource>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IAnimatedIconSource, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IAnimatedIconSource>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Source(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IAnimatedIconSource>**)this;
            check_hresult(_winrt_abi_type->get_Source(&value));
        }
        return winrt::Microsoft::UI::Xaml::Controls::IAnimatedVisualSource2{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IAnimatedIconSource<D>::Source(winrt::Microsoft::UI::Xaml::Controls::IAnimatedVisualSource2 const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IAnimatedIconSource>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IAnimatedIconSource, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IAnimatedIconSource>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_Source(*(void**)(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IAnimatedIconSource>**)this;
            check_hresult(_winrt_abi_type->put_Source(*(void**)(&value)));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IAnimatedIconSource<D>::FallbackIconSource() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IAnimatedIconSource>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IAnimatedIconSource, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IAnimatedIconSource>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_FallbackIconSource(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IAnimatedIconSource>**)this;
            check_hresult(_winrt_abi_type->get_FallbackIconSource(&value));
        }
        return winrt::Microsoft::UI::Xaml::Controls::IconSource{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IAnimatedIconSource<D>::FallbackIconSource(winrt::Microsoft::UI::Xaml::Controls::IconSource const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IAnimatedIconSource>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IAnimatedIconSource, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IAnimatedIconSource>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_FallbackIconSource(*(void**)(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IAnimatedIconSource>**)this;
            check_hresult(_winrt_abi_type->put_FallbackIconSource(*(void**)(&value)));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IAnimatedIconSource<D>::MirroredWhenRightToLeft() const
    {
        bool value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IAnimatedIconSource>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IAnimatedIconSource, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IAnimatedIconSource>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_MirroredWhenRightToLeft(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IAnimatedIconSource>**)this;
            check_hresult(_winrt_abi_type->get_MirroredWhenRightToLeft(&value));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IAnimatedIconSource<D>::MirroredWhenRightToLeft(bool value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IAnimatedIconSource>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IAnimatedIconSource, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IAnimatedIconSource>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_MirroredWhenRightToLeft(value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IAnimatedIconSource>**)this;
            check_hresult(_winrt_abi_type->put_MirroredWhenRightToLeft(value));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IAnimatedIconSourceFactory<D>::CreateInstance(winrt::Windows::Foundation::IInspectable const& baseInterface, winrt::Windows::Foundation::IInspectable& innerInterface) const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IAnimatedIconSourceFactory>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IAnimatedIconSourceFactory, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IAnimatedIconSourceFactory>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->CreateInstance(*(void**)(&baseInterface), impl::bind_out(innerInterface), &value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IAnimatedIconSourceFactory>**)this;
            check_hresult(_winrt_abi_type->CreateInstance(*(void**)(&baseInterface), impl::bind_out(innerInterface), &value));
        }
        return winrt::Microsoft::UI::Xaml::Controls::AnimatedIconSource{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IAnimatedIconSourceStatics<D>::SourceProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IAnimatedIconSourceStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IAnimatedIconSourceStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IAnimatedIconSourceStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_SourceProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IAnimatedIconSourceStatics>**)this;
            check_hresult(_winrt_abi_type->get_SourceProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IAnimatedIconSourceStatics<D>::FallbackIconSourceProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IAnimatedIconSourceStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IAnimatedIconSourceStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IAnimatedIconSourceStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_FallbackIconSourceProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IAnimatedIconSourceStatics>**)this;
            check_hresult(_winrt_abi_type->get_FallbackIconSourceProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IAnimatedIconSourceStatics<D>::MirroredWhenRightToLeftProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IAnimatedIconSourceStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IAnimatedIconSourceStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IAnimatedIconSourceStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_MirroredWhenRightToLeftProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IAnimatedIconSourceStatics>**)this;
            check_hresult(_winrt_abi_type->get_MirroredWhenRightToLeftProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IAnimatedIconStatics<D>::StateProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IAnimatedIconStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IAnimatedIconStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IAnimatedIconStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_StateProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IAnimatedIconStatics>**)this;
            check_hresult(_winrt_abi_type->get_StateProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IAnimatedIconStatics<D>::SetState(winrt::Windows::UI::Xaml::DependencyObject const& object, param::hstring const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IAnimatedIconStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IAnimatedIconStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IAnimatedIconStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->SetState(*(void**)(&object), *(void**)(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IAnimatedIconStatics>**)this;
            check_hresult(_winrt_abi_type->SetState(*(void**)(&object), *(void**)(&value)));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IAnimatedIconStatics<D>::GetState(winrt::Windows::UI::Xaml::DependencyObject const& object) const
    {
        void* result{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IAnimatedIconStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IAnimatedIconStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IAnimatedIconStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->GetState(*(void**)(&object), &result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IAnimatedIconStatics>**)this;
            check_hresult(_winrt_abi_type->GetState(*(void**)(&object), &result));
        }
        return hstring{ result, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IAnimatedIconStatics<D>::SourceProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IAnimatedIconStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IAnimatedIconStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IAnimatedIconStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_SourceProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IAnimatedIconStatics>**)this;
            check_hresult(_winrt_abi_type->get_SourceProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IAnimatedIconStatics<D>::FallbackIconSourceProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IAnimatedIconStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IAnimatedIconStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IAnimatedIconStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_FallbackIconSourceProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IAnimatedIconStatics>**)this;
            check_hresult(_winrt_abi_type->get_FallbackIconSourceProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IAnimatedIconStatics<D>::MirroredWhenRightToLeftProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IAnimatedIconStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IAnimatedIconStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IAnimatedIconStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_MirroredWhenRightToLeftProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IAnimatedIconStatics>**)this;
            check_hresult(_winrt_abi_type->get_MirroredWhenRightToLeftProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IAnimatedVisual<D>::RootVisual() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IAnimatedVisual>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IAnimatedVisual, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IAnimatedVisual>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_RootVisual(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IAnimatedVisual>**)this;
            check_hresult(_winrt_abi_type->get_RootVisual(&value));
        }
        return winrt::Windows::UI::Composition::Visual{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IAnimatedVisual<D>::Size() const
    {
        winrt::Windows::Foundation::Numerics::float2 value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IAnimatedVisual>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IAnimatedVisual, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IAnimatedVisual>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Size(put_abi(value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IAnimatedVisual>**)this;
            check_hresult(_winrt_abi_type->get_Size(put_abi(value)));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IAnimatedVisual<D>::Duration() const
    {
        winrt::Windows::Foundation::TimeSpan value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IAnimatedVisual>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IAnimatedVisual, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IAnimatedVisual>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Duration(put_abi(value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IAnimatedVisual>**)this;
            check_hresult(_winrt_abi_type->get_Duration(put_abi(value)));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IAnimatedVisual2<D>::CreateAnimations() const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IAnimatedVisual2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IAnimatedVisual2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IAnimatedVisual2>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->CreateAnimations());
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IAnimatedVisual2>**)this;
            check_hresult(_winrt_abi_type->CreateAnimations());
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IAnimatedVisual2<D>::DestroyAnimations() const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IAnimatedVisual2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IAnimatedVisual2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IAnimatedVisual2>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->DestroyAnimations());
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IAnimatedVisual2>**)this;
            check_hresult(_winrt_abi_type->DestroyAnimations());
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IAnimatedVisualPlayer<D>::Diagnostics() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IAnimatedVisualPlayer>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IAnimatedVisualPlayer, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IAnimatedVisualPlayer>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Diagnostics(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IAnimatedVisualPlayer>**)this;
            check_hresult(_winrt_abi_type->get_Diagnostics(&value));
        }
        return winrt::Windows::Foundation::IInspectable{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IAnimatedVisualPlayer<D>::Duration() const
    {
        winrt::Windows::Foundation::TimeSpan value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IAnimatedVisualPlayer>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IAnimatedVisualPlayer, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IAnimatedVisualPlayer>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Duration(put_abi(value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IAnimatedVisualPlayer>**)this;
            check_hresult(_winrt_abi_type->get_Duration(put_abi(value)));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IAnimatedVisualPlayer<D>::Source() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IAnimatedVisualPlayer>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IAnimatedVisualPlayer, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IAnimatedVisualPlayer>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Source(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IAnimatedVisualPlayer>**)this;
            check_hresult(_winrt_abi_type->get_Source(&value));
        }
        return winrt::Microsoft::UI::Xaml::Controls::IAnimatedVisualSource{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IAnimatedVisualPlayer<D>::Source(winrt::Microsoft::UI::Xaml::Controls::IAnimatedVisualSource const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IAnimatedVisualPlayer>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IAnimatedVisualPlayer, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IAnimatedVisualPlayer>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_Source(*(void**)(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IAnimatedVisualPlayer>**)this;
            check_hresult(_winrt_abi_type->put_Source(*(void**)(&value)));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IAnimatedVisualPlayer<D>::FallbackContent() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IAnimatedVisualPlayer>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IAnimatedVisualPlayer, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IAnimatedVisualPlayer>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_FallbackContent(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IAnimatedVisualPlayer>**)this;
            check_hresult(_winrt_abi_type->get_FallbackContent(&value));
        }
        return winrt::Windows::UI::Xaml::DataTemplate{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IAnimatedVisualPlayer<D>::FallbackContent(winrt::Windows::UI::Xaml::DataTemplate const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IAnimatedVisualPlayer>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IAnimatedVisualPlayer, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IAnimatedVisualPlayer>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_FallbackContent(*(void**)(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IAnimatedVisualPlayer>**)this;
            check_hresult(_winrt_abi_type->put_FallbackContent(*(void**)(&value)));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IAnimatedVisualPlayer<D>::AutoPlay() const
    {
        bool value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IAnimatedVisualPlayer>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IAnimatedVisualPlayer, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IAnimatedVisualPlayer>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_AutoPlay(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IAnimatedVisualPlayer>**)this;
            check_hresult(_winrt_abi_type->get_AutoPlay(&value));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IAnimatedVisualPlayer<D>::AutoPlay(bool value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IAnimatedVisualPlayer>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IAnimatedVisualPlayer, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IAnimatedVisualPlayer>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_AutoPlay(value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IAnimatedVisualPlayer>**)this;
            check_hresult(_winrt_abi_type->put_AutoPlay(value));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IAnimatedVisualPlayer<D>::IsAnimatedVisualLoaded() const
    {
        bool value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IAnimatedVisualPlayer>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IAnimatedVisualPlayer, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IAnimatedVisualPlayer>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_IsAnimatedVisualLoaded(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IAnimatedVisualPlayer>**)this;
            check_hresult(_winrt_abi_type->get_IsAnimatedVisualLoaded(&value));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IAnimatedVisualPlayer<D>::IsPlaying() const
    {
        bool value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IAnimatedVisualPlayer>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IAnimatedVisualPlayer, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IAnimatedVisualPlayer>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_IsPlaying(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IAnimatedVisualPlayer>**)this;
            check_hresult(_winrt_abi_type->get_IsPlaying(&value));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IAnimatedVisualPlayer<D>::PlaybackRate() const
    {
        double value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IAnimatedVisualPlayer>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IAnimatedVisualPlayer, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IAnimatedVisualPlayer>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_PlaybackRate(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IAnimatedVisualPlayer>**)this;
            check_hresult(_winrt_abi_type->get_PlaybackRate(&value));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IAnimatedVisualPlayer<D>::PlaybackRate(double value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IAnimatedVisualPlayer>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IAnimatedVisualPlayer, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IAnimatedVisualPlayer>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_PlaybackRate(value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IAnimatedVisualPlayer>**)this;
            check_hresult(_winrt_abi_type->put_PlaybackRate(value));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IAnimatedVisualPlayer<D>::ProgressObject() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IAnimatedVisualPlayer>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IAnimatedVisualPlayer, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IAnimatedVisualPlayer>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_ProgressObject(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IAnimatedVisualPlayer>**)this;
            check_hresult(_winrt_abi_type->get_ProgressObject(&value));
        }
        return winrt::Windows::UI::Composition::CompositionObject{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IAnimatedVisualPlayer<D>::Stretch() const
    {
        winrt::Windows::UI::Xaml::Media::Stretch value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IAnimatedVisualPlayer>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IAnimatedVisualPlayer, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IAnimatedVisualPlayer>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Stretch(reinterpret_cast<int32_t*>(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IAnimatedVisualPlayer>**)this;
            check_hresult(_winrt_abi_type->get_Stretch(reinterpret_cast<int32_t*>(&value)));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IAnimatedVisualPlayer<D>::Stretch(winrt::Windows::UI::Xaml::Media::Stretch const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IAnimatedVisualPlayer>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IAnimatedVisualPlayer, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IAnimatedVisualPlayer>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_Stretch(static_cast<int32_t>(value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IAnimatedVisualPlayer>**)this;
            check_hresult(_winrt_abi_type->put_Stretch(static_cast<int32_t>(value)));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IAnimatedVisualPlayer<D>::Pause() const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IAnimatedVisualPlayer>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IAnimatedVisualPlayer, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IAnimatedVisualPlayer>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->Pause());
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IAnimatedVisualPlayer>**)this;
            check_hresult(_winrt_abi_type->Pause());
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IAnimatedVisualPlayer<D>::PlayAsync(double fromProgress, double toProgress, bool looped) const
    {
        void* operation{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IAnimatedVisualPlayer>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IAnimatedVisualPlayer, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IAnimatedVisualPlayer>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->PlayAsync(fromProgress, toProgress, looped, &operation));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IAnimatedVisualPlayer>**)this;
            check_hresult(_winrt_abi_type->PlayAsync(fromProgress, toProgress, looped, &operation));
        }
        return winrt::Windows::Foundation::IAsyncAction{ operation, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IAnimatedVisualPlayer<D>::Resume() const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IAnimatedVisualPlayer>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IAnimatedVisualPlayer, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IAnimatedVisualPlayer>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->Resume());
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IAnimatedVisualPlayer>**)this;
            check_hresult(_winrt_abi_type->Resume());
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IAnimatedVisualPlayer<D>::SetProgress(double progress) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IAnimatedVisualPlayer>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IAnimatedVisualPlayer, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IAnimatedVisualPlayer>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->SetProgress(progress));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IAnimatedVisualPlayer>**)this;
            check_hresult(_winrt_abi_type->SetProgress(progress));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IAnimatedVisualPlayer<D>::Stop() const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IAnimatedVisualPlayer>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IAnimatedVisualPlayer, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IAnimatedVisualPlayer>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->Stop());
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IAnimatedVisualPlayer>**)this;
            check_hresult(_winrt_abi_type->Stop());
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IAnimatedVisualPlayer2<D>::AnimationOptimization() const
    {
        winrt::Microsoft::UI::Xaml::Controls::PlayerAnimationOptimization value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IAnimatedVisualPlayer2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IAnimatedVisualPlayer2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IAnimatedVisualPlayer2>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_AnimationOptimization(reinterpret_cast<int32_t*>(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IAnimatedVisualPlayer2>**)this;
            check_hresult(_winrt_abi_type->get_AnimationOptimization(reinterpret_cast<int32_t*>(&value)));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IAnimatedVisualPlayer2<D>::AnimationOptimization(winrt::Microsoft::UI::Xaml::Controls::PlayerAnimationOptimization const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IAnimatedVisualPlayer2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IAnimatedVisualPlayer2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IAnimatedVisualPlayer2>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_AnimationOptimization(static_cast<int32_t>(value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IAnimatedVisualPlayer2>**)this;
            check_hresult(_winrt_abi_type->put_AnimationOptimization(static_cast<int32_t>(value)));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IAnimatedVisualPlayerFactory<D>::CreateInstance(winrt::Windows::Foundation::IInspectable const& baseInterface, winrt::Windows::Foundation::IInspectable& innerInterface) const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IAnimatedVisualPlayerFactory>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IAnimatedVisualPlayerFactory, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IAnimatedVisualPlayerFactory>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->CreateInstance(*(void**)(&baseInterface), impl::bind_out(innerInterface), &value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IAnimatedVisualPlayerFactory>**)this;
            check_hresult(_winrt_abi_type->CreateInstance(*(void**)(&baseInterface), impl::bind_out(innerInterface), &value));
        }
        return winrt::Microsoft::UI::Xaml::Controls::AnimatedVisualPlayer{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IAnimatedVisualPlayerStatics<D>::AutoPlayProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IAnimatedVisualPlayerStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IAnimatedVisualPlayerStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IAnimatedVisualPlayerStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_AutoPlayProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IAnimatedVisualPlayerStatics>**)this;
            check_hresult(_winrt_abi_type->get_AutoPlayProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IAnimatedVisualPlayerStatics<D>::DiagnosticsProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IAnimatedVisualPlayerStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IAnimatedVisualPlayerStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IAnimatedVisualPlayerStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_DiagnosticsProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IAnimatedVisualPlayerStatics>**)this;
            check_hresult(_winrt_abi_type->get_DiagnosticsProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IAnimatedVisualPlayerStatics<D>::DurationProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IAnimatedVisualPlayerStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IAnimatedVisualPlayerStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IAnimatedVisualPlayerStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_DurationProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IAnimatedVisualPlayerStatics>**)this;
            check_hresult(_winrt_abi_type->get_DurationProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IAnimatedVisualPlayerStatics<D>::FallbackContentProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IAnimatedVisualPlayerStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IAnimatedVisualPlayerStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IAnimatedVisualPlayerStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_FallbackContentProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IAnimatedVisualPlayerStatics>**)this;
            check_hresult(_winrt_abi_type->get_FallbackContentProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IAnimatedVisualPlayerStatics<D>::IsAnimatedVisualLoadedProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IAnimatedVisualPlayerStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IAnimatedVisualPlayerStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IAnimatedVisualPlayerStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_IsAnimatedVisualLoadedProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IAnimatedVisualPlayerStatics>**)this;
            check_hresult(_winrt_abi_type->get_IsAnimatedVisualLoadedProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IAnimatedVisualPlayerStatics<D>::IsPlayingProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IAnimatedVisualPlayerStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IAnimatedVisualPlayerStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IAnimatedVisualPlayerStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_IsPlayingProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IAnimatedVisualPlayerStatics>**)this;
            check_hresult(_winrt_abi_type->get_IsPlayingProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IAnimatedVisualPlayerStatics<D>::PlaybackRateProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IAnimatedVisualPlayerStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IAnimatedVisualPlayerStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IAnimatedVisualPlayerStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_PlaybackRateProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IAnimatedVisualPlayerStatics>**)this;
            check_hresult(_winrt_abi_type->get_PlaybackRateProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IAnimatedVisualPlayerStatics<D>::SourceProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IAnimatedVisualPlayerStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IAnimatedVisualPlayerStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IAnimatedVisualPlayerStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_SourceProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IAnimatedVisualPlayerStatics>**)this;
            check_hresult(_winrt_abi_type->get_SourceProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IAnimatedVisualPlayerStatics<D>::StretchProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IAnimatedVisualPlayerStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IAnimatedVisualPlayerStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IAnimatedVisualPlayerStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_StretchProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IAnimatedVisualPlayerStatics>**)this;
            check_hresult(_winrt_abi_type->get_StretchProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IAnimatedVisualPlayerStatics2<D>::AnimationOptimizationProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IAnimatedVisualPlayerStatics2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IAnimatedVisualPlayerStatics2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IAnimatedVisualPlayerStatics2>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_AnimationOptimizationProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IAnimatedVisualPlayerStatics2>**)this;
            check_hresult(_winrt_abi_type->get_AnimationOptimizationProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IAnimatedVisualSource<D>::TryCreateAnimatedVisual(winrt::Windows::UI::Composition::Compositor const& compositor, winrt::Windows::Foundation::IInspectable& diagnostics) const
    {
        void* result{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IAnimatedVisualSource>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IAnimatedVisualSource, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IAnimatedVisualSource>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->TryCreateAnimatedVisual(*(void**)(&compositor), impl::bind_out(diagnostics), &result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IAnimatedVisualSource>**)this;
            check_hresult(_winrt_abi_type->TryCreateAnimatedVisual(*(void**)(&compositor), impl::bind_out(diagnostics), &result));
        }
        return winrt::Microsoft::UI::Xaml::Controls::IAnimatedVisual{ result, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IAnimatedVisualSource2<D>::Markers() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IAnimatedVisualSource2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IAnimatedVisualSource2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IAnimatedVisualSource2>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Markers(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IAnimatedVisualSource2>**)this;
            check_hresult(_winrt_abi_type->get_Markers(&value));
        }
        return winrt::Windows::Foundation::Collections::IMapView<hstring, double>{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IAnimatedVisualSource2<D>::SetColorProperty(param::hstring const& propertyName, winrt::Windows::UI::Color const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IAnimatedVisualSource2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IAnimatedVisualSource2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IAnimatedVisualSource2>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->SetColorProperty(*(void**)(&propertyName), impl::bind_in(value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IAnimatedVisualSource2>**)this;
            check_hresult(_winrt_abi_type->SetColorProperty(*(void**)(&propertyName), impl::bind_in(value)));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IAnimatedVisualSource3<D>::TryCreateAnimatedVisual(winrt::Windows::UI::Composition::Compositor const& compositor, winrt::Windows::Foundation::IInspectable& diagnostics, bool createAnimations) const
    {
        void* result{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IAnimatedVisualSource3>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IAnimatedVisualSource3, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IAnimatedVisualSource3>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->TryCreateAnimatedVisual(*(void**)(&compositor), impl::bind_out(diagnostics), createAnimations, &result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IAnimatedVisualSource3>**)this;
            check_hresult(_winrt_abi_type->TryCreateAnimatedVisual(*(void**)(&compositor), impl::bind_out(diagnostics), createAnimations, &result));
        }
        return winrt::Microsoft::UI::Xaml::Controls::IAnimatedVisual2{ result, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IBackdropMaterialStatics<D>::ApplyToRootOrPageBackgroundProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IBackdropMaterialStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IBackdropMaterialStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IBackdropMaterialStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_ApplyToRootOrPageBackgroundProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IBackdropMaterialStatics>**)this;
            check_hresult(_winrt_abi_type->get_ApplyToRootOrPageBackgroundProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IBackdropMaterialStatics<D>::SetApplyToRootOrPageBackground(winrt::Windows::UI::Xaml::Controls::Control const& element, bool value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IBackdropMaterialStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IBackdropMaterialStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IBackdropMaterialStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->SetApplyToRootOrPageBackground(*(void**)(&element), value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IBackdropMaterialStatics>**)this;
            check_hresult(_winrt_abi_type->SetApplyToRootOrPageBackground(*(void**)(&element), value));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IBackdropMaterialStatics<D>::GetApplyToRootOrPageBackground(winrt::Windows::UI::Xaml::Controls::Control const& element) const
    {
        bool result{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IBackdropMaterialStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IBackdropMaterialStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IBackdropMaterialStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->GetApplyToRootOrPageBackground(*(void**)(&element), &result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IBackdropMaterialStatics>**)this;
            check_hresult(_winrt_abi_type->GetApplyToRootOrPageBackground(*(void**)(&element), &result));
        }
        return result;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IBitmapIconSource<D>::UriSource() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IBitmapIconSource>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IBitmapIconSource, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IBitmapIconSource>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_UriSource(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IBitmapIconSource>**)this;
            check_hresult(_winrt_abi_type->get_UriSource(&value));
        }
        return winrt::Windows::Foundation::Uri{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IBitmapIconSource<D>::UriSource(winrt::Windows::Foundation::Uri const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IBitmapIconSource>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IBitmapIconSource, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IBitmapIconSource>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_UriSource(*(void**)(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IBitmapIconSource>**)this;
            check_hresult(_winrt_abi_type->put_UriSource(*(void**)(&value)));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IBitmapIconSource<D>::ShowAsMonochrome() const
    {
        bool value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IBitmapIconSource>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IBitmapIconSource, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IBitmapIconSource>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_ShowAsMonochrome(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IBitmapIconSource>**)this;
            check_hresult(_winrt_abi_type->get_ShowAsMonochrome(&value));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IBitmapIconSource<D>::ShowAsMonochrome(bool value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IBitmapIconSource>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IBitmapIconSource, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IBitmapIconSource>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_ShowAsMonochrome(value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IBitmapIconSource>**)this;
            check_hresult(_winrt_abi_type->put_ShowAsMonochrome(value));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IBitmapIconSourceFactory<D>::CreateInstance(winrt::Windows::Foundation::IInspectable const& baseInterface, winrt::Windows::Foundation::IInspectable& innerInterface) const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IBitmapIconSourceFactory>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IBitmapIconSourceFactory, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IBitmapIconSourceFactory>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->CreateInstance(*(void**)(&baseInterface), impl::bind_out(innerInterface), &value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IBitmapIconSourceFactory>**)this;
            check_hresult(_winrt_abi_type->CreateInstance(*(void**)(&baseInterface), impl::bind_out(innerInterface), &value));
        }
        return winrt::Microsoft::UI::Xaml::Controls::BitmapIconSource{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IBitmapIconSourceStatics<D>::UriSourceProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IBitmapIconSourceStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IBitmapIconSourceStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IBitmapIconSourceStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_UriSourceProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IBitmapIconSourceStatics>**)this;
            check_hresult(_winrt_abi_type->get_UriSourceProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IBitmapIconSourceStatics<D>::ShowAsMonochromeProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IBitmapIconSourceStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IBitmapIconSourceStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IBitmapIconSourceStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_ShowAsMonochromeProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IBitmapIconSourceStatics>**)this;
            check_hresult(_winrt_abi_type->get_ShowAsMonochromeProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IBreadcrumbBar<D>::ItemsSource() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IBreadcrumbBar>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IBreadcrumbBar, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IBreadcrumbBar>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_ItemsSource(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IBreadcrumbBar>**)this;
            check_hresult(_winrt_abi_type->get_ItemsSource(&value));
        }
        return winrt::Windows::Foundation::IInspectable{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IBreadcrumbBar<D>::ItemsSource(winrt::Windows::Foundation::IInspectable const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IBreadcrumbBar>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IBreadcrumbBar, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IBreadcrumbBar>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_ItemsSource(*(void**)(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IBreadcrumbBar>**)this;
            check_hresult(_winrt_abi_type->put_ItemsSource(*(void**)(&value)));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IBreadcrumbBar<D>::ItemTemplate() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IBreadcrumbBar>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IBreadcrumbBar, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IBreadcrumbBar>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_ItemTemplate(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IBreadcrumbBar>**)this;
            check_hresult(_winrt_abi_type->get_ItemTemplate(&value));
        }
        return winrt::Windows::Foundation::IInspectable{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IBreadcrumbBar<D>::ItemTemplate(winrt::Windows::Foundation::IInspectable const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IBreadcrumbBar>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IBreadcrumbBar, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IBreadcrumbBar>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_ItemTemplate(*(void**)(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IBreadcrumbBar>**)this;
            check_hresult(_winrt_abi_type->put_ItemTemplate(*(void**)(&value)));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IBreadcrumbBar<D>::ItemClicked(winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Xaml::Controls::BreadcrumbBar, winrt::Microsoft::UI::Xaml::Controls::BreadcrumbBarItemClickedEventArgs> const& handler) const
    {
        winrt::event_token token{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IBreadcrumbBar>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IBreadcrumbBar, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IBreadcrumbBar>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->add_ItemClicked(*(void**)(&handler), put_abi(token)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IBreadcrumbBar>**)this;
            check_hresult(_winrt_abi_type->add_ItemClicked(*(void**)(&handler), put_abi(token)));
        }
        return token;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IBreadcrumbBar<D>::ItemClicked(auto_revoke_t, winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Xaml::Controls::BreadcrumbBar, winrt::Microsoft::UI::Xaml::Controls::BreadcrumbBarItemClickedEventArgs> const& handler) const
    {
        return impl::make_event_revoker<D, ItemClicked_revoker>(this, ItemClicked(handler));
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IBreadcrumbBar<D>::ItemClicked(winrt::event_token const& token) const noexcept
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IBreadcrumbBar>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IBreadcrumbBar, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IBreadcrumbBar>**)&_winrt_casted_result;
            _winrt_abi_type->remove_ItemClicked(impl::bind_in(token));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IBreadcrumbBar>**)this;
            _winrt_abi_type->remove_ItemClicked(impl::bind_in(token));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IBreadcrumbBarFactory<D>::CreateInstance(winrt::Windows::Foundation::IInspectable const& baseInterface, winrt::Windows::Foundation::IInspectable& innerInterface) const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IBreadcrumbBarFactory>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IBreadcrumbBarFactory, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IBreadcrumbBarFactory>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->CreateInstance(*(void**)(&baseInterface), impl::bind_out(innerInterface), &value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IBreadcrumbBarFactory>**)this;
            check_hresult(_winrt_abi_type->CreateInstance(*(void**)(&baseInterface), impl::bind_out(innerInterface), &value));
        }
        return winrt::Microsoft::UI::Xaml::Controls::BreadcrumbBar{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IBreadcrumbBarItemClickedEventArgs<D>::Index() const
    {
        int32_t value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IBreadcrumbBarItemClickedEventArgs>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IBreadcrumbBarItemClickedEventArgs, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IBreadcrumbBarItemClickedEventArgs>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Index(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IBreadcrumbBarItemClickedEventArgs>**)this;
            check_hresult(_winrt_abi_type->get_Index(&value));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IBreadcrumbBarItemClickedEventArgs<D>::Item() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IBreadcrumbBarItemClickedEventArgs>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IBreadcrumbBarItemClickedEventArgs, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IBreadcrumbBarItemClickedEventArgs>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Item(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IBreadcrumbBarItemClickedEventArgs>**)this;
            check_hresult(_winrt_abi_type->get_Item(&value));
        }
        return winrt::Windows::Foundation::IInspectable{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IBreadcrumbBarItemFactory<D>::CreateInstance(winrt::Windows::Foundation::IInspectable const& baseInterface, winrt::Windows::Foundation::IInspectable& innerInterface) const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IBreadcrumbBarItemFactory>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IBreadcrumbBarItemFactory, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IBreadcrumbBarItemFactory>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->CreateInstance(*(void**)(&baseInterface), impl::bind_out(innerInterface), &value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IBreadcrumbBarItemFactory>**)this;
            check_hresult(_winrt_abi_type->CreateInstance(*(void**)(&baseInterface), impl::bind_out(innerInterface), &value));
        }
        return winrt::Microsoft::UI::Xaml::Controls::BreadcrumbBarItem{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IBreadcrumbBarStatics<D>::ItemsSourceProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IBreadcrumbBarStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IBreadcrumbBarStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IBreadcrumbBarStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_ItemsSourceProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IBreadcrumbBarStatics>**)this;
            check_hresult(_winrt_abi_type->get_ItemsSourceProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IBreadcrumbBarStatics<D>::ItemTemplateProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IBreadcrumbBarStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IBreadcrumbBarStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IBreadcrumbBarStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_ItemTemplateProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IBreadcrumbBarStatics>**)this;
            check_hresult(_winrt_abi_type->get_ItemTemplateProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IColorChangedEventArgs<D>::OldColor() const
    {
        winrt::Windows::UI::Color value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IColorChangedEventArgs>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IColorChangedEventArgs, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IColorChangedEventArgs>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_OldColor(put_abi(value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IColorChangedEventArgs>**)this;
            check_hresult(_winrt_abi_type->get_OldColor(put_abi(value)));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IColorChangedEventArgs<D>::NewColor() const
    {
        winrt::Windows::UI::Color value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IColorChangedEventArgs>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IColorChangedEventArgs, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IColorChangedEventArgs>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_NewColor(put_abi(value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IColorChangedEventArgs>**)this;
            check_hresult(_winrt_abi_type->get_NewColor(put_abi(value)));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IColorPicker<D>::Color() const
    {
        winrt::Windows::UI::Color value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IColorPicker>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IColorPicker, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IColorPicker>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Color(put_abi(value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IColorPicker>**)this;
            check_hresult(_winrt_abi_type->get_Color(put_abi(value)));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IColorPicker<D>::Color(winrt::Windows::UI::Color const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IColorPicker>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IColorPicker, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IColorPicker>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_Color(impl::bind_in(value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IColorPicker>**)this;
            check_hresult(_winrt_abi_type->put_Color(impl::bind_in(value)));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IColorPicker<D>::PreviousColor() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IColorPicker>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IColorPicker, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IColorPicker>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_PreviousColor(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IColorPicker>**)this;
            check_hresult(_winrt_abi_type->get_PreviousColor(&value));
        }
        return winrt::Windows::Foundation::IReference<winrt::Windows::UI::Color>{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IColorPicker<D>::PreviousColor(winrt::Windows::Foundation::IReference<winrt::Windows::UI::Color> const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IColorPicker>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IColorPicker, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IColorPicker>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_PreviousColor(*(void**)(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IColorPicker>**)this;
            check_hresult(_winrt_abi_type->put_PreviousColor(*(void**)(&value)));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IColorPicker<D>::IsAlphaEnabled() const
    {
        bool value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IColorPicker>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IColorPicker, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IColorPicker>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_IsAlphaEnabled(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IColorPicker>**)this;
            check_hresult(_winrt_abi_type->get_IsAlphaEnabled(&value));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IColorPicker<D>::IsAlphaEnabled(bool value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IColorPicker>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IColorPicker, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IColorPicker>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_IsAlphaEnabled(value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IColorPicker>**)this;
            check_hresult(_winrt_abi_type->put_IsAlphaEnabled(value));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IColorPicker<D>::IsColorSpectrumVisible() const
    {
        bool value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IColorPicker>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IColorPicker, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IColorPicker>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_IsColorSpectrumVisible(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IColorPicker>**)this;
            check_hresult(_winrt_abi_type->get_IsColorSpectrumVisible(&value));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IColorPicker<D>::IsColorSpectrumVisible(bool value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IColorPicker>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IColorPicker, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IColorPicker>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_IsColorSpectrumVisible(value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IColorPicker>**)this;
            check_hresult(_winrt_abi_type->put_IsColorSpectrumVisible(value));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IColorPicker<D>::IsColorPreviewVisible() const
    {
        bool value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IColorPicker>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IColorPicker, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IColorPicker>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_IsColorPreviewVisible(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IColorPicker>**)this;
            check_hresult(_winrt_abi_type->get_IsColorPreviewVisible(&value));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IColorPicker<D>::IsColorPreviewVisible(bool value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IColorPicker>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IColorPicker, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IColorPicker>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_IsColorPreviewVisible(value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IColorPicker>**)this;
            check_hresult(_winrt_abi_type->put_IsColorPreviewVisible(value));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IColorPicker<D>::IsColorSliderVisible() const
    {
        bool value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IColorPicker>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IColorPicker, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IColorPicker>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_IsColorSliderVisible(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IColorPicker>**)this;
            check_hresult(_winrt_abi_type->get_IsColorSliderVisible(&value));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IColorPicker<D>::IsColorSliderVisible(bool value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IColorPicker>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IColorPicker, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IColorPicker>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_IsColorSliderVisible(value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IColorPicker>**)this;
            check_hresult(_winrt_abi_type->put_IsColorSliderVisible(value));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IColorPicker<D>::IsAlphaSliderVisible() const
    {
        bool value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IColorPicker>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IColorPicker, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IColorPicker>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_IsAlphaSliderVisible(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IColorPicker>**)this;
            check_hresult(_winrt_abi_type->get_IsAlphaSliderVisible(&value));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IColorPicker<D>::IsAlphaSliderVisible(bool value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IColorPicker>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IColorPicker, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IColorPicker>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_IsAlphaSliderVisible(value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IColorPicker>**)this;
            check_hresult(_winrt_abi_type->put_IsAlphaSliderVisible(value));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IColorPicker<D>::IsMoreButtonVisible() const
    {
        bool value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IColorPicker>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IColorPicker, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IColorPicker>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_IsMoreButtonVisible(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IColorPicker>**)this;
            check_hresult(_winrt_abi_type->get_IsMoreButtonVisible(&value));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IColorPicker<D>::IsMoreButtonVisible(bool value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IColorPicker>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IColorPicker, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IColorPicker>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_IsMoreButtonVisible(value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IColorPicker>**)this;
            check_hresult(_winrt_abi_type->put_IsMoreButtonVisible(value));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IColorPicker<D>::IsColorChannelTextInputVisible() const
    {
        bool value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IColorPicker>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IColorPicker, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IColorPicker>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_IsColorChannelTextInputVisible(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IColorPicker>**)this;
            check_hresult(_winrt_abi_type->get_IsColorChannelTextInputVisible(&value));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IColorPicker<D>::IsColorChannelTextInputVisible(bool value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IColorPicker>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IColorPicker, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IColorPicker>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_IsColorChannelTextInputVisible(value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IColorPicker>**)this;
            check_hresult(_winrt_abi_type->put_IsColorChannelTextInputVisible(value));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IColorPicker<D>::IsAlphaTextInputVisible() const
    {
        bool value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IColorPicker>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IColorPicker, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IColorPicker>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_IsAlphaTextInputVisible(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IColorPicker>**)this;
            check_hresult(_winrt_abi_type->get_IsAlphaTextInputVisible(&value));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IColorPicker<D>::IsAlphaTextInputVisible(bool value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IColorPicker>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IColorPicker, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IColorPicker>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_IsAlphaTextInputVisible(value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IColorPicker>**)this;
            check_hresult(_winrt_abi_type->put_IsAlphaTextInputVisible(value));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IColorPicker<D>::IsHexInputVisible() const
    {
        bool value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IColorPicker>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IColorPicker, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IColorPicker>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_IsHexInputVisible(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IColorPicker>**)this;
            check_hresult(_winrt_abi_type->get_IsHexInputVisible(&value));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IColorPicker<D>::IsHexInputVisible(bool value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IColorPicker>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IColorPicker, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IColorPicker>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_IsHexInputVisible(value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IColorPicker>**)this;
            check_hresult(_winrt_abi_type->put_IsHexInputVisible(value));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IColorPicker<D>::MinHue() const
    {
        int32_t value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IColorPicker>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IColorPicker, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IColorPicker>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_MinHue(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IColorPicker>**)this;
            check_hresult(_winrt_abi_type->get_MinHue(&value));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IColorPicker<D>::MinHue(int32_t value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IColorPicker>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IColorPicker, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IColorPicker>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_MinHue(value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IColorPicker>**)this;
            check_hresult(_winrt_abi_type->put_MinHue(value));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IColorPicker<D>::MaxHue() const
    {
        int32_t value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IColorPicker>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IColorPicker, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IColorPicker>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_MaxHue(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IColorPicker>**)this;
            check_hresult(_winrt_abi_type->get_MaxHue(&value));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IColorPicker<D>::MaxHue(int32_t value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IColorPicker>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IColorPicker, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IColorPicker>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_MaxHue(value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IColorPicker>**)this;
            check_hresult(_winrt_abi_type->put_MaxHue(value));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IColorPicker<D>::MinSaturation() const
    {
        int32_t value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IColorPicker>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IColorPicker, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IColorPicker>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_MinSaturation(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IColorPicker>**)this;
            check_hresult(_winrt_abi_type->get_MinSaturation(&value));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IColorPicker<D>::MinSaturation(int32_t value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IColorPicker>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IColorPicker, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IColorPicker>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_MinSaturation(value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IColorPicker>**)this;
            check_hresult(_winrt_abi_type->put_MinSaturation(value));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IColorPicker<D>::MaxSaturation() const
    {
        int32_t value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IColorPicker>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IColorPicker, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IColorPicker>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_MaxSaturation(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IColorPicker>**)this;
            check_hresult(_winrt_abi_type->get_MaxSaturation(&value));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IColorPicker<D>::MaxSaturation(int32_t value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IColorPicker>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IColorPicker, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IColorPicker>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_MaxSaturation(value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IColorPicker>**)this;
            check_hresult(_winrt_abi_type->put_MaxSaturation(value));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IColorPicker<D>::MinValue() const
    {
        int32_t value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IColorPicker>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IColorPicker, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IColorPicker>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_MinValue(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IColorPicker>**)this;
            check_hresult(_winrt_abi_type->get_MinValue(&value));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IColorPicker<D>::MinValue(int32_t value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IColorPicker>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IColorPicker, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IColorPicker>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_MinValue(value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IColorPicker>**)this;
            check_hresult(_winrt_abi_type->put_MinValue(value));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IColorPicker<D>::MaxValue() const
    {
        int32_t value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IColorPicker>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IColorPicker, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IColorPicker>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_MaxValue(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IColorPicker>**)this;
            check_hresult(_winrt_abi_type->get_MaxValue(&value));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IColorPicker<D>::MaxValue(int32_t value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IColorPicker>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IColorPicker, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IColorPicker>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_MaxValue(value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IColorPicker>**)this;
            check_hresult(_winrt_abi_type->put_MaxValue(value));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IColorPicker<D>::ColorSpectrumShape() const
    {
        winrt::Microsoft::UI::Xaml::Controls::ColorSpectrumShape value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IColorPicker>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IColorPicker, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IColorPicker>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_ColorSpectrumShape(reinterpret_cast<int32_t*>(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IColorPicker>**)this;
            check_hresult(_winrt_abi_type->get_ColorSpectrumShape(reinterpret_cast<int32_t*>(&value)));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IColorPicker<D>::ColorSpectrumShape(winrt::Microsoft::UI::Xaml::Controls::ColorSpectrumShape const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IColorPicker>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IColorPicker, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IColorPicker>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_ColorSpectrumShape(static_cast<int32_t>(value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IColorPicker>**)this;
            check_hresult(_winrt_abi_type->put_ColorSpectrumShape(static_cast<int32_t>(value)));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IColorPicker<D>::ColorSpectrumComponents() const
    {
        winrt::Microsoft::UI::Xaml::Controls::ColorSpectrumComponents value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IColorPicker>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IColorPicker, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IColorPicker>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_ColorSpectrumComponents(reinterpret_cast<int32_t*>(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IColorPicker>**)this;
            check_hresult(_winrt_abi_type->get_ColorSpectrumComponents(reinterpret_cast<int32_t*>(&value)));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IColorPicker<D>::ColorSpectrumComponents(winrt::Microsoft::UI::Xaml::Controls::ColorSpectrumComponents const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IColorPicker>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IColorPicker, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IColorPicker>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_ColorSpectrumComponents(static_cast<int32_t>(value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IColorPicker>**)this;
            check_hresult(_winrt_abi_type->put_ColorSpectrumComponents(static_cast<int32_t>(value)));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IColorPicker<D>::ColorChanged(winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Xaml::Controls::ColorPicker, winrt::Microsoft::UI::Xaml::Controls::ColorChangedEventArgs> const& handler) const
    {
        winrt::event_token token{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IColorPicker>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IColorPicker, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IColorPicker>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->add_ColorChanged(*(void**)(&handler), put_abi(token)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IColorPicker>**)this;
            check_hresult(_winrt_abi_type->add_ColorChanged(*(void**)(&handler), put_abi(token)));
        }
        return token;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IColorPicker<D>::ColorChanged(auto_revoke_t, winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Xaml::Controls::ColorPicker, winrt::Microsoft::UI::Xaml::Controls::ColorChangedEventArgs> const& handler) const
    {
        return impl::make_event_revoker<D, ColorChanged_revoker>(this, ColorChanged(handler));
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IColorPicker<D>::ColorChanged(winrt::event_token const& token) const noexcept
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IColorPicker>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IColorPicker, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IColorPicker>**)&_winrt_casted_result;
            _winrt_abi_type->remove_ColorChanged(impl::bind_in(token));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IColorPicker>**)this;
            _winrt_abi_type->remove_ColorChanged(impl::bind_in(token));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IColorPicker2<D>::Orientation() const
    {
        winrt::Windows::UI::Xaml::Controls::Orientation value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IColorPicker2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IColorPicker2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IColorPicker2>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Orientation(reinterpret_cast<int32_t*>(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IColorPicker2>**)this;
            check_hresult(_winrt_abi_type->get_Orientation(reinterpret_cast<int32_t*>(&value)));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IColorPicker2<D>::Orientation(winrt::Windows::UI::Xaml::Controls::Orientation const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IColorPicker2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IColorPicker2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IColorPicker2>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_Orientation(static_cast<int32_t>(value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IColorPicker2>**)this;
            check_hresult(_winrt_abi_type->put_Orientation(static_cast<int32_t>(value)));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IColorPickerFactory<D>::CreateInstance(winrt::Windows::Foundation::IInspectable const& baseInterface, winrt::Windows::Foundation::IInspectable& innerInterface) const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IColorPickerFactory>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IColorPickerFactory, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IColorPickerFactory>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->CreateInstance(*(void**)(&baseInterface), impl::bind_out(innerInterface), &value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IColorPickerFactory>**)this;
            check_hresult(_winrt_abi_type->CreateInstance(*(void**)(&baseInterface), impl::bind_out(innerInterface), &value));
        }
        return winrt::Microsoft::UI::Xaml::Controls::ColorPicker{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IColorPickerStatics<D>::ColorProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IColorPickerStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IColorPickerStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IColorPickerStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_ColorProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IColorPickerStatics>**)this;
            check_hresult(_winrt_abi_type->get_ColorProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IColorPickerStatics<D>::PreviousColorProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IColorPickerStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IColorPickerStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IColorPickerStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_PreviousColorProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IColorPickerStatics>**)this;
            check_hresult(_winrt_abi_type->get_PreviousColorProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IColorPickerStatics<D>::IsAlphaEnabledProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IColorPickerStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IColorPickerStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IColorPickerStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_IsAlphaEnabledProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IColorPickerStatics>**)this;
            check_hresult(_winrt_abi_type->get_IsAlphaEnabledProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IColorPickerStatics<D>::IsColorSpectrumVisibleProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IColorPickerStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IColorPickerStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IColorPickerStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_IsColorSpectrumVisibleProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IColorPickerStatics>**)this;
            check_hresult(_winrt_abi_type->get_IsColorSpectrumVisibleProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IColorPickerStatics<D>::IsColorPreviewVisibleProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IColorPickerStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IColorPickerStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IColorPickerStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_IsColorPreviewVisibleProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IColorPickerStatics>**)this;
            check_hresult(_winrt_abi_type->get_IsColorPreviewVisibleProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IColorPickerStatics<D>::IsColorSliderVisibleProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IColorPickerStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IColorPickerStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IColorPickerStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_IsColorSliderVisibleProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IColorPickerStatics>**)this;
            check_hresult(_winrt_abi_type->get_IsColorSliderVisibleProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IColorPickerStatics<D>::IsAlphaSliderVisibleProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IColorPickerStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IColorPickerStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IColorPickerStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_IsAlphaSliderVisibleProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IColorPickerStatics>**)this;
            check_hresult(_winrt_abi_type->get_IsAlphaSliderVisibleProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IColorPickerStatics<D>::IsMoreButtonVisibleProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IColorPickerStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IColorPickerStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IColorPickerStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_IsMoreButtonVisibleProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IColorPickerStatics>**)this;
            check_hresult(_winrt_abi_type->get_IsMoreButtonVisibleProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IColorPickerStatics<D>::IsColorChannelTextInputVisibleProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IColorPickerStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IColorPickerStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IColorPickerStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_IsColorChannelTextInputVisibleProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IColorPickerStatics>**)this;
            check_hresult(_winrt_abi_type->get_IsColorChannelTextInputVisibleProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IColorPickerStatics<D>::IsAlphaTextInputVisibleProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IColorPickerStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IColorPickerStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IColorPickerStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_IsAlphaTextInputVisibleProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IColorPickerStatics>**)this;
            check_hresult(_winrt_abi_type->get_IsAlphaTextInputVisibleProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IColorPickerStatics<D>::IsHexInputVisibleProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IColorPickerStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IColorPickerStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IColorPickerStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_IsHexInputVisibleProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IColorPickerStatics>**)this;
            check_hresult(_winrt_abi_type->get_IsHexInputVisibleProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IColorPickerStatics<D>::MinHueProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IColorPickerStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IColorPickerStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IColorPickerStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_MinHueProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IColorPickerStatics>**)this;
            check_hresult(_winrt_abi_type->get_MinHueProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IColorPickerStatics<D>::MaxHueProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IColorPickerStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IColorPickerStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IColorPickerStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_MaxHueProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IColorPickerStatics>**)this;
            check_hresult(_winrt_abi_type->get_MaxHueProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IColorPickerStatics<D>::MinSaturationProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IColorPickerStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IColorPickerStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IColorPickerStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_MinSaturationProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IColorPickerStatics>**)this;
            check_hresult(_winrt_abi_type->get_MinSaturationProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IColorPickerStatics<D>::MaxSaturationProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IColorPickerStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IColorPickerStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IColorPickerStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_MaxSaturationProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IColorPickerStatics>**)this;
            check_hresult(_winrt_abi_type->get_MaxSaturationProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IColorPickerStatics<D>::MinValueProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IColorPickerStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IColorPickerStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IColorPickerStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_MinValueProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IColorPickerStatics>**)this;
            check_hresult(_winrt_abi_type->get_MinValueProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IColorPickerStatics<D>::MaxValueProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IColorPickerStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IColorPickerStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IColorPickerStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_MaxValueProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IColorPickerStatics>**)this;
            check_hresult(_winrt_abi_type->get_MaxValueProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IColorPickerStatics<D>::ColorSpectrumShapeProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IColorPickerStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IColorPickerStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IColorPickerStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_ColorSpectrumShapeProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IColorPickerStatics>**)this;
            check_hresult(_winrt_abi_type->get_ColorSpectrumShapeProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IColorPickerStatics<D>::ColorSpectrumComponentsProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IColorPickerStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IColorPickerStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IColorPickerStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_ColorSpectrumComponentsProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IColorPickerStatics>**)this;
            check_hresult(_winrt_abi_type->get_ColorSpectrumComponentsProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IColorPickerStatics2<D>::OrientationProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IColorPickerStatics2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IColorPickerStatics2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IColorPickerStatics2>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_OrientationProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IColorPickerStatics2>**)this;
            check_hresult(_winrt_abi_type->get_OrientationProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ICommandBarFlyout<D>::PrimaryCommands() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ICommandBarFlyout>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ICommandBarFlyout, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ICommandBarFlyout>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_PrimaryCommands(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ICommandBarFlyout>**)this;
            check_hresult(_winrt_abi_type->get_PrimaryCommands(&value));
        }
        return winrt::Windows::Foundation::Collections::IObservableVector<winrt::Windows::UI::Xaml::Controls::ICommandBarElement>{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ICommandBarFlyout<D>::SecondaryCommands() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ICommandBarFlyout>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ICommandBarFlyout, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ICommandBarFlyout>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_SecondaryCommands(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ICommandBarFlyout>**)this;
            check_hresult(_winrt_abi_type->get_SecondaryCommands(&value));
        }
        return winrt::Windows::Foundation::Collections::IObservableVector<winrt::Windows::UI::Xaml::Controls::ICommandBarElement>{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ICommandBarFlyout2<D>::AlwaysExpanded() const
    {
        bool value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ICommandBarFlyout2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ICommandBarFlyout2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ICommandBarFlyout2>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_AlwaysExpanded(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ICommandBarFlyout2>**)this;
            check_hresult(_winrt_abi_type->get_AlwaysExpanded(&value));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ICommandBarFlyout2<D>::AlwaysExpanded(bool value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ICommandBarFlyout2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ICommandBarFlyout2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ICommandBarFlyout2>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_AlwaysExpanded(value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ICommandBarFlyout2>**)this;
            check_hresult(_winrt_abi_type->put_AlwaysExpanded(value));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ICommandBarFlyoutFactory<D>::CreateInstance(winrt::Windows::Foundation::IInspectable const& baseInterface, winrt::Windows::Foundation::IInspectable& innerInterface) const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ICommandBarFlyoutFactory>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ICommandBarFlyoutFactory, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ICommandBarFlyoutFactory>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->CreateInstance(*(void**)(&baseInterface), impl::bind_out(innerInterface), &value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ICommandBarFlyoutFactory>**)this;
            check_hresult(_winrt_abi_type->CreateInstance(*(void**)(&baseInterface), impl::bind_out(innerInterface), &value));
        }
        return winrt::Microsoft::UI::Xaml::Controls::CommandBarFlyout{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ICoreWebView2InitializedEventArgs<D>::Exception() const
    {
        winrt::hresult value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ICoreWebView2InitializedEventArgs>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ICoreWebView2InitializedEventArgs, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ICoreWebView2InitializedEventArgs>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Exception(put_abi(value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ICoreWebView2InitializedEventArgs>**)this;
            check_hresult(_winrt_abi_type->get_Exception(put_abi(value)));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IDropDownButtonFactory<D>::CreateInstance(winrt::Windows::Foundation::IInspectable const& baseInterface, winrt::Windows::Foundation::IInspectable& innerInterface) const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IDropDownButtonFactory>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IDropDownButtonFactory, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IDropDownButtonFactory>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->CreateInstance(*(void**)(&baseInterface), impl::bind_out(innerInterface), &value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IDropDownButtonFactory>**)this;
            check_hresult(_winrt_abi_type->CreateInstance(*(void**)(&baseInterface), impl::bind_out(innerInterface), &value));
        }
        return winrt::Microsoft::UI::Xaml::Controls::DropDownButton{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IDynamicAnimatedVisualSource<D>::AnimatedVisualInvalidated(winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Xaml::Controls::IDynamicAnimatedVisualSource, winrt::Windows::Foundation::IInspectable> const& handler) const
    {
        winrt::event_token token{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IDynamicAnimatedVisualSource>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IDynamicAnimatedVisualSource, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IDynamicAnimatedVisualSource>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->add_AnimatedVisualInvalidated(*(void**)(&handler), put_abi(token)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IDynamicAnimatedVisualSource>**)this;
            check_hresult(_winrt_abi_type->add_AnimatedVisualInvalidated(*(void**)(&handler), put_abi(token)));
        }
        return token;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IDynamicAnimatedVisualSource<D>::AnimatedVisualInvalidated(auto_revoke_t, winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Xaml::Controls::IDynamicAnimatedVisualSource, winrt::Windows::Foundation::IInspectable> const& handler) const
    {
        return impl::make_event_revoker<D, AnimatedVisualInvalidated_revoker>(this, AnimatedVisualInvalidated(handler));
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IDynamicAnimatedVisualSource<D>::AnimatedVisualInvalidated(winrt::event_token const& token) const noexcept
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IDynamicAnimatedVisualSource>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IDynamicAnimatedVisualSource, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IDynamicAnimatedVisualSource>**)&_winrt_casted_result;
            _winrt_abi_type->remove_AnimatedVisualInvalidated(impl::bind_in(token));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IDynamicAnimatedVisualSource>**)this;
            _winrt_abi_type->remove_AnimatedVisualInvalidated(impl::bind_in(token));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IElementFactoryFactory<D>::CreateInstance(winrt::Windows::Foundation::IInspectable const& baseInterface, winrt::Windows::Foundation::IInspectable& innerInterface) const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IElementFactoryFactory>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IElementFactoryFactory, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IElementFactoryFactory>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->CreateInstance(*(void**)(&baseInterface), impl::bind_out(innerInterface), &value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IElementFactoryFactory>**)this;
            check_hresult(_winrt_abi_type->CreateInstance(*(void**)(&baseInterface), impl::bind_out(innerInterface), &value));
        }
        return winrt::Microsoft::UI::Xaml::Controls::ElementFactory{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IElementFactoryGetArgs<D>::Data() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IElementFactoryGetArgs>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IElementFactoryGetArgs, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IElementFactoryGetArgs>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Data(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IElementFactoryGetArgs>**)this;
            check_hresult(_winrt_abi_type->get_Data(&value));
        }
        return winrt::Windows::Foundation::IInspectable{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IElementFactoryGetArgs<D>::Data(winrt::Windows::Foundation::IInspectable const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IElementFactoryGetArgs>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IElementFactoryGetArgs, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IElementFactoryGetArgs>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_Data(*(void**)(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IElementFactoryGetArgs>**)this;
            check_hresult(_winrt_abi_type->put_Data(*(void**)(&value)));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IElementFactoryGetArgs<D>::Parent() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IElementFactoryGetArgs>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IElementFactoryGetArgs, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IElementFactoryGetArgs>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Parent(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IElementFactoryGetArgs>**)this;
            check_hresult(_winrt_abi_type->get_Parent(&value));
        }
        return winrt::Windows::UI::Xaml::UIElement{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IElementFactoryGetArgs<D>::Parent(winrt::Windows::UI::Xaml::UIElement const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IElementFactoryGetArgs>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IElementFactoryGetArgs, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IElementFactoryGetArgs>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_Parent(*(void**)(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IElementFactoryGetArgs>**)this;
            check_hresult(_winrt_abi_type->put_Parent(*(void**)(&value)));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IElementFactoryOverrides<D>::GetElementCore(winrt::Microsoft::UI::Xaml::Controls::ElementFactoryGetArgs const& args) const
    {
        void* result{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IElementFactoryOverrides>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IElementFactoryOverrides, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IElementFactoryOverrides>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->GetElementCore(*(void**)(&args), &result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IElementFactoryOverrides>**)this;
            check_hresult(_winrt_abi_type->GetElementCore(*(void**)(&args), &result));
        }
        return winrt::Windows::UI::Xaml::UIElement{ result, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IElementFactoryOverrides<D>::RecycleElementCore(winrt::Microsoft::UI::Xaml::Controls::ElementFactoryRecycleArgs const& args) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IElementFactoryOverrides>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IElementFactoryOverrides, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IElementFactoryOverrides>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->RecycleElementCore(*(void**)(&args)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IElementFactoryOverrides>**)this;
            check_hresult(_winrt_abi_type->RecycleElementCore(*(void**)(&args)));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IElementFactoryRecycleArgs<D>::Element() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IElementFactoryRecycleArgs>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IElementFactoryRecycleArgs, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IElementFactoryRecycleArgs>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Element(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IElementFactoryRecycleArgs>**)this;
            check_hresult(_winrt_abi_type->get_Element(&value));
        }
        return winrt::Windows::UI::Xaml::UIElement{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IElementFactoryRecycleArgs<D>::Element(winrt::Windows::UI::Xaml::UIElement const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IElementFactoryRecycleArgs>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IElementFactoryRecycleArgs, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IElementFactoryRecycleArgs>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_Element(*(void**)(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IElementFactoryRecycleArgs>**)this;
            check_hresult(_winrt_abi_type->put_Element(*(void**)(&value)));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IElementFactoryRecycleArgs<D>::Parent() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IElementFactoryRecycleArgs>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IElementFactoryRecycleArgs, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IElementFactoryRecycleArgs>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Parent(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IElementFactoryRecycleArgs>**)this;
            check_hresult(_winrt_abi_type->get_Parent(&value));
        }
        return winrt::Windows::UI::Xaml::UIElement{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IElementFactoryRecycleArgs<D>::Parent(winrt::Windows::UI::Xaml::UIElement const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IElementFactoryRecycleArgs>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IElementFactoryRecycleArgs, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IElementFactoryRecycleArgs>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_Parent(*(void**)(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IElementFactoryRecycleArgs>**)this;
            check_hresult(_winrt_abi_type->put_Parent(*(void**)(&value)));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IExpander<D>::Header() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IExpander>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IExpander, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IExpander>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Header(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IExpander>**)this;
            check_hresult(_winrt_abi_type->get_Header(&value));
        }
        return winrt::Windows::Foundation::IInspectable{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IExpander<D>::Header(winrt::Windows::Foundation::IInspectable const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IExpander>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IExpander, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IExpander>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_Header(*(void**)(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IExpander>**)this;
            check_hresult(_winrt_abi_type->put_Header(*(void**)(&value)));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IExpander<D>::HeaderTemplate() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IExpander>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IExpander, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IExpander>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_HeaderTemplate(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IExpander>**)this;
            check_hresult(_winrt_abi_type->get_HeaderTemplate(&value));
        }
        return winrt::Windows::UI::Xaml::DataTemplate{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IExpander<D>::HeaderTemplate(winrt::Windows::UI::Xaml::DataTemplate const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IExpander>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IExpander, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IExpander>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_HeaderTemplate(*(void**)(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IExpander>**)this;
            check_hresult(_winrt_abi_type->put_HeaderTemplate(*(void**)(&value)));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IExpander<D>::HeaderTemplateSelector() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IExpander>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IExpander, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IExpander>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_HeaderTemplateSelector(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IExpander>**)this;
            check_hresult(_winrt_abi_type->get_HeaderTemplateSelector(&value));
        }
        return winrt::Windows::UI::Xaml::Controls::DataTemplateSelector{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IExpander<D>::HeaderTemplateSelector(winrt::Windows::UI::Xaml::Controls::DataTemplateSelector const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IExpander>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IExpander, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IExpander>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_HeaderTemplateSelector(*(void**)(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IExpander>**)this;
            check_hresult(_winrt_abi_type->put_HeaderTemplateSelector(*(void**)(&value)));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IExpander<D>::IsExpanded() const
    {
        bool value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IExpander>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IExpander, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IExpander>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_IsExpanded(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IExpander>**)this;
            check_hresult(_winrt_abi_type->get_IsExpanded(&value));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IExpander<D>::IsExpanded(bool value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IExpander>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IExpander, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IExpander>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_IsExpanded(value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IExpander>**)this;
            check_hresult(_winrt_abi_type->put_IsExpanded(value));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IExpander<D>::ExpandDirection() const
    {
        winrt::Microsoft::UI::Xaml::Controls::ExpandDirection value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IExpander>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IExpander, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IExpander>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_ExpandDirection(reinterpret_cast<int32_t*>(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IExpander>**)this;
            check_hresult(_winrt_abi_type->get_ExpandDirection(reinterpret_cast<int32_t*>(&value)));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IExpander<D>::ExpandDirection(winrt::Microsoft::UI::Xaml::Controls::ExpandDirection const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IExpander>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IExpander, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IExpander>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_ExpandDirection(static_cast<int32_t>(value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IExpander>**)this;
            check_hresult(_winrt_abi_type->put_ExpandDirection(static_cast<int32_t>(value)));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IExpander<D>::Expanding(winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Xaml::Controls::Expander, winrt::Microsoft::UI::Xaml::Controls::ExpanderExpandingEventArgs> const& handler) const
    {
        winrt::event_token token{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IExpander>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IExpander, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IExpander>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->add_Expanding(*(void**)(&handler), put_abi(token)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IExpander>**)this;
            check_hresult(_winrt_abi_type->add_Expanding(*(void**)(&handler), put_abi(token)));
        }
        return token;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IExpander<D>::Expanding(auto_revoke_t, winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Xaml::Controls::Expander, winrt::Microsoft::UI::Xaml::Controls::ExpanderExpandingEventArgs> const& handler) const
    {
        return impl::make_event_revoker<D, Expanding_revoker>(this, Expanding(handler));
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IExpander<D>::Expanding(winrt::event_token const& token) const noexcept
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IExpander>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IExpander, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IExpander>**)&_winrt_casted_result;
            _winrt_abi_type->remove_Expanding(impl::bind_in(token));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IExpander>**)this;
            _winrt_abi_type->remove_Expanding(impl::bind_in(token));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IExpander<D>::Collapsed(winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Xaml::Controls::Expander, winrt::Microsoft::UI::Xaml::Controls::ExpanderCollapsedEventArgs> const& handler) const
    {
        winrt::event_token token{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IExpander>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IExpander, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IExpander>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->add_Collapsed(*(void**)(&handler), put_abi(token)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IExpander>**)this;
            check_hresult(_winrt_abi_type->add_Collapsed(*(void**)(&handler), put_abi(token)));
        }
        return token;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IExpander<D>::Collapsed(auto_revoke_t, winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Xaml::Controls::Expander, winrt::Microsoft::UI::Xaml::Controls::ExpanderCollapsedEventArgs> const& handler) const
    {
        return impl::make_event_revoker<D, Collapsed_revoker>(this, Collapsed(handler));
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IExpander<D>::Collapsed(winrt::event_token const& token) const noexcept
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IExpander>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IExpander, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IExpander>**)&_winrt_casted_result;
            _winrt_abi_type->remove_Collapsed(impl::bind_in(token));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IExpander>**)this;
            _winrt_abi_type->remove_Collapsed(impl::bind_in(token));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IExpander<D>::TemplateSettings() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IExpander>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IExpander, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IExpander>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_TemplateSettings(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IExpander>**)this;
            check_hresult(_winrt_abi_type->get_TemplateSettings(&value));
        }
        return winrt::Microsoft::UI::Xaml::Controls::ExpanderTemplateSettings{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IExpanderFactory<D>::CreateInstance(winrt::Windows::Foundation::IInspectable const& baseInterface, winrt::Windows::Foundation::IInspectable& innerInterface) const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IExpanderFactory>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IExpanderFactory, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IExpanderFactory>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->CreateInstance(*(void**)(&baseInterface), impl::bind_out(innerInterface), &value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IExpanderFactory>**)this;
            check_hresult(_winrt_abi_type->CreateInstance(*(void**)(&baseInterface), impl::bind_out(innerInterface), &value));
        }
        return winrt::Microsoft::UI::Xaml::Controls::Expander{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IExpanderStatics<D>::HeaderProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IExpanderStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IExpanderStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IExpanderStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_HeaderProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IExpanderStatics>**)this;
            check_hresult(_winrt_abi_type->get_HeaderProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IExpanderStatics<D>::HeaderTemplateProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IExpanderStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IExpanderStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IExpanderStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_HeaderTemplateProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IExpanderStatics>**)this;
            check_hresult(_winrt_abi_type->get_HeaderTemplateProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IExpanderStatics<D>::HeaderTemplateSelectorProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IExpanderStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IExpanderStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IExpanderStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_HeaderTemplateSelectorProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IExpanderStatics>**)this;
            check_hresult(_winrt_abi_type->get_HeaderTemplateSelectorProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IExpanderStatics<D>::IsExpandedProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IExpanderStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IExpanderStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IExpanderStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_IsExpandedProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IExpanderStatics>**)this;
            check_hresult(_winrt_abi_type->get_IsExpandedProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IExpanderStatics<D>::ExpandDirectionProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IExpanderStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IExpanderStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IExpanderStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_ExpandDirectionProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IExpanderStatics>**)this;
            check_hresult(_winrt_abi_type->get_ExpandDirectionProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IExpanderTemplateSettings<D>::ContentHeight() const
    {
        double value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IExpanderTemplateSettings>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IExpanderTemplateSettings, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IExpanderTemplateSettings>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_ContentHeight(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IExpanderTemplateSettings>**)this;
            check_hresult(_winrt_abi_type->get_ContentHeight(&value));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IExpanderTemplateSettings<D>::NegativeContentHeight() const
    {
        double value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IExpanderTemplateSettings>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IExpanderTemplateSettings, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IExpanderTemplateSettings>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_NegativeContentHeight(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IExpanderTemplateSettings>**)this;
            check_hresult(_winrt_abi_type->get_NegativeContentHeight(&value));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IFontIconSource<D>::Glyph() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IFontIconSource>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IFontIconSource, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IFontIconSource>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Glyph(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IFontIconSource>**)this;
            check_hresult(_winrt_abi_type->get_Glyph(&value));
        }
        return hstring{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IFontIconSource<D>::Glyph(param::hstring const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IFontIconSource>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IFontIconSource, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IFontIconSource>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_Glyph(*(void**)(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IFontIconSource>**)this;
            check_hresult(_winrt_abi_type->put_Glyph(*(void**)(&value)));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IFontIconSource<D>::FontSize() const
    {
        double value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IFontIconSource>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IFontIconSource, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IFontIconSource>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_FontSize(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IFontIconSource>**)this;
            check_hresult(_winrt_abi_type->get_FontSize(&value));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IFontIconSource<D>::FontSize(double value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IFontIconSource>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IFontIconSource, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IFontIconSource>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_FontSize(value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IFontIconSource>**)this;
            check_hresult(_winrt_abi_type->put_FontSize(value));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IFontIconSource<D>::FontFamily() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IFontIconSource>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IFontIconSource, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IFontIconSource>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_FontFamily(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IFontIconSource>**)this;
            check_hresult(_winrt_abi_type->get_FontFamily(&value));
        }
        return winrt::Windows::UI::Xaml::Media::FontFamily{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IFontIconSource<D>::FontFamily(winrt::Windows::UI::Xaml::Media::FontFamily const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IFontIconSource>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IFontIconSource, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IFontIconSource>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_FontFamily(*(void**)(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IFontIconSource>**)this;
            check_hresult(_winrt_abi_type->put_FontFamily(*(void**)(&value)));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IFontIconSource<D>::FontWeight() const
    {
        winrt::Windows::UI::Text::FontWeight value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IFontIconSource>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IFontIconSource, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IFontIconSource>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_FontWeight(put_abi(value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IFontIconSource>**)this;
            check_hresult(_winrt_abi_type->get_FontWeight(put_abi(value)));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IFontIconSource<D>::FontWeight(winrt::Windows::UI::Text::FontWeight const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IFontIconSource>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IFontIconSource, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IFontIconSource>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_FontWeight(impl::bind_in(value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IFontIconSource>**)this;
            check_hresult(_winrt_abi_type->put_FontWeight(impl::bind_in(value)));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IFontIconSource<D>::FontStyle() const
    {
        winrt::Windows::UI::Text::FontStyle value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IFontIconSource>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IFontIconSource, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IFontIconSource>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_FontStyle(reinterpret_cast<int32_t*>(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IFontIconSource>**)this;
            check_hresult(_winrt_abi_type->get_FontStyle(reinterpret_cast<int32_t*>(&value)));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IFontIconSource<D>::FontStyle(winrt::Windows::UI::Text::FontStyle const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IFontIconSource>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IFontIconSource, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IFontIconSource>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_FontStyle(static_cast<int32_t>(value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IFontIconSource>**)this;
            check_hresult(_winrt_abi_type->put_FontStyle(static_cast<int32_t>(value)));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IFontIconSource<D>::IsTextScaleFactorEnabled() const
    {
        bool value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IFontIconSource>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IFontIconSource, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IFontIconSource>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_IsTextScaleFactorEnabled(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IFontIconSource>**)this;
            check_hresult(_winrt_abi_type->get_IsTextScaleFactorEnabled(&value));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IFontIconSource<D>::IsTextScaleFactorEnabled(bool value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IFontIconSource>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IFontIconSource, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IFontIconSource>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_IsTextScaleFactorEnabled(value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IFontIconSource>**)this;
            check_hresult(_winrt_abi_type->put_IsTextScaleFactorEnabled(value));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IFontIconSource<D>::MirroredWhenRightToLeft() const
    {
        bool value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IFontIconSource>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IFontIconSource, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IFontIconSource>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_MirroredWhenRightToLeft(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IFontIconSource>**)this;
            check_hresult(_winrt_abi_type->get_MirroredWhenRightToLeft(&value));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IFontIconSource<D>::MirroredWhenRightToLeft(bool value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IFontIconSource>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IFontIconSource, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IFontIconSource>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_MirroredWhenRightToLeft(value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IFontIconSource>**)this;
            check_hresult(_winrt_abi_type->put_MirroredWhenRightToLeft(value));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IFontIconSourceFactory<D>::CreateInstance(winrt::Windows::Foundation::IInspectable const& baseInterface, winrt::Windows::Foundation::IInspectable& innerInterface) const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IFontIconSourceFactory>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IFontIconSourceFactory, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IFontIconSourceFactory>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->CreateInstance(*(void**)(&baseInterface), impl::bind_out(innerInterface), &value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IFontIconSourceFactory>**)this;
            check_hresult(_winrt_abi_type->CreateInstance(*(void**)(&baseInterface), impl::bind_out(innerInterface), &value));
        }
        return winrt::Microsoft::UI::Xaml::Controls::FontIconSource{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IFontIconSourceStatics<D>::GlyphProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IFontIconSourceStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IFontIconSourceStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IFontIconSourceStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_GlyphProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IFontIconSourceStatics>**)this;
            check_hresult(_winrt_abi_type->get_GlyphProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IFontIconSourceStatics<D>::FontSizeProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IFontIconSourceStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IFontIconSourceStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IFontIconSourceStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_FontSizeProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IFontIconSourceStatics>**)this;
            check_hresult(_winrt_abi_type->get_FontSizeProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IFontIconSourceStatics<D>::FontFamilyProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IFontIconSourceStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IFontIconSourceStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IFontIconSourceStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_FontFamilyProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IFontIconSourceStatics>**)this;
            check_hresult(_winrt_abi_type->get_FontFamilyProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IFontIconSourceStatics<D>::FontWeightProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IFontIconSourceStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IFontIconSourceStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IFontIconSourceStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_FontWeightProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IFontIconSourceStatics>**)this;
            check_hresult(_winrt_abi_type->get_FontWeightProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IFontIconSourceStatics<D>::FontStyleProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IFontIconSourceStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IFontIconSourceStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IFontIconSourceStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_FontStyleProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IFontIconSourceStatics>**)this;
            check_hresult(_winrt_abi_type->get_FontStyleProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IFontIconSourceStatics<D>::IsTextScaleFactorEnabledProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IFontIconSourceStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IFontIconSourceStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IFontIconSourceStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_IsTextScaleFactorEnabledProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IFontIconSourceStatics>**)this;
            check_hresult(_winrt_abi_type->get_IsTextScaleFactorEnabledProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IFontIconSourceStatics<D>::MirroredWhenRightToLeftProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IFontIconSourceStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IFontIconSourceStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IFontIconSourceStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_MirroredWhenRightToLeftProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IFontIconSourceStatics>**)this;
            check_hresult(_winrt_abi_type->get_MirroredWhenRightToLeftProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IIconSource<D>::CreateIconElement() const
    {
        void* result{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IIconSource>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IIconSource, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IIconSource>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->CreateIconElement(&result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IIconSource>**)this;
            check_hresult(_winrt_abi_type->CreateIconElement(&result));
        }
        return winrt::Windows::UI::Xaml::Controls::IconElement{ result, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IIconSource<D>::Foreground() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IIconSource>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IIconSource, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IIconSource>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Foreground(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IIconSource>**)this;
            check_hresult(_winrt_abi_type->get_Foreground(&value));
        }
        return winrt::Windows::UI::Xaml::Media::Brush{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IIconSource<D>::Foreground(winrt::Windows::UI::Xaml::Media::Brush const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IIconSource>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IIconSource, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IIconSource>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_Foreground(*(void**)(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IIconSource>**)this;
            check_hresult(_winrt_abi_type->put_Foreground(*(void**)(&value)));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IIconSourceStatics<D>::ForegroundProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IIconSourceStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IIconSourceStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IIconSourceStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_ForegroundProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IIconSourceStatics>**)this;
            check_hresult(_winrt_abi_type->get_ForegroundProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IImageIcon<D>::Source() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IImageIcon>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IImageIcon, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IImageIcon>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Source(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IImageIcon>**)this;
            check_hresult(_winrt_abi_type->get_Source(&value));
        }
        return winrt::Windows::UI::Xaml::Media::ImageSource{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IImageIcon<D>::Source(winrt::Windows::UI::Xaml::Media::ImageSource const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IImageIcon>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IImageIcon, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IImageIcon>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_Source(*(void**)(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IImageIcon>**)this;
            check_hresult(_winrt_abi_type->put_Source(*(void**)(&value)));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IImageIconFactory<D>::CreateInstance(winrt::Windows::Foundation::IInspectable const& baseInterface, winrt::Windows::Foundation::IInspectable& innerInterface) const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IImageIconFactory>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IImageIconFactory, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IImageIconFactory>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->CreateInstance(*(void**)(&baseInterface), impl::bind_out(innerInterface), &value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IImageIconFactory>**)this;
            check_hresult(_winrt_abi_type->CreateInstance(*(void**)(&baseInterface), impl::bind_out(innerInterface), &value));
        }
        return winrt::Microsoft::UI::Xaml::Controls::ImageIcon{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IImageIconSource<D>::ImageSource() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IImageIconSource>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IImageIconSource, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IImageIconSource>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_ImageSource(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IImageIconSource>**)this;
            check_hresult(_winrt_abi_type->get_ImageSource(&value));
        }
        return winrt::Windows::UI::Xaml::Media::ImageSource{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IImageIconSource<D>::ImageSource(winrt::Windows::UI::Xaml::Media::ImageSource const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IImageIconSource>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IImageIconSource, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IImageIconSource>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_ImageSource(*(void**)(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IImageIconSource>**)this;
            check_hresult(_winrt_abi_type->put_ImageSource(*(void**)(&value)));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IImageIconSourceFactory<D>::CreateInstance(winrt::Windows::Foundation::IInspectable const& baseInterface, winrt::Windows::Foundation::IInspectable& innerInterface) const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IImageIconSourceFactory>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IImageIconSourceFactory, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IImageIconSourceFactory>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->CreateInstance(*(void**)(&baseInterface), impl::bind_out(innerInterface), &value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IImageIconSourceFactory>**)this;
            check_hresult(_winrt_abi_type->CreateInstance(*(void**)(&baseInterface), impl::bind_out(innerInterface), &value));
        }
        return winrt::Microsoft::UI::Xaml::Controls::ImageIconSource{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IImageIconSourceStatics<D>::ImageSourceProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IImageIconSourceStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IImageIconSourceStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IImageIconSourceStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_ImageSourceProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IImageIconSourceStatics>**)this;
            check_hresult(_winrt_abi_type->get_ImageSourceProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IImageIconStatics<D>::SourceProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IImageIconStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IImageIconStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IImageIconStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_SourceProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IImageIconStatics>**)this;
            check_hresult(_winrt_abi_type->get_SourceProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IInfoBadge<D>::Value() const
    {
        int32_t value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IInfoBadge>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IInfoBadge, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IInfoBadge>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Value(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IInfoBadge>**)this;
            check_hresult(_winrt_abi_type->get_Value(&value));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IInfoBadge<D>::Value(int32_t value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IInfoBadge>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IInfoBadge, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IInfoBadge>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_Value(value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IInfoBadge>**)this;
            check_hresult(_winrt_abi_type->put_Value(value));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IInfoBadge<D>::IconSource() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IInfoBadge>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IInfoBadge, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IInfoBadge>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_IconSource(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IInfoBadge>**)this;
            check_hresult(_winrt_abi_type->get_IconSource(&value));
        }
        return winrt::Microsoft::UI::Xaml::Controls::IconSource{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IInfoBadge<D>::IconSource(winrt::Microsoft::UI::Xaml::Controls::IconSource const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IInfoBadge>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IInfoBadge, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IInfoBadge>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_IconSource(*(void**)(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IInfoBadge>**)this;
            check_hresult(_winrt_abi_type->put_IconSource(*(void**)(&value)));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IInfoBadge<D>::TemplateSettings() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IInfoBadge>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IInfoBadge, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IInfoBadge>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_TemplateSettings(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IInfoBadge>**)this;
            check_hresult(_winrt_abi_type->get_TemplateSettings(&value));
        }
        return winrt::Microsoft::UI::Xaml::Controls::InfoBadgeTemplateSettings{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IInfoBadgeFactory<D>::CreateInstance(winrt::Windows::Foundation::IInspectable const& baseInterface, winrt::Windows::Foundation::IInspectable& innerInterface) const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IInfoBadgeFactory>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IInfoBadgeFactory, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IInfoBadgeFactory>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->CreateInstance(*(void**)(&baseInterface), impl::bind_out(innerInterface), &value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IInfoBadgeFactory>**)this;
            check_hresult(_winrt_abi_type->CreateInstance(*(void**)(&baseInterface), impl::bind_out(innerInterface), &value));
        }
        return winrt::Microsoft::UI::Xaml::Controls::InfoBadge{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IInfoBadgeStatics<D>::ValueProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IInfoBadgeStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IInfoBadgeStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IInfoBadgeStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_ValueProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IInfoBadgeStatics>**)this;
            check_hresult(_winrt_abi_type->get_ValueProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IInfoBadgeStatics<D>::IconSourceProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IInfoBadgeStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IInfoBadgeStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IInfoBadgeStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_IconSourceProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IInfoBadgeStatics>**)this;
            check_hresult(_winrt_abi_type->get_IconSourceProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IInfoBadgeStatics<D>::TemplateSettingsProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IInfoBadgeStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IInfoBadgeStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IInfoBadgeStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_TemplateSettingsProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IInfoBadgeStatics>**)this;
            check_hresult(_winrt_abi_type->get_TemplateSettingsProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IInfoBadgeTemplateSettings<D>::InfoBadgeCornerRadius() const
    {
        winrt::Windows::UI::Xaml::CornerRadius value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IInfoBadgeTemplateSettings>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IInfoBadgeTemplateSettings, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IInfoBadgeTemplateSettings>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_InfoBadgeCornerRadius(put_abi(value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IInfoBadgeTemplateSettings>**)this;
            check_hresult(_winrt_abi_type->get_InfoBadgeCornerRadius(put_abi(value)));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IInfoBadgeTemplateSettings<D>::InfoBadgeCornerRadius(winrt::Windows::UI::Xaml::CornerRadius const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IInfoBadgeTemplateSettings>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IInfoBadgeTemplateSettings, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IInfoBadgeTemplateSettings>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_InfoBadgeCornerRadius(impl::bind_in(value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IInfoBadgeTemplateSettings>**)this;
            check_hresult(_winrt_abi_type->put_InfoBadgeCornerRadius(impl::bind_in(value)));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IInfoBadgeTemplateSettings<D>::IconElement() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IInfoBadgeTemplateSettings>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IInfoBadgeTemplateSettings, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IInfoBadgeTemplateSettings>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_IconElement(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IInfoBadgeTemplateSettings>**)this;
            check_hresult(_winrt_abi_type->get_IconElement(&value));
        }
        return winrt::Windows::UI::Xaml::Controls::IconElement{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IInfoBadgeTemplateSettings<D>::IconElement(winrt::Windows::UI::Xaml::Controls::IconElement const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IInfoBadgeTemplateSettings>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IInfoBadgeTemplateSettings, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IInfoBadgeTemplateSettings>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_IconElement(*(void**)(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IInfoBadgeTemplateSettings>**)this;
            check_hresult(_winrt_abi_type->put_IconElement(*(void**)(&value)));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IInfoBadgeTemplateSettingsFactory<D>::CreateInstance(winrt::Windows::Foundation::IInspectable const& baseInterface, winrt::Windows::Foundation::IInspectable& innerInterface) const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IInfoBadgeTemplateSettingsFactory>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IInfoBadgeTemplateSettingsFactory, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IInfoBadgeTemplateSettingsFactory>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->CreateInstance(*(void**)(&baseInterface), impl::bind_out(innerInterface), &value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IInfoBadgeTemplateSettingsFactory>**)this;
            check_hresult(_winrt_abi_type->CreateInstance(*(void**)(&baseInterface), impl::bind_out(innerInterface), &value));
        }
        return winrt::Microsoft::UI::Xaml::Controls::InfoBadgeTemplateSettings{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IInfoBadgeTemplateSettingsStatics<D>::InfoBadgeCornerRadiusProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IInfoBadgeTemplateSettingsStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IInfoBadgeTemplateSettingsStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IInfoBadgeTemplateSettingsStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_InfoBadgeCornerRadiusProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IInfoBadgeTemplateSettingsStatics>**)this;
            check_hresult(_winrt_abi_type->get_InfoBadgeCornerRadiusProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IInfoBadgeTemplateSettingsStatics<D>::IconElementProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IInfoBadgeTemplateSettingsStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IInfoBadgeTemplateSettingsStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IInfoBadgeTemplateSettingsStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_IconElementProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IInfoBadgeTemplateSettingsStatics>**)this;
            check_hresult(_winrt_abi_type->get_IconElementProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IInfoBar<D>::IsOpen() const
    {
        bool value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IInfoBar>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IInfoBar, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IInfoBar>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_IsOpen(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IInfoBar>**)this;
            check_hresult(_winrt_abi_type->get_IsOpen(&value));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IInfoBar<D>::IsOpen(bool value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IInfoBar>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IInfoBar, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IInfoBar>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_IsOpen(value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IInfoBar>**)this;
            check_hresult(_winrt_abi_type->put_IsOpen(value));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IInfoBar<D>::Title() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IInfoBar>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IInfoBar, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IInfoBar>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Title(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IInfoBar>**)this;
            check_hresult(_winrt_abi_type->get_Title(&value));
        }
        return hstring{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IInfoBar<D>::Title(param::hstring const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IInfoBar>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IInfoBar, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IInfoBar>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_Title(*(void**)(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IInfoBar>**)this;
            check_hresult(_winrt_abi_type->put_Title(*(void**)(&value)));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IInfoBar<D>::Message() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IInfoBar>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IInfoBar, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IInfoBar>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Message(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IInfoBar>**)this;
            check_hresult(_winrt_abi_type->get_Message(&value));
        }
        return hstring{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IInfoBar<D>::Message(param::hstring const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IInfoBar>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IInfoBar, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IInfoBar>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_Message(*(void**)(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IInfoBar>**)this;
            check_hresult(_winrt_abi_type->put_Message(*(void**)(&value)));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IInfoBar<D>::Severity() const
    {
        winrt::Microsoft::UI::Xaml::Controls::InfoBarSeverity value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IInfoBar>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IInfoBar, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IInfoBar>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Severity(reinterpret_cast<int32_t*>(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IInfoBar>**)this;
            check_hresult(_winrt_abi_type->get_Severity(reinterpret_cast<int32_t*>(&value)));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IInfoBar<D>::Severity(winrt::Microsoft::UI::Xaml::Controls::InfoBarSeverity const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IInfoBar>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IInfoBar, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IInfoBar>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_Severity(static_cast<int32_t>(value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IInfoBar>**)this;
            check_hresult(_winrt_abi_type->put_Severity(static_cast<int32_t>(value)));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IInfoBar<D>::IconSource() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IInfoBar>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IInfoBar, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IInfoBar>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_IconSource(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IInfoBar>**)this;
            check_hresult(_winrt_abi_type->get_IconSource(&value));
        }
        return winrt::Microsoft::UI::Xaml::Controls::IconSource{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IInfoBar<D>::IconSource(winrt::Microsoft::UI::Xaml::Controls::IconSource const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IInfoBar>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IInfoBar, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IInfoBar>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_IconSource(*(void**)(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IInfoBar>**)this;
            check_hresult(_winrt_abi_type->put_IconSource(*(void**)(&value)));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IInfoBar<D>::IsIconVisible() const
    {
        bool value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IInfoBar>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IInfoBar, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IInfoBar>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_IsIconVisible(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IInfoBar>**)this;
            check_hresult(_winrt_abi_type->get_IsIconVisible(&value));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IInfoBar<D>::IsIconVisible(bool value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IInfoBar>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IInfoBar, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IInfoBar>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_IsIconVisible(value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IInfoBar>**)this;
            check_hresult(_winrt_abi_type->put_IsIconVisible(value));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IInfoBar<D>::IsClosable() const
    {
        bool value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IInfoBar>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IInfoBar, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IInfoBar>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_IsClosable(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IInfoBar>**)this;
            check_hresult(_winrt_abi_type->get_IsClosable(&value));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IInfoBar<D>::IsClosable(bool value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IInfoBar>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IInfoBar, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IInfoBar>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_IsClosable(value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IInfoBar>**)this;
            check_hresult(_winrt_abi_type->put_IsClosable(value));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IInfoBar<D>::CloseButtonStyle() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IInfoBar>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IInfoBar, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IInfoBar>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_CloseButtonStyle(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IInfoBar>**)this;
            check_hresult(_winrt_abi_type->get_CloseButtonStyle(&value));
        }
        return winrt::Windows::UI::Xaml::Style{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IInfoBar<D>::CloseButtonStyle(winrt::Windows::UI::Xaml::Style const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IInfoBar>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IInfoBar, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IInfoBar>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_CloseButtonStyle(*(void**)(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IInfoBar>**)this;
            check_hresult(_winrt_abi_type->put_CloseButtonStyle(*(void**)(&value)));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IInfoBar<D>::CloseButtonCommand() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IInfoBar>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IInfoBar, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IInfoBar>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_CloseButtonCommand(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IInfoBar>**)this;
            check_hresult(_winrt_abi_type->get_CloseButtonCommand(&value));
        }
        return winrt::Windows::UI::Xaml::Input::ICommand{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IInfoBar<D>::CloseButtonCommand(winrt::Windows::UI::Xaml::Input::ICommand const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IInfoBar>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IInfoBar, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IInfoBar>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_CloseButtonCommand(*(void**)(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IInfoBar>**)this;
            check_hresult(_winrt_abi_type->put_CloseButtonCommand(*(void**)(&value)));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IInfoBar<D>::CloseButtonCommandParameter() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IInfoBar>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IInfoBar, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IInfoBar>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_CloseButtonCommandParameter(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IInfoBar>**)this;
            check_hresult(_winrt_abi_type->get_CloseButtonCommandParameter(&value));
        }
        return winrt::Windows::Foundation::IInspectable{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IInfoBar<D>::CloseButtonCommandParameter(winrt::Windows::Foundation::IInspectable const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IInfoBar>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IInfoBar, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IInfoBar>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_CloseButtonCommandParameter(*(void**)(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IInfoBar>**)this;
            check_hresult(_winrt_abi_type->put_CloseButtonCommandParameter(*(void**)(&value)));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IInfoBar<D>::ActionButton() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IInfoBar>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IInfoBar, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IInfoBar>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_ActionButton(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IInfoBar>**)this;
            check_hresult(_winrt_abi_type->get_ActionButton(&value));
        }
        return winrt::Windows::UI::Xaml::Controls::Primitives::ButtonBase{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IInfoBar<D>::ActionButton(winrt::Windows::UI::Xaml::Controls::Primitives::ButtonBase const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IInfoBar>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IInfoBar, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IInfoBar>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_ActionButton(*(void**)(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IInfoBar>**)this;
            check_hresult(_winrt_abi_type->put_ActionButton(*(void**)(&value)));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IInfoBar<D>::Content() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IInfoBar>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IInfoBar, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IInfoBar>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Content(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IInfoBar>**)this;
            check_hresult(_winrt_abi_type->get_Content(&value));
        }
        return winrt::Windows::Foundation::IInspectable{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IInfoBar<D>::Content(winrt::Windows::Foundation::IInspectable const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IInfoBar>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IInfoBar, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IInfoBar>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_Content(*(void**)(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IInfoBar>**)this;
            check_hresult(_winrt_abi_type->put_Content(*(void**)(&value)));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IInfoBar<D>::ContentTemplate() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IInfoBar>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IInfoBar, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IInfoBar>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_ContentTemplate(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IInfoBar>**)this;
            check_hresult(_winrt_abi_type->get_ContentTemplate(&value));
        }
        return winrt::Windows::UI::Xaml::DataTemplate{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IInfoBar<D>::ContentTemplate(winrt::Windows::UI::Xaml::DataTemplate const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IInfoBar>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IInfoBar, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IInfoBar>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_ContentTemplate(*(void**)(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IInfoBar>**)this;
            check_hresult(_winrt_abi_type->put_ContentTemplate(*(void**)(&value)));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IInfoBar<D>::TemplateSettings() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IInfoBar>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IInfoBar, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IInfoBar>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_TemplateSettings(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IInfoBar>**)this;
            check_hresult(_winrt_abi_type->get_TemplateSettings(&value));
        }
        return winrt::Microsoft::UI::Xaml::Controls::InfoBarTemplateSettings{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IInfoBar<D>::CloseButtonClick(winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Xaml::Controls::InfoBar, winrt::Windows::Foundation::IInspectable> const& handler) const
    {
        winrt::event_token token{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IInfoBar>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IInfoBar, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IInfoBar>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->add_CloseButtonClick(*(void**)(&handler), put_abi(token)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IInfoBar>**)this;
            check_hresult(_winrt_abi_type->add_CloseButtonClick(*(void**)(&handler), put_abi(token)));
        }
        return token;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IInfoBar<D>::CloseButtonClick(auto_revoke_t, winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Xaml::Controls::InfoBar, winrt::Windows::Foundation::IInspectable> const& handler) const
    {
        return impl::make_event_revoker<D, CloseButtonClick_revoker>(this, CloseButtonClick(handler));
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IInfoBar<D>::CloseButtonClick(winrt::event_token const& token) const noexcept
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IInfoBar>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IInfoBar, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IInfoBar>**)&_winrt_casted_result;
            _winrt_abi_type->remove_CloseButtonClick(impl::bind_in(token));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IInfoBar>**)this;
            _winrt_abi_type->remove_CloseButtonClick(impl::bind_in(token));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IInfoBar<D>::Closing(winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Xaml::Controls::InfoBar, winrt::Microsoft::UI::Xaml::Controls::InfoBarClosingEventArgs> const& handler) const
    {
        winrt::event_token token{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IInfoBar>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IInfoBar, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IInfoBar>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->add_Closing(*(void**)(&handler), put_abi(token)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IInfoBar>**)this;
            check_hresult(_winrt_abi_type->add_Closing(*(void**)(&handler), put_abi(token)));
        }
        return token;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IInfoBar<D>::Closing(auto_revoke_t, winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Xaml::Controls::InfoBar, winrt::Microsoft::UI::Xaml::Controls::InfoBarClosingEventArgs> const& handler) const
    {
        return impl::make_event_revoker<D, Closing_revoker>(this, Closing(handler));
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IInfoBar<D>::Closing(winrt::event_token const& token) const noexcept
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IInfoBar>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IInfoBar, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IInfoBar>**)&_winrt_casted_result;
            _winrt_abi_type->remove_Closing(impl::bind_in(token));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IInfoBar>**)this;
            _winrt_abi_type->remove_Closing(impl::bind_in(token));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IInfoBar<D>::Closed(winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Xaml::Controls::InfoBar, winrt::Microsoft::UI::Xaml::Controls::InfoBarClosedEventArgs> const& handler) const
    {
        winrt::event_token token{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IInfoBar>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IInfoBar, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IInfoBar>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->add_Closed(*(void**)(&handler), put_abi(token)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IInfoBar>**)this;
            check_hresult(_winrt_abi_type->add_Closed(*(void**)(&handler), put_abi(token)));
        }
        return token;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IInfoBar<D>::Closed(auto_revoke_t, winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Xaml::Controls::InfoBar, winrt::Microsoft::UI::Xaml::Controls::InfoBarClosedEventArgs> const& handler) const
    {
        return impl::make_event_revoker<D, Closed_revoker>(this, Closed(handler));
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IInfoBar<D>::Closed(winrt::event_token const& token) const noexcept
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IInfoBar>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IInfoBar, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IInfoBar>**)&_winrt_casted_result;
            _winrt_abi_type->remove_Closed(impl::bind_in(token));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IInfoBar>**)this;
            _winrt_abi_type->remove_Closed(impl::bind_in(token));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IInfoBarClosedEventArgs<D>::Reason() const
    {
        winrt::Microsoft::UI::Xaml::Controls::InfoBarCloseReason value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IInfoBarClosedEventArgs>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IInfoBarClosedEventArgs, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IInfoBarClosedEventArgs>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Reason(reinterpret_cast<int32_t*>(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IInfoBarClosedEventArgs>**)this;
            check_hresult(_winrt_abi_type->get_Reason(reinterpret_cast<int32_t*>(&value)));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IInfoBarClosingEventArgs<D>::Reason() const
    {
        winrt::Microsoft::UI::Xaml::Controls::InfoBarCloseReason value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IInfoBarClosingEventArgs>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IInfoBarClosingEventArgs, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IInfoBarClosingEventArgs>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Reason(reinterpret_cast<int32_t*>(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IInfoBarClosingEventArgs>**)this;
            check_hresult(_winrt_abi_type->get_Reason(reinterpret_cast<int32_t*>(&value)));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IInfoBarClosingEventArgs<D>::Cancel() const
    {
        bool value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IInfoBarClosingEventArgs>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IInfoBarClosingEventArgs, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IInfoBarClosingEventArgs>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Cancel(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IInfoBarClosingEventArgs>**)this;
            check_hresult(_winrt_abi_type->get_Cancel(&value));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IInfoBarClosingEventArgs<D>::Cancel(bool value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IInfoBarClosingEventArgs>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IInfoBarClosingEventArgs, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IInfoBarClosingEventArgs>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_Cancel(value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IInfoBarClosingEventArgs>**)this;
            check_hresult(_winrt_abi_type->put_Cancel(value));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IInfoBarFactory<D>::CreateInstance(winrt::Windows::Foundation::IInspectable const& baseInterface, winrt::Windows::Foundation::IInspectable& innerInterface) const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IInfoBarFactory>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IInfoBarFactory, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IInfoBarFactory>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->CreateInstance(*(void**)(&baseInterface), impl::bind_out(innerInterface), &value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IInfoBarFactory>**)this;
            check_hresult(_winrt_abi_type->CreateInstance(*(void**)(&baseInterface), impl::bind_out(innerInterface), &value));
        }
        return winrt::Microsoft::UI::Xaml::Controls::InfoBar{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IInfoBarStatics<D>::IsOpenProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IInfoBarStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IInfoBarStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IInfoBarStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_IsOpenProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IInfoBarStatics>**)this;
            check_hresult(_winrt_abi_type->get_IsOpenProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IInfoBarStatics<D>::TitleProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IInfoBarStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IInfoBarStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IInfoBarStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_TitleProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IInfoBarStatics>**)this;
            check_hresult(_winrt_abi_type->get_TitleProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IInfoBarStatics<D>::MessageProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IInfoBarStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IInfoBarStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IInfoBarStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_MessageProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IInfoBarStatics>**)this;
            check_hresult(_winrt_abi_type->get_MessageProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IInfoBarStatics<D>::SeverityProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IInfoBarStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IInfoBarStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IInfoBarStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_SeverityProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IInfoBarStatics>**)this;
            check_hresult(_winrt_abi_type->get_SeverityProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IInfoBarStatics<D>::IconSourceProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IInfoBarStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IInfoBarStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IInfoBarStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_IconSourceProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IInfoBarStatics>**)this;
            check_hresult(_winrt_abi_type->get_IconSourceProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IInfoBarStatics<D>::IsIconVisibleProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IInfoBarStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IInfoBarStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IInfoBarStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_IsIconVisibleProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IInfoBarStatics>**)this;
            check_hresult(_winrt_abi_type->get_IsIconVisibleProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IInfoBarStatics<D>::IsClosableProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IInfoBarStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IInfoBarStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IInfoBarStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_IsClosableProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IInfoBarStatics>**)this;
            check_hresult(_winrt_abi_type->get_IsClosableProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IInfoBarStatics<D>::CloseButtonStyleProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IInfoBarStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IInfoBarStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IInfoBarStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_CloseButtonStyleProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IInfoBarStatics>**)this;
            check_hresult(_winrt_abi_type->get_CloseButtonStyleProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IInfoBarStatics<D>::CloseButtonCommandProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IInfoBarStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IInfoBarStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IInfoBarStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_CloseButtonCommandProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IInfoBarStatics>**)this;
            check_hresult(_winrt_abi_type->get_CloseButtonCommandProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IInfoBarStatics<D>::CloseButtonCommandParameterProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IInfoBarStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IInfoBarStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IInfoBarStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_CloseButtonCommandParameterProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IInfoBarStatics>**)this;
            check_hresult(_winrt_abi_type->get_CloseButtonCommandParameterProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IInfoBarStatics<D>::ActionButtonProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IInfoBarStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IInfoBarStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IInfoBarStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_ActionButtonProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IInfoBarStatics>**)this;
            check_hresult(_winrt_abi_type->get_ActionButtonProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IInfoBarStatics<D>::ContentProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IInfoBarStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IInfoBarStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IInfoBarStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_ContentProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IInfoBarStatics>**)this;
            check_hresult(_winrt_abi_type->get_ContentProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IInfoBarStatics<D>::ContentTemplateProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IInfoBarStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IInfoBarStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IInfoBarStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_ContentTemplateProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IInfoBarStatics>**)this;
            check_hresult(_winrt_abi_type->get_ContentTemplateProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IInfoBarStatics<D>::TemplateSettingsProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IInfoBarStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IInfoBarStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IInfoBarStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_TemplateSettingsProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IInfoBarStatics>**)this;
            check_hresult(_winrt_abi_type->get_TemplateSettingsProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IInfoBarTemplateSettings<D>::IconElement() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IInfoBarTemplateSettings>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IInfoBarTemplateSettings, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IInfoBarTemplateSettings>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_IconElement(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IInfoBarTemplateSettings>**)this;
            check_hresult(_winrt_abi_type->get_IconElement(&value));
        }
        return winrt::Windows::UI::Xaml::Controls::IconElement{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IInfoBarTemplateSettings<D>::IconElement(winrt::Windows::UI::Xaml::Controls::IconElement const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IInfoBarTemplateSettings>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IInfoBarTemplateSettings, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IInfoBarTemplateSettings>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_IconElement(*(void**)(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IInfoBarTemplateSettings>**)this;
            check_hresult(_winrt_abi_type->put_IconElement(*(void**)(&value)));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IInfoBarTemplateSettingsFactory<D>::CreateInstance(winrt::Windows::Foundation::IInspectable const& baseInterface, winrt::Windows::Foundation::IInspectable& innerInterface) const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IInfoBarTemplateSettingsFactory>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IInfoBarTemplateSettingsFactory, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IInfoBarTemplateSettingsFactory>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->CreateInstance(*(void**)(&baseInterface), impl::bind_out(innerInterface), &value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IInfoBarTemplateSettingsFactory>**)this;
            check_hresult(_winrt_abi_type->CreateInstance(*(void**)(&baseInterface), impl::bind_out(innerInterface), &value));
        }
        return winrt::Microsoft::UI::Xaml::Controls::InfoBarTemplateSettings{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IInfoBarTemplateSettingsStatics<D>::IconElementProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IInfoBarTemplateSettingsStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IInfoBarTemplateSettingsStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IInfoBarTemplateSettingsStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_IconElementProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IInfoBarTemplateSettingsStatics>**)this;
            check_hresult(_winrt_abi_type->get_IconElementProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IItemsRepeater<D>::ItemsSource() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IItemsRepeater>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IItemsRepeater, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IItemsRepeater>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_ItemsSource(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IItemsRepeater>**)this;
            check_hresult(_winrt_abi_type->get_ItemsSource(&value));
        }
        return winrt::Windows::Foundation::IInspectable{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IItemsRepeater<D>::ItemsSource(winrt::Windows::Foundation::IInspectable const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IItemsRepeater>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IItemsRepeater, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IItemsRepeater>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_ItemsSource(*(void**)(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IItemsRepeater>**)this;
            check_hresult(_winrt_abi_type->put_ItemsSource(*(void**)(&value)));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IItemsRepeater<D>::ItemsSourceView() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IItemsRepeater>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IItemsRepeater, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IItemsRepeater>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_ItemsSourceView(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IItemsRepeater>**)this;
            check_hresult(_winrt_abi_type->get_ItemsSourceView(&value));
        }
        return winrt::Microsoft::UI::Xaml::Controls::ItemsSourceView{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IItemsRepeater<D>::ItemTemplate() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IItemsRepeater>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IItemsRepeater, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IItemsRepeater>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_ItemTemplate(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IItemsRepeater>**)this;
            check_hresult(_winrt_abi_type->get_ItemTemplate(&value));
        }
        return winrt::Windows::Foundation::IInspectable{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IItemsRepeater<D>::ItemTemplate(winrt::Windows::Foundation::IInspectable const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IItemsRepeater>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IItemsRepeater, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IItemsRepeater>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_ItemTemplate(*(void**)(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IItemsRepeater>**)this;
            check_hresult(_winrt_abi_type->put_ItemTemplate(*(void**)(&value)));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IItemsRepeater<D>::Layout() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IItemsRepeater>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IItemsRepeater, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IItemsRepeater>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Layout(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IItemsRepeater>**)this;
            check_hresult(_winrt_abi_type->get_Layout(&value));
        }
        return winrt::Microsoft::UI::Xaml::Controls::Layout{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IItemsRepeater<D>::Layout(winrt::Microsoft::UI::Xaml::Controls::Layout const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IItemsRepeater>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IItemsRepeater, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IItemsRepeater>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_Layout(*(void**)(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IItemsRepeater>**)this;
            check_hresult(_winrt_abi_type->put_Layout(*(void**)(&value)));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IItemsRepeater<D>::HorizontalCacheLength() const
    {
        double value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IItemsRepeater>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IItemsRepeater, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IItemsRepeater>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_HorizontalCacheLength(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IItemsRepeater>**)this;
            check_hresult(_winrt_abi_type->get_HorizontalCacheLength(&value));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IItemsRepeater<D>::HorizontalCacheLength(double value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IItemsRepeater>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IItemsRepeater, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IItemsRepeater>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_HorizontalCacheLength(value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IItemsRepeater>**)this;
            check_hresult(_winrt_abi_type->put_HorizontalCacheLength(value));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IItemsRepeater<D>::VerticalCacheLength() const
    {
        double value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IItemsRepeater>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IItemsRepeater, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IItemsRepeater>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_VerticalCacheLength(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IItemsRepeater>**)this;
            check_hresult(_winrt_abi_type->get_VerticalCacheLength(&value));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IItemsRepeater<D>::VerticalCacheLength(double value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IItemsRepeater>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IItemsRepeater, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IItemsRepeater>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_VerticalCacheLength(value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IItemsRepeater>**)this;
            check_hresult(_winrt_abi_type->put_VerticalCacheLength(value));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IItemsRepeater<D>::Background() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IItemsRepeater>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IItemsRepeater, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IItemsRepeater>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Background(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IItemsRepeater>**)this;
            check_hresult(_winrt_abi_type->get_Background(&value));
        }
        return winrt::Windows::UI::Xaml::Media::Brush{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IItemsRepeater<D>::Background(winrt::Windows::UI::Xaml::Media::Brush const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IItemsRepeater>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IItemsRepeater, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IItemsRepeater>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_Background(*(void**)(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IItemsRepeater>**)this;
            check_hresult(_winrt_abi_type->put_Background(*(void**)(&value)));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IItemsRepeater<D>::GetElementIndex(winrt::Windows::UI::Xaml::UIElement const& element) const
    {
        int32_t result{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IItemsRepeater>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IItemsRepeater, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IItemsRepeater>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->GetElementIndex(*(void**)(&element), &result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IItemsRepeater>**)this;
            check_hresult(_winrt_abi_type->GetElementIndex(*(void**)(&element), &result));
        }
        return result;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IItemsRepeater<D>::TryGetElement(int32_t index) const
    {
        void* result{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IItemsRepeater>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IItemsRepeater, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IItemsRepeater>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->TryGetElement(index, &result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IItemsRepeater>**)this;
            check_hresult(_winrt_abi_type->TryGetElement(index, &result));
        }
        return winrt::Windows::UI::Xaml::UIElement{ result, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IItemsRepeater<D>::GetOrCreateElement(int32_t index) const
    {
        void* result{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IItemsRepeater>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IItemsRepeater, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IItemsRepeater>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->GetOrCreateElement(index, &result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IItemsRepeater>**)this;
            check_hresult(_winrt_abi_type->GetOrCreateElement(index, &result));
        }
        return winrt::Windows::UI::Xaml::UIElement{ result, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IItemsRepeater<D>::ElementPrepared(winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Xaml::Controls::ItemsRepeater, winrt::Microsoft::UI::Xaml::Controls::ItemsRepeaterElementPreparedEventArgs> const& handler) const
    {
        winrt::event_token token{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IItemsRepeater>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IItemsRepeater, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IItemsRepeater>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->add_ElementPrepared(*(void**)(&handler), put_abi(token)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IItemsRepeater>**)this;
            check_hresult(_winrt_abi_type->add_ElementPrepared(*(void**)(&handler), put_abi(token)));
        }
        return token;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IItemsRepeater<D>::ElementPrepared(auto_revoke_t, winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Xaml::Controls::ItemsRepeater, winrt::Microsoft::UI::Xaml::Controls::ItemsRepeaterElementPreparedEventArgs> const& handler) const
    {
        return impl::make_event_revoker<D, ElementPrepared_revoker>(this, ElementPrepared(handler));
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IItemsRepeater<D>::ElementPrepared(winrt::event_token const& token) const noexcept
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IItemsRepeater>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IItemsRepeater, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IItemsRepeater>**)&_winrt_casted_result;
            _winrt_abi_type->remove_ElementPrepared(impl::bind_in(token));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IItemsRepeater>**)this;
            _winrt_abi_type->remove_ElementPrepared(impl::bind_in(token));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IItemsRepeater<D>::ElementClearing(winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Xaml::Controls::ItemsRepeater, winrt::Microsoft::UI::Xaml::Controls::ItemsRepeaterElementClearingEventArgs> const& handler) const
    {
        winrt::event_token token{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IItemsRepeater>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IItemsRepeater, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IItemsRepeater>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->add_ElementClearing(*(void**)(&handler), put_abi(token)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IItemsRepeater>**)this;
            check_hresult(_winrt_abi_type->add_ElementClearing(*(void**)(&handler), put_abi(token)));
        }
        return token;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IItemsRepeater<D>::ElementClearing(auto_revoke_t, winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Xaml::Controls::ItemsRepeater, winrt::Microsoft::UI::Xaml::Controls::ItemsRepeaterElementClearingEventArgs> const& handler) const
    {
        return impl::make_event_revoker<D, ElementClearing_revoker>(this, ElementClearing(handler));
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IItemsRepeater<D>::ElementClearing(winrt::event_token const& token) const noexcept
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IItemsRepeater>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IItemsRepeater, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IItemsRepeater>**)&_winrt_casted_result;
            _winrt_abi_type->remove_ElementClearing(impl::bind_in(token));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IItemsRepeater>**)this;
            _winrt_abi_type->remove_ElementClearing(impl::bind_in(token));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IItemsRepeater<D>::ElementIndexChanged(winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Xaml::Controls::ItemsRepeater, winrt::Microsoft::UI::Xaml::Controls::ItemsRepeaterElementIndexChangedEventArgs> const& handler) const
    {
        winrt::event_token token{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IItemsRepeater>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IItemsRepeater, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IItemsRepeater>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->add_ElementIndexChanged(*(void**)(&handler), put_abi(token)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IItemsRepeater>**)this;
            check_hresult(_winrt_abi_type->add_ElementIndexChanged(*(void**)(&handler), put_abi(token)));
        }
        return token;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IItemsRepeater<D>::ElementIndexChanged(auto_revoke_t, winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Xaml::Controls::ItemsRepeater, winrt::Microsoft::UI::Xaml::Controls::ItemsRepeaterElementIndexChangedEventArgs> const& handler) const
    {
        return impl::make_event_revoker<D, ElementIndexChanged_revoker>(this, ElementIndexChanged(handler));
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IItemsRepeater<D>::ElementIndexChanged(winrt::event_token const& token) const noexcept
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IItemsRepeater>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IItemsRepeater, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IItemsRepeater>**)&_winrt_casted_result;
            _winrt_abi_type->remove_ElementIndexChanged(impl::bind_in(token));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IItemsRepeater>**)this;
            _winrt_abi_type->remove_ElementIndexChanged(impl::bind_in(token));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IItemsRepeaterElementClearingEventArgs<D>::Element() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IItemsRepeaterElementClearingEventArgs>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IItemsRepeaterElementClearingEventArgs, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IItemsRepeaterElementClearingEventArgs>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Element(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IItemsRepeaterElementClearingEventArgs>**)this;
            check_hresult(_winrt_abi_type->get_Element(&value));
        }
        return winrt::Windows::UI::Xaml::UIElement{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IItemsRepeaterElementIndexChangedEventArgs<D>::Element() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IItemsRepeaterElementIndexChangedEventArgs>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IItemsRepeaterElementIndexChangedEventArgs, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IItemsRepeaterElementIndexChangedEventArgs>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Element(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IItemsRepeaterElementIndexChangedEventArgs>**)this;
            check_hresult(_winrt_abi_type->get_Element(&value));
        }
        return winrt::Windows::UI::Xaml::UIElement{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IItemsRepeaterElementIndexChangedEventArgs<D>::OldIndex() const
    {
        int32_t value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IItemsRepeaterElementIndexChangedEventArgs>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IItemsRepeaterElementIndexChangedEventArgs, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IItemsRepeaterElementIndexChangedEventArgs>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_OldIndex(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IItemsRepeaterElementIndexChangedEventArgs>**)this;
            check_hresult(_winrt_abi_type->get_OldIndex(&value));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IItemsRepeaterElementIndexChangedEventArgs<D>::NewIndex() const
    {
        int32_t value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IItemsRepeaterElementIndexChangedEventArgs>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IItemsRepeaterElementIndexChangedEventArgs, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IItemsRepeaterElementIndexChangedEventArgs>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_NewIndex(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IItemsRepeaterElementIndexChangedEventArgs>**)this;
            check_hresult(_winrt_abi_type->get_NewIndex(&value));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IItemsRepeaterElementPreparedEventArgs<D>::Element() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IItemsRepeaterElementPreparedEventArgs>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IItemsRepeaterElementPreparedEventArgs, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IItemsRepeaterElementPreparedEventArgs>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Element(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IItemsRepeaterElementPreparedEventArgs>**)this;
            check_hresult(_winrt_abi_type->get_Element(&value));
        }
        return winrt::Windows::UI::Xaml::UIElement{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IItemsRepeaterElementPreparedEventArgs<D>::Index() const
    {
        int32_t value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IItemsRepeaterElementPreparedEventArgs>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IItemsRepeaterElementPreparedEventArgs, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IItemsRepeaterElementPreparedEventArgs>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Index(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IItemsRepeaterElementPreparedEventArgs>**)this;
            check_hresult(_winrt_abi_type->get_Index(&value));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IItemsRepeaterFactory<D>::CreateInstance(winrt::Windows::Foundation::IInspectable const& baseInterface, winrt::Windows::Foundation::IInspectable& innerInterface) const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IItemsRepeaterFactory>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IItemsRepeaterFactory, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IItemsRepeaterFactory>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->CreateInstance(*(void**)(&baseInterface), impl::bind_out(innerInterface), &value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IItemsRepeaterFactory>**)this;
            check_hresult(_winrt_abi_type->CreateInstance(*(void**)(&baseInterface), impl::bind_out(innerInterface), &value));
        }
        return winrt::Microsoft::UI::Xaml::Controls::ItemsRepeater{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IItemsRepeaterScrollHost<D>::ScrollViewer() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IItemsRepeaterScrollHost>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IItemsRepeaterScrollHost, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IItemsRepeaterScrollHost>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_ScrollViewer(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IItemsRepeaterScrollHost>**)this;
            check_hresult(_winrt_abi_type->get_ScrollViewer(&value));
        }
        return winrt::Windows::UI::Xaml::Controls::ScrollViewer{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IItemsRepeaterScrollHost<D>::ScrollViewer(winrt::Windows::UI::Xaml::Controls::ScrollViewer const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IItemsRepeaterScrollHost>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IItemsRepeaterScrollHost, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IItemsRepeaterScrollHost>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_ScrollViewer(*(void**)(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IItemsRepeaterScrollHost>**)this;
            check_hresult(_winrt_abi_type->put_ScrollViewer(*(void**)(&value)));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IItemsRepeaterScrollHost<D>::CurrentAnchor() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IItemsRepeaterScrollHost>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IItemsRepeaterScrollHost, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IItemsRepeaterScrollHost>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_CurrentAnchor(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IItemsRepeaterScrollHost>**)this;
            check_hresult(_winrt_abi_type->get_CurrentAnchor(&value));
        }
        return winrt::Windows::UI::Xaml::UIElement{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IItemsRepeaterScrollHost<D>::HorizontalAnchorRatio() const
    {
        double value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IItemsRepeaterScrollHost>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IItemsRepeaterScrollHost, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IItemsRepeaterScrollHost>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_HorizontalAnchorRatio(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IItemsRepeaterScrollHost>**)this;
            check_hresult(_winrt_abi_type->get_HorizontalAnchorRatio(&value));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IItemsRepeaterScrollHost<D>::HorizontalAnchorRatio(double value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IItemsRepeaterScrollHost>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IItemsRepeaterScrollHost, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IItemsRepeaterScrollHost>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_HorizontalAnchorRatio(value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IItemsRepeaterScrollHost>**)this;
            check_hresult(_winrt_abi_type->put_HorizontalAnchorRatio(value));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IItemsRepeaterScrollHost<D>::VerticalAnchorRatio() const
    {
        double value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IItemsRepeaterScrollHost>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IItemsRepeaterScrollHost, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IItemsRepeaterScrollHost>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_VerticalAnchorRatio(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IItemsRepeaterScrollHost>**)this;
            check_hresult(_winrt_abi_type->get_VerticalAnchorRatio(&value));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IItemsRepeaterScrollHost<D>::VerticalAnchorRatio(double value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IItemsRepeaterScrollHost>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IItemsRepeaterScrollHost, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IItemsRepeaterScrollHost>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_VerticalAnchorRatio(value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IItemsRepeaterScrollHost>**)this;
            check_hresult(_winrt_abi_type->put_VerticalAnchorRatio(value));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IItemsRepeaterStatics<D>::ItemsSourceProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IItemsRepeaterStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IItemsRepeaterStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IItemsRepeaterStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_ItemsSourceProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IItemsRepeaterStatics>**)this;
            check_hresult(_winrt_abi_type->get_ItemsSourceProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IItemsRepeaterStatics<D>::ItemTemplateProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IItemsRepeaterStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IItemsRepeaterStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IItemsRepeaterStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_ItemTemplateProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IItemsRepeaterStatics>**)this;
            check_hresult(_winrt_abi_type->get_ItemTemplateProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IItemsRepeaterStatics<D>::LayoutProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IItemsRepeaterStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IItemsRepeaterStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IItemsRepeaterStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_LayoutProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IItemsRepeaterStatics>**)this;
            check_hresult(_winrt_abi_type->get_LayoutProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IItemsRepeaterStatics<D>::HorizontalCacheLengthProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IItemsRepeaterStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IItemsRepeaterStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IItemsRepeaterStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_HorizontalCacheLengthProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IItemsRepeaterStatics>**)this;
            check_hresult(_winrt_abi_type->get_HorizontalCacheLengthProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IItemsRepeaterStatics<D>::VerticalCacheLengthProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IItemsRepeaterStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IItemsRepeaterStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IItemsRepeaterStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_VerticalCacheLengthProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IItemsRepeaterStatics>**)this;
            check_hresult(_winrt_abi_type->get_VerticalCacheLengthProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IItemsRepeaterStatics<D>::BackgroundProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IItemsRepeaterStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IItemsRepeaterStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IItemsRepeaterStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_BackgroundProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IItemsRepeaterStatics>**)this;
            check_hresult(_winrt_abi_type->get_BackgroundProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IItemsSourceView<D>::Count() const
    {
        int32_t value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IItemsSourceView>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IItemsSourceView, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IItemsSourceView>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Count(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IItemsSourceView>**)this;
            check_hresult(_winrt_abi_type->get_Count(&value));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IItemsSourceView<D>::GetAt(int32_t index) const
    {
        void* result{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IItemsSourceView>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IItemsSourceView, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IItemsSourceView>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->GetAt(index, &result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IItemsSourceView>**)this;
            check_hresult(_winrt_abi_type->GetAt(index, &result));
        }
        return winrt::Windows::Foundation::IInspectable{ result, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IItemsSourceView<D>::HasKeyIndexMapping() const
    {
        bool value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IItemsSourceView>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IItemsSourceView, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IItemsSourceView>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_HasKeyIndexMapping(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IItemsSourceView>**)this;
            check_hresult(_winrt_abi_type->get_HasKeyIndexMapping(&value));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IItemsSourceView<D>::KeyFromIndex(int32_t index) const
    {
        void* result{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IItemsSourceView>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IItemsSourceView, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IItemsSourceView>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->KeyFromIndex(index, &result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IItemsSourceView>**)this;
            check_hresult(_winrt_abi_type->KeyFromIndex(index, &result));
        }
        return hstring{ result, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IItemsSourceView<D>::IndexFromKey(param::hstring const& key) const
    {
        int32_t result{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IItemsSourceView>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IItemsSourceView, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IItemsSourceView>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->IndexFromKey(*(void**)(&key), &result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IItemsSourceView>**)this;
            check_hresult(_winrt_abi_type->IndexFromKey(*(void**)(&key), &result));
        }
        return result;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IItemsSourceView<D>::IndexOf(winrt::Windows::Foundation::IInspectable const& item) const
    {
        int32_t result{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IItemsSourceView>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IItemsSourceView, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IItemsSourceView>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->IndexOf(*(void**)(&item), &result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IItemsSourceView>**)this;
            check_hresult(_winrt_abi_type->IndexOf(*(void**)(&item), &result));
        }
        return result;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IItemsSourceViewFactory<D>::CreateInstance(winrt::Windows::Foundation::IInspectable const& source, winrt::Windows::Foundation::IInspectable const& baseInterface, winrt::Windows::Foundation::IInspectable& innerInterface) const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IItemsSourceViewFactory>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IItemsSourceViewFactory, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IItemsSourceViewFactory>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->CreateInstance(*(void**)(&source), *(void**)(&baseInterface), impl::bind_out(innerInterface), &value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IItemsSourceViewFactory>**)this;
            check_hresult(_winrt_abi_type->CreateInstance(*(void**)(&source), *(void**)(&baseInterface), impl::bind_out(innerInterface), &value));
        }
        return winrt::Microsoft::UI::Xaml::Controls::ItemsSourceView{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IKeyIndexMapping<D>::KeyFromIndex(int32_t index) const
    {
        void* result{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IKeyIndexMapping>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IKeyIndexMapping, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IKeyIndexMapping>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->KeyFromIndex(index, &result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IKeyIndexMapping>**)this;
            check_hresult(_winrt_abi_type->KeyFromIndex(index, &result));
        }
        return hstring{ result, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IKeyIndexMapping<D>::IndexFromKey(param::hstring const& key) const
    {
        int32_t result{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IKeyIndexMapping>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IKeyIndexMapping, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IKeyIndexMapping>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->IndexFromKey(*(void**)(&key), &result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IKeyIndexMapping>**)this;
            check_hresult(_winrt_abi_type->IndexFromKey(*(void**)(&key), &result));
        }
        return result;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ILayout<D>::InitializeForContext(winrt::Microsoft::UI::Xaml::Controls::LayoutContext const& context) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ILayout>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ILayout, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ILayout>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->InitializeForContext(*(void**)(&context)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ILayout>**)this;
            check_hresult(_winrt_abi_type->InitializeForContext(*(void**)(&context)));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ILayout<D>::UninitializeForContext(winrt::Microsoft::UI::Xaml::Controls::LayoutContext const& context) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ILayout>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ILayout, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ILayout>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->UninitializeForContext(*(void**)(&context)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ILayout>**)this;
            check_hresult(_winrt_abi_type->UninitializeForContext(*(void**)(&context)));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ILayout<D>::Measure(winrt::Microsoft::UI::Xaml::Controls::LayoutContext const& context, winrt::Windows::Foundation::Size const& availableSize) const
    {
        winrt::Windows::Foundation::Size result{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ILayout>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ILayout, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ILayout>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->Measure(*(void**)(&context), impl::bind_in(availableSize), put_abi(result)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ILayout>**)this;
            check_hresult(_winrt_abi_type->Measure(*(void**)(&context), impl::bind_in(availableSize), put_abi(result)));
        }
        return result;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ILayout<D>::Arrange(winrt::Microsoft::UI::Xaml::Controls::LayoutContext const& context, winrt::Windows::Foundation::Size const& finalSize) const
    {
        winrt::Windows::Foundation::Size result{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ILayout>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ILayout, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ILayout>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->Arrange(*(void**)(&context), impl::bind_in(finalSize), put_abi(result)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ILayout>**)this;
            check_hresult(_winrt_abi_type->Arrange(*(void**)(&context), impl::bind_in(finalSize), put_abi(result)));
        }
        return result;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ILayout<D>::MeasureInvalidated(winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Xaml::Controls::Layout, winrt::Windows::Foundation::IInspectable> const& handler) const
    {
        winrt::event_token token{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ILayout>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ILayout, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ILayout>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->add_MeasureInvalidated(*(void**)(&handler), put_abi(token)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ILayout>**)this;
            check_hresult(_winrt_abi_type->add_MeasureInvalidated(*(void**)(&handler), put_abi(token)));
        }
        return token;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ILayout<D>::MeasureInvalidated(auto_revoke_t, winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Xaml::Controls::Layout, winrt::Windows::Foundation::IInspectable> const& handler) const
    {
        return impl::make_event_revoker<D, MeasureInvalidated_revoker>(this, MeasureInvalidated(handler));
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ILayout<D>::MeasureInvalidated(winrt::event_token const& token) const noexcept
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ILayout>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ILayout, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ILayout>**)&_winrt_casted_result;
            _winrt_abi_type->remove_MeasureInvalidated(impl::bind_in(token));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ILayout>**)this;
            _winrt_abi_type->remove_MeasureInvalidated(impl::bind_in(token));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ILayout<D>::ArrangeInvalidated(winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Xaml::Controls::Layout, winrt::Windows::Foundation::IInspectable> const& handler) const
    {
        winrt::event_token token{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ILayout>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ILayout, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ILayout>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->add_ArrangeInvalidated(*(void**)(&handler), put_abi(token)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ILayout>**)this;
            check_hresult(_winrt_abi_type->add_ArrangeInvalidated(*(void**)(&handler), put_abi(token)));
        }
        return token;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ILayout<D>::ArrangeInvalidated(auto_revoke_t, winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Xaml::Controls::Layout, winrt::Windows::Foundation::IInspectable> const& handler) const
    {
        return impl::make_event_revoker<D, ArrangeInvalidated_revoker>(this, ArrangeInvalidated(handler));
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ILayout<D>::ArrangeInvalidated(winrt::event_token const& token) const noexcept
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ILayout>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ILayout, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ILayout>**)&_winrt_casted_result;
            _winrt_abi_type->remove_ArrangeInvalidated(impl::bind_in(token));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ILayout>**)this;
            _winrt_abi_type->remove_ArrangeInvalidated(impl::bind_in(token));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ILayoutContext<D>::LayoutState() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ILayoutContext>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ILayoutContext, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ILayoutContext>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_LayoutState(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ILayoutContext>**)this;
            check_hresult(_winrt_abi_type->get_LayoutState(&value));
        }
        return winrt::Windows::Foundation::IInspectable{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ILayoutContext<D>::LayoutState(winrt::Windows::Foundation::IInspectable const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ILayoutContext>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ILayoutContext, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ILayoutContext>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_LayoutState(*(void**)(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ILayoutContext>**)this;
            check_hresult(_winrt_abi_type->put_LayoutState(*(void**)(&value)));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ILayoutContextOverrides<D>::LayoutStateCore() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ILayoutContextOverrides>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ILayoutContextOverrides, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ILayoutContextOverrides>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_LayoutStateCore(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ILayoutContextOverrides>**)this;
            check_hresult(_winrt_abi_type->get_LayoutStateCore(&value));
        }
        return winrt::Windows::Foundation::IInspectable{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ILayoutContextOverrides<D>::LayoutStateCore(winrt::Windows::Foundation::IInspectable const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ILayoutContextOverrides>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ILayoutContextOverrides, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ILayoutContextOverrides>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_LayoutStateCore(*(void**)(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ILayoutContextOverrides>**)this;
            check_hresult(_winrt_abi_type->put_LayoutStateCore(*(void**)(&value)));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ILayoutProtected<D>::InvalidateMeasure() const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ILayoutProtected>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ILayoutProtected, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ILayoutProtected>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->InvalidateMeasure());
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ILayoutProtected>**)this;
            check_hresult(_winrt_abi_type->InvalidateMeasure());
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ILayoutProtected<D>::InvalidateArrange() const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ILayoutProtected>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ILayoutProtected, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ILayoutProtected>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->InvalidateArrange());
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ILayoutProtected>**)this;
            check_hresult(_winrt_abi_type->InvalidateArrange());
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IMenuBar<D>::Items() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IMenuBar>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IMenuBar, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IMenuBar>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Items(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IMenuBar>**)this;
            check_hresult(_winrt_abi_type->get_Items(&value));
        }
        return winrt::Windows::Foundation::Collections::IVector<winrt::Microsoft::UI::Xaml::Controls::MenuBarItem>{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IMenuBarFactory<D>::CreateInstance(winrt::Windows::Foundation::IInspectable const& baseInterface, winrt::Windows::Foundation::IInspectable& innerInterface) const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IMenuBarFactory>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IMenuBarFactory, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IMenuBarFactory>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->CreateInstance(*(void**)(&baseInterface), impl::bind_out(innerInterface), &value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IMenuBarFactory>**)this;
            check_hresult(_winrt_abi_type->CreateInstance(*(void**)(&baseInterface), impl::bind_out(innerInterface), &value));
        }
        return winrt::Microsoft::UI::Xaml::Controls::MenuBar{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IMenuBarItem<D>::Title() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IMenuBarItem>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IMenuBarItem, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IMenuBarItem>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Title(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IMenuBarItem>**)this;
            check_hresult(_winrt_abi_type->get_Title(&value));
        }
        return hstring{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IMenuBarItem<D>::Title(param::hstring const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IMenuBarItem>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IMenuBarItem, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IMenuBarItem>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_Title(*(void**)(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IMenuBarItem>**)this;
            check_hresult(_winrt_abi_type->put_Title(*(void**)(&value)));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IMenuBarItem<D>::Items() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IMenuBarItem>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IMenuBarItem, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IMenuBarItem>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Items(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IMenuBarItem>**)this;
            check_hresult(_winrt_abi_type->get_Items(&value));
        }
        return winrt::Windows::Foundation::Collections::IVector<winrt::Windows::UI::Xaml::Controls::MenuFlyoutItemBase>{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IMenuBarItemFactory<D>::CreateInstance(winrt::Windows::Foundation::IInspectable const& baseInterface, winrt::Windows::Foundation::IInspectable& innerInterface) const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IMenuBarItemFactory>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IMenuBarItemFactory, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IMenuBarItemFactory>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->CreateInstance(*(void**)(&baseInterface), impl::bind_out(innerInterface), &value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IMenuBarItemFactory>**)this;
            check_hresult(_winrt_abi_type->CreateInstance(*(void**)(&baseInterface), impl::bind_out(innerInterface), &value));
        }
        return winrt::Microsoft::UI::Xaml::Controls::MenuBarItem{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IMenuBarItemFlyoutFactory<D>::CreateInstance(winrt::Windows::Foundation::IInspectable const& baseInterface, winrt::Windows::Foundation::IInspectable& innerInterface) const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IMenuBarItemFlyoutFactory>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IMenuBarItemFlyoutFactory, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IMenuBarItemFlyoutFactory>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->CreateInstance(*(void**)(&baseInterface), impl::bind_out(innerInterface), &value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IMenuBarItemFlyoutFactory>**)this;
            check_hresult(_winrt_abi_type->CreateInstance(*(void**)(&baseInterface), impl::bind_out(innerInterface), &value));
        }
        return winrt::Microsoft::UI::Xaml::Controls::MenuBarItemFlyout{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IMenuBarItemStatics<D>::TitleProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IMenuBarItemStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IMenuBarItemStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IMenuBarItemStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_TitleProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IMenuBarItemStatics>**)this;
            check_hresult(_winrt_abi_type->get_TitleProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IMenuBarItemStatics<D>::ItemsProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IMenuBarItemStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IMenuBarItemStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IMenuBarItemStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_ItemsProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IMenuBarItemStatics>**)this;
            check_hresult(_winrt_abi_type->get_ItemsProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IMenuBarStatics<D>::ItemsProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IMenuBarStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IMenuBarStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IMenuBarStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_ItemsProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IMenuBarStatics>**)this;
            check_hresult(_winrt_abi_type->get_ItemsProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_INavigationView<D>::IsPaneOpen() const
    {
        bool value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::INavigationView>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::INavigationView, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationView>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_IsPaneOpen(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationView>**)this;
            check_hresult(_winrt_abi_type->get_IsPaneOpen(&value));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_INavigationView<D>::IsPaneOpen(bool value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::INavigationView>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::INavigationView, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationView>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_IsPaneOpen(value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationView>**)this;
            check_hresult(_winrt_abi_type->put_IsPaneOpen(value));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_INavigationView<D>::CompactModeThresholdWidth() const
    {
        double value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::INavigationView>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::INavigationView, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationView>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_CompactModeThresholdWidth(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationView>**)this;
            check_hresult(_winrt_abi_type->get_CompactModeThresholdWidth(&value));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_INavigationView<D>::CompactModeThresholdWidth(double value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::INavigationView>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::INavigationView, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationView>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_CompactModeThresholdWidth(value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationView>**)this;
            check_hresult(_winrt_abi_type->put_CompactModeThresholdWidth(value));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_INavigationView<D>::ExpandedModeThresholdWidth() const
    {
        double value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::INavigationView>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::INavigationView, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationView>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_ExpandedModeThresholdWidth(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationView>**)this;
            check_hresult(_winrt_abi_type->get_ExpandedModeThresholdWidth(&value));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_INavigationView<D>::ExpandedModeThresholdWidth(double value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::INavigationView>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::INavigationView, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationView>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_ExpandedModeThresholdWidth(value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationView>**)this;
            check_hresult(_winrt_abi_type->put_ExpandedModeThresholdWidth(value));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_INavigationView<D>::FooterMenuItems() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::INavigationView>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::INavigationView, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationView>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_FooterMenuItems(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationView>**)this;
            check_hresult(_winrt_abi_type->get_FooterMenuItems(&value));
        }
        return winrt::Windows::Foundation::Collections::IVector<winrt::Windows::Foundation::IInspectable>{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_INavigationView<D>::FooterMenuItemsSource() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::INavigationView>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::INavigationView, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationView>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_FooterMenuItemsSource(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationView>**)this;
            check_hresult(_winrt_abi_type->get_FooterMenuItemsSource(&value));
        }
        return winrt::Windows::Foundation::IInspectable{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_INavigationView<D>::FooterMenuItemsSource(winrt::Windows::Foundation::IInspectable const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::INavigationView>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::INavigationView, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationView>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_FooterMenuItemsSource(*(void**)(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationView>**)this;
            check_hresult(_winrt_abi_type->put_FooterMenuItemsSource(*(void**)(&value)));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_INavigationView<D>::PaneFooter() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::INavigationView>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::INavigationView, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationView>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_PaneFooter(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationView>**)this;
            check_hresult(_winrt_abi_type->get_PaneFooter(&value));
        }
        return winrt::Windows::UI::Xaml::UIElement{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_INavigationView<D>::PaneFooter(winrt::Windows::UI::Xaml::UIElement const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::INavigationView>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::INavigationView, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationView>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_PaneFooter(*(void**)(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationView>**)this;
            check_hresult(_winrt_abi_type->put_PaneFooter(*(void**)(&value)));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_INavigationView<D>::Header() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::INavigationView>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::INavigationView, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationView>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Header(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationView>**)this;
            check_hresult(_winrt_abi_type->get_Header(&value));
        }
        return winrt::Windows::Foundation::IInspectable{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_INavigationView<D>::Header(winrt::Windows::Foundation::IInspectable const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::INavigationView>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::INavigationView, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationView>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_Header(*(void**)(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationView>**)this;
            check_hresult(_winrt_abi_type->put_Header(*(void**)(&value)));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_INavigationView<D>::HeaderTemplate() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::INavigationView>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::INavigationView, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationView>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_HeaderTemplate(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationView>**)this;
            check_hresult(_winrt_abi_type->get_HeaderTemplate(&value));
        }
        return winrt::Windows::UI::Xaml::DataTemplate{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_INavigationView<D>::HeaderTemplate(winrt::Windows::UI::Xaml::DataTemplate const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::INavigationView>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::INavigationView, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationView>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_HeaderTemplate(*(void**)(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationView>**)this;
            check_hresult(_winrt_abi_type->put_HeaderTemplate(*(void**)(&value)));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_INavigationView<D>::DisplayMode() const
    {
        winrt::Microsoft::UI::Xaml::Controls::NavigationViewDisplayMode value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::INavigationView>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::INavigationView, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationView>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_DisplayMode(reinterpret_cast<int32_t*>(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationView>**)this;
            check_hresult(_winrt_abi_type->get_DisplayMode(reinterpret_cast<int32_t*>(&value)));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_INavigationView<D>::IsSettingsVisible() const
    {
        bool value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::INavigationView>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::INavigationView, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationView>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_IsSettingsVisible(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationView>**)this;
            check_hresult(_winrt_abi_type->get_IsSettingsVisible(&value));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_INavigationView<D>::IsSettingsVisible(bool value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::INavigationView>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::INavigationView, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationView>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_IsSettingsVisible(value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationView>**)this;
            check_hresult(_winrt_abi_type->put_IsSettingsVisible(value));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_INavigationView<D>::IsPaneToggleButtonVisible() const
    {
        bool value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::INavigationView>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::INavigationView, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationView>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_IsPaneToggleButtonVisible(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationView>**)this;
            check_hresult(_winrt_abi_type->get_IsPaneToggleButtonVisible(&value));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_INavigationView<D>::IsPaneToggleButtonVisible(bool value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::INavigationView>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::INavigationView, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationView>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_IsPaneToggleButtonVisible(value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationView>**)this;
            check_hresult(_winrt_abi_type->put_IsPaneToggleButtonVisible(value));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_INavigationView<D>::AlwaysShowHeader() const
    {
        bool value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::INavigationView>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::INavigationView, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationView>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_AlwaysShowHeader(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationView>**)this;
            check_hresult(_winrt_abi_type->get_AlwaysShowHeader(&value));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_INavigationView<D>::AlwaysShowHeader(bool value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::INavigationView>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::INavigationView, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationView>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_AlwaysShowHeader(value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationView>**)this;
            check_hresult(_winrt_abi_type->put_AlwaysShowHeader(value));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_INavigationView<D>::CompactPaneLength() const
    {
        double value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::INavigationView>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::INavigationView, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationView>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_CompactPaneLength(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationView>**)this;
            check_hresult(_winrt_abi_type->get_CompactPaneLength(&value));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_INavigationView<D>::CompactPaneLength(double value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::INavigationView>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::INavigationView, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationView>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_CompactPaneLength(value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationView>**)this;
            check_hresult(_winrt_abi_type->put_CompactPaneLength(value));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_INavigationView<D>::OpenPaneLength() const
    {
        double value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::INavigationView>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::INavigationView, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationView>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_OpenPaneLength(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationView>**)this;
            check_hresult(_winrt_abi_type->get_OpenPaneLength(&value));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_INavigationView<D>::OpenPaneLength(double value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::INavigationView>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::INavigationView, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationView>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_OpenPaneLength(value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationView>**)this;
            check_hresult(_winrt_abi_type->put_OpenPaneLength(value));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_INavigationView<D>::PaneToggleButtonStyle() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::INavigationView>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::INavigationView, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationView>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_PaneToggleButtonStyle(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationView>**)this;
            check_hresult(_winrt_abi_type->get_PaneToggleButtonStyle(&value));
        }
        return winrt::Windows::UI::Xaml::Style{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_INavigationView<D>::PaneToggleButtonStyle(winrt::Windows::UI::Xaml::Style const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::INavigationView>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::INavigationView, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationView>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_PaneToggleButtonStyle(*(void**)(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationView>**)this;
            check_hresult(_winrt_abi_type->put_PaneToggleButtonStyle(*(void**)(&value)));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_INavigationView<D>::SelectedItem() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::INavigationView>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::INavigationView, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationView>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_SelectedItem(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationView>**)this;
            check_hresult(_winrt_abi_type->get_SelectedItem(&value));
        }
        return winrt::Windows::Foundation::IInspectable{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_INavigationView<D>::SelectedItem(winrt::Windows::Foundation::IInspectable const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::INavigationView>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::INavigationView, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationView>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_SelectedItem(*(void**)(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationView>**)this;
            check_hresult(_winrt_abi_type->put_SelectedItem(*(void**)(&value)));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_INavigationView<D>::MenuItems() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::INavigationView>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::INavigationView, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationView>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_MenuItems(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationView>**)this;
            check_hresult(_winrt_abi_type->get_MenuItems(&value));
        }
        return winrt::Windows::Foundation::Collections::IVector<winrt::Windows::Foundation::IInspectable>{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_INavigationView<D>::MenuItemsSource() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::INavigationView>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::INavigationView, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationView>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_MenuItemsSource(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationView>**)this;
            check_hresult(_winrt_abi_type->get_MenuItemsSource(&value));
        }
        return winrt::Windows::Foundation::IInspectable{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_INavigationView<D>::MenuItemsSource(winrt::Windows::Foundation::IInspectable const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::INavigationView>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::INavigationView, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationView>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_MenuItemsSource(*(void**)(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationView>**)this;
            check_hresult(_winrt_abi_type->put_MenuItemsSource(*(void**)(&value)));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_INavigationView<D>::SettingsItem() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::INavigationView>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::INavigationView, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationView>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_SettingsItem(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationView>**)this;
            check_hresult(_winrt_abi_type->get_SettingsItem(&value));
        }
        return winrt::Windows::Foundation::IInspectable{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_INavigationView<D>::AutoSuggestBox() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::INavigationView>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::INavigationView, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationView>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_AutoSuggestBox(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationView>**)this;
            check_hresult(_winrt_abi_type->get_AutoSuggestBox(&value));
        }
        return winrt::Windows::UI::Xaml::Controls::AutoSuggestBox{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_INavigationView<D>::AutoSuggestBox(winrt::Windows::UI::Xaml::Controls::AutoSuggestBox const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::INavigationView>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::INavigationView, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationView>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_AutoSuggestBox(*(void**)(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationView>**)this;
            check_hresult(_winrt_abi_type->put_AutoSuggestBox(*(void**)(&value)));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_INavigationView<D>::MenuItemTemplate() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::INavigationView>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::INavigationView, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationView>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_MenuItemTemplate(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationView>**)this;
            check_hresult(_winrt_abi_type->get_MenuItemTemplate(&value));
        }
        return winrt::Windows::UI::Xaml::DataTemplate{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_INavigationView<D>::MenuItemTemplate(winrt::Windows::UI::Xaml::DataTemplate const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::INavigationView>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::INavigationView, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationView>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_MenuItemTemplate(*(void**)(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationView>**)this;
            check_hresult(_winrt_abi_type->put_MenuItemTemplate(*(void**)(&value)));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_INavigationView<D>::MenuItemTemplateSelector() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::INavigationView>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::INavigationView, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationView>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_MenuItemTemplateSelector(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationView>**)this;
            check_hresult(_winrt_abi_type->get_MenuItemTemplateSelector(&value));
        }
        return winrt::Windows::UI::Xaml::Controls::DataTemplateSelector{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_INavigationView<D>::MenuItemTemplateSelector(winrt::Windows::UI::Xaml::Controls::DataTemplateSelector const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::INavigationView>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::INavigationView, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationView>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_MenuItemTemplateSelector(*(void**)(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationView>**)this;
            check_hresult(_winrt_abi_type->put_MenuItemTemplateSelector(*(void**)(&value)));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_INavigationView<D>::MenuItemContainerStyle() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::INavigationView>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::INavigationView, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationView>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_MenuItemContainerStyle(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationView>**)this;
            check_hresult(_winrt_abi_type->get_MenuItemContainerStyle(&value));
        }
        return winrt::Windows::UI::Xaml::Style{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_INavigationView<D>::MenuItemContainerStyle(winrt::Windows::UI::Xaml::Style const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::INavigationView>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::INavigationView, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationView>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_MenuItemContainerStyle(*(void**)(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationView>**)this;
            check_hresult(_winrt_abi_type->put_MenuItemContainerStyle(*(void**)(&value)));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_INavigationView<D>::MenuItemContainerStyleSelector() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::INavigationView>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::INavigationView, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationView>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_MenuItemContainerStyleSelector(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationView>**)this;
            check_hresult(_winrt_abi_type->get_MenuItemContainerStyleSelector(&value));
        }
        return winrt::Windows::UI::Xaml::Controls::StyleSelector{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_INavigationView<D>::MenuItemContainerStyleSelector(winrt::Windows::UI::Xaml::Controls::StyleSelector const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::INavigationView>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::INavigationView, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationView>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_MenuItemContainerStyleSelector(*(void**)(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationView>**)this;
            check_hresult(_winrt_abi_type->put_MenuItemContainerStyleSelector(*(void**)(&value)));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_INavigationView<D>::MenuItemFromContainer(winrt::Windows::UI::Xaml::DependencyObject const& container) const
    {
        void* result{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::INavigationView>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::INavigationView, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationView>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->MenuItemFromContainer(*(void**)(&container), &result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationView>**)this;
            check_hresult(_winrt_abi_type->MenuItemFromContainer(*(void**)(&container), &result));
        }
        return winrt::Windows::Foundation::IInspectable{ result, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_INavigationView<D>::ContainerFromMenuItem(winrt::Windows::Foundation::IInspectable const& item) const
    {
        void* result{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::INavigationView>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::INavigationView, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationView>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->ContainerFromMenuItem(*(void**)(&item), &result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationView>**)this;
            check_hresult(_winrt_abi_type->ContainerFromMenuItem(*(void**)(&item), &result));
        }
        return winrt::Windows::UI::Xaml::DependencyObject{ result, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_INavigationView<D>::SelectionChanged(winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Xaml::Controls::NavigationView, winrt::Microsoft::UI::Xaml::Controls::NavigationViewSelectionChangedEventArgs> const& handler) const
    {
        winrt::event_token token{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::INavigationView>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::INavigationView, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationView>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->add_SelectionChanged(*(void**)(&handler), put_abi(token)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationView>**)this;
            check_hresult(_winrt_abi_type->add_SelectionChanged(*(void**)(&handler), put_abi(token)));
        }
        return token;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_INavigationView<D>::SelectionChanged(auto_revoke_t, winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Xaml::Controls::NavigationView, winrt::Microsoft::UI::Xaml::Controls::NavigationViewSelectionChangedEventArgs> const& handler) const
    {
        return impl::make_event_revoker<D, SelectionChanged_revoker>(this, SelectionChanged(handler));
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_INavigationView<D>::SelectionChanged(winrt::event_token const& token) const noexcept
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::INavigationView>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::INavigationView, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationView>**)&_winrt_casted_result;
            _winrt_abi_type->remove_SelectionChanged(impl::bind_in(token));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationView>**)this;
            _winrt_abi_type->remove_SelectionChanged(impl::bind_in(token));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_INavigationView<D>::ItemInvoked(winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Xaml::Controls::NavigationView, winrt::Microsoft::UI::Xaml::Controls::NavigationViewItemInvokedEventArgs> const& handler) const
    {
        winrt::event_token token{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::INavigationView>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::INavigationView, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationView>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->add_ItemInvoked(*(void**)(&handler), put_abi(token)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationView>**)this;
            check_hresult(_winrt_abi_type->add_ItemInvoked(*(void**)(&handler), put_abi(token)));
        }
        return token;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_INavigationView<D>::ItemInvoked(auto_revoke_t, winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Xaml::Controls::NavigationView, winrt::Microsoft::UI::Xaml::Controls::NavigationViewItemInvokedEventArgs> const& handler) const
    {
        return impl::make_event_revoker<D, ItemInvoked_revoker>(this, ItemInvoked(handler));
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_INavigationView<D>::ItemInvoked(winrt::event_token const& token) const noexcept
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::INavigationView>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::INavigationView, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationView>**)&_winrt_casted_result;
            _winrt_abi_type->remove_ItemInvoked(impl::bind_in(token));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationView>**)this;
            _winrt_abi_type->remove_ItemInvoked(impl::bind_in(token));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_INavigationView<D>::DisplayModeChanged(winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Xaml::Controls::NavigationView, winrt::Microsoft::UI::Xaml::Controls::NavigationViewDisplayModeChangedEventArgs> const& handler) const
    {
        winrt::event_token token{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::INavigationView>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::INavigationView, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationView>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->add_DisplayModeChanged(*(void**)(&handler), put_abi(token)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationView>**)this;
            check_hresult(_winrt_abi_type->add_DisplayModeChanged(*(void**)(&handler), put_abi(token)));
        }
        return token;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_INavigationView<D>::DisplayModeChanged(auto_revoke_t, winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Xaml::Controls::NavigationView, winrt::Microsoft::UI::Xaml::Controls::NavigationViewDisplayModeChangedEventArgs> const& handler) const
    {
        return impl::make_event_revoker<D, DisplayModeChanged_revoker>(this, DisplayModeChanged(handler));
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_INavigationView<D>::DisplayModeChanged(winrt::event_token const& token) const noexcept
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::INavigationView>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::INavigationView, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationView>**)&_winrt_casted_result;
            _winrt_abi_type->remove_DisplayModeChanged(impl::bind_in(token));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationView>**)this;
            _winrt_abi_type->remove_DisplayModeChanged(impl::bind_in(token));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_INavigationView<D>::IsTitleBarAutoPaddingEnabled() const
    {
        bool value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::INavigationView>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::INavigationView, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationView>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_IsTitleBarAutoPaddingEnabled(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationView>**)this;
            check_hresult(_winrt_abi_type->get_IsTitleBarAutoPaddingEnabled(&value));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_INavigationView<D>::IsTitleBarAutoPaddingEnabled(bool value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::INavigationView>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::INavigationView, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationView>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_IsTitleBarAutoPaddingEnabled(value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationView>**)this;
            check_hresult(_winrt_abi_type->put_IsTitleBarAutoPaddingEnabled(value));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_INavigationView2<D>::IsBackButtonVisible() const
    {
        winrt::Microsoft::UI::Xaml::Controls::NavigationViewBackButtonVisible value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::INavigationView2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::INavigationView2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationView2>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_IsBackButtonVisible(reinterpret_cast<int32_t*>(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationView2>**)this;
            check_hresult(_winrt_abi_type->get_IsBackButtonVisible(reinterpret_cast<int32_t*>(&value)));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_INavigationView2<D>::IsBackButtonVisible(winrt::Microsoft::UI::Xaml::Controls::NavigationViewBackButtonVisible const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::INavigationView2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::INavigationView2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationView2>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_IsBackButtonVisible(static_cast<int32_t>(value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationView2>**)this;
            check_hresult(_winrt_abi_type->put_IsBackButtonVisible(static_cast<int32_t>(value)));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_INavigationView2<D>::IsBackEnabled() const
    {
        bool value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::INavigationView2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::INavigationView2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationView2>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_IsBackEnabled(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationView2>**)this;
            check_hresult(_winrt_abi_type->get_IsBackEnabled(&value));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_INavigationView2<D>::IsBackEnabled(bool value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::INavigationView2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::INavigationView2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationView2>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_IsBackEnabled(value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationView2>**)this;
            check_hresult(_winrt_abi_type->put_IsBackEnabled(value));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_INavigationView2<D>::PaneTitle() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::INavigationView2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::INavigationView2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationView2>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_PaneTitle(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationView2>**)this;
            check_hresult(_winrt_abi_type->get_PaneTitle(&value));
        }
        return hstring{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_INavigationView2<D>::PaneTitle(param::hstring const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::INavigationView2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::INavigationView2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationView2>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_PaneTitle(*(void**)(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationView2>**)this;
            check_hresult(_winrt_abi_type->put_PaneTitle(*(void**)(&value)));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_INavigationView2<D>::BackRequested(winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Xaml::Controls::NavigationView, winrt::Microsoft::UI::Xaml::Controls::NavigationViewBackRequestedEventArgs> const& handler) const
    {
        winrt::event_token token{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::INavigationView2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::INavigationView2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationView2>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->add_BackRequested(*(void**)(&handler), put_abi(token)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationView2>**)this;
            check_hresult(_winrt_abi_type->add_BackRequested(*(void**)(&handler), put_abi(token)));
        }
        return token;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_INavigationView2<D>::BackRequested(auto_revoke_t, winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Xaml::Controls::NavigationView, winrt::Microsoft::UI::Xaml::Controls::NavigationViewBackRequestedEventArgs> const& handler) const
    {
        return impl::make_event_revoker<D, BackRequested_revoker>(this, BackRequested(handler));
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_INavigationView2<D>::BackRequested(winrt::event_token const& token) const noexcept
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::INavigationView2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::INavigationView2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationView2>**)&_winrt_casted_result;
            _winrt_abi_type->remove_BackRequested(impl::bind_in(token));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationView2>**)this;
            _winrt_abi_type->remove_BackRequested(impl::bind_in(token));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_INavigationView2<D>::PaneClosed(winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Xaml::Controls::NavigationView, winrt::Windows::Foundation::IInspectable> const& handler) const
    {
        winrt::event_token token{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::INavigationView2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::INavigationView2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationView2>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->add_PaneClosed(*(void**)(&handler), put_abi(token)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationView2>**)this;
            check_hresult(_winrt_abi_type->add_PaneClosed(*(void**)(&handler), put_abi(token)));
        }
        return token;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_INavigationView2<D>::PaneClosed(auto_revoke_t, winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Xaml::Controls::NavigationView, winrt::Windows::Foundation::IInspectable> const& handler) const
    {
        return impl::make_event_revoker<D, PaneClosed_revoker>(this, PaneClosed(handler));
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_INavigationView2<D>::PaneClosed(winrt::event_token const& token) const noexcept
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::INavigationView2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::INavigationView2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationView2>**)&_winrt_casted_result;
            _winrt_abi_type->remove_PaneClosed(impl::bind_in(token));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationView2>**)this;
            _winrt_abi_type->remove_PaneClosed(impl::bind_in(token));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_INavigationView2<D>::PaneClosing(winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Xaml::Controls::NavigationView, winrt::Microsoft::UI::Xaml::Controls::NavigationViewPaneClosingEventArgs> const& handler) const
    {
        winrt::event_token token{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::INavigationView2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::INavigationView2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationView2>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->add_PaneClosing(*(void**)(&handler), put_abi(token)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationView2>**)this;
            check_hresult(_winrt_abi_type->add_PaneClosing(*(void**)(&handler), put_abi(token)));
        }
        return token;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_INavigationView2<D>::PaneClosing(auto_revoke_t, winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Xaml::Controls::NavigationView, winrt::Microsoft::UI::Xaml::Controls::NavigationViewPaneClosingEventArgs> const& handler) const
    {
        return impl::make_event_revoker<D, PaneClosing_revoker>(this, PaneClosing(handler));
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_INavigationView2<D>::PaneClosing(winrt::event_token const& token) const noexcept
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::INavigationView2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::INavigationView2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationView2>**)&_winrt_casted_result;
            _winrt_abi_type->remove_PaneClosing(impl::bind_in(token));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationView2>**)this;
            _winrt_abi_type->remove_PaneClosing(impl::bind_in(token));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_INavigationView2<D>::PaneOpened(winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Xaml::Controls::NavigationView, winrt::Windows::Foundation::IInspectable> const& handler) const
    {
        winrt::event_token token{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::INavigationView2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::INavigationView2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationView2>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->add_PaneOpened(*(void**)(&handler), put_abi(token)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationView2>**)this;
            check_hresult(_winrt_abi_type->add_PaneOpened(*(void**)(&handler), put_abi(token)));
        }
        return token;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_INavigationView2<D>::PaneOpened(auto_revoke_t, winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Xaml::Controls::NavigationView, winrt::Windows::Foundation::IInspectable> const& handler) const
    {
        return impl::make_event_revoker<D, PaneOpened_revoker>(this, PaneOpened(handler));
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_INavigationView2<D>::PaneOpened(winrt::event_token const& token) const noexcept
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::INavigationView2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::INavigationView2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationView2>**)&_winrt_casted_result;
            _winrt_abi_type->remove_PaneOpened(impl::bind_in(token));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationView2>**)this;
            _winrt_abi_type->remove_PaneOpened(impl::bind_in(token));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_INavigationView2<D>::PaneOpening(winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Xaml::Controls::NavigationView, winrt::Windows::Foundation::IInspectable> const& handler) const
    {
        winrt::event_token token{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::INavigationView2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::INavigationView2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationView2>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->add_PaneOpening(*(void**)(&handler), put_abi(token)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationView2>**)this;
            check_hresult(_winrt_abi_type->add_PaneOpening(*(void**)(&handler), put_abi(token)));
        }
        return token;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_INavigationView2<D>::PaneOpening(auto_revoke_t, winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Xaml::Controls::NavigationView, winrt::Windows::Foundation::IInspectable> const& handler) const
    {
        return impl::make_event_revoker<D, PaneOpening_revoker>(this, PaneOpening(handler));
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_INavigationView2<D>::PaneOpening(winrt::event_token const& token) const noexcept
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::INavigationView2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::INavigationView2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationView2>**)&_winrt_casted_result;
            _winrt_abi_type->remove_PaneOpening(impl::bind_in(token));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationView2>**)this;
            _winrt_abi_type->remove_PaneOpening(impl::bind_in(token));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_INavigationView2<D>::PaneDisplayMode() const
    {
        winrt::Microsoft::UI::Xaml::Controls::NavigationViewPaneDisplayMode value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::INavigationView2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::INavigationView2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationView2>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_PaneDisplayMode(reinterpret_cast<int32_t*>(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationView2>**)this;
            check_hresult(_winrt_abi_type->get_PaneDisplayMode(reinterpret_cast<int32_t*>(&value)));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_INavigationView2<D>::PaneDisplayMode(winrt::Microsoft::UI::Xaml::Controls::NavigationViewPaneDisplayMode const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::INavigationView2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::INavigationView2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationView2>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_PaneDisplayMode(static_cast<int32_t>(value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationView2>**)this;
            check_hresult(_winrt_abi_type->put_PaneDisplayMode(static_cast<int32_t>(value)));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_INavigationView2<D>::PaneHeader() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::INavigationView2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::INavigationView2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationView2>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_PaneHeader(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationView2>**)this;
            check_hresult(_winrt_abi_type->get_PaneHeader(&value));
        }
        return winrt::Windows::UI::Xaml::UIElement{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_INavigationView2<D>::PaneHeader(winrt::Windows::UI::Xaml::UIElement const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::INavigationView2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::INavigationView2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationView2>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_PaneHeader(*(void**)(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationView2>**)this;
            check_hresult(_winrt_abi_type->put_PaneHeader(*(void**)(&value)));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_INavigationView2<D>::PaneCustomContent() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::INavigationView2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::INavigationView2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationView2>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_PaneCustomContent(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationView2>**)this;
            check_hresult(_winrt_abi_type->get_PaneCustomContent(&value));
        }
        return winrt::Windows::UI::Xaml::UIElement{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_INavigationView2<D>::PaneCustomContent(winrt::Windows::UI::Xaml::UIElement const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::INavigationView2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::INavigationView2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationView2>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_PaneCustomContent(*(void**)(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationView2>**)this;
            check_hresult(_winrt_abi_type->put_PaneCustomContent(*(void**)(&value)));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_INavigationView2<D>::ContentOverlay() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::INavigationView2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::INavigationView2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationView2>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_ContentOverlay(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationView2>**)this;
            check_hresult(_winrt_abi_type->get_ContentOverlay(&value));
        }
        return winrt::Windows::UI::Xaml::UIElement{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_INavigationView2<D>::ContentOverlay(winrt::Windows::UI::Xaml::UIElement const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::INavigationView2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::INavigationView2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationView2>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_ContentOverlay(*(void**)(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationView2>**)this;
            check_hresult(_winrt_abi_type->put_ContentOverlay(*(void**)(&value)));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_INavigationView2<D>::IsPaneVisible() const
    {
        bool value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::INavigationView2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::INavigationView2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationView2>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_IsPaneVisible(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationView2>**)this;
            check_hresult(_winrt_abi_type->get_IsPaneVisible(&value));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_INavigationView2<D>::IsPaneVisible(bool value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::INavigationView2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::INavigationView2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationView2>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_IsPaneVisible(value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationView2>**)this;
            check_hresult(_winrt_abi_type->put_IsPaneVisible(value));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_INavigationView2<D>::SelectionFollowsFocus() const
    {
        winrt::Microsoft::UI::Xaml::Controls::NavigationViewSelectionFollowsFocus value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::INavigationView2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::INavigationView2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationView2>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_SelectionFollowsFocus(reinterpret_cast<int32_t*>(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationView2>**)this;
            check_hresult(_winrt_abi_type->get_SelectionFollowsFocus(reinterpret_cast<int32_t*>(&value)));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_INavigationView2<D>::SelectionFollowsFocus(winrt::Microsoft::UI::Xaml::Controls::NavigationViewSelectionFollowsFocus const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::INavigationView2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::INavigationView2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationView2>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_SelectionFollowsFocus(static_cast<int32_t>(value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationView2>**)this;
            check_hresult(_winrt_abi_type->put_SelectionFollowsFocus(static_cast<int32_t>(value)));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_INavigationView2<D>::TemplateSettings() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::INavigationView2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::INavigationView2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationView2>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_TemplateSettings(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationView2>**)this;
            check_hresult(_winrt_abi_type->get_TemplateSettings(&value));
        }
        return winrt::Microsoft::UI::Xaml::Controls::NavigationViewTemplateSettings{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_INavigationView2<D>::ShoulderNavigationEnabled() const
    {
        winrt::Microsoft::UI::Xaml::Controls::NavigationViewShoulderNavigationEnabled value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::INavigationView2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::INavigationView2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationView2>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_ShoulderNavigationEnabled(reinterpret_cast<int32_t*>(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationView2>**)this;
            check_hresult(_winrt_abi_type->get_ShoulderNavigationEnabled(reinterpret_cast<int32_t*>(&value)));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_INavigationView2<D>::ShoulderNavigationEnabled(winrt::Microsoft::UI::Xaml::Controls::NavigationViewShoulderNavigationEnabled const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::INavigationView2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::INavigationView2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationView2>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_ShoulderNavigationEnabled(static_cast<int32_t>(value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationView2>**)this;
            check_hresult(_winrt_abi_type->put_ShoulderNavigationEnabled(static_cast<int32_t>(value)));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_INavigationView2<D>::OverflowLabelMode() const
    {
        winrt::Microsoft::UI::Xaml::Controls::NavigationViewOverflowLabelMode value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::INavigationView2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::INavigationView2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationView2>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_OverflowLabelMode(reinterpret_cast<int32_t*>(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationView2>**)this;
            check_hresult(_winrt_abi_type->get_OverflowLabelMode(reinterpret_cast<int32_t*>(&value)));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_INavigationView2<D>::OverflowLabelMode(winrt::Microsoft::UI::Xaml::Controls::NavigationViewOverflowLabelMode const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::INavigationView2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::INavigationView2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationView2>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_OverflowLabelMode(static_cast<int32_t>(value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationView2>**)this;
            check_hresult(_winrt_abi_type->put_OverflowLabelMode(static_cast<int32_t>(value)));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_INavigationView2<D>::Expanding(winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Xaml::Controls::NavigationView, winrt::Microsoft::UI::Xaml::Controls::NavigationViewItemExpandingEventArgs> const& handler) const
    {
        winrt::event_token token{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::INavigationView2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::INavigationView2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationView2>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->add_Expanding(*(void**)(&handler), put_abi(token)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationView2>**)this;
            check_hresult(_winrt_abi_type->add_Expanding(*(void**)(&handler), put_abi(token)));
        }
        return token;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_INavigationView2<D>::Expanding(auto_revoke_t, winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Xaml::Controls::NavigationView, winrt::Microsoft::UI::Xaml::Controls::NavigationViewItemExpandingEventArgs> const& handler) const
    {
        return impl::make_event_revoker<D, Expanding_revoker>(this, Expanding(handler));
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_INavigationView2<D>::Expanding(winrt::event_token const& token) const noexcept
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::INavigationView2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::INavigationView2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationView2>**)&_winrt_casted_result;
            _winrt_abi_type->remove_Expanding(impl::bind_in(token));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationView2>**)this;
            _winrt_abi_type->remove_Expanding(impl::bind_in(token));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_INavigationView2<D>::Collapsed(winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Xaml::Controls::NavigationView, winrt::Microsoft::UI::Xaml::Controls::NavigationViewItemCollapsedEventArgs> const& handler) const
    {
        winrt::event_token token{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::INavigationView2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::INavigationView2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationView2>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->add_Collapsed(*(void**)(&handler), put_abi(token)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationView2>**)this;
            check_hresult(_winrt_abi_type->add_Collapsed(*(void**)(&handler), put_abi(token)));
        }
        return token;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_INavigationView2<D>::Collapsed(auto_revoke_t, winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Xaml::Controls::NavigationView, winrt::Microsoft::UI::Xaml::Controls::NavigationViewItemCollapsedEventArgs> const& handler) const
    {
        return impl::make_event_revoker<D, Collapsed_revoker>(this, Collapsed(handler));
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_INavigationView2<D>::Collapsed(winrt::event_token const& token) const noexcept
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::INavigationView2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::INavigationView2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationView2>**)&_winrt_casted_result;
            _winrt_abi_type->remove_Collapsed(impl::bind_in(token));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationView2>**)this;
            _winrt_abi_type->remove_Collapsed(impl::bind_in(token));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_INavigationView2<D>::Expand(winrt::Microsoft::UI::Xaml::Controls::NavigationViewItem const& item) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::INavigationView2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::INavigationView2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationView2>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->Expand(*(void**)(&item)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationView2>**)this;
            check_hresult(_winrt_abi_type->Expand(*(void**)(&item)));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_INavigationView2<D>::Collapse(winrt::Microsoft::UI::Xaml::Controls::NavigationViewItem const& item) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::INavigationView2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::INavigationView2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationView2>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->Collapse(*(void**)(&item)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationView2>**)this;
            check_hresult(_winrt_abi_type->Collapse(*(void**)(&item)));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_INavigationViewDisplayModeChangedEventArgs<D>::DisplayMode() const
    {
        winrt::Microsoft::UI::Xaml::Controls::NavigationViewDisplayMode value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::INavigationViewDisplayModeChangedEventArgs>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::INavigationViewDisplayModeChangedEventArgs, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationViewDisplayModeChangedEventArgs>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_DisplayMode(reinterpret_cast<int32_t*>(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationViewDisplayModeChangedEventArgs>**)this;
            check_hresult(_winrt_abi_type->get_DisplayMode(reinterpret_cast<int32_t*>(&value)));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_INavigationViewFactory<D>::CreateInstance(winrt::Windows::Foundation::IInspectable const& baseInterface, winrt::Windows::Foundation::IInspectable& innerInterface) const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::INavigationViewFactory>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::INavigationViewFactory, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationViewFactory>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->CreateInstance(*(void**)(&baseInterface), impl::bind_out(innerInterface), &value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationViewFactory>**)this;
            check_hresult(_winrt_abi_type->CreateInstance(*(void**)(&baseInterface), impl::bind_out(innerInterface), &value));
        }
        return winrt::Microsoft::UI::Xaml::Controls::NavigationView{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_INavigationViewItem<D>::Icon() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::INavigationViewItem>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::INavigationViewItem, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationViewItem>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Icon(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationViewItem>**)this;
            check_hresult(_winrt_abi_type->get_Icon(&value));
        }
        return winrt::Windows::UI::Xaml::Controls::IconElement{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_INavigationViewItem<D>::Icon(winrt::Windows::UI::Xaml::Controls::IconElement const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::INavigationViewItem>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::INavigationViewItem, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationViewItem>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_Icon(*(void**)(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationViewItem>**)this;
            check_hresult(_winrt_abi_type->put_Icon(*(void**)(&value)));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_INavigationViewItem<D>::CompactPaneLength() const
    {
        double value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::INavigationViewItem>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::INavigationViewItem, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationViewItem>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_CompactPaneLength(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationViewItem>**)this;
            check_hresult(_winrt_abi_type->get_CompactPaneLength(&value));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_INavigationViewItem2<D>::SelectsOnInvoked() const
    {
        bool value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::INavigationViewItem2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::INavigationViewItem2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationViewItem2>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_SelectsOnInvoked(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationViewItem2>**)this;
            check_hresult(_winrt_abi_type->get_SelectsOnInvoked(&value));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_INavigationViewItem2<D>::SelectsOnInvoked(bool value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::INavigationViewItem2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::INavigationViewItem2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationViewItem2>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_SelectsOnInvoked(value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationViewItem2>**)this;
            check_hresult(_winrt_abi_type->put_SelectsOnInvoked(value));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_INavigationViewItem2<D>::IsExpanded() const
    {
        bool value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::INavigationViewItem2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::INavigationViewItem2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationViewItem2>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_IsExpanded(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationViewItem2>**)this;
            check_hresult(_winrt_abi_type->get_IsExpanded(&value));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_INavigationViewItem2<D>::IsExpanded(bool value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::INavigationViewItem2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::INavigationViewItem2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationViewItem2>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_IsExpanded(value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationViewItem2>**)this;
            check_hresult(_winrt_abi_type->put_IsExpanded(value));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_INavigationViewItem2<D>::HasUnrealizedChildren() const
    {
        bool value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::INavigationViewItem2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::INavigationViewItem2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationViewItem2>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_HasUnrealizedChildren(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationViewItem2>**)this;
            check_hresult(_winrt_abi_type->get_HasUnrealizedChildren(&value));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_INavigationViewItem2<D>::HasUnrealizedChildren(bool value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::INavigationViewItem2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::INavigationViewItem2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationViewItem2>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_HasUnrealizedChildren(value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationViewItem2>**)this;
            check_hresult(_winrt_abi_type->put_HasUnrealizedChildren(value));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_INavigationViewItem2<D>::IsChildSelected() const
    {
        bool value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::INavigationViewItem2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::INavigationViewItem2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationViewItem2>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_IsChildSelected(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationViewItem2>**)this;
            check_hresult(_winrt_abi_type->get_IsChildSelected(&value));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_INavigationViewItem2<D>::IsChildSelected(bool value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::INavigationViewItem2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::INavigationViewItem2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationViewItem2>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_IsChildSelected(value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationViewItem2>**)this;
            check_hresult(_winrt_abi_type->put_IsChildSelected(value));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_INavigationViewItem2<D>::MenuItems() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::INavigationViewItem2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::INavigationViewItem2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationViewItem2>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_MenuItems(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationViewItem2>**)this;
            check_hresult(_winrt_abi_type->get_MenuItems(&value));
        }
        return winrt::Windows::Foundation::Collections::IVector<winrt::Windows::Foundation::IInspectable>{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_INavigationViewItem2<D>::MenuItemsSource() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::INavigationViewItem2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::INavigationViewItem2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationViewItem2>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_MenuItemsSource(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationViewItem2>**)this;
            check_hresult(_winrt_abi_type->get_MenuItemsSource(&value));
        }
        return winrt::Windows::Foundation::IInspectable{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_INavigationViewItem2<D>::MenuItemsSource(winrt::Windows::Foundation::IInspectable const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::INavigationViewItem2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::INavigationViewItem2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationViewItem2>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_MenuItemsSource(*(void**)(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationViewItem2>**)this;
            check_hresult(_winrt_abi_type->put_MenuItemsSource(*(void**)(&value)));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_INavigationViewItem3<D>::InfoBadge() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::INavigationViewItem3>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::INavigationViewItem3, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationViewItem3>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_InfoBadge(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationViewItem3>**)this;
            check_hresult(_winrt_abi_type->get_InfoBadge(&value));
        }
        return winrt::Microsoft::UI::Xaml::Controls::InfoBadge{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_INavigationViewItem3<D>::InfoBadge(winrt::Microsoft::UI::Xaml::Controls::InfoBadge const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::INavigationViewItem3>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::INavigationViewItem3, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationViewItem3>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_InfoBadge(*(void**)(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationViewItem3>**)this;
            check_hresult(_winrt_abi_type->put_InfoBadge(*(void**)(&value)));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_INavigationViewItemBase2<D>::IsSelected() const
    {
        bool value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::INavigationViewItemBase2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::INavigationViewItemBase2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationViewItemBase2>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_IsSelected(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationViewItemBase2>**)this;
            check_hresult(_winrt_abi_type->get_IsSelected(&value));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_INavigationViewItemBase2<D>::IsSelected(bool value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::INavigationViewItemBase2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::INavigationViewItemBase2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationViewItemBase2>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_IsSelected(value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationViewItemBase2>**)this;
            check_hresult(_winrt_abi_type->put_IsSelected(value));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_INavigationViewItemBaseStatics<D>::IsSelectedProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::INavigationViewItemBaseStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::INavigationViewItemBaseStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationViewItemBaseStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_IsSelectedProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationViewItemBaseStatics>**)this;
            check_hresult(_winrt_abi_type->get_IsSelectedProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_INavigationViewItemCollapsedEventArgs<D>::CollapsedItemContainer() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::INavigationViewItemCollapsedEventArgs>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::INavigationViewItemCollapsedEventArgs, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationViewItemCollapsedEventArgs>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_CollapsedItemContainer(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationViewItemCollapsedEventArgs>**)this;
            check_hresult(_winrt_abi_type->get_CollapsedItemContainer(&value));
        }
        return winrt::Microsoft::UI::Xaml::Controls::NavigationViewItemBase{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_INavigationViewItemCollapsedEventArgs<D>::CollapsedItem() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::INavigationViewItemCollapsedEventArgs>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::INavigationViewItemCollapsedEventArgs, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationViewItemCollapsedEventArgs>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_CollapsedItem(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationViewItemCollapsedEventArgs>**)this;
            check_hresult(_winrt_abi_type->get_CollapsedItem(&value));
        }
        return winrt::Windows::Foundation::IInspectable{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_INavigationViewItemExpandingEventArgs<D>::ExpandingItemContainer() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::INavigationViewItemExpandingEventArgs>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::INavigationViewItemExpandingEventArgs, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationViewItemExpandingEventArgs>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_ExpandingItemContainer(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationViewItemExpandingEventArgs>**)this;
            check_hresult(_winrt_abi_type->get_ExpandingItemContainer(&value));
        }
        return winrt::Microsoft::UI::Xaml::Controls::NavigationViewItemBase{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_INavigationViewItemExpandingEventArgs<D>::ExpandingItem() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::INavigationViewItemExpandingEventArgs>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::INavigationViewItemExpandingEventArgs, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationViewItemExpandingEventArgs>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_ExpandingItem(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationViewItemExpandingEventArgs>**)this;
            check_hresult(_winrt_abi_type->get_ExpandingItem(&value));
        }
        return winrt::Windows::Foundation::IInspectable{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_INavigationViewItemFactory<D>::CreateInstance(winrt::Windows::Foundation::IInspectable const& baseInterface, winrt::Windows::Foundation::IInspectable& innerInterface) const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::INavigationViewItemFactory>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::INavigationViewItemFactory, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationViewItemFactory>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->CreateInstance(*(void**)(&baseInterface), impl::bind_out(innerInterface), &value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationViewItemFactory>**)this;
            check_hresult(_winrt_abi_type->CreateInstance(*(void**)(&baseInterface), impl::bind_out(innerInterface), &value));
        }
        return winrt::Microsoft::UI::Xaml::Controls::NavigationViewItem{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_INavigationViewItemHeaderFactory<D>::CreateInstance(winrt::Windows::Foundation::IInspectable const& baseInterface, winrt::Windows::Foundation::IInspectable& innerInterface) const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::INavigationViewItemHeaderFactory>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::INavigationViewItemHeaderFactory, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationViewItemHeaderFactory>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->CreateInstance(*(void**)(&baseInterface), impl::bind_out(innerInterface), &value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationViewItemHeaderFactory>**)this;
            check_hresult(_winrt_abi_type->CreateInstance(*(void**)(&baseInterface), impl::bind_out(innerInterface), &value));
        }
        return winrt::Microsoft::UI::Xaml::Controls::NavigationViewItemHeader{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_INavigationViewItemInvokedEventArgs<D>::InvokedItem() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::INavigationViewItemInvokedEventArgs>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::INavigationViewItemInvokedEventArgs, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationViewItemInvokedEventArgs>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_InvokedItem(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationViewItemInvokedEventArgs>**)this;
            check_hresult(_winrt_abi_type->get_InvokedItem(&value));
        }
        return winrt::Windows::Foundation::IInspectable{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_INavigationViewItemInvokedEventArgs<D>::IsSettingsInvoked() const
    {
        bool value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::INavigationViewItemInvokedEventArgs>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::INavigationViewItemInvokedEventArgs, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationViewItemInvokedEventArgs>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_IsSettingsInvoked(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationViewItemInvokedEventArgs>**)this;
            check_hresult(_winrt_abi_type->get_IsSettingsInvoked(&value));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_INavigationViewItemInvokedEventArgs2<D>::InvokedItemContainer() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::INavigationViewItemInvokedEventArgs2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::INavigationViewItemInvokedEventArgs2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationViewItemInvokedEventArgs2>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_InvokedItemContainer(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationViewItemInvokedEventArgs2>**)this;
            check_hresult(_winrt_abi_type->get_InvokedItemContainer(&value));
        }
        return winrt::Microsoft::UI::Xaml::Controls::NavigationViewItemBase{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_INavigationViewItemInvokedEventArgs2<D>::RecommendedNavigationTransitionInfo() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::INavigationViewItemInvokedEventArgs2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::INavigationViewItemInvokedEventArgs2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationViewItemInvokedEventArgs2>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_RecommendedNavigationTransitionInfo(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationViewItemInvokedEventArgs2>**)this;
            check_hresult(_winrt_abi_type->get_RecommendedNavigationTransitionInfo(&value));
        }
        return winrt::Windows::UI::Xaml::Media::Animation::NavigationTransitionInfo{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_INavigationViewItemSeparatorFactory<D>::CreateInstance(winrt::Windows::Foundation::IInspectable const& baseInterface, winrt::Windows::Foundation::IInspectable& innerInterface) const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::INavigationViewItemSeparatorFactory>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::INavigationViewItemSeparatorFactory, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationViewItemSeparatorFactory>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->CreateInstance(*(void**)(&baseInterface), impl::bind_out(innerInterface), &value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationViewItemSeparatorFactory>**)this;
            check_hresult(_winrt_abi_type->CreateInstance(*(void**)(&baseInterface), impl::bind_out(innerInterface), &value));
        }
        return winrt::Microsoft::UI::Xaml::Controls::NavigationViewItemSeparator{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_INavigationViewItemStatics<D>::IconProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::INavigationViewItemStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::INavigationViewItemStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationViewItemStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_IconProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationViewItemStatics>**)this;
            check_hresult(_winrt_abi_type->get_IconProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_INavigationViewItemStatics<D>::CompactPaneLengthProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::INavigationViewItemStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::INavigationViewItemStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationViewItemStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_CompactPaneLengthProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationViewItemStatics>**)this;
            check_hresult(_winrt_abi_type->get_CompactPaneLengthProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_INavigationViewItemStatics2<D>::SelectsOnInvokedProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::INavigationViewItemStatics2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::INavigationViewItemStatics2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationViewItemStatics2>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_SelectsOnInvokedProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationViewItemStatics2>**)this;
            check_hresult(_winrt_abi_type->get_SelectsOnInvokedProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_INavigationViewItemStatics2<D>::IsExpandedProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::INavigationViewItemStatics2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::INavigationViewItemStatics2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationViewItemStatics2>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_IsExpandedProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationViewItemStatics2>**)this;
            check_hresult(_winrt_abi_type->get_IsExpandedProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_INavigationViewItemStatics2<D>::HasUnrealizedChildrenProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::INavigationViewItemStatics2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::INavigationViewItemStatics2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationViewItemStatics2>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_HasUnrealizedChildrenProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationViewItemStatics2>**)this;
            check_hresult(_winrt_abi_type->get_HasUnrealizedChildrenProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_INavigationViewItemStatics2<D>::IsChildSelectedProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::INavigationViewItemStatics2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::INavigationViewItemStatics2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationViewItemStatics2>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_IsChildSelectedProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationViewItemStatics2>**)this;
            check_hresult(_winrt_abi_type->get_IsChildSelectedProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_INavigationViewItemStatics2<D>::MenuItemsProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::INavigationViewItemStatics2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::INavigationViewItemStatics2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationViewItemStatics2>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_MenuItemsProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationViewItemStatics2>**)this;
            check_hresult(_winrt_abi_type->get_MenuItemsProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_INavigationViewItemStatics2<D>::MenuItemsSourceProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::INavigationViewItemStatics2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::INavigationViewItemStatics2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationViewItemStatics2>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_MenuItemsSourceProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationViewItemStatics2>**)this;
            check_hresult(_winrt_abi_type->get_MenuItemsSourceProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_INavigationViewItemStatics3<D>::InfoBadgeProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::INavigationViewItemStatics3>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::INavigationViewItemStatics3, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationViewItemStatics3>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_InfoBadgeProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationViewItemStatics3>**)this;
            check_hresult(_winrt_abi_type->get_InfoBadgeProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_INavigationViewPaneClosingEventArgs<D>::Cancel() const
    {
        bool value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::INavigationViewPaneClosingEventArgs>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::INavigationViewPaneClosingEventArgs, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationViewPaneClosingEventArgs>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Cancel(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationViewPaneClosingEventArgs>**)this;
            check_hresult(_winrt_abi_type->get_Cancel(&value));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_INavigationViewPaneClosingEventArgs<D>::Cancel(bool value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::INavigationViewPaneClosingEventArgs>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::INavigationViewPaneClosingEventArgs, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationViewPaneClosingEventArgs>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_Cancel(value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationViewPaneClosingEventArgs>**)this;
            check_hresult(_winrt_abi_type->put_Cancel(value));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_INavigationViewSelectionChangedEventArgs<D>::SelectedItem() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::INavigationViewSelectionChangedEventArgs>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::INavigationViewSelectionChangedEventArgs, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationViewSelectionChangedEventArgs>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_SelectedItem(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationViewSelectionChangedEventArgs>**)this;
            check_hresult(_winrt_abi_type->get_SelectedItem(&value));
        }
        return winrt::Windows::Foundation::IInspectable{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_INavigationViewSelectionChangedEventArgs<D>::IsSettingsSelected() const
    {
        bool value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::INavigationViewSelectionChangedEventArgs>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::INavigationViewSelectionChangedEventArgs, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationViewSelectionChangedEventArgs>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_IsSettingsSelected(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationViewSelectionChangedEventArgs>**)this;
            check_hresult(_winrt_abi_type->get_IsSettingsSelected(&value));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_INavigationViewSelectionChangedEventArgs2<D>::SelectedItemContainer() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::INavigationViewSelectionChangedEventArgs2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::INavigationViewSelectionChangedEventArgs2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationViewSelectionChangedEventArgs2>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_SelectedItemContainer(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationViewSelectionChangedEventArgs2>**)this;
            check_hresult(_winrt_abi_type->get_SelectedItemContainer(&value));
        }
        return winrt::Microsoft::UI::Xaml::Controls::NavigationViewItemBase{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_INavigationViewSelectionChangedEventArgs2<D>::RecommendedNavigationTransitionInfo() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::INavigationViewSelectionChangedEventArgs2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::INavigationViewSelectionChangedEventArgs2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationViewSelectionChangedEventArgs2>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_RecommendedNavigationTransitionInfo(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationViewSelectionChangedEventArgs2>**)this;
            check_hresult(_winrt_abi_type->get_RecommendedNavigationTransitionInfo(&value));
        }
        return winrt::Windows::UI::Xaml::Media::Animation::NavigationTransitionInfo{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_INavigationViewStatics<D>::IsPaneOpenProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::INavigationViewStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::INavigationViewStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationViewStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_IsPaneOpenProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationViewStatics>**)this;
            check_hresult(_winrt_abi_type->get_IsPaneOpenProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_INavigationViewStatics<D>::CompactModeThresholdWidthProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::INavigationViewStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::INavigationViewStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationViewStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_CompactModeThresholdWidthProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationViewStatics>**)this;
            check_hresult(_winrt_abi_type->get_CompactModeThresholdWidthProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_INavigationViewStatics<D>::ExpandedModeThresholdWidthProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::INavigationViewStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::INavigationViewStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationViewStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_ExpandedModeThresholdWidthProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationViewStatics>**)this;
            check_hresult(_winrt_abi_type->get_ExpandedModeThresholdWidthProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_INavigationViewStatics<D>::FooterMenuItemsProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::INavigationViewStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::INavigationViewStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationViewStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_FooterMenuItemsProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationViewStatics>**)this;
            check_hresult(_winrt_abi_type->get_FooterMenuItemsProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_INavigationViewStatics<D>::FooterMenuItemsSourceProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::INavigationViewStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::INavigationViewStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationViewStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_FooterMenuItemsSourceProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationViewStatics>**)this;
            check_hresult(_winrt_abi_type->get_FooterMenuItemsSourceProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_INavigationViewStatics<D>::PaneFooterProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::INavigationViewStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::INavigationViewStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationViewStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_PaneFooterProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationViewStatics>**)this;
            check_hresult(_winrt_abi_type->get_PaneFooterProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_INavigationViewStatics<D>::HeaderProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::INavigationViewStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::INavigationViewStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationViewStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_HeaderProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationViewStatics>**)this;
            check_hresult(_winrt_abi_type->get_HeaderProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_INavigationViewStatics<D>::HeaderTemplateProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::INavigationViewStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::INavigationViewStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationViewStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_HeaderTemplateProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationViewStatics>**)this;
            check_hresult(_winrt_abi_type->get_HeaderTemplateProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_INavigationViewStatics<D>::DisplayModeProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::INavigationViewStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::INavigationViewStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationViewStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_DisplayModeProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationViewStatics>**)this;
            check_hresult(_winrt_abi_type->get_DisplayModeProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_INavigationViewStatics<D>::IsSettingsVisibleProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::INavigationViewStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::INavigationViewStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationViewStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_IsSettingsVisibleProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationViewStatics>**)this;
            check_hresult(_winrt_abi_type->get_IsSettingsVisibleProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_INavigationViewStatics<D>::IsPaneToggleButtonVisibleProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::INavigationViewStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::INavigationViewStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationViewStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_IsPaneToggleButtonVisibleProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationViewStatics>**)this;
            check_hresult(_winrt_abi_type->get_IsPaneToggleButtonVisibleProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_INavigationViewStatics<D>::AlwaysShowHeaderProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::INavigationViewStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::INavigationViewStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationViewStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_AlwaysShowHeaderProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationViewStatics>**)this;
            check_hresult(_winrt_abi_type->get_AlwaysShowHeaderProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_INavigationViewStatics<D>::CompactPaneLengthProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::INavigationViewStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::INavigationViewStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationViewStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_CompactPaneLengthProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationViewStatics>**)this;
            check_hresult(_winrt_abi_type->get_CompactPaneLengthProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_INavigationViewStatics<D>::OpenPaneLengthProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::INavigationViewStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::INavigationViewStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationViewStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_OpenPaneLengthProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationViewStatics>**)this;
            check_hresult(_winrt_abi_type->get_OpenPaneLengthProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_INavigationViewStatics<D>::PaneToggleButtonStyleProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::INavigationViewStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::INavigationViewStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationViewStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_PaneToggleButtonStyleProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationViewStatics>**)this;
            check_hresult(_winrt_abi_type->get_PaneToggleButtonStyleProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_INavigationViewStatics<D>::MenuItemsProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::INavigationViewStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::INavigationViewStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationViewStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_MenuItemsProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationViewStatics>**)this;
            check_hresult(_winrt_abi_type->get_MenuItemsProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_INavigationViewStatics<D>::MenuItemsSourceProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::INavigationViewStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::INavigationViewStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationViewStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_MenuItemsSourceProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationViewStatics>**)this;
            check_hresult(_winrt_abi_type->get_MenuItemsSourceProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_INavigationViewStatics<D>::SelectedItemProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::INavigationViewStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::INavigationViewStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationViewStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_SelectedItemProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationViewStatics>**)this;
            check_hresult(_winrt_abi_type->get_SelectedItemProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_INavigationViewStatics<D>::SettingsItemProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::INavigationViewStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::INavigationViewStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationViewStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_SettingsItemProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationViewStatics>**)this;
            check_hresult(_winrt_abi_type->get_SettingsItemProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_INavigationViewStatics<D>::AutoSuggestBoxProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::INavigationViewStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::INavigationViewStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationViewStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_AutoSuggestBoxProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationViewStatics>**)this;
            check_hresult(_winrt_abi_type->get_AutoSuggestBoxProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_INavigationViewStatics<D>::MenuItemTemplateProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::INavigationViewStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::INavigationViewStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationViewStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_MenuItemTemplateProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationViewStatics>**)this;
            check_hresult(_winrt_abi_type->get_MenuItemTemplateProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_INavigationViewStatics<D>::MenuItemTemplateSelectorProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::INavigationViewStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::INavigationViewStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationViewStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_MenuItemTemplateSelectorProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationViewStatics>**)this;
            check_hresult(_winrt_abi_type->get_MenuItemTemplateSelectorProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_INavigationViewStatics<D>::MenuItemContainerStyleProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::INavigationViewStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::INavigationViewStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationViewStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_MenuItemContainerStyleProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationViewStatics>**)this;
            check_hresult(_winrt_abi_type->get_MenuItemContainerStyleProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_INavigationViewStatics<D>::MenuItemContainerStyleSelectorProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::INavigationViewStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::INavigationViewStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationViewStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_MenuItemContainerStyleSelectorProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationViewStatics>**)this;
            check_hresult(_winrt_abi_type->get_MenuItemContainerStyleSelectorProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_INavigationViewStatics<D>::IsTitleBarAutoPaddingEnabledProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::INavigationViewStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::INavigationViewStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationViewStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_IsTitleBarAutoPaddingEnabledProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationViewStatics>**)this;
            check_hresult(_winrt_abi_type->get_IsTitleBarAutoPaddingEnabledProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_INavigationViewStatics2<D>::IsBackButtonVisibleProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::INavigationViewStatics2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::INavigationViewStatics2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationViewStatics2>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_IsBackButtonVisibleProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationViewStatics2>**)this;
            check_hresult(_winrt_abi_type->get_IsBackButtonVisibleProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_INavigationViewStatics2<D>::IsBackEnabledProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::INavigationViewStatics2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::INavigationViewStatics2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationViewStatics2>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_IsBackEnabledProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationViewStatics2>**)this;
            check_hresult(_winrt_abi_type->get_IsBackEnabledProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_INavigationViewStatics2<D>::PaneTitleProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::INavigationViewStatics2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::INavigationViewStatics2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationViewStatics2>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_PaneTitleProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationViewStatics2>**)this;
            check_hresult(_winrt_abi_type->get_PaneTitleProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_INavigationViewStatics2<D>::PaneDisplayModeProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::INavigationViewStatics2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::INavigationViewStatics2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationViewStatics2>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_PaneDisplayModeProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationViewStatics2>**)this;
            check_hresult(_winrt_abi_type->get_PaneDisplayModeProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_INavigationViewStatics2<D>::PaneHeaderProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::INavigationViewStatics2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::INavigationViewStatics2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationViewStatics2>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_PaneHeaderProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationViewStatics2>**)this;
            check_hresult(_winrt_abi_type->get_PaneHeaderProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_INavigationViewStatics2<D>::PaneCustomContentProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::INavigationViewStatics2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::INavigationViewStatics2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationViewStatics2>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_PaneCustomContentProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationViewStatics2>**)this;
            check_hresult(_winrt_abi_type->get_PaneCustomContentProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_INavigationViewStatics2<D>::ContentOverlayProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::INavigationViewStatics2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::INavigationViewStatics2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationViewStatics2>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_ContentOverlayProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationViewStatics2>**)this;
            check_hresult(_winrt_abi_type->get_ContentOverlayProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_INavigationViewStatics2<D>::IsPaneVisibleProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::INavigationViewStatics2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::INavigationViewStatics2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationViewStatics2>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_IsPaneVisibleProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationViewStatics2>**)this;
            check_hresult(_winrt_abi_type->get_IsPaneVisibleProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_INavigationViewStatics2<D>::SelectionFollowsFocusProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::INavigationViewStatics2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::INavigationViewStatics2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationViewStatics2>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_SelectionFollowsFocusProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationViewStatics2>**)this;
            check_hresult(_winrt_abi_type->get_SelectionFollowsFocusProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_INavigationViewStatics2<D>::TemplateSettingsProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::INavigationViewStatics2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::INavigationViewStatics2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationViewStatics2>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_TemplateSettingsProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationViewStatics2>**)this;
            check_hresult(_winrt_abi_type->get_TemplateSettingsProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_INavigationViewStatics2<D>::ShoulderNavigationEnabledProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::INavigationViewStatics2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::INavigationViewStatics2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationViewStatics2>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_ShoulderNavigationEnabledProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationViewStatics2>**)this;
            check_hresult(_winrt_abi_type->get_ShoulderNavigationEnabledProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_INavigationViewStatics2<D>::OverflowLabelModeProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::INavigationViewStatics2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::INavigationViewStatics2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationViewStatics2>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_OverflowLabelModeProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationViewStatics2>**)this;
            check_hresult(_winrt_abi_type->get_OverflowLabelModeProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_INavigationViewTemplateSettings<D>::TopPadding() const
    {
        double value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::INavigationViewTemplateSettings>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::INavigationViewTemplateSettings, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationViewTemplateSettings>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_TopPadding(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationViewTemplateSettings>**)this;
            check_hresult(_winrt_abi_type->get_TopPadding(&value));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_INavigationViewTemplateSettings<D>::OverflowButtonVisibility() const
    {
        winrt::Windows::UI::Xaml::Visibility value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::INavigationViewTemplateSettings>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::INavigationViewTemplateSettings, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationViewTemplateSettings>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_OverflowButtonVisibility(reinterpret_cast<int32_t*>(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationViewTemplateSettings>**)this;
            check_hresult(_winrt_abi_type->get_OverflowButtonVisibility(reinterpret_cast<int32_t*>(&value)));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_INavigationViewTemplateSettings<D>::PaneToggleButtonVisibility() const
    {
        winrt::Windows::UI::Xaml::Visibility value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::INavigationViewTemplateSettings>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::INavigationViewTemplateSettings, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationViewTemplateSettings>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_PaneToggleButtonVisibility(reinterpret_cast<int32_t*>(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationViewTemplateSettings>**)this;
            check_hresult(_winrt_abi_type->get_PaneToggleButtonVisibility(reinterpret_cast<int32_t*>(&value)));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_INavigationViewTemplateSettings<D>::BackButtonVisibility() const
    {
        winrt::Windows::UI::Xaml::Visibility value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::INavigationViewTemplateSettings>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::INavigationViewTemplateSettings, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationViewTemplateSettings>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_BackButtonVisibility(reinterpret_cast<int32_t*>(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationViewTemplateSettings>**)this;
            check_hresult(_winrt_abi_type->get_BackButtonVisibility(reinterpret_cast<int32_t*>(&value)));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_INavigationViewTemplateSettings<D>::TopPaneVisibility() const
    {
        winrt::Windows::UI::Xaml::Visibility value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::INavigationViewTemplateSettings>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::INavigationViewTemplateSettings, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationViewTemplateSettings>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_TopPaneVisibility(reinterpret_cast<int32_t*>(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationViewTemplateSettings>**)this;
            check_hresult(_winrt_abi_type->get_TopPaneVisibility(reinterpret_cast<int32_t*>(&value)));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_INavigationViewTemplateSettings<D>::LeftPaneVisibility() const
    {
        winrt::Windows::UI::Xaml::Visibility value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::INavigationViewTemplateSettings>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::INavigationViewTemplateSettings, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationViewTemplateSettings>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_LeftPaneVisibility(reinterpret_cast<int32_t*>(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationViewTemplateSettings>**)this;
            check_hresult(_winrt_abi_type->get_LeftPaneVisibility(reinterpret_cast<int32_t*>(&value)));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_INavigationViewTemplateSettings<D>::SingleSelectionFollowsFocus() const
    {
        bool value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::INavigationViewTemplateSettings>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::INavigationViewTemplateSettings, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationViewTemplateSettings>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_SingleSelectionFollowsFocus(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationViewTemplateSettings>**)this;
            check_hresult(_winrt_abi_type->get_SingleSelectionFollowsFocus(&value));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_INavigationViewTemplateSettings<D>::PaneToggleButtonWidth() const
    {
        double value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::INavigationViewTemplateSettings>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::INavigationViewTemplateSettings, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationViewTemplateSettings>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_PaneToggleButtonWidth(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationViewTemplateSettings>**)this;
            check_hresult(_winrt_abi_type->get_PaneToggleButtonWidth(&value));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_INavigationViewTemplateSettings<D>::SmallerPaneToggleButtonWidth() const
    {
        double value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::INavigationViewTemplateSettings>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::INavigationViewTemplateSettings, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationViewTemplateSettings>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_SmallerPaneToggleButtonWidth(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationViewTemplateSettings>**)this;
            check_hresult(_winrt_abi_type->get_SmallerPaneToggleButtonWidth(&value));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_INavigationViewTemplateSettings2<D>::OpenPaneLength() const
    {
        double value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::INavigationViewTemplateSettings2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::INavigationViewTemplateSettings2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationViewTemplateSettings2>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_OpenPaneLength(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationViewTemplateSettings2>**)this;
            check_hresult(_winrt_abi_type->get_OpenPaneLength(&value));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_INavigationViewTemplateSettingsFactory<D>::CreateInstance(winrt::Windows::Foundation::IInspectable const& baseInterface, winrt::Windows::Foundation::IInspectable& innerInterface) const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::INavigationViewTemplateSettingsFactory>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::INavigationViewTemplateSettingsFactory, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationViewTemplateSettingsFactory>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->CreateInstance(*(void**)(&baseInterface), impl::bind_out(innerInterface), &value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationViewTemplateSettingsFactory>**)this;
            check_hresult(_winrt_abi_type->CreateInstance(*(void**)(&baseInterface), impl::bind_out(innerInterface), &value));
        }
        return winrt::Microsoft::UI::Xaml::Controls::NavigationViewTemplateSettings{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_INavigationViewTemplateSettingsStatics<D>::TopPaddingProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::INavigationViewTemplateSettingsStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::INavigationViewTemplateSettingsStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationViewTemplateSettingsStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_TopPaddingProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationViewTemplateSettingsStatics>**)this;
            check_hresult(_winrt_abi_type->get_TopPaddingProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_INavigationViewTemplateSettingsStatics<D>::OverflowButtonVisibilityProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::INavigationViewTemplateSettingsStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::INavigationViewTemplateSettingsStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationViewTemplateSettingsStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_OverflowButtonVisibilityProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationViewTemplateSettingsStatics>**)this;
            check_hresult(_winrt_abi_type->get_OverflowButtonVisibilityProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_INavigationViewTemplateSettingsStatics<D>::PaneToggleButtonVisibilityProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::INavigationViewTemplateSettingsStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::INavigationViewTemplateSettingsStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationViewTemplateSettingsStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_PaneToggleButtonVisibilityProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationViewTemplateSettingsStatics>**)this;
            check_hresult(_winrt_abi_type->get_PaneToggleButtonVisibilityProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_INavigationViewTemplateSettingsStatics<D>::BackButtonVisibilityProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::INavigationViewTemplateSettingsStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::INavigationViewTemplateSettingsStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationViewTemplateSettingsStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_BackButtonVisibilityProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationViewTemplateSettingsStatics>**)this;
            check_hresult(_winrt_abi_type->get_BackButtonVisibilityProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_INavigationViewTemplateSettingsStatics<D>::TopPaneVisibilityProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::INavigationViewTemplateSettingsStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::INavigationViewTemplateSettingsStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationViewTemplateSettingsStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_TopPaneVisibilityProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationViewTemplateSettingsStatics>**)this;
            check_hresult(_winrt_abi_type->get_TopPaneVisibilityProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_INavigationViewTemplateSettingsStatics<D>::LeftPaneVisibilityProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::INavigationViewTemplateSettingsStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::INavigationViewTemplateSettingsStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationViewTemplateSettingsStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_LeftPaneVisibilityProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationViewTemplateSettingsStatics>**)this;
            check_hresult(_winrt_abi_type->get_LeftPaneVisibilityProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_INavigationViewTemplateSettingsStatics<D>::SingleSelectionFollowsFocusProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::INavigationViewTemplateSettingsStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::INavigationViewTemplateSettingsStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationViewTemplateSettingsStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_SingleSelectionFollowsFocusProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationViewTemplateSettingsStatics>**)this;
            check_hresult(_winrt_abi_type->get_SingleSelectionFollowsFocusProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_INavigationViewTemplateSettingsStatics<D>::PaneToggleButtonWidthProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::INavigationViewTemplateSettingsStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::INavigationViewTemplateSettingsStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationViewTemplateSettingsStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_PaneToggleButtonWidthProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationViewTemplateSettingsStatics>**)this;
            check_hresult(_winrt_abi_type->get_PaneToggleButtonWidthProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_INavigationViewTemplateSettingsStatics<D>::SmallerPaneToggleButtonWidthProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::INavigationViewTemplateSettingsStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::INavigationViewTemplateSettingsStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationViewTemplateSettingsStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_SmallerPaneToggleButtonWidthProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationViewTemplateSettingsStatics>**)this;
            check_hresult(_winrt_abi_type->get_SmallerPaneToggleButtonWidthProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_INavigationViewTemplateSettingsStatics2<D>::OpenPaneLengthProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::INavigationViewTemplateSettingsStatics2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::INavigationViewTemplateSettingsStatics2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationViewTemplateSettingsStatics2>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_OpenPaneLengthProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INavigationViewTemplateSettingsStatics2>**)this;
            check_hresult(_winrt_abi_type->get_OpenPaneLengthProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_INonVirtualizingLayoutContext<D>::Children() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::INonVirtualizingLayoutContext>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::INonVirtualizingLayoutContext, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INonVirtualizingLayoutContext>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Children(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INonVirtualizingLayoutContext>**)this;
            check_hresult(_winrt_abi_type->get_Children(&value));
        }
        return winrt::Windows::Foundation::Collections::IVectorView<winrt::Windows::UI::Xaml::UIElement>{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_INonVirtualizingLayoutContextFactory<D>::CreateInstance(winrt::Windows::Foundation::IInspectable const& baseInterface, winrt::Windows::Foundation::IInspectable& innerInterface) const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::INonVirtualizingLayoutContextFactory>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::INonVirtualizingLayoutContextFactory, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INonVirtualizingLayoutContextFactory>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->CreateInstance(*(void**)(&baseInterface), impl::bind_out(innerInterface), &value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INonVirtualizingLayoutContextFactory>**)this;
            check_hresult(_winrt_abi_type->CreateInstance(*(void**)(&baseInterface), impl::bind_out(innerInterface), &value));
        }
        return winrt::Microsoft::UI::Xaml::Controls::NonVirtualizingLayoutContext{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_INonVirtualizingLayoutContextOverrides<D>::ChildrenCore() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::INonVirtualizingLayoutContextOverrides>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::INonVirtualizingLayoutContextOverrides, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INonVirtualizingLayoutContextOverrides>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_ChildrenCore(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INonVirtualizingLayoutContextOverrides>**)this;
            check_hresult(_winrt_abi_type->get_ChildrenCore(&value));
        }
        return winrt::Windows::Foundation::Collections::IVectorView<winrt::Windows::UI::Xaml::UIElement>{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_INonVirtualizingLayoutFactory<D>::CreateInstance(winrt::Windows::Foundation::IInspectable const& baseInterface, winrt::Windows::Foundation::IInspectable& innerInterface) const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::INonVirtualizingLayoutFactory>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::INonVirtualizingLayoutFactory, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INonVirtualizingLayoutFactory>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->CreateInstance(*(void**)(&baseInterface), impl::bind_out(innerInterface), &value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INonVirtualizingLayoutFactory>**)this;
            check_hresult(_winrt_abi_type->CreateInstance(*(void**)(&baseInterface), impl::bind_out(innerInterface), &value));
        }
        return winrt::Microsoft::UI::Xaml::Controls::NonVirtualizingLayout{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_INonVirtualizingLayoutOverrides<D>::InitializeForContextCore(winrt::Microsoft::UI::Xaml::Controls::NonVirtualizingLayoutContext const& context) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::INonVirtualizingLayoutOverrides>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::INonVirtualizingLayoutOverrides, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INonVirtualizingLayoutOverrides>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->InitializeForContextCore(*(void**)(&context)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INonVirtualizingLayoutOverrides>**)this;
            check_hresult(_winrt_abi_type->InitializeForContextCore(*(void**)(&context)));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_INonVirtualizingLayoutOverrides<D>::UninitializeForContextCore(winrt::Microsoft::UI::Xaml::Controls::NonVirtualizingLayoutContext const& context) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::INonVirtualizingLayoutOverrides>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::INonVirtualizingLayoutOverrides, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INonVirtualizingLayoutOverrides>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->UninitializeForContextCore(*(void**)(&context)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INonVirtualizingLayoutOverrides>**)this;
            check_hresult(_winrt_abi_type->UninitializeForContextCore(*(void**)(&context)));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_INonVirtualizingLayoutOverrides<D>::MeasureOverride(winrt::Microsoft::UI::Xaml::Controls::NonVirtualizingLayoutContext const& context, winrt::Windows::Foundation::Size const& availableSize) const
    {
        winrt::Windows::Foundation::Size result{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::INonVirtualizingLayoutOverrides>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::INonVirtualizingLayoutOverrides, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INonVirtualizingLayoutOverrides>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->MeasureOverride(*(void**)(&context), impl::bind_in(availableSize), put_abi(result)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INonVirtualizingLayoutOverrides>**)this;
            check_hresult(_winrt_abi_type->MeasureOverride(*(void**)(&context), impl::bind_in(availableSize), put_abi(result)));
        }
        return result;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_INonVirtualizingLayoutOverrides<D>::ArrangeOverride(winrt::Microsoft::UI::Xaml::Controls::NonVirtualizingLayoutContext const& context, winrt::Windows::Foundation::Size const& finalSize) const
    {
        winrt::Windows::Foundation::Size result{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::INonVirtualizingLayoutOverrides>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::INonVirtualizingLayoutOverrides, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INonVirtualizingLayoutOverrides>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->ArrangeOverride(*(void**)(&context), impl::bind_in(finalSize), put_abi(result)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INonVirtualizingLayoutOverrides>**)this;
            check_hresult(_winrt_abi_type->ArrangeOverride(*(void**)(&context), impl::bind_in(finalSize), put_abi(result)));
        }
        return result;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_INumberBox<D>::Minimum() const
    {
        double value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::INumberBox>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::INumberBox, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INumberBox>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Minimum(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INumberBox>**)this;
            check_hresult(_winrt_abi_type->get_Minimum(&value));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_INumberBox<D>::Minimum(double value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::INumberBox>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::INumberBox, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INumberBox>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_Minimum(value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INumberBox>**)this;
            check_hresult(_winrt_abi_type->put_Minimum(value));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_INumberBox<D>::Maximum() const
    {
        double value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::INumberBox>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::INumberBox, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INumberBox>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Maximum(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INumberBox>**)this;
            check_hresult(_winrt_abi_type->get_Maximum(&value));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_INumberBox<D>::Maximum(double value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::INumberBox>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::INumberBox, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INumberBox>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_Maximum(value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INumberBox>**)this;
            check_hresult(_winrt_abi_type->put_Maximum(value));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_INumberBox<D>::Value() const
    {
        double value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::INumberBox>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::INumberBox, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INumberBox>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Value(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INumberBox>**)this;
            check_hresult(_winrt_abi_type->get_Value(&value));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_INumberBox<D>::Value(double value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::INumberBox>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::INumberBox, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INumberBox>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_Value(value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INumberBox>**)this;
            check_hresult(_winrt_abi_type->put_Value(value));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_INumberBox<D>::SmallChange() const
    {
        double value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::INumberBox>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::INumberBox, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INumberBox>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_SmallChange(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INumberBox>**)this;
            check_hresult(_winrt_abi_type->get_SmallChange(&value));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_INumberBox<D>::SmallChange(double value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::INumberBox>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::INumberBox, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INumberBox>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_SmallChange(value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INumberBox>**)this;
            check_hresult(_winrt_abi_type->put_SmallChange(value));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_INumberBox<D>::LargeChange() const
    {
        double value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::INumberBox>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::INumberBox, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INumberBox>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_LargeChange(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INumberBox>**)this;
            check_hresult(_winrt_abi_type->get_LargeChange(&value));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_INumberBox<D>::LargeChange(double value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::INumberBox>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::INumberBox, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INumberBox>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_LargeChange(value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INumberBox>**)this;
            check_hresult(_winrt_abi_type->put_LargeChange(value));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_INumberBox<D>::Text() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::INumberBox>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::INumberBox, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INumberBox>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Text(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INumberBox>**)this;
            check_hresult(_winrt_abi_type->get_Text(&value));
        }
        return hstring{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_INumberBox<D>::Text(param::hstring const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::INumberBox>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::INumberBox, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INumberBox>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_Text(*(void**)(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INumberBox>**)this;
            check_hresult(_winrt_abi_type->put_Text(*(void**)(&value)));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_INumberBox<D>::Header() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::INumberBox>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::INumberBox, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INumberBox>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Header(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INumberBox>**)this;
            check_hresult(_winrt_abi_type->get_Header(&value));
        }
        return winrt::Windows::Foundation::IInspectable{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_INumberBox<D>::Header(winrt::Windows::Foundation::IInspectable const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::INumberBox>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::INumberBox, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INumberBox>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_Header(*(void**)(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INumberBox>**)this;
            check_hresult(_winrt_abi_type->put_Header(*(void**)(&value)));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_INumberBox<D>::HeaderTemplate() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::INumberBox>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::INumberBox, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INumberBox>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_HeaderTemplate(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INumberBox>**)this;
            check_hresult(_winrt_abi_type->get_HeaderTemplate(&value));
        }
        return winrt::Windows::UI::Xaml::DataTemplate{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_INumberBox<D>::HeaderTemplate(winrt::Windows::UI::Xaml::DataTemplate const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::INumberBox>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::INumberBox, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INumberBox>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_HeaderTemplate(*(void**)(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INumberBox>**)this;
            check_hresult(_winrt_abi_type->put_HeaderTemplate(*(void**)(&value)));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_INumberBox<D>::PlaceholderText() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::INumberBox>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::INumberBox, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INumberBox>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_PlaceholderText(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INumberBox>**)this;
            check_hresult(_winrt_abi_type->get_PlaceholderText(&value));
        }
        return hstring{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_INumberBox<D>::PlaceholderText(param::hstring const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::INumberBox>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::INumberBox, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INumberBox>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_PlaceholderText(*(void**)(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INumberBox>**)this;
            check_hresult(_winrt_abi_type->put_PlaceholderText(*(void**)(&value)));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_INumberBox<D>::SelectionFlyout() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::INumberBox>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::INumberBox, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INumberBox>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_SelectionFlyout(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INumberBox>**)this;
            check_hresult(_winrt_abi_type->get_SelectionFlyout(&value));
        }
        return winrt::Windows::UI::Xaml::Controls::Primitives::FlyoutBase{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_INumberBox<D>::SelectionFlyout(winrt::Windows::UI::Xaml::Controls::Primitives::FlyoutBase const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::INumberBox>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::INumberBox, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INumberBox>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_SelectionFlyout(*(void**)(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INumberBox>**)this;
            check_hresult(_winrt_abi_type->put_SelectionFlyout(*(void**)(&value)));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_INumberBox<D>::SelectionHighlightColor() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::INumberBox>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::INumberBox, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INumberBox>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_SelectionHighlightColor(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INumberBox>**)this;
            check_hresult(_winrt_abi_type->get_SelectionHighlightColor(&value));
        }
        return winrt::Windows::UI::Xaml::Media::SolidColorBrush{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_INumberBox<D>::SelectionHighlightColor(winrt::Windows::UI::Xaml::Media::SolidColorBrush const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::INumberBox>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::INumberBox, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INumberBox>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_SelectionHighlightColor(*(void**)(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INumberBox>**)this;
            check_hresult(_winrt_abi_type->put_SelectionHighlightColor(*(void**)(&value)));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_INumberBox<D>::TextReadingOrder() const
    {
        winrt::Windows::UI::Xaml::TextReadingOrder value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::INumberBox>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::INumberBox, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INumberBox>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_TextReadingOrder(reinterpret_cast<int32_t*>(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INumberBox>**)this;
            check_hresult(_winrt_abi_type->get_TextReadingOrder(reinterpret_cast<int32_t*>(&value)));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_INumberBox<D>::TextReadingOrder(winrt::Windows::UI::Xaml::TextReadingOrder const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::INumberBox>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::INumberBox, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INumberBox>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_TextReadingOrder(static_cast<int32_t>(value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INumberBox>**)this;
            check_hresult(_winrt_abi_type->put_TextReadingOrder(static_cast<int32_t>(value)));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_INumberBox<D>::PreventKeyboardDisplayOnProgrammaticFocus() const
    {
        bool value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::INumberBox>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::INumberBox, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INumberBox>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_PreventKeyboardDisplayOnProgrammaticFocus(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INumberBox>**)this;
            check_hresult(_winrt_abi_type->get_PreventKeyboardDisplayOnProgrammaticFocus(&value));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_INumberBox<D>::PreventKeyboardDisplayOnProgrammaticFocus(bool value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::INumberBox>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::INumberBox, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INumberBox>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_PreventKeyboardDisplayOnProgrammaticFocus(value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INumberBox>**)this;
            check_hresult(_winrt_abi_type->put_PreventKeyboardDisplayOnProgrammaticFocus(value));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_INumberBox<D>::Description() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::INumberBox>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::INumberBox, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INumberBox>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Description(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INumberBox>**)this;
            check_hresult(_winrt_abi_type->get_Description(&value));
        }
        return winrt::Windows::Foundation::IInspectable{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_INumberBox<D>::Description(winrt::Windows::Foundation::IInspectable const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::INumberBox>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::INumberBox, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INumberBox>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_Description(*(void**)(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INumberBox>**)this;
            check_hresult(_winrt_abi_type->put_Description(*(void**)(&value)));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_INumberBox<D>::ValidationMode() const
    {
        winrt::Microsoft::UI::Xaml::Controls::NumberBoxValidationMode value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::INumberBox>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::INumberBox, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INumberBox>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_ValidationMode(reinterpret_cast<int32_t*>(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INumberBox>**)this;
            check_hresult(_winrt_abi_type->get_ValidationMode(reinterpret_cast<int32_t*>(&value)));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_INumberBox<D>::ValidationMode(winrt::Microsoft::UI::Xaml::Controls::NumberBoxValidationMode const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::INumberBox>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::INumberBox, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INumberBox>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_ValidationMode(static_cast<int32_t>(value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INumberBox>**)this;
            check_hresult(_winrt_abi_type->put_ValidationMode(static_cast<int32_t>(value)));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_INumberBox<D>::SpinButtonPlacementMode() const
    {
        winrt::Microsoft::UI::Xaml::Controls::NumberBoxSpinButtonPlacementMode value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::INumberBox>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::INumberBox, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INumberBox>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_SpinButtonPlacementMode(reinterpret_cast<int32_t*>(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INumberBox>**)this;
            check_hresult(_winrt_abi_type->get_SpinButtonPlacementMode(reinterpret_cast<int32_t*>(&value)));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_INumberBox<D>::SpinButtonPlacementMode(winrt::Microsoft::UI::Xaml::Controls::NumberBoxSpinButtonPlacementMode const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::INumberBox>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::INumberBox, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INumberBox>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_SpinButtonPlacementMode(static_cast<int32_t>(value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INumberBox>**)this;
            check_hresult(_winrt_abi_type->put_SpinButtonPlacementMode(static_cast<int32_t>(value)));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_INumberBox<D>::IsWrapEnabled() const
    {
        bool value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::INumberBox>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::INumberBox, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INumberBox>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_IsWrapEnabled(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INumberBox>**)this;
            check_hresult(_winrt_abi_type->get_IsWrapEnabled(&value));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_INumberBox<D>::IsWrapEnabled(bool value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::INumberBox>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::INumberBox, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INumberBox>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_IsWrapEnabled(value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INumberBox>**)this;
            check_hresult(_winrt_abi_type->put_IsWrapEnabled(value));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_INumberBox<D>::AcceptsExpression() const
    {
        bool value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::INumberBox>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::INumberBox, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INumberBox>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_AcceptsExpression(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INumberBox>**)this;
            check_hresult(_winrt_abi_type->get_AcceptsExpression(&value));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_INumberBox<D>::AcceptsExpression(bool value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::INumberBox>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::INumberBox, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INumberBox>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_AcceptsExpression(value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INumberBox>**)this;
            check_hresult(_winrt_abi_type->put_AcceptsExpression(value));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_INumberBox<D>::NumberFormatter() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::INumberBox>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::INumberBox, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INumberBox>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_NumberFormatter(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INumberBox>**)this;
            check_hresult(_winrt_abi_type->get_NumberFormatter(&value));
        }
        return winrt::Windows::Globalization::NumberFormatting::INumberFormatter2{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_INumberBox<D>::NumberFormatter(winrt::Windows::Globalization::NumberFormatting::INumberFormatter2 const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::INumberBox>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::INumberBox, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INumberBox>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_NumberFormatter(*(void**)(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INumberBox>**)this;
            check_hresult(_winrt_abi_type->put_NumberFormatter(*(void**)(&value)));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_INumberBox<D>::ValueChanged(winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Xaml::Controls::NumberBox, winrt::Microsoft::UI::Xaml::Controls::NumberBoxValueChangedEventArgs> const& handler) const
    {
        winrt::event_token token{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::INumberBox>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::INumberBox, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INumberBox>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->add_ValueChanged(*(void**)(&handler), put_abi(token)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INumberBox>**)this;
            check_hresult(_winrt_abi_type->add_ValueChanged(*(void**)(&handler), put_abi(token)));
        }
        return token;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_INumberBox<D>::ValueChanged(auto_revoke_t, winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Xaml::Controls::NumberBox, winrt::Microsoft::UI::Xaml::Controls::NumberBoxValueChangedEventArgs> const& handler) const
    {
        return impl::make_event_revoker<D, ValueChanged_revoker>(this, ValueChanged(handler));
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_INumberBox<D>::ValueChanged(winrt::event_token const& token) const noexcept
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::INumberBox>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::INumberBox, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INumberBox>**)&_winrt_casted_result;
            _winrt_abi_type->remove_ValueChanged(impl::bind_in(token));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INumberBox>**)this;
            _winrt_abi_type->remove_ValueChanged(impl::bind_in(token));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_INumberBoxFactory<D>::CreateInstance(winrt::Windows::Foundation::IInspectable const& baseInterface, winrt::Windows::Foundation::IInspectable& innerInterface) const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::INumberBoxFactory>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::INumberBoxFactory, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INumberBoxFactory>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->CreateInstance(*(void**)(&baseInterface), impl::bind_out(innerInterface), &value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INumberBoxFactory>**)this;
            check_hresult(_winrt_abi_type->CreateInstance(*(void**)(&baseInterface), impl::bind_out(innerInterface), &value));
        }
        return winrt::Microsoft::UI::Xaml::Controls::NumberBox{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_INumberBoxStatics<D>::MinimumProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::INumberBoxStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::INumberBoxStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INumberBoxStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_MinimumProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INumberBoxStatics>**)this;
            check_hresult(_winrt_abi_type->get_MinimumProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_INumberBoxStatics<D>::MaximumProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::INumberBoxStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::INumberBoxStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INumberBoxStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_MaximumProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INumberBoxStatics>**)this;
            check_hresult(_winrt_abi_type->get_MaximumProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_INumberBoxStatics<D>::ValueProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::INumberBoxStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::INumberBoxStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INumberBoxStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_ValueProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INumberBoxStatics>**)this;
            check_hresult(_winrt_abi_type->get_ValueProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_INumberBoxStatics<D>::SmallChangeProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::INumberBoxStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::INumberBoxStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INumberBoxStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_SmallChangeProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INumberBoxStatics>**)this;
            check_hresult(_winrt_abi_type->get_SmallChangeProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_INumberBoxStatics<D>::LargeChangeProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::INumberBoxStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::INumberBoxStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INumberBoxStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_LargeChangeProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INumberBoxStatics>**)this;
            check_hresult(_winrt_abi_type->get_LargeChangeProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_INumberBoxStatics<D>::TextProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::INumberBoxStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::INumberBoxStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INumberBoxStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_TextProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INumberBoxStatics>**)this;
            check_hresult(_winrt_abi_type->get_TextProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_INumberBoxStatics<D>::HeaderProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::INumberBoxStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::INumberBoxStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INumberBoxStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_HeaderProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INumberBoxStatics>**)this;
            check_hresult(_winrt_abi_type->get_HeaderProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_INumberBoxStatics<D>::HeaderTemplateProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::INumberBoxStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::INumberBoxStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INumberBoxStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_HeaderTemplateProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INumberBoxStatics>**)this;
            check_hresult(_winrt_abi_type->get_HeaderTemplateProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_INumberBoxStatics<D>::PlaceholderTextProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::INumberBoxStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::INumberBoxStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INumberBoxStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_PlaceholderTextProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INumberBoxStatics>**)this;
            check_hresult(_winrt_abi_type->get_PlaceholderTextProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_INumberBoxStatics<D>::SelectionFlyoutProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::INumberBoxStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::INumberBoxStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INumberBoxStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_SelectionFlyoutProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INumberBoxStatics>**)this;
            check_hresult(_winrt_abi_type->get_SelectionFlyoutProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_INumberBoxStatics<D>::SelectionHighlightColorProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::INumberBoxStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::INumberBoxStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INumberBoxStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_SelectionHighlightColorProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INumberBoxStatics>**)this;
            check_hresult(_winrt_abi_type->get_SelectionHighlightColorProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_INumberBoxStatics<D>::TextReadingOrderProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::INumberBoxStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::INumberBoxStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INumberBoxStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_TextReadingOrderProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INumberBoxStatics>**)this;
            check_hresult(_winrt_abi_type->get_TextReadingOrderProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_INumberBoxStatics<D>::PreventKeyboardDisplayOnProgrammaticFocusProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::INumberBoxStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::INumberBoxStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INumberBoxStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_PreventKeyboardDisplayOnProgrammaticFocusProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INumberBoxStatics>**)this;
            check_hresult(_winrt_abi_type->get_PreventKeyboardDisplayOnProgrammaticFocusProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_INumberBoxStatics<D>::DescriptionProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::INumberBoxStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::INumberBoxStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INumberBoxStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_DescriptionProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INumberBoxStatics>**)this;
            check_hresult(_winrt_abi_type->get_DescriptionProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_INumberBoxStatics<D>::ValidationModeProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::INumberBoxStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::INumberBoxStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INumberBoxStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_ValidationModeProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INumberBoxStatics>**)this;
            check_hresult(_winrt_abi_type->get_ValidationModeProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_INumberBoxStatics<D>::SpinButtonPlacementModeProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::INumberBoxStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::INumberBoxStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INumberBoxStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_SpinButtonPlacementModeProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INumberBoxStatics>**)this;
            check_hresult(_winrt_abi_type->get_SpinButtonPlacementModeProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_INumberBoxStatics<D>::IsWrapEnabledProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::INumberBoxStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::INumberBoxStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INumberBoxStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_IsWrapEnabledProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INumberBoxStatics>**)this;
            check_hresult(_winrt_abi_type->get_IsWrapEnabledProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_INumberBoxStatics<D>::AcceptsExpressionProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::INumberBoxStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::INumberBoxStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INumberBoxStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_AcceptsExpressionProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INumberBoxStatics>**)this;
            check_hresult(_winrt_abi_type->get_AcceptsExpressionProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_INumberBoxStatics<D>::NumberFormatterProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::INumberBoxStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::INumberBoxStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INumberBoxStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_NumberFormatterProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INumberBoxStatics>**)this;
            check_hresult(_winrt_abi_type->get_NumberFormatterProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_INumberBoxValueChangedEventArgs<D>::OldValue() const
    {
        double value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::INumberBoxValueChangedEventArgs>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::INumberBoxValueChangedEventArgs, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INumberBoxValueChangedEventArgs>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_OldValue(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INumberBoxValueChangedEventArgs>**)this;
            check_hresult(_winrt_abi_type->get_OldValue(&value));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_INumberBoxValueChangedEventArgs<D>::NewValue() const
    {
        double value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::INumberBoxValueChangedEventArgs>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::INumberBoxValueChangedEventArgs, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INumberBoxValueChangedEventArgs>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_NewValue(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::INumberBoxValueChangedEventArgs>**)this;
            check_hresult(_winrt_abi_type->get_NewValue(&value));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IParallaxView<D>::Child() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IParallaxView>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IParallaxView, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IParallaxView>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Child(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IParallaxView>**)this;
            check_hresult(_winrt_abi_type->get_Child(&value));
        }
        return winrt::Windows::UI::Xaml::UIElement{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IParallaxView<D>::Child(winrt::Windows::UI::Xaml::UIElement const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IParallaxView>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IParallaxView, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IParallaxView>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_Child(*(void**)(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IParallaxView>**)this;
            check_hresult(_winrt_abi_type->put_Child(*(void**)(&value)));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IParallaxView<D>::HorizontalShift() const
    {
        double value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IParallaxView>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IParallaxView, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IParallaxView>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_HorizontalShift(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IParallaxView>**)this;
            check_hresult(_winrt_abi_type->get_HorizontalShift(&value));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IParallaxView<D>::HorizontalShift(double value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IParallaxView>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IParallaxView, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IParallaxView>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_HorizontalShift(value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IParallaxView>**)this;
            check_hresult(_winrt_abi_type->put_HorizontalShift(value));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IParallaxView<D>::HorizontalSourceEndOffset() const
    {
        double value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IParallaxView>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IParallaxView, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IParallaxView>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_HorizontalSourceEndOffset(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IParallaxView>**)this;
            check_hresult(_winrt_abi_type->get_HorizontalSourceEndOffset(&value));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IParallaxView<D>::HorizontalSourceEndOffset(double value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IParallaxView>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IParallaxView, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IParallaxView>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_HorizontalSourceEndOffset(value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IParallaxView>**)this;
            check_hresult(_winrt_abi_type->put_HorizontalSourceEndOffset(value));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IParallaxView<D>::HorizontalSourceOffsetKind() const
    {
        winrt::Microsoft::UI::Xaml::Controls::ParallaxSourceOffsetKind value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IParallaxView>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IParallaxView, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IParallaxView>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_HorizontalSourceOffsetKind(reinterpret_cast<int32_t*>(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IParallaxView>**)this;
            check_hresult(_winrt_abi_type->get_HorizontalSourceOffsetKind(reinterpret_cast<int32_t*>(&value)));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IParallaxView<D>::HorizontalSourceOffsetKind(winrt::Microsoft::UI::Xaml::Controls::ParallaxSourceOffsetKind const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IParallaxView>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IParallaxView, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IParallaxView>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_HorizontalSourceOffsetKind(static_cast<int32_t>(value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IParallaxView>**)this;
            check_hresult(_winrt_abi_type->put_HorizontalSourceOffsetKind(static_cast<int32_t>(value)));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IParallaxView<D>::HorizontalSourceStartOffset() const
    {
        double value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IParallaxView>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IParallaxView, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IParallaxView>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_HorizontalSourceStartOffset(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IParallaxView>**)this;
            check_hresult(_winrt_abi_type->get_HorizontalSourceStartOffset(&value));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IParallaxView<D>::HorizontalSourceStartOffset(double value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IParallaxView>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IParallaxView, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IParallaxView>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_HorizontalSourceStartOffset(value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IParallaxView>**)this;
            check_hresult(_winrt_abi_type->put_HorizontalSourceStartOffset(value));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IParallaxView<D>::IsHorizontalShiftClamped() const
    {
        bool value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IParallaxView>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IParallaxView, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IParallaxView>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_IsHorizontalShiftClamped(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IParallaxView>**)this;
            check_hresult(_winrt_abi_type->get_IsHorizontalShiftClamped(&value));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IParallaxView<D>::IsHorizontalShiftClamped(bool value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IParallaxView>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IParallaxView, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IParallaxView>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_IsHorizontalShiftClamped(value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IParallaxView>**)this;
            check_hresult(_winrt_abi_type->put_IsHorizontalShiftClamped(value));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IParallaxView<D>::IsVerticalShiftClamped() const
    {
        bool value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IParallaxView>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IParallaxView, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IParallaxView>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_IsVerticalShiftClamped(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IParallaxView>**)this;
            check_hresult(_winrt_abi_type->get_IsVerticalShiftClamped(&value));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IParallaxView<D>::IsVerticalShiftClamped(bool value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IParallaxView>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IParallaxView, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IParallaxView>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_IsVerticalShiftClamped(value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IParallaxView>**)this;
            check_hresult(_winrt_abi_type->put_IsVerticalShiftClamped(value));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IParallaxView<D>::MaxHorizontalShiftRatio() const
    {
        double value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IParallaxView>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IParallaxView, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IParallaxView>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_MaxHorizontalShiftRatio(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IParallaxView>**)this;
            check_hresult(_winrt_abi_type->get_MaxHorizontalShiftRatio(&value));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IParallaxView<D>::MaxHorizontalShiftRatio(double value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IParallaxView>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IParallaxView, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IParallaxView>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_MaxHorizontalShiftRatio(value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IParallaxView>**)this;
            check_hresult(_winrt_abi_type->put_MaxHorizontalShiftRatio(value));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IParallaxView<D>::MaxVerticalShiftRatio() const
    {
        double value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IParallaxView>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IParallaxView, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IParallaxView>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_MaxVerticalShiftRatio(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IParallaxView>**)this;
            check_hresult(_winrt_abi_type->get_MaxVerticalShiftRatio(&value));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IParallaxView<D>::MaxVerticalShiftRatio(double value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IParallaxView>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IParallaxView, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IParallaxView>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_MaxVerticalShiftRatio(value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IParallaxView>**)this;
            check_hresult(_winrt_abi_type->put_MaxVerticalShiftRatio(value));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IParallaxView<D>::Source() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IParallaxView>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IParallaxView, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IParallaxView>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Source(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IParallaxView>**)this;
            check_hresult(_winrt_abi_type->get_Source(&value));
        }
        return winrt::Windows::UI::Xaml::UIElement{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IParallaxView<D>::Source(winrt::Windows::UI::Xaml::UIElement const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IParallaxView>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IParallaxView, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IParallaxView>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_Source(*(void**)(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IParallaxView>**)this;
            check_hresult(_winrt_abi_type->put_Source(*(void**)(&value)));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IParallaxView<D>::VerticalShift() const
    {
        double value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IParallaxView>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IParallaxView, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IParallaxView>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_VerticalShift(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IParallaxView>**)this;
            check_hresult(_winrt_abi_type->get_VerticalShift(&value));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IParallaxView<D>::VerticalShift(double value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IParallaxView>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IParallaxView, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IParallaxView>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_VerticalShift(value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IParallaxView>**)this;
            check_hresult(_winrt_abi_type->put_VerticalShift(value));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IParallaxView<D>::VerticalSourceEndOffset() const
    {
        double value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IParallaxView>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IParallaxView, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IParallaxView>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_VerticalSourceEndOffset(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IParallaxView>**)this;
            check_hresult(_winrt_abi_type->get_VerticalSourceEndOffset(&value));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IParallaxView<D>::VerticalSourceEndOffset(double value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IParallaxView>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IParallaxView, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IParallaxView>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_VerticalSourceEndOffset(value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IParallaxView>**)this;
            check_hresult(_winrt_abi_type->put_VerticalSourceEndOffset(value));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IParallaxView<D>::VerticalSourceOffsetKind() const
    {
        winrt::Microsoft::UI::Xaml::Controls::ParallaxSourceOffsetKind value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IParallaxView>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IParallaxView, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IParallaxView>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_VerticalSourceOffsetKind(reinterpret_cast<int32_t*>(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IParallaxView>**)this;
            check_hresult(_winrt_abi_type->get_VerticalSourceOffsetKind(reinterpret_cast<int32_t*>(&value)));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IParallaxView<D>::VerticalSourceOffsetKind(winrt::Microsoft::UI::Xaml::Controls::ParallaxSourceOffsetKind const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IParallaxView>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IParallaxView, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IParallaxView>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_VerticalSourceOffsetKind(static_cast<int32_t>(value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IParallaxView>**)this;
            check_hresult(_winrt_abi_type->put_VerticalSourceOffsetKind(static_cast<int32_t>(value)));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IParallaxView<D>::VerticalSourceStartOffset() const
    {
        double value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IParallaxView>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IParallaxView, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IParallaxView>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_VerticalSourceStartOffset(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IParallaxView>**)this;
            check_hresult(_winrt_abi_type->get_VerticalSourceStartOffset(&value));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IParallaxView<D>::VerticalSourceStartOffset(double value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IParallaxView>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IParallaxView, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IParallaxView>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_VerticalSourceStartOffset(value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IParallaxView>**)this;
            check_hresult(_winrt_abi_type->put_VerticalSourceStartOffset(value));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IParallaxView<D>::RefreshAutomaticHorizontalOffsets() const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IParallaxView>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IParallaxView, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IParallaxView>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->RefreshAutomaticHorizontalOffsets());
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IParallaxView>**)this;
            check_hresult(_winrt_abi_type->RefreshAutomaticHorizontalOffsets());
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IParallaxView<D>::RefreshAutomaticVerticalOffsets() const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IParallaxView>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IParallaxView, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IParallaxView>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->RefreshAutomaticVerticalOffsets());
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IParallaxView>**)this;
            check_hresult(_winrt_abi_type->RefreshAutomaticVerticalOffsets());
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IParallaxViewFactory<D>::CreateInstance(winrt::Windows::Foundation::IInspectable const& baseInterface, winrt::Windows::Foundation::IInspectable& innerInterface) const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IParallaxViewFactory>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IParallaxViewFactory, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IParallaxViewFactory>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->CreateInstance(*(void**)(&baseInterface), impl::bind_out(innerInterface), &value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IParallaxViewFactory>**)this;
            check_hresult(_winrt_abi_type->CreateInstance(*(void**)(&baseInterface), impl::bind_out(innerInterface), &value));
        }
        return winrt::Microsoft::UI::Xaml::Controls::ParallaxView{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IParallaxViewStatics<D>::ChildProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IParallaxViewStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IParallaxViewStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IParallaxViewStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_ChildProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IParallaxViewStatics>**)this;
            check_hresult(_winrt_abi_type->get_ChildProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IParallaxViewStatics<D>::HorizontalSourceEndOffsetProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IParallaxViewStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IParallaxViewStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IParallaxViewStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_HorizontalSourceEndOffsetProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IParallaxViewStatics>**)this;
            check_hresult(_winrt_abi_type->get_HorizontalSourceEndOffsetProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IParallaxViewStatics<D>::HorizontalSourceOffsetKindProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IParallaxViewStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IParallaxViewStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IParallaxViewStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_HorizontalSourceOffsetKindProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IParallaxViewStatics>**)this;
            check_hresult(_winrt_abi_type->get_HorizontalSourceOffsetKindProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IParallaxViewStatics<D>::HorizontalSourceStartOffsetProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IParallaxViewStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IParallaxViewStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IParallaxViewStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_HorizontalSourceStartOffsetProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IParallaxViewStatics>**)this;
            check_hresult(_winrt_abi_type->get_HorizontalSourceStartOffsetProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IParallaxViewStatics<D>::MaxHorizontalShiftRatioProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IParallaxViewStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IParallaxViewStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IParallaxViewStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_MaxHorizontalShiftRatioProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IParallaxViewStatics>**)this;
            check_hresult(_winrt_abi_type->get_MaxHorizontalShiftRatioProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IParallaxViewStatics<D>::HorizontalShiftProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IParallaxViewStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IParallaxViewStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IParallaxViewStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_HorizontalShiftProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IParallaxViewStatics>**)this;
            check_hresult(_winrt_abi_type->get_HorizontalShiftProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IParallaxViewStatics<D>::IsHorizontalShiftClampedProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IParallaxViewStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IParallaxViewStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IParallaxViewStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_IsHorizontalShiftClampedProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IParallaxViewStatics>**)this;
            check_hresult(_winrt_abi_type->get_IsHorizontalShiftClampedProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IParallaxViewStatics<D>::IsVerticalShiftClampedProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IParallaxViewStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IParallaxViewStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IParallaxViewStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_IsVerticalShiftClampedProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IParallaxViewStatics>**)this;
            check_hresult(_winrt_abi_type->get_IsVerticalShiftClampedProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IParallaxViewStatics<D>::SourceProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IParallaxViewStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IParallaxViewStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IParallaxViewStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_SourceProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IParallaxViewStatics>**)this;
            check_hresult(_winrt_abi_type->get_SourceProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IParallaxViewStatics<D>::VerticalSourceEndOffsetProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IParallaxViewStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IParallaxViewStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IParallaxViewStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_VerticalSourceEndOffsetProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IParallaxViewStatics>**)this;
            check_hresult(_winrt_abi_type->get_VerticalSourceEndOffsetProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IParallaxViewStatics<D>::VerticalSourceOffsetKindProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IParallaxViewStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IParallaxViewStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IParallaxViewStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_VerticalSourceOffsetKindProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IParallaxViewStatics>**)this;
            check_hresult(_winrt_abi_type->get_VerticalSourceOffsetKindProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IParallaxViewStatics<D>::VerticalSourceStartOffsetProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IParallaxViewStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IParallaxViewStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IParallaxViewStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_VerticalSourceStartOffsetProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IParallaxViewStatics>**)this;
            check_hresult(_winrt_abi_type->get_VerticalSourceStartOffsetProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IParallaxViewStatics<D>::MaxVerticalShiftRatioProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IParallaxViewStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IParallaxViewStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IParallaxViewStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_MaxVerticalShiftRatioProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IParallaxViewStatics>**)this;
            check_hresult(_winrt_abi_type->get_MaxVerticalShiftRatioProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IParallaxViewStatics<D>::VerticalShiftProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IParallaxViewStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IParallaxViewStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IParallaxViewStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_VerticalShiftProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IParallaxViewStatics>**)this;
            check_hresult(_winrt_abi_type->get_VerticalShiftProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IPathIconSource<D>::Data() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IPathIconSource>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IPathIconSource, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IPathIconSource>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Data(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IPathIconSource>**)this;
            check_hresult(_winrt_abi_type->get_Data(&value));
        }
        return winrt::Windows::UI::Xaml::Media::Geometry{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IPathIconSource<D>::Data(winrt::Windows::UI::Xaml::Media::Geometry const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IPathIconSource>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IPathIconSource, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IPathIconSource>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_Data(*(void**)(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IPathIconSource>**)this;
            check_hresult(_winrt_abi_type->put_Data(*(void**)(&value)));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IPathIconSourceFactory<D>::CreateInstance(winrt::Windows::Foundation::IInspectable const& baseInterface, winrt::Windows::Foundation::IInspectable& innerInterface) const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IPathIconSourceFactory>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IPathIconSourceFactory, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IPathIconSourceFactory>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->CreateInstance(*(void**)(&baseInterface), impl::bind_out(innerInterface), &value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IPathIconSourceFactory>**)this;
            check_hresult(_winrt_abi_type->CreateInstance(*(void**)(&baseInterface), impl::bind_out(innerInterface), &value));
        }
        return winrt::Microsoft::UI::Xaml::Controls::PathIconSource{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IPathIconSourceStatics<D>::DataProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IPathIconSourceStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IPathIconSourceStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IPathIconSourceStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_DataProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IPathIconSourceStatics>**)this;
            check_hresult(_winrt_abi_type->get_DataProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IPersonPicture<D>::BadgeNumber() const
    {
        int32_t value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IPersonPicture>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IPersonPicture, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IPersonPicture>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_BadgeNumber(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IPersonPicture>**)this;
            check_hresult(_winrt_abi_type->get_BadgeNumber(&value));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IPersonPicture<D>::BadgeNumber(int32_t value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IPersonPicture>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IPersonPicture, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IPersonPicture>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_BadgeNumber(value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IPersonPicture>**)this;
            check_hresult(_winrt_abi_type->put_BadgeNumber(value));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IPersonPicture<D>::BadgeGlyph() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IPersonPicture>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IPersonPicture, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IPersonPicture>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_BadgeGlyph(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IPersonPicture>**)this;
            check_hresult(_winrt_abi_type->get_BadgeGlyph(&value));
        }
        return hstring{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IPersonPicture<D>::BadgeGlyph(param::hstring const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IPersonPicture>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IPersonPicture, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IPersonPicture>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_BadgeGlyph(*(void**)(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IPersonPicture>**)this;
            check_hresult(_winrt_abi_type->put_BadgeGlyph(*(void**)(&value)));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IPersonPicture<D>::BadgeImageSource() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IPersonPicture>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IPersonPicture, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IPersonPicture>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_BadgeImageSource(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IPersonPicture>**)this;
            check_hresult(_winrt_abi_type->get_BadgeImageSource(&value));
        }
        return winrt::Windows::UI::Xaml::Media::ImageSource{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IPersonPicture<D>::BadgeImageSource(winrt::Windows::UI::Xaml::Media::ImageSource const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IPersonPicture>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IPersonPicture, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IPersonPicture>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_BadgeImageSource(*(void**)(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IPersonPicture>**)this;
            check_hresult(_winrt_abi_type->put_BadgeImageSource(*(void**)(&value)));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IPersonPicture<D>::BadgeText() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IPersonPicture>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IPersonPicture, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IPersonPicture>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_BadgeText(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IPersonPicture>**)this;
            check_hresult(_winrt_abi_type->get_BadgeText(&value));
        }
        return hstring{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IPersonPicture<D>::BadgeText(param::hstring const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IPersonPicture>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IPersonPicture, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IPersonPicture>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_BadgeText(*(void**)(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IPersonPicture>**)this;
            check_hresult(_winrt_abi_type->put_BadgeText(*(void**)(&value)));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IPersonPicture<D>::IsGroup() const
    {
        bool value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IPersonPicture>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IPersonPicture, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IPersonPicture>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_IsGroup(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IPersonPicture>**)this;
            check_hresult(_winrt_abi_type->get_IsGroup(&value));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IPersonPicture<D>::IsGroup(bool value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IPersonPicture>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IPersonPicture, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IPersonPicture>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_IsGroup(value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IPersonPicture>**)this;
            check_hresult(_winrt_abi_type->put_IsGroup(value));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IPersonPicture<D>::Contact() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IPersonPicture>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IPersonPicture, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IPersonPicture>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Contact(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IPersonPicture>**)this;
            check_hresult(_winrt_abi_type->get_Contact(&value));
        }
        return winrt::Windows::ApplicationModel::Contacts::Contact{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IPersonPicture<D>::Contact(winrt::Windows::ApplicationModel::Contacts::Contact const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IPersonPicture>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IPersonPicture, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IPersonPicture>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_Contact(*(void**)(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IPersonPicture>**)this;
            check_hresult(_winrt_abi_type->put_Contact(*(void**)(&value)));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IPersonPicture<D>::DisplayName() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IPersonPicture>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IPersonPicture, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IPersonPicture>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_DisplayName(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IPersonPicture>**)this;
            check_hresult(_winrt_abi_type->get_DisplayName(&value));
        }
        return hstring{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IPersonPicture<D>::DisplayName(param::hstring const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IPersonPicture>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IPersonPicture, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IPersonPicture>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_DisplayName(*(void**)(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IPersonPicture>**)this;
            check_hresult(_winrt_abi_type->put_DisplayName(*(void**)(&value)));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IPersonPicture<D>::Initials() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IPersonPicture>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IPersonPicture, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IPersonPicture>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Initials(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IPersonPicture>**)this;
            check_hresult(_winrt_abi_type->get_Initials(&value));
        }
        return hstring{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IPersonPicture<D>::Initials(param::hstring const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IPersonPicture>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IPersonPicture, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IPersonPicture>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_Initials(*(void**)(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IPersonPicture>**)this;
            check_hresult(_winrt_abi_type->put_Initials(*(void**)(&value)));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IPersonPicture<D>::PreferSmallImage() const
    {
        bool value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IPersonPicture>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IPersonPicture, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IPersonPicture>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_PreferSmallImage(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IPersonPicture>**)this;
            check_hresult(_winrt_abi_type->get_PreferSmallImage(&value));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IPersonPicture<D>::PreferSmallImage(bool value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IPersonPicture>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IPersonPicture, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IPersonPicture>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_PreferSmallImage(value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IPersonPicture>**)this;
            check_hresult(_winrt_abi_type->put_PreferSmallImage(value));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IPersonPicture<D>::ProfilePicture() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IPersonPicture>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IPersonPicture, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IPersonPicture>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_ProfilePicture(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IPersonPicture>**)this;
            check_hresult(_winrt_abi_type->get_ProfilePicture(&value));
        }
        return winrt::Windows::UI::Xaml::Media::ImageSource{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IPersonPicture<D>::ProfilePicture(winrt::Windows::UI::Xaml::Media::ImageSource const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IPersonPicture>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IPersonPicture, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IPersonPicture>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_ProfilePicture(*(void**)(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IPersonPicture>**)this;
            check_hresult(_winrt_abi_type->put_ProfilePicture(*(void**)(&value)));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IPersonPicture<D>::TemplateSettings() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IPersonPicture>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IPersonPicture, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IPersonPicture>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_TemplateSettings(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IPersonPicture>**)this;
            check_hresult(_winrt_abi_type->get_TemplateSettings(&value));
        }
        return winrt::Microsoft::UI::Xaml::Controls::PersonPictureTemplateSettings{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IPersonPictureFactory<D>::CreateInstance(winrt::Windows::Foundation::IInspectable const& baseInterface, winrt::Windows::Foundation::IInspectable& innerInterface) const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IPersonPictureFactory>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IPersonPictureFactory, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IPersonPictureFactory>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->CreateInstance(*(void**)(&baseInterface), impl::bind_out(innerInterface), &value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IPersonPictureFactory>**)this;
            check_hresult(_winrt_abi_type->CreateInstance(*(void**)(&baseInterface), impl::bind_out(innerInterface), &value));
        }
        return winrt::Microsoft::UI::Xaml::Controls::PersonPicture{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IPersonPictureStatics<D>::BadgeNumberProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IPersonPictureStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IPersonPictureStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IPersonPictureStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_BadgeNumberProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IPersonPictureStatics>**)this;
            check_hresult(_winrt_abi_type->get_BadgeNumberProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IPersonPictureStatics<D>::BadgeGlyphProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IPersonPictureStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IPersonPictureStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IPersonPictureStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_BadgeGlyphProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IPersonPictureStatics>**)this;
            check_hresult(_winrt_abi_type->get_BadgeGlyphProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IPersonPictureStatics<D>::BadgeImageSourceProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IPersonPictureStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IPersonPictureStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IPersonPictureStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_BadgeImageSourceProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IPersonPictureStatics>**)this;
            check_hresult(_winrt_abi_type->get_BadgeImageSourceProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IPersonPictureStatics<D>::BadgeTextProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IPersonPictureStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IPersonPictureStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IPersonPictureStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_BadgeTextProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IPersonPictureStatics>**)this;
            check_hresult(_winrt_abi_type->get_BadgeTextProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IPersonPictureStatics<D>::IsGroupProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IPersonPictureStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IPersonPictureStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IPersonPictureStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_IsGroupProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IPersonPictureStatics>**)this;
            check_hresult(_winrt_abi_type->get_IsGroupProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IPersonPictureStatics<D>::ContactProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IPersonPictureStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IPersonPictureStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IPersonPictureStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_ContactProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IPersonPictureStatics>**)this;
            check_hresult(_winrt_abi_type->get_ContactProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IPersonPictureStatics<D>::DisplayNameProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IPersonPictureStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IPersonPictureStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IPersonPictureStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_DisplayNameProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IPersonPictureStatics>**)this;
            check_hresult(_winrt_abi_type->get_DisplayNameProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IPersonPictureStatics<D>::InitialsProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IPersonPictureStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IPersonPictureStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IPersonPictureStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_InitialsProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IPersonPictureStatics>**)this;
            check_hresult(_winrt_abi_type->get_InitialsProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IPersonPictureStatics<D>::PreferSmallImageProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IPersonPictureStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IPersonPictureStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IPersonPictureStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_PreferSmallImageProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IPersonPictureStatics>**)this;
            check_hresult(_winrt_abi_type->get_PreferSmallImageProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IPersonPictureStatics<D>::ProfilePictureProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IPersonPictureStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IPersonPictureStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IPersonPictureStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_ProfilePictureProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IPersonPictureStatics>**)this;
            check_hresult(_winrt_abi_type->get_ProfilePictureProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IPersonPictureTemplateSettings<D>::ActualInitials() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IPersonPictureTemplateSettings>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IPersonPictureTemplateSettings, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IPersonPictureTemplateSettings>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_ActualInitials(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IPersonPictureTemplateSettings>**)this;
            check_hresult(_winrt_abi_type->get_ActualInitials(&value));
        }
        return hstring{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IPersonPictureTemplateSettings<D>::ActualImageBrush() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IPersonPictureTemplateSettings>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IPersonPictureTemplateSettings, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IPersonPictureTemplateSettings>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_ActualImageBrush(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IPersonPictureTemplateSettings>**)this;
            check_hresult(_winrt_abi_type->get_ActualImageBrush(&value));
        }
        return winrt::Windows::UI::Xaml::Media::ImageBrush{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IPipsPager<D>::NumberOfPages() const
    {
        int32_t value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IPipsPager>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IPipsPager, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IPipsPager>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_NumberOfPages(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IPipsPager>**)this;
            check_hresult(_winrt_abi_type->get_NumberOfPages(&value));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IPipsPager<D>::NumberOfPages(int32_t value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IPipsPager>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IPipsPager, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IPipsPager>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_NumberOfPages(value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IPipsPager>**)this;
            check_hresult(_winrt_abi_type->put_NumberOfPages(value));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IPipsPager<D>::SelectedPageIndex() const
    {
        int32_t value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IPipsPager>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IPipsPager, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IPipsPager>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_SelectedPageIndex(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IPipsPager>**)this;
            check_hresult(_winrt_abi_type->get_SelectedPageIndex(&value));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IPipsPager<D>::SelectedPageIndex(int32_t value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IPipsPager>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IPipsPager, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IPipsPager>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_SelectedPageIndex(value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IPipsPager>**)this;
            check_hresult(_winrt_abi_type->put_SelectedPageIndex(value));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IPipsPager<D>::MaxVisiblePips() const
    {
        int32_t value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IPipsPager>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IPipsPager, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IPipsPager>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_MaxVisiblePips(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IPipsPager>**)this;
            check_hresult(_winrt_abi_type->get_MaxVisiblePips(&value));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IPipsPager<D>::MaxVisiblePips(int32_t value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IPipsPager>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IPipsPager, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IPipsPager>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_MaxVisiblePips(value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IPipsPager>**)this;
            check_hresult(_winrt_abi_type->put_MaxVisiblePips(value));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IPipsPager<D>::Orientation() const
    {
        winrt::Windows::UI::Xaml::Controls::Orientation value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IPipsPager>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IPipsPager, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IPipsPager>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Orientation(reinterpret_cast<int32_t*>(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IPipsPager>**)this;
            check_hresult(_winrt_abi_type->get_Orientation(reinterpret_cast<int32_t*>(&value)));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IPipsPager<D>::Orientation(winrt::Windows::UI::Xaml::Controls::Orientation const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IPipsPager>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IPipsPager, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IPipsPager>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_Orientation(static_cast<int32_t>(value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IPipsPager>**)this;
            check_hresult(_winrt_abi_type->put_Orientation(static_cast<int32_t>(value)));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IPipsPager<D>::PreviousButtonVisibility() const
    {
        winrt::Microsoft::UI::Xaml::Controls::PipsPagerButtonVisibility value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IPipsPager>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IPipsPager, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IPipsPager>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_PreviousButtonVisibility(reinterpret_cast<int32_t*>(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IPipsPager>**)this;
            check_hresult(_winrt_abi_type->get_PreviousButtonVisibility(reinterpret_cast<int32_t*>(&value)));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IPipsPager<D>::PreviousButtonVisibility(winrt::Microsoft::UI::Xaml::Controls::PipsPagerButtonVisibility const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IPipsPager>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IPipsPager, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IPipsPager>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_PreviousButtonVisibility(static_cast<int32_t>(value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IPipsPager>**)this;
            check_hresult(_winrt_abi_type->put_PreviousButtonVisibility(static_cast<int32_t>(value)));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IPipsPager<D>::NextButtonVisibility() const
    {
        winrt::Microsoft::UI::Xaml::Controls::PipsPagerButtonVisibility value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IPipsPager>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IPipsPager, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IPipsPager>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_NextButtonVisibility(reinterpret_cast<int32_t*>(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IPipsPager>**)this;
            check_hresult(_winrt_abi_type->get_NextButtonVisibility(reinterpret_cast<int32_t*>(&value)));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IPipsPager<D>::NextButtonVisibility(winrt::Microsoft::UI::Xaml::Controls::PipsPagerButtonVisibility const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IPipsPager>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IPipsPager, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IPipsPager>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_NextButtonVisibility(static_cast<int32_t>(value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IPipsPager>**)this;
            check_hresult(_winrt_abi_type->put_NextButtonVisibility(static_cast<int32_t>(value)));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IPipsPager<D>::PreviousButtonStyle() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IPipsPager>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IPipsPager, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IPipsPager>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_PreviousButtonStyle(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IPipsPager>**)this;
            check_hresult(_winrt_abi_type->get_PreviousButtonStyle(&value));
        }
        return winrt::Windows::UI::Xaml::Style{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IPipsPager<D>::PreviousButtonStyle(winrt::Windows::UI::Xaml::Style const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IPipsPager>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IPipsPager, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IPipsPager>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_PreviousButtonStyle(*(void**)(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IPipsPager>**)this;
            check_hresult(_winrt_abi_type->put_PreviousButtonStyle(*(void**)(&value)));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IPipsPager<D>::NextButtonStyle() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IPipsPager>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IPipsPager, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IPipsPager>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_NextButtonStyle(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IPipsPager>**)this;
            check_hresult(_winrt_abi_type->get_NextButtonStyle(&value));
        }
        return winrt::Windows::UI::Xaml::Style{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IPipsPager<D>::NextButtonStyle(winrt::Windows::UI::Xaml::Style const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IPipsPager>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IPipsPager, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IPipsPager>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_NextButtonStyle(*(void**)(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IPipsPager>**)this;
            check_hresult(_winrt_abi_type->put_NextButtonStyle(*(void**)(&value)));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IPipsPager<D>::SelectedPipStyle() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IPipsPager>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IPipsPager, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IPipsPager>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_SelectedPipStyle(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IPipsPager>**)this;
            check_hresult(_winrt_abi_type->get_SelectedPipStyle(&value));
        }
        return winrt::Windows::UI::Xaml::Style{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IPipsPager<D>::SelectedPipStyle(winrt::Windows::UI::Xaml::Style const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IPipsPager>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IPipsPager, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IPipsPager>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_SelectedPipStyle(*(void**)(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IPipsPager>**)this;
            check_hresult(_winrt_abi_type->put_SelectedPipStyle(*(void**)(&value)));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IPipsPager<D>::NormalPipStyle() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IPipsPager>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IPipsPager, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IPipsPager>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_NormalPipStyle(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IPipsPager>**)this;
            check_hresult(_winrt_abi_type->get_NormalPipStyle(&value));
        }
        return winrt::Windows::UI::Xaml::Style{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IPipsPager<D>::NormalPipStyle(winrt::Windows::UI::Xaml::Style const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IPipsPager>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IPipsPager, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IPipsPager>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_NormalPipStyle(*(void**)(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IPipsPager>**)this;
            check_hresult(_winrt_abi_type->put_NormalPipStyle(*(void**)(&value)));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IPipsPager<D>::SelectedIndexChanged(winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Xaml::Controls::PipsPager, winrt::Microsoft::UI::Xaml::Controls::PipsPagerSelectedIndexChangedEventArgs> const& handler) const
    {
        winrt::event_token token{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IPipsPager>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IPipsPager, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IPipsPager>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->add_SelectedIndexChanged(*(void**)(&handler), put_abi(token)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IPipsPager>**)this;
            check_hresult(_winrt_abi_type->add_SelectedIndexChanged(*(void**)(&handler), put_abi(token)));
        }
        return token;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IPipsPager<D>::SelectedIndexChanged(auto_revoke_t, winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Xaml::Controls::PipsPager, winrt::Microsoft::UI::Xaml::Controls::PipsPagerSelectedIndexChangedEventArgs> const& handler) const
    {
        return impl::make_event_revoker<D, SelectedIndexChanged_revoker>(this, SelectedIndexChanged(handler));
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IPipsPager<D>::SelectedIndexChanged(winrt::event_token const& token) const noexcept
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IPipsPager>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IPipsPager, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IPipsPager>**)&_winrt_casted_result;
            _winrt_abi_type->remove_SelectedIndexChanged(impl::bind_in(token));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IPipsPager>**)this;
            _winrt_abi_type->remove_SelectedIndexChanged(impl::bind_in(token));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IPipsPager<D>::TemplateSettings() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IPipsPager>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IPipsPager, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IPipsPager>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_TemplateSettings(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IPipsPager>**)this;
            check_hresult(_winrt_abi_type->get_TemplateSettings(&value));
        }
        return winrt::Microsoft::UI::Xaml::Controls::PipsPagerTemplateSettings{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IPipsPagerFactory<D>::CreateInstance(winrt::Windows::Foundation::IInspectable const& baseInterface, winrt::Windows::Foundation::IInspectable& innerInterface) const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IPipsPagerFactory>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IPipsPagerFactory, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IPipsPagerFactory>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->CreateInstance(*(void**)(&baseInterface), impl::bind_out(innerInterface), &value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IPipsPagerFactory>**)this;
            check_hresult(_winrt_abi_type->CreateInstance(*(void**)(&baseInterface), impl::bind_out(innerInterface), &value));
        }
        return winrt::Microsoft::UI::Xaml::Controls::PipsPager{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IPipsPagerStatics<D>::NumberOfPagesProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IPipsPagerStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IPipsPagerStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IPipsPagerStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_NumberOfPagesProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IPipsPagerStatics>**)this;
            check_hresult(_winrt_abi_type->get_NumberOfPagesProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IPipsPagerStatics<D>::SelectedPageIndexProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IPipsPagerStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IPipsPagerStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IPipsPagerStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_SelectedPageIndexProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IPipsPagerStatics>**)this;
            check_hresult(_winrt_abi_type->get_SelectedPageIndexProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IPipsPagerStatics<D>::MaxVisiblePipsProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IPipsPagerStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IPipsPagerStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IPipsPagerStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_MaxVisiblePipsProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IPipsPagerStatics>**)this;
            check_hresult(_winrt_abi_type->get_MaxVisiblePipsProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IPipsPagerStatics<D>::OrientationProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IPipsPagerStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IPipsPagerStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IPipsPagerStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_OrientationProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IPipsPagerStatics>**)this;
            check_hresult(_winrt_abi_type->get_OrientationProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IPipsPagerStatics<D>::PreviousButtonVisibilityProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IPipsPagerStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IPipsPagerStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IPipsPagerStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_PreviousButtonVisibilityProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IPipsPagerStatics>**)this;
            check_hresult(_winrt_abi_type->get_PreviousButtonVisibilityProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IPipsPagerStatics<D>::NextButtonVisibilityProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IPipsPagerStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IPipsPagerStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IPipsPagerStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_NextButtonVisibilityProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IPipsPagerStatics>**)this;
            check_hresult(_winrt_abi_type->get_NextButtonVisibilityProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IPipsPagerStatics<D>::PreviousButtonStyleProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IPipsPagerStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IPipsPagerStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IPipsPagerStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_PreviousButtonStyleProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IPipsPagerStatics>**)this;
            check_hresult(_winrt_abi_type->get_PreviousButtonStyleProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IPipsPagerStatics<D>::NextButtonStyleProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IPipsPagerStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IPipsPagerStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IPipsPagerStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_NextButtonStyleProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IPipsPagerStatics>**)this;
            check_hresult(_winrt_abi_type->get_NextButtonStyleProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IPipsPagerStatics<D>::SelectedPipStyleProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IPipsPagerStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IPipsPagerStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IPipsPagerStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_SelectedPipStyleProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IPipsPagerStatics>**)this;
            check_hresult(_winrt_abi_type->get_SelectedPipStyleProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IPipsPagerStatics<D>::NormalPipStyleProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IPipsPagerStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IPipsPagerStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IPipsPagerStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_NormalPipStyleProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IPipsPagerStatics>**)this;
            check_hresult(_winrt_abi_type->get_NormalPipStyleProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IPipsPagerTemplateSettings<D>::PipsPagerItems() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IPipsPagerTemplateSettings>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IPipsPagerTemplateSettings, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IPipsPagerTemplateSettings>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_PipsPagerItems(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IPipsPagerTemplateSettings>**)this;
            check_hresult(_winrt_abi_type->get_PipsPagerItems(&value));
        }
        return winrt::Windows::Foundation::Collections::IVector<int32_t>{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IProgressBar<D>::IsIndeterminate() const
    {
        bool value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IProgressBar>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IProgressBar, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IProgressBar>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_IsIndeterminate(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IProgressBar>**)this;
            check_hresult(_winrt_abi_type->get_IsIndeterminate(&value));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IProgressBar<D>::IsIndeterminate(bool value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IProgressBar>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IProgressBar, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IProgressBar>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_IsIndeterminate(value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IProgressBar>**)this;
            check_hresult(_winrt_abi_type->put_IsIndeterminate(value));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IProgressBar<D>::ShowError() const
    {
        bool value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IProgressBar>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IProgressBar, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IProgressBar>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_ShowError(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IProgressBar>**)this;
            check_hresult(_winrt_abi_type->get_ShowError(&value));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IProgressBar<D>::ShowError(bool value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IProgressBar>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IProgressBar, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IProgressBar>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_ShowError(value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IProgressBar>**)this;
            check_hresult(_winrt_abi_type->put_ShowError(value));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IProgressBar<D>::ShowPaused() const
    {
        bool value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IProgressBar>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IProgressBar, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IProgressBar>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_ShowPaused(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IProgressBar>**)this;
            check_hresult(_winrt_abi_type->get_ShowPaused(&value));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IProgressBar<D>::ShowPaused(bool value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IProgressBar>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IProgressBar, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IProgressBar>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_ShowPaused(value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IProgressBar>**)this;
            check_hresult(_winrt_abi_type->put_ShowPaused(value));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IProgressBar<D>::TemplateSettings() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IProgressBar>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IProgressBar, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IProgressBar>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_TemplateSettings(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IProgressBar>**)this;
            check_hresult(_winrt_abi_type->get_TemplateSettings(&value));
        }
        return winrt::Microsoft::UI::Xaml::Controls::ProgressBarTemplateSettings{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IProgressBarFactory<D>::CreateInstance(winrt::Windows::Foundation::IInspectable const& baseInterface, winrt::Windows::Foundation::IInspectable& innerInterface) const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IProgressBarFactory>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IProgressBarFactory, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IProgressBarFactory>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->CreateInstance(*(void**)(&baseInterface), impl::bind_out(innerInterface), &value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IProgressBarFactory>**)this;
            check_hresult(_winrt_abi_type->CreateInstance(*(void**)(&baseInterface), impl::bind_out(innerInterface), &value));
        }
        return winrt::Microsoft::UI::Xaml::Controls::ProgressBar{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IProgressBarStatics<D>::IsIndeterminateProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IProgressBarStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IProgressBarStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IProgressBarStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_IsIndeterminateProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IProgressBarStatics>**)this;
            check_hresult(_winrt_abi_type->get_IsIndeterminateProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IProgressBarStatics<D>::ShowErrorProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IProgressBarStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IProgressBarStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IProgressBarStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_ShowErrorProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IProgressBarStatics>**)this;
            check_hresult(_winrt_abi_type->get_ShowErrorProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IProgressBarStatics<D>::ShowPausedProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IProgressBarStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IProgressBarStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IProgressBarStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_ShowPausedProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IProgressBarStatics>**)this;
            check_hresult(_winrt_abi_type->get_ShowPausedProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IProgressBarTemplateSettings<D>::ContainerAnimationStartPosition() const
    {
        double value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IProgressBarTemplateSettings>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IProgressBarTemplateSettings, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IProgressBarTemplateSettings>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_ContainerAnimationStartPosition(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IProgressBarTemplateSettings>**)this;
            check_hresult(_winrt_abi_type->get_ContainerAnimationStartPosition(&value));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IProgressBarTemplateSettings<D>::ContainerAnimationEndPosition() const
    {
        double value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IProgressBarTemplateSettings>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IProgressBarTemplateSettings, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IProgressBarTemplateSettings>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_ContainerAnimationEndPosition(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IProgressBarTemplateSettings>**)this;
            check_hresult(_winrt_abi_type->get_ContainerAnimationEndPosition(&value));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IProgressBarTemplateSettings<D>::Container2AnimationStartPosition() const
    {
        double value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IProgressBarTemplateSettings>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IProgressBarTemplateSettings, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IProgressBarTemplateSettings>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Container2AnimationStartPosition(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IProgressBarTemplateSettings>**)this;
            check_hresult(_winrt_abi_type->get_Container2AnimationStartPosition(&value));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IProgressBarTemplateSettings<D>::Container2AnimationEndPosition() const
    {
        double value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IProgressBarTemplateSettings>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IProgressBarTemplateSettings, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IProgressBarTemplateSettings>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Container2AnimationEndPosition(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IProgressBarTemplateSettings>**)this;
            check_hresult(_winrt_abi_type->get_Container2AnimationEndPosition(&value));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IProgressBarTemplateSettings<D>::ContainerAnimationMidPosition() const
    {
        double value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IProgressBarTemplateSettings>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IProgressBarTemplateSettings, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IProgressBarTemplateSettings>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_ContainerAnimationMidPosition(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IProgressBarTemplateSettings>**)this;
            check_hresult(_winrt_abi_type->get_ContainerAnimationMidPosition(&value));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IProgressBarTemplateSettings<D>::IndicatorLengthDelta() const
    {
        double value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IProgressBarTemplateSettings>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IProgressBarTemplateSettings, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IProgressBarTemplateSettings>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_IndicatorLengthDelta(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IProgressBarTemplateSettings>**)this;
            check_hresult(_winrt_abi_type->get_IndicatorLengthDelta(&value));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IProgressBarTemplateSettings<D>::ClipRect() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IProgressBarTemplateSettings>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IProgressBarTemplateSettings, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IProgressBarTemplateSettings>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_ClipRect(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IProgressBarTemplateSettings>**)this;
            check_hresult(_winrt_abi_type->get_ClipRect(&value));
        }
        return winrt::Windows::UI::Xaml::Media::RectangleGeometry{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IProgressBarTemplateSettings<D>::EllipseAnimationEndPosition() const
    {
        double value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IProgressBarTemplateSettings>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IProgressBarTemplateSettings, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IProgressBarTemplateSettings>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_EllipseAnimationEndPosition(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IProgressBarTemplateSettings>**)this;
            check_hresult(_winrt_abi_type->get_EllipseAnimationEndPosition(&value));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IProgressBarTemplateSettings<D>::EllipseAnimationWellPosition() const
    {
        double value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IProgressBarTemplateSettings>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IProgressBarTemplateSettings, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IProgressBarTemplateSettings>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_EllipseAnimationWellPosition(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IProgressBarTemplateSettings>**)this;
            check_hresult(_winrt_abi_type->get_EllipseAnimationWellPosition(&value));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IProgressBarTemplateSettings<D>::EllipseDiameter() const
    {
        double value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IProgressBarTemplateSettings>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IProgressBarTemplateSettings, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IProgressBarTemplateSettings>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_EllipseDiameter(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IProgressBarTemplateSettings>**)this;
            check_hresult(_winrt_abi_type->get_EllipseDiameter(&value));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IProgressBarTemplateSettings<D>::EllipseOffset() const
    {
        double value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IProgressBarTemplateSettings>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IProgressBarTemplateSettings, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IProgressBarTemplateSettings>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_EllipseOffset(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IProgressBarTemplateSettings>**)this;
            check_hresult(_winrt_abi_type->get_EllipseOffset(&value));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IProgressRing<D>::IsActive() const
    {
        bool value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IProgressRing>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IProgressRing, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IProgressRing>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_IsActive(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IProgressRing>**)this;
            check_hresult(_winrt_abi_type->get_IsActive(&value));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IProgressRing<D>::IsActive(bool value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IProgressRing>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IProgressRing, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IProgressRing>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_IsActive(value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IProgressRing>**)this;
            check_hresult(_winrt_abi_type->put_IsActive(value));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IProgressRing<D>::IsIndeterminate() const
    {
        bool value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IProgressRing>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IProgressRing, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IProgressRing>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_IsIndeterminate(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IProgressRing>**)this;
            check_hresult(_winrt_abi_type->get_IsIndeterminate(&value));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IProgressRing<D>::IsIndeterminate(bool value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IProgressRing>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IProgressRing, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IProgressRing>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_IsIndeterminate(value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IProgressRing>**)this;
            check_hresult(_winrt_abi_type->put_IsIndeterminate(value));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IProgressRing<D>::TemplateSettings() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IProgressRing>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IProgressRing, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IProgressRing>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_TemplateSettings(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IProgressRing>**)this;
            check_hresult(_winrt_abi_type->get_TemplateSettings(&value));
        }
        return winrt::Microsoft::UI::Xaml::Controls::ProgressRingTemplateSettings{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IProgressRing<D>::Value() const
    {
        double value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IProgressRing>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IProgressRing, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IProgressRing>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Value(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IProgressRing>**)this;
            check_hresult(_winrt_abi_type->get_Value(&value));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IProgressRing<D>::Value(double value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IProgressRing>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IProgressRing, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IProgressRing>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_Value(value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IProgressRing>**)this;
            check_hresult(_winrt_abi_type->put_Value(value));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IProgressRing<D>::Minimum() const
    {
        double value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IProgressRing>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IProgressRing, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IProgressRing>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Minimum(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IProgressRing>**)this;
            check_hresult(_winrt_abi_type->get_Minimum(&value));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IProgressRing<D>::Minimum(double value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IProgressRing>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IProgressRing, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IProgressRing>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_Minimum(value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IProgressRing>**)this;
            check_hresult(_winrt_abi_type->put_Minimum(value));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IProgressRing<D>::Maximum() const
    {
        double value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IProgressRing>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IProgressRing, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IProgressRing>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Maximum(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IProgressRing>**)this;
            check_hresult(_winrt_abi_type->get_Maximum(&value));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IProgressRing<D>::Maximum(double value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IProgressRing>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IProgressRing, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IProgressRing>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_Maximum(value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IProgressRing>**)this;
            check_hresult(_winrt_abi_type->put_Maximum(value));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IProgressRingFactory<D>::CreateInstance(winrt::Windows::Foundation::IInspectable const& baseInterface, winrt::Windows::Foundation::IInspectable& innerInterface) const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IProgressRingFactory>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IProgressRingFactory, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IProgressRingFactory>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->CreateInstance(*(void**)(&baseInterface), impl::bind_out(innerInterface), &value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IProgressRingFactory>**)this;
            check_hresult(_winrt_abi_type->CreateInstance(*(void**)(&baseInterface), impl::bind_out(innerInterface), &value));
        }
        return winrt::Microsoft::UI::Xaml::Controls::ProgressRing{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IProgressRingStatics<D>::IsActiveProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IProgressRingStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IProgressRingStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IProgressRingStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_IsActiveProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IProgressRingStatics>**)this;
            check_hresult(_winrt_abi_type->get_IsActiveProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IProgressRingStatics<D>::IsIndeterminateProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IProgressRingStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IProgressRingStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IProgressRingStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_IsIndeterminateProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IProgressRingStatics>**)this;
            check_hresult(_winrt_abi_type->get_IsIndeterminateProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IProgressRingStatics<D>::ValueProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IProgressRingStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IProgressRingStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IProgressRingStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_ValueProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IProgressRingStatics>**)this;
            check_hresult(_winrt_abi_type->get_ValueProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IProgressRingStatics<D>::MinimumProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IProgressRingStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IProgressRingStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IProgressRingStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_MinimumProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IProgressRingStatics>**)this;
            check_hresult(_winrt_abi_type->get_MinimumProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IProgressRingStatics<D>::MaximumProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IProgressRingStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IProgressRingStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IProgressRingStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_MaximumProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IProgressRingStatics>**)this;
            check_hresult(_winrt_abi_type->get_MaximumProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IProgressRingTemplateSettings<D>::EllipseDiameter() const
    {
        double value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IProgressRingTemplateSettings>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IProgressRingTemplateSettings, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IProgressRingTemplateSettings>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_EllipseDiameter(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IProgressRingTemplateSettings>**)this;
            check_hresult(_winrt_abi_type->get_EllipseDiameter(&value));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IProgressRingTemplateSettings<D>::EllipseOffset() const
    {
        winrt::Windows::UI::Xaml::Thickness value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IProgressRingTemplateSettings>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IProgressRingTemplateSettings, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IProgressRingTemplateSettings>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_EllipseOffset(put_abi(value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IProgressRingTemplateSettings>**)this;
            check_hresult(_winrt_abi_type->get_EllipseOffset(put_abi(value)));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IProgressRingTemplateSettings<D>::MaxSideLength() const
    {
        double value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IProgressRingTemplateSettings>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IProgressRingTemplateSettings, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IProgressRingTemplateSettings>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_MaxSideLength(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IProgressRingTemplateSettings>**)this;
            check_hresult(_winrt_abi_type->get_MaxSideLength(&value));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IRadioButtons<D>::ItemsSource() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IRadioButtons>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IRadioButtons, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IRadioButtons>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_ItemsSource(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IRadioButtons>**)this;
            check_hresult(_winrt_abi_type->get_ItemsSource(&value));
        }
        return winrt::Windows::Foundation::IInspectable{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IRadioButtons<D>::ItemsSource(winrt::Windows::Foundation::IInspectable const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IRadioButtons>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IRadioButtons, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IRadioButtons>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_ItemsSource(*(void**)(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IRadioButtons>**)this;
            check_hresult(_winrt_abi_type->put_ItemsSource(*(void**)(&value)));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IRadioButtons<D>::Items() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IRadioButtons>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IRadioButtons, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IRadioButtons>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Items(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IRadioButtons>**)this;
            check_hresult(_winrt_abi_type->get_Items(&value));
        }
        return winrt::Windows::Foundation::Collections::IVector<winrt::Windows::Foundation::IInspectable>{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IRadioButtons<D>::ItemTemplate() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IRadioButtons>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IRadioButtons, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IRadioButtons>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_ItemTemplate(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IRadioButtons>**)this;
            check_hresult(_winrt_abi_type->get_ItemTemplate(&value));
        }
        return winrt::Windows::Foundation::IInspectable{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IRadioButtons<D>::ItemTemplate(winrt::Windows::Foundation::IInspectable const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IRadioButtons>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IRadioButtons, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IRadioButtons>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_ItemTemplate(*(void**)(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IRadioButtons>**)this;
            check_hresult(_winrt_abi_type->put_ItemTemplate(*(void**)(&value)));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IRadioButtons<D>::ContainerFromIndex(int32_t index) const
    {
        void* result{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IRadioButtons>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IRadioButtons, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IRadioButtons>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->ContainerFromIndex(index, &result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IRadioButtons>**)this;
            check_hresult(_winrt_abi_type->ContainerFromIndex(index, &result));
        }
        return winrt::Windows::UI::Xaml::UIElement{ result, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IRadioButtons<D>::SelectedIndex() const
    {
        int32_t value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IRadioButtons>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IRadioButtons, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IRadioButtons>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_SelectedIndex(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IRadioButtons>**)this;
            check_hresult(_winrt_abi_type->get_SelectedIndex(&value));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IRadioButtons<D>::SelectedIndex(int32_t value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IRadioButtons>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IRadioButtons, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IRadioButtons>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_SelectedIndex(value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IRadioButtons>**)this;
            check_hresult(_winrt_abi_type->put_SelectedIndex(value));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IRadioButtons<D>::SelectedItem() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IRadioButtons>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IRadioButtons, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IRadioButtons>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_SelectedItem(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IRadioButtons>**)this;
            check_hresult(_winrt_abi_type->get_SelectedItem(&value));
        }
        return winrt::Windows::Foundation::IInspectable{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IRadioButtons<D>::SelectedItem(winrt::Windows::Foundation::IInspectable const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IRadioButtons>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IRadioButtons, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IRadioButtons>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_SelectedItem(*(void**)(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IRadioButtons>**)this;
            check_hresult(_winrt_abi_type->put_SelectedItem(*(void**)(&value)));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IRadioButtons<D>::SelectionChanged(winrt::Windows::UI::Xaml::Controls::SelectionChangedEventHandler const& handler) const
    {
        winrt::event_token token{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IRadioButtons>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IRadioButtons, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IRadioButtons>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->add_SelectionChanged(*(void**)(&handler), put_abi(token)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IRadioButtons>**)this;
            check_hresult(_winrt_abi_type->add_SelectionChanged(*(void**)(&handler), put_abi(token)));
        }
        return token;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IRadioButtons<D>::SelectionChanged(auto_revoke_t, winrt::Windows::UI::Xaml::Controls::SelectionChangedEventHandler const& handler) const
    {
        return impl::make_event_revoker<D, SelectionChanged_revoker>(this, SelectionChanged(handler));
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IRadioButtons<D>::SelectionChanged(winrt::event_token const& token) const noexcept
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IRadioButtons>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IRadioButtons, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IRadioButtons>**)&_winrt_casted_result;
            _winrt_abi_type->remove_SelectionChanged(impl::bind_in(token));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IRadioButtons>**)this;
            _winrt_abi_type->remove_SelectionChanged(impl::bind_in(token));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IRadioButtons<D>::MaxColumns() const
    {
        int32_t value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IRadioButtons>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IRadioButtons, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IRadioButtons>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_MaxColumns(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IRadioButtons>**)this;
            check_hresult(_winrt_abi_type->get_MaxColumns(&value));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IRadioButtons<D>::MaxColumns(int32_t value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IRadioButtons>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IRadioButtons, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IRadioButtons>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_MaxColumns(value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IRadioButtons>**)this;
            check_hresult(_winrt_abi_type->put_MaxColumns(value));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IRadioButtons<D>::Header() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IRadioButtons>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IRadioButtons, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IRadioButtons>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Header(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IRadioButtons>**)this;
            check_hresult(_winrt_abi_type->get_Header(&value));
        }
        return winrt::Windows::Foundation::IInspectable{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IRadioButtons<D>::Header(winrt::Windows::Foundation::IInspectable const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IRadioButtons>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IRadioButtons, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IRadioButtons>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_Header(*(void**)(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IRadioButtons>**)this;
            check_hresult(_winrt_abi_type->put_Header(*(void**)(&value)));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IRadioButtons<D>::HeaderTemplate() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IRadioButtons>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IRadioButtons, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IRadioButtons>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_HeaderTemplate(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IRadioButtons>**)this;
            check_hresult(_winrt_abi_type->get_HeaderTemplate(&value));
        }
        return winrt::Windows::UI::Xaml::DataTemplate{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IRadioButtons<D>::HeaderTemplate(winrt::Windows::UI::Xaml::DataTemplate const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IRadioButtons>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IRadioButtons, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IRadioButtons>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_HeaderTemplate(*(void**)(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IRadioButtons>**)this;
            check_hresult(_winrt_abi_type->put_HeaderTemplate(*(void**)(&value)));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IRadioButtonsFactory<D>::CreateInstance(winrt::Windows::Foundation::IInspectable const& baseInterface, winrt::Windows::Foundation::IInspectable& innerInterface) const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IRadioButtonsFactory>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IRadioButtonsFactory, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IRadioButtonsFactory>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->CreateInstance(*(void**)(&baseInterface), impl::bind_out(innerInterface), &value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IRadioButtonsFactory>**)this;
            check_hresult(_winrt_abi_type->CreateInstance(*(void**)(&baseInterface), impl::bind_out(innerInterface), &value));
        }
        return winrt::Microsoft::UI::Xaml::Controls::RadioButtons{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IRadioButtonsStatics<D>::ItemsSourceProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IRadioButtonsStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IRadioButtonsStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IRadioButtonsStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_ItemsSourceProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IRadioButtonsStatics>**)this;
            check_hresult(_winrt_abi_type->get_ItemsSourceProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IRadioButtonsStatics<D>::ItemsProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IRadioButtonsStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IRadioButtonsStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IRadioButtonsStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_ItemsProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IRadioButtonsStatics>**)this;
            check_hresult(_winrt_abi_type->get_ItemsProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IRadioButtonsStatics<D>::ItemTemplateProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IRadioButtonsStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IRadioButtonsStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IRadioButtonsStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_ItemTemplateProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IRadioButtonsStatics>**)this;
            check_hresult(_winrt_abi_type->get_ItemTemplateProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IRadioButtonsStatics<D>::SelectedIndexProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IRadioButtonsStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IRadioButtonsStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IRadioButtonsStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_SelectedIndexProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IRadioButtonsStatics>**)this;
            check_hresult(_winrt_abi_type->get_SelectedIndexProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IRadioButtonsStatics<D>::SelectedItemProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IRadioButtonsStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IRadioButtonsStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IRadioButtonsStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_SelectedItemProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IRadioButtonsStatics>**)this;
            check_hresult(_winrt_abi_type->get_SelectedItemProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IRadioButtonsStatics<D>::MaxColumnsProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IRadioButtonsStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IRadioButtonsStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IRadioButtonsStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_MaxColumnsProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IRadioButtonsStatics>**)this;
            check_hresult(_winrt_abi_type->get_MaxColumnsProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IRadioButtonsStatics<D>::HeaderProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IRadioButtonsStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IRadioButtonsStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IRadioButtonsStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_HeaderProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IRadioButtonsStatics>**)this;
            check_hresult(_winrt_abi_type->get_HeaderProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IRadioButtonsStatics<D>::HeaderTemplateProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IRadioButtonsStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IRadioButtonsStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IRadioButtonsStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_HeaderTemplateProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IRadioButtonsStatics>**)this;
            check_hresult(_winrt_abi_type->get_HeaderTemplateProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IRadioMenuFlyoutItem<D>::IsChecked() const
    {
        bool value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IRadioMenuFlyoutItem>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IRadioMenuFlyoutItem, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IRadioMenuFlyoutItem>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_IsChecked(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IRadioMenuFlyoutItem>**)this;
            check_hresult(_winrt_abi_type->get_IsChecked(&value));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IRadioMenuFlyoutItem<D>::IsChecked(bool value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IRadioMenuFlyoutItem>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IRadioMenuFlyoutItem, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IRadioMenuFlyoutItem>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_IsChecked(value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IRadioMenuFlyoutItem>**)this;
            check_hresult(_winrt_abi_type->put_IsChecked(value));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IRadioMenuFlyoutItem<D>::GroupName() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IRadioMenuFlyoutItem>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IRadioMenuFlyoutItem, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IRadioMenuFlyoutItem>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_GroupName(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IRadioMenuFlyoutItem>**)this;
            check_hresult(_winrt_abi_type->get_GroupName(&value));
        }
        return hstring{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IRadioMenuFlyoutItem<D>::GroupName(param::hstring const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IRadioMenuFlyoutItem>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IRadioMenuFlyoutItem, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IRadioMenuFlyoutItem>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_GroupName(*(void**)(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IRadioMenuFlyoutItem>**)this;
            check_hresult(_winrt_abi_type->put_GroupName(*(void**)(&value)));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IRadioMenuFlyoutItemFactory<D>::CreateInstance(winrt::Windows::Foundation::IInspectable const& baseInterface, winrt::Windows::Foundation::IInspectable& innerInterface) const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IRadioMenuFlyoutItemFactory>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IRadioMenuFlyoutItemFactory, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IRadioMenuFlyoutItemFactory>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->CreateInstance(*(void**)(&baseInterface), impl::bind_out(innerInterface), &value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IRadioMenuFlyoutItemFactory>**)this;
            check_hresult(_winrt_abi_type->CreateInstance(*(void**)(&baseInterface), impl::bind_out(innerInterface), &value));
        }
        return winrt::Microsoft::UI::Xaml::Controls::RadioMenuFlyoutItem{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IRadioMenuFlyoutItemStatics<D>::IsCheckedProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IRadioMenuFlyoutItemStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IRadioMenuFlyoutItemStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IRadioMenuFlyoutItemStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_IsCheckedProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IRadioMenuFlyoutItemStatics>**)this;
            check_hresult(_winrt_abi_type->get_IsCheckedProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IRadioMenuFlyoutItemStatics<D>::GroupNameProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IRadioMenuFlyoutItemStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IRadioMenuFlyoutItemStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IRadioMenuFlyoutItemStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_GroupNameProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IRadioMenuFlyoutItemStatics>**)this;
            check_hresult(_winrt_abi_type->get_GroupNameProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IRadioMenuFlyoutItemStatics2<D>::AreCheckStatesEnabledProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IRadioMenuFlyoutItemStatics2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IRadioMenuFlyoutItemStatics2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IRadioMenuFlyoutItemStatics2>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_AreCheckStatesEnabledProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IRadioMenuFlyoutItemStatics2>**)this;
            check_hresult(_winrt_abi_type->get_AreCheckStatesEnabledProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IRadioMenuFlyoutItemStatics2<D>::SetAreCheckStatesEnabled(winrt::Windows::UI::Xaml::Controls::MenuFlyoutSubItem const& object, bool value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IRadioMenuFlyoutItemStatics2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IRadioMenuFlyoutItemStatics2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IRadioMenuFlyoutItemStatics2>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->SetAreCheckStatesEnabled(*(void**)(&object), value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IRadioMenuFlyoutItemStatics2>**)this;
            check_hresult(_winrt_abi_type->SetAreCheckStatesEnabled(*(void**)(&object), value));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IRadioMenuFlyoutItemStatics2<D>::GetAreCheckStatesEnabled(winrt::Windows::UI::Xaml::Controls::MenuFlyoutSubItem const& object) const
    {
        bool result{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IRadioMenuFlyoutItemStatics2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IRadioMenuFlyoutItemStatics2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IRadioMenuFlyoutItemStatics2>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->GetAreCheckStatesEnabled(*(void**)(&object), &result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IRadioMenuFlyoutItemStatics2>**)this;
            check_hresult(_winrt_abi_type->GetAreCheckStatesEnabled(*(void**)(&object), &result));
        }
        return result;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IRatingControl<D>::Caption() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IRatingControl>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IRatingControl, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IRatingControl>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Caption(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IRatingControl>**)this;
            check_hresult(_winrt_abi_type->get_Caption(&value));
        }
        return hstring{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IRatingControl<D>::Caption(param::hstring const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IRatingControl>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IRatingControl, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IRatingControl>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_Caption(*(void**)(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IRatingControl>**)this;
            check_hresult(_winrt_abi_type->put_Caption(*(void**)(&value)));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IRatingControl<D>::InitialSetValue() const
    {
        int32_t value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IRatingControl>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IRatingControl, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IRatingControl>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_InitialSetValue(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IRatingControl>**)this;
            check_hresult(_winrt_abi_type->get_InitialSetValue(&value));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IRatingControl<D>::InitialSetValue(int32_t value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IRatingControl>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IRatingControl, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IRatingControl>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_InitialSetValue(value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IRatingControl>**)this;
            check_hresult(_winrt_abi_type->put_InitialSetValue(value));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IRatingControl<D>::IsClearEnabled() const
    {
        bool value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IRatingControl>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IRatingControl, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IRatingControl>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_IsClearEnabled(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IRatingControl>**)this;
            check_hresult(_winrt_abi_type->get_IsClearEnabled(&value));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IRatingControl<D>::IsClearEnabled(bool value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IRatingControl>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IRatingControl, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IRatingControl>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_IsClearEnabled(value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IRatingControl>**)this;
            check_hresult(_winrt_abi_type->put_IsClearEnabled(value));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IRatingControl<D>::IsReadOnly() const
    {
        bool value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IRatingControl>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IRatingControl, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IRatingControl>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_IsReadOnly(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IRatingControl>**)this;
            check_hresult(_winrt_abi_type->get_IsReadOnly(&value));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IRatingControl<D>::IsReadOnly(bool value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IRatingControl>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IRatingControl, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IRatingControl>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_IsReadOnly(value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IRatingControl>**)this;
            check_hresult(_winrt_abi_type->put_IsReadOnly(value));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IRatingControl<D>::MaxRating() const
    {
        int32_t value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IRatingControl>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IRatingControl, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IRatingControl>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_MaxRating(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IRatingControl>**)this;
            check_hresult(_winrt_abi_type->get_MaxRating(&value));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IRatingControl<D>::MaxRating(int32_t value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IRatingControl>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IRatingControl, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IRatingControl>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_MaxRating(value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IRatingControl>**)this;
            check_hresult(_winrt_abi_type->put_MaxRating(value));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IRatingControl<D>::PlaceholderValue() const
    {
        double value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IRatingControl>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IRatingControl, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IRatingControl>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_PlaceholderValue(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IRatingControl>**)this;
            check_hresult(_winrt_abi_type->get_PlaceholderValue(&value));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IRatingControl<D>::PlaceholderValue(double value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IRatingControl>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IRatingControl, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IRatingControl>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_PlaceholderValue(value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IRatingControl>**)this;
            check_hresult(_winrt_abi_type->put_PlaceholderValue(value));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IRatingControl<D>::ItemInfo() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IRatingControl>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IRatingControl, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IRatingControl>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_ItemInfo(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IRatingControl>**)this;
            check_hresult(_winrt_abi_type->get_ItemInfo(&value));
        }
        return winrt::Microsoft::UI::Xaml::Controls::RatingItemInfo{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IRatingControl<D>::ItemInfo(winrt::Microsoft::UI::Xaml::Controls::RatingItemInfo const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IRatingControl>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IRatingControl, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IRatingControl>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_ItemInfo(*(void**)(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IRatingControl>**)this;
            check_hresult(_winrt_abi_type->put_ItemInfo(*(void**)(&value)));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IRatingControl<D>::Value() const
    {
        double value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IRatingControl>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IRatingControl, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IRatingControl>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Value(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IRatingControl>**)this;
            check_hresult(_winrt_abi_type->get_Value(&value));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IRatingControl<D>::Value(double value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IRatingControl>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IRatingControl, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IRatingControl>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_Value(value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IRatingControl>**)this;
            check_hresult(_winrt_abi_type->put_Value(value));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IRatingControl<D>::ValueChanged(winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Xaml::Controls::RatingControl, winrt::Windows::Foundation::IInspectable> const& handler) const
    {
        winrt::event_token token{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IRatingControl>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IRatingControl, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IRatingControl>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->add_ValueChanged(*(void**)(&handler), put_abi(token)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IRatingControl>**)this;
            check_hresult(_winrt_abi_type->add_ValueChanged(*(void**)(&handler), put_abi(token)));
        }
        return token;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IRatingControl<D>::ValueChanged(auto_revoke_t, winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Xaml::Controls::RatingControl, winrt::Windows::Foundation::IInspectable> const& handler) const
    {
        return impl::make_event_revoker<D, ValueChanged_revoker>(this, ValueChanged(handler));
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IRatingControl<D>::ValueChanged(winrt::event_token const& token) const noexcept
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IRatingControl>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IRatingControl, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IRatingControl>**)&_winrt_casted_result;
            _winrt_abi_type->remove_ValueChanged(impl::bind_in(token));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IRatingControl>**)this;
            _winrt_abi_type->remove_ValueChanged(impl::bind_in(token));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IRatingControlFactory<D>::CreateInstance(winrt::Windows::Foundation::IInspectable const& baseInterface, winrt::Windows::Foundation::IInspectable& innerInterface) const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IRatingControlFactory>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IRatingControlFactory, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IRatingControlFactory>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->CreateInstance(*(void**)(&baseInterface), impl::bind_out(innerInterface), &value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IRatingControlFactory>**)this;
            check_hresult(_winrt_abi_type->CreateInstance(*(void**)(&baseInterface), impl::bind_out(innerInterface), &value));
        }
        return winrt::Microsoft::UI::Xaml::Controls::RatingControl{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IRatingControlStatics<D>::CaptionProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IRatingControlStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IRatingControlStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IRatingControlStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_CaptionProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IRatingControlStatics>**)this;
            check_hresult(_winrt_abi_type->get_CaptionProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IRatingControlStatics<D>::InitialSetValueProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IRatingControlStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IRatingControlStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IRatingControlStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_InitialSetValueProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IRatingControlStatics>**)this;
            check_hresult(_winrt_abi_type->get_InitialSetValueProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IRatingControlStatics<D>::IsClearEnabledProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IRatingControlStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IRatingControlStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IRatingControlStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_IsClearEnabledProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IRatingControlStatics>**)this;
            check_hresult(_winrt_abi_type->get_IsClearEnabledProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IRatingControlStatics<D>::IsReadOnlyProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IRatingControlStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IRatingControlStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IRatingControlStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_IsReadOnlyProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IRatingControlStatics>**)this;
            check_hresult(_winrt_abi_type->get_IsReadOnlyProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IRatingControlStatics<D>::MaxRatingProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IRatingControlStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IRatingControlStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IRatingControlStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_MaxRatingProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IRatingControlStatics>**)this;
            check_hresult(_winrt_abi_type->get_MaxRatingProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IRatingControlStatics<D>::PlaceholderValueProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IRatingControlStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IRatingControlStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IRatingControlStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_PlaceholderValueProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IRatingControlStatics>**)this;
            check_hresult(_winrt_abi_type->get_PlaceholderValueProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IRatingControlStatics<D>::ItemInfoProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IRatingControlStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IRatingControlStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IRatingControlStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_ItemInfoProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IRatingControlStatics>**)this;
            check_hresult(_winrt_abi_type->get_ItemInfoProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IRatingControlStatics<D>::ValueProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IRatingControlStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IRatingControlStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IRatingControlStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_ValueProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IRatingControlStatics>**)this;
            check_hresult(_winrt_abi_type->get_ValueProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IRatingItemFontInfo<D>::DisabledGlyph() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IRatingItemFontInfo>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IRatingItemFontInfo, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IRatingItemFontInfo>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_DisabledGlyph(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IRatingItemFontInfo>**)this;
            check_hresult(_winrt_abi_type->get_DisabledGlyph(&value));
        }
        return hstring{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IRatingItemFontInfo<D>::DisabledGlyph(param::hstring const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IRatingItemFontInfo>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IRatingItemFontInfo, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IRatingItemFontInfo>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_DisabledGlyph(*(void**)(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IRatingItemFontInfo>**)this;
            check_hresult(_winrt_abi_type->put_DisabledGlyph(*(void**)(&value)));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IRatingItemFontInfo<D>::Glyph() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IRatingItemFontInfo>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IRatingItemFontInfo, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IRatingItemFontInfo>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Glyph(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IRatingItemFontInfo>**)this;
            check_hresult(_winrt_abi_type->get_Glyph(&value));
        }
        return hstring{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IRatingItemFontInfo<D>::Glyph(param::hstring const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IRatingItemFontInfo>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IRatingItemFontInfo, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IRatingItemFontInfo>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_Glyph(*(void**)(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IRatingItemFontInfo>**)this;
            check_hresult(_winrt_abi_type->put_Glyph(*(void**)(&value)));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IRatingItemFontInfo<D>::PointerOverGlyph() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IRatingItemFontInfo>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IRatingItemFontInfo, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IRatingItemFontInfo>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_PointerOverGlyph(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IRatingItemFontInfo>**)this;
            check_hresult(_winrt_abi_type->get_PointerOverGlyph(&value));
        }
        return hstring{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IRatingItemFontInfo<D>::PointerOverGlyph(param::hstring const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IRatingItemFontInfo>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IRatingItemFontInfo, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IRatingItemFontInfo>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_PointerOverGlyph(*(void**)(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IRatingItemFontInfo>**)this;
            check_hresult(_winrt_abi_type->put_PointerOverGlyph(*(void**)(&value)));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IRatingItemFontInfo<D>::PointerOverPlaceholderGlyph() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IRatingItemFontInfo>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IRatingItemFontInfo, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IRatingItemFontInfo>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_PointerOverPlaceholderGlyph(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IRatingItemFontInfo>**)this;
            check_hresult(_winrt_abi_type->get_PointerOverPlaceholderGlyph(&value));
        }
        return hstring{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IRatingItemFontInfo<D>::PointerOverPlaceholderGlyph(param::hstring const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IRatingItemFontInfo>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IRatingItemFontInfo, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IRatingItemFontInfo>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_PointerOverPlaceholderGlyph(*(void**)(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IRatingItemFontInfo>**)this;
            check_hresult(_winrt_abi_type->put_PointerOverPlaceholderGlyph(*(void**)(&value)));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IRatingItemFontInfo<D>::PlaceholderGlyph() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IRatingItemFontInfo>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IRatingItemFontInfo, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IRatingItemFontInfo>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_PlaceholderGlyph(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IRatingItemFontInfo>**)this;
            check_hresult(_winrt_abi_type->get_PlaceholderGlyph(&value));
        }
        return hstring{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IRatingItemFontInfo<D>::PlaceholderGlyph(param::hstring const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IRatingItemFontInfo>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IRatingItemFontInfo, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IRatingItemFontInfo>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_PlaceholderGlyph(*(void**)(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IRatingItemFontInfo>**)this;
            check_hresult(_winrt_abi_type->put_PlaceholderGlyph(*(void**)(&value)));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IRatingItemFontInfo<D>::UnsetGlyph() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IRatingItemFontInfo>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IRatingItemFontInfo, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IRatingItemFontInfo>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_UnsetGlyph(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IRatingItemFontInfo>**)this;
            check_hresult(_winrt_abi_type->get_UnsetGlyph(&value));
        }
        return hstring{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IRatingItemFontInfo<D>::UnsetGlyph(param::hstring const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IRatingItemFontInfo>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IRatingItemFontInfo, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IRatingItemFontInfo>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_UnsetGlyph(*(void**)(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IRatingItemFontInfo>**)this;
            check_hresult(_winrt_abi_type->put_UnsetGlyph(*(void**)(&value)));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IRatingItemFontInfoFactory<D>::CreateInstance(winrt::Windows::Foundation::IInspectable const& baseInterface, winrt::Windows::Foundation::IInspectable& innerInterface) const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IRatingItemFontInfoFactory>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IRatingItemFontInfoFactory, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IRatingItemFontInfoFactory>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->CreateInstance(*(void**)(&baseInterface), impl::bind_out(innerInterface), &value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IRatingItemFontInfoFactory>**)this;
            check_hresult(_winrt_abi_type->CreateInstance(*(void**)(&baseInterface), impl::bind_out(innerInterface), &value));
        }
        return winrt::Microsoft::UI::Xaml::Controls::RatingItemFontInfo{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IRatingItemFontInfoStatics<D>::DisabledGlyphProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IRatingItemFontInfoStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IRatingItemFontInfoStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IRatingItemFontInfoStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_DisabledGlyphProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IRatingItemFontInfoStatics>**)this;
            check_hresult(_winrt_abi_type->get_DisabledGlyphProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IRatingItemFontInfoStatics<D>::GlyphProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IRatingItemFontInfoStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IRatingItemFontInfoStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IRatingItemFontInfoStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_GlyphProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IRatingItemFontInfoStatics>**)this;
            check_hresult(_winrt_abi_type->get_GlyphProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IRatingItemFontInfoStatics<D>::PlaceholderGlyphProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IRatingItemFontInfoStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IRatingItemFontInfoStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IRatingItemFontInfoStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_PlaceholderGlyphProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IRatingItemFontInfoStatics>**)this;
            check_hresult(_winrt_abi_type->get_PlaceholderGlyphProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IRatingItemFontInfoStatics<D>::PointerOverGlyphProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IRatingItemFontInfoStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IRatingItemFontInfoStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IRatingItemFontInfoStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_PointerOverGlyphProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IRatingItemFontInfoStatics>**)this;
            check_hresult(_winrt_abi_type->get_PointerOverGlyphProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IRatingItemFontInfoStatics<D>::PointerOverPlaceholderGlyphProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IRatingItemFontInfoStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IRatingItemFontInfoStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IRatingItemFontInfoStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_PointerOverPlaceholderGlyphProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IRatingItemFontInfoStatics>**)this;
            check_hresult(_winrt_abi_type->get_PointerOverPlaceholderGlyphProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IRatingItemFontInfoStatics<D>::UnsetGlyphProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IRatingItemFontInfoStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IRatingItemFontInfoStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IRatingItemFontInfoStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_UnsetGlyphProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IRatingItemFontInfoStatics>**)this;
            check_hresult(_winrt_abi_type->get_UnsetGlyphProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IRatingItemImageInfo<D>::DisabledImage() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IRatingItemImageInfo>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IRatingItemImageInfo, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IRatingItemImageInfo>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_DisabledImage(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IRatingItemImageInfo>**)this;
            check_hresult(_winrt_abi_type->get_DisabledImage(&value));
        }
        return winrt::Windows::UI::Xaml::Media::ImageSource{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IRatingItemImageInfo<D>::DisabledImage(winrt::Windows::UI::Xaml::Media::ImageSource const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IRatingItemImageInfo>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IRatingItemImageInfo, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IRatingItemImageInfo>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_DisabledImage(*(void**)(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IRatingItemImageInfo>**)this;
            check_hresult(_winrt_abi_type->put_DisabledImage(*(void**)(&value)));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IRatingItemImageInfo<D>::Image() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IRatingItemImageInfo>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IRatingItemImageInfo, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IRatingItemImageInfo>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Image(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IRatingItemImageInfo>**)this;
            check_hresult(_winrt_abi_type->get_Image(&value));
        }
        return winrt::Windows::UI::Xaml::Media::ImageSource{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IRatingItemImageInfo<D>::Image(winrt::Windows::UI::Xaml::Media::ImageSource const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IRatingItemImageInfo>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IRatingItemImageInfo, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IRatingItemImageInfo>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_Image(*(void**)(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IRatingItemImageInfo>**)this;
            check_hresult(_winrt_abi_type->put_Image(*(void**)(&value)));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IRatingItemImageInfo<D>::PlaceholderImage() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IRatingItemImageInfo>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IRatingItemImageInfo, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IRatingItemImageInfo>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_PlaceholderImage(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IRatingItemImageInfo>**)this;
            check_hresult(_winrt_abi_type->get_PlaceholderImage(&value));
        }
        return winrt::Windows::UI::Xaml::Media::ImageSource{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IRatingItemImageInfo<D>::PlaceholderImage(winrt::Windows::UI::Xaml::Media::ImageSource const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IRatingItemImageInfo>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IRatingItemImageInfo, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IRatingItemImageInfo>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_PlaceholderImage(*(void**)(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IRatingItemImageInfo>**)this;
            check_hresult(_winrt_abi_type->put_PlaceholderImage(*(void**)(&value)));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IRatingItemImageInfo<D>::PointerOverImage() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IRatingItemImageInfo>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IRatingItemImageInfo, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IRatingItemImageInfo>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_PointerOverImage(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IRatingItemImageInfo>**)this;
            check_hresult(_winrt_abi_type->get_PointerOverImage(&value));
        }
        return winrt::Windows::UI::Xaml::Media::ImageSource{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IRatingItemImageInfo<D>::PointerOverImage(winrt::Windows::UI::Xaml::Media::ImageSource const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IRatingItemImageInfo>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IRatingItemImageInfo, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IRatingItemImageInfo>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_PointerOverImage(*(void**)(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IRatingItemImageInfo>**)this;
            check_hresult(_winrt_abi_type->put_PointerOverImage(*(void**)(&value)));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IRatingItemImageInfo<D>::PointerOverPlaceholderImage() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IRatingItemImageInfo>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IRatingItemImageInfo, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IRatingItemImageInfo>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_PointerOverPlaceholderImage(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IRatingItemImageInfo>**)this;
            check_hresult(_winrt_abi_type->get_PointerOverPlaceholderImage(&value));
        }
        return winrt::Windows::UI::Xaml::Media::ImageSource{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IRatingItemImageInfo<D>::PointerOverPlaceholderImage(winrt::Windows::UI::Xaml::Media::ImageSource const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IRatingItemImageInfo>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IRatingItemImageInfo, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IRatingItemImageInfo>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_PointerOverPlaceholderImage(*(void**)(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IRatingItemImageInfo>**)this;
            check_hresult(_winrt_abi_type->put_PointerOverPlaceholderImage(*(void**)(&value)));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IRatingItemImageInfo<D>::UnsetImage() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IRatingItemImageInfo>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IRatingItemImageInfo, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IRatingItemImageInfo>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_UnsetImage(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IRatingItemImageInfo>**)this;
            check_hresult(_winrt_abi_type->get_UnsetImage(&value));
        }
        return winrt::Windows::UI::Xaml::Media::ImageSource{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IRatingItemImageInfo<D>::UnsetImage(winrt::Windows::UI::Xaml::Media::ImageSource const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IRatingItemImageInfo>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IRatingItemImageInfo, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IRatingItemImageInfo>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_UnsetImage(*(void**)(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IRatingItemImageInfo>**)this;
            check_hresult(_winrt_abi_type->put_UnsetImage(*(void**)(&value)));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IRatingItemImageInfoFactory<D>::CreateInstance(winrt::Windows::Foundation::IInspectable const& baseInterface, winrt::Windows::Foundation::IInspectable& innerInterface) const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IRatingItemImageInfoFactory>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IRatingItemImageInfoFactory, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IRatingItemImageInfoFactory>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->CreateInstance(*(void**)(&baseInterface), impl::bind_out(innerInterface), &value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IRatingItemImageInfoFactory>**)this;
            check_hresult(_winrt_abi_type->CreateInstance(*(void**)(&baseInterface), impl::bind_out(innerInterface), &value));
        }
        return winrt::Microsoft::UI::Xaml::Controls::RatingItemImageInfo{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IRatingItemImageInfoStatics<D>::DisabledImageProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IRatingItemImageInfoStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IRatingItemImageInfoStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IRatingItemImageInfoStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_DisabledImageProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IRatingItemImageInfoStatics>**)this;
            check_hresult(_winrt_abi_type->get_DisabledImageProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IRatingItemImageInfoStatics<D>::ImageProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IRatingItemImageInfoStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IRatingItemImageInfoStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IRatingItemImageInfoStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_ImageProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IRatingItemImageInfoStatics>**)this;
            check_hresult(_winrt_abi_type->get_ImageProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IRatingItemImageInfoStatics<D>::PlaceholderImageProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IRatingItemImageInfoStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IRatingItemImageInfoStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IRatingItemImageInfoStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_PlaceholderImageProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IRatingItemImageInfoStatics>**)this;
            check_hresult(_winrt_abi_type->get_PlaceholderImageProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IRatingItemImageInfoStatics<D>::PointerOverImageProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IRatingItemImageInfoStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IRatingItemImageInfoStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IRatingItemImageInfoStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_PointerOverImageProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IRatingItemImageInfoStatics>**)this;
            check_hresult(_winrt_abi_type->get_PointerOverImageProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IRatingItemImageInfoStatics<D>::PointerOverPlaceholderImageProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IRatingItemImageInfoStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IRatingItemImageInfoStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IRatingItemImageInfoStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_PointerOverPlaceholderImageProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IRatingItemImageInfoStatics>**)this;
            check_hresult(_winrt_abi_type->get_PointerOverPlaceholderImageProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IRatingItemImageInfoStatics<D>::UnsetImageProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IRatingItemImageInfoStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IRatingItemImageInfoStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IRatingItemImageInfoStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_UnsetImageProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IRatingItemImageInfoStatics>**)this;
            check_hresult(_winrt_abi_type->get_UnsetImageProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IRatingItemInfoFactory<D>::CreateInstance(winrt::Windows::Foundation::IInspectable const& baseInterface, winrt::Windows::Foundation::IInspectable& innerInterface) const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IRatingItemInfoFactory>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IRatingItemInfoFactory, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IRatingItemInfoFactory>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->CreateInstance(*(void**)(&baseInterface), impl::bind_out(innerInterface), &value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IRatingItemInfoFactory>**)this;
            check_hresult(_winrt_abi_type->CreateInstance(*(void**)(&baseInterface), impl::bind_out(innerInterface), &value));
        }
        return winrt::Microsoft::UI::Xaml::Controls::RatingItemInfo{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IRefreshContainer<D>::Visualizer() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IRefreshContainer>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IRefreshContainer, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IRefreshContainer>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Visualizer(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IRefreshContainer>**)this;
            check_hresult(_winrt_abi_type->get_Visualizer(&value));
        }
        return winrt::Microsoft::UI::Xaml::Controls::RefreshVisualizer{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IRefreshContainer<D>::Visualizer(winrt::Microsoft::UI::Xaml::Controls::RefreshVisualizer const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IRefreshContainer>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IRefreshContainer, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IRefreshContainer>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_Visualizer(*(void**)(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IRefreshContainer>**)this;
            check_hresult(_winrt_abi_type->put_Visualizer(*(void**)(&value)));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IRefreshContainer<D>::PullDirection() const
    {
        winrt::Microsoft::UI::Xaml::Controls::RefreshPullDirection value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IRefreshContainer>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IRefreshContainer, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IRefreshContainer>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_PullDirection(reinterpret_cast<int32_t*>(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IRefreshContainer>**)this;
            check_hresult(_winrt_abi_type->get_PullDirection(reinterpret_cast<int32_t*>(&value)));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IRefreshContainer<D>::PullDirection(winrt::Microsoft::UI::Xaml::Controls::RefreshPullDirection const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IRefreshContainer>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IRefreshContainer, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IRefreshContainer>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_PullDirection(static_cast<int32_t>(value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IRefreshContainer>**)this;
            check_hresult(_winrt_abi_type->put_PullDirection(static_cast<int32_t>(value)));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IRefreshContainer<D>::RefreshRequested(winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Xaml::Controls::RefreshContainer, winrt::Microsoft::UI::Xaml::Controls::RefreshRequestedEventArgs> const& handler) const
    {
        winrt::event_token token{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IRefreshContainer>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IRefreshContainer, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IRefreshContainer>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->add_RefreshRequested(*(void**)(&handler), put_abi(token)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IRefreshContainer>**)this;
            check_hresult(_winrt_abi_type->add_RefreshRequested(*(void**)(&handler), put_abi(token)));
        }
        return token;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IRefreshContainer<D>::RefreshRequested(auto_revoke_t, winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Xaml::Controls::RefreshContainer, winrt::Microsoft::UI::Xaml::Controls::RefreshRequestedEventArgs> const& handler) const
    {
        return impl::make_event_revoker<D, RefreshRequested_revoker>(this, RefreshRequested(handler));
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IRefreshContainer<D>::RefreshRequested(winrt::event_token const& token) const noexcept
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IRefreshContainer>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IRefreshContainer, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IRefreshContainer>**)&_winrt_casted_result;
            _winrt_abi_type->remove_RefreshRequested(impl::bind_in(token));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IRefreshContainer>**)this;
            _winrt_abi_type->remove_RefreshRequested(impl::bind_in(token));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IRefreshContainer<D>::RequestRefresh() const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IRefreshContainer>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IRefreshContainer, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IRefreshContainer>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->RequestRefresh());
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IRefreshContainer>**)this;
            check_hresult(_winrt_abi_type->RequestRefresh());
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IRefreshContainerFactory<D>::CreateInstance(winrt::Windows::Foundation::IInspectable const& baseInterface, winrt::Windows::Foundation::IInspectable& innerInterface) const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IRefreshContainerFactory>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IRefreshContainerFactory, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IRefreshContainerFactory>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->CreateInstance(*(void**)(&baseInterface), impl::bind_out(innerInterface), &value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IRefreshContainerFactory>**)this;
            check_hresult(_winrt_abi_type->CreateInstance(*(void**)(&baseInterface), impl::bind_out(innerInterface), &value));
        }
        return winrt::Microsoft::UI::Xaml::Controls::RefreshContainer{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IRefreshContainerStatics<D>::VisualizerProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IRefreshContainerStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IRefreshContainerStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IRefreshContainerStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_VisualizerProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IRefreshContainerStatics>**)this;
            check_hresult(_winrt_abi_type->get_VisualizerProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IRefreshContainerStatics<D>::PullDirectionProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IRefreshContainerStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IRefreshContainerStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IRefreshContainerStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_PullDirectionProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IRefreshContainerStatics>**)this;
            check_hresult(_winrt_abi_type->get_PullDirectionProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IRefreshInteractionRatioChangedEventArgs<D>::InteractionRatio() const
    {
        double value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IRefreshInteractionRatioChangedEventArgs>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IRefreshInteractionRatioChangedEventArgs, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IRefreshInteractionRatioChangedEventArgs>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_InteractionRatio(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IRefreshInteractionRatioChangedEventArgs>**)this;
            check_hresult(_winrt_abi_type->get_InteractionRatio(&value));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IRefreshRequestedEventArgs<D>::GetDeferral() const
    {
        void* result{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IRefreshRequestedEventArgs>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IRefreshRequestedEventArgs, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IRefreshRequestedEventArgs>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->GetDeferral(&result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IRefreshRequestedEventArgs>**)this;
            check_hresult(_winrt_abi_type->GetDeferral(&result));
        }
        return winrt::Windows::Foundation::Deferral{ result, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IRefreshStateChangedEventArgs<D>::OldState() const
    {
        winrt::Microsoft::UI::Xaml::Controls::RefreshVisualizerState value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IRefreshStateChangedEventArgs>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IRefreshStateChangedEventArgs, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IRefreshStateChangedEventArgs>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_OldState(reinterpret_cast<int32_t*>(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IRefreshStateChangedEventArgs>**)this;
            check_hresult(_winrt_abi_type->get_OldState(reinterpret_cast<int32_t*>(&value)));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IRefreshStateChangedEventArgs<D>::NewState() const
    {
        winrt::Microsoft::UI::Xaml::Controls::RefreshVisualizerState value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IRefreshStateChangedEventArgs>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IRefreshStateChangedEventArgs, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IRefreshStateChangedEventArgs>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_NewState(reinterpret_cast<int32_t*>(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IRefreshStateChangedEventArgs>**)this;
            check_hresult(_winrt_abi_type->get_NewState(reinterpret_cast<int32_t*>(&value)));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IRefreshVisualizer<D>::RequestRefresh() const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IRefreshVisualizer>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IRefreshVisualizer, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IRefreshVisualizer>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->RequestRefresh());
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IRefreshVisualizer>**)this;
            check_hresult(_winrt_abi_type->RequestRefresh());
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IRefreshVisualizer<D>::Orientation() const
    {
        winrt::Microsoft::UI::Xaml::Controls::RefreshVisualizerOrientation value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IRefreshVisualizer>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IRefreshVisualizer, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IRefreshVisualizer>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Orientation(reinterpret_cast<int32_t*>(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IRefreshVisualizer>**)this;
            check_hresult(_winrt_abi_type->get_Orientation(reinterpret_cast<int32_t*>(&value)));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IRefreshVisualizer<D>::Orientation(winrt::Microsoft::UI::Xaml::Controls::RefreshVisualizerOrientation const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IRefreshVisualizer>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IRefreshVisualizer, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IRefreshVisualizer>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_Orientation(static_cast<int32_t>(value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IRefreshVisualizer>**)this;
            check_hresult(_winrt_abi_type->put_Orientation(static_cast<int32_t>(value)));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IRefreshVisualizer<D>::Content() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IRefreshVisualizer>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IRefreshVisualizer, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IRefreshVisualizer>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Content(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IRefreshVisualizer>**)this;
            check_hresult(_winrt_abi_type->get_Content(&value));
        }
        return winrt::Windows::UI::Xaml::UIElement{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IRefreshVisualizer<D>::Content(winrt::Windows::UI::Xaml::UIElement const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IRefreshVisualizer>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IRefreshVisualizer, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IRefreshVisualizer>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_Content(*(void**)(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IRefreshVisualizer>**)this;
            check_hresult(_winrt_abi_type->put_Content(*(void**)(&value)));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IRefreshVisualizer<D>::State() const
    {
        winrt::Microsoft::UI::Xaml::Controls::RefreshVisualizerState value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IRefreshVisualizer>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IRefreshVisualizer, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IRefreshVisualizer>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_State(reinterpret_cast<int32_t*>(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IRefreshVisualizer>**)this;
            check_hresult(_winrt_abi_type->get_State(reinterpret_cast<int32_t*>(&value)));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IRefreshVisualizer<D>::RefreshRequested(winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Xaml::Controls::RefreshVisualizer, winrt::Microsoft::UI::Xaml::Controls::RefreshRequestedEventArgs> const& handler) const
    {
        winrt::event_token token{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IRefreshVisualizer>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IRefreshVisualizer, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IRefreshVisualizer>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->add_RefreshRequested(*(void**)(&handler), put_abi(token)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IRefreshVisualizer>**)this;
            check_hresult(_winrt_abi_type->add_RefreshRequested(*(void**)(&handler), put_abi(token)));
        }
        return token;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IRefreshVisualizer<D>::RefreshRequested(auto_revoke_t, winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Xaml::Controls::RefreshVisualizer, winrt::Microsoft::UI::Xaml::Controls::RefreshRequestedEventArgs> const& handler) const
    {
        return impl::make_event_revoker<D, RefreshRequested_revoker>(this, RefreshRequested(handler));
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IRefreshVisualizer<D>::RefreshRequested(winrt::event_token const& token) const noexcept
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IRefreshVisualizer>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IRefreshVisualizer, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IRefreshVisualizer>**)&_winrt_casted_result;
            _winrt_abi_type->remove_RefreshRequested(impl::bind_in(token));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IRefreshVisualizer>**)this;
            _winrt_abi_type->remove_RefreshRequested(impl::bind_in(token));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IRefreshVisualizer<D>::RefreshStateChanged(winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Xaml::Controls::RefreshVisualizer, winrt::Microsoft::UI::Xaml::Controls::RefreshStateChangedEventArgs> const& handler) const
    {
        winrt::event_token token{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IRefreshVisualizer>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IRefreshVisualizer, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IRefreshVisualizer>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->add_RefreshStateChanged(*(void**)(&handler), put_abi(token)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IRefreshVisualizer>**)this;
            check_hresult(_winrt_abi_type->add_RefreshStateChanged(*(void**)(&handler), put_abi(token)));
        }
        return token;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IRefreshVisualizer<D>::RefreshStateChanged(auto_revoke_t, winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Xaml::Controls::RefreshVisualizer, winrt::Microsoft::UI::Xaml::Controls::RefreshStateChangedEventArgs> const& handler) const
    {
        return impl::make_event_revoker<D, RefreshStateChanged_revoker>(this, RefreshStateChanged(handler));
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IRefreshVisualizer<D>::RefreshStateChanged(winrt::event_token const& token) const noexcept
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IRefreshVisualizer>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IRefreshVisualizer, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IRefreshVisualizer>**)&_winrt_casted_result;
            _winrt_abi_type->remove_RefreshStateChanged(impl::bind_in(token));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IRefreshVisualizer>**)this;
            _winrt_abi_type->remove_RefreshStateChanged(impl::bind_in(token));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IRefreshVisualizerFactory<D>::CreateInstance(winrt::Windows::Foundation::IInspectable const& baseInterface, winrt::Windows::Foundation::IInspectable& innerInterface) const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IRefreshVisualizerFactory>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IRefreshVisualizerFactory, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IRefreshVisualizerFactory>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->CreateInstance(*(void**)(&baseInterface), impl::bind_out(innerInterface), &value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IRefreshVisualizerFactory>**)this;
            check_hresult(_winrt_abi_type->CreateInstance(*(void**)(&baseInterface), impl::bind_out(innerInterface), &value));
        }
        return winrt::Microsoft::UI::Xaml::Controls::RefreshVisualizer{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IRefreshVisualizerStatics<D>::InfoProviderProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IRefreshVisualizerStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IRefreshVisualizerStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IRefreshVisualizerStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_InfoProviderProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IRefreshVisualizerStatics>**)this;
            check_hresult(_winrt_abi_type->get_InfoProviderProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IRefreshVisualizerStatics<D>::OrientationProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IRefreshVisualizerStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IRefreshVisualizerStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IRefreshVisualizerStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_OrientationProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IRefreshVisualizerStatics>**)this;
            check_hresult(_winrt_abi_type->get_OrientationProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IRefreshVisualizerStatics<D>::ContentProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IRefreshVisualizerStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IRefreshVisualizerStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IRefreshVisualizerStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_ContentProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IRefreshVisualizerStatics>**)this;
            check_hresult(_winrt_abi_type->get_ContentProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IRefreshVisualizerStatics<D>::StateProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IRefreshVisualizerStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IRefreshVisualizerStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IRefreshVisualizerStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_StateProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IRefreshVisualizerStatics>**)this;
            check_hresult(_winrt_abi_type->get_StateProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IRevealListViewItemPresenterFactory<D>::CreateInstance(winrt::Windows::Foundation::IInspectable const& baseInterface, winrt::Windows::Foundation::IInspectable& innerInterface) const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IRevealListViewItemPresenterFactory>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IRevealListViewItemPresenterFactory, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IRevealListViewItemPresenterFactory>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->CreateInstance(*(void**)(&baseInterface), impl::bind_out(innerInterface), &value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IRevealListViewItemPresenterFactory>**)this;
            check_hresult(_winrt_abi_type->CreateInstance(*(void**)(&baseInterface), impl::bind_out(innerInterface), &value));
        }
        return winrt::Microsoft::UI::Xaml::Controls::RevealListViewItemPresenter{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ISplitButton<D>::Flyout() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ISplitButton>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ISplitButton, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ISplitButton>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Flyout(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ISplitButton>**)this;
            check_hresult(_winrt_abi_type->get_Flyout(&value));
        }
        return winrt::Windows::UI::Xaml::Controls::Primitives::FlyoutBase{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ISplitButton<D>::Flyout(winrt::Windows::UI::Xaml::Controls::Primitives::FlyoutBase const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ISplitButton>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ISplitButton, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ISplitButton>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_Flyout(*(void**)(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ISplitButton>**)this;
            check_hresult(_winrt_abi_type->put_Flyout(*(void**)(&value)));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ISplitButton<D>::Command() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ISplitButton>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ISplitButton, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ISplitButton>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Command(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ISplitButton>**)this;
            check_hresult(_winrt_abi_type->get_Command(&value));
        }
        return winrt::Windows::UI::Xaml::Input::ICommand{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ISplitButton<D>::Command(winrt::Windows::UI::Xaml::Input::ICommand const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ISplitButton>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ISplitButton, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ISplitButton>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_Command(*(void**)(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ISplitButton>**)this;
            check_hresult(_winrt_abi_type->put_Command(*(void**)(&value)));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ISplitButton<D>::CommandParameter() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ISplitButton>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ISplitButton, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ISplitButton>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_CommandParameter(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ISplitButton>**)this;
            check_hresult(_winrt_abi_type->get_CommandParameter(&value));
        }
        return winrt::Windows::Foundation::IInspectable{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ISplitButton<D>::CommandParameter(winrt::Windows::Foundation::IInspectable const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ISplitButton>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ISplitButton, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ISplitButton>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_CommandParameter(*(void**)(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ISplitButton>**)this;
            check_hresult(_winrt_abi_type->put_CommandParameter(*(void**)(&value)));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ISplitButton<D>::Click(winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Xaml::Controls::SplitButton, winrt::Microsoft::UI::Xaml::Controls::SplitButtonClickEventArgs> const& handler) const
    {
        winrt::event_token token{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ISplitButton>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ISplitButton, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ISplitButton>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->add_Click(*(void**)(&handler), put_abi(token)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ISplitButton>**)this;
            check_hresult(_winrt_abi_type->add_Click(*(void**)(&handler), put_abi(token)));
        }
        return token;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ISplitButton<D>::Click(auto_revoke_t, winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Xaml::Controls::SplitButton, winrt::Microsoft::UI::Xaml::Controls::SplitButtonClickEventArgs> const& handler) const
    {
        return impl::make_event_revoker<D, Click_revoker>(this, Click(handler));
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ISplitButton<D>::Click(winrt::event_token const& token) const noexcept
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ISplitButton>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ISplitButton, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ISplitButton>**)&_winrt_casted_result;
            _winrt_abi_type->remove_Click(impl::bind_in(token));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ISplitButton>**)this;
            _winrt_abi_type->remove_Click(impl::bind_in(token));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ISplitButtonFactory<D>::CreateInstance(winrt::Windows::Foundation::IInspectable const& baseInterface, winrt::Windows::Foundation::IInspectable& innerInterface) const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ISplitButtonFactory>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ISplitButtonFactory, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ISplitButtonFactory>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->CreateInstance(*(void**)(&baseInterface), impl::bind_out(innerInterface), &value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ISplitButtonFactory>**)this;
            check_hresult(_winrt_abi_type->CreateInstance(*(void**)(&baseInterface), impl::bind_out(innerInterface), &value));
        }
        return winrt::Microsoft::UI::Xaml::Controls::SplitButton{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ISplitButtonStatics<D>::FlyoutProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ISplitButtonStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ISplitButtonStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ISplitButtonStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_FlyoutProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ISplitButtonStatics>**)this;
            check_hresult(_winrt_abi_type->get_FlyoutProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ISplitButtonStatics<D>::CommandProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ISplitButtonStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ISplitButtonStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ISplitButtonStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_CommandProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ISplitButtonStatics>**)this;
            check_hresult(_winrt_abi_type->get_CommandProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ISplitButtonStatics<D>::CommandParameterProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ISplitButtonStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ISplitButtonStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ISplitButtonStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_CommandParameterProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ISplitButtonStatics>**)this;
            check_hresult(_winrt_abi_type->get_CommandParameterProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IStackLayout<D>::Orientation() const
    {
        winrt::Windows::UI::Xaml::Controls::Orientation value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IStackLayout>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IStackLayout, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IStackLayout>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Orientation(reinterpret_cast<int32_t*>(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IStackLayout>**)this;
            check_hresult(_winrt_abi_type->get_Orientation(reinterpret_cast<int32_t*>(&value)));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IStackLayout<D>::Orientation(winrt::Windows::UI::Xaml::Controls::Orientation const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IStackLayout>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IStackLayout, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IStackLayout>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_Orientation(static_cast<int32_t>(value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IStackLayout>**)this;
            check_hresult(_winrt_abi_type->put_Orientation(static_cast<int32_t>(value)));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IStackLayout<D>::Spacing() const
    {
        double value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IStackLayout>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IStackLayout, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IStackLayout>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Spacing(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IStackLayout>**)this;
            check_hresult(_winrt_abi_type->get_Spacing(&value));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IStackLayout<D>::Spacing(double value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IStackLayout>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IStackLayout, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IStackLayout>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_Spacing(value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IStackLayout>**)this;
            check_hresult(_winrt_abi_type->put_Spacing(value));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IStackLayoutFactory<D>::CreateInstance(winrt::Windows::Foundation::IInspectable const& baseInterface, winrt::Windows::Foundation::IInspectable& innerInterface) const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IStackLayoutFactory>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IStackLayoutFactory, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IStackLayoutFactory>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->CreateInstance(*(void**)(&baseInterface), impl::bind_out(innerInterface), &value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IStackLayoutFactory>**)this;
            check_hresult(_winrt_abi_type->CreateInstance(*(void**)(&baseInterface), impl::bind_out(innerInterface), &value));
        }
        return winrt::Microsoft::UI::Xaml::Controls::StackLayout{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IStackLayoutStatics<D>::OrientationProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IStackLayoutStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IStackLayoutStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IStackLayoutStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_OrientationProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IStackLayoutStatics>**)this;
            check_hresult(_winrt_abi_type->get_OrientationProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IStackLayoutStatics<D>::SpacingProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IStackLayoutStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IStackLayoutStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IStackLayoutStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_SpacingProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IStackLayoutStatics>**)this;
            check_hresult(_winrt_abi_type->get_SpacingProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ISwipeControl<D>::LeftItems() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ISwipeControl>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ISwipeControl, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ISwipeControl>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_LeftItems(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ISwipeControl>**)this;
            check_hresult(_winrt_abi_type->get_LeftItems(&value));
        }
        return winrt::Microsoft::UI::Xaml::Controls::SwipeItems{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ISwipeControl<D>::LeftItems(winrt::Microsoft::UI::Xaml::Controls::SwipeItems const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ISwipeControl>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ISwipeControl, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ISwipeControl>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_LeftItems(*(void**)(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ISwipeControl>**)this;
            check_hresult(_winrt_abi_type->put_LeftItems(*(void**)(&value)));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ISwipeControl<D>::RightItems() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ISwipeControl>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ISwipeControl, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ISwipeControl>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_RightItems(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ISwipeControl>**)this;
            check_hresult(_winrt_abi_type->get_RightItems(&value));
        }
        return winrt::Microsoft::UI::Xaml::Controls::SwipeItems{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ISwipeControl<D>::RightItems(winrt::Microsoft::UI::Xaml::Controls::SwipeItems const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ISwipeControl>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ISwipeControl, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ISwipeControl>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_RightItems(*(void**)(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ISwipeControl>**)this;
            check_hresult(_winrt_abi_type->put_RightItems(*(void**)(&value)));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ISwipeControl<D>::TopItems() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ISwipeControl>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ISwipeControl, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ISwipeControl>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_TopItems(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ISwipeControl>**)this;
            check_hresult(_winrt_abi_type->get_TopItems(&value));
        }
        return winrt::Microsoft::UI::Xaml::Controls::SwipeItems{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ISwipeControl<D>::TopItems(winrt::Microsoft::UI::Xaml::Controls::SwipeItems const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ISwipeControl>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ISwipeControl, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ISwipeControl>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_TopItems(*(void**)(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ISwipeControl>**)this;
            check_hresult(_winrt_abi_type->put_TopItems(*(void**)(&value)));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ISwipeControl<D>::BottomItems() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ISwipeControl>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ISwipeControl, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ISwipeControl>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_BottomItems(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ISwipeControl>**)this;
            check_hresult(_winrt_abi_type->get_BottomItems(&value));
        }
        return winrt::Microsoft::UI::Xaml::Controls::SwipeItems{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ISwipeControl<D>::BottomItems(winrt::Microsoft::UI::Xaml::Controls::SwipeItems const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ISwipeControl>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ISwipeControl, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ISwipeControl>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_BottomItems(*(void**)(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ISwipeControl>**)this;
            check_hresult(_winrt_abi_type->put_BottomItems(*(void**)(&value)));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ISwipeControl<D>::Close() const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ISwipeControl>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ISwipeControl, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ISwipeControl>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->Close());
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ISwipeControl>**)this;
            check_hresult(_winrt_abi_type->Close());
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ISwipeControlFactory<D>::CreateInstance(winrt::Windows::Foundation::IInspectable const& baseInterface, winrt::Windows::Foundation::IInspectable& innerInterface) const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ISwipeControlFactory>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ISwipeControlFactory, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ISwipeControlFactory>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->CreateInstance(*(void**)(&baseInterface), impl::bind_out(innerInterface), &value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ISwipeControlFactory>**)this;
            check_hresult(_winrt_abi_type->CreateInstance(*(void**)(&baseInterface), impl::bind_out(innerInterface), &value));
        }
        return winrt::Microsoft::UI::Xaml::Controls::SwipeControl{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ISwipeControlStatics<D>::LeftItemsProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ISwipeControlStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ISwipeControlStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ISwipeControlStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_LeftItemsProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ISwipeControlStatics>**)this;
            check_hresult(_winrt_abi_type->get_LeftItemsProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ISwipeControlStatics<D>::RightItemsProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ISwipeControlStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ISwipeControlStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ISwipeControlStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_RightItemsProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ISwipeControlStatics>**)this;
            check_hresult(_winrt_abi_type->get_RightItemsProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ISwipeControlStatics<D>::TopItemsProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ISwipeControlStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ISwipeControlStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ISwipeControlStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_TopItemsProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ISwipeControlStatics>**)this;
            check_hresult(_winrt_abi_type->get_TopItemsProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ISwipeControlStatics<D>::BottomItemsProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ISwipeControlStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ISwipeControlStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ISwipeControlStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_BottomItemsProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ISwipeControlStatics>**)this;
            check_hresult(_winrt_abi_type->get_BottomItemsProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ISwipeItem<D>::Text() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ISwipeItem>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ISwipeItem, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ISwipeItem>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Text(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ISwipeItem>**)this;
            check_hresult(_winrt_abi_type->get_Text(&value));
        }
        return hstring{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ISwipeItem<D>::Text(param::hstring const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ISwipeItem>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ISwipeItem, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ISwipeItem>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_Text(*(void**)(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ISwipeItem>**)this;
            check_hresult(_winrt_abi_type->put_Text(*(void**)(&value)));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ISwipeItem<D>::IconSource() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ISwipeItem>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ISwipeItem, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ISwipeItem>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_IconSource(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ISwipeItem>**)this;
            check_hresult(_winrt_abi_type->get_IconSource(&value));
        }
        return winrt::Microsoft::UI::Xaml::Controls::IconSource{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ISwipeItem<D>::IconSource(winrt::Microsoft::UI::Xaml::Controls::IconSource const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ISwipeItem>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ISwipeItem, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ISwipeItem>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_IconSource(*(void**)(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ISwipeItem>**)this;
            check_hresult(_winrt_abi_type->put_IconSource(*(void**)(&value)));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ISwipeItem<D>::Background() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ISwipeItem>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ISwipeItem, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ISwipeItem>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Background(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ISwipeItem>**)this;
            check_hresult(_winrt_abi_type->get_Background(&value));
        }
        return winrt::Windows::UI::Xaml::Media::Brush{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ISwipeItem<D>::Background(winrt::Windows::UI::Xaml::Media::Brush const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ISwipeItem>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ISwipeItem, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ISwipeItem>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_Background(*(void**)(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ISwipeItem>**)this;
            check_hresult(_winrt_abi_type->put_Background(*(void**)(&value)));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ISwipeItem<D>::Foreground() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ISwipeItem>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ISwipeItem, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ISwipeItem>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Foreground(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ISwipeItem>**)this;
            check_hresult(_winrt_abi_type->get_Foreground(&value));
        }
        return winrt::Windows::UI::Xaml::Media::Brush{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ISwipeItem<D>::Foreground(winrt::Windows::UI::Xaml::Media::Brush const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ISwipeItem>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ISwipeItem, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ISwipeItem>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_Foreground(*(void**)(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ISwipeItem>**)this;
            check_hresult(_winrt_abi_type->put_Foreground(*(void**)(&value)));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ISwipeItem<D>::Command() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ISwipeItem>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ISwipeItem, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ISwipeItem>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Command(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ISwipeItem>**)this;
            check_hresult(_winrt_abi_type->get_Command(&value));
        }
        return winrt::Windows::UI::Xaml::Input::ICommand{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ISwipeItem<D>::Command(winrt::Windows::UI::Xaml::Input::ICommand const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ISwipeItem>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ISwipeItem, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ISwipeItem>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_Command(*(void**)(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ISwipeItem>**)this;
            check_hresult(_winrt_abi_type->put_Command(*(void**)(&value)));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ISwipeItem<D>::CommandParameter() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ISwipeItem>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ISwipeItem, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ISwipeItem>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_CommandParameter(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ISwipeItem>**)this;
            check_hresult(_winrt_abi_type->get_CommandParameter(&value));
        }
        return winrt::Windows::Foundation::IInspectable{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ISwipeItem<D>::CommandParameter(winrt::Windows::Foundation::IInspectable const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ISwipeItem>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ISwipeItem, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ISwipeItem>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_CommandParameter(*(void**)(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ISwipeItem>**)this;
            check_hresult(_winrt_abi_type->put_CommandParameter(*(void**)(&value)));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ISwipeItem<D>::BehaviorOnInvoked() const
    {
        winrt::Microsoft::UI::Xaml::Controls::SwipeBehaviorOnInvoked value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ISwipeItem>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ISwipeItem, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ISwipeItem>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_BehaviorOnInvoked(reinterpret_cast<int32_t*>(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ISwipeItem>**)this;
            check_hresult(_winrt_abi_type->get_BehaviorOnInvoked(reinterpret_cast<int32_t*>(&value)));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ISwipeItem<D>::BehaviorOnInvoked(winrt::Microsoft::UI::Xaml::Controls::SwipeBehaviorOnInvoked const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ISwipeItem>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ISwipeItem, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ISwipeItem>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_BehaviorOnInvoked(static_cast<int32_t>(value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ISwipeItem>**)this;
            check_hresult(_winrt_abi_type->put_BehaviorOnInvoked(static_cast<int32_t>(value)));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ISwipeItem<D>::Invoked(winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Xaml::Controls::SwipeItem, winrt::Microsoft::UI::Xaml::Controls::SwipeItemInvokedEventArgs> const& handler) const
    {
        winrt::event_token token{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ISwipeItem>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ISwipeItem, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ISwipeItem>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->add_Invoked(*(void**)(&handler), put_abi(token)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ISwipeItem>**)this;
            check_hresult(_winrt_abi_type->add_Invoked(*(void**)(&handler), put_abi(token)));
        }
        return token;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ISwipeItem<D>::Invoked(auto_revoke_t, winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Xaml::Controls::SwipeItem, winrt::Microsoft::UI::Xaml::Controls::SwipeItemInvokedEventArgs> const& handler) const
    {
        return impl::make_event_revoker<D, Invoked_revoker>(this, Invoked(handler));
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ISwipeItem<D>::Invoked(winrt::event_token const& token) const noexcept
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ISwipeItem>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ISwipeItem, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ISwipeItem>**)&_winrt_casted_result;
            _winrt_abi_type->remove_Invoked(impl::bind_in(token));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ISwipeItem>**)this;
            _winrt_abi_type->remove_Invoked(impl::bind_in(token));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ISwipeItemFactory<D>::CreateInstance(winrt::Windows::Foundation::IInspectable const& baseInterface, winrt::Windows::Foundation::IInspectable& innerInterface) const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ISwipeItemFactory>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ISwipeItemFactory, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ISwipeItemFactory>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->CreateInstance(*(void**)(&baseInterface), impl::bind_out(innerInterface), &value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ISwipeItemFactory>**)this;
            check_hresult(_winrt_abi_type->CreateInstance(*(void**)(&baseInterface), impl::bind_out(innerInterface), &value));
        }
        return winrt::Microsoft::UI::Xaml::Controls::SwipeItem{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ISwipeItemInvokedEventArgs<D>::SwipeControl() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ISwipeItemInvokedEventArgs>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ISwipeItemInvokedEventArgs, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ISwipeItemInvokedEventArgs>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_SwipeControl(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ISwipeItemInvokedEventArgs>**)this;
            check_hresult(_winrt_abi_type->get_SwipeControl(&value));
        }
        return winrt::Microsoft::UI::Xaml::Controls::SwipeControl{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ISwipeItemStatics<D>::IconSourceProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ISwipeItemStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ISwipeItemStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ISwipeItemStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_IconSourceProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ISwipeItemStatics>**)this;
            check_hresult(_winrt_abi_type->get_IconSourceProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ISwipeItemStatics<D>::TextProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ISwipeItemStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ISwipeItemStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ISwipeItemStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_TextProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ISwipeItemStatics>**)this;
            check_hresult(_winrt_abi_type->get_TextProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ISwipeItemStatics<D>::BackgroundProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ISwipeItemStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ISwipeItemStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ISwipeItemStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_BackgroundProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ISwipeItemStatics>**)this;
            check_hresult(_winrt_abi_type->get_BackgroundProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ISwipeItemStatics<D>::ForegroundProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ISwipeItemStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ISwipeItemStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ISwipeItemStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_ForegroundProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ISwipeItemStatics>**)this;
            check_hresult(_winrt_abi_type->get_ForegroundProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ISwipeItemStatics<D>::CommandProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ISwipeItemStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ISwipeItemStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ISwipeItemStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_CommandProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ISwipeItemStatics>**)this;
            check_hresult(_winrt_abi_type->get_CommandProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ISwipeItemStatics<D>::CommandParameterProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ISwipeItemStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ISwipeItemStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ISwipeItemStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_CommandParameterProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ISwipeItemStatics>**)this;
            check_hresult(_winrt_abi_type->get_CommandParameterProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ISwipeItemStatics<D>::BehaviorOnInvokedProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ISwipeItemStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ISwipeItemStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ISwipeItemStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_BehaviorOnInvokedProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ISwipeItemStatics>**)this;
            check_hresult(_winrt_abi_type->get_BehaviorOnInvokedProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ISwipeItems<D>::Mode() const
    {
        winrt::Microsoft::UI::Xaml::Controls::SwipeMode value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ISwipeItems>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ISwipeItems, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ISwipeItems>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Mode(reinterpret_cast<int32_t*>(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ISwipeItems>**)this;
            check_hresult(_winrt_abi_type->get_Mode(reinterpret_cast<int32_t*>(&value)));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ISwipeItems<D>::Mode(winrt::Microsoft::UI::Xaml::Controls::SwipeMode const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ISwipeItems>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ISwipeItems, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ISwipeItems>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_Mode(static_cast<int32_t>(value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ISwipeItems>**)this;
            check_hresult(_winrt_abi_type->put_Mode(static_cast<int32_t>(value)));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ISwipeItemsFactory<D>::CreateInstance(winrt::Windows::Foundation::IInspectable const& baseInterface, winrt::Windows::Foundation::IInspectable& innerInterface) const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ISwipeItemsFactory>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ISwipeItemsFactory, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ISwipeItemsFactory>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->CreateInstance(*(void**)(&baseInterface), impl::bind_out(innerInterface), &value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ISwipeItemsFactory>**)this;
            check_hresult(_winrt_abi_type->CreateInstance(*(void**)(&baseInterface), impl::bind_out(innerInterface), &value));
        }
        return winrt::Microsoft::UI::Xaml::Controls::SwipeItems{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ISwipeItemsStatics<D>::ModeProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ISwipeItemsStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ISwipeItemsStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ISwipeItemsStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_ModeProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ISwipeItemsStatics>**)this;
            check_hresult(_winrt_abi_type->get_ModeProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ISymbolIconSource<D>::Symbol() const
    {
        winrt::Windows::UI::Xaml::Controls::Symbol value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ISymbolIconSource>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ISymbolIconSource, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ISymbolIconSource>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Symbol(reinterpret_cast<int32_t*>(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ISymbolIconSource>**)this;
            check_hresult(_winrt_abi_type->get_Symbol(reinterpret_cast<int32_t*>(&value)));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ISymbolIconSource<D>::Symbol(winrt::Windows::UI::Xaml::Controls::Symbol const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ISymbolIconSource>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ISymbolIconSource, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ISymbolIconSource>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_Symbol(static_cast<int32_t>(value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ISymbolIconSource>**)this;
            check_hresult(_winrt_abi_type->put_Symbol(static_cast<int32_t>(value)));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ISymbolIconSourceFactory<D>::CreateInstance(winrt::Windows::Foundation::IInspectable const& baseInterface, winrt::Windows::Foundation::IInspectable& innerInterface) const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ISymbolIconSourceFactory>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ISymbolIconSourceFactory, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ISymbolIconSourceFactory>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->CreateInstance(*(void**)(&baseInterface), impl::bind_out(innerInterface), &value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ISymbolIconSourceFactory>**)this;
            check_hresult(_winrt_abi_type->CreateInstance(*(void**)(&baseInterface), impl::bind_out(innerInterface), &value));
        }
        return winrt::Microsoft::UI::Xaml::Controls::SymbolIconSource{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ISymbolIconSourceStatics<D>::SymbolProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ISymbolIconSourceStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ISymbolIconSourceStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ISymbolIconSourceStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_SymbolProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ISymbolIconSourceStatics>**)this;
            check_hresult(_winrt_abi_type->get_SymbolProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITabView<D>::TabWidthMode() const
    {
        winrt::Microsoft::UI::Xaml::Controls::TabViewWidthMode value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITabView>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITabView, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITabView>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_TabWidthMode(reinterpret_cast<int32_t*>(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITabView>**)this;
            check_hresult(_winrt_abi_type->get_TabWidthMode(reinterpret_cast<int32_t*>(&value)));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITabView<D>::TabWidthMode(winrt::Microsoft::UI::Xaml::Controls::TabViewWidthMode const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITabView>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITabView, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITabView>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_TabWidthMode(static_cast<int32_t>(value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITabView>**)this;
            check_hresult(_winrt_abi_type->put_TabWidthMode(static_cast<int32_t>(value)));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITabView<D>::CloseButtonOverlayMode() const
    {
        winrt::Microsoft::UI::Xaml::Controls::TabViewCloseButtonOverlayMode value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITabView>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITabView, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITabView>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_CloseButtonOverlayMode(reinterpret_cast<int32_t*>(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITabView>**)this;
            check_hresult(_winrt_abi_type->get_CloseButtonOverlayMode(reinterpret_cast<int32_t*>(&value)));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITabView<D>::CloseButtonOverlayMode(winrt::Microsoft::UI::Xaml::Controls::TabViewCloseButtonOverlayMode const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITabView>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITabView, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITabView>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_CloseButtonOverlayMode(static_cast<int32_t>(value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITabView>**)this;
            check_hresult(_winrt_abi_type->put_CloseButtonOverlayMode(static_cast<int32_t>(value)));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITabView<D>::TabStripHeader() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITabView>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITabView, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITabView>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_TabStripHeader(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITabView>**)this;
            check_hresult(_winrt_abi_type->get_TabStripHeader(&value));
        }
        return winrt::Windows::Foundation::IInspectable{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITabView<D>::TabStripHeader(winrt::Windows::Foundation::IInspectable const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITabView>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITabView, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITabView>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_TabStripHeader(*(void**)(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITabView>**)this;
            check_hresult(_winrt_abi_type->put_TabStripHeader(*(void**)(&value)));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITabView<D>::TabStripHeaderTemplate() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITabView>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITabView, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITabView>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_TabStripHeaderTemplate(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITabView>**)this;
            check_hresult(_winrt_abi_type->get_TabStripHeaderTemplate(&value));
        }
        return winrt::Windows::UI::Xaml::DataTemplate{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITabView<D>::TabStripHeaderTemplate(winrt::Windows::UI::Xaml::DataTemplate const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITabView>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITabView, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITabView>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_TabStripHeaderTemplate(*(void**)(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITabView>**)this;
            check_hresult(_winrt_abi_type->put_TabStripHeaderTemplate(*(void**)(&value)));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITabView<D>::TabStripFooter() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITabView>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITabView, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITabView>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_TabStripFooter(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITabView>**)this;
            check_hresult(_winrt_abi_type->get_TabStripFooter(&value));
        }
        return winrt::Windows::Foundation::IInspectable{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITabView<D>::TabStripFooter(winrt::Windows::Foundation::IInspectable const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITabView>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITabView, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITabView>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_TabStripFooter(*(void**)(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITabView>**)this;
            check_hresult(_winrt_abi_type->put_TabStripFooter(*(void**)(&value)));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITabView<D>::TabStripFooterTemplate() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITabView>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITabView, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITabView>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_TabStripFooterTemplate(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITabView>**)this;
            check_hresult(_winrt_abi_type->get_TabStripFooterTemplate(&value));
        }
        return winrt::Windows::UI::Xaml::DataTemplate{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITabView<D>::TabStripFooterTemplate(winrt::Windows::UI::Xaml::DataTemplate const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITabView>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITabView, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITabView>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_TabStripFooterTemplate(*(void**)(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITabView>**)this;
            check_hresult(_winrt_abi_type->put_TabStripFooterTemplate(*(void**)(&value)));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITabView<D>::IsAddTabButtonVisible() const
    {
        bool value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITabView>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITabView, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITabView>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_IsAddTabButtonVisible(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITabView>**)this;
            check_hresult(_winrt_abi_type->get_IsAddTabButtonVisible(&value));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITabView<D>::IsAddTabButtonVisible(bool value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITabView>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITabView, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITabView>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_IsAddTabButtonVisible(value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITabView>**)this;
            check_hresult(_winrt_abi_type->put_IsAddTabButtonVisible(value));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITabView<D>::AddTabButtonCommand() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITabView>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITabView, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITabView>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_AddTabButtonCommand(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITabView>**)this;
            check_hresult(_winrt_abi_type->get_AddTabButtonCommand(&value));
        }
        return winrt::Windows::UI::Xaml::Input::ICommand{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITabView<D>::AddTabButtonCommand(winrt::Windows::UI::Xaml::Input::ICommand const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITabView>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITabView, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITabView>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_AddTabButtonCommand(*(void**)(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITabView>**)this;
            check_hresult(_winrt_abi_type->put_AddTabButtonCommand(*(void**)(&value)));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITabView<D>::AddTabButtonCommandParameter() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITabView>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITabView, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITabView>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_AddTabButtonCommandParameter(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITabView>**)this;
            check_hresult(_winrt_abi_type->get_AddTabButtonCommandParameter(&value));
        }
        return winrt::Windows::Foundation::IInspectable{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITabView<D>::AddTabButtonCommandParameter(winrt::Windows::Foundation::IInspectable const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITabView>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITabView, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITabView>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_AddTabButtonCommandParameter(*(void**)(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITabView>**)this;
            check_hresult(_winrt_abi_type->put_AddTabButtonCommandParameter(*(void**)(&value)));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITabView<D>::TabCloseRequested(winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Xaml::Controls::TabView, winrt::Microsoft::UI::Xaml::Controls::TabViewTabCloseRequestedEventArgs> const& handler) const
    {
        winrt::event_token token{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITabView>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITabView, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITabView>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->add_TabCloseRequested(*(void**)(&handler), put_abi(token)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITabView>**)this;
            check_hresult(_winrt_abi_type->add_TabCloseRequested(*(void**)(&handler), put_abi(token)));
        }
        return token;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITabView<D>::TabCloseRequested(auto_revoke_t, winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Xaml::Controls::TabView, winrt::Microsoft::UI::Xaml::Controls::TabViewTabCloseRequestedEventArgs> const& handler) const
    {
        return impl::make_event_revoker<D, TabCloseRequested_revoker>(this, TabCloseRequested(handler));
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITabView<D>::TabCloseRequested(winrt::event_token const& token) const noexcept
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITabView>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITabView, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITabView>**)&_winrt_casted_result;
            _winrt_abi_type->remove_TabCloseRequested(impl::bind_in(token));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITabView>**)this;
            _winrt_abi_type->remove_TabCloseRequested(impl::bind_in(token));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITabView<D>::TabDroppedOutside(winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Xaml::Controls::TabView, winrt::Microsoft::UI::Xaml::Controls::TabViewTabDroppedOutsideEventArgs> const& handler) const
    {
        winrt::event_token token{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITabView>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITabView, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITabView>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->add_TabDroppedOutside(*(void**)(&handler), put_abi(token)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITabView>**)this;
            check_hresult(_winrt_abi_type->add_TabDroppedOutside(*(void**)(&handler), put_abi(token)));
        }
        return token;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITabView<D>::TabDroppedOutside(auto_revoke_t, winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Xaml::Controls::TabView, winrt::Microsoft::UI::Xaml::Controls::TabViewTabDroppedOutsideEventArgs> const& handler) const
    {
        return impl::make_event_revoker<D, TabDroppedOutside_revoker>(this, TabDroppedOutside(handler));
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITabView<D>::TabDroppedOutside(winrt::event_token const& token) const noexcept
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITabView>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITabView, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITabView>**)&_winrt_casted_result;
            _winrt_abi_type->remove_TabDroppedOutside(impl::bind_in(token));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITabView>**)this;
            _winrt_abi_type->remove_TabDroppedOutside(impl::bind_in(token));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITabView<D>::AddTabButtonClick(winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Xaml::Controls::TabView, winrt::Windows::Foundation::IInspectable> const& handler) const
    {
        winrt::event_token token{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITabView>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITabView, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITabView>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->add_AddTabButtonClick(*(void**)(&handler), put_abi(token)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITabView>**)this;
            check_hresult(_winrt_abi_type->add_AddTabButtonClick(*(void**)(&handler), put_abi(token)));
        }
        return token;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITabView<D>::AddTabButtonClick(auto_revoke_t, winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Xaml::Controls::TabView, winrt::Windows::Foundation::IInspectable> const& handler) const
    {
        return impl::make_event_revoker<D, AddTabButtonClick_revoker>(this, AddTabButtonClick(handler));
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITabView<D>::AddTabButtonClick(winrt::event_token const& token) const noexcept
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITabView>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITabView, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITabView>**)&_winrt_casted_result;
            _winrt_abi_type->remove_AddTabButtonClick(impl::bind_in(token));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITabView>**)this;
            _winrt_abi_type->remove_AddTabButtonClick(impl::bind_in(token));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITabView<D>::TabItemsChanged(winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Xaml::Controls::TabView, winrt::Windows::Foundation::Collections::IVectorChangedEventArgs> const& handler) const
    {
        winrt::event_token token{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITabView>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITabView, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITabView>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->add_TabItemsChanged(*(void**)(&handler), put_abi(token)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITabView>**)this;
            check_hresult(_winrt_abi_type->add_TabItemsChanged(*(void**)(&handler), put_abi(token)));
        }
        return token;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITabView<D>::TabItemsChanged(auto_revoke_t, winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Xaml::Controls::TabView, winrt::Windows::Foundation::Collections::IVectorChangedEventArgs> const& handler) const
    {
        return impl::make_event_revoker<D, TabItemsChanged_revoker>(this, TabItemsChanged(handler));
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITabView<D>::TabItemsChanged(winrt::event_token const& token) const noexcept
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITabView>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITabView, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITabView>**)&_winrt_casted_result;
            _winrt_abi_type->remove_TabItemsChanged(impl::bind_in(token));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITabView>**)this;
            _winrt_abi_type->remove_TabItemsChanged(impl::bind_in(token));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITabView<D>::TabItemsSource() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITabView>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITabView, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITabView>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_TabItemsSource(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITabView>**)this;
            check_hresult(_winrt_abi_type->get_TabItemsSource(&value));
        }
        return winrt::Windows::Foundation::IInspectable{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITabView<D>::TabItemsSource(winrt::Windows::Foundation::IInspectable const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITabView>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITabView, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITabView>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_TabItemsSource(*(void**)(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITabView>**)this;
            check_hresult(_winrt_abi_type->put_TabItemsSource(*(void**)(&value)));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITabView<D>::TabItems() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITabView>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITabView, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITabView>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_TabItems(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITabView>**)this;
            check_hresult(_winrt_abi_type->get_TabItems(&value));
        }
        return winrt::Windows::Foundation::Collections::IVector<winrt::Windows::Foundation::IInspectable>{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITabView<D>::TabItemTemplate() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITabView>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITabView, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITabView>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_TabItemTemplate(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITabView>**)this;
            check_hresult(_winrt_abi_type->get_TabItemTemplate(&value));
        }
        return winrt::Windows::UI::Xaml::DataTemplate{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITabView<D>::TabItemTemplate(winrt::Windows::UI::Xaml::DataTemplate const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITabView>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITabView, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITabView>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_TabItemTemplate(*(void**)(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITabView>**)this;
            check_hresult(_winrt_abi_type->put_TabItemTemplate(*(void**)(&value)));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITabView<D>::TabItemTemplateSelector() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITabView>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITabView, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITabView>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_TabItemTemplateSelector(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITabView>**)this;
            check_hresult(_winrt_abi_type->get_TabItemTemplateSelector(&value));
        }
        return winrt::Windows::UI::Xaml::Controls::DataTemplateSelector{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITabView<D>::TabItemTemplateSelector(winrt::Windows::UI::Xaml::Controls::DataTemplateSelector const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITabView>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITabView, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITabView>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_TabItemTemplateSelector(*(void**)(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITabView>**)this;
            check_hresult(_winrt_abi_type->put_TabItemTemplateSelector(*(void**)(&value)));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITabView<D>::CanDragTabs() const
    {
        bool value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITabView>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITabView, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITabView>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_CanDragTabs(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITabView>**)this;
            check_hresult(_winrt_abi_type->get_CanDragTabs(&value));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITabView<D>::CanDragTabs(bool value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITabView>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITabView, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITabView>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_CanDragTabs(value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITabView>**)this;
            check_hresult(_winrt_abi_type->put_CanDragTabs(value));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITabView<D>::CanReorderTabs() const
    {
        bool value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITabView>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITabView, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITabView>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_CanReorderTabs(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITabView>**)this;
            check_hresult(_winrt_abi_type->get_CanReorderTabs(&value));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITabView<D>::CanReorderTabs(bool value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITabView>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITabView, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITabView>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_CanReorderTabs(value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITabView>**)this;
            check_hresult(_winrt_abi_type->put_CanReorderTabs(value));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITabView<D>::AllowDropTabs() const
    {
        bool value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITabView>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITabView, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITabView>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_AllowDropTabs(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITabView>**)this;
            check_hresult(_winrt_abi_type->get_AllowDropTabs(&value));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITabView<D>::AllowDropTabs(bool value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITabView>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITabView, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITabView>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_AllowDropTabs(value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITabView>**)this;
            check_hresult(_winrt_abi_type->put_AllowDropTabs(value));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITabView<D>::SelectedIndex() const
    {
        int32_t value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITabView>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITabView, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITabView>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_SelectedIndex(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITabView>**)this;
            check_hresult(_winrt_abi_type->get_SelectedIndex(&value));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITabView<D>::SelectedIndex(int32_t value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITabView>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITabView, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITabView>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_SelectedIndex(value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITabView>**)this;
            check_hresult(_winrt_abi_type->put_SelectedIndex(value));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITabView<D>::SelectedItem() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITabView>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITabView, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITabView>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_SelectedItem(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITabView>**)this;
            check_hresult(_winrt_abi_type->get_SelectedItem(&value));
        }
        return winrt::Windows::Foundation::IInspectable{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITabView<D>::SelectedItem(winrt::Windows::Foundation::IInspectable const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITabView>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITabView, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITabView>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_SelectedItem(*(void**)(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITabView>**)this;
            check_hresult(_winrt_abi_type->put_SelectedItem(*(void**)(&value)));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITabView<D>::ContainerFromItem(winrt::Windows::Foundation::IInspectable const& item) const
    {
        void* result{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITabView>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITabView, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITabView>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->ContainerFromItem(*(void**)(&item), &result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITabView>**)this;
            check_hresult(_winrt_abi_type->ContainerFromItem(*(void**)(&item), &result));
        }
        return winrt::Windows::UI::Xaml::DependencyObject{ result, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITabView<D>::ContainerFromIndex(int32_t index) const
    {
        void* result{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITabView>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITabView, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITabView>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->ContainerFromIndex(index, &result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITabView>**)this;
            check_hresult(_winrt_abi_type->ContainerFromIndex(index, &result));
        }
        return winrt::Windows::UI::Xaml::DependencyObject{ result, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITabView<D>::SelectionChanged(winrt::Windows::UI::Xaml::Controls::SelectionChangedEventHandler const& handler) const
    {
        winrt::event_token token{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITabView>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITabView, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITabView>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->add_SelectionChanged(*(void**)(&handler), put_abi(token)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITabView>**)this;
            check_hresult(_winrt_abi_type->add_SelectionChanged(*(void**)(&handler), put_abi(token)));
        }
        return token;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITabView<D>::SelectionChanged(auto_revoke_t, winrt::Windows::UI::Xaml::Controls::SelectionChangedEventHandler const& handler) const
    {
        return impl::make_event_revoker<D, SelectionChanged_revoker>(this, SelectionChanged(handler));
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITabView<D>::SelectionChanged(winrt::event_token const& token) const noexcept
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITabView>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITabView, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITabView>**)&_winrt_casted_result;
            _winrt_abi_type->remove_SelectionChanged(impl::bind_in(token));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITabView>**)this;
            _winrt_abi_type->remove_SelectionChanged(impl::bind_in(token));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITabView<D>::TabDragStarting(winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Xaml::Controls::TabView, winrt::Microsoft::UI::Xaml::Controls::TabViewTabDragStartingEventArgs> const& handler) const
    {
        winrt::event_token token{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITabView>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITabView, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITabView>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->add_TabDragStarting(*(void**)(&handler), put_abi(token)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITabView>**)this;
            check_hresult(_winrt_abi_type->add_TabDragStarting(*(void**)(&handler), put_abi(token)));
        }
        return token;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITabView<D>::TabDragStarting(auto_revoke_t, winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Xaml::Controls::TabView, winrt::Microsoft::UI::Xaml::Controls::TabViewTabDragStartingEventArgs> const& handler) const
    {
        return impl::make_event_revoker<D, TabDragStarting_revoker>(this, TabDragStarting(handler));
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITabView<D>::TabDragStarting(winrt::event_token const& token) const noexcept
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITabView>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITabView, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITabView>**)&_winrt_casted_result;
            _winrt_abi_type->remove_TabDragStarting(impl::bind_in(token));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITabView>**)this;
            _winrt_abi_type->remove_TabDragStarting(impl::bind_in(token));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITabView<D>::TabDragCompleted(winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Xaml::Controls::TabView, winrt::Microsoft::UI::Xaml::Controls::TabViewTabDragCompletedEventArgs> const& handler) const
    {
        winrt::event_token token{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITabView>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITabView, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITabView>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->add_TabDragCompleted(*(void**)(&handler), put_abi(token)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITabView>**)this;
            check_hresult(_winrt_abi_type->add_TabDragCompleted(*(void**)(&handler), put_abi(token)));
        }
        return token;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITabView<D>::TabDragCompleted(auto_revoke_t, winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Xaml::Controls::TabView, winrt::Microsoft::UI::Xaml::Controls::TabViewTabDragCompletedEventArgs> const& handler) const
    {
        return impl::make_event_revoker<D, TabDragCompleted_revoker>(this, TabDragCompleted(handler));
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITabView<D>::TabDragCompleted(winrt::event_token const& token) const noexcept
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITabView>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITabView, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITabView>**)&_winrt_casted_result;
            _winrt_abi_type->remove_TabDragCompleted(impl::bind_in(token));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITabView>**)this;
            _winrt_abi_type->remove_TabDragCompleted(impl::bind_in(token));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITabView<D>::TabStripDragOver(winrt::Windows::UI::Xaml::DragEventHandler const& handler) const
    {
        winrt::event_token token{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITabView>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITabView, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITabView>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->add_TabStripDragOver(*(void**)(&handler), put_abi(token)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITabView>**)this;
            check_hresult(_winrt_abi_type->add_TabStripDragOver(*(void**)(&handler), put_abi(token)));
        }
        return token;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITabView<D>::TabStripDragOver(auto_revoke_t, winrt::Windows::UI::Xaml::DragEventHandler const& handler) const
    {
        return impl::make_event_revoker<D, TabStripDragOver_revoker>(this, TabStripDragOver(handler));
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITabView<D>::TabStripDragOver(winrt::event_token const& token) const noexcept
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITabView>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITabView, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITabView>**)&_winrt_casted_result;
            _winrt_abi_type->remove_TabStripDragOver(impl::bind_in(token));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITabView>**)this;
            _winrt_abi_type->remove_TabStripDragOver(impl::bind_in(token));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITabView<D>::TabStripDrop(winrt::Windows::UI::Xaml::DragEventHandler const& handler) const
    {
        winrt::event_token token{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITabView>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITabView, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITabView>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->add_TabStripDrop(*(void**)(&handler), put_abi(token)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITabView>**)this;
            check_hresult(_winrt_abi_type->add_TabStripDrop(*(void**)(&handler), put_abi(token)));
        }
        return token;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITabView<D>::TabStripDrop(auto_revoke_t, winrt::Windows::UI::Xaml::DragEventHandler const& handler) const
    {
        return impl::make_event_revoker<D, TabStripDrop_revoker>(this, TabStripDrop(handler));
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITabView<D>::TabStripDrop(winrt::event_token const& token) const noexcept
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITabView>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITabView, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITabView>**)&_winrt_casted_result;
            _winrt_abi_type->remove_TabStripDrop(impl::bind_in(token));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITabView>**)this;
            _winrt_abi_type->remove_TabStripDrop(impl::bind_in(token));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITabViewFactory<D>::CreateInstance(winrt::Windows::Foundation::IInspectable const& baseInterface, winrt::Windows::Foundation::IInspectable& innerInterface) const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITabViewFactory>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITabViewFactory, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITabViewFactory>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->CreateInstance(*(void**)(&baseInterface), impl::bind_out(innerInterface), &value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITabViewFactory>**)this;
            check_hresult(_winrt_abi_type->CreateInstance(*(void**)(&baseInterface), impl::bind_out(innerInterface), &value));
        }
        return winrt::Microsoft::UI::Xaml::Controls::TabView{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITabViewItem<D>::Header() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITabViewItem>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITabViewItem, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITabViewItem>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Header(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITabViewItem>**)this;
            check_hresult(_winrt_abi_type->get_Header(&value));
        }
        return winrt::Windows::Foundation::IInspectable{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITabViewItem<D>::Header(winrt::Windows::Foundation::IInspectable const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITabViewItem>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITabViewItem, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITabViewItem>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_Header(*(void**)(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITabViewItem>**)this;
            check_hresult(_winrt_abi_type->put_Header(*(void**)(&value)));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITabViewItem<D>::HeaderTemplate() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITabViewItem>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITabViewItem, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITabViewItem>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_HeaderTemplate(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITabViewItem>**)this;
            check_hresult(_winrt_abi_type->get_HeaderTemplate(&value));
        }
        return winrt::Windows::UI::Xaml::DataTemplate{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITabViewItem<D>::HeaderTemplate(winrt::Windows::UI::Xaml::DataTemplate const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITabViewItem>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITabViewItem, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITabViewItem>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_HeaderTemplate(*(void**)(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITabViewItem>**)this;
            check_hresult(_winrt_abi_type->put_HeaderTemplate(*(void**)(&value)));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITabViewItem<D>::IconSource() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITabViewItem>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITabViewItem, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITabViewItem>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_IconSource(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITabViewItem>**)this;
            check_hresult(_winrt_abi_type->get_IconSource(&value));
        }
        return winrt::Microsoft::UI::Xaml::Controls::IconSource{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITabViewItem<D>::IconSource(winrt::Microsoft::UI::Xaml::Controls::IconSource const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITabViewItem>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITabViewItem, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITabViewItem>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_IconSource(*(void**)(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITabViewItem>**)this;
            check_hresult(_winrt_abi_type->put_IconSource(*(void**)(&value)));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITabViewItem<D>::IsClosable() const
    {
        bool value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITabViewItem>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITabViewItem, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITabViewItem>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_IsClosable(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITabViewItem>**)this;
            check_hresult(_winrt_abi_type->get_IsClosable(&value));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITabViewItem<D>::IsClosable(bool value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITabViewItem>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITabViewItem, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITabViewItem>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_IsClosable(value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITabViewItem>**)this;
            check_hresult(_winrt_abi_type->put_IsClosable(value));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITabViewItem<D>::TabViewTemplateSettings() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITabViewItem>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITabViewItem, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITabViewItem>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_TabViewTemplateSettings(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITabViewItem>**)this;
            check_hresult(_winrt_abi_type->get_TabViewTemplateSettings(&value));
        }
        return winrt::Microsoft::UI::Xaml::Controls::TabViewItemTemplateSettings{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITabViewItem<D>::CloseRequested(winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Xaml::Controls::TabViewItem, winrt::Microsoft::UI::Xaml::Controls::TabViewTabCloseRequestedEventArgs> const& handler) const
    {
        winrt::event_token token{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITabViewItem>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITabViewItem, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITabViewItem>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->add_CloseRequested(*(void**)(&handler), put_abi(token)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITabViewItem>**)this;
            check_hresult(_winrt_abi_type->add_CloseRequested(*(void**)(&handler), put_abi(token)));
        }
        return token;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITabViewItem<D>::CloseRequested(auto_revoke_t, winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Xaml::Controls::TabViewItem, winrt::Microsoft::UI::Xaml::Controls::TabViewTabCloseRequestedEventArgs> const& handler) const
    {
        return impl::make_event_revoker<D, CloseRequested_revoker>(this, CloseRequested(handler));
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITabViewItem<D>::CloseRequested(winrt::event_token const& token) const noexcept
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITabViewItem>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITabViewItem, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITabViewItem>**)&_winrt_casted_result;
            _winrt_abi_type->remove_CloseRequested(impl::bind_in(token));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITabViewItem>**)this;
            _winrt_abi_type->remove_CloseRequested(impl::bind_in(token));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITabViewItemFactory<D>::CreateInstance(winrt::Windows::Foundation::IInspectable const& baseInterface, winrt::Windows::Foundation::IInspectable& innerInterface) const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITabViewItemFactory>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITabViewItemFactory, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITabViewItemFactory>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->CreateInstance(*(void**)(&baseInterface), impl::bind_out(innerInterface), &value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITabViewItemFactory>**)this;
            check_hresult(_winrt_abi_type->CreateInstance(*(void**)(&baseInterface), impl::bind_out(innerInterface), &value));
        }
        return winrt::Microsoft::UI::Xaml::Controls::TabViewItem{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITabViewItemStatics<D>::HeaderProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITabViewItemStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITabViewItemStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITabViewItemStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_HeaderProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITabViewItemStatics>**)this;
            check_hresult(_winrt_abi_type->get_HeaderProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITabViewItemStatics<D>::HeaderTemplateProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITabViewItemStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITabViewItemStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITabViewItemStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_HeaderTemplateProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITabViewItemStatics>**)this;
            check_hresult(_winrt_abi_type->get_HeaderTemplateProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITabViewItemStatics<D>::IconSourceProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITabViewItemStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITabViewItemStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITabViewItemStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_IconSourceProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITabViewItemStatics>**)this;
            check_hresult(_winrt_abi_type->get_IconSourceProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITabViewItemStatics<D>::IsClosableProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITabViewItemStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITabViewItemStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITabViewItemStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_IsClosableProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITabViewItemStatics>**)this;
            check_hresult(_winrt_abi_type->get_IsClosableProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITabViewItemStatics<D>::TabViewTemplateSettingsProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITabViewItemStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITabViewItemStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITabViewItemStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_TabViewTemplateSettingsProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITabViewItemStatics>**)this;
            check_hresult(_winrt_abi_type->get_TabViewTemplateSettingsProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITabViewItemTemplateSettings<D>::IconElement() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITabViewItemTemplateSettings>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITabViewItemTemplateSettings, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITabViewItemTemplateSettings>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_IconElement(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITabViewItemTemplateSettings>**)this;
            check_hresult(_winrt_abi_type->get_IconElement(&value));
        }
        return winrt::Windows::UI::Xaml::Controls::IconElement{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITabViewItemTemplateSettings<D>::IconElement(winrt::Windows::UI::Xaml::Controls::IconElement const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITabViewItemTemplateSettings>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITabViewItemTemplateSettings, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITabViewItemTemplateSettings>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_IconElement(*(void**)(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITabViewItemTemplateSettings>**)this;
            check_hresult(_winrt_abi_type->put_IconElement(*(void**)(&value)));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITabViewItemTemplateSettings2<D>::TabGeometry() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITabViewItemTemplateSettings2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITabViewItemTemplateSettings2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITabViewItemTemplateSettings2>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_TabGeometry(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITabViewItemTemplateSettings2>**)this;
            check_hresult(_winrt_abi_type->get_TabGeometry(&value));
        }
        return winrt::Windows::UI::Xaml::Media::Geometry{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITabViewItemTemplateSettings2<D>::TabGeometry(winrt::Windows::UI::Xaml::Media::Geometry const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITabViewItemTemplateSettings2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITabViewItemTemplateSettings2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITabViewItemTemplateSettings2>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_TabGeometry(*(void**)(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITabViewItemTemplateSettings2>**)this;
            check_hresult(_winrt_abi_type->put_TabGeometry(*(void**)(&value)));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITabViewItemTemplateSettingsFactory<D>::CreateInstance(winrt::Windows::Foundation::IInspectable const& baseInterface, winrt::Windows::Foundation::IInspectable& innerInterface) const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITabViewItemTemplateSettingsFactory>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITabViewItemTemplateSettingsFactory, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITabViewItemTemplateSettingsFactory>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->CreateInstance(*(void**)(&baseInterface), impl::bind_out(innerInterface), &value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITabViewItemTemplateSettingsFactory>**)this;
            check_hresult(_winrt_abi_type->CreateInstance(*(void**)(&baseInterface), impl::bind_out(innerInterface), &value));
        }
        return winrt::Microsoft::UI::Xaml::Controls::TabViewItemTemplateSettings{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITabViewItemTemplateSettingsStatics<D>::IconElementProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITabViewItemTemplateSettingsStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITabViewItemTemplateSettingsStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITabViewItemTemplateSettingsStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_IconElementProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITabViewItemTemplateSettingsStatics>**)this;
            check_hresult(_winrt_abi_type->get_IconElementProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITabViewItemTemplateSettingsStatics2<D>::TabGeometryProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITabViewItemTemplateSettingsStatics2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITabViewItemTemplateSettingsStatics2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITabViewItemTemplateSettingsStatics2>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_TabGeometryProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITabViewItemTemplateSettingsStatics2>**)this;
            check_hresult(_winrt_abi_type->get_TabGeometryProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITabViewStatics<D>::TabWidthModeProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITabViewStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITabViewStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITabViewStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_TabWidthModeProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITabViewStatics>**)this;
            check_hresult(_winrt_abi_type->get_TabWidthModeProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITabViewStatics<D>::TabStripHeaderProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITabViewStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITabViewStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITabViewStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_TabStripHeaderProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITabViewStatics>**)this;
            check_hresult(_winrt_abi_type->get_TabStripHeaderProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITabViewStatics<D>::TabStripHeaderTemplateProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITabViewStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITabViewStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITabViewStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_TabStripHeaderTemplateProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITabViewStatics>**)this;
            check_hresult(_winrt_abi_type->get_TabStripHeaderTemplateProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITabViewStatics<D>::TabStripFooterProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITabViewStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITabViewStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITabViewStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_TabStripFooterProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITabViewStatics>**)this;
            check_hresult(_winrt_abi_type->get_TabStripFooterProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITabViewStatics<D>::TabStripFooterTemplateProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITabViewStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITabViewStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITabViewStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_TabStripFooterTemplateProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITabViewStatics>**)this;
            check_hresult(_winrt_abi_type->get_TabStripFooterTemplateProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITabViewStatics<D>::IsAddTabButtonVisibleProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITabViewStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITabViewStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITabViewStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_IsAddTabButtonVisibleProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITabViewStatics>**)this;
            check_hresult(_winrt_abi_type->get_IsAddTabButtonVisibleProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITabViewStatics<D>::AddTabButtonCommandProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITabViewStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITabViewStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITabViewStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_AddTabButtonCommandProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITabViewStatics>**)this;
            check_hresult(_winrt_abi_type->get_AddTabButtonCommandProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITabViewStatics<D>::AddTabButtonCommandParameterProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITabViewStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITabViewStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITabViewStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_AddTabButtonCommandParameterProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITabViewStatics>**)this;
            check_hresult(_winrt_abi_type->get_AddTabButtonCommandParameterProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITabViewStatics<D>::TabItemsSourceProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITabViewStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITabViewStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITabViewStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_TabItemsSourceProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITabViewStatics>**)this;
            check_hresult(_winrt_abi_type->get_TabItemsSourceProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITabViewStatics<D>::TabItemsProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITabViewStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITabViewStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITabViewStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_TabItemsProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITabViewStatics>**)this;
            check_hresult(_winrt_abi_type->get_TabItemsProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITabViewStatics<D>::TabItemTemplateProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITabViewStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITabViewStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITabViewStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_TabItemTemplateProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITabViewStatics>**)this;
            check_hresult(_winrt_abi_type->get_TabItemTemplateProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITabViewStatics<D>::TabItemTemplateSelectorProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITabViewStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITabViewStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITabViewStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_TabItemTemplateSelectorProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITabViewStatics>**)this;
            check_hresult(_winrt_abi_type->get_TabItemTemplateSelectorProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITabViewStatics<D>::CloseButtonOverlayModeProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITabViewStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITabViewStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITabViewStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_CloseButtonOverlayModeProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITabViewStatics>**)this;
            check_hresult(_winrt_abi_type->get_CloseButtonOverlayModeProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITabViewStatics<D>::CanDragTabsProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITabViewStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITabViewStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITabViewStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_CanDragTabsProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITabViewStatics>**)this;
            check_hresult(_winrt_abi_type->get_CanDragTabsProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITabViewStatics<D>::CanReorderTabsProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITabViewStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITabViewStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITabViewStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_CanReorderTabsProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITabViewStatics>**)this;
            check_hresult(_winrt_abi_type->get_CanReorderTabsProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITabViewStatics<D>::AllowDropTabsProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITabViewStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITabViewStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITabViewStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_AllowDropTabsProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITabViewStatics>**)this;
            check_hresult(_winrt_abi_type->get_AllowDropTabsProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITabViewStatics<D>::SelectedIndexProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITabViewStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITabViewStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITabViewStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_SelectedIndexProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITabViewStatics>**)this;
            check_hresult(_winrt_abi_type->get_SelectedIndexProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITabViewStatics<D>::SelectedItemProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITabViewStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITabViewStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITabViewStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_SelectedItemProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITabViewStatics>**)this;
            check_hresult(_winrt_abi_type->get_SelectedItemProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITabViewTabCloseRequestedEventArgs<D>::Item() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITabViewTabCloseRequestedEventArgs>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITabViewTabCloseRequestedEventArgs, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITabViewTabCloseRequestedEventArgs>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Item(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITabViewTabCloseRequestedEventArgs>**)this;
            check_hresult(_winrt_abi_type->get_Item(&value));
        }
        return winrt::Windows::Foundation::IInspectable{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITabViewTabCloseRequestedEventArgs<D>::Tab() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITabViewTabCloseRequestedEventArgs>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITabViewTabCloseRequestedEventArgs, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITabViewTabCloseRequestedEventArgs>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Tab(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITabViewTabCloseRequestedEventArgs>**)this;
            check_hresult(_winrt_abi_type->get_Tab(&value));
        }
        return winrt::Microsoft::UI::Xaml::Controls::TabViewItem{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITabViewTabDragCompletedEventArgs<D>::DropResult() const
    {
        winrt::Windows::ApplicationModel::DataTransfer::DataPackageOperation value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITabViewTabDragCompletedEventArgs>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITabViewTabDragCompletedEventArgs, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITabViewTabDragCompletedEventArgs>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_DropResult(reinterpret_cast<uint32_t*>(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITabViewTabDragCompletedEventArgs>**)this;
            check_hresult(_winrt_abi_type->get_DropResult(reinterpret_cast<uint32_t*>(&value)));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITabViewTabDragCompletedEventArgs<D>::Item() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITabViewTabDragCompletedEventArgs>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITabViewTabDragCompletedEventArgs, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITabViewTabDragCompletedEventArgs>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Item(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITabViewTabDragCompletedEventArgs>**)this;
            check_hresult(_winrt_abi_type->get_Item(&value));
        }
        return winrt::Windows::Foundation::IInspectable{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITabViewTabDragCompletedEventArgs<D>::Tab() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITabViewTabDragCompletedEventArgs>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITabViewTabDragCompletedEventArgs, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITabViewTabDragCompletedEventArgs>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Tab(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITabViewTabDragCompletedEventArgs>**)this;
            check_hresult(_winrt_abi_type->get_Tab(&value));
        }
        return winrt::Microsoft::UI::Xaml::Controls::TabViewItem{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITabViewTabDragStartingEventArgs<D>::Cancel() const
    {
        bool value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITabViewTabDragStartingEventArgs>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITabViewTabDragStartingEventArgs, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITabViewTabDragStartingEventArgs>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Cancel(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITabViewTabDragStartingEventArgs>**)this;
            check_hresult(_winrt_abi_type->get_Cancel(&value));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITabViewTabDragStartingEventArgs<D>::Cancel(bool value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITabViewTabDragStartingEventArgs>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITabViewTabDragStartingEventArgs, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITabViewTabDragStartingEventArgs>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_Cancel(value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITabViewTabDragStartingEventArgs>**)this;
            check_hresult(_winrt_abi_type->put_Cancel(value));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITabViewTabDragStartingEventArgs<D>::Data() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITabViewTabDragStartingEventArgs>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITabViewTabDragStartingEventArgs, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITabViewTabDragStartingEventArgs>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Data(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITabViewTabDragStartingEventArgs>**)this;
            check_hresult(_winrt_abi_type->get_Data(&value));
        }
        return winrt::Windows::ApplicationModel::DataTransfer::DataPackage{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITabViewTabDragStartingEventArgs<D>::Item() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITabViewTabDragStartingEventArgs>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITabViewTabDragStartingEventArgs, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITabViewTabDragStartingEventArgs>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Item(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITabViewTabDragStartingEventArgs>**)this;
            check_hresult(_winrt_abi_type->get_Item(&value));
        }
        return winrt::Windows::Foundation::IInspectable{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITabViewTabDragStartingEventArgs<D>::Tab() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITabViewTabDragStartingEventArgs>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITabViewTabDragStartingEventArgs, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITabViewTabDragStartingEventArgs>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Tab(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITabViewTabDragStartingEventArgs>**)this;
            check_hresult(_winrt_abi_type->get_Tab(&value));
        }
        return winrt::Microsoft::UI::Xaml::Controls::TabViewItem{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITabViewTabDroppedOutsideEventArgs<D>::Item() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITabViewTabDroppedOutsideEventArgs>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITabViewTabDroppedOutsideEventArgs, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITabViewTabDroppedOutsideEventArgs>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Item(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITabViewTabDroppedOutsideEventArgs>**)this;
            check_hresult(_winrt_abi_type->get_Item(&value));
        }
        return winrt::Windows::Foundation::IInspectable{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITabViewTabDroppedOutsideEventArgs<D>::Tab() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITabViewTabDroppedOutsideEventArgs>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITabViewTabDroppedOutsideEventArgs, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITabViewTabDroppedOutsideEventArgs>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Tab(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITabViewTabDroppedOutsideEventArgs>**)this;
            check_hresult(_winrt_abi_type->get_Tab(&value));
        }
        return winrt::Microsoft::UI::Xaml::Controls::TabViewItem{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITeachingTip<D>::Title() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITeachingTip>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITeachingTip, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITeachingTip>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Title(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITeachingTip>**)this;
            check_hresult(_winrt_abi_type->get_Title(&value));
        }
        return hstring{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITeachingTip<D>::Title(param::hstring const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITeachingTip>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITeachingTip, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITeachingTip>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_Title(*(void**)(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITeachingTip>**)this;
            check_hresult(_winrt_abi_type->put_Title(*(void**)(&value)));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITeachingTip<D>::Subtitle() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITeachingTip>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITeachingTip, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITeachingTip>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Subtitle(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITeachingTip>**)this;
            check_hresult(_winrt_abi_type->get_Subtitle(&value));
        }
        return hstring{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITeachingTip<D>::Subtitle(param::hstring const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITeachingTip>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITeachingTip, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITeachingTip>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_Subtitle(*(void**)(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITeachingTip>**)this;
            check_hresult(_winrt_abi_type->put_Subtitle(*(void**)(&value)));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITeachingTip<D>::IsOpen() const
    {
        bool value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITeachingTip>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITeachingTip, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITeachingTip>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_IsOpen(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITeachingTip>**)this;
            check_hresult(_winrt_abi_type->get_IsOpen(&value));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITeachingTip<D>::IsOpen(bool value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITeachingTip>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITeachingTip, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITeachingTip>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_IsOpen(value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITeachingTip>**)this;
            check_hresult(_winrt_abi_type->put_IsOpen(value));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITeachingTip<D>::Target() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITeachingTip>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITeachingTip, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITeachingTip>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Target(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITeachingTip>**)this;
            check_hresult(_winrt_abi_type->get_Target(&value));
        }
        return winrt::Windows::UI::Xaml::FrameworkElement{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITeachingTip<D>::Target(winrt::Windows::UI::Xaml::FrameworkElement const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITeachingTip>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITeachingTip, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITeachingTip>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_Target(*(void**)(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITeachingTip>**)this;
            check_hresult(_winrt_abi_type->put_Target(*(void**)(&value)));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITeachingTip<D>::TailVisibility() const
    {
        winrt::Microsoft::UI::Xaml::Controls::TeachingTipTailVisibility value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITeachingTip>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITeachingTip, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITeachingTip>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_TailVisibility(reinterpret_cast<int32_t*>(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITeachingTip>**)this;
            check_hresult(_winrt_abi_type->get_TailVisibility(reinterpret_cast<int32_t*>(&value)));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITeachingTip<D>::TailVisibility(winrt::Microsoft::UI::Xaml::Controls::TeachingTipTailVisibility const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITeachingTip>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITeachingTip, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITeachingTip>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_TailVisibility(static_cast<int32_t>(value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITeachingTip>**)this;
            check_hresult(_winrt_abi_type->put_TailVisibility(static_cast<int32_t>(value)));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITeachingTip<D>::ActionButtonContent() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITeachingTip>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITeachingTip, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITeachingTip>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_ActionButtonContent(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITeachingTip>**)this;
            check_hresult(_winrt_abi_type->get_ActionButtonContent(&value));
        }
        return winrt::Windows::Foundation::IInspectable{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITeachingTip<D>::ActionButtonContent(winrt::Windows::Foundation::IInspectable const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITeachingTip>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITeachingTip, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITeachingTip>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_ActionButtonContent(*(void**)(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITeachingTip>**)this;
            check_hresult(_winrt_abi_type->put_ActionButtonContent(*(void**)(&value)));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITeachingTip<D>::ActionButtonStyle() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITeachingTip>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITeachingTip, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITeachingTip>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_ActionButtonStyle(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITeachingTip>**)this;
            check_hresult(_winrt_abi_type->get_ActionButtonStyle(&value));
        }
        return winrt::Windows::UI::Xaml::Style{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITeachingTip<D>::ActionButtonStyle(winrt::Windows::UI::Xaml::Style const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITeachingTip>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITeachingTip, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITeachingTip>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_ActionButtonStyle(*(void**)(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITeachingTip>**)this;
            check_hresult(_winrt_abi_type->put_ActionButtonStyle(*(void**)(&value)));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITeachingTip<D>::ActionButtonCommand() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITeachingTip>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITeachingTip, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITeachingTip>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_ActionButtonCommand(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITeachingTip>**)this;
            check_hresult(_winrt_abi_type->get_ActionButtonCommand(&value));
        }
        return winrt::Windows::UI::Xaml::Input::ICommand{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITeachingTip<D>::ActionButtonCommand(winrt::Windows::UI::Xaml::Input::ICommand const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITeachingTip>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITeachingTip, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITeachingTip>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_ActionButtonCommand(*(void**)(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITeachingTip>**)this;
            check_hresult(_winrt_abi_type->put_ActionButtonCommand(*(void**)(&value)));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITeachingTip<D>::ActionButtonCommandParameter() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITeachingTip>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITeachingTip, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITeachingTip>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_ActionButtonCommandParameter(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITeachingTip>**)this;
            check_hresult(_winrt_abi_type->get_ActionButtonCommandParameter(&value));
        }
        return winrt::Windows::Foundation::IInspectable{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITeachingTip<D>::ActionButtonCommandParameter(winrt::Windows::Foundation::IInspectable const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITeachingTip>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITeachingTip, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITeachingTip>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_ActionButtonCommandParameter(*(void**)(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITeachingTip>**)this;
            check_hresult(_winrt_abi_type->put_ActionButtonCommandParameter(*(void**)(&value)));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITeachingTip<D>::CloseButtonContent() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITeachingTip>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITeachingTip, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITeachingTip>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_CloseButtonContent(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITeachingTip>**)this;
            check_hresult(_winrt_abi_type->get_CloseButtonContent(&value));
        }
        return winrt::Windows::Foundation::IInspectable{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITeachingTip<D>::CloseButtonContent(winrt::Windows::Foundation::IInspectable const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITeachingTip>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITeachingTip, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITeachingTip>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_CloseButtonContent(*(void**)(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITeachingTip>**)this;
            check_hresult(_winrt_abi_type->put_CloseButtonContent(*(void**)(&value)));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITeachingTip<D>::CloseButtonStyle() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITeachingTip>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITeachingTip, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITeachingTip>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_CloseButtonStyle(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITeachingTip>**)this;
            check_hresult(_winrt_abi_type->get_CloseButtonStyle(&value));
        }
        return winrt::Windows::UI::Xaml::Style{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITeachingTip<D>::CloseButtonStyle(winrt::Windows::UI::Xaml::Style const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITeachingTip>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITeachingTip, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITeachingTip>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_CloseButtonStyle(*(void**)(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITeachingTip>**)this;
            check_hresult(_winrt_abi_type->put_CloseButtonStyle(*(void**)(&value)));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITeachingTip<D>::CloseButtonCommand() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITeachingTip>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITeachingTip, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITeachingTip>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_CloseButtonCommand(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITeachingTip>**)this;
            check_hresult(_winrt_abi_type->get_CloseButtonCommand(&value));
        }
        return winrt::Windows::UI::Xaml::Input::ICommand{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITeachingTip<D>::CloseButtonCommand(winrt::Windows::UI::Xaml::Input::ICommand const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITeachingTip>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITeachingTip, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITeachingTip>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_CloseButtonCommand(*(void**)(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITeachingTip>**)this;
            check_hresult(_winrt_abi_type->put_CloseButtonCommand(*(void**)(&value)));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITeachingTip<D>::CloseButtonCommandParameter() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITeachingTip>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITeachingTip, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITeachingTip>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_CloseButtonCommandParameter(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITeachingTip>**)this;
            check_hresult(_winrt_abi_type->get_CloseButtonCommandParameter(&value));
        }
        return winrt::Windows::Foundation::IInspectable{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITeachingTip<D>::CloseButtonCommandParameter(winrt::Windows::Foundation::IInspectable const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITeachingTip>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITeachingTip, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITeachingTip>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_CloseButtonCommandParameter(*(void**)(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITeachingTip>**)this;
            check_hresult(_winrt_abi_type->put_CloseButtonCommandParameter(*(void**)(&value)));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITeachingTip<D>::PlacementMargin() const
    {
        winrt::Windows::UI::Xaml::Thickness value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITeachingTip>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITeachingTip, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITeachingTip>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_PlacementMargin(put_abi(value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITeachingTip>**)this;
            check_hresult(_winrt_abi_type->get_PlacementMargin(put_abi(value)));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITeachingTip<D>::PlacementMargin(winrt::Windows::UI::Xaml::Thickness const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITeachingTip>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITeachingTip, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITeachingTip>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_PlacementMargin(impl::bind_in(value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITeachingTip>**)this;
            check_hresult(_winrt_abi_type->put_PlacementMargin(impl::bind_in(value)));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITeachingTip<D>::ShouldConstrainToRootBounds() const
    {
        bool value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITeachingTip>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITeachingTip, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITeachingTip>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_ShouldConstrainToRootBounds(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITeachingTip>**)this;
            check_hresult(_winrt_abi_type->get_ShouldConstrainToRootBounds(&value));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITeachingTip<D>::ShouldConstrainToRootBounds(bool value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITeachingTip>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITeachingTip, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITeachingTip>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_ShouldConstrainToRootBounds(value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITeachingTip>**)this;
            check_hresult(_winrt_abi_type->put_ShouldConstrainToRootBounds(value));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITeachingTip<D>::IsLightDismissEnabled() const
    {
        bool value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITeachingTip>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITeachingTip, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITeachingTip>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_IsLightDismissEnabled(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITeachingTip>**)this;
            check_hresult(_winrt_abi_type->get_IsLightDismissEnabled(&value));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITeachingTip<D>::IsLightDismissEnabled(bool value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITeachingTip>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITeachingTip, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITeachingTip>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_IsLightDismissEnabled(value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITeachingTip>**)this;
            check_hresult(_winrt_abi_type->put_IsLightDismissEnabled(value));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITeachingTip<D>::PreferredPlacement() const
    {
        winrt::Microsoft::UI::Xaml::Controls::TeachingTipPlacementMode value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITeachingTip>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITeachingTip, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITeachingTip>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_PreferredPlacement(reinterpret_cast<int32_t*>(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITeachingTip>**)this;
            check_hresult(_winrt_abi_type->get_PreferredPlacement(reinterpret_cast<int32_t*>(&value)));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITeachingTip<D>::PreferredPlacement(winrt::Microsoft::UI::Xaml::Controls::TeachingTipPlacementMode const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITeachingTip>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITeachingTip, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITeachingTip>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_PreferredPlacement(static_cast<int32_t>(value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITeachingTip>**)this;
            check_hresult(_winrt_abi_type->put_PreferredPlacement(static_cast<int32_t>(value)));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITeachingTip<D>::HeroContentPlacement() const
    {
        winrt::Microsoft::UI::Xaml::Controls::TeachingTipHeroContentPlacementMode value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITeachingTip>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITeachingTip, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITeachingTip>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_HeroContentPlacement(reinterpret_cast<int32_t*>(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITeachingTip>**)this;
            check_hresult(_winrt_abi_type->get_HeroContentPlacement(reinterpret_cast<int32_t*>(&value)));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITeachingTip<D>::HeroContentPlacement(winrt::Microsoft::UI::Xaml::Controls::TeachingTipHeroContentPlacementMode const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITeachingTip>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITeachingTip, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITeachingTip>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_HeroContentPlacement(static_cast<int32_t>(value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITeachingTip>**)this;
            check_hresult(_winrt_abi_type->put_HeroContentPlacement(static_cast<int32_t>(value)));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITeachingTip<D>::HeroContent() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITeachingTip>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITeachingTip, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITeachingTip>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_HeroContent(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITeachingTip>**)this;
            check_hresult(_winrt_abi_type->get_HeroContent(&value));
        }
        return winrt::Windows::UI::Xaml::UIElement{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITeachingTip<D>::HeroContent(winrt::Windows::UI::Xaml::UIElement const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITeachingTip>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITeachingTip, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITeachingTip>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_HeroContent(*(void**)(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITeachingTip>**)this;
            check_hresult(_winrt_abi_type->put_HeroContent(*(void**)(&value)));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITeachingTip<D>::IconSource() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITeachingTip>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITeachingTip, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITeachingTip>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_IconSource(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITeachingTip>**)this;
            check_hresult(_winrt_abi_type->get_IconSource(&value));
        }
        return winrt::Microsoft::UI::Xaml::Controls::IconSource{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITeachingTip<D>::IconSource(winrt::Microsoft::UI::Xaml::Controls::IconSource const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITeachingTip>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITeachingTip, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITeachingTip>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_IconSource(*(void**)(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITeachingTip>**)this;
            check_hresult(_winrt_abi_type->put_IconSource(*(void**)(&value)));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITeachingTip<D>::TemplateSettings() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITeachingTip>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITeachingTip, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITeachingTip>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_TemplateSettings(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITeachingTip>**)this;
            check_hresult(_winrt_abi_type->get_TemplateSettings(&value));
        }
        return winrt::Microsoft::UI::Xaml::Controls::TeachingTipTemplateSettings{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITeachingTip<D>::ActionButtonClick(winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Xaml::Controls::TeachingTip, winrt::Windows::Foundation::IInspectable> const& handler) const
    {
        winrt::event_token token{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITeachingTip>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITeachingTip, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITeachingTip>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->add_ActionButtonClick(*(void**)(&handler), put_abi(token)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITeachingTip>**)this;
            check_hresult(_winrt_abi_type->add_ActionButtonClick(*(void**)(&handler), put_abi(token)));
        }
        return token;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITeachingTip<D>::ActionButtonClick(auto_revoke_t, winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Xaml::Controls::TeachingTip, winrt::Windows::Foundation::IInspectable> const& handler) const
    {
        return impl::make_event_revoker<D, ActionButtonClick_revoker>(this, ActionButtonClick(handler));
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITeachingTip<D>::ActionButtonClick(winrt::event_token const& token) const noexcept
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITeachingTip>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITeachingTip, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITeachingTip>**)&_winrt_casted_result;
            _winrt_abi_type->remove_ActionButtonClick(impl::bind_in(token));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITeachingTip>**)this;
            _winrt_abi_type->remove_ActionButtonClick(impl::bind_in(token));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITeachingTip<D>::CloseButtonClick(winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Xaml::Controls::TeachingTip, winrt::Windows::Foundation::IInspectable> const& handler) const
    {
        winrt::event_token token{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITeachingTip>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITeachingTip, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITeachingTip>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->add_CloseButtonClick(*(void**)(&handler), put_abi(token)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITeachingTip>**)this;
            check_hresult(_winrt_abi_type->add_CloseButtonClick(*(void**)(&handler), put_abi(token)));
        }
        return token;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITeachingTip<D>::CloseButtonClick(auto_revoke_t, winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Xaml::Controls::TeachingTip, winrt::Windows::Foundation::IInspectable> const& handler) const
    {
        return impl::make_event_revoker<D, CloseButtonClick_revoker>(this, CloseButtonClick(handler));
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITeachingTip<D>::CloseButtonClick(winrt::event_token const& token) const noexcept
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITeachingTip>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITeachingTip, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITeachingTip>**)&_winrt_casted_result;
            _winrt_abi_type->remove_CloseButtonClick(impl::bind_in(token));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITeachingTip>**)this;
            _winrt_abi_type->remove_CloseButtonClick(impl::bind_in(token));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITeachingTip<D>::Closing(winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Xaml::Controls::TeachingTip, winrt::Microsoft::UI::Xaml::Controls::TeachingTipClosingEventArgs> const& handler) const
    {
        winrt::event_token token{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITeachingTip>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITeachingTip, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITeachingTip>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->add_Closing(*(void**)(&handler), put_abi(token)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITeachingTip>**)this;
            check_hresult(_winrt_abi_type->add_Closing(*(void**)(&handler), put_abi(token)));
        }
        return token;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITeachingTip<D>::Closing(auto_revoke_t, winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Xaml::Controls::TeachingTip, winrt::Microsoft::UI::Xaml::Controls::TeachingTipClosingEventArgs> const& handler) const
    {
        return impl::make_event_revoker<D, Closing_revoker>(this, Closing(handler));
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITeachingTip<D>::Closing(winrt::event_token const& token) const noexcept
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITeachingTip>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITeachingTip, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITeachingTip>**)&_winrt_casted_result;
            _winrt_abi_type->remove_Closing(impl::bind_in(token));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITeachingTip>**)this;
            _winrt_abi_type->remove_Closing(impl::bind_in(token));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITeachingTip<D>::Closed(winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Xaml::Controls::TeachingTip, winrt::Microsoft::UI::Xaml::Controls::TeachingTipClosedEventArgs> const& handler) const
    {
        winrt::event_token token{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITeachingTip>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITeachingTip, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITeachingTip>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->add_Closed(*(void**)(&handler), put_abi(token)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITeachingTip>**)this;
            check_hresult(_winrt_abi_type->add_Closed(*(void**)(&handler), put_abi(token)));
        }
        return token;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITeachingTip<D>::Closed(auto_revoke_t, winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Xaml::Controls::TeachingTip, winrt::Microsoft::UI::Xaml::Controls::TeachingTipClosedEventArgs> const& handler) const
    {
        return impl::make_event_revoker<D, Closed_revoker>(this, Closed(handler));
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITeachingTip<D>::Closed(winrt::event_token const& token) const noexcept
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITeachingTip>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITeachingTip, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITeachingTip>**)&_winrt_casted_result;
            _winrt_abi_type->remove_Closed(impl::bind_in(token));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITeachingTip>**)this;
            _winrt_abi_type->remove_Closed(impl::bind_in(token));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITeachingTipClosedEventArgs<D>::Reason() const
    {
        winrt::Microsoft::UI::Xaml::Controls::TeachingTipCloseReason value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITeachingTipClosedEventArgs>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITeachingTipClosedEventArgs, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITeachingTipClosedEventArgs>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Reason(reinterpret_cast<int32_t*>(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITeachingTipClosedEventArgs>**)this;
            check_hresult(_winrt_abi_type->get_Reason(reinterpret_cast<int32_t*>(&value)));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITeachingTipClosingEventArgs<D>::Reason() const
    {
        winrt::Microsoft::UI::Xaml::Controls::TeachingTipCloseReason value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITeachingTipClosingEventArgs>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITeachingTipClosingEventArgs, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITeachingTipClosingEventArgs>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Reason(reinterpret_cast<int32_t*>(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITeachingTipClosingEventArgs>**)this;
            check_hresult(_winrt_abi_type->get_Reason(reinterpret_cast<int32_t*>(&value)));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITeachingTipClosingEventArgs<D>::Cancel() const
    {
        bool value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITeachingTipClosingEventArgs>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITeachingTipClosingEventArgs, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITeachingTipClosingEventArgs>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Cancel(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITeachingTipClosingEventArgs>**)this;
            check_hresult(_winrt_abi_type->get_Cancel(&value));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITeachingTipClosingEventArgs<D>::Cancel(bool value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITeachingTipClosingEventArgs>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITeachingTipClosingEventArgs, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITeachingTipClosingEventArgs>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_Cancel(value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITeachingTipClosingEventArgs>**)this;
            check_hresult(_winrt_abi_type->put_Cancel(value));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITeachingTipClosingEventArgs<D>::GetDeferral() const
    {
        void* result{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITeachingTipClosingEventArgs>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITeachingTipClosingEventArgs, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITeachingTipClosingEventArgs>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->GetDeferral(&result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITeachingTipClosingEventArgs>**)this;
            check_hresult(_winrt_abi_type->GetDeferral(&result));
        }
        return winrt::Windows::Foundation::Deferral{ result, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITeachingTipFactory<D>::CreateInstance(winrt::Windows::Foundation::IInspectable const& baseInterface, winrt::Windows::Foundation::IInspectable& innerInterface) const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITeachingTipFactory>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITeachingTipFactory, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITeachingTipFactory>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->CreateInstance(*(void**)(&baseInterface), impl::bind_out(innerInterface), &value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITeachingTipFactory>**)this;
            check_hresult(_winrt_abi_type->CreateInstance(*(void**)(&baseInterface), impl::bind_out(innerInterface), &value));
        }
        return winrt::Microsoft::UI::Xaml::Controls::TeachingTip{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITeachingTipStatics<D>::IsOpenProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITeachingTipStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITeachingTipStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITeachingTipStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_IsOpenProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITeachingTipStatics>**)this;
            check_hresult(_winrt_abi_type->get_IsOpenProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITeachingTipStatics<D>::TargetProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITeachingTipStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITeachingTipStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITeachingTipStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_TargetProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITeachingTipStatics>**)this;
            check_hresult(_winrt_abi_type->get_TargetProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITeachingTipStatics<D>::TailVisibilityProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITeachingTipStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITeachingTipStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITeachingTipStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_TailVisibilityProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITeachingTipStatics>**)this;
            check_hresult(_winrt_abi_type->get_TailVisibilityProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITeachingTipStatics<D>::TitleProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITeachingTipStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITeachingTipStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITeachingTipStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_TitleProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITeachingTipStatics>**)this;
            check_hresult(_winrt_abi_type->get_TitleProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITeachingTipStatics<D>::SubtitleProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITeachingTipStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITeachingTipStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITeachingTipStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_SubtitleProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITeachingTipStatics>**)this;
            check_hresult(_winrt_abi_type->get_SubtitleProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITeachingTipStatics<D>::ActionButtonContentProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITeachingTipStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITeachingTipStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITeachingTipStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_ActionButtonContentProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITeachingTipStatics>**)this;
            check_hresult(_winrt_abi_type->get_ActionButtonContentProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITeachingTipStatics<D>::ActionButtonStyleProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITeachingTipStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITeachingTipStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITeachingTipStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_ActionButtonStyleProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITeachingTipStatics>**)this;
            check_hresult(_winrt_abi_type->get_ActionButtonStyleProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITeachingTipStatics<D>::ActionButtonCommandProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITeachingTipStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITeachingTipStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITeachingTipStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_ActionButtonCommandProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITeachingTipStatics>**)this;
            check_hresult(_winrt_abi_type->get_ActionButtonCommandProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITeachingTipStatics<D>::ActionButtonCommandParameterProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITeachingTipStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITeachingTipStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITeachingTipStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_ActionButtonCommandParameterProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITeachingTipStatics>**)this;
            check_hresult(_winrt_abi_type->get_ActionButtonCommandParameterProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITeachingTipStatics<D>::CloseButtonContentProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITeachingTipStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITeachingTipStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITeachingTipStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_CloseButtonContentProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITeachingTipStatics>**)this;
            check_hresult(_winrt_abi_type->get_CloseButtonContentProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITeachingTipStatics<D>::CloseButtonStyleProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITeachingTipStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITeachingTipStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITeachingTipStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_CloseButtonStyleProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITeachingTipStatics>**)this;
            check_hresult(_winrt_abi_type->get_CloseButtonStyleProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITeachingTipStatics<D>::CloseButtonCommandProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITeachingTipStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITeachingTipStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITeachingTipStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_CloseButtonCommandProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITeachingTipStatics>**)this;
            check_hresult(_winrt_abi_type->get_CloseButtonCommandProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITeachingTipStatics<D>::CloseButtonCommandParameterProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITeachingTipStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITeachingTipStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITeachingTipStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_CloseButtonCommandParameterProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITeachingTipStatics>**)this;
            check_hresult(_winrt_abi_type->get_CloseButtonCommandParameterProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITeachingTipStatics<D>::PlacementMarginProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITeachingTipStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITeachingTipStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITeachingTipStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_PlacementMarginProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITeachingTipStatics>**)this;
            check_hresult(_winrt_abi_type->get_PlacementMarginProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITeachingTipStatics<D>::ShouldConstrainToRootBoundsProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITeachingTipStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITeachingTipStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITeachingTipStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_ShouldConstrainToRootBoundsProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITeachingTipStatics>**)this;
            check_hresult(_winrt_abi_type->get_ShouldConstrainToRootBoundsProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITeachingTipStatics<D>::IsLightDismissEnabledProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITeachingTipStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITeachingTipStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITeachingTipStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_IsLightDismissEnabledProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITeachingTipStatics>**)this;
            check_hresult(_winrt_abi_type->get_IsLightDismissEnabledProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITeachingTipStatics<D>::PreferredPlacementProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITeachingTipStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITeachingTipStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITeachingTipStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_PreferredPlacementProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITeachingTipStatics>**)this;
            check_hresult(_winrt_abi_type->get_PreferredPlacementProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITeachingTipStatics<D>::HeroContentPlacementProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITeachingTipStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITeachingTipStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITeachingTipStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_HeroContentPlacementProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITeachingTipStatics>**)this;
            check_hresult(_winrt_abi_type->get_HeroContentPlacementProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITeachingTipStatics<D>::HeroContentProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITeachingTipStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITeachingTipStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITeachingTipStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_HeroContentProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITeachingTipStatics>**)this;
            check_hresult(_winrt_abi_type->get_HeroContentProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITeachingTipStatics<D>::IconSourceProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITeachingTipStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITeachingTipStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITeachingTipStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_IconSourceProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITeachingTipStatics>**)this;
            check_hresult(_winrt_abi_type->get_IconSourceProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITeachingTipStatics<D>::TemplateSettingsProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITeachingTipStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITeachingTipStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITeachingTipStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_TemplateSettingsProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITeachingTipStatics>**)this;
            check_hresult(_winrt_abi_type->get_TemplateSettingsProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITeachingTipTemplateSettings<D>::TopRightHighlightMargin() const
    {
        winrt::Windows::UI::Xaml::Thickness value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITeachingTipTemplateSettings>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITeachingTipTemplateSettings, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITeachingTipTemplateSettings>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_TopRightHighlightMargin(put_abi(value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITeachingTipTemplateSettings>**)this;
            check_hresult(_winrt_abi_type->get_TopRightHighlightMargin(put_abi(value)));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITeachingTipTemplateSettings<D>::TopRightHighlightMargin(winrt::Windows::UI::Xaml::Thickness const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITeachingTipTemplateSettings>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITeachingTipTemplateSettings, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITeachingTipTemplateSettings>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_TopRightHighlightMargin(impl::bind_in(value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITeachingTipTemplateSettings>**)this;
            check_hresult(_winrt_abi_type->put_TopRightHighlightMargin(impl::bind_in(value)));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITeachingTipTemplateSettings<D>::TopLeftHighlightMargin() const
    {
        winrt::Windows::UI::Xaml::Thickness value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITeachingTipTemplateSettings>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITeachingTipTemplateSettings, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITeachingTipTemplateSettings>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_TopLeftHighlightMargin(put_abi(value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITeachingTipTemplateSettings>**)this;
            check_hresult(_winrt_abi_type->get_TopLeftHighlightMargin(put_abi(value)));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITeachingTipTemplateSettings<D>::TopLeftHighlightMargin(winrt::Windows::UI::Xaml::Thickness const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITeachingTipTemplateSettings>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITeachingTipTemplateSettings, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITeachingTipTemplateSettings>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_TopLeftHighlightMargin(impl::bind_in(value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITeachingTipTemplateSettings>**)this;
            check_hresult(_winrt_abi_type->put_TopLeftHighlightMargin(impl::bind_in(value)));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITeachingTipTemplateSettings<D>::IconElement() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITeachingTipTemplateSettings>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITeachingTipTemplateSettings, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITeachingTipTemplateSettings>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_IconElement(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITeachingTipTemplateSettings>**)this;
            check_hresult(_winrt_abi_type->get_IconElement(&value));
        }
        return winrt::Windows::UI::Xaml::Controls::IconElement{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITeachingTipTemplateSettings<D>::IconElement(winrt::Windows::UI::Xaml::Controls::IconElement const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITeachingTipTemplateSettings>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITeachingTipTemplateSettings, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITeachingTipTemplateSettings>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_IconElement(*(void**)(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITeachingTipTemplateSettings>**)this;
            check_hresult(_winrt_abi_type->put_IconElement(*(void**)(&value)));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITeachingTipTemplateSettingsFactory<D>::CreateInstance(winrt::Windows::Foundation::IInspectable const& baseInterface, winrt::Windows::Foundation::IInspectable& innerInterface) const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITeachingTipTemplateSettingsFactory>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITeachingTipTemplateSettingsFactory, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITeachingTipTemplateSettingsFactory>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->CreateInstance(*(void**)(&baseInterface), impl::bind_out(innerInterface), &value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITeachingTipTemplateSettingsFactory>**)this;
            check_hresult(_winrt_abi_type->CreateInstance(*(void**)(&baseInterface), impl::bind_out(innerInterface), &value));
        }
        return winrt::Microsoft::UI::Xaml::Controls::TeachingTipTemplateSettings{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITeachingTipTemplateSettingsStatics<D>::TopRightHighlightMarginProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITeachingTipTemplateSettingsStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITeachingTipTemplateSettingsStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITeachingTipTemplateSettingsStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_TopRightHighlightMarginProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITeachingTipTemplateSettingsStatics>**)this;
            check_hresult(_winrt_abi_type->get_TopRightHighlightMarginProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITeachingTipTemplateSettingsStatics<D>::TopLeftHighlightMarginProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITeachingTipTemplateSettingsStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITeachingTipTemplateSettingsStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITeachingTipTemplateSettingsStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_TopLeftHighlightMarginProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITeachingTipTemplateSettingsStatics>**)this;
            check_hresult(_winrt_abi_type->get_TopLeftHighlightMarginProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITeachingTipTemplateSettingsStatics<D>::IconElementProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITeachingTipTemplateSettingsStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITeachingTipTemplateSettingsStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITeachingTipTemplateSettingsStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_IconElementProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITeachingTipTemplateSettingsStatics>**)this;
            check_hresult(_winrt_abi_type->get_IconElementProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITextCommandBarFlyoutFactory<D>::CreateInstance(winrt::Windows::Foundation::IInspectable const& baseInterface, winrt::Windows::Foundation::IInspectable& innerInterface) const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITextCommandBarFlyoutFactory>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITextCommandBarFlyoutFactory, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITextCommandBarFlyoutFactory>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->CreateInstance(*(void**)(&baseInterface), impl::bind_out(innerInterface), &value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITextCommandBarFlyoutFactory>**)this;
            check_hresult(_winrt_abi_type->CreateInstance(*(void**)(&baseInterface), impl::bind_out(innerInterface), &value));
        }
        return winrt::Microsoft::UI::Xaml::Controls::TextCommandBarFlyout{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IToggleSplitButton<D>::IsChecked() const
    {
        bool value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IToggleSplitButton>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IToggleSplitButton, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IToggleSplitButton>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_IsChecked(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IToggleSplitButton>**)this;
            check_hresult(_winrt_abi_type->get_IsChecked(&value));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IToggleSplitButton<D>::IsChecked(bool value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IToggleSplitButton>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IToggleSplitButton, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IToggleSplitButton>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_IsChecked(value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IToggleSplitButton>**)this;
            check_hresult(_winrt_abi_type->put_IsChecked(value));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IToggleSplitButton<D>::IsCheckedChanged(winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Xaml::Controls::ToggleSplitButton, winrt::Microsoft::UI::Xaml::Controls::ToggleSplitButtonIsCheckedChangedEventArgs> const& handler) const
    {
        winrt::event_token token{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IToggleSplitButton>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IToggleSplitButton, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IToggleSplitButton>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->add_IsCheckedChanged(*(void**)(&handler), put_abi(token)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IToggleSplitButton>**)this;
            check_hresult(_winrt_abi_type->add_IsCheckedChanged(*(void**)(&handler), put_abi(token)));
        }
        return token;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IToggleSplitButton<D>::IsCheckedChanged(auto_revoke_t, winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Xaml::Controls::ToggleSplitButton, winrt::Microsoft::UI::Xaml::Controls::ToggleSplitButtonIsCheckedChangedEventArgs> const& handler) const
    {
        return impl::make_event_revoker<D, IsCheckedChanged_revoker>(this, IsCheckedChanged(handler));
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IToggleSplitButton<D>::IsCheckedChanged(winrt::event_token const& token) const noexcept
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IToggleSplitButton>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IToggleSplitButton, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IToggleSplitButton>**)&_winrt_casted_result;
            _winrt_abi_type->remove_IsCheckedChanged(impl::bind_in(token));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IToggleSplitButton>**)this;
            _winrt_abi_type->remove_IsCheckedChanged(impl::bind_in(token));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IToggleSplitButtonFactory<D>::CreateInstance(winrt::Windows::Foundation::IInspectable const& baseInterface, winrt::Windows::Foundation::IInspectable& innerInterface) const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IToggleSplitButtonFactory>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IToggleSplitButtonFactory, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IToggleSplitButtonFactory>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->CreateInstance(*(void**)(&baseInterface), impl::bind_out(innerInterface), &value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IToggleSplitButtonFactory>**)this;
            check_hresult(_winrt_abi_type->CreateInstance(*(void**)(&baseInterface), impl::bind_out(innerInterface), &value));
        }
        return winrt::Microsoft::UI::Xaml::Controls::ToggleSplitButton{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IToggleSplitButtonStatics<D>::IsCheckedProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IToggleSplitButtonStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IToggleSplitButtonStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IToggleSplitButtonStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_IsCheckedProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IToggleSplitButtonStatics>**)this;
            check_hresult(_winrt_abi_type->get_IsCheckedProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITreeView<D>::RootNodes() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITreeView>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITreeView, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITreeView>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_RootNodes(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITreeView>**)this;
            check_hresult(_winrt_abi_type->get_RootNodes(&value));
        }
        return winrt::Windows::Foundation::Collections::IVector<winrt::Microsoft::UI::Xaml::Controls::TreeViewNode>{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITreeView<D>::SelectionMode() const
    {
        winrt::Microsoft::UI::Xaml::Controls::TreeViewSelectionMode value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITreeView>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITreeView, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITreeView>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_SelectionMode(reinterpret_cast<int32_t*>(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITreeView>**)this;
            check_hresult(_winrt_abi_type->get_SelectionMode(reinterpret_cast<int32_t*>(&value)));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITreeView<D>::SelectionMode(winrt::Microsoft::UI::Xaml::Controls::TreeViewSelectionMode const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITreeView>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITreeView, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITreeView>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_SelectionMode(static_cast<int32_t>(value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITreeView>**)this;
            check_hresult(_winrt_abi_type->put_SelectionMode(static_cast<int32_t>(value)));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITreeView<D>::SelectedNodes() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITreeView>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITreeView, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITreeView>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_SelectedNodes(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITreeView>**)this;
            check_hresult(_winrt_abi_type->get_SelectedNodes(&value));
        }
        return winrt::Windows::Foundation::Collections::IVector<winrt::Microsoft::UI::Xaml::Controls::TreeViewNode>{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITreeView<D>::Expand(winrt::Microsoft::UI::Xaml::Controls::TreeViewNode const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITreeView>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITreeView, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITreeView>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->Expand(*(void**)(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITreeView>**)this;
            check_hresult(_winrt_abi_type->Expand(*(void**)(&value)));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITreeView<D>::Collapse(winrt::Microsoft::UI::Xaml::Controls::TreeViewNode const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITreeView>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITreeView, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITreeView>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->Collapse(*(void**)(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITreeView>**)this;
            check_hresult(_winrt_abi_type->Collapse(*(void**)(&value)));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITreeView<D>::SelectAll() const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITreeView>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITreeView, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITreeView>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->SelectAll());
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITreeView>**)this;
            check_hresult(_winrt_abi_type->SelectAll());
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITreeView<D>::ItemInvoked(winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Xaml::Controls::TreeView, winrt::Microsoft::UI::Xaml::Controls::TreeViewItemInvokedEventArgs> const& handler) const
    {
        winrt::event_token token{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITreeView>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITreeView, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITreeView>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->add_ItemInvoked(*(void**)(&handler), put_abi(token)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITreeView>**)this;
            check_hresult(_winrt_abi_type->add_ItemInvoked(*(void**)(&handler), put_abi(token)));
        }
        return token;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITreeView<D>::ItemInvoked(auto_revoke_t, winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Xaml::Controls::TreeView, winrt::Microsoft::UI::Xaml::Controls::TreeViewItemInvokedEventArgs> const& handler) const
    {
        return impl::make_event_revoker<D, ItemInvoked_revoker>(this, ItemInvoked(handler));
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITreeView<D>::ItemInvoked(winrt::event_token const& token) const noexcept
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITreeView>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITreeView, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITreeView>**)&_winrt_casted_result;
            _winrt_abi_type->remove_ItemInvoked(impl::bind_in(token));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITreeView>**)this;
            _winrt_abi_type->remove_ItemInvoked(impl::bind_in(token));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITreeView<D>::Expanding(winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Xaml::Controls::TreeView, winrt::Microsoft::UI::Xaml::Controls::TreeViewExpandingEventArgs> const& handler) const
    {
        winrt::event_token token{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITreeView>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITreeView, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITreeView>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->add_Expanding(*(void**)(&handler), put_abi(token)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITreeView>**)this;
            check_hresult(_winrt_abi_type->add_Expanding(*(void**)(&handler), put_abi(token)));
        }
        return token;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITreeView<D>::Expanding(auto_revoke_t, winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Xaml::Controls::TreeView, winrt::Microsoft::UI::Xaml::Controls::TreeViewExpandingEventArgs> const& handler) const
    {
        return impl::make_event_revoker<D, Expanding_revoker>(this, Expanding(handler));
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITreeView<D>::Expanding(winrt::event_token const& token) const noexcept
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITreeView>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITreeView, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITreeView>**)&_winrt_casted_result;
            _winrt_abi_type->remove_Expanding(impl::bind_in(token));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITreeView>**)this;
            _winrt_abi_type->remove_Expanding(impl::bind_in(token));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITreeView<D>::Collapsed(winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Xaml::Controls::TreeView, winrt::Microsoft::UI::Xaml::Controls::TreeViewCollapsedEventArgs> const& handler) const
    {
        winrt::event_token token{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITreeView>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITreeView, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITreeView>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->add_Collapsed(*(void**)(&handler), put_abi(token)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITreeView>**)this;
            check_hresult(_winrt_abi_type->add_Collapsed(*(void**)(&handler), put_abi(token)));
        }
        return token;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITreeView<D>::Collapsed(auto_revoke_t, winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Xaml::Controls::TreeView, winrt::Microsoft::UI::Xaml::Controls::TreeViewCollapsedEventArgs> const& handler) const
    {
        return impl::make_event_revoker<D, Collapsed_revoker>(this, Collapsed(handler));
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITreeView<D>::Collapsed(winrt::event_token const& token) const noexcept
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITreeView>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITreeView, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITreeView>**)&_winrt_casted_result;
            _winrt_abi_type->remove_Collapsed(impl::bind_in(token));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITreeView>**)this;
            _winrt_abi_type->remove_Collapsed(impl::bind_in(token));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITreeView2<D>::NodeFromContainer(winrt::Windows::UI::Xaml::DependencyObject const& container) const
    {
        void* result{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITreeView2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITreeView2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITreeView2>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->NodeFromContainer(*(void**)(&container), &result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITreeView2>**)this;
            check_hresult(_winrt_abi_type->NodeFromContainer(*(void**)(&container), &result));
        }
        return winrt::Microsoft::UI::Xaml::Controls::TreeViewNode{ result, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITreeView2<D>::ContainerFromNode(winrt::Microsoft::UI::Xaml::Controls::TreeViewNode const& node) const
    {
        void* result{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITreeView2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITreeView2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITreeView2>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->ContainerFromNode(*(void**)(&node), &result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITreeView2>**)this;
            check_hresult(_winrt_abi_type->ContainerFromNode(*(void**)(&node), &result));
        }
        return winrt::Windows::UI::Xaml::DependencyObject{ result, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITreeView2<D>::ItemFromContainer(winrt::Windows::UI::Xaml::DependencyObject const& container) const
    {
        void* result{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITreeView2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITreeView2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITreeView2>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->ItemFromContainer(*(void**)(&container), &result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITreeView2>**)this;
            check_hresult(_winrt_abi_type->ItemFromContainer(*(void**)(&container), &result));
        }
        return winrt::Windows::Foundation::IInspectable{ result, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITreeView2<D>::ContainerFromItem(winrt::Windows::Foundation::IInspectable const& item) const
    {
        void* result{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITreeView2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITreeView2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITreeView2>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->ContainerFromItem(*(void**)(&item), &result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITreeView2>**)this;
            check_hresult(_winrt_abi_type->ContainerFromItem(*(void**)(&item), &result));
        }
        return winrt::Windows::UI::Xaml::DependencyObject{ result, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITreeView2<D>::CanDragItems() const
    {
        bool value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITreeView2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITreeView2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITreeView2>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_CanDragItems(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITreeView2>**)this;
            check_hresult(_winrt_abi_type->get_CanDragItems(&value));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITreeView2<D>::CanDragItems(bool value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITreeView2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITreeView2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITreeView2>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_CanDragItems(value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITreeView2>**)this;
            check_hresult(_winrt_abi_type->put_CanDragItems(value));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITreeView2<D>::CanReorderItems() const
    {
        bool value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITreeView2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITreeView2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITreeView2>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_CanReorderItems(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITreeView2>**)this;
            check_hresult(_winrt_abi_type->get_CanReorderItems(&value));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITreeView2<D>::CanReorderItems(bool value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITreeView2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITreeView2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITreeView2>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_CanReorderItems(value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITreeView2>**)this;
            check_hresult(_winrt_abi_type->put_CanReorderItems(value));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITreeView2<D>::ItemTemplate() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITreeView2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITreeView2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITreeView2>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_ItemTemplate(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITreeView2>**)this;
            check_hresult(_winrt_abi_type->get_ItemTemplate(&value));
        }
        return winrt::Windows::UI::Xaml::DataTemplate{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITreeView2<D>::ItemTemplate(winrt::Windows::UI::Xaml::DataTemplate const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITreeView2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITreeView2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITreeView2>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_ItemTemplate(*(void**)(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITreeView2>**)this;
            check_hresult(_winrt_abi_type->put_ItemTemplate(*(void**)(&value)));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITreeView2<D>::ItemTemplateSelector() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITreeView2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITreeView2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITreeView2>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_ItemTemplateSelector(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITreeView2>**)this;
            check_hresult(_winrt_abi_type->get_ItemTemplateSelector(&value));
        }
        return winrt::Windows::UI::Xaml::Controls::DataTemplateSelector{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITreeView2<D>::ItemTemplateSelector(winrt::Windows::UI::Xaml::Controls::DataTemplateSelector const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITreeView2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITreeView2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITreeView2>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_ItemTemplateSelector(*(void**)(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITreeView2>**)this;
            check_hresult(_winrt_abi_type->put_ItemTemplateSelector(*(void**)(&value)));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITreeView2<D>::ItemContainerStyle() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITreeView2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITreeView2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITreeView2>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_ItemContainerStyle(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITreeView2>**)this;
            check_hresult(_winrt_abi_type->get_ItemContainerStyle(&value));
        }
        return winrt::Windows::UI::Xaml::Style{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITreeView2<D>::ItemContainerStyle(winrt::Windows::UI::Xaml::Style const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITreeView2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITreeView2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITreeView2>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_ItemContainerStyle(*(void**)(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITreeView2>**)this;
            check_hresult(_winrt_abi_type->put_ItemContainerStyle(*(void**)(&value)));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITreeView2<D>::ItemContainerStyleSelector() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITreeView2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITreeView2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITreeView2>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_ItemContainerStyleSelector(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITreeView2>**)this;
            check_hresult(_winrt_abi_type->get_ItemContainerStyleSelector(&value));
        }
        return winrt::Windows::UI::Xaml::Controls::StyleSelector{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITreeView2<D>::ItemContainerStyleSelector(winrt::Windows::UI::Xaml::Controls::StyleSelector const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITreeView2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITreeView2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITreeView2>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_ItemContainerStyleSelector(*(void**)(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITreeView2>**)this;
            check_hresult(_winrt_abi_type->put_ItemContainerStyleSelector(*(void**)(&value)));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITreeView2<D>::ItemContainerTransitions() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITreeView2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITreeView2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITreeView2>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_ItemContainerTransitions(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITreeView2>**)this;
            check_hresult(_winrt_abi_type->get_ItemContainerTransitions(&value));
        }
        return winrt::Windows::UI::Xaml::Media::Animation::TransitionCollection{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITreeView2<D>::ItemContainerTransitions(winrt::Windows::UI::Xaml::Media::Animation::TransitionCollection const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITreeView2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITreeView2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITreeView2>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_ItemContainerTransitions(*(void**)(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITreeView2>**)this;
            check_hresult(_winrt_abi_type->put_ItemContainerTransitions(*(void**)(&value)));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITreeView2<D>::ItemsSource() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITreeView2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITreeView2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITreeView2>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_ItemsSource(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITreeView2>**)this;
            check_hresult(_winrt_abi_type->get_ItemsSource(&value));
        }
        return winrt::Windows::Foundation::IInspectable{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITreeView2<D>::ItemsSource(winrt::Windows::Foundation::IInspectable const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITreeView2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITreeView2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITreeView2>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_ItemsSource(*(void**)(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITreeView2>**)this;
            check_hresult(_winrt_abi_type->put_ItemsSource(*(void**)(&value)));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITreeView2<D>::DragItemsStarting(winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Xaml::Controls::TreeView, winrt::Microsoft::UI::Xaml::Controls::TreeViewDragItemsStartingEventArgs> const& handler) const
    {
        winrt::event_token token{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITreeView2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITreeView2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITreeView2>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->add_DragItemsStarting(*(void**)(&handler), put_abi(token)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITreeView2>**)this;
            check_hresult(_winrt_abi_type->add_DragItemsStarting(*(void**)(&handler), put_abi(token)));
        }
        return token;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITreeView2<D>::DragItemsStarting(auto_revoke_t, winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Xaml::Controls::TreeView, winrt::Microsoft::UI::Xaml::Controls::TreeViewDragItemsStartingEventArgs> const& handler) const
    {
        return impl::make_event_revoker<D, DragItemsStarting_revoker>(this, DragItemsStarting(handler));
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITreeView2<D>::DragItemsStarting(winrt::event_token const& token) const noexcept
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITreeView2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITreeView2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITreeView2>**)&_winrt_casted_result;
            _winrt_abi_type->remove_DragItemsStarting(impl::bind_in(token));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITreeView2>**)this;
            _winrt_abi_type->remove_DragItemsStarting(impl::bind_in(token));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITreeView2<D>::DragItemsCompleted(winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Xaml::Controls::TreeView, winrt::Microsoft::UI::Xaml::Controls::TreeViewDragItemsCompletedEventArgs> const& handler) const
    {
        winrt::event_token token{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITreeView2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITreeView2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITreeView2>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->add_DragItemsCompleted(*(void**)(&handler), put_abi(token)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITreeView2>**)this;
            check_hresult(_winrt_abi_type->add_DragItemsCompleted(*(void**)(&handler), put_abi(token)));
        }
        return token;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITreeView2<D>::DragItemsCompleted(auto_revoke_t, winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Xaml::Controls::TreeView, winrt::Microsoft::UI::Xaml::Controls::TreeViewDragItemsCompletedEventArgs> const& handler) const
    {
        return impl::make_event_revoker<D, DragItemsCompleted_revoker>(this, DragItemsCompleted(handler));
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITreeView2<D>::DragItemsCompleted(winrt::event_token const& token) const noexcept
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITreeView2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITreeView2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITreeView2>**)&_winrt_casted_result;
            _winrt_abi_type->remove_DragItemsCompleted(impl::bind_in(token));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITreeView2>**)this;
            _winrt_abi_type->remove_DragItemsCompleted(impl::bind_in(token));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITreeView2<D>::SelectedNode() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITreeView2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITreeView2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITreeView2>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_SelectedNode(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITreeView2>**)this;
            check_hresult(_winrt_abi_type->get_SelectedNode(&value));
        }
        return winrt::Microsoft::UI::Xaml::Controls::TreeViewNode{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITreeView2<D>::SelectedNode(winrt::Microsoft::UI::Xaml::Controls::TreeViewNode const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITreeView2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITreeView2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITreeView2>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_SelectedNode(*(void**)(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITreeView2>**)this;
            check_hresult(_winrt_abi_type->put_SelectedNode(*(void**)(&value)));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITreeView2<D>::SelectedItem() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITreeView2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITreeView2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITreeView2>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_SelectedItem(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITreeView2>**)this;
            check_hresult(_winrt_abi_type->get_SelectedItem(&value));
        }
        return winrt::Windows::Foundation::IInspectable{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITreeView2<D>::SelectedItem(winrt::Windows::Foundation::IInspectable const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITreeView2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITreeView2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITreeView2>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_SelectedItem(*(void**)(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITreeView2>**)this;
            check_hresult(_winrt_abi_type->put_SelectedItem(*(void**)(&value)));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITreeView2<D>::SelectedItems() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITreeView2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITreeView2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITreeView2>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_SelectedItems(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITreeView2>**)this;
            check_hresult(_winrt_abi_type->get_SelectedItems(&value));
        }
        return winrt::Windows::Foundation::Collections::IVector<winrt::Windows::Foundation::IInspectable>{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITreeViewCollapsedEventArgs<D>::Node() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITreeViewCollapsedEventArgs>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITreeViewCollapsedEventArgs, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITreeViewCollapsedEventArgs>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Node(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITreeViewCollapsedEventArgs>**)this;
            check_hresult(_winrt_abi_type->get_Node(&value));
        }
        return winrt::Microsoft::UI::Xaml::Controls::TreeViewNode{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITreeViewCollapsedEventArgs2<D>::Item() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITreeViewCollapsedEventArgs2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITreeViewCollapsedEventArgs2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITreeViewCollapsedEventArgs2>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Item(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITreeViewCollapsedEventArgs2>**)this;
            check_hresult(_winrt_abi_type->get_Item(&value));
        }
        return winrt::Windows::Foundation::IInspectable{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITreeViewDragItemsCompletedEventArgs<D>::DropResult() const
    {
        winrt::Windows::ApplicationModel::DataTransfer::DataPackageOperation value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITreeViewDragItemsCompletedEventArgs>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITreeViewDragItemsCompletedEventArgs, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITreeViewDragItemsCompletedEventArgs>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_DropResult(reinterpret_cast<uint32_t*>(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITreeViewDragItemsCompletedEventArgs>**)this;
            check_hresult(_winrt_abi_type->get_DropResult(reinterpret_cast<uint32_t*>(&value)));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITreeViewDragItemsCompletedEventArgs<D>::Items() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITreeViewDragItemsCompletedEventArgs>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITreeViewDragItemsCompletedEventArgs, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITreeViewDragItemsCompletedEventArgs>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Items(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITreeViewDragItemsCompletedEventArgs>**)this;
            check_hresult(_winrt_abi_type->get_Items(&value));
        }
        return winrt::Windows::Foundation::Collections::IVectorView<winrt::Windows::Foundation::IInspectable>{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITreeViewDragItemsCompletedEventArgs2<D>::NewParentItem() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITreeViewDragItemsCompletedEventArgs2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITreeViewDragItemsCompletedEventArgs2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITreeViewDragItemsCompletedEventArgs2>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_NewParentItem(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITreeViewDragItemsCompletedEventArgs2>**)this;
            check_hresult(_winrt_abi_type->get_NewParentItem(&value));
        }
        return winrt::Windows::Foundation::IInspectable{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITreeViewDragItemsStartingEventArgs<D>::Cancel() const
    {
        bool value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITreeViewDragItemsStartingEventArgs>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITreeViewDragItemsStartingEventArgs, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITreeViewDragItemsStartingEventArgs>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Cancel(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITreeViewDragItemsStartingEventArgs>**)this;
            check_hresult(_winrt_abi_type->get_Cancel(&value));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITreeViewDragItemsStartingEventArgs<D>::Cancel(bool value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITreeViewDragItemsStartingEventArgs>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITreeViewDragItemsStartingEventArgs, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITreeViewDragItemsStartingEventArgs>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_Cancel(value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITreeViewDragItemsStartingEventArgs>**)this;
            check_hresult(_winrt_abi_type->put_Cancel(value));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITreeViewDragItemsStartingEventArgs<D>::Data() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITreeViewDragItemsStartingEventArgs>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITreeViewDragItemsStartingEventArgs, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITreeViewDragItemsStartingEventArgs>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Data(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITreeViewDragItemsStartingEventArgs>**)this;
            check_hresult(_winrt_abi_type->get_Data(&value));
        }
        return winrt::Windows::ApplicationModel::DataTransfer::DataPackage{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITreeViewDragItemsStartingEventArgs<D>::Items() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITreeViewDragItemsStartingEventArgs>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITreeViewDragItemsStartingEventArgs, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITreeViewDragItemsStartingEventArgs>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Items(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITreeViewDragItemsStartingEventArgs>**)this;
            check_hresult(_winrt_abi_type->get_Items(&value));
        }
        return winrt::Windows::Foundation::Collections::IVector<winrt::Windows::Foundation::IInspectable>{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITreeViewExpandingEventArgs<D>::Node() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITreeViewExpandingEventArgs>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITreeViewExpandingEventArgs, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITreeViewExpandingEventArgs>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Node(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITreeViewExpandingEventArgs>**)this;
            check_hresult(_winrt_abi_type->get_Node(&value));
        }
        return winrt::Microsoft::UI::Xaml::Controls::TreeViewNode{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITreeViewExpandingEventArgs2<D>::Item() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITreeViewExpandingEventArgs2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITreeViewExpandingEventArgs2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITreeViewExpandingEventArgs2>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Item(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITreeViewExpandingEventArgs2>**)this;
            check_hresult(_winrt_abi_type->get_Item(&value));
        }
        return winrt::Windows::Foundation::IInspectable{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITreeViewFactory<D>::CreateInstance(winrt::Windows::Foundation::IInspectable const& baseInterface, winrt::Windows::Foundation::IInspectable& innerInterface) const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITreeViewFactory>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITreeViewFactory, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITreeViewFactory>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->CreateInstance(*(void**)(&baseInterface), impl::bind_out(innerInterface), &value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITreeViewFactory>**)this;
            check_hresult(_winrt_abi_type->CreateInstance(*(void**)(&baseInterface), impl::bind_out(innerInterface), &value));
        }
        return winrt::Microsoft::UI::Xaml::Controls::TreeView{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITreeViewItem<D>::GlyphOpacity() const
    {
        double value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITreeViewItem>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITreeViewItem, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITreeViewItem>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_GlyphOpacity(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITreeViewItem>**)this;
            check_hresult(_winrt_abi_type->get_GlyphOpacity(&value));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITreeViewItem<D>::GlyphOpacity(double value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITreeViewItem>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITreeViewItem, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITreeViewItem>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_GlyphOpacity(value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITreeViewItem>**)this;
            check_hresult(_winrt_abi_type->put_GlyphOpacity(value));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITreeViewItem<D>::GlyphBrush() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITreeViewItem>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITreeViewItem, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITreeViewItem>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_GlyphBrush(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITreeViewItem>**)this;
            check_hresult(_winrt_abi_type->get_GlyphBrush(&value));
        }
        return winrt::Windows::UI::Xaml::Media::Brush{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITreeViewItem<D>::GlyphBrush(winrt::Windows::UI::Xaml::Media::Brush const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITreeViewItem>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITreeViewItem, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITreeViewItem>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_GlyphBrush(*(void**)(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITreeViewItem>**)this;
            check_hresult(_winrt_abi_type->put_GlyphBrush(*(void**)(&value)));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITreeViewItem<D>::ExpandedGlyph() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITreeViewItem>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITreeViewItem, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITreeViewItem>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_ExpandedGlyph(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITreeViewItem>**)this;
            check_hresult(_winrt_abi_type->get_ExpandedGlyph(&value));
        }
        return hstring{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITreeViewItem<D>::ExpandedGlyph(param::hstring const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITreeViewItem>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITreeViewItem, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITreeViewItem>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_ExpandedGlyph(*(void**)(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITreeViewItem>**)this;
            check_hresult(_winrt_abi_type->put_ExpandedGlyph(*(void**)(&value)));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITreeViewItem<D>::CollapsedGlyph() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITreeViewItem>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITreeViewItem, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITreeViewItem>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_CollapsedGlyph(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITreeViewItem>**)this;
            check_hresult(_winrt_abi_type->get_CollapsedGlyph(&value));
        }
        return hstring{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITreeViewItem<D>::CollapsedGlyph(param::hstring const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITreeViewItem>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITreeViewItem, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITreeViewItem>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_CollapsedGlyph(*(void**)(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITreeViewItem>**)this;
            check_hresult(_winrt_abi_type->put_CollapsedGlyph(*(void**)(&value)));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITreeViewItem<D>::GlyphSize() const
    {
        double value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITreeViewItem>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITreeViewItem, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITreeViewItem>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_GlyphSize(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITreeViewItem>**)this;
            check_hresult(_winrt_abi_type->get_GlyphSize(&value));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITreeViewItem<D>::GlyphSize(double value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITreeViewItem>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITreeViewItem, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITreeViewItem>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_GlyphSize(value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITreeViewItem>**)this;
            check_hresult(_winrt_abi_type->put_GlyphSize(value));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITreeViewItem<D>::IsExpanded() const
    {
        bool value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITreeViewItem>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITreeViewItem, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITreeViewItem>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_IsExpanded(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITreeViewItem>**)this;
            check_hresult(_winrt_abi_type->get_IsExpanded(&value));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITreeViewItem<D>::IsExpanded(bool value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITreeViewItem>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITreeViewItem, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITreeViewItem>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_IsExpanded(value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITreeViewItem>**)this;
            check_hresult(_winrt_abi_type->put_IsExpanded(value));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITreeViewItem<D>::TreeViewItemTemplateSettings() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITreeViewItem>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITreeViewItem, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITreeViewItem>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_TreeViewItemTemplateSettings(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITreeViewItem>**)this;
            check_hresult(_winrt_abi_type->get_TreeViewItemTemplateSettings(&value));
        }
        return winrt::Microsoft::UI::Xaml::Controls::TreeViewItemTemplateSettings{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITreeViewItem2<D>::HasUnrealizedChildren() const
    {
        bool value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITreeViewItem2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITreeViewItem2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITreeViewItem2>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_HasUnrealizedChildren(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITreeViewItem2>**)this;
            check_hresult(_winrt_abi_type->get_HasUnrealizedChildren(&value));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITreeViewItem2<D>::HasUnrealizedChildren(bool value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITreeViewItem2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITreeViewItem2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITreeViewItem2>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_HasUnrealizedChildren(value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITreeViewItem2>**)this;
            check_hresult(_winrt_abi_type->put_HasUnrealizedChildren(value));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITreeViewItem2<D>::ItemsSource() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITreeViewItem2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITreeViewItem2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITreeViewItem2>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_ItemsSource(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITreeViewItem2>**)this;
            check_hresult(_winrt_abi_type->get_ItemsSource(&value));
        }
        return winrt::Windows::Foundation::IInspectable{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITreeViewItem2<D>::ItemsSource(winrt::Windows::Foundation::IInspectable const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITreeViewItem2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITreeViewItem2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITreeViewItem2>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_ItemsSource(*(void**)(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITreeViewItem2>**)this;
            check_hresult(_winrt_abi_type->put_ItemsSource(*(void**)(&value)));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITreeViewItemFactory<D>::CreateInstance(winrt::Windows::Foundation::IInspectable const& baseInterface, winrt::Windows::Foundation::IInspectable& innerInterface) const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITreeViewItemFactory>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITreeViewItemFactory, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITreeViewItemFactory>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->CreateInstance(*(void**)(&baseInterface), impl::bind_out(innerInterface), &value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITreeViewItemFactory>**)this;
            check_hresult(_winrt_abi_type->CreateInstance(*(void**)(&baseInterface), impl::bind_out(innerInterface), &value));
        }
        return winrt::Microsoft::UI::Xaml::Controls::TreeViewItem{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITreeViewItemInvokedEventArgs<D>::InvokedItem() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITreeViewItemInvokedEventArgs>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITreeViewItemInvokedEventArgs, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITreeViewItemInvokedEventArgs>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_InvokedItem(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITreeViewItemInvokedEventArgs>**)this;
            check_hresult(_winrt_abi_type->get_InvokedItem(&value));
        }
        return winrt::Windows::Foundation::IInspectable{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITreeViewItemInvokedEventArgs<D>::Handled(bool value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITreeViewItemInvokedEventArgs>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITreeViewItemInvokedEventArgs, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITreeViewItemInvokedEventArgs>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_Handled(value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITreeViewItemInvokedEventArgs>**)this;
            check_hresult(_winrt_abi_type->put_Handled(value));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITreeViewItemInvokedEventArgs<D>::Handled() const
    {
        bool value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITreeViewItemInvokedEventArgs>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITreeViewItemInvokedEventArgs, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITreeViewItemInvokedEventArgs>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Handled(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITreeViewItemInvokedEventArgs>**)this;
            check_hresult(_winrt_abi_type->get_Handled(&value));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITreeViewItemStatics<D>::GlyphOpacityProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITreeViewItemStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITreeViewItemStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITreeViewItemStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_GlyphOpacityProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITreeViewItemStatics>**)this;
            check_hresult(_winrt_abi_type->get_GlyphOpacityProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITreeViewItemStatics<D>::GlyphBrushProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITreeViewItemStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITreeViewItemStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITreeViewItemStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_GlyphBrushProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITreeViewItemStatics>**)this;
            check_hresult(_winrt_abi_type->get_GlyphBrushProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITreeViewItemStatics<D>::ExpandedGlyphProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITreeViewItemStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITreeViewItemStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITreeViewItemStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_ExpandedGlyphProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITreeViewItemStatics>**)this;
            check_hresult(_winrt_abi_type->get_ExpandedGlyphProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITreeViewItemStatics<D>::CollapsedGlyphProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITreeViewItemStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITreeViewItemStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITreeViewItemStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_CollapsedGlyphProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITreeViewItemStatics>**)this;
            check_hresult(_winrt_abi_type->get_CollapsedGlyphProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITreeViewItemStatics<D>::GlyphSizeProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITreeViewItemStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITreeViewItemStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITreeViewItemStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_GlyphSizeProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITreeViewItemStatics>**)this;
            check_hresult(_winrt_abi_type->get_GlyphSizeProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITreeViewItemStatics<D>::IsExpandedProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITreeViewItemStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITreeViewItemStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITreeViewItemStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_IsExpandedProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITreeViewItemStatics>**)this;
            check_hresult(_winrt_abi_type->get_IsExpandedProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITreeViewItemStatics<D>::TreeViewItemTemplateSettingsProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITreeViewItemStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITreeViewItemStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITreeViewItemStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_TreeViewItemTemplateSettingsProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITreeViewItemStatics>**)this;
            check_hresult(_winrt_abi_type->get_TreeViewItemTemplateSettingsProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITreeViewItemStatics2<D>::HasUnrealizedChildrenProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITreeViewItemStatics2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITreeViewItemStatics2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITreeViewItemStatics2>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_HasUnrealizedChildrenProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITreeViewItemStatics2>**)this;
            check_hresult(_winrt_abi_type->get_HasUnrealizedChildrenProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITreeViewItemStatics2<D>::ItemsSourceProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITreeViewItemStatics2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITreeViewItemStatics2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITreeViewItemStatics2>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_ItemsSourceProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITreeViewItemStatics2>**)this;
            check_hresult(_winrt_abi_type->get_ItemsSourceProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITreeViewItemTemplateSettings<D>::ExpandedGlyphVisibility() const
    {
        winrt::Windows::UI::Xaml::Visibility value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITreeViewItemTemplateSettings>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITreeViewItemTemplateSettings, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITreeViewItemTemplateSettings>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_ExpandedGlyphVisibility(reinterpret_cast<int32_t*>(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITreeViewItemTemplateSettings>**)this;
            check_hresult(_winrt_abi_type->get_ExpandedGlyphVisibility(reinterpret_cast<int32_t*>(&value)));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITreeViewItemTemplateSettings<D>::CollapsedGlyphVisibility() const
    {
        winrt::Windows::UI::Xaml::Visibility value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITreeViewItemTemplateSettings>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITreeViewItemTemplateSettings, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITreeViewItemTemplateSettings>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_CollapsedGlyphVisibility(reinterpret_cast<int32_t*>(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITreeViewItemTemplateSettings>**)this;
            check_hresult(_winrt_abi_type->get_CollapsedGlyphVisibility(reinterpret_cast<int32_t*>(&value)));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITreeViewItemTemplateSettings<D>::Indentation() const
    {
        winrt::Windows::UI::Xaml::Thickness value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITreeViewItemTemplateSettings>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITreeViewItemTemplateSettings, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITreeViewItemTemplateSettings>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Indentation(put_abi(value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITreeViewItemTemplateSettings>**)this;
            check_hresult(_winrt_abi_type->get_Indentation(put_abi(value)));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITreeViewItemTemplateSettings<D>::DragItemsCount() const
    {
        int32_t value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITreeViewItemTemplateSettings>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITreeViewItemTemplateSettings, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITreeViewItemTemplateSettings>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_DragItemsCount(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITreeViewItemTemplateSettings>**)this;
            check_hresult(_winrt_abi_type->get_DragItemsCount(&value));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITreeViewItemTemplateSettingsFactory<D>::CreateInstance(winrt::Windows::Foundation::IInspectable const& baseInterface, winrt::Windows::Foundation::IInspectable& innerInterface) const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITreeViewItemTemplateSettingsFactory>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITreeViewItemTemplateSettingsFactory, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITreeViewItemTemplateSettingsFactory>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->CreateInstance(*(void**)(&baseInterface), impl::bind_out(innerInterface), &value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITreeViewItemTemplateSettingsFactory>**)this;
            check_hresult(_winrt_abi_type->CreateInstance(*(void**)(&baseInterface), impl::bind_out(innerInterface), &value));
        }
        return winrt::Microsoft::UI::Xaml::Controls::TreeViewItemTemplateSettings{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITreeViewItemTemplateSettingsStatics<D>::ExpandedGlyphVisibilityProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITreeViewItemTemplateSettingsStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITreeViewItemTemplateSettingsStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITreeViewItemTemplateSettingsStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_ExpandedGlyphVisibilityProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITreeViewItemTemplateSettingsStatics>**)this;
            check_hresult(_winrt_abi_type->get_ExpandedGlyphVisibilityProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITreeViewItemTemplateSettingsStatics<D>::CollapsedGlyphVisibilityProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITreeViewItemTemplateSettingsStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITreeViewItemTemplateSettingsStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITreeViewItemTemplateSettingsStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_CollapsedGlyphVisibilityProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITreeViewItemTemplateSettingsStatics>**)this;
            check_hresult(_winrt_abi_type->get_CollapsedGlyphVisibilityProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITreeViewItemTemplateSettingsStatics<D>::IndentationProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITreeViewItemTemplateSettingsStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITreeViewItemTemplateSettingsStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITreeViewItemTemplateSettingsStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_IndentationProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITreeViewItemTemplateSettingsStatics>**)this;
            check_hresult(_winrt_abi_type->get_IndentationProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITreeViewItemTemplateSettingsStatics<D>::DragItemsCountProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITreeViewItemTemplateSettingsStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITreeViewItemTemplateSettingsStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITreeViewItemTemplateSettingsStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_DragItemsCountProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITreeViewItemTemplateSettingsStatics>**)this;
            check_hresult(_winrt_abi_type->get_DragItemsCountProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITreeViewListFactory<D>::CreateInstance(winrt::Windows::Foundation::IInspectable const& baseInterface, winrt::Windows::Foundation::IInspectable& innerInterface) const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITreeViewListFactory>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITreeViewListFactory, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITreeViewListFactory>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->CreateInstance(*(void**)(&baseInterface), impl::bind_out(innerInterface), &value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITreeViewListFactory>**)this;
            check_hresult(_winrt_abi_type->CreateInstance(*(void**)(&baseInterface), impl::bind_out(innerInterface), &value));
        }
        return winrt::Microsoft::UI::Xaml::Controls::TreeViewList{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITreeViewNode<D>::Content() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITreeViewNode>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITreeViewNode, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITreeViewNode>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Content(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITreeViewNode>**)this;
            check_hresult(_winrt_abi_type->get_Content(&value));
        }
        return winrt::Windows::Foundation::IInspectable{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITreeViewNode<D>::Content(winrt::Windows::Foundation::IInspectable const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITreeViewNode>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITreeViewNode, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITreeViewNode>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_Content(*(void**)(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITreeViewNode>**)this;
            check_hresult(_winrt_abi_type->put_Content(*(void**)(&value)));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITreeViewNode<D>::Parent() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITreeViewNode>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITreeViewNode, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITreeViewNode>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Parent(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITreeViewNode>**)this;
            check_hresult(_winrt_abi_type->get_Parent(&value));
        }
        return winrt::Microsoft::UI::Xaml::Controls::TreeViewNode{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITreeViewNode<D>::IsExpanded() const
    {
        bool value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITreeViewNode>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITreeViewNode, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITreeViewNode>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_IsExpanded(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITreeViewNode>**)this;
            check_hresult(_winrt_abi_type->get_IsExpanded(&value));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITreeViewNode<D>::IsExpanded(bool value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITreeViewNode>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITreeViewNode, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITreeViewNode>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_IsExpanded(value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITreeViewNode>**)this;
            check_hresult(_winrt_abi_type->put_IsExpanded(value));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITreeViewNode<D>::HasChildren() const
    {
        bool value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITreeViewNode>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITreeViewNode, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITreeViewNode>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_HasChildren(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITreeViewNode>**)this;
            check_hresult(_winrt_abi_type->get_HasChildren(&value));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITreeViewNode<D>::Depth() const
    {
        int32_t value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITreeViewNode>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITreeViewNode, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITreeViewNode>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Depth(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITreeViewNode>**)this;
            check_hresult(_winrt_abi_type->get_Depth(&value));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITreeViewNode<D>::HasUnrealizedChildren() const
    {
        bool value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITreeViewNode>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITreeViewNode, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITreeViewNode>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_HasUnrealizedChildren(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITreeViewNode>**)this;
            check_hresult(_winrt_abi_type->get_HasUnrealizedChildren(&value));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITreeViewNode<D>::HasUnrealizedChildren(bool value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITreeViewNode>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITreeViewNode, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITreeViewNode>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_HasUnrealizedChildren(value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITreeViewNode>**)this;
            check_hresult(_winrt_abi_type->put_HasUnrealizedChildren(value));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITreeViewNode<D>::Children() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITreeViewNode>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITreeViewNode, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITreeViewNode>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Children(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITreeViewNode>**)this;
            check_hresult(_winrt_abi_type->get_Children(&value));
        }
        return winrt::Windows::Foundation::Collections::IVector<winrt::Microsoft::UI::Xaml::Controls::TreeViewNode>{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITreeViewNodeFactory<D>::CreateInstance(winrt::Windows::Foundation::IInspectable const& baseInterface, winrt::Windows::Foundation::IInspectable& innerInterface) const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITreeViewNodeFactory>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITreeViewNodeFactory, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITreeViewNodeFactory>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->CreateInstance(*(void**)(&baseInterface), impl::bind_out(innerInterface), &value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITreeViewNodeFactory>**)this;
            check_hresult(_winrt_abi_type->CreateInstance(*(void**)(&baseInterface), impl::bind_out(innerInterface), &value));
        }
        return winrt::Microsoft::UI::Xaml::Controls::TreeViewNode{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITreeViewNodeStatics<D>::ContentProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITreeViewNodeStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITreeViewNodeStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITreeViewNodeStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_ContentProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITreeViewNodeStatics>**)this;
            check_hresult(_winrt_abi_type->get_ContentProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITreeViewNodeStatics<D>::DepthProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITreeViewNodeStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITreeViewNodeStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITreeViewNodeStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_DepthProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITreeViewNodeStatics>**)this;
            check_hresult(_winrt_abi_type->get_DepthProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITreeViewNodeStatics<D>::IsExpandedProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITreeViewNodeStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITreeViewNodeStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITreeViewNodeStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_IsExpandedProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITreeViewNodeStatics>**)this;
            check_hresult(_winrt_abi_type->get_IsExpandedProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITreeViewNodeStatics<D>::HasChildrenProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITreeViewNodeStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITreeViewNodeStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITreeViewNodeStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_HasChildrenProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITreeViewNodeStatics>**)this;
            check_hresult(_winrt_abi_type->get_HasChildrenProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITreeViewStatics<D>::SelectedItemProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITreeViewStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITreeViewStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITreeViewStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_SelectedItemProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITreeViewStatics>**)this;
            check_hresult(_winrt_abi_type->get_SelectedItemProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITreeViewStatics<D>::SelectionModeProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITreeViewStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITreeViewStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITreeViewStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_SelectionModeProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITreeViewStatics>**)this;
            check_hresult(_winrt_abi_type->get_SelectionModeProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITreeViewStatics2<D>::CanDragItemsProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITreeViewStatics2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITreeViewStatics2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITreeViewStatics2>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_CanDragItemsProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITreeViewStatics2>**)this;
            check_hresult(_winrt_abi_type->get_CanDragItemsProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITreeViewStatics2<D>::CanReorderItemsProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITreeViewStatics2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITreeViewStatics2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITreeViewStatics2>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_CanReorderItemsProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITreeViewStatics2>**)this;
            check_hresult(_winrt_abi_type->get_CanReorderItemsProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITreeViewStatics2<D>::ItemTemplateProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITreeViewStatics2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITreeViewStatics2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITreeViewStatics2>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_ItemTemplateProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITreeViewStatics2>**)this;
            check_hresult(_winrt_abi_type->get_ItemTemplateProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITreeViewStatics2<D>::ItemTemplateSelectorProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITreeViewStatics2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITreeViewStatics2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITreeViewStatics2>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_ItemTemplateSelectorProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITreeViewStatics2>**)this;
            check_hresult(_winrt_abi_type->get_ItemTemplateSelectorProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITreeViewStatics2<D>::ItemContainerStyleProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITreeViewStatics2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITreeViewStatics2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITreeViewStatics2>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_ItemContainerStyleProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITreeViewStatics2>**)this;
            check_hresult(_winrt_abi_type->get_ItemContainerStyleProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITreeViewStatics2<D>::ItemContainerStyleSelectorProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITreeViewStatics2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITreeViewStatics2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITreeViewStatics2>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_ItemContainerStyleSelectorProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITreeViewStatics2>**)this;
            check_hresult(_winrt_abi_type->get_ItemContainerStyleSelectorProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITreeViewStatics2<D>::ItemContainerTransitionsProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITreeViewStatics2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITreeViewStatics2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITreeViewStatics2>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_ItemContainerTransitionsProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITreeViewStatics2>**)this;
            check_hresult(_winrt_abi_type->get_ItemContainerTransitionsProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITreeViewStatics2<D>::ItemsSourceProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITreeViewStatics2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITreeViewStatics2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITreeViewStatics2>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_ItemsSourceProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITreeViewStatics2>**)this;
            check_hresult(_winrt_abi_type->get_ItemsSourceProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITwoPaneView<D>::Pane1() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITwoPaneView>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITwoPaneView, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITwoPaneView>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Pane1(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITwoPaneView>**)this;
            check_hresult(_winrt_abi_type->get_Pane1(&value));
        }
        return winrt::Windows::UI::Xaml::UIElement{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITwoPaneView<D>::Pane1(winrt::Windows::UI::Xaml::UIElement const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITwoPaneView>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITwoPaneView, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITwoPaneView>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_Pane1(*(void**)(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITwoPaneView>**)this;
            check_hresult(_winrt_abi_type->put_Pane1(*(void**)(&value)));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITwoPaneView<D>::Pane2() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITwoPaneView>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITwoPaneView, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITwoPaneView>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Pane2(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITwoPaneView>**)this;
            check_hresult(_winrt_abi_type->get_Pane2(&value));
        }
        return winrt::Windows::UI::Xaml::UIElement{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITwoPaneView<D>::Pane2(winrt::Windows::UI::Xaml::UIElement const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITwoPaneView>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITwoPaneView, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITwoPaneView>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_Pane2(*(void**)(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITwoPaneView>**)this;
            check_hresult(_winrt_abi_type->put_Pane2(*(void**)(&value)));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITwoPaneView<D>::Pane1Length() const
    {
        winrt::Windows::UI::Xaml::GridLength value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITwoPaneView>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITwoPaneView, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITwoPaneView>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Pane1Length(put_abi(value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITwoPaneView>**)this;
            check_hresult(_winrt_abi_type->get_Pane1Length(put_abi(value)));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITwoPaneView<D>::Pane1Length(winrt::Windows::UI::Xaml::GridLength const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITwoPaneView>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITwoPaneView, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITwoPaneView>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_Pane1Length(impl::bind_in(value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITwoPaneView>**)this;
            check_hresult(_winrt_abi_type->put_Pane1Length(impl::bind_in(value)));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITwoPaneView<D>::Pane2Length() const
    {
        winrt::Windows::UI::Xaml::GridLength value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITwoPaneView>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITwoPaneView, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITwoPaneView>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Pane2Length(put_abi(value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITwoPaneView>**)this;
            check_hresult(_winrt_abi_type->get_Pane2Length(put_abi(value)));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITwoPaneView<D>::Pane2Length(winrt::Windows::UI::Xaml::GridLength const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITwoPaneView>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITwoPaneView, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITwoPaneView>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_Pane2Length(impl::bind_in(value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITwoPaneView>**)this;
            check_hresult(_winrt_abi_type->put_Pane2Length(impl::bind_in(value)));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITwoPaneView<D>::PanePriority() const
    {
        winrt::Microsoft::UI::Xaml::Controls::TwoPaneViewPriority value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITwoPaneView>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITwoPaneView, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITwoPaneView>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_PanePriority(reinterpret_cast<int32_t*>(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITwoPaneView>**)this;
            check_hresult(_winrt_abi_type->get_PanePriority(reinterpret_cast<int32_t*>(&value)));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITwoPaneView<D>::PanePriority(winrt::Microsoft::UI::Xaml::Controls::TwoPaneViewPriority const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITwoPaneView>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITwoPaneView, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITwoPaneView>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_PanePriority(static_cast<int32_t>(value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITwoPaneView>**)this;
            check_hresult(_winrt_abi_type->put_PanePriority(static_cast<int32_t>(value)));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITwoPaneView<D>::Mode() const
    {
        winrt::Microsoft::UI::Xaml::Controls::TwoPaneViewMode value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITwoPaneView>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITwoPaneView, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITwoPaneView>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Mode(reinterpret_cast<int32_t*>(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITwoPaneView>**)this;
            check_hresult(_winrt_abi_type->get_Mode(reinterpret_cast<int32_t*>(&value)));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITwoPaneView<D>::WideModeConfiguration() const
    {
        winrt::Microsoft::UI::Xaml::Controls::TwoPaneViewWideModeConfiguration value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITwoPaneView>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITwoPaneView, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITwoPaneView>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_WideModeConfiguration(reinterpret_cast<int32_t*>(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITwoPaneView>**)this;
            check_hresult(_winrt_abi_type->get_WideModeConfiguration(reinterpret_cast<int32_t*>(&value)));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITwoPaneView<D>::WideModeConfiguration(winrt::Microsoft::UI::Xaml::Controls::TwoPaneViewWideModeConfiguration const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITwoPaneView>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITwoPaneView, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITwoPaneView>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_WideModeConfiguration(static_cast<int32_t>(value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITwoPaneView>**)this;
            check_hresult(_winrt_abi_type->put_WideModeConfiguration(static_cast<int32_t>(value)));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITwoPaneView<D>::TallModeConfiguration() const
    {
        winrt::Microsoft::UI::Xaml::Controls::TwoPaneViewTallModeConfiguration value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITwoPaneView>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITwoPaneView, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITwoPaneView>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_TallModeConfiguration(reinterpret_cast<int32_t*>(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITwoPaneView>**)this;
            check_hresult(_winrt_abi_type->get_TallModeConfiguration(reinterpret_cast<int32_t*>(&value)));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITwoPaneView<D>::TallModeConfiguration(winrt::Microsoft::UI::Xaml::Controls::TwoPaneViewTallModeConfiguration const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITwoPaneView>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITwoPaneView, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITwoPaneView>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_TallModeConfiguration(static_cast<int32_t>(value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITwoPaneView>**)this;
            check_hresult(_winrt_abi_type->put_TallModeConfiguration(static_cast<int32_t>(value)));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITwoPaneView<D>::MinWideModeWidth() const
    {
        double value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITwoPaneView>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITwoPaneView, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITwoPaneView>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_MinWideModeWidth(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITwoPaneView>**)this;
            check_hresult(_winrt_abi_type->get_MinWideModeWidth(&value));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITwoPaneView<D>::MinWideModeWidth(double value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITwoPaneView>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITwoPaneView, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITwoPaneView>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_MinWideModeWidth(value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITwoPaneView>**)this;
            check_hresult(_winrt_abi_type->put_MinWideModeWidth(value));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITwoPaneView<D>::MinTallModeHeight() const
    {
        double value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITwoPaneView>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITwoPaneView, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITwoPaneView>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_MinTallModeHeight(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITwoPaneView>**)this;
            check_hresult(_winrt_abi_type->get_MinTallModeHeight(&value));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITwoPaneView<D>::MinTallModeHeight(double value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITwoPaneView>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITwoPaneView, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITwoPaneView>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_MinTallModeHeight(value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITwoPaneView>**)this;
            check_hresult(_winrt_abi_type->put_MinTallModeHeight(value));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITwoPaneView<D>::ModeChanged(winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Xaml::Controls::TwoPaneView, winrt::Windows::Foundation::IInspectable> const& handler) const
    {
        winrt::event_token token{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITwoPaneView>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITwoPaneView, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITwoPaneView>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->add_ModeChanged(*(void**)(&handler), put_abi(token)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITwoPaneView>**)this;
            check_hresult(_winrt_abi_type->add_ModeChanged(*(void**)(&handler), put_abi(token)));
        }
        return token;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITwoPaneView<D>::ModeChanged(auto_revoke_t, winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Xaml::Controls::TwoPaneView, winrt::Windows::Foundation::IInspectable> const& handler) const
    {
        return impl::make_event_revoker<D, ModeChanged_revoker>(this, ModeChanged(handler));
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITwoPaneView<D>::ModeChanged(winrt::event_token const& token) const noexcept
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITwoPaneView>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITwoPaneView, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITwoPaneView>**)&_winrt_casted_result;
            _winrt_abi_type->remove_ModeChanged(impl::bind_in(token));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITwoPaneView>**)this;
            _winrt_abi_type->remove_ModeChanged(impl::bind_in(token));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITwoPaneViewFactory<D>::CreateInstance(winrt::Windows::Foundation::IInspectable const& baseInterface, winrt::Windows::Foundation::IInspectable& innerInterface) const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITwoPaneViewFactory>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITwoPaneViewFactory, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITwoPaneViewFactory>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->CreateInstance(*(void**)(&baseInterface), impl::bind_out(innerInterface), &value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITwoPaneViewFactory>**)this;
            check_hresult(_winrt_abi_type->CreateInstance(*(void**)(&baseInterface), impl::bind_out(innerInterface), &value));
        }
        return winrt::Microsoft::UI::Xaml::Controls::TwoPaneView{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITwoPaneViewStatics<D>::Pane1Property() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITwoPaneViewStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITwoPaneViewStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITwoPaneViewStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Pane1Property(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITwoPaneViewStatics>**)this;
            check_hresult(_winrt_abi_type->get_Pane1Property(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITwoPaneViewStatics<D>::Pane2Property() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITwoPaneViewStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITwoPaneViewStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITwoPaneViewStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Pane2Property(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITwoPaneViewStatics>**)this;
            check_hresult(_winrt_abi_type->get_Pane2Property(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITwoPaneViewStatics<D>::Pane1LengthProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITwoPaneViewStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITwoPaneViewStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITwoPaneViewStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Pane1LengthProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITwoPaneViewStatics>**)this;
            check_hresult(_winrt_abi_type->get_Pane1LengthProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITwoPaneViewStatics<D>::Pane2LengthProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITwoPaneViewStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITwoPaneViewStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITwoPaneViewStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Pane2LengthProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITwoPaneViewStatics>**)this;
            check_hresult(_winrt_abi_type->get_Pane2LengthProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITwoPaneViewStatics<D>::PanePriorityProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITwoPaneViewStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITwoPaneViewStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITwoPaneViewStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_PanePriorityProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITwoPaneViewStatics>**)this;
            check_hresult(_winrt_abi_type->get_PanePriorityProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITwoPaneViewStatics<D>::ModeProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITwoPaneViewStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITwoPaneViewStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITwoPaneViewStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_ModeProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITwoPaneViewStatics>**)this;
            check_hresult(_winrt_abi_type->get_ModeProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITwoPaneViewStatics<D>::WideModeConfigurationProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITwoPaneViewStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITwoPaneViewStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITwoPaneViewStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_WideModeConfigurationProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITwoPaneViewStatics>**)this;
            check_hresult(_winrt_abi_type->get_WideModeConfigurationProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITwoPaneViewStatics<D>::TallModeConfigurationProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITwoPaneViewStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITwoPaneViewStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITwoPaneViewStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_TallModeConfigurationProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITwoPaneViewStatics>**)this;
            check_hresult(_winrt_abi_type->get_TallModeConfigurationProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITwoPaneViewStatics<D>::MinWideModeWidthProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITwoPaneViewStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITwoPaneViewStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITwoPaneViewStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_MinWideModeWidthProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITwoPaneViewStatics>**)this;
            check_hresult(_winrt_abi_type->get_MinWideModeWidthProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_ITwoPaneViewStatics<D>::MinTallModeHeightProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::ITwoPaneViewStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::ITwoPaneViewStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITwoPaneViewStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_MinTallModeHeightProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::ITwoPaneViewStatics>**)this;
            check_hresult(_winrt_abi_type->get_MinTallModeHeightProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IUniformGridLayout<D>::Orientation() const
    {
        winrt::Windows::UI::Xaml::Controls::Orientation value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IUniformGridLayout>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IUniformGridLayout, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IUniformGridLayout>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Orientation(reinterpret_cast<int32_t*>(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IUniformGridLayout>**)this;
            check_hresult(_winrt_abi_type->get_Orientation(reinterpret_cast<int32_t*>(&value)));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IUniformGridLayout<D>::Orientation(winrt::Windows::UI::Xaml::Controls::Orientation const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IUniformGridLayout>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IUniformGridLayout, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IUniformGridLayout>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_Orientation(static_cast<int32_t>(value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IUniformGridLayout>**)this;
            check_hresult(_winrt_abi_type->put_Orientation(static_cast<int32_t>(value)));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IUniformGridLayout<D>::MinItemWidth() const
    {
        double value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IUniformGridLayout>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IUniformGridLayout, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IUniformGridLayout>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_MinItemWidth(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IUniformGridLayout>**)this;
            check_hresult(_winrt_abi_type->get_MinItemWidth(&value));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IUniformGridLayout<D>::MinItemWidth(double value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IUniformGridLayout>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IUniformGridLayout, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IUniformGridLayout>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_MinItemWidth(value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IUniformGridLayout>**)this;
            check_hresult(_winrt_abi_type->put_MinItemWidth(value));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IUniformGridLayout<D>::MinItemHeight() const
    {
        double value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IUniformGridLayout>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IUniformGridLayout, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IUniformGridLayout>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_MinItemHeight(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IUniformGridLayout>**)this;
            check_hresult(_winrt_abi_type->get_MinItemHeight(&value));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IUniformGridLayout<D>::MinItemHeight(double value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IUniformGridLayout>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IUniformGridLayout, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IUniformGridLayout>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_MinItemHeight(value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IUniformGridLayout>**)this;
            check_hresult(_winrt_abi_type->put_MinItemHeight(value));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IUniformGridLayout<D>::MinRowSpacing() const
    {
        double value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IUniformGridLayout>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IUniformGridLayout, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IUniformGridLayout>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_MinRowSpacing(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IUniformGridLayout>**)this;
            check_hresult(_winrt_abi_type->get_MinRowSpacing(&value));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IUniformGridLayout<D>::MinRowSpacing(double value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IUniformGridLayout>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IUniformGridLayout, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IUniformGridLayout>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_MinRowSpacing(value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IUniformGridLayout>**)this;
            check_hresult(_winrt_abi_type->put_MinRowSpacing(value));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IUniformGridLayout<D>::MinColumnSpacing() const
    {
        double value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IUniformGridLayout>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IUniformGridLayout, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IUniformGridLayout>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_MinColumnSpacing(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IUniformGridLayout>**)this;
            check_hresult(_winrt_abi_type->get_MinColumnSpacing(&value));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IUniformGridLayout<D>::MinColumnSpacing(double value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IUniformGridLayout>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IUniformGridLayout, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IUniformGridLayout>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_MinColumnSpacing(value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IUniformGridLayout>**)this;
            check_hresult(_winrt_abi_type->put_MinColumnSpacing(value));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IUniformGridLayout<D>::ItemsJustification() const
    {
        winrt::Microsoft::UI::Xaml::Controls::UniformGridLayoutItemsJustification value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IUniformGridLayout>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IUniformGridLayout, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IUniformGridLayout>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_ItemsJustification(reinterpret_cast<int32_t*>(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IUniformGridLayout>**)this;
            check_hresult(_winrt_abi_type->get_ItemsJustification(reinterpret_cast<int32_t*>(&value)));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IUniformGridLayout<D>::ItemsJustification(winrt::Microsoft::UI::Xaml::Controls::UniformGridLayoutItemsJustification const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IUniformGridLayout>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IUniformGridLayout, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IUniformGridLayout>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_ItemsJustification(static_cast<int32_t>(value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IUniformGridLayout>**)this;
            check_hresult(_winrt_abi_type->put_ItemsJustification(static_cast<int32_t>(value)));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IUniformGridLayout<D>::ItemsStretch() const
    {
        winrt::Microsoft::UI::Xaml::Controls::UniformGridLayoutItemsStretch value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IUniformGridLayout>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IUniformGridLayout, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IUniformGridLayout>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_ItemsStretch(reinterpret_cast<int32_t*>(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IUniformGridLayout>**)this;
            check_hresult(_winrt_abi_type->get_ItemsStretch(reinterpret_cast<int32_t*>(&value)));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IUniformGridLayout<D>::ItemsStretch(winrt::Microsoft::UI::Xaml::Controls::UniformGridLayoutItemsStretch const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IUniformGridLayout>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IUniformGridLayout, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IUniformGridLayout>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_ItemsStretch(static_cast<int32_t>(value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IUniformGridLayout>**)this;
            check_hresult(_winrt_abi_type->put_ItemsStretch(static_cast<int32_t>(value)));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IUniformGridLayout<D>::MaximumRowsOrColumns() const
    {
        int32_t value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IUniformGridLayout>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IUniformGridLayout, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IUniformGridLayout>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_MaximumRowsOrColumns(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IUniformGridLayout>**)this;
            check_hresult(_winrt_abi_type->get_MaximumRowsOrColumns(&value));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IUniformGridLayout<D>::MaximumRowsOrColumns(int32_t value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IUniformGridLayout>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IUniformGridLayout, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IUniformGridLayout>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_MaximumRowsOrColumns(value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IUniformGridLayout>**)this;
            check_hresult(_winrt_abi_type->put_MaximumRowsOrColumns(value));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IUniformGridLayoutFactory<D>::CreateInstance(winrt::Windows::Foundation::IInspectable const& baseInterface, winrt::Windows::Foundation::IInspectable& innerInterface) const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IUniformGridLayoutFactory>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IUniformGridLayoutFactory, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IUniformGridLayoutFactory>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->CreateInstance(*(void**)(&baseInterface), impl::bind_out(innerInterface), &value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IUniformGridLayoutFactory>**)this;
            check_hresult(_winrt_abi_type->CreateInstance(*(void**)(&baseInterface), impl::bind_out(innerInterface), &value));
        }
        return winrt::Microsoft::UI::Xaml::Controls::UniformGridLayout{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IUniformGridLayoutStatics<D>::OrientationProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IUniformGridLayoutStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IUniformGridLayoutStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IUniformGridLayoutStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_OrientationProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IUniformGridLayoutStatics>**)this;
            check_hresult(_winrt_abi_type->get_OrientationProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IUniformGridLayoutStatics<D>::MinItemWidthProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IUniformGridLayoutStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IUniformGridLayoutStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IUniformGridLayoutStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_MinItemWidthProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IUniformGridLayoutStatics>**)this;
            check_hresult(_winrt_abi_type->get_MinItemWidthProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IUniformGridLayoutStatics<D>::MinItemHeightProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IUniformGridLayoutStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IUniformGridLayoutStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IUniformGridLayoutStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_MinItemHeightProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IUniformGridLayoutStatics>**)this;
            check_hresult(_winrt_abi_type->get_MinItemHeightProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IUniformGridLayoutStatics<D>::MinRowSpacingProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IUniformGridLayoutStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IUniformGridLayoutStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IUniformGridLayoutStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_MinRowSpacingProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IUniformGridLayoutStatics>**)this;
            check_hresult(_winrt_abi_type->get_MinRowSpacingProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IUniformGridLayoutStatics<D>::MinColumnSpacingProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IUniformGridLayoutStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IUniformGridLayoutStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IUniformGridLayoutStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_MinColumnSpacingProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IUniformGridLayoutStatics>**)this;
            check_hresult(_winrt_abi_type->get_MinColumnSpacingProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IUniformGridLayoutStatics<D>::ItemsJustificationProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IUniformGridLayoutStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IUniformGridLayoutStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IUniformGridLayoutStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_ItemsJustificationProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IUniformGridLayoutStatics>**)this;
            check_hresult(_winrt_abi_type->get_ItemsJustificationProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IUniformGridLayoutStatics<D>::ItemsStretchProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IUniformGridLayoutStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IUniformGridLayoutStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IUniformGridLayoutStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_ItemsStretchProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IUniformGridLayoutStatics>**)this;
            check_hresult(_winrt_abi_type->get_ItemsStretchProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IUniformGridLayoutStatics<D>::MaximumRowsOrColumnsProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IUniformGridLayoutStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IUniformGridLayoutStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IUniformGridLayoutStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_MaximumRowsOrColumnsProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IUniformGridLayoutStatics>**)this;
            check_hresult(_winrt_abi_type->get_MaximumRowsOrColumnsProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IVirtualizingLayoutContext<D>::ItemCount() const
    {
        int32_t value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IVirtualizingLayoutContext>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IVirtualizingLayoutContext, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IVirtualizingLayoutContext>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_ItemCount(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IVirtualizingLayoutContext>**)this;
            check_hresult(_winrt_abi_type->get_ItemCount(&value));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IVirtualizingLayoutContext<D>::GetItemAt(int32_t index) const
    {
        void* result{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IVirtualizingLayoutContext>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IVirtualizingLayoutContext, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IVirtualizingLayoutContext>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->GetItemAt(index, &result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IVirtualizingLayoutContext>**)this;
            check_hresult(_winrt_abi_type->GetItemAt(index, &result));
        }
        return winrt::Windows::Foundation::IInspectable{ result, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IVirtualizingLayoutContext<D>::RealizationRect() const
    {
        winrt::Windows::Foundation::Rect value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IVirtualizingLayoutContext>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IVirtualizingLayoutContext, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IVirtualizingLayoutContext>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_RealizationRect(put_abi(value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IVirtualizingLayoutContext>**)this;
            check_hresult(_winrt_abi_type->get_RealizationRect(put_abi(value)));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IVirtualizingLayoutContext<D>::GetOrCreateElementAt(int32_t index) const
    {
        void* result{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IVirtualizingLayoutContext>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IVirtualizingLayoutContext, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IVirtualizingLayoutContext>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->GetOrCreateElementAt(index, &result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IVirtualizingLayoutContext>**)this;
            check_hresult(_winrt_abi_type->GetOrCreateElementAt(index, &result));
        }
        return winrt::Windows::UI::Xaml::UIElement{ result, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IVirtualizingLayoutContext<D>::GetOrCreateElementAt(int32_t index, winrt::Microsoft::UI::Xaml::Controls::ElementRealizationOptions const& options) const
    {
        void* result{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IVirtualizingLayoutContext>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IVirtualizingLayoutContext, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IVirtualizingLayoutContext>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->GetOrCreateElementAt2(index, static_cast<uint32_t>(options), &result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IVirtualizingLayoutContext>**)this;
            check_hresult(_winrt_abi_type->GetOrCreateElementAt2(index, static_cast<uint32_t>(options), &result));
        }
        return winrt::Windows::UI::Xaml::UIElement{ result, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IVirtualizingLayoutContext<D>::RecycleElement(winrt::Windows::UI::Xaml::UIElement const& element) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IVirtualizingLayoutContext>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IVirtualizingLayoutContext, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IVirtualizingLayoutContext>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->RecycleElement(*(void**)(&element)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IVirtualizingLayoutContext>**)this;
            check_hresult(_winrt_abi_type->RecycleElement(*(void**)(&element)));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IVirtualizingLayoutContext<D>::RecommendedAnchorIndex() const
    {
        int32_t value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IVirtualizingLayoutContext>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IVirtualizingLayoutContext, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IVirtualizingLayoutContext>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_RecommendedAnchorIndex(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IVirtualizingLayoutContext>**)this;
            check_hresult(_winrt_abi_type->get_RecommendedAnchorIndex(&value));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IVirtualizingLayoutContext<D>::LayoutOrigin() const
    {
        winrt::Windows::Foundation::Point value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IVirtualizingLayoutContext>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IVirtualizingLayoutContext, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IVirtualizingLayoutContext>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_LayoutOrigin(put_abi(value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IVirtualizingLayoutContext>**)this;
            check_hresult(_winrt_abi_type->get_LayoutOrigin(put_abi(value)));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IVirtualizingLayoutContext<D>::LayoutOrigin(winrt::Windows::Foundation::Point const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IVirtualizingLayoutContext>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IVirtualizingLayoutContext, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IVirtualizingLayoutContext>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_LayoutOrigin(impl::bind_in(value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IVirtualizingLayoutContext>**)this;
            check_hresult(_winrt_abi_type->put_LayoutOrigin(impl::bind_in(value)));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IVirtualizingLayoutContextFactory<D>::CreateInstance(winrt::Windows::Foundation::IInspectable const& baseInterface, winrt::Windows::Foundation::IInspectable& innerInterface) const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IVirtualizingLayoutContextFactory>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IVirtualizingLayoutContextFactory, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IVirtualizingLayoutContextFactory>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->CreateInstance(*(void**)(&baseInterface), impl::bind_out(innerInterface), &value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IVirtualizingLayoutContextFactory>**)this;
            check_hresult(_winrt_abi_type->CreateInstance(*(void**)(&baseInterface), impl::bind_out(innerInterface), &value));
        }
        return winrt::Microsoft::UI::Xaml::Controls::VirtualizingLayoutContext{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IVirtualizingLayoutContextOverrides<D>::ItemCountCore() const
    {
        int32_t result{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IVirtualizingLayoutContextOverrides>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IVirtualizingLayoutContextOverrides, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IVirtualizingLayoutContextOverrides>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->ItemCountCore(&result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IVirtualizingLayoutContextOverrides>**)this;
            check_hresult(_winrt_abi_type->ItemCountCore(&result));
        }
        return result;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IVirtualizingLayoutContextOverrides<D>::GetItemAtCore(int32_t index) const
    {
        void* result{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IVirtualizingLayoutContextOverrides>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IVirtualizingLayoutContextOverrides, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IVirtualizingLayoutContextOverrides>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->GetItemAtCore(index, &result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IVirtualizingLayoutContextOverrides>**)this;
            check_hresult(_winrt_abi_type->GetItemAtCore(index, &result));
        }
        return winrt::Windows::Foundation::IInspectable{ result, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IVirtualizingLayoutContextOverrides<D>::RealizationRectCore() const
    {
        winrt::Windows::Foundation::Rect result{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IVirtualizingLayoutContextOverrides>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IVirtualizingLayoutContextOverrides, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IVirtualizingLayoutContextOverrides>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->RealizationRectCore(put_abi(result)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IVirtualizingLayoutContextOverrides>**)this;
            check_hresult(_winrt_abi_type->RealizationRectCore(put_abi(result)));
        }
        return result;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IVirtualizingLayoutContextOverrides<D>::GetOrCreateElementAtCore(int32_t index, winrt::Microsoft::UI::Xaml::Controls::ElementRealizationOptions const& options) const
    {
        void* result{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IVirtualizingLayoutContextOverrides>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IVirtualizingLayoutContextOverrides, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IVirtualizingLayoutContextOverrides>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->GetOrCreateElementAtCore(index, static_cast<uint32_t>(options), &result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IVirtualizingLayoutContextOverrides>**)this;
            check_hresult(_winrt_abi_type->GetOrCreateElementAtCore(index, static_cast<uint32_t>(options), &result));
        }
        return winrt::Windows::UI::Xaml::UIElement{ result, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IVirtualizingLayoutContextOverrides<D>::RecycleElementCore(winrt::Windows::UI::Xaml::UIElement const& element) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IVirtualizingLayoutContextOverrides>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IVirtualizingLayoutContextOverrides, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IVirtualizingLayoutContextOverrides>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->RecycleElementCore(*(void**)(&element)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IVirtualizingLayoutContextOverrides>**)this;
            check_hresult(_winrt_abi_type->RecycleElementCore(*(void**)(&element)));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IVirtualizingLayoutContextOverrides<D>::RecommendedAnchorIndexCore() const
    {
        int32_t value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IVirtualizingLayoutContextOverrides>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IVirtualizingLayoutContextOverrides, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IVirtualizingLayoutContextOverrides>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_RecommendedAnchorIndexCore(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IVirtualizingLayoutContextOverrides>**)this;
            check_hresult(_winrt_abi_type->get_RecommendedAnchorIndexCore(&value));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IVirtualizingLayoutContextOverrides<D>::LayoutOriginCore() const
    {
        winrt::Windows::Foundation::Point value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IVirtualizingLayoutContextOverrides>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IVirtualizingLayoutContextOverrides, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IVirtualizingLayoutContextOverrides>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_LayoutOriginCore(put_abi(value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IVirtualizingLayoutContextOverrides>**)this;
            check_hresult(_winrt_abi_type->get_LayoutOriginCore(put_abi(value)));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IVirtualizingLayoutContextOverrides<D>::LayoutOriginCore(winrt::Windows::Foundation::Point const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IVirtualizingLayoutContextOverrides>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IVirtualizingLayoutContextOverrides, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IVirtualizingLayoutContextOverrides>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_LayoutOriginCore(impl::bind_in(value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IVirtualizingLayoutContextOverrides>**)this;
            check_hresult(_winrt_abi_type->put_LayoutOriginCore(impl::bind_in(value)));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IVirtualizingLayoutFactory<D>::CreateInstance(winrt::Windows::Foundation::IInspectable const& baseInterface, winrt::Windows::Foundation::IInspectable& innerInterface) const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IVirtualizingLayoutFactory>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IVirtualizingLayoutFactory, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IVirtualizingLayoutFactory>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->CreateInstance(*(void**)(&baseInterface), impl::bind_out(innerInterface), &value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IVirtualizingLayoutFactory>**)this;
            check_hresult(_winrt_abi_type->CreateInstance(*(void**)(&baseInterface), impl::bind_out(innerInterface), &value));
        }
        return winrt::Microsoft::UI::Xaml::Controls::VirtualizingLayout{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IVirtualizingLayoutOverrides<D>::InitializeForContextCore(winrt::Microsoft::UI::Xaml::Controls::VirtualizingLayoutContext const& context) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IVirtualizingLayoutOverrides>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IVirtualizingLayoutOverrides, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IVirtualizingLayoutOverrides>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->InitializeForContextCore(*(void**)(&context)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IVirtualizingLayoutOverrides>**)this;
            check_hresult(_winrt_abi_type->InitializeForContextCore(*(void**)(&context)));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IVirtualizingLayoutOverrides<D>::UninitializeForContextCore(winrt::Microsoft::UI::Xaml::Controls::VirtualizingLayoutContext const& context) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IVirtualizingLayoutOverrides>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IVirtualizingLayoutOverrides, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IVirtualizingLayoutOverrides>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->UninitializeForContextCore(*(void**)(&context)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IVirtualizingLayoutOverrides>**)this;
            check_hresult(_winrt_abi_type->UninitializeForContextCore(*(void**)(&context)));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IVirtualizingLayoutOverrides<D>::MeasureOverride(winrt::Microsoft::UI::Xaml::Controls::VirtualizingLayoutContext const& context, winrt::Windows::Foundation::Size const& availableSize) const
    {
        winrt::Windows::Foundation::Size result{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IVirtualizingLayoutOverrides>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IVirtualizingLayoutOverrides, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IVirtualizingLayoutOverrides>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->MeasureOverride(*(void**)(&context), impl::bind_in(availableSize), put_abi(result)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IVirtualizingLayoutOverrides>**)this;
            check_hresult(_winrt_abi_type->MeasureOverride(*(void**)(&context), impl::bind_in(availableSize), put_abi(result)));
        }
        return result;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IVirtualizingLayoutOverrides<D>::ArrangeOverride(winrt::Microsoft::UI::Xaml::Controls::VirtualizingLayoutContext const& context, winrt::Windows::Foundation::Size const& finalSize) const
    {
        winrt::Windows::Foundation::Size result{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IVirtualizingLayoutOverrides>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IVirtualizingLayoutOverrides, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IVirtualizingLayoutOverrides>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->ArrangeOverride(*(void**)(&context), impl::bind_in(finalSize), put_abi(result)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IVirtualizingLayoutOverrides>**)this;
            check_hresult(_winrt_abi_type->ArrangeOverride(*(void**)(&context), impl::bind_in(finalSize), put_abi(result)));
        }
        return result;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IVirtualizingLayoutOverrides<D>::OnItemsChangedCore(winrt::Microsoft::UI::Xaml::Controls::VirtualizingLayoutContext const& context, winrt::Windows::Foundation::IInspectable const& source, winrt::Windows::UI::Xaml::Interop::NotifyCollectionChangedEventArgs const& args) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IVirtualizingLayoutOverrides>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IVirtualizingLayoutOverrides, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IVirtualizingLayoutOverrides>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->OnItemsChangedCore(*(void**)(&context), *(void**)(&source), *(void**)(&args)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IVirtualizingLayoutOverrides>**)this;
            check_hresult(_winrt_abi_type->OnItemsChangedCore(*(void**)(&context), *(void**)(&source), *(void**)(&args)));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IWebView2<D>::CoreWebView2() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IWebView2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IWebView2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IWebView2>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_CoreWebView2(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IWebView2>**)this;
            check_hresult(_winrt_abi_type->get_CoreWebView2(&value));
        }
        return winrt::Microsoft::Web::WebView2::Core::CoreWebView2{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IWebView2<D>::EnsureCoreWebView2Async() const
    {
        void* operation{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IWebView2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IWebView2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IWebView2>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->EnsureCoreWebView2Async(&operation));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IWebView2>**)this;
            check_hresult(_winrt_abi_type->EnsureCoreWebView2Async(&operation));
        }
        return winrt::Windows::Foundation::IAsyncAction{ operation, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IWebView2<D>::ExecuteScriptAsync(param::hstring const& javascriptCode) const
    {
        void* operation{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IWebView2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IWebView2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IWebView2>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->ExecuteScriptAsync(*(void**)(&javascriptCode), &operation));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IWebView2>**)this;
            check_hresult(_winrt_abi_type->ExecuteScriptAsync(*(void**)(&javascriptCode), &operation));
        }
        return winrt::Windows::Foundation::IAsyncOperation<hstring>{ operation, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IWebView2<D>::Source() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IWebView2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IWebView2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IWebView2>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Source(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IWebView2>**)this;
            check_hresult(_winrt_abi_type->get_Source(&value));
        }
        return winrt::Windows::Foundation::Uri{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IWebView2<D>::Source(winrt::Windows::Foundation::Uri const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IWebView2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IWebView2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IWebView2>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_Source(*(void**)(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IWebView2>**)this;
            check_hresult(_winrt_abi_type->put_Source(*(void**)(&value)));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IWebView2<D>::CanGoForward() const
    {
        bool value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IWebView2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IWebView2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IWebView2>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_CanGoForward(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IWebView2>**)this;
            check_hresult(_winrt_abi_type->get_CanGoForward(&value));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IWebView2<D>::CanGoForward(bool value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IWebView2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IWebView2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IWebView2>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_CanGoForward(value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IWebView2>**)this;
            check_hresult(_winrt_abi_type->put_CanGoForward(value));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IWebView2<D>::CanGoBack() const
    {
        bool value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IWebView2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IWebView2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IWebView2>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_CanGoBack(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IWebView2>**)this;
            check_hresult(_winrt_abi_type->get_CanGoBack(&value));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IWebView2<D>::CanGoBack(bool value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IWebView2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IWebView2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IWebView2>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_CanGoBack(value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IWebView2>**)this;
            check_hresult(_winrt_abi_type->put_CanGoBack(value));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IWebView2<D>::Reload() const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IWebView2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IWebView2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IWebView2>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->Reload());
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IWebView2>**)this;
            check_hresult(_winrt_abi_type->Reload());
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IWebView2<D>::GoForward() const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IWebView2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IWebView2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IWebView2>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->GoForward());
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IWebView2>**)this;
            check_hresult(_winrt_abi_type->GoForward());
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IWebView2<D>::GoBack() const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IWebView2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IWebView2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IWebView2>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->GoBack());
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IWebView2>**)this;
            check_hresult(_winrt_abi_type->GoBack());
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IWebView2<D>::NavigateToString(param::hstring const& htmlContent) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IWebView2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IWebView2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IWebView2>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->NavigateToString(*(void**)(&htmlContent)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IWebView2>**)this;
            check_hresult(_winrt_abi_type->NavigateToString(*(void**)(&htmlContent)));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IWebView2<D>::Close() const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IWebView2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IWebView2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IWebView2>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->Close());
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IWebView2>**)this;
            check_hresult(_winrt_abi_type->Close());
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IWebView2<D>::NavigationCompleted(winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Xaml::Controls::WebView2, winrt::Microsoft::Web::WebView2::Core::CoreWebView2NavigationCompletedEventArgs> const& handler) const
    {
        winrt::event_token token{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IWebView2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IWebView2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IWebView2>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->add_NavigationCompleted(*(void**)(&handler), put_abi(token)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IWebView2>**)this;
            check_hresult(_winrt_abi_type->add_NavigationCompleted(*(void**)(&handler), put_abi(token)));
        }
        return token;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IWebView2<D>::NavigationCompleted(auto_revoke_t, winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Xaml::Controls::WebView2, winrt::Microsoft::Web::WebView2::Core::CoreWebView2NavigationCompletedEventArgs> const& handler) const
    {
        return impl::make_event_revoker<D, NavigationCompleted_revoker>(this, NavigationCompleted(handler));
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IWebView2<D>::NavigationCompleted(winrt::event_token const& token) const noexcept
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IWebView2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IWebView2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IWebView2>**)&_winrt_casted_result;
            _winrt_abi_type->remove_NavigationCompleted(impl::bind_in(token));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IWebView2>**)this;
            _winrt_abi_type->remove_NavigationCompleted(impl::bind_in(token));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IWebView2<D>::WebMessageReceived(winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Xaml::Controls::WebView2, winrt::Microsoft::Web::WebView2::Core::CoreWebView2WebMessageReceivedEventArgs> const& handler) const
    {
        winrt::event_token token{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IWebView2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IWebView2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IWebView2>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->add_WebMessageReceived(*(void**)(&handler), put_abi(token)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IWebView2>**)this;
            check_hresult(_winrt_abi_type->add_WebMessageReceived(*(void**)(&handler), put_abi(token)));
        }
        return token;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IWebView2<D>::WebMessageReceived(auto_revoke_t, winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Xaml::Controls::WebView2, winrt::Microsoft::Web::WebView2::Core::CoreWebView2WebMessageReceivedEventArgs> const& handler) const
    {
        return impl::make_event_revoker<D, WebMessageReceived_revoker>(this, WebMessageReceived(handler));
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IWebView2<D>::WebMessageReceived(winrt::event_token const& token) const noexcept
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IWebView2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IWebView2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IWebView2>**)&_winrt_casted_result;
            _winrt_abi_type->remove_WebMessageReceived(impl::bind_in(token));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IWebView2>**)this;
            _winrt_abi_type->remove_WebMessageReceived(impl::bind_in(token));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IWebView2<D>::NavigationStarting(winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Xaml::Controls::WebView2, winrt::Microsoft::Web::WebView2::Core::CoreWebView2NavigationStartingEventArgs> const& handler) const
    {
        winrt::event_token token{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IWebView2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IWebView2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IWebView2>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->add_NavigationStarting(*(void**)(&handler), put_abi(token)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IWebView2>**)this;
            check_hresult(_winrt_abi_type->add_NavigationStarting(*(void**)(&handler), put_abi(token)));
        }
        return token;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IWebView2<D>::NavigationStarting(auto_revoke_t, winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Xaml::Controls::WebView2, winrt::Microsoft::Web::WebView2::Core::CoreWebView2NavigationStartingEventArgs> const& handler) const
    {
        return impl::make_event_revoker<D, NavigationStarting_revoker>(this, NavigationStarting(handler));
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IWebView2<D>::NavigationStarting(winrt::event_token const& token) const noexcept
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IWebView2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IWebView2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IWebView2>**)&_winrt_casted_result;
            _winrt_abi_type->remove_NavigationStarting(impl::bind_in(token));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IWebView2>**)this;
            _winrt_abi_type->remove_NavigationStarting(impl::bind_in(token));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IWebView2<D>::CoreProcessFailed(winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Xaml::Controls::WebView2, winrt::Microsoft::Web::WebView2::Core::CoreWebView2ProcessFailedEventArgs> const& handler) const
    {
        winrt::event_token token{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IWebView2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IWebView2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IWebView2>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->add_CoreProcessFailed(*(void**)(&handler), put_abi(token)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IWebView2>**)this;
            check_hresult(_winrt_abi_type->add_CoreProcessFailed(*(void**)(&handler), put_abi(token)));
        }
        return token;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IWebView2<D>::CoreProcessFailed(auto_revoke_t, winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Xaml::Controls::WebView2, winrt::Microsoft::Web::WebView2::Core::CoreWebView2ProcessFailedEventArgs> const& handler) const
    {
        return impl::make_event_revoker<D, CoreProcessFailed_revoker>(this, CoreProcessFailed(handler));
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IWebView2<D>::CoreProcessFailed(winrt::event_token const& token) const noexcept
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IWebView2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IWebView2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IWebView2>**)&_winrt_casted_result;
            _winrt_abi_type->remove_CoreProcessFailed(impl::bind_in(token));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IWebView2>**)this;
            _winrt_abi_type->remove_CoreProcessFailed(impl::bind_in(token));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IWebView2<D>::CoreWebView2Initialized(winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Xaml::Controls::WebView2, winrt::Microsoft::UI::Xaml::Controls::CoreWebView2InitializedEventArgs> const& handler) const
    {
        winrt::event_token token{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IWebView2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IWebView2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IWebView2>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->add_CoreWebView2Initialized(*(void**)(&handler), put_abi(token)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IWebView2>**)this;
            check_hresult(_winrt_abi_type->add_CoreWebView2Initialized(*(void**)(&handler), put_abi(token)));
        }
        return token;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IWebView2<D>::CoreWebView2Initialized(auto_revoke_t, winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Xaml::Controls::WebView2, winrt::Microsoft::UI::Xaml::Controls::CoreWebView2InitializedEventArgs> const& handler) const
    {
        return impl::make_event_revoker<D, CoreWebView2Initialized_revoker>(this, CoreWebView2Initialized(handler));
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IWebView2<D>::CoreWebView2Initialized(winrt::event_token const& token) const noexcept
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IWebView2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IWebView2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IWebView2>**)&_winrt_casted_result;
            _winrt_abi_type->remove_CoreWebView2Initialized(impl::bind_in(token));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IWebView2>**)this;
            _winrt_abi_type->remove_CoreWebView2Initialized(impl::bind_in(token));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IWebView2Factory<D>::CreateInstance(winrt::Windows::Foundation::IInspectable const& baseInterface, winrt::Windows::Foundation::IInspectable& innerInterface) const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IWebView2Factory>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IWebView2Factory, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IWebView2Factory>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->CreateInstance(*(void**)(&baseInterface), impl::bind_out(innerInterface), &value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IWebView2Factory>**)this;
            check_hresult(_winrt_abi_type->CreateInstance(*(void**)(&baseInterface), impl::bind_out(innerInterface), &value));
        }
        return winrt::Microsoft::UI::Xaml::Controls::WebView2{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IWebView2Statics<D>::SourceProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IWebView2Statics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IWebView2Statics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IWebView2Statics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_SourceProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IWebView2Statics>**)this;
            check_hresult(_winrt_abi_type->get_SourceProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IWebView2Statics<D>::CanGoForwardProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IWebView2Statics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IWebView2Statics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IWebView2Statics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_CanGoForwardProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IWebView2Statics>**)this;
            check_hresult(_winrt_abi_type->get_CanGoForwardProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IWebView2Statics<D>::CanGoBackProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IWebView2Statics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IWebView2Statics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IWebView2Statics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_CanGoBackProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IWebView2Statics>**)this;
            check_hresult(_winrt_abi_type->get_CanGoBackProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IXamlControlsResources3<D>::ControlsResourcesVersion() const
    {
        winrt::Microsoft::UI::Xaml::Controls::ControlsResourcesVersion value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IXamlControlsResources3>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IXamlControlsResources3, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IXamlControlsResources3>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_ControlsResourcesVersion(reinterpret_cast<int32_t*>(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IXamlControlsResources3>**)this;
            check_hresult(_winrt_abi_type->get_ControlsResourcesVersion(reinterpret_cast<int32_t*>(&value)));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IXamlControlsResources3<D>::ControlsResourcesVersion(winrt::Microsoft::UI::Xaml::Controls::ControlsResourcesVersion const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IXamlControlsResources3>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IXamlControlsResources3, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IXamlControlsResources3>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_ControlsResourcesVersion(static_cast<int32_t>(value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IXamlControlsResources3>**)this;
            check_hresult(_winrt_abi_type->put_ControlsResourcesVersion(static_cast<int32_t>(value)));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IXamlControlsResourcesStatics<D>::EnsureRevealLights(winrt::Windows::UI::Xaml::UIElement const& element) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IXamlControlsResourcesStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IXamlControlsResourcesStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IXamlControlsResourcesStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->EnsureRevealLights(*(void**)(&element)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IXamlControlsResourcesStatics>**)this;
            check_hresult(_winrt_abi_type->EnsureRevealLights(*(void**)(&element)));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Controls_IXamlControlsResourcesStatics3<D>::ControlsResourcesVersionProperty() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Controls::IXamlControlsResourcesStatics3>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Controls::IXamlControlsResourcesStatics3, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IXamlControlsResourcesStatics3>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_ControlsResourcesVersionProperty(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Controls::IXamlControlsResourcesStatics3>**)this;
            check_hresult(_winrt_abi_type->get_ControlsResourcesVersionProperty(&value));
        }
        return winrt::Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Controls::IAnimatedIcon> : produce_base<D, winrt::Microsoft::UI::Xaml::Controls::IAnimatedIcon>
    {
        int32_t __stdcall get_Source(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::UI::Xaml::Controls::IAnimatedVisualSource2>(this->shim().Source());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_Source(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Source(*reinterpret_cast<winrt::Microsoft::UI::Xaml::Controls::IAnimatedVisualSource2 const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_FallbackIconSource(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::UI::Xaml::Controls::IconSource>(this->shim().FallbackIconSource());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_FallbackIconSource(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().FallbackIconSource(*reinterpret_cast<winrt::Microsoft::UI::Xaml::Controls::IconSource const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_MirroredWhenRightToLeft(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().MirroredWhenRightToLeft());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_MirroredWhenRightToLeft(bool value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().MirroredWhenRightToLeft(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Controls::IAnimatedIconFactory> : produce_base<D, winrt::Microsoft::UI::Xaml::Controls::IAnimatedIconFactory>
    {
        int32_t __stdcall CreateInstance(void* baseInterface, void** innerInterface, void** value) noexcept final try
        {
            if (innerInterface) *innerInterface = nullptr;
            winrt::Windows::Foundation::IInspectable winrt_impl_innerInterface;
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::UI::Xaml::Controls::AnimatedIcon>(this->shim().CreateInstance(*reinterpret_cast<winrt::Windows::Foundation::IInspectable const*>(&baseInterface), winrt_impl_innerInterface));
                if (innerInterface) *innerInterface = detach_abi(winrt_impl_innerInterface);
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Controls::IAnimatedIconSource> : produce_base<D, winrt::Microsoft::UI::Xaml::Controls::IAnimatedIconSource>
    {
        int32_t __stdcall get_Source(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::UI::Xaml::Controls::IAnimatedVisualSource2>(this->shim().Source());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_Source(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Source(*reinterpret_cast<winrt::Microsoft::UI::Xaml::Controls::IAnimatedVisualSource2 const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_FallbackIconSource(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::UI::Xaml::Controls::IconSource>(this->shim().FallbackIconSource());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_FallbackIconSource(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().FallbackIconSource(*reinterpret_cast<winrt::Microsoft::UI::Xaml::Controls::IconSource const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_MirroredWhenRightToLeft(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().MirroredWhenRightToLeft());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_MirroredWhenRightToLeft(bool value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().MirroredWhenRightToLeft(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Controls::IAnimatedIconSourceFactory> : produce_base<D, winrt::Microsoft::UI::Xaml::Controls::IAnimatedIconSourceFactory>
    {
        int32_t __stdcall CreateInstance(void* baseInterface, void** innerInterface, void** value) noexcept final try
        {
            if (innerInterface) *innerInterface = nullptr;
            winrt::Windows::Foundation::IInspectable winrt_impl_innerInterface;
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::UI::Xaml::Controls::AnimatedIconSource>(this->shim().CreateInstance(*reinterpret_cast<winrt::Windows::Foundation::IInspectable const*>(&baseInterface), winrt_impl_innerInterface));
                if (innerInterface) *innerInterface = detach_abi(winrt_impl_innerInterface);
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Controls::IAnimatedIconSourceStatics> : produce_base<D, winrt::Microsoft::UI::Xaml::Controls::IAnimatedIconSourceStatics>
    {
        int32_t __stdcall get_SourceProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().SourceProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_FallbackIconSourceProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().FallbackIconSourceProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_MirroredWhenRightToLeftProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().MirroredWhenRightToLeftProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Controls::IAnimatedIconStatics> : produce_base<D, winrt::Microsoft::UI::Xaml::Controls::IAnimatedIconStatics>
    {
        int32_t __stdcall get_StateProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().StateProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall SetState(void* object, void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().SetState(*reinterpret_cast<winrt::Windows::UI::Xaml::DependencyObject const*>(&object), *reinterpret_cast<hstring const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall GetState(void* object, void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<hstring>(this->shim().GetState(*reinterpret_cast<winrt::Windows::UI::Xaml::DependencyObject const*>(&object)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_SourceProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().SourceProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_FallbackIconSourceProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().FallbackIconSourceProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_MirroredWhenRightToLeftProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().MirroredWhenRightToLeftProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Controls::IAnimatedVisual> : produce_base<D, winrt::Microsoft::UI::Xaml::Controls::IAnimatedVisual>
    {
        int32_t __stdcall get_RootVisual(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Composition::Visual>(this->shim().RootVisual());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Size(winrt::Windows::Foundation::Numerics::float2* value) noexcept final try
        {
            zero_abi<winrt::Windows::Foundation::Numerics::float2>(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::Numerics::float2>(this->shim().Size());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Duration(int64_t* value) noexcept final try
        {
            zero_abi<winrt::Windows::Foundation::TimeSpan>(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::TimeSpan>(this->shim().Duration());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Controls::IAnimatedVisual2> : produce_base<D, winrt::Microsoft::UI::Xaml::Controls::IAnimatedVisual2>
    {
        int32_t __stdcall CreateAnimations() noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().CreateAnimations();
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall DestroyAnimations() noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().DestroyAnimations();
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Controls::IAnimatedVisualPlayer> : produce_base<D, winrt::Microsoft::UI::Xaml::Controls::IAnimatedVisualPlayer>
    {
        int32_t __stdcall get_Diagnostics(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::IInspectable>(this->shim().Diagnostics());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Duration(int64_t* value) noexcept final try
        {
            zero_abi<winrt::Windows::Foundation::TimeSpan>(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::TimeSpan>(this->shim().Duration());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Source(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::UI::Xaml::Controls::IAnimatedVisualSource>(this->shim().Source());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_Source(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Source(*reinterpret_cast<winrt::Microsoft::UI::Xaml::Controls::IAnimatedVisualSource const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_FallbackContent(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DataTemplate>(this->shim().FallbackContent());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_FallbackContent(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().FallbackContent(*reinterpret_cast<winrt::Windows::UI::Xaml::DataTemplate const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_AutoPlay(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().AutoPlay());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_AutoPlay(bool value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().AutoPlay(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_IsAnimatedVisualLoaded(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().IsAnimatedVisualLoaded());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_IsPlaying(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().IsPlaying());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_PlaybackRate(double* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<double>(this->shim().PlaybackRate());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_PlaybackRate(double value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().PlaybackRate(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_ProgressObject(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Composition::CompositionObject>(this->shim().ProgressObject());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Stretch(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::Media::Stretch>(this->shim().Stretch());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_Stretch(int32_t value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Stretch(*reinterpret_cast<winrt::Windows::UI::Xaml::Media::Stretch const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall Pause() noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Pause();
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall PlayAsync(double fromProgress, double toProgress, bool looped, void** operation) noexcept final try
        {
            clear_abi(operation);
            typename D::abi_guard guard(this->shim());
            *operation = detach_from<winrt::Windows::Foundation::IAsyncAction>(this->shim().PlayAsync(fromProgress, toProgress, looped));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall Resume() noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Resume();
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall SetProgress(double progress) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().SetProgress(progress);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall Stop() noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Stop();
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Controls::IAnimatedVisualPlayer2> : produce_base<D, winrt::Microsoft::UI::Xaml::Controls::IAnimatedVisualPlayer2>
    {
        int32_t __stdcall get_AnimationOptimization(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::UI::Xaml::Controls::PlayerAnimationOptimization>(this->shim().AnimationOptimization());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_AnimationOptimization(int32_t value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().AnimationOptimization(*reinterpret_cast<winrt::Microsoft::UI::Xaml::Controls::PlayerAnimationOptimization const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Controls::IAnimatedVisualPlayerFactory> : produce_base<D, winrt::Microsoft::UI::Xaml::Controls::IAnimatedVisualPlayerFactory>
    {
        int32_t __stdcall CreateInstance(void* baseInterface, void** innerInterface, void** value) noexcept final try
        {
            if (innerInterface) *innerInterface = nullptr;
            winrt::Windows::Foundation::IInspectable winrt_impl_innerInterface;
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::UI::Xaml::Controls::AnimatedVisualPlayer>(this->shim().CreateInstance(*reinterpret_cast<winrt::Windows::Foundation::IInspectable const*>(&baseInterface), winrt_impl_innerInterface));
                if (innerInterface) *innerInterface = detach_abi(winrt_impl_innerInterface);
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Controls::IAnimatedVisualPlayerStatics> : produce_base<D, winrt::Microsoft::UI::Xaml::Controls::IAnimatedVisualPlayerStatics>
    {
        int32_t __stdcall get_AutoPlayProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().AutoPlayProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_DiagnosticsProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().DiagnosticsProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_DurationProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().DurationProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_FallbackContentProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().FallbackContentProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_IsAnimatedVisualLoadedProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().IsAnimatedVisualLoadedProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_IsPlayingProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().IsPlayingProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_PlaybackRateProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().PlaybackRateProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_SourceProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().SourceProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_StretchProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().StretchProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Controls::IAnimatedVisualPlayerStatics2> : produce_base<D, winrt::Microsoft::UI::Xaml::Controls::IAnimatedVisualPlayerStatics2>
    {
        int32_t __stdcall get_AnimationOptimizationProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().AnimationOptimizationProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Controls::IAnimatedVisualSource> : produce_base<D, winrt::Microsoft::UI::Xaml::Controls::IAnimatedVisualSource>
    {
        int32_t __stdcall TryCreateAnimatedVisual(void* compositor, void** diagnostics, void** result) noexcept final try
        {
            if (diagnostics) *diagnostics = nullptr;
            winrt::Windows::Foundation::IInspectable winrt_impl_diagnostics;
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Microsoft::UI::Xaml::Controls::IAnimatedVisual>(this->shim().TryCreateAnimatedVisual(*reinterpret_cast<winrt::Windows::UI::Composition::Compositor const*>(&compositor), winrt_impl_diagnostics));
                if (diagnostics) *diagnostics = detach_abi(winrt_impl_diagnostics);
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Controls::IAnimatedVisualSource2> : produce_base<D, winrt::Microsoft::UI::Xaml::Controls::IAnimatedVisualSource2>
    {
        int32_t __stdcall get_Markers(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::Collections::IMapView<hstring, double>>(this->shim().Markers());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall SetColorProperty(void* propertyName, struct struct_Windows_UI_Color value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().SetColorProperty(*reinterpret_cast<hstring const*>(&propertyName), *reinterpret_cast<winrt::Windows::UI::Color const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Controls::IAnimatedVisualSource3> : produce_base<D, winrt::Microsoft::UI::Xaml::Controls::IAnimatedVisualSource3>
    {
        int32_t __stdcall TryCreateAnimatedVisual(void* compositor, void** diagnostics, bool createAnimations, void** result) noexcept final try
        {
            if (diagnostics) *diagnostics = nullptr;
            winrt::Windows::Foundation::IInspectable winrt_impl_diagnostics;
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Microsoft::UI::Xaml::Controls::IAnimatedVisual2>(this->shim().TryCreateAnimatedVisual(*reinterpret_cast<winrt::Windows::UI::Composition::Compositor const*>(&compositor), winrt_impl_diagnostics, createAnimations));
                if (diagnostics) *diagnostics = detach_abi(winrt_impl_diagnostics);
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Controls::IBackdropMaterial> : produce_base<D, winrt::Microsoft::UI::Xaml::Controls::IBackdropMaterial>
    {
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Controls::IBackdropMaterialFactory> : produce_base<D, winrt::Microsoft::UI::Xaml::Controls::IBackdropMaterialFactory>
    {
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Controls::IBackdropMaterialStatics> : produce_base<D, winrt::Microsoft::UI::Xaml::Controls::IBackdropMaterialStatics>
    {
        int32_t __stdcall get_ApplyToRootOrPageBackgroundProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().ApplyToRootOrPageBackgroundProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall SetApplyToRootOrPageBackground(void* element, bool value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().SetApplyToRootOrPageBackground(*reinterpret_cast<winrt::Windows::UI::Xaml::Controls::Control const*>(&element), value);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall GetApplyToRootOrPageBackground(void* element, bool* result) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *result = detach_from<bool>(this->shim().GetApplyToRootOrPageBackground(*reinterpret_cast<winrt::Windows::UI::Xaml::Controls::Control const*>(&element)));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Controls::IBitmapIconSource> : produce_base<D, winrt::Microsoft::UI::Xaml::Controls::IBitmapIconSource>
    {
        int32_t __stdcall get_UriSource(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::Uri>(this->shim().UriSource());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_UriSource(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().UriSource(*reinterpret_cast<winrt::Windows::Foundation::Uri const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_ShowAsMonochrome(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().ShowAsMonochrome());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_ShowAsMonochrome(bool value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().ShowAsMonochrome(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Controls::IBitmapIconSourceFactory> : produce_base<D, winrt::Microsoft::UI::Xaml::Controls::IBitmapIconSourceFactory>
    {
        int32_t __stdcall CreateInstance(void* baseInterface, void** innerInterface, void** value) noexcept final try
        {
            if (innerInterface) *innerInterface = nullptr;
            winrt::Windows::Foundation::IInspectable winrt_impl_innerInterface;
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::UI::Xaml::Controls::BitmapIconSource>(this->shim().CreateInstance(*reinterpret_cast<winrt::Windows::Foundation::IInspectable const*>(&baseInterface), winrt_impl_innerInterface));
                if (innerInterface) *innerInterface = detach_abi(winrt_impl_innerInterface);
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Controls::IBitmapIconSourceStatics> : produce_base<D, winrt::Microsoft::UI::Xaml::Controls::IBitmapIconSourceStatics>
    {
        int32_t __stdcall get_UriSourceProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().UriSourceProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_ShowAsMonochromeProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().ShowAsMonochromeProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Controls::IBreadcrumbBar> : produce_base<D, winrt::Microsoft::UI::Xaml::Controls::IBreadcrumbBar>
    {
        int32_t __stdcall get_ItemsSource(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::IInspectable>(this->shim().ItemsSource());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_ItemsSource(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().ItemsSource(*reinterpret_cast<winrt::Windows::Foundation::IInspectable const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_ItemTemplate(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::IInspectable>(this->shim().ItemTemplate());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_ItemTemplate(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().ItemTemplate(*reinterpret_cast<winrt::Windows::Foundation::IInspectable const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall add_ItemClicked(void* handler, winrt::event_token* token) noexcept final try
        {
            zero_abi<winrt::event_token>(token);
            typename D::abi_guard guard(this->shim());
            *token = detach_from<winrt::event_token>(this->shim().ItemClicked(*reinterpret_cast<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Xaml::Controls::BreadcrumbBar, winrt::Microsoft::UI::Xaml::Controls::BreadcrumbBarItemClickedEventArgs> const*>(&handler)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall remove_ItemClicked(winrt::event_token token) noexcept final
        {
            typename D::abi_guard guard(this->shim());
            this->shim().ItemClicked(*reinterpret_cast<winrt::event_token const*>(&token));
            return 0;
        }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Controls::IBreadcrumbBarFactory> : produce_base<D, winrt::Microsoft::UI::Xaml::Controls::IBreadcrumbBarFactory>
    {
        int32_t __stdcall CreateInstance(void* baseInterface, void** innerInterface, void** value) noexcept final try
        {
            if (innerInterface) *innerInterface = nullptr;
            winrt::Windows::Foundation::IInspectable winrt_impl_innerInterface;
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::UI::Xaml::Controls::BreadcrumbBar>(this->shim().CreateInstance(*reinterpret_cast<winrt::Windows::Foundation::IInspectable const*>(&baseInterface), winrt_impl_innerInterface));
                if (innerInterface) *innerInterface = detach_abi(winrt_impl_innerInterface);
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Controls::IBreadcrumbBarItem> : produce_base<D, winrt::Microsoft::UI::Xaml::Controls::IBreadcrumbBarItem>
    {
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Controls::IBreadcrumbBarItemClickedEventArgs> : produce_base<D, winrt::Microsoft::UI::Xaml::Controls::IBreadcrumbBarItemClickedEventArgs>
    {
        int32_t __stdcall get_Index(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<int32_t>(this->shim().Index());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Item(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::IInspectable>(this->shim().Item());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Controls::IBreadcrumbBarItemFactory> : produce_base<D, winrt::Microsoft::UI::Xaml::Controls::IBreadcrumbBarItemFactory>
    {
        int32_t __stdcall CreateInstance(void* baseInterface, void** innerInterface, void** value) noexcept final try
        {
            if (innerInterface) *innerInterface = nullptr;
            winrt::Windows::Foundation::IInspectable winrt_impl_innerInterface;
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::UI::Xaml::Controls::BreadcrumbBarItem>(this->shim().CreateInstance(*reinterpret_cast<winrt::Windows::Foundation::IInspectable const*>(&baseInterface), winrt_impl_innerInterface));
                if (innerInterface) *innerInterface = detach_abi(winrt_impl_innerInterface);
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Controls::IBreadcrumbBarStatics> : produce_base<D, winrt::Microsoft::UI::Xaml::Controls::IBreadcrumbBarStatics>
    {
        int32_t __stdcall get_ItemsSourceProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().ItemsSourceProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_ItemTemplateProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().ItemTemplateProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Controls::IColorChangedEventArgs> : produce_base<D, winrt::Microsoft::UI::Xaml::Controls::IColorChangedEventArgs>
    {
        int32_t __stdcall get_OldColor(struct struct_Windows_UI_Color* value) noexcept final try
        {
            zero_abi<winrt::Windows::UI::Color>(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Color>(this->shim().OldColor());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_NewColor(struct struct_Windows_UI_Color* value) noexcept final try
        {
            zero_abi<winrt::Windows::UI::Color>(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Color>(this->shim().NewColor());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Controls::IColorPicker> : produce_base<D, winrt::Microsoft::UI::Xaml::Controls::IColorPicker>
    {
        int32_t __stdcall get_Color(struct struct_Windows_UI_Color* value) noexcept final try
        {
            zero_abi<winrt::Windows::UI::Color>(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Color>(this->shim().Color());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_Color(struct struct_Windows_UI_Color value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Color(*reinterpret_cast<winrt::Windows::UI::Color const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_PreviousColor(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::IReference<winrt::Windows::UI::Color>>(this->shim().PreviousColor());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_PreviousColor(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().PreviousColor(*reinterpret_cast<winrt::Windows::Foundation::IReference<winrt::Windows::UI::Color> const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_IsAlphaEnabled(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().IsAlphaEnabled());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_IsAlphaEnabled(bool value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().IsAlphaEnabled(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_IsColorSpectrumVisible(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().IsColorSpectrumVisible());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_IsColorSpectrumVisible(bool value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().IsColorSpectrumVisible(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_IsColorPreviewVisible(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().IsColorPreviewVisible());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_IsColorPreviewVisible(bool value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().IsColorPreviewVisible(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_IsColorSliderVisible(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().IsColorSliderVisible());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_IsColorSliderVisible(bool value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().IsColorSliderVisible(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_IsAlphaSliderVisible(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().IsAlphaSliderVisible());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_IsAlphaSliderVisible(bool value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().IsAlphaSliderVisible(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_IsMoreButtonVisible(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().IsMoreButtonVisible());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_IsMoreButtonVisible(bool value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().IsMoreButtonVisible(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_IsColorChannelTextInputVisible(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().IsColorChannelTextInputVisible());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_IsColorChannelTextInputVisible(bool value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().IsColorChannelTextInputVisible(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_IsAlphaTextInputVisible(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().IsAlphaTextInputVisible());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_IsAlphaTextInputVisible(bool value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().IsAlphaTextInputVisible(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_IsHexInputVisible(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().IsHexInputVisible());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_IsHexInputVisible(bool value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().IsHexInputVisible(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_MinHue(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<int32_t>(this->shim().MinHue());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_MinHue(int32_t value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().MinHue(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_MaxHue(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<int32_t>(this->shim().MaxHue());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_MaxHue(int32_t value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().MaxHue(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_MinSaturation(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<int32_t>(this->shim().MinSaturation());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_MinSaturation(int32_t value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().MinSaturation(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_MaxSaturation(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<int32_t>(this->shim().MaxSaturation());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_MaxSaturation(int32_t value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().MaxSaturation(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_MinValue(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<int32_t>(this->shim().MinValue());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_MinValue(int32_t value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().MinValue(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_MaxValue(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<int32_t>(this->shim().MaxValue());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_MaxValue(int32_t value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().MaxValue(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_ColorSpectrumShape(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::UI::Xaml::Controls::ColorSpectrumShape>(this->shim().ColorSpectrumShape());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_ColorSpectrumShape(int32_t value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().ColorSpectrumShape(*reinterpret_cast<winrt::Microsoft::UI::Xaml::Controls::ColorSpectrumShape const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_ColorSpectrumComponents(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::UI::Xaml::Controls::ColorSpectrumComponents>(this->shim().ColorSpectrumComponents());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_ColorSpectrumComponents(int32_t value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().ColorSpectrumComponents(*reinterpret_cast<winrt::Microsoft::UI::Xaml::Controls::ColorSpectrumComponents const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall add_ColorChanged(void* handler, winrt::event_token* token) noexcept final try
        {
            zero_abi<winrt::event_token>(token);
            typename D::abi_guard guard(this->shim());
            *token = detach_from<winrt::event_token>(this->shim().ColorChanged(*reinterpret_cast<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Xaml::Controls::ColorPicker, winrt::Microsoft::UI::Xaml::Controls::ColorChangedEventArgs> const*>(&handler)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall remove_ColorChanged(winrt::event_token token) noexcept final
        {
            typename D::abi_guard guard(this->shim());
            this->shim().ColorChanged(*reinterpret_cast<winrt::event_token const*>(&token));
            return 0;
        }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Controls::IColorPicker2> : produce_base<D, winrt::Microsoft::UI::Xaml::Controls::IColorPicker2>
    {
        int32_t __stdcall get_Orientation(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::Controls::Orientation>(this->shim().Orientation());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_Orientation(int32_t value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Orientation(*reinterpret_cast<winrt::Windows::UI::Xaml::Controls::Orientation const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Controls::IColorPickerFactory> : produce_base<D, winrt::Microsoft::UI::Xaml::Controls::IColorPickerFactory>
    {
        int32_t __stdcall CreateInstance(void* baseInterface, void** innerInterface, void** value) noexcept final try
        {
            if (innerInterface) *innerInterface = nullptr;
            winrt::Windows::Foundation::IInspectable winrt_impl_innerInterface;
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::UI::Xaml::Controls::ColorPicker>(this->shim().CreateInstance(*reinterpret_cast<winrt::Windows::Foundation::IInspectable const*>(&baseInterface), winrt_impl_innerInterface));
                if (innerInterface) *innerInterface = detach_abi(winrt_impl_innerInterface);
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Controls::IColorPickerStatics> : produce_base<D, winrt::Microsoft::UI::Xaml::Controls::IColorPickerStatics>
    {
        int32_t __stdcall get_ColorProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().ColorProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_PreviousColorProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().PreviousColorProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_IsAlphaEnabledProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().IsAlphaEnabledProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_IsColorSpectrumVisibleProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().IsColorSpectrumVisibleProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_IsColorPreviewVisibleProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().IsColorPreviewVisibleProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_IsColorSliderVisibleProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().IsColorSliderVisibleProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_IsAlphaSliderVisibleProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().IsAlphaSliderVisibleProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_IsMoreButtonVisibleProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().IsMoreButtonVisibleProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_IsColorChannelTextInputVisibleProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().IsColorChannelTextInputVisibleProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_IsAlphaTextInputVisibleProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().IsAlphaTextInputVisibleProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_IsHexInputVisibleProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().IsHexInputVisibleProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_MinHueProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().MinHueProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_MaxHueProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().MaxHueProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_MinSaturationProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().MinSaturationProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_MaxSaturationProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().MaxSaturationProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_MinValueProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().MinValueProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_MaxValueProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().MaxValueProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_ColorSpectrumShapeProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().ColorSpectrumShapeProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_ColorSpectrumComponentsProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().ColorSpectrumComponentsProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Controls::IColorPickerStatics2> : produce_base<D, winrt::Microsoft::UI::Xaml::Controls::IColorPickerStatics2>
    {
        int32_t __stdcall get_OrientationProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().OrientationProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Controls::ICommandBarFlyout> : produce_base<D, winrt::Microsoft::UI::Xaml::Controls::ICommandBarFlyout>
    {
        int32_t __stdcall get_PrimaryCommands(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::Collections::IObservableVector<winrt::Windows::UI::Xaml::Controls::ICommandBarElement>>(this->shim().PrimaryCommands());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_SecondaryCommands(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::Collections::IObservableVector<winrt::Windows::UI::Xaml::Controls::ICommandBarElement>>(this->shim().SecondaryCommands());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Controls::ICommandBarFlyout2> : produce_base<D, winrt::Microsoft::UI::Xaml::Controls::ICommandBarFlyout2>
    {
        int32_t __stdcall get_AlwaysExpanded(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().AlwaysExpanded());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_AlwaysExpanded(bool value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().AlwaysExpanded(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Controls::ICommandBarFlyoutFactory> : produce_base<D, winrt::Microsoft::UI::Xaml::Controls::ICommandBarFlyoutFactory>
    {
        int32_t __stdcall CreateInstance(void* baseInterface, void** innerInterface, void** value) noexcept final try
        {
            if (innerInterface) *innerInterface = nullptr;
            winrt::Windows::Foundation::IInspectable winrt_impl_innerInterface;
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::UI::Xaml::Controls::CommandBarFlyout>(this->shim().CreateInstance(*reinterpret_cast<winrt::Windows::Foundation::IInspectable const*>(&baseInterface), winrt_impl_innerInterface));
                if (innerInterface) *innerInterface = detach_abi(winrt_impl_innerInterface);
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Controls::ICoreWebView2InitializedEventArgs> : produce_base<D, winrt::Microsoft::UI::Xaml::Controls::ICoreWebView2InitializedEventArgs>
    {
        int32_t __stdcall get_Exception(winrt::hresult* value) noexcept final try
        {
            zero_abi<winrt::hresult>(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::hresult>(this->shim().Exception());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Controls::IDropDownButton> : produce_base<D, winrt::Microsoft::UI::Xaml::Controls::IDropDownButton>
    {
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Controls::IDropDownButtonFactory> : produce_base<D, winrt::Microsoft::UI::Xaml::Controls::IDropDownButtonFactory>
    {
        int32_t __stdcall CreateInstance(void* baseInterface, void** innerInterface, void** value) noexcept final try
        {
            if (innerInterface) *innerInterface = nullptr;
            winrt::Windows::Foundation::IInspectable winrt_impl_innerInterface;
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::UI::Xaml::Controls::DropDownButton>(this->shim().CreateInstance(*reinterpret_cast<winrt::Windows::Foundation::IInspectable const*>(&baseInterface), winrt_impl_innerInterface));
                if (innerInterface) *innerInterface = detach_abi(winrt_impl_innerInterface);
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Controls::IDynamicAnimatedVisualSource> : produce_base<D, winrt::Microsoft::UI::Xaml::Controls::IDynamicAnimatedVisualSource>
    {
        int32_t __stdcall add_AnimatedVisualInvalidated(void* handler, winrt::event_token* token) noexcept final try
        {
            zero_abi<winrt::event_token>(token);
            typename D::abi_guard guard(this->shim());
            *token = detach_from<winrt::event_token>(this->shim().AnimatedVisualInvalidated(*reinterpret_cast<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Xaml::Controls::IDynamicAnimatedVisualSource, winrt::Windows::Foundation::IInspectable> const*>(&handler)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall remove_AnimatedVisualInvalidated(winrt::event_token token) noexcept final
        {
            typename D::abi_guard guard(this->shim());
            this->shim().AnimatedVisualInvalidated(*reinterpret_cast<winrt::event_token const*>(&token));
            return 0;
        }
    };
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Controls::IElementFactory> : produce_base<D, winrt::Microsoft::UI::Xaml::Controls::IElementFactory>
    {
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Controls::IElementFactoryFactory> : produce_base<D, winrt::Microsoft::UI::Xaml::Controls::IElementFactoryFactory>
    {
        int32_t __stdcall CreateInstance(void* baseInterface, void** innerInterface, void** value) noexcept final try
        {
            if (innerInterface) *innerInterface = nullptr;
            winrt::Windows::Foundation::IInspectable winrt_impl_innerInterface;
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::UI::Xaml::Controls::ElementFactory>(this->shim().CreateInstance(*reinterpret_cast<winrt::Windows::Foundation::IInspectable const*>(&baseInterface), winrt_impl_innerInterface));
                if (innerInterface) *innerInterface = detach_abi(winrt_impl_innerInterface);
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Controls::IElementFactoryGetArgs> : produce_base<D, winrt::Microsoft::UI::Xaml::Controls::IElementFactoryGetArgs>
    {
        int32_t __stdcall get_Data(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::IInspectable>(this->shim().Data());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_Data(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Data(*reinterpret_cast<winrt::Windows::Foundation::IInspectable const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Parent(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::UIElement>(this->shim().Parent());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_Parent(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Parent(*reinterpret_cast<winrt::Windows::UI::Xaml::UIElement const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Controls::IElementFactoryOverrides> : produce_base<D, winrt::Microsoft::UI::Xaml::Controls::IElementFactoryOverrides>
    {
        int32_t __stdcall GetElementCore(void* args, void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Windows::UI::Xaml::UIElement>(this->shim().GetElementCore(*reinterpret_cast<winrt::Microsoft::UI::Xaml::Controls::ElementFactoryGetArgs const*>(&args)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall RecycleElementCore(void* args) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().RecycleElementCore(*reinterpret_cast<winrt::Microsoft::UI::Xaml::Controls::ElementFactoryRecycleArgs const*>(&args));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Controls::IElementFactoryRecycleArgs> : produce_base<D, winrt::Microsoft::UI::Xaml::Controls::IElementFactoryRecycleArgs>
    {
        int32_t __stdcall get_Element(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::UIElement>(this->shim().Element());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_Element(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Element(*reinterpret_cast<winrt::Windows::UI::Xaml::UIElement const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Parent(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::UIElement>(this->shim().Parent());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_Parent(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Parent(*reinterpret_cast<winrt::Windows::UI::Xaml::UIElement const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Controls::IExpander> : produce_base<D, winrt::Microsoft::UI::Xaml::Controls::IExpander>
    {
        int32_t __stdcall get_Header(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::IInspectable>(this->shim().Header());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_Header(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Header(*reinterpret_cast<winrt::Windows::Foundation::IInspectable const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_HeaderTemplate(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DataTemplate>(this->shim().HeaderTemplate());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_HeaderTemplate(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().HeaderTemplate(*reinterpret_cast<winrt::Windows::UI::Xaml::DataTemplate const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_HeaderTemplateSelector(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::Controls::DataTemplateSelector>(this->shim().HeaderTemplateSelector());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_HeaderTemplateSelector(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().HeaderTemplateSelector(*reinterpret_cast<winrt::Windows::UI::Xaml::Controls::DataTemplateSelector const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_IsExpanded(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().IsExpanded());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_IsExpanded(bool value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().IsExpanded(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_ExpandDirection(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::UI::Xaml::Controls::ExpandDirection>(this->shim().ExpandDirection());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_ExpandDirection(int32_t value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().ExpandDirection(*reinterpret_cast<winrt::Microsoft::UI::Xaml::Controls::ExpandDirection const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall add_Expanding(void* handler, winrt::event_token* token) noexcept final try
        {
            zero_abi<winrt::event_token>(token);
            typename D::abi_guard guard(this->shim());
            *token = detach_from<winrt::event_token>(this->shim().Expanding(*reinterpret_cast<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Xaml::Controls::Expander, winrt::Microsoft::UI::Xaml::Controls::ExpanderExpandingEventArgs> const*>(&handler)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall remove_Expanding(winrt::event_token token) noexcept final
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Expanding(*reinterpret_cast<winrt::event_token const*>(&token));
            return 0;
        }
        int32_t __stdcall add_Collapsed(void* handler, winrt::event_token* token) noexcept final try
        {
            zero_abi<winrt::event_token>(token);
            typename D::abi_guard guard(this->shim());
            *token = detach_from<winrt::event_token>(this->shim().Collapsed(*reinterpret_cast<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Xaml::Controls::Expander, winrt::Microsoft::UI::Xaml::Controls::ExpanderCollapsedEventArgs> const*>(&handler)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall remove_Collapsed(winrt::event_token token) noexcept final
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Collapsed(*reinterpret_cast<winrt::event_token const*>(&token));
            return 0;
        }
        int32_t __stdcall get_TemplateSettings(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::UI::Xaml::Controls::ExpanderTemplateSettings>(this->shim().TemplateSettings());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Controls::IExpanderCollapsedEventArgs> : produce_base<D, winrt::Microsoft::UI::Xaml::Controls::IExpanderCollapsedEventArgs>
    {
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Controls::IExpanderExpandingEventArgs> : produce_base<D, winrt::Microsoft::UI::Xaml::Controls::IExpanderExpandingEventArgs>
    {
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Controls::IExpanderFactory> : produce_base<D, winrt::Microsoft::UI::Xaml::Controls::IExpanderFactory>
    {
        int32_t __stdcall CreateInstance(void* baseInterface, void** innerInterface, void** value) noexcept final try
        {
            if (innerInterface) *innerInterface = nullptr;
            winrt::Windows::Foundation::IInspectable winrt_impl_innerInterface;
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::UI::Xaml::Controls::Expander>(this->shim().CreateInstance(*reinterpret_cast<winrt::Windows::Foundation::IInspectable const*>(&baseInterface), winrt_impl_innerInterface));
                if (innerInterface) *innerInterface = detach_abi(winrt_impl_innerInterface);
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Controls::IExpanderStatics> : produce_base<D, winrt::Microsoft::UI::Xaml::Controls::IExpanderStatics>
    {
        int32_t __stdcall get_HeaderProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().HeaderProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_HeaderTemplateProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().HeaderTemplateProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_HeaderTemplateSelectorProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().HeaderTemplateSelectorProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_IsExpandedProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().IsExpandedProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_ExpandDirectionProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().ExpandDirectionProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Controls::IExpanderTemplateSettings> : produce_base<D, winrt::Microsoft::UI::Xaml::Controls::IExpanderTemplateSettings>
    {
        int32_t __stdcall get_ContentHeight(double* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<double>(this->shim().ContentHeight());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_NegativeContentHeight(double* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<double>(this->shim().NegativeContentHeight());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Controls::IFontIconSource> : produce_base<D, winrt::Microsoft::UI::Xaml::Controls::IFontIconSource>
    {
        int32_t __stdcall get_Glyph(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<hstring>(this->shim().Glyph());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_Glyph(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Glyph(*reinterpret_cast<hstring const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_FontSize(double* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<double>(this->shim().FontSize());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_FontSize(double value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().FontSize(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_FontFamily(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::Media::FontFamily>(this->shim().FontFamily());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_FontFamily(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().FontFamily(*reinterpret_cast<winrt::Windows::UI::Xaml::Media::FontFamily const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_FontWeight(struct struct_Windows_UI_Text_FontWeight* value) noexcept final try
        {
            zero_abi<winrt::Windows::UI::Text::FontWeight>(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Text::FontWeight>(this->shim().FontWeight());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_FontWeight(struct struct_Windows_UI_Text_FontWeight value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().FontWeight(*reinterpret_cast<winrt::Windows::UI::Text::FontWeight const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_FontStyle(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Text::FontStyle>(this->shim().FontStyle());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_FontStyle(int32_t value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().FontStyle(*reinterpret_cast<winrt::Windows::UI::Text::FontStyle const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_IsTextScaleFactorEnabled(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().IsTextScaleFactorEnabled());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_IsTextScaleFactorEnabled(bool value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().IsTextScaleFactorEnabled(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_MirroredWhenRightToLeft(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().MirroredWhenRightToLeft());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_MirroredWhenRightToLeft(bool value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().MirroredWhenRightToLeft(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Controls::IFontIconSourceFactory> : produce_base<D, winrt::Microsoft::UI::Xaml::Controls::IFontIconSourceFactory>
    {
        int32_t __stdcall CreateInstance(void* baseInterface, void** innerInterface, void** value) noexcept final try
        {
            if (innerInterface) *innerInterface = nullptr;
            winrt::Windows::Foundation::IInspectable winrt_impl_innerInterface;
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::UI::Xaml::Controls::FontIconSource>(this->shim().CreateInstance(*reinterpret_cast<winrt::Windows::Foundation::IInspectable const*>(&baseInterface), winrt_impl_innerInterface));
                if (innerInterface) *innerInterface = detach_abi(winrt_impl_innerInterface);
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Controls::IFontIconSourceStatics> : produce_base<D, winrt::Microsoft::UI::Xaml::Controls::IFontIconSourceStatics>
    {
        int32_t __stdcall get_GlyphProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().GlyphProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_FontSizeProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().FontSizeProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_FontFamilyProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().FontFamilyProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_FontWeightProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().FontWeightProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_FontStyleProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().FontStyleProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_IsTextScaleFactorEnabledProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().IsTextScaleFactorEnabledProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_MirroredWhenRightToLeftProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().MirroredWhenRightToLeftProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Controls::IIconSource> : produce_base<D, winrt::Microsoft::UI::Xaml::Controls::IIconSource>
    {
        int32_t __stdcall CreateIconElement(void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Windows::UI::Xaml::Controls::IconElement>(this->shim().CreateIconElement());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Foreground(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::Media::Brush>(this->shim().Foreground());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_Foreground(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Foreground(*reinterpret_cast<winrt::Windows::UI::Xaml::Media::Brush const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Controls::IIconSourceFactory> : produce_base<D, winrt::Microsoft::UI::Xaml::Controls::IIconSourceFactory>
    {
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Controls::IIconSourceStatics> : produce_base<D, winrt::Microsoft::UI::Xaml::Controls::IIconSourceStatics>
    {
        int32_t __stdcall get_ForegroundProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().ForegroundProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Controls::IImageIcon> : produce_base<D, winrt::Microsoft::UI::Xaml::Controls::IImageIcon>
    {
        int32_t __stdcall get_Source(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::Media::ImageSource>(this->shim().Source());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_Source(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Source(*reinterpret_cast<winrt::Windows::UI::Xaml::Media::ImageSource const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Controls::IImageIconFactory> : produce_base<D, winrt::Microsoft::UI::Xaml::Controls::IImageIconFactory>
    {
        int32_t __stdcall CreateInstance(void* baseInterface, void** innerInterface, void** value) noexcept final try
        {
            if (innerInterface) *innerInterface = nullptr;
            winrt::Windows::Foundation::IInspectable winrt_impl_innerInterface;
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::UI::Xaml::Controls::ImageIcon>(this->shim().CreateInstance(*reinterpret_cast<winrt::Windows::Foundation::IInspectable const*>(&baseInterface), winrt_impl_innerInterface));
                if (innerInterface) *innerInterface = detach_abi(winrt_impl_innerInterface);
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Controls::IImageIconSource> : produce_base<D, winrt::Microsoft::UI::Xaml::Controls::IImageIconSource>
    {
        int32_t __stdcall get_ImageSource(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::Media::ImageSource>(this->shim().ImageSource());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_ImageSource(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().ImageSource(*reinterpret_cast<winrt::Windows::UI::Xaml::Media::ImageSource const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Controls::IImageIconSourceFactory> : produce_base<D, winrt::Microsoft::UI::Xaml::Controls::IImageIconSourceFactory>
    {
        int32_t __stdcall CreateInstance(void* baseInterface, void** innerInterface, void** value) noexcept final try
        {
            if (innerInterface) *innerInterface = nullptr;
            winrt::Windows::Foundation::IInspectable winrt_impl_innerInterface;
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::UI::Xaml::Controls::ImageIconSource>(this->shim().CreateInstance(*reinterpret_cast<winrt::Windows::Foundation::IInspectable const*>(&baseInterface), winrt_impl_innerInterface));
                if (innerInterface) *innerInterface = detach_abi(winrt_impl_innerInterface);
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Controls::IImageIconSourceStatics> : produce_base<D, winrt::Microsoft::UI::Xaml::Controls::IImageIconSourceStatics>
    {
        int32_t __stdcall get_ImageSourceProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().ImageSourceProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Controls::IImageIconStatics> : produce_base<D, winrt::Microsoft::UI::Xaml::Controls::IImageIconStatics>
    {
        int32_t __stdcall get_SourceProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().SourceProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Controls::IInfoBadge> : produce_base<D, winrt::Microsoft::UI::Xaml::Controls::IInfoBadge>
    {
        int32_t __stdcall get_Value(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<int32_t>(this->shim().Value());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_Value(int32_t value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Value(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_IconSource(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::UI::Xaml::Controls::IconSource>(this->shim().IconSource());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_IconSource(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().IconSource(*reinterpret_cast<winrt::Microsoft::UI::Xaml::Controls::IconSource const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_TemplateSettings(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::UI::Xaml::Controls::InfoBadgeTemplateSettings>(this->shim().TemplateSettings());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Controls::IInfoBadgeFactory> : produce_base<D, winrt::Microsoft::UI::Xaml::Controls::IInfoBadgeFactory>
    {
        int32_t __stdcall CreateInstance(void* baseInterface, void** innerInterface, void** value) noexcept final try
        {
            if (innerInterface) *innerInterface = nullptr;
            winrt::Windows::Foundation::IInspectable winrt_impl_innerInterface;
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::UI::Xaml::Controls::InfoBadge>(this->shim().CreateInstance(*reinterpret_cast<winrt::Windows::Foundation::IInspectable const*>(&baseInterface), winrt_impl_innerInterface));
                if (innerInterface) *innerInterface = detach_abi(winrt_impl_innerInterface);
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Controls::IInfoBadgeStatics> : produce_base<D, winrt::Microsoft::UI::Xaml::Controls::IInfoBadgeStatics>
    {
        int32_t __stdcall get_ValueProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().ValueProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_IconSourceProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().IconSourceProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_TemplateSettingsProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().TemplateSettingsProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Controls::IInfoBadgeTemplateSettings> : produce_base<D, winrt::Microsoft::UI::Xaml::Controls::IInfoBadgeTemplateSettings>
    {
        int32_t __stdcall get_InfoBadgeCornerRadius(struct struct_Windows_UI_Xaml_CornerRadius* value) noexcept final try
        {
            zero_abi<winrt::Windows::UI::Xaml::CornerRadius>(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::CornerRadius>(this->shim().InfoBadgeCornerRadius());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_InfoBadgeCornerRadius(struct struct_Windows_UI_Xaml_CornerRadius value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().InfoBadgeCornerRadius(*reinterpret_cast<winrt::Windows::UI::Xaml::CornerRadius const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_IconElement(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::Controls::IconElement>(this->shim().IconElement());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_IconElement(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().IconElement(*reinterpret_cast<winrt::Windows::UI::Xaml::Controls::IconElement const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Controls::IInfoBadgeTemplateSettingsFactory> : produce_base<D, winrt::Microsoft::UI::Xaml::Controls::IInfoBadgeTemplateSettingsFactory>
    {
        int32_t __stdcall CreateInstance(void* baseInterface, void** innerInterface, void** value) noexcept final try
        {
            if (innerInterface) *innerInterface = nullptr;
            winrt::Windows::Foundation::IInspectable winrt_impl_innerInterface;
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::UI::Xaml::Controls::InfoBadgeTemplateSettings>(this->shim().CreateInstance(*reinterpret_cast<winrt::Windows::Foundation::IInspectable const*>(&baseInterface), winrt_impl_innerInterface));
                if (innerInterface) *innerInterface = detach_abi(winrt_impl_innerInterface);
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Controls::IInfoBadgeTemplateSettingsStatics> : produce_base<D, winrt::Microsoft::UI::Xaml::Controls::IInfoBadgeTemplateSettingsStatics>
    {
        int32_t __stdcall get_InfoBadgeCornerRadiusProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().InfoBadgeCornerRadiusProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_IconElementProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().IconElementProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Controls::IInfoBar> : produce_base<D, winrt::Microsoft::UI::Xaml::Controls::IInfoBar>
    {
        int32_t __stdcall get_IsOpen(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().IsOpen());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_IsOpen(bool value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().IsOpen(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Title(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<hstring>(this->shim().Title());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_Title(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Title(*reinterpret_cast<hstring const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Message(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<hstring>(this->shim().Message());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_Message(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Message(*reinterpret_cast<hstring const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Severity(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::UI::Xaml::Controls::InfoBarSeverity>(this->shim().Severity());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_Severity(int32_t value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Severity(*reinterpret_cast<winrt::Microsoft::UI::Xaml::Controls::InfoBarSeverity const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_IconSource(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::UI::Xaml::Controls::IconSource>(this->shim().IconSource());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_IconSource(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().IconSource(*reinterpret_cast<winrt::Microsoft::UI::Xaml::Controls::IconSource const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_IsIconVisible(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().IsIconVisible());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_IsIconVisible(bool value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().IsIconVisible(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_IsClosable(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().IsClosable());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_IsClosable(bool value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().IsClosable(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_CloseButtonStyle(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::Style>(this->shim().CloseButtonStyle());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_CloseButtonStyle(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().CloseButtonStyle(*reinterpret_cast<winrt::Windows::UI::Xaml::Style const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_CloseButtonCommand(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::Input::ICommand>(this->shim().CloseButtonCommand());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_CloseButtonCommand(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().CloseButtonCommand(*reinterpret_cast<winrt::Windows::UI::Xaml::Input::ICommand const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_CloseButtonCommandParameter(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::IInspectable>(this->shim().CloseButtonCommandParameter());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_CloseButtonCommandParameter(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().CloseButtonCommandParameter(*reinterpret_cast<winrt::Windows::Foundation::IInspectable const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_ActionButton(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::Controls::Primitives::ButtonBase>(this->shim().ActionButton());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_ActionButton(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().ActionButton(*reinterpret_cast<winrt::Windows::UI::Xaml::Controls::Primitives::ButtonBase const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Content(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::IInspectable>(this->shim().Content());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_Content(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Content(*reinterpret_cast<winrt::Windows::Foundation::IInspectable const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_ContentTemplate(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DataTemplate>(this->shim().ContentTemplate());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_ContentTemplate(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().ContentTemplate(*reinterpret_cast<winrt::Windows::UI::Xaml::DataTemplate const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_TemplateSettings(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::UI::Xaml::Controls::InfoBarTemplateSettings>(this->shim().TemplateSettings());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall add_CloseButtonClick(void* handler, winrt::event_token* token) noexcept final try
        {
            zero_abi<winrt::event_token>(token);
            typename D::abi_guard guard(this->shim());
            *token = detach_from<winrt::event_token>(this->shim().CloseButtonClick(*reinterpret_cast<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Xaml::Controls::InfoBar, winrt::Windows::Foundation::IInspectable> const*>(&handler)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall remove_CloseButtonClick(winrt::event_token token) noexcept final
        {
            typename D::abi_guard guard(this->shim());
            this->shim().CloseButtonClick(*reinterpret_cast<winrt::event_token const*>(&token));
            return 0;
        }
        int32_t __stdcall add_Closing(void* handler, winrt::event_token* token) noexcept final try
        {
            zero_abi<winrt::event_token>(token);
            typename D::abi_guard guard(this->shim());
            *token = detach_from<winrt::event_token>(this->shim().Closing(*reinterpret_cast<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Xaml::Controls::InfoBar, winrt::Microsoft::UI::Xaml::Controls::InfoBarClosingEventArgs> const*>(&handler)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall remove_Closing(winrt::event_token token) noexcept final
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Closing(*reinterpret_cast<winrt::event_token const*>(&token));
            return 0;
        }
        int32_t __stdcall add_Closed(void* handler, winrt::event_token* token) noexcept final try
        {
            zero_abi<winrt::event_token>(token);
            typename D::abi_guard guard(this->shim());
            *token = detach_from<winrt::event_token>(this->shim().Closed(*reinterpret_cast<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Xaml::Controls::InfoBar, winrt::Microsoft::UI::Xaml::Controls::InfoBarClosedEventArgs> const*>(&handler)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall remove_Closed(winrt::event_token token) noexcept final
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Closed(*reinterpret_cast<winrt::event_token const*>(&token));
            return 0;
        }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Controls::IInfoBarClosedEventArgs> : produce_base<D, winrt::Microsoft::UI::Xaml::Controls::IInfoBarClosedEventArgs>
    {
        int32_t __stdcall get_Reason(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::UI::Xaml::Controls::InfoBarCloseReason>(this->shim().Reason());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Controls::IInfoBarClosedEventArgsFactory> : produce_base<D, winrt::Microsoft::UI::Xaml::Controls::IInfoBarClosedEventArgsFactory>
    {
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Controls::IInfoBarClosingEventArgs> : produce_base<D, winrt::Microsoft::UI::Xaml::Controls::IInfoBarClosingEventArgs>
    {
        int32_t __stdcall get_Reason(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::UI::Xaml::Controls::InfoBarCloseReason>(this->shim().Reason());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Cancel(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().Cancel());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_Cancel(bool value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Cancel(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Controls::IInfoBarClosingEventArgsFactory> : produce_base<D, winrt::Microsoft::UI::Xaml::Controls::IInfoBarClosingEventArgsFactory>
    {
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Controls::IInfoBarFactory> : produce_base<D, winrt::Microsoft::UI::Xaml::Controls::IInfoBarFactory>
    {
        int32_t __stdcall CreateInstance(void* baseInterface, void** innerInterface, void** value) noexcept final try
        {
            if (innerInterface) *innerInterface = nullptr;
            winrt::Windows::Foundation::IInspectable winrt_impl_innerInterface;
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::UI::Xaml::Controls::InfoBar>(this->shim().CreateInstance(*reinterpret_cast<winrt::Windows::Foundation::IInspectable const*>(&baseInterface), winrt_impl_innerInterface));
                if (innerInterface) *innerInterface = detach_abi(winrt_impl_innerInterface);
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Controls::IInfoBarStatics> : produce_base<D, winrt::Microsoft::UI::Xaml::Controls::IInfoBarStatics>
    {
        int32_t __stdcall get_IsOpenProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().IsOpenProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_TitleProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().TitleProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_MessageProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().MessageProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_SeverityProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().SeverityProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_IconSourceProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().IconSourceProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_IsIconVisibleProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().IsIconVisibleProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_IsClosableProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().IsClosableProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_CloseButtonStyleProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().CloseButtonStyleProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_CloseButtonCommandProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().CloseButtonCommandProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_CloseButtonCommandParameterProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().CloseButtonCommandParameterProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_ActionButtonProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().ActionButtonProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_ContentProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().ContentProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_ContentTemplateProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().ContentTemplateProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_TemplateSettingsProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().TemplateSettingsProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Controls::IInfoBarTemplateSettings> : produce_base<D, winrt::Microsoft::UI::Xaml::Controls::IInfoBarTemplateSettings>
    {
        int32_t __stdcall get_IconElement(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::Controls::IconElement>(this->shim().IconElement());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_IconElement(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().IconElement(*reinterpret_cast<winrt::Windows::UI::Xaml::Controls::IconElement const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Controls::IInfoBarTemplateSettingsFactory> : produce_base<D, winrt::Microsoft::UI::Xaml::Controls::IInfoBarTemplateSettingsFactory>
    {
        int32_t __stdcall CreateInstance(void* baseInterface, void** innerInterface, void** value) noexcept final try
        {
            if (innerInterface) *innerInterface = nullptr;
            winrt::Windows::Foundation::IInspectable winrt_impl_innerInterface;
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::UI::Xaml::Controls::InfoBarTemplateSettings>(this->shim().CreateInstance(*reinterpret_cast<winrt::Windows::Foundation::IInspectable const*>(&baseInterface), winrt_impl_innerInterface));
                if (innerInterface) *innerInterface = detach_abi(winrt_impl_innerInterface);
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Controls::IInfoBarTemplateSettingsStatics> : produce_base<D, winrt::Microsoft::UI::Xaml::Controls::IInfoBarTemplateSettingsStatics>
    {
        int32_t __stdcall get_IconElementProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().IconElementProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Controls::IItemsRepeater> : produce_base<D, winrt::Microsoft::UI::Xaml::Controls::IItemsRepeater>
    {
        int32_t __stdcall get_ItemsSource(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::IInspectable>(this->shim().ItemsSource());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_ItemsSource(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().ItemsSource(*reinterpret_cast<winrt::Windows::Foundation::IInspectable const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_ItemsSourceView(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::UI::Xaml::Controls::ItemsSourceView>(this->shim().ItemsSourceView());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_ItemTemplate(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::IInspectable>(this->shim().ItemTemplate());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_ItemTemplate(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().ItemTemplate(*reinterpret_cast<winrt::Windows::Foundation::IInspectable const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Layout(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::UI::Xaml::Controls::Layout>(this->shim().Layout());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_Layout(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Layout(*reinterpret_cast<winrt::Microsoft::UI::Xaml::Controls::Layout const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_HorizontalCacheLength(double* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<double>(this->shim().HorizontalCacheLength());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_HorizontalCacheLength(double value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().HorizontalCacheLength(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_VerticalCacheLength(double* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<double>(this->shim().VerticalCacheLength());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_VerticalCacheLength(double value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().VerticalCacheLength(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Background(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::Media::Brush>(this->shim().Background());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_Background(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Background(*reinterpret_cast<winrt::Windows::UI::Xaml::Media::Brush const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall GetElementIndex(void* element, int32_t* result) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *result = detach_from<int32_t>(this->shim().GetElementIndex(*reinterpret_cast<winrt::Windows::UI::Xaml::UIElement const*>(&element)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall TryGetElement(int32_t index, void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Windows::UI::Xaml::UIElement>(this->shim().TryGetElement(index));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall GetOrCreateElement(int32_t index, void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Windows::UI::Xaml::UIElement>(this->shim().GetOrCreateElement(index));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall add_ElementPrepared(void* handler, winrt::event_token* token) noexcept final try
        {
            zero_abi<winrt::event_token>(token);
            typename D::abi_guard guard(this->shim());
            *token = detach_from<winrt::event_token>(this->shim().ElementPrepared(*reinterpret_cast<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Xaml::Controls::ItemsRepeater, winrt::Microsoft::UI::Xaml::Controls::ItemsRepeaterElementPreparedEventArgs> const*>(&handler)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall remove_ElementPrepared(winrt::event_token token) noexcept final
        {
            typename D::abi_guard guard(this->shim());
            this->shim().ElementPrepared(*reinterpret_cast<winrt::event_token const*>(&token));
            return 0;
        }
        int32_t __stdcall add_ElementClearing(void* handler, winrt::event_token* token) noexcept final try
        {
            zero_abi<winrt::event_token>(token);
            typename D::abi_guard guard(this->shim());
            *token = detach_from<winrt::event_token>(this->shim().ElementClearing(*reinterpret_cast<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Xaml::Controls::ItemsRepeater, winrt::Microsoft::UI::Xaml::Controls::ItemsRepeaterElementClearingEventArgs> const*>(&handler)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall remove_ElementClearing(winrt::event_token token) noexcept final
        {
            typename D::abi_guard guard(this->shim());
            this->shim().ElementClearing(*reinterpret_cast<winrt::event_token const*>(&token));
            return 0;
        }
        int32_t __stdcall add_ElementIndexChanged(void* handler, winrt::event_token* token) noexcept final try
        {
            zero_abi<winrt::event_token>(token);
            typename D::abi_guard guard(this->shim());
            *token = detach_from<winrt::event_token>(this->shim().ElementIndexChanged(*reinterpret_cast<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Xaml::Controls::ItemsRepeater, winrt::Microsoft::UI::Xaml::Controls::ItemsRepeaterElementIndexChangedEventArgs> const*>(&handler)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall remove_ElementIndexChanged(winrt::event_token token) noexcept final
        {
            typename D::abi_guard guard(this->shim());
            this->shim().ElementIndexChanged(*reinterpret_cast<winrt::event_token const*>(&token));
            return 0;
        }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Controls::IItemsRepeaterElementClearingEventArgs> : produce_base<D, winrt::Microsoft::UI::Xaml::Controls::IItemsRepeaterElementClearingEventArgs>
    {
        int32_t __stdcall get_Element(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::UIElement>(this->shim().Element());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Controls::IItemsRepeaterElementIndexChangedEventArgs> : produce_base<D, winrt::Microsoft::UI::Xaml::Controls::IItemsRepeaterElementIndexChangedEventArgs>
    {
        int32_t __stdcall get_Element(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::UIElement>(this->shim().Element());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_OldIndex(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<int32_t>(this->shim().OldIndex());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_NewIndex(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<int32_t>(this->shim().NewIndex());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Controls::IItemsRepeaterElementPreparedEventArgs> : produce_base<D, winrt::Microsoft::UI::Xaml::Controls::IItemsRepeaterElementPreparedEventArgs>
    {
        int32_t __stdcall get_Element(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::UIElement>(this->shim().Element());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Index(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<int32_t>(this->shim().Index());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Controls::IItemsRepeaterFactory> : produce_base<D, winrt::Microsoft::UI::Xaml::Controls::IItemsRepeaterFactory>
    {
        int32_t __stdcall CreateInstance(void* baseInterface, void** innerInterface, void** value) noexcept final try
        {
            if (innerInterface) *innerInterface = nullptr;
            winrt::Windows::Foundation::IInspectable winrt_impl_innerInterface;
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::UI::Xaml::Controls::ItemsRepeater>(this->shim().CreateInstance(*reinterpret_cast<winrt::Windows::Foundation::IInspectable const*>(&baseInterface), winrt_impl_innerInterface));
                if (innerInterface) *innerInterface = detach_abi(winrt_impl_innerInterface);
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Controls::IItemsRepeaterScrollHost> : produce_base<D, winrt::Microsoft::UI::Xaml::Controls::IItemsRepeaterScrollHost>
    {
        int32_t __stdcall get_ScrollViewer(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::Controls::ScrollViewer>(this->shim().ScrollViewer());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_ScrollViewer(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().ScrollViewer(*reinterpret_cast<winrt::Windows::UI::Xaml::Controls::ScrollViewer const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_CurrentAnchor(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::UIElement>(this->shim().CurrentAnchor());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_HorizontalAnchorRatio(double* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<double>(this->shim().HorizontalAnchorRatio());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_HorizontalAnchorRatio(double value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().HorizontalAnchorRatio(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_VerticalAnchorRatio(double* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<double>(this->shim().VerticalAnchorRatio());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_VerticalAnchorRatio(double value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().VerticalAnchorRatio(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Controls::IItemsRepeaterStatics> : produce_base<D, winrt::Microsoft::UI::Xaml::Controls::IItemsRepeaterStatics>
    {
        int32_t __stdcall get_ItemsSourceProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().ItemsSourceProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_ItemTemplateProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().ItemTemplateProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_LayoutProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().LayoutProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_HorizontalCacheLengthProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().HorizontalCacheLengthProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_VerticalCacheLengthProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().VerticalCacheLengthProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_BackgroundProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().BackgroundProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Controls::IItemsSourceView> : produce_base<D, winrt::Microsoft::UI::Xaml::Controls::IItemsSourceView>
    {
        int32_t __stdcall get_Count(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<int32_t>(this->shim().Count());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall GetAt(int32_t index, void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Windows::Foundation::IInspectable>(this->shim().GetAt(index));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_HasKeyIndexMapping(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().HasKeyIndexMapping());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall KeyFromIndex(int32_t index, void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<hstring>(this->shim().KeyFromIndex(index));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall IndexFromKey(void* key, int32_t* result) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *result = detach_from<int32_t>(this->shim().IndexFromKey(*reinterpret_cast<hstring const*>(&key)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall IndexOf(void* item, int32_t* result) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *result = detach_from<int32_t>(this->shim().IndexOf(*reinterpret_cast<winrt::Windows::Foundation::IInspectable const*>(&item)));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Controls::IItemsSourceViewFactory> : produce_base<D, winrt::Microsoft::UI::Xaml::Controls::IItemsSourceViewFactory>
    {
        int32_t __stdcall CreateInstance(void* source, void* baseInterface, void** innerInterface, void** value) noexcept final try
        {
            if (innerInterface) *innerInterface = nullptr;
            winrt::Windows::Foundation::IInspectable winrt_impl_innerInterface;
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::UI::Xaml::Controls::ItemsSourceView>(this->shim().CreateInstance(*reinterpret_cast<winrt::Windows::Foundation::IInspectable const*>(&source), *reinterpret_cast<winrt::Windows::Foundation::IInspectable const*>(&baseInterface), winrt_impl_innerInterface));
                if (innerInterface) *innerInterface = detach_abi(winrt_impl_innerInterface);
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Controls::IKeyIndexMapping> : produce_base<D, winrt::Microsoft::UI::Xaml::Controls::IKeyIndexMapping>
    {
        int32_t __stdcall KeyFromIndex(int32_t index, void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<hstring>(this->shim().KeyFromIndex(index));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall IndexFromKey(void* key, int32_t* result) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *result = detach_from<int32_t>(this->shim().IndexFromKey(*reinterpret_cast<hstring const*>(&key)));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Controls::ILayout> : produce_base<D, winrt::Microsoft::UI::Xaml::Controls::ILayout>
    {
        int32_t __stdcall InitializeForContext(void* context) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().InitializeForContext(*reinterpret_cast<winrt::Microsoft::UI::Xaml::Controls::LayoutContext const*>(&context));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall UninitializeForContext(void* context) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().UninitializeForContext(*reinterpret_cast<winrt::Microsoft::UI::Xaml::Controls::LayoutContext const*>(&context));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall Measure(void* context, winrt::Windows::Foundation::Size availableSize, winrt::Windows::Foundation::Size* result) noexcept final try
        {
            zero_abi<winrt::Windows::Foundation::Size>(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Windows::Foundation::Size>(this->shim().Measure(*reinterpret_cast<winrt::Microsoft::UI::Xaml::Controls::LayoutContext const*>(&context), *reinterpret_cast<winrt::Windows::Foundation::Size const*>(&availableSize)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall Arrange(void* context, winrt::Windows::Foundation::Size finalSize, winrt::Windows::Foundation::Size* result) noexcept final try
        {
            zero_abi<winrt::Windows::Foundation::Size>(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Windows::Foundation::Size>(this->shim().Arrange(*reinterpret_cast<winrt::Microsoft::UI::Xaml::Controls::LayoutContext const*>(&context), *reinterpret_cast<winrt::Windows::Foundation::Size const*>(&finalSize)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall add_MeasureInvalidated(void* handler, winrt::event_token* token) noexcept final try
        {
            zero_abi<winrt::event_token>(token);
            typename D::abi_guard guard(this->shim());
            *token = detach_from<winrt::event_token>(this->shim().MeasureInvalidated(*reinterpret_cast<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Xaml::Controls::Layout, winrt::Windows::Foundation::IInspectable> const*>(&handler)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall remove_MeasureInvalidated(winrt::event_token token) noexcept final
        {
            typename D::abi_guard guard(this->shim());
            this->shim().MeasureInvalidated(*reinterpret_cast<winrt::event_token const*>(&token));
            return 0;
        }
        int32_t __stdcall add_ArrangeInvalidated(void* handler, winrt::event_token* token) noexcept final try
        {
            zero_abi<winrt::event_token>(token);
            typename D::abi_guard guard(this->shim());
            *token = detach_from<winrt::event_token>(this->shim().ArrangeInvalidated(*reinterpret_cast<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Xaml::Controls::Layout, winrt::Windows::Foundation::IInspectable> const*>(&handler)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall remove_ArrangeInvalidated(winrt::event_token token) noexcept final
        {
            typename D::abi_guard guard(this->shim());
            this->shim().ArrangeInvalidated(*reinterpret_cast<winrt::event_token const*>(&token));
            return 0;
        }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Controls::ILayoutContext> : produce_base<D, winrt::Microsoft::UI::Xaml::Controls::ILayoutContext>
    {
        int32_t __stdcall get_LayoutState(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::IInspectable>(this->shim().LayoutState());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_LayoutState(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().LayoutState(*reinterpret_cast<winrt::Windows::Foundation::IInspectable const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Controls::ILayoutContextFactory> : produce_base<D, winrt::Microsoft::UI::Xaml::Controls::ILayoutContextFactory>
    {
    };
#endif
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Controls::ILayoutContextOverrides> : produce_base<D, winrt::Microsoft::UI::Xaml::Controls::ILayoutContextOverrides>
    {
        int32_t __stdcall get_LayoutStateCore(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::IInspectable>(this->shim().LayoutStateCore());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_LayoutStateCore(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().LayoutStateCore(*reinterpret_cast<winrt::Windows::Foundation::IInspectable const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Controls::ILayoutFactory> : produce_base<D, winrt::Microsoft::UI::Xaml::Controls::ILayoutFactory>
    {
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Controls::ILayoutProtected> : produce_base<D, winrt::Microsoft::UI::Xaml::Controls::ILayoutProtected>
    {
        int32_t __stdcall InvalidateMeasure() noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().InvalidateMeasure();
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall InvalidateArrange() noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().InvalidateArrange();
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Controls::IMenuBar> : produce_base<D, winrt::Microsoft::UI::Xaml::Controls::IMenuBar>
    {
        int32_t __stdcall get_Items(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::Collections::IVector<winrt::Microsoft::UI::Xaml::Controls::MenuBarItem>>(this->shim().Items());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Controls::IMenuBarFactory> : produce_base<D, winrt::Microsoft::UI::Xaml::Controls::IMenuBarFactory>
    {
        int32_t __stdcall CreateInstance(void* baseInterface, void** innerInterface, void** value) noexcept final try
        {
            if (innerInterface) *innerInterface = nullptr;
            winrt::Windows::Foundation::IInspectable winrt_impl_innerInterface;
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::UI::Xaml::Controls::MenuBar>(this->shim().CreateInstance(*reinterpret_cast<winrt::Windows::Foundation::IInspectable const*>(&baseInterface), winrt_impl_innerInterface));
                if (innerInterface) *innerInterface = detach_abi(winrt_impl_innerInterface);
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Controls::IMenuBarItem> : produce_base<D, winrt::Microsoft::UI::Xaml::Controls::IMenuBarItem>
    {
        int32_t __stdcall get_Title(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<hstring>(this->shim().Title());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_Title(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Title(*reinterpret_cast<hstring const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Items(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::Collections::IVector<winrt::Windows::UI::Xaml::Controls::MenuFlyoutItemBase>>(this->shim().Items());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Controls::IMenuBarItemFactory> : produce_base<D, winrt::Microsoft::UI::Xaml::Controls::IMenuBarItemFactory>
    {
        int32_t __stdcall CreateInstance(void* baseInterface, void** innerInterface, void** value) noexcept final try
        {
            if (innerInterface) *innerInterface = nullptr;
            winrt::Windows::Foundation::IInspectable winrt_impl_innerInterface;
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::UI::Xaml::Controls::MenuBarItem>(this->shim().CreateInstance(*reinterpret_cast<winrt::Windows::Foundation::IInspectable const*>(&baseInterface), winrt_impl_innerInterface));
                if (innerInterface) *innerInterface = detach_abi(winrt_impl_innerInterface);
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Controls::IMenuBarItemFlyout> : produce_base<D, winrt::Microsoft::UI::Xaml::Controls::IMenuBarItemFlyout>
    {
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Controls::IMenuBarItemFlyoutFactory> : produce_base<D, winrt::Microsoft::UI::Xaml::Controls::IMenuBarItemFlyoutFactory>
    {
        int32_t __stdcall CreateInstance(void* baseInterface, void** innerInterface, void** value) noexcept final try
        {
            if (innerInterface) *innerInterface = nullptr;
            winrt::Windows::Foundation::IInspectable winrt_impl_innerInterface;
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::UI::Xaml::Controls::MenuBarItemFlyout>(this->shim().CreateInstance(*reinterpret_cast<winrt::Windows::Foundation::IInspectable const*>(&baseInterface), winrt_impl_innerInterface));
                if (innerInterface) *innerInterface = detach_abi(winrt_impl_innerInterface);
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Controls::IMenuBarItemStatics> : produce_base<D, winrt::Microsoft::UI::Xaml::Controls::IMenuBarItemStatics>
    {
        int32_t __stdcall get_TitleProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().TitleProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_ItemsProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().ItemsProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Controls::IMenuBarStatics> : produce_base<D, winrt::Microsoft::UI::Xaml::Controls::IMenuBarStatics>
    {
        int32_t __stdcall get_ItemsProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().ItemsProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Controls::INavigationView> : produce_base<D, winrt::Microsoft::UI::Xaml::Controls::INavigationView>
    {
        int32_t __stdcall get_IsPaneOpen(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().IsPaneOpen());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_IsPaneOpen(bool value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().IsPaneOpen(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_CompactModeThresholdWidth(double* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<double>(this->shim().CompactModeThresholdWidth());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_CompactModeThresholdWidth(double value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().CompactModeThresholdWidth(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_ExpandedModeThresholdWidth(double* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<double>(this->shim().ExpandedModeThresholdWidth());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_ExpandedModeThresholdWidth(double value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().ExpandedModeThresholdWidth(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_FooterMenuItems(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::Collections::IVector<winrt::Windows::Foundation::IInspectable>>(this->shim().FooterMenuItems());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_FooterMenuItemsSource(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::IInspectable>(this->shim().FooterMenuItemsSource());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_FooterMenuItemsSource(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().FooterMenuItemsSource(*reinterpret_cast<winrt::Windows::Foundation::IInspectable const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_PaneFooter(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::UIElement>(this->shim().PaneFooter());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_PaneFooter(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().PaneFooter(*reinterpret_cast<winrt::Windows::UI::Xaml::UIElement const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Header(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::IInspectable>(this->shim().Header());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_Header(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Header(*reinterpret_cast<winrt::Windows::Foundation::IInspectable const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_HeaderTemplate(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DataTemplate>(this->shim().HeaderTemplate());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_HeaderTemplate(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().HeaderTemplate(*reinterpret_cast<winrt::Windows::UI::Xaml::DataTemplate const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_DisplayMode(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::UI::Xaml::Controls::NavigationViewDisplayMode>(this->shim().DisplayMode());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_IsSettingsVisible(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().IsSettingsVisible());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_IsSettingsVisible(bool value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().IsSettingsVisible(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_IsPaneToggleButtonVisible(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().IsPaneToggleButtonVisible());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_IsPaneToggleButtonVisible(bool value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().IsPaneToggleButtonVisible(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_AlwaysShowHeader(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().AlwaysShowHeader());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_AlwaysShowHeader(bool value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().AlwaysShowHeader(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_CompactPaneLength(double* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<double>(this->shim().CompactPaneLength());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_CompactPaneLength(double value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().CompactPaneLength(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_OpenPaneLength(double* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<double>(this->shim().OpenPaneLength());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_OpenPaneLength(double value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().OpenPaneLength(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_PaneToggleButtonStyle(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::Style>(this->shim().PaneToggleButtonStyle());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_PaneToggleButtonStyle(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().PaneToggleButtonStyle(*reinterpret_cast<winrt::Windows::UI::Xaml::Style const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_SelectedItem(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::IInspectable>(this->shim().SelectedItem());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_SelectedItem(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().SelectedItem(*reinterpret_cast<winrt::Windows::Foundation::IInspectable const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_MenuItems(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::Collections::IVector<winrt::Windows::Foundation::IInspectable>>(this->shim().MenuItems());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_MenuItemsSource(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::IInspectable>(this->shim().MenuItemsSource());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_MenuItemsSource(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().MenuItemsSource(*reinterpret_cast<winrt::Windows::Foundation::IInspectable const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_SettingsItem(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::IInspectable>(this->shim().SettingsItem());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_AutoSuggestBox(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::Controls::AutoSuggestBox>(this->shim().AutoSuggestBox());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_AutoSuggestBox(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().AutoSuggestBox(*reinterpret_cast<winrt::Windows::UI::Xaml::Controls::AutoSuggestBox const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_MenuItemTemplate(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DataTemplate>(this->shim().MenuItemTemplate());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_MenuItemTemplate(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().MenuItemTemplate(*reinterpret_cast<winrt::Windows::UI::Xaml::DataTemplate const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_MenuItemTemplateSelector(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::Controls::DataTemplateSelector>(this->shim().MenuItemTemplateSelector());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_MenuItemTemplateSelector(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().MenuItemTemplateSelector(*reinterpret_cast<winrt::Windows::UI::Xaml::Controls::DataTemplateSelector const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_MenuItemContainerStyle(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::Style>(this->shim().MenuItemContainerStyle());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_MenuItemContainerStyle(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().MenuItemContainerStyle(*reinterpret_cast<winrt::Windows::UI::Xaml::Style const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_MenuItemContainerStyleSelector(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::Controls::StyleSelector>(this->shim().MenuItemContainerStyleSelector());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_MenuItemContainerStyleSelector(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().MenuItemContainerStyleSelector(*reinterpret_cast<winrt::Windows::UI::Xaml::Controls::StyleSelector const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall MenuItemFromContainer(void* container, void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Windows::Foundation::IInspectable>(this->shim().MenuItemFromContainer(*reinterpret_cast<winrt::Windows::UI::Xaml::DependencyObject const*>(&container)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall ContainerFromMenuItem(void* item, void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Windows::UI::Xaml::DependencyObject>(this->shim().ContainerFromMenuItem(*reinterpret_cast<winrt::Windows::Foundation::IInspectable const*>(&item)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall add_SelectionChanged(void* handler, winrt::event_token* token) noexcept final try
        {
            zero_abi<winrt::event_token>(token);
            typename D::abi_guard guard(this->shim());
            *token = detach_from<winrt::event_token>(this->shim().SelectionChanged(*reinterpret_cast<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Xaml::Controls::NavigationView, winrt::Microsoft::UI::Xaml::Controls::NavigationViewSelectionChangedEventArgs> const*>(&handler)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall remove_SelectionChanged(winrt::event_token token) noexcept final
        {
            typename D::abi_guard guard(this->shim());
            this->shim().SelectionChanged(*reinterpret_cast<winrt::event_token const*>(&token));
            return 0;
        }
        int32_t __stdcall add_ItemInvoked(void* handler, winrt::event_token* token) noexcept final try
        {
            zero_abi<winrt::event_token>(token);
            typename D::abi_guard guard(this->shim());
            *token = detach_from<winrt::event_token>(this->shim().ItemInvoked(*reinterpret_cast<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Xaml::Controls::NavigationView, winrt::Microsoft::UI::Xaml::Controls::NavigationViewItemInvokedEventArgs> const*>(&handler)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall remove_ItemInvoked(winrt::event_token token) noexcept final
        {
            typename D::abi_guard guard(this->shim());
            this->shim().ItemInvoked(*reinterpret_cast<winrt::event_token const*>(&token));
            return 0;
        }
        int32_t __stdcall add_DisplayModeChanged(void* handler, winrt::event_token* token) noexcept final try
        {
            zero_abi<winrt::event_token>(token);
            typename D::abi_guard guard(this->shim());
            *token = detach_from<winrt::event_token>(this->shim().DisplayModeChanged(*reinterpret_cast<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Xaml::Controls::NavigationView, winrt::Microsoft::UI::Xaml::Controls::NavigationViewDisplayModeChangedEventArgs> const*>(&handler)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall remove_DisplayModeChanged(winrt::event_token token) noexcept final
        {
            typename D::abi_guard guard(this->shim());
            this->shim().DisplayModeChanged(*reinterpret_cast<winrt::event_token const*>(&token));
            return 0;
        }
        int32_t __stdcall get_IsTitleBarAutoPaddingEnabled(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().IsTitleBarAutoPaddingEnabled());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_IsTitleBarAutoPaddingEnabled(bool value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().IsTitleBarAutoPaddingEnabled(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Controls::INavigationView2> : produce_base<D, winrt::Microsoft::UI::Xaml::Controls::INavigationView2>
    {
        int32_t __stdcall get_IsBackButtonVisible(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::UI::Xaml::Controls::NavigationViewBackButtonVisible>(this->shim().IsBackButtonVisible());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_IsBackButtonVisible(int32_t value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().IsBackButtonVisible(*reinterpret_cast<winrt::Microsoft::UI::Xaml::Controls::NavigationViewBackButtonVisible const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_IsBackEnabled(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().IsBackEnabled());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_IsBackEnabled(bool value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().IsBackEnabled(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_PaneTitle(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<hstring>(this->shim().PaneTitle());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_PaneTitle(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().PaneTitle(*reinterpret_cast<hstring const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall add_BackRequested(void* handler, winrt::event_token* token) noexcept final try
        {
            zero_abi<winrt::event_token>(token);
            typename D::abi_guard guard(this->shim());
            *token = detach_from<winrt::event_token>(this->shim().BackRequested(*reinterpret_cast<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Xaml::Controls::NavigationView, winrt::Microsoft::UI::Xaml::Controls::NavigationViewBackRequestedEventArgs> const*>(&handler)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall remove_BackRequested(winrt::event_token token) noexcept final
        {
            typename D::abi_guard guard(this->shim());
            this->shim().BackRequested(*reinterpret_cast<winrt::event_token const*>(&token));
            return 0;
        }
        int32_t __stdcall add_PaneClosed(void* handler, winrt::event_token* token) noexcept final try
        {
            zero_abi<winrt::event_token>(token);
            typename D::abi_guard guard(this->shim());
            *token = detach_from<winrt::event_token>(this->shim().PaneClosed(*reinterpret_cast<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Xaml::Controls::NavigationView, winrt::Windows::Foundation::IInspectable> const*>(&handler)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall remove_PaneClosed(winrt::event_token token) noexcept final
        {
            typename D::abi_guard guard(this->shim());
            this->shim().PaneClosed(*reinterpret_cast<winrt::event_token const*>(&token));
            return 0;
        }
        int32_t __stdcall add_PaneClosing(void* handler, winrt::event_token* token) noexcept final try
        {
            zero_abi<winrt::event_token>(token);
            typename D::abi_guard guard(this->shim());
            *token = detach_from<winrt::event_token>(this->shim().PaneClosing(*reinterpret_cast<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Xaml::Controls::NavigationView, winrt::Microsoft::UI::Xaml::Controls::NavigationViewPaneClosingEventArgs> const*>(&handler)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall remove_PaneClosing(winrt::event_token token) noexcept final
        {
            typename D::abi_guard guard(this->shim());
            this->shim().PaneClosing(*reinterpret_cast<winrt::event_token const*>(&token));
            return 0;
        }
        int32_t __stdcall add_PaneOpened(void* handler, winrt::event_token* token) noexcept final try
        {
            zero_abi<winrt::event_token>(token);
            typename D::abi_guard guard(this->shim());
            *token = detach_from<winrt::event_token>(this->shim().PaneOpened(*reinterpret_cast<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Xaml::Controls::NavigationView, winrt::Windows::Foundation::IInspectable> const*>(&handler)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall remove_PaneOpened(winrt::event_token token) noexcept final
        {
            typename D::abi_guard guard(this->shim());
            this->shim().PaneOpened(*reinterpret_cast<winrt::event_token const*>(&token));
            return 0;
        }
        int32_t __stdcall add_PaneOpening(void* handler, winrt::event_token* token) noexcept final try
        {
            zero_abi<winrt::event_token>(token);
            typename D::abi_guard guard(this->shim());
            *token = detach_from<winrt::event_token>(this->shim().PaneOpening(*reinterpret_cast<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Xaml::Controls::NavigationView, winrt::Windows::Foundation::IInspectable> const*>(&handler)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall remove_PaneOpening(winrt::event_token token) noexcept final
        {
            typename D::abi_guard guard(this->shim());
            this->shim().PaneOpening(*reinterpret_cast<winrt::event_token const*>(&token));
            return 0;
        }
        int32_t __stdcall get_PaneDisplayMode(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::UI::Xaml::Controls::NavigationViewPaneDisplayMode>(this->shim().PaneDisplayMode());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_PaneDisplayMode(int32_t value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().PaneDisplayMode(*reinterpret_cast<winrt::Microsoft::UI::Xaml::Controls::NavigationViewPaneDisplayMode const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_PaneHeader(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::UIElement>(this->shim().PaneHeader());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_PaneHeader(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().PaneHeader(*reinterpret_cast<winrt::Windows::UI::Xaml::UIElement const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_PaneCustomContent(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::UIElement>(this->shim().PaneCustomContent());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_PaneCustomContent(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().PaneCustomContent(*reinterpret_cast<winrt::Windows::UI::Xaml::UIElement const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_ContentOverlay(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::UIElement>(this->shim().ContentOverlay());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_ContentOverlay(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().ContentOverlay(*reinterpret_cast<winrt::Windows::UI::Xaml::UIElement const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_IsPaneVisible(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().IsPaneVisible());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_IsPaneVisible(bool value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().IsPaneVisible(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_SelectionFollowsFocus(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::UI::Xaml::Controls::NavigationViewSelectionFollowsFocus>(this->shim().SelectionFollowsFocus());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_SelectionFollowsFocus(int32_t value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().SelectionFollowsFocus(*reinterpret_cast<winrt::Microsoft::UI::Xaml::Controls::NavigationViewSelectionFollowsFocus const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_TemplateSettings(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::UI::Xaml::Controls::NavigationViewTemplateSettings>(this->shim().TemplateSettings());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_ShoulderNavigationEnabled(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::UI::Xaml::Controls::NavigationViewShoulderNavigationEnabled>(this->shim().ShoulderNavigationEnabled());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_ShoulderNavigationEnabled(int32_t value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().ShoulderNavigationEnabled(*reinterpret_cast<winrt::Microsoft::UI::Xaml::Controls::NavigationViewShoulderNavigationEnabled const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_OverflowLabelMode(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::UI::Xaml::Controls::NavigationViewOverflowLabelMode>(this->shim().OverflowLabelMode());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_OverflowLabelMode(int32_t value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().OverflowLabelMode(*reinterpret_cast<winrt::Microsoft::UI::Xaml::Controls::NavigationViewOverflowLabelMode const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall add_Expanding(void* handler, winrt::event_token* token) noexcept final try
        {
            zero_abi<winrt::event_token>(token);
            typename D::abi_guard guard(this->shim());
            *token = detach_from<winrt::event_token>(this->shim().Expanding(*reinterpret_cast<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Xaml::Controls::NavigationView, winrt::Microsoft::UI::Xaml::Controls::NavigationViewItemExpandingEventArgs> const*>(&handler)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall remove_Expanding(winrt::event_token token) noexcept final
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Expanding(*reinterpret_cast<winrt::event_token const*>(&token));
            return 0;
        }
        int32_t __stdcall add_Collapsed(void* handler, winrt::event_token* token) noexcept final try
        {
            zero_abi<winrt::event_token>(token);
            typename D::abi_guard guard(this->shim());
            *token = detach_from<winrt::event_token>(this->shim().Collapsed(*reinterpret_cast<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Xaml::Controls::NavigationView, winrt::Microsoft::UI::Xaml::Controls::NavigationViewItemCollapsedEventArgs> const*>(&handler)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall remove_Collapsed(winrt::event_token token) noexcept final
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Collapsed(*reinterpret_cast<winrt::event_token const*>(&token));
            return 0;
        }
        int32_t __stdcall Expand(void* item) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Expand(*reinterpret_cast<winrt::Microsoft::UI::Xaml::Controls::NavigationViewItem const*>(&item));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall Collapse(void* item) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Collapse(*reinterpret_cast<winrt::Microsoft::UI::Xaml::Controls::NavigationViewItem const*>(&item));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Controls::INavigationViewBackRequestedEventArgs> : produce_base<D, winrt::Microsoft::UI::Xaml::Controls::INavigationViewBackRequestedEventArgs>
    {
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Controls::INavigationViewDisplayModeChangedEventArgs> : produce_base<D, winrt::Microsoft::UI::Xaml::Controls::INavigationViewDisplayModeChangedEventArgs>
    {
        int32_t __stdcall get_DisplayMode(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::UI::Xaml::Controls::NavigationViewDisplayMode>(this->shim().DisplayMode());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Controls::INavigationViewFactory> : produce_base<D, winrt::Microsoft::UI::Xaml::Controls::INavigationViewFactory>
    {
        int32_t __stdcall CreateInstance(void* baseInterface, void** innerInterface, void** value) noexcept final try
        {
            if (innerInterface) *innerInterface = nullptr;
            winrt::Windows::Foundation::IInspectable winrt_impl_innerInterface;
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::UI::Xaml::Controls::NavigationView>(this->shim().CreateInstance(*reinterpret_cast<winrt::Windows::Foundation::IInspectable const*>(&baseInterface), winrt_impl_innerInterface));
                if (innerInterface) *innerInterface = detach_abi(winrt_impl_innerInterface);
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Controls::INavigationViewItem> : produce_base<D, winrt::Microsoft::UI::Xaml::Controls::INavigationViewItem>
    {
        int32_t __stdcall get_Icon(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::Controls::IconElement>(this->shim().Icon());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_Icon(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Icon(*reinterpret_cast<winrt::Windows::UI::Xaml::Controls::IconElement const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_CompactPaneLength(double* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<double>(this->shim().CompactPaneLength());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Controls::INavigationViewItem2> : produce_base<D, winrt::Microsoft::UI::Xaml::Controls::INavigationViewItem2>
    {
        int32_t __stdcall get_SelectsOnInvoked(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().SelectsOnInvoked());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_SelectsOnInvoked(bool value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().SelectsOnInvoked(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_IsExpanded(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().IsExpanded());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_IsExpanded(bool value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().IsExpanded(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_HasUnrealizedChildren(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().HasUnrealizedChildren());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_HasUnrealizedChildren(bool value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().HasUnrealizedChildren(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_IsChildSelected(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().IsChildSelected());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_IsChildSelected(bool value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().IsChildSelected(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_MenuItems(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::Collections::IVector<winrt::Windows::Foundation::IInspectable>>(this->shim().MenuItems());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_MenuItemsSource(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::IInspectable>(this->shim().MenuItemsSource());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_MenuItemsSource(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().MenuItemsSource(*reinterpret_cast<winrt::Windows::Foundation::IInspectable const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Controls::INavigationViewItem3> : produce_base<D, winrt::Microsoft::UI::Xaml::Controls::INavigationViewItem3>
    {
        int32_t __stdcall get_InfoBadge(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::UI::Xaml::Controls::InfoBadge>(this->shim().InfoBadge());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_InfoBadge(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().InfoBadge(*reinterpret_cast<winrt::Microsoft::UI::Xaml::Controls::InfoBadge const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Controls::INavigationViewItemBase> : produce_base<D, winrt::Microsoft::UI::Xaml::Controls::INavigationViewItemBase>
    {
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Controls::INavigationViewItemBase2> : produce_base<D, winrt::Microsoft::UI::Xaml::Controls::INavigationViewItemBase2>
    {
        int32_t __stdcall get_IsSelected(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().IsSelected());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_IsSelected(bool value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().IsSelected(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Controls::INavigationViewItemBaseFactory> : produce_base<D, winrt::Microsoft::UI::Xaml::Controls::INavigationViewItemBaseFactory>
    {
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Controls::INavigationViewItemBaseStatics> : produce_base<D, winrt::Microsoft::UI::Xaml::Controls::INavigationViewItemBaseStatics>
    {
        int32_t __stdcall get_IsSelectedProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().IsSelectedProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Controls::INavigationViewItemCollapsedEventArgs> : produce_base<D, winrt::Microsoft::UI::Xaml::Controls::INavigationViewItemCollapsedEventArgs>
    {
        int32_t __stdcall get_CollapsedItemContainer(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::UI::Xaml::Controls::NavigationViewItemBase>(this->shim().CollapsedItemContainer());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_CollapsedItem(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::IInspectable>(this->shim().CollapsedItem());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Controls::INavigationViewItemExpandingEventArgs> : produce_base<D, winrt::Microsoft::UI::Xaml::Controls::INavigationViewItemExpandingEventArgs>
    {
        int32_t __stdcall get_ExpandingItemContainer(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::UI::Xaml::Controls::NavigationViewItemBase>(this->shim().ExpandingItemContainer());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_ExpandingItem(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::IInspectable>(this->shim().ExpandingItem());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Controls::INavigationViewItemFactory> : produce_base<D, winrt::Microsoft::UI::Xaml::Controls::INavigationViewItemFactory>
    {
        int32_t __stdcall CreateInstance(void* baseInterface, void** innerInterface, void** value) noexcept final try
        {
            if (innerInterface) *innerInterface = nullptr;
            winrt::Windows::Foundation::IInspectable winrt_impl_innerInterface;
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::UI::Xaml::Controls::NavigationViewItem>(this->shim().CreateInstance(*reinterpret_cast<winrt::Windows::Foundation::IInspectable const*>(&baseInterface), winrt_impl_innerInterface));
                if (innerInterface) *innerInterface = detach_abi(winrt_impl_innerInterface);
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Controls::INavigationViewItemHeader> : produce_base<D, winrt::Microsoft::UI::Xaml::Controls::INavigationViewItemHeader>
    {
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Controls::INavigationViewItemHeaderFactory> : produce_base<D, winrt::Microsoft::UI::Xaml::Controls::INavigationViewItemHeaderFactory>
    {
        int32_t __stdcall CreateInstance(void* baseInterface, void** innerInterface, void** value) noexcept final try
        {
            if (innerInterface) *innerInterface = nullptr;
            winrt::Windows::Foundation::IInspectable winrt_impl_innerInterface;
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::UI::Xaml::Controls::NavigationViewItemHeader>(this->shim().CreateInstance(*reinterpret_cast<winrt::Windows::Foundation::IInspectable const*>(&baseInterface), winrt_impl_innerInterface));
                if (innerInterface) *innerInterface = detach_abi(winrt_impl_innerInterface);
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Controls::INavigationViewItemInvokedEventArgs> : produce_base<D, winrt::Microsoft::UI::Xaml::Controls::INavigationViewItemInvokedEventArgs>
    {
        int32_t __stdcall get_InvokedItem(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::IInspectable>(this->shim().InvokedItem());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_IsSettingsInvoked(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().IsSettingsInvoked());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Controls::INavigationViewItemInvokedEventArgs2> : produce_base<D, winrt::Microsoft::UI::Xaml::Controls::INavigationViewItemInvokedEventArgs2>
    {
        int32_t __stdcall get_InvokedItemContainer(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::UI::Xaml::Controls::NavigationViewItemBase>(this->shim().InvokedItemContainer());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_RecommendedNavigationTransitionInfo(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::Media::Animation::NavigationTransitionInfo>(this->shim().RecommendedNavigationTransitionInfo());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Controls::INavigationViewItemSeparator> : produce_base<D, winrt::Microsoft::UI::Xaml::Controls::INavigationViewItemSeparator>
    {
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Controls::INavigationViewItemSeparatorFactory> : produce_base<D, winrt::Microsoft::UI::Xaml::Controls::INavigationViewItemSeparatorFactory>
    {
        int32_t __stdcall CreateInstance(void* baseInterface, void** innerInterface, void** value) noexcept final try
        {
            if (innerInterface) *innerInterface = nullptr;
            winrt::Windows::Foundation::IInspectable winrt_impl_innerInterface;
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::UI::Xaml::Controls::NavigationViewItemSeparator>(this->shim().CreateInstance(*reinterpret_cast<winrt::Windows::Foundation::IInspectable const*>(&baseInterface), winrt_impl_innerInterface));
                if (innerInterface) *innerInterface = detach_abi(winrt_impl_innerInterface);
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Controls::INavigationViewItemStatics> : produce_base<D, winrt::Microsoft::UI::Xaml::Controls::INavigationViewItemStatics>
    {
        int32_t __stdcall get_IconProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().IconProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_CompactPaneLengthProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().CompactPaneLengthProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Controls::INavigationViewItemStatics2> : produce_base<D, winrt::Microsoft::UI::Xaml::Controls::INavigationViewItemStatics2>
    {
        int32_t __stdcall get_SelectsOnInvokedProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().SelectsOnInvokedProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_IsExpandedProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().IsExpandedProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_HasUnrealizedChildrenProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().HasUnrealizedChildrenProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_IsChildSelectedProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().IsChildSelectedProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_MenuItemsProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().MenuItemsProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_MenuItemsSourceProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().MenuItemsSourceProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Controls::INavigationViewItemStatics3> : produce_base<D, winrt::Microsoft::UI::Xaml::Controls::INavigationViewItemStatics3>
    {
        int32_t __stdcall get_InfoBadgeProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().InfoBadgeProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Controls::INavigationViewPaneClosingEventArgs> : produce_base<D, winrt::Microsoft::UI::Xaml::Controls::INavigationViewPaneClosingEventArgs>
    {
        int32_t __stdcall get_Cancel(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().Cancel());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_Cancel(bool value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Cancel(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Controls::INavigationViewSelectionChangedEventArgs> : produce_base<D, winrt::Microsoft::UI::Xaml::Controls::INavigationViewSelectionChangedEventArgs>
    {
        int32_t __stdcall get_SelectedItem(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::IInspectable>(this->shim().SelectedItem());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_IsSettingsSelected(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().IsSettingsSelected());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Controls::INavigationViewSelectionChangedEventArgs2> : produce_base<D, winrt::Microsoft::UI::Xaml::Controls::INavigationViewSelectionChangedEventArgs2>
    {
        int32_t __stdcall get_SelectedItemContainer(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::UI::Xaml::Controls::NavigationViewItemBase>(this->shim().SelectedItemContainer());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_RecommendedNavigationTransitionInfo(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::Media::Animation::NavigationTransitionInfo>(this->shim().RecommendedNavigationTransitionInfo());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Controls::INavigationViewStatics> : produce_base<D, winrt::Microsoft::UI::Xaml::Controls::INavigationViewStatics>
    {
        int32_t __stdcall get_IsPaneOpenProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().IsPaneOpenProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_CompactModeThresholdWidthProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().CompactModeThresholdWidthProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_ExpandedModeThresholdWidthProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().ExpandedModeThresholdWidthProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_FooterMenuItemsProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().FooterMenuItemsProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_FooterMenuItemsSourceProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().FooterMenuItemsSourceProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_PaneFooterProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().PaneFooterProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_HeaderProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().HeaderProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_HeaderTemplateProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().HeaderTemplateProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_DisplayModeProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().DisplayModeProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_IsSettingsVisibleProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().IsSettingsVisibleProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_IsPaneToggleButtonVisibleProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().IsPaneToggleButtonVisibleProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_AlwaysShowHeaderProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().AlwaysShowHeaderProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_CompactPaneLengthProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().CompactPaneLengthProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_OpenPaneLengthProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().OpenPaneLengthProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_PaneToggleButtonStyleProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().PaneToggleButtonStyleProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_MenuItemsProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().MenuItemsProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_MenuItemsSourceProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().MenuItemsSourceProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_SelectedItemProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().SelectedItemProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_SettingsItemProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().SettingsItemProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_AutoSuggestBoxProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().AutoSuggestBoxProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_MenuItemTemplateProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().MenuItemTemplateProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_MenuItemTemplateSelectorProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().MenuItemTemplateSelectorProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_MenuItemContainerStyleProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().MenuItemContainerStyleProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_MenuItemContainerStyleSelectorProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().MenuItemContainerStyleSelectorProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_IsTitleBarAutoPaddingEnabledProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().IsTitleBarAutoPaddingEnabledProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Controls::INavigationViewStatics2> : produce_base<D, winrt::Microsoft::UI::Xaml::Controls::INavigationViewStatics2>
    {
        int32_t __stdcall get_IsBackButtonVisibleProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().IsBackButtonVisibleProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_IsBackEnabledProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().IsBackEnabledProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_PaneTitleProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().PaneTitleProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_PaneDisplayModeProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().PaneDisplayModeProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_PaneHeaderProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().PaneHeaderProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_PaneCustomContentProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().PaneCustomContentProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_ContentOverlayProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().ContentOverlayProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_IsPaneVisibleProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().IsPaneVisibleProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_SelectionFollowsFocusProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().SelectionFollowsFocusProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_TemplateSettingsProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().TemplateSettingsProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_ShoulderNavigationEnabledProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().ShoulderNavigationEnabledProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_OverflowLabelModeProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().OverflowLabelModeProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Controls::INavigationViewTemplateSettings> : produce_base<D, winrt::Microsoft::UI::Xaml::Controls::INavigationViewTemplateSettings>
    {
        int32_t __stdcall get_TopPadding(double* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<double>(this->shim().TopPadding());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_OverflowButtonVisibility(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::Visibility>(this->shim().OverflowButtonVisibility());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_PaneToggleButtonVisibility(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::Visibility>(this->shim().PaneToggleButtonVisibility());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_BackButtonVisibility(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::Visibility>(this->shim().BackButtonVisibility());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_TopPaneVisibility(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::Visibility>(this->shim().TopPaneVisibility());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_LeftPaneVisibility(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::Visibility>(this->shim().LeftPaneVisibility());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_SingleSelectionFollowsFocus(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().SingleSelectionFollowsFocus());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_PaneToggleButtonWidth(double* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<double>(this->shim().PaneToggleButtonWidth());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_SmallerPaneToggleButtonWidth(double* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<double>(this->shim().SmallerPaneToggleButtonWidth());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Controls::INavigationViewTemplateSettings2> : produce_base<D, winrt::Microsoft::UI::Xaml::Controls::INavigationViewTemplateSettings2>
    {
        int32_t __stdcall get_OpenPaneLength(double* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<double>(this->shim().OpenPaneLength());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Controls::INavigationViewTemplateSettingsFactory> : produce_base<D, winrt::Microsoft::UI::Xaml::Controls::INavigationViewTemplateSettingsFactory>
    {
        int32_t __stdcall CreateInstance(void* baseInterface, void** innerInterface, void** value) noexcept final try
        {
            if (innerInterface) *innerInterface = nullptr;
            winrt::Windows::Foundation::IInspectable winrt_impl_innerInterface;
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::UI::Xaml::Controls::NavigationViewTemplateSettings>(this->shim().CreateInstance(*reinterpret_cast<winrt::Windows::Foundation::IInspectable const*>(&baseInterface), winrt_impl_innerInterface));
                if (innerInterface) *innerInterface = detach_abi(winrt_impl_innerInterface);
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Controls::INavigationViewTemplateSettingsStatics> : produce_base<D, winrt::Microsoft::UI::Xaml::Controls::INavigationViewTemplateSettingsStatics>
    {
        int32_t __stdcall get_TopPaddingProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().TopPaddingProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_OverflowButtonVisibilityProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().OverflowButtonVisibilityProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_PaneToggleButtonVisibilityProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().PaneToggleButtonVisibilityProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_BackButtonVisibilityProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().BackButtonVisibilityProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_TopPaneVisibilityProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().TopPaneVisibilityProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_LeftPaneVisibilityProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().LeftPaneVisibilityProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_SingleSelectionFollowsFocusProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().SingleSelectionFollowsFocusProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_PaneToggleButtonWidthProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().PaneToggleButtonWidthProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_SmallerPaneToggleButtonWidthProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().SmallerPaneToggleButtonWidthProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Controls::INavigationViewTemplateSettingsStatics2> : produce_base<D, winrt::Microsoft::UI::Xaml::Controls::INavigationViewTemplateSettingsStatics2>
    {
        int32_t __stdcall get_OpenPaneLengthProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().OpenPaneLengthProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Controls::INonVirtualizingLayout> : produce_base<D, winrt::Microsoft::UI::Xaml::Controls::INonVirtualizingLayout>
    {
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Controls::INonVirtualizingLayoutContext> : produce_base<D, winrt::Microsoft::UI::Xaml::Controls::INonVirtualizingLayoutContext>
    {
        int32_t __stdcall get_Children(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::Collections::IVectorView<winrt::Windows::UI::Xaml::UIElement>>(this->shim().Children());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Controls::INonVirtualizingLayoutContextFactory> : produce_base<D, winrt::Microsoft::UI::Xaml::Controls::INonVirtualizingLayoutContextFactory>
    {
        int32_t __stdcall CreateInstance(void* baseInterface, void** innerInterface, void** value) noexcept final try
        {
            if (innerInterface) *innerInterface = nullptr;
            winrt::Windows::Foundation::IInspectable winrt_impl_innerInterface;
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::UI::Xaml::Controls::NonVirtualizingLayoutContext>(this->shim().CreateInstance(*reinterpret_cast<winrt::Windows::Foundation::IInspectable const*>(&baseInterface), winrt_impl_innerInterface));
                if (innerInterface) *innerInterface = detach_abi(winrt_impl_innerInterface);
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Controls::INonVirtualizingLayoutContextOverrides> : produce_base<D, winrt::Microsoft::UI::Xaml::Controls::INonVirtualizingLayoutContextOverrides>
    {
        int32_t __stdcall get_ChildrenCore(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::Collections::IVectorView<winrt::Windows::UI::Xaml::UIElement>>(this->shim().ChildrenCore());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Controls::INonVirtualizingLayoutFactory> : produce_base<D, winrt::Microsoft::UI::Xaml::Controls::INonVirtualizingLayoutFactory>
    {
        int32_t __stdcall CreateInstance(void* baseInterface, void** innerInterface, void** value) noexcept final try
        {
            if (innerInterface) *innerInterface = nullptr;
            winrt::Windows::Foundation::IInspectable winrt_impl_innerInterface;
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::UI::Xaml::Controls::NonVirtualizingLayout>(this->shim().CreateInstance(*reinterpret_cast<winrt::Windows::Foundation::IInspectable const*>(&baseInterface), winrt_impl_innerInterface));
                if (innerInterface) *innerInterface = detach_abi(winrt_impl_innerInterface);
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Controls::INonVirtualizingLayoutOverrides> : produce_base<D, winrt::Microsoft::UI::Xaml::Controls::INonVirtualizingLayoutOverrides>
    {
        int32_t __stdcall InitializeForContextCore(void* context) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().InitializeForContextCore(*reinterpret_cast<winrt::Microsoft::UI::Xaml::Controls::NonVirtualizingLayoutContext const*>(&context));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall UninitializeForContextCore(void* context) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().UninitializeForContextCore(*reinterpret_cast<winrt::Microsoft::UI::Xaml::Controls::NonVirtualizingLayoutContext const*>(&context));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall MeasureOverride(void* context, winrt::Windows::Foundation::Size availableSize, winrt::Windows::Foundation::Size* result) noexcept final try
        {
            zero_abi<winrt::Windows::Foundation::Size>(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Windows::Foundation::Size>(this->shim().MeasureOverride(*reinterpret_cast<winrt::Microsoft::UI::Xaml::Controls::NonVirtualizingLayoutContext const*>(&context), *reinterpret_cast<winrt::Windows::Foundation::Size const*>(&availableSize)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall ArrangeOverride(void* context, winrt::Windows::Foundation::Size finalSize, winrt::Windows::Foundation::Size* result) noexcept final try
        {
            zero_abi<winrt::Windows::Foundation::Size>(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Windows::Foundation::Size>(this->shim().ArrangeOverride(*reinterpret_cast<winrt::Microsoft::UI::Xaml::Controls::NonVirtualizingLayoutContext const*>(&context), *reinterpret_cast<winrt::Windows::Foundation::Size const*>(&finalSize)));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Controls::INumberBox> : produce_base<D, winrt::Microsoft::UI::Xaml::Controls::INumberBox>
    {
        int32_t __stdcall get_Minimum(double* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<double>(this->shim().Minimum());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_Minimum(double value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Minimum(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Maximum(double* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<double>(this->shim().Maximum());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_Maximum(double value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Maximum(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Value(double* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<double>(this->shim().Value());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_Value(double value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Value(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_SmallChange(double* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<double>(this->shim().SmallChange());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_SmallChange(double value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().SmallChange(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_LargeChange(double* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<double>(this->shim().LargeChange());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_LargeChange(double value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().LargeChange(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Text(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<hstring>(this->shim().Text());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_Text(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Text(*reinterpret_cast<hstring const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Header(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::IInspectable>(this->shim().Header());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_Header(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Header(*reinterpret_cast<winrt::Windows::Foundation::IInspectable const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_HeaderTemplate(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DataTemplate>(this->shim().HeaderTemplate());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_HeaderTemplate(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().HeaderTemplate(*reinterpret_cast<winrt::Windows::UI::Xaml::DataTemplate const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_PlaceholderText(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<hstring>(this->shim().PlaceholderText());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_PlaceholderText(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().PlaceholderText(*reinterpret_cast<hstring const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_SelectionFlyout(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::Controls::Primitives::FlyoutBase>(this->shim().SelectionFlyout());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_SelectionFlyout(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().SelectionFlyout(*reinterpret_cast<winrt::Windows::UI::Xaml::Controls::Primitives::FlyoutBase const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_SelectionHighlightColor(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::Media::SolidColorBrush>(this->shim().SelectionHighlightColor());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_SelectionHighlightColor(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().SelectionHighlightColor(*reinterpret_cast<winrt::Windows::UI::Xaml::Media::SolidColorBrush const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_TextReadingOrder(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::TextReadingOrder>(this->shim().TextReadingOrder());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_TextReadingOrder(int32_t value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().TextReadingOrder(*reinterpret_cast<winrt::Windows::UI::Xaml::TextReadingOrder const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_PreventKeyboardDisplayOnProgrammaticFocus(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().PreventKeyboardDisplayOnProgrammaticFocus());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_PreventKeyboardDisplayOnProgrammaticFocus(bool value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().PreventKeyboardDisplayOnProgrammaticFocus(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Description(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::IInspectable>(this->shim().Description());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_Description(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Description(*reinterpret_cast<winrt::Windows::Foundation::IInspectable const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_ValidationMode(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::UI::Xaml::Controls::NumberBoxValidationMode>(this->shim().ValidationMode());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_ValidationMode(int32_t value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().ValidationMode(*reinterpret_cast<winrt::Microsoft::UI::Xaml::Controls::NumberBoxValidationMode const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_SpinButtonPlacementMode(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::UI::Xaml::Controls::NumberBoxSpinButtonPlacementMode>(this->shim().SpinButtonPlacementMode());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_SpinButtonPlacementMode(int32_t value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().SpinButtonPlacementMode(*reinterpret_cast<winrt::Microsoft::UI::Xaml::Controls::NumberBoxSpinButtonPlacementMode const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_IsWrapEnabled(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().IsWrapEnabled());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_IsWrapEnabled(bool value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().IsWrapEnabled(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_AcceptsExpression(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().AcceptsExpression());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_AcceptsExpression(bool value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().AcceptsExpression(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_NumberFormatter(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Globalization::NumberFormatting::INumberFormatter2>(this->shim().NumberFormatter());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_NumberFormatter(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().NumberFormatter(*reinterpret_cast<winrt::Windows::Globalization::NumberFormatting::INumberFormatter2 const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall add_ValueChanged(void* handler, winrt::event_token* token) noexcept final try
        {
            zero_abi<winrt::event_token>(token);
            typename D::abi_guard guard(this->shim());
            *token = detach_from<winrt::event_token>(this->shim().ValueChanged(*reinterpret_cast<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Xaml::Controls::NumberBox, winrt::Microsoft::UI::Xaml::Controls::NumberBoxValueChangedEventArgs> const*>(&handler)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall remove_ValueChanged(winrt::event_token token) noexcept final
        {
            typename D::abi_guard guard(this->shim());
            this->shim().ValueChanged(*reinterpret_cast<winrt::event_token const*>(&token));
            return 0;
        }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Controls::INumberBoxFactory> : produce_base<D, winrt::Microsoft::UI::Xaml::Controls::INumberBoxFactory>
    {
        int32_t __stdcall CreateInstance(void* baseInterface, void** innerInterface, void** value) noexcept final try
        {
            if (innerInterface) *innerInterface = nullptr;
            winrt::Windows::Foundation::IInspectable winrt_impl_innerInterface;
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::UI::Xaml::Controls::NumberBox>(this->shim().CreateInstance(*reinterpret_cast<winrt::Windows::Foundation::IInspectable const*>(&baseInterface), winrt_impl_innerInterface));
                if (innerInterface) *innerInterface = detach_abi(winrt_impl_innerInterface);
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Controls::INumberBoxStatics> : produce_base<D, winrt::Microsoft::UI::Xaml::Controls::INumberBoxStatics>
    {
        int32_t __stdcall get_MinimumProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().MinimumProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_MaximumProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().MaximumProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_ValueProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().ValueProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_SmallChangeProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().SmallChangeProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_LargeChangeProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().LargeChangeProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_TextProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().TextProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_HeaderProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().HeaderProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_HeaderTemplateProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().HeaderTemplateProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_PlaceholderTextProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().PlaceholderTextProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_SelectionFlyoutProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().SelectionFlyoutProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_SelectionHighlightColorProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().SelectionHighlightColorProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_TextReadingOrderProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().TextReadingOrderProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_PreventKeyboardDisplayOnProgrammaticFocusProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().PreventKeyboardDisplayOnProgrammaticFocusProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_DescriptionProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().DescriptionProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_ValidationModeProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().ValidationModeProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_SpinButtonPlacementModeProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().SpinButtonPlacementModeProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_IsWrapEnabledProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().IsWrapEnabledProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_AcceptsExpressionProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().AcceptsExpressionProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_NumberFormatterProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().NumberFormatterProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Controls::INumberBoxValueChangedEventArgs> : produce_base<D, winrt::Microsoft::UI::Xaml::Controls::INumberBoxValueChangedEventArgs>
    {
        int32_t __stdcall get_OldValue(double* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<double>(this->shim().OldValue());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_NewValue(double* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<double>(this->shim().NewValue());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Controls::IParallaxView> : produce_base<D, winrt::Microsoft::UI::Xaml::Controls::IParallaxView>
    {
        int32_t __stdcall get_Child(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::UIElement>(this->shim().Child());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_Child(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Child(*reinterpret_cast<winrt::Windows::UI::Xaml::UIElement const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_HorizontalShift(double* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<double>(this->shim().HorizontalShift());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_HorizontalShift(double value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().HorizontalShift(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_HorizontalSourceEndOffset(double* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<double>(this->shim().HorizontalSourceEndOffset());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_HorizontalSourceEndOffset(double value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().HorizontalSourceEndOffset(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_HorizontalSourceOffsetKind(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::UI::Xaml::Controls::ParallaxSourceOffsetKind>(this->shim().HorizontalSourceOffsetKind());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_HorizontalSourceOffsetKind(int32_t value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().HorizontalSourceOffsetKind(*reinterpret_cast<winrt::Microsoft::UI::Xaml::Controls::ParallaxSourceOffsetKind const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_HorizontalSourceStartOffset(double* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<double>(this->shim().HorizontalSourceStartOffset());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_HorizontalSourceStartOffset(double value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().HorizontalSourceStartOffset(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_IsHorizontalShiftClamped(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().IsHorizontalShiftClamped());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_IsHorizontalShiftClamped(bool value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().IsHorizontalShiftClamped(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_IsVerticalShiftClamped(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().IsVerticalShiftClamped());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_IsVerticalShiftClamped(bool value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().IsVerticalShiftClamped(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_MaxHorizontalShiftRatio(double* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<double>(this->shim().MaxHorizontalShiftRatio());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_MaxHorizontalShiftRatio(double value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().MaxHorizontalShiftRatio(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_MaxVerticalShiftRatio(double* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<double>(this->shim().MaxVerticalShiftRatio());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_MaxVerticalShiftRatio(double value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().MaxVerticalShiftRatio(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Source(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::UIElement>(this->shim().Source());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_Source(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Source(*reinterpret_cast<winrt::Windows::UI::Xaml::UIElement const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_VerticalShift(double* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<double>(this->shim().VerticalShift());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_VerticalShift(double value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().VerticalShift(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_VerticalSourceEndOffset(double* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<double>(this->shim().VerticalSourceEndOffset());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_VerticalSourceEndOffset(double value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().VerticalSourceEndOffset(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_VerticalSourceOffsetKind(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::UI::Xaml::Controls::ParallaxSourceOffsetKind>(this->shim().VerticalSourceOffsetKind());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_VerticalSourceOffsetKind(int32_t value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().VerticalSourceOffsetKind(*reinterpret_cast<winrt::Microsoft::UI::Xaml::Controls::ParallaxSourceOffsetKind const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_VerticalSourceStartOffset(double* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<double>(this->shim().VerticalSourceStartOffset());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_VerticalSourceStartOffset(double value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().VerticalSourceStartOffset(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall RefreshAutomaticHorizontalOffsets() noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().RefreshAutomaticHorizontalOffsets();
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall RefreshAutomaticVerticalOffsets() noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().RefreshAutomaticVerticalOffsets();
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Controls::IParallaxViewFactory> : produce_base<D, winrt::Microsoft::UI::Xaml::Controls::IParallaxViewFactory>
    {
        int32_t __stdcall CreateInstance(void* baseInterface, void** innerInterface, void** value) noexcept final try
        {
            if (innerInterface) *innerInterface = nullptr;
            winrt::Windows::Foundation::IInspectable winrt_impl_innerInterface;
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::UI::Xaml::Controls::ParallaxView>(this->shim().CreateInstance(*reinterpret_cast<winrt::Windows::Foundation::IInspectable const*>(&baseInterface), winrt_impl_innerInterface));
                if (innerInterface) *innerInterface = detach_abi(winrt_impl_innerInterface);
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Controls::IParallaxViewStatics> : produce_base<D, winrt::Microsoft::UI::Xaml::Controls::IParallaxViewStatics>
    {
        int32_t __stdcall get_ChildProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().ChildProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_HorizontalSourceEndOffsetProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().HorizontalSourceEndOffsetProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_HorizontalSourceOffsetKindProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().HorizontalSourceOffsetKindProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_HorizontalSourceStartOffsetProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().HorizontalSourceStartOffsetProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_MaxHorizontalShiftRatioProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().MaxHorizontalShiftRatioProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_HorizontalShiftProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().HorizontalShiftProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_IsHorizontalShiftClampedProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().IsHorizontalShiftClampedProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_IsVerticalShiftClampedProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().IsVerticalShiftClampedProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_SourceProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().SourceProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_VerticalSourceEndOffsetProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().VerticalSourceEndOffsetProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_VerticalSourceOffsetKindProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().VerticalSourceOffsetKindProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_VerticalSourceStartOffsetProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().VerticalSourceStartOffsetProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_MaxVerticalShiftRatioProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().MaxVerticalShiftRatioProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_VerticalShiftProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().VerticalShiftProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Controls::IPathIconSource> : produce_base<D, winrt::Microsoft::UI::Xaml::Controls::IPathIconSource>
    {
        int32_t __stdcall get_Data(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::Media::Geometry>(this->shim().Data());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_Data(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Data(*reinterpret_cast<winrt::Windows::UI::Xaml::Media::Geometry const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Controls::IPathIconSourceFactory> : produce_base<D, winrt::Microsoft::UI::Xaml::Controls::IPathIconSourceFactory>
    {
        int32_t __stdcall CreateInstance(void* baseInterface, void** innerInterface, void** value) noexcept final try
        {
            if (innerInterface) *innerInterface = nullptr;
            winrt::Windows::Foundation::IInspectable winrt_impl_innerInterface;
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::UI::Xaml::Controls::PathIconSource>(this->shim().CreateInstance(*reinterpret_cast<winrt::Windows::Foundation::IInspectable const*>(&baseInterface), winrt_impl_innerInterface));
                if (innerInterface) *innerInterface = detach_abi(winrt_impl_innerInterface);
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Controls::IPathIconSourceStatics> : produce_base<D, winrt::Microsoft::UI::Xaml::Controls::IPathIconSourceStatics>
    {
        int32_t __stdcall get_DataProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().DataProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Controls::IPersonPicture> : produce_base<D, winrt::Microsoft::UI::Xaml::Controls::IPersonPicture>
    {
        int32_t __stdcall get_BadgeNumber(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<int32_t>(this->shim().BadgeNumber());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_BadgeNumber(int32_t value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().BadgeNumber(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_BadgeGlyph(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<hstring>(this->shim().BadgeGlyph());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_BadgeGlyph(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().BadgeGlyph(*reinterpret_cast<hstring const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_BadgeImageSource(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::Media::ImageSource>(this->shim().BadgeImageSource());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_BadgeImageSource(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().BadgeImageSource(*reinterpret_cast<winrt::Windows::UI::Xaml::Media::ImageSource const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_BadgeText(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<hstring>(this->shim().BadgeText());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_BadgeText(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().BadgeText(*reinterpret_cast<hstring const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_IsGroup(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().IsGroup());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_IsGroup(bool value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().IsGroup(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Contact(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::ApplicationModel::Contacts::Contact>(this->shim().Contact());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_Contact(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Contact(*reinterpret_cast<winrt::Windows::ApplicationModel::Contacts::Contact const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_DisplayName(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<hstring>(this->shim().DisplayName());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_DisplayName(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().DisplayName(*reinterpret_cast<hstring const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Initials(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<hstring>(this->shim().Initials());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_Initials(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Initials(*reinterpret_cast<hstring const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_PreferSmallImage(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().PreferSmallImage());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_PreferSmallImage(bool value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().PreferSmallImage(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_ProfilePicture(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::Media::ImageSource>(this->shim().ProfilePicture());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_ProfilePicture(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().ProfilePicture(*reinterpret_cast<winrt::Windows::UI::Xaml::Media::ImageSource const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_TemplateSettings(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::UI::Xaml::Controls::PersonPictureTemplateSettings>(this->shim().TemplateSettings());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Controls::IPersonPictureFactory> : produce_base<D, winrt::Microsoft::UI::Xaml::Controls::IPersonPictureFactory>
    {
        int32_t __stdcall CreateInstance(void* baseInterface, void** innerInterface, void** value) noexcept final try
        {
            if (innerInterface) *innerInterface = nullptr;
            winrt::Windows::Foundation::IInspectable winrt_impl_innerInterface;
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::UI::Xaml::Controls::PersonPicture>(this->shim().CreateInstance(*reinterpret_cast<winrt::Windows::Foundation::IInspectable const*>(&baseInterface), winrt_impl_innerInterface));
                if (innerInterface) *innerInterface = detach_abi(winrt_impl_innerInterface);
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Controls::IPersonPictureStatics> : produce_base<D, winrt::Microsoft::UI::Xaml::Controls::IPersonPictureStatics>
    {
        int32_t __stdcall get_BadgeNumberProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().BadgeNumberProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_BadgeGlyphProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().BadgeGlyphProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_BadgeImageSourceProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().BadgeImageSourceProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_BadgeTextProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().BadgeTextProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_IsGroupProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().IsGroupProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_ContactProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().ContactProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_DisplayNameProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().DisplayNameProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_InitialsProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().InitialsProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_PreferSmallImageProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().PreferSmallImageProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_ProfilePictureProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().ProfilePictureProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Controls::IPersonPictureTemplateSettings> : produce_base<D, winrt::Microsoft::UI::Xaml::Controls::IPersonPictureTemplateSettings>
    {
        int32_t __stdcall get_ActualInitials(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<hstring>(this->shim().ActualInitials());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_ActualImageBrush(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::Media::ImageBrush>(this->shim().ActualImageBrush());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Controls::IPipsPager> : produce_base<D, winrt::Microsoft::UI::Xaml::Controls::IPipsPager>
    {
        int32_t __stdcall get_NumberOfPages(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<int32_t>(this->shim().NumberOfPages());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_NumberOfPages(int32_t value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().NumberOfPages(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_SelectedPageIndex(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<int32_t>(this->shim().SelectedPageIndex());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_SelectedPageIndex(int32_t value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().SelectedPageIndex(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_MaxVisiblePips(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<int32_t>(this->shim().MaxVisiblePips());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_MaxVisiblePips(int32_t value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().MaxVisiblePips(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Orientation(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::Controls::Orientation>(this->shim().Orientation());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_Orientation(int32_t value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Orientation(*reinterpret_cast<winrt::Windows::UI::Xaml::Controls::Orientation const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_PreviousButtonVisibility(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::UI::Xaml::Controls::PipsPagerButtonVisibility>(this->shim().PreviousButtonVisibility());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_PreviousButtonVisibility(int32_t value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().PreviousButtonVisibility(*reinterpret_cast<winrt::Microsoft::UI::Xaml::Controls::PipsPagerButtonVisibility const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_NextButtonVisibility(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::UI::Xaml::Controls::PipsPagerButtonVisibility>(this->shim().NextButtonVisibility());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_NextButtonVisibility(int32_t value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().NextButtonVisibility(*reinterpret_cast<winrt::Microsoft::UI::Xaml::Controls::PipsPagerButtonVisibility const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_PreviousButtonStyle(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::Style>(this->shim().PreviousButtonStyle());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_PreviousButtonStyle(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().PreviousButtonStyle(*reinterpret_cast<winrt::Windows::UI::Xaml::Style const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_NextButtonStyle(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::Style>(this->shim().NextButtonStyle());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_NextButtonStyle(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().NextButtonStyle(*reinterpret_cast<winrt::Windows::UI::Xaml::Style const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_SelectedPipStyle(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::Style>(this->shim().SelectedPipStyle());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_SelectedPipStyle(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().SelectedPipStyle(*reinterpret_cast<winrt::Windows::UI::Xaml::Style const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_NormalPipStyle(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::Style>(this->shim().NormalPipStyle());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_NormalPipStyle(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().NormalPipStyle(*reinterpret_cast<winrt::Windows::UI::Xaml::Style const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall add_SelectedIndexChanged(void* handler, winrt::event_token* token) noexcept final try
        {
            zero_abi<winrt::event_token>(token);
            typename D::abi_guard guard(this->shim());
            *token = detach_from<winrt::event_token>(this->shim().SelectedIndexChanged(*reinterpret_cast<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Xaml::Controls::PipsPager, winrt::Microsoft::UI::Xaml::Controls::PipsPagerSelectedIndexChangedEventArgs> const*>(&handler)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall remove_SelectedIndexChanged(winrt::event_token token) noexcept final
        {
            typename D::abi_guard guard(this->shim());
            this->shim().SelectedIndexChanged(*reinterpret_cast<winrt::event_token const*>(&token));
            return 0;
        }
        int32_t __stdcall get_TemplateSettings(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::UI::Xaml::Controls::PipsPagerTemplateSettings>(this->shim().TemplateSettings());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Controls::IPipsPagerFactory> : produce_base<D, winrt::Microsoft::UI::Xaml::Controls::IPipsPagerFactory>
    {
        int32_t __stdcall CreateInstance(void* baseInterface, void** innerInterface, void** value) noexcept final try
        {
            if (innerInterface) *innerInterface = nullptr;
            winrt::Windows::Foundation::IInspectable winrt_impl_innerInterface;
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::UI::Xaml::Controls::PipsPager>(this->shim().CreateInstance(*reinterpret_cast<winrt::Windows::Foundation::IInspectable const*>(&baseInterface), winrt_impl_innerInterface));
                if (innerInterface) *innerInterface = detach_abi(winrt_impl_innerInterface);
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Controls::IPipsPagerSelectedIndexChangedEventArgs> : produce_base<D, winrt::Microsoft::UI::Xaml::Controls::IPipsPagerSelectedIndexChangedEventArgs>
    {
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Controls::IPipsPagerStatics> : produce_base<D, winrt::Microsoft::UI::Xaml::Controls::IPipsPagerStatics>
    {
        int32_t __stdcall get_NumberOfPagesProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().NumberOfPagesProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_SelectedPageIndexProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().SelectedPageIndexProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_MaxVisiblePipsProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().MaxVisiblePipsProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_OrientationProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().OrientationProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_PreviousButtonVisibilityProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().PreviousButtonVisibilityProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_NextButtonVisibilityProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().NextButtonVisibilityProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_PreviousButtonStyleProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().PreviousButtonStyleProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_NextButtonStyleProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().NextButtonStyleProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_SelectedPipStyleProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().SelectedPipStyleProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_NormalPipStyleProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().NormalPipStyleProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Controls::IPipsPagerTemplateSettings> : produce_base<D, winrt::Microsoft::UI::Xaml::Controls::IPipsPagerTemplateSettings>
    {
        int32_t __stdcall get_PipsPagerItems(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::Collections::IVector<int32_t>>(this->shim().PipsPagerItems());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Controls::IProgressBar> : produce_base<D, winrt::Microsoft::UI::Xaml::Controls::IProgressBar>
    {
        int32_t __stdcall get_IsIndeterminate(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().IsIndeterminate());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_IsIndeterminate(bool value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().IsIndeterminate(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_ShowError(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().ShowError());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_ShowError(bool value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().ShowError(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_ShowPaused(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().ShowPaused());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_ShowPaused(bool value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().ShowPaused(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_TemplateSettings(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::UI::Xaml::Controls::ProgressBarTemplateSettings>(this->shim().TemplateSettings());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Controls::IProgressBarFactory> : produce_base<D, winrt::Microsoft::UI::Xaml::Controls::IProgressBarFactory>
    {
        int32_t __stdcall CreateInstance(void* baseInterface, void** innerInterface, void** value) noexcept final try
        {
            if (innerInterface) *innerInterface = nullptr;
            winrt::Windows::Foundation::IInspectable winrt_impl_innerInterface;
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::UI::Xaml::Controls::ProgressBar>(this->shim().CreateInstance(*reinterpret_cast<winrt::Windows::Foundation::IInspectable const*>(&baseInterface), winrt_impl_innerInterface));
                if (innerInterface) *innerInterface = detach_abi(winrt_impl_innerInterface);
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Controls::IProgressBarStatics> : produce_base<D, winrt::Microsoft::UI::Xaml::Controls::IProgressBarStatics>
    {
        int32_t __stdcall get_IsIndeterminateProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().IsIndeterminateProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_ShowErrorProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().ShowErrorProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_ShowPausedProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().ShowPausedProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Controls::IProgressBarTemplateSettings> : produce_base<D, winrt::Microsoft::UI::Xaml::Controls::IProgressBarTemplateSettings>
    {
        int32_t __stdcall get_ContainerAnimationStartPosition(double* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<double>(this->shim().ContainerAnimationStartPosition());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_ContainerAnimationEndPosition(double* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<double>(this->shim().ContainerAnimationEndPosition());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Container2AnimationStartPosition(double* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<double>(this->shim().Container2AnimationStartPosition());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Container2AnimationEndPosition(double* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<double>(this->shim().Container2AnimationEndPosition());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_ContainerAnimationMidPosition(double* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<double>(this->shim().ContainerAnimationMidPosition());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_IndicatorLengthDelta(double* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<double>(this->shim().IndicatorLengthDelta());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_ClipRect(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::Media::RectangleGeometry>(this->shim().ClipRect());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_EllipseAnimationEndPosition(double* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<double>(this->shim().EllipseAnimationEndPosition());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_EllipseAnimationWellPosition(double* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<double>(this->shim().EllipseAnimationWellPosition());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_EllipseDiameter(double* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<double>(this->shim().EllipseDiameter());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_EllipseOffset(double* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<double>(this->shim().EllipseOffset());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Controls::IProgressRing> : produce_base<D, winrt::Microsoft::UI::Xaml::Controls::IProgressRing>
    {
        int32_t __stdcall get_IsActive(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().IsActive());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_IsActive(bool value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().IsActive(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_IsIndeterminate(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().IsIndeterminate());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_IsIndeterminate(bool value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().IsIndeterminate(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_TemplateSettings(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::UI::Xaml::Controls::ProgressRingTemplateSettings>(this->shim().TemplateSettings());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Value(double* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<double>(this->shim().Value());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_Value(double value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Value(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Minimum(double* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<double>(this->shim().Minimum());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_Minimum(double value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Minimum(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Maximum(double* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<double>(this->shim().Maximum());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_Maximum(double value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Maximum(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Controls::IProgressRingFactory> : produce_base<D, winrt::Microsoft::UI::Xaml::Controls::IProgressRingFactory>
    {
        int32_t __stdcall CreateInstance(void* baseInterface, void** innerInterface, void** value) noexcept final try
        {
            if (innerInterface) *innerInterface = nullptr;
            winrt::Windows::Foundation::IInspectable winrt_impl_innerInterface;
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::UI::Xaml::Controls::ProgressRing>(this->shim().CreateInstance(*reinterpret_cast<winrt::Windows::Foundation::IInspectable const*>(&baseInterface), winrt_impl_innerInterface));
                if (innerInterface) *innerInterface = detach_abi(winrt_impl_innerInterface);
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Controls::IProgressRingStatics> : produce_base<D, winrt::Microsoft::UI::Xaml::Controls::IProgressRingStatics>
    {
        int32_t __stdcall get_IsActiveProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().IsActiveProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_IsIndeterminateProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().IsIndeterminateProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_ValueProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().ValueProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_MinimumProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().MinimumProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_MaximumProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().MaximumProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Controls::IProgressRingTemplateSettings> : produce_base<D, winrt::Microsoft::UI::Xaml::Controls::IProgressRingTemplateSettings>
    {
        int32_t __stdcall get_EllipseDiameter(double* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<double>(this->shim().EllipseDiameter());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_EllipseOffset(struct struct_Windows_UI_Xaml_Thickness* value) noexcept final try
        {
            zero_abi<winrt::Windows::UI::Xaml::Thickness>(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::Thickness>(this->shim().EllipseOffset());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_MaxSideLength(double* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<double>(this->shim().MaxSideLength());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Controls::IRadioButtons> : produce_base<D, winrt::Microsoft::UI::Xaml::Controls::IRadioButtons>
    {
        int32_t __stdcall get_ItemsSource(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::IInspectable>(this->shim().ItemsSource());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_ItemsSource(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().ItemsSource(*reinterpret_cast<winrt::Windows::Foundation::IInspectable const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Items(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::Collections::IVector<winrt::Windows::Foundation::IInspectable>>(this->shim().Items());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_ItemTemplate(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::IInspectable>(this->shim().ItemTemplate());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_ItemTemplate(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().ItemTemplate(*reinterpret_cast<winrt::Windows::Foundation::IInspectable const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall ContainerFromIndex(int32_t index, void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Windows::UI::Xaml::UIElement>(this->shim().ContainerFromIndex(index));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_SelectedIndex(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<int32_t>(this->shim().SelectedIndex());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_SelectedIndex(int32_t value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().SelectedIndex(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_SelectedItem(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::IInspectable>(this->shim().SelectedItem());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_SelectedItem(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().SelectedItem(*reinterpret_cast<winrt::Windows::Foundation::IInspectable const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall add_SelectionChanged(void* handler, winrt::event_token* token) noexcept final try
        {
            zero_abi<winrt::event_token>(token);
            typename D::abi_guard guard(this->shim());
            *token = detach_from<winrt::event_token>(this->shim().SelectionChanged(*reinterpret_cast<winrt::Windows::UI::Xaml::Controls::SelectionChangedEventHandler const*>(&handler)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall remove_SelectionChanged(winrt::event_token token) noexcept final
        {
            typename D::abi_guard guard(this->shim());
            this->shim().SelectionChanged(*reinterpret_cast<winrt::event_token const*>(&token));
            return 0;
        }
        int32_t __stdcall get_MaxColumns(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<int32_t>(this->shim().MaxColumns());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_MaxColumns(int32_t value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().MaxColumns(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Header(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::IInspectable>(this->shim().Header());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_Header(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Header(*reinterpret_cast<winrt::Windows::Foundation::IInspectable const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_HeaderTemplate(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DataTemplate>(this->shim().HeaderTemplate());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_HeaderTemplate(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().HeaderTemplate(*reinterpret_cast<winrt::Windows::UI::Xaml::DataTemplate const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Controls::IRadioButtonsFactory> : produce_base<D, winrt::Microsoft::UI::Xaml::Controls::IRadioButtonsFactory>
    {
        int32_t __stdcall CreateInstance(void* baseInterface, void** innerInterface, void** value) noexcept final try
        {
            if (innerInterface) *innerInterface = nullptr;
            winrt::Windows::Foundation::IInspectable winrt_impl_innerInterface;
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::UI::Xaml::Controls::RadioButtons>(this->shim().CreateInstance(*reinterpret_cast<winrt::Windows::Foundation::IInspectable const*>(&baseInterface), winrt_impl_innerInterface));
                if (innerInterface) *innerInterface = detach_abi(winrt_impl_innerInterface);
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Controls::IRadioButtonsStatics> : produce_base<D, winrt::Microsoft::UI::Xaml::Controls::IRadioButtonsStatics>
    {
        int32_t __stdcall get_ItemsSourceProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().ItemsSourceProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_ItemsProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().ItemsProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_ItemTemplateProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().ItemTemplateProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_SelectedIndexProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().SelectedIndexProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_SelectedItemProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().SelectedItemProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_MaxColumnsProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().MaxColumnsProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_HeaderProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().HeaderProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_HeaderTemplateProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().HeaderTemplateProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Controls::IRadioMenuFlyoutItem> : produce_base<D, winrt::Microsoft::UI::Xaml::Controls::IRadioMenuFlyoutItem>
    {
        int32_t __stdcall get_IsChecked(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().IsChecked());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_IsChecked(bool value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().IsChecked(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_GroupName(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<hstring>(this->shim().GroupName());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_GroupName(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().GroupName(*reinterpret_cast<hstring const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Controls::IRadioMenuFlyoutItemFactory> : produce_base<D, winrt::Microsoft::UI::Xaml::Controls::IRadioMenuFlyoutItemFactory>
    {
        int32_t __stdcall CreateInstance(void* baseInterface, void** innerInterface, void** value) noexcept final try
        {
            if (innerInterface) *innerInterface = nullptr;
            winrt::Windows::Foundation::IInspectable winrt_impl_innerInterface;
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::UI::Xaml::Controls::RadioMenuFlyoutItem>(this->shim().CreateInstance(*reinterpret_cast<winrt::Windows::Foundation::IInspectable const*>(&baseInterface), winrt_impl_innerInterface));
                if (innerInterface) *innerInterface = detach_abi(winrt_impl_innerInterface);
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Controls::IRadioMenuFlyoutItemStatics> : produce_base<D, winrt::Microsoft::UI::Xaml::Controls::IRadioMenuFlyoutItemStatics>
    {
        int32_t __stdcall get_IsCheckedProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().IsCheckedProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_GroupNameProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().GroupNameProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Controls::IRadioMenuFlyoutItemStatics2> : produce_base<D, winrt::Microsoft::UI::Xaml::Controls::IRadioMenuFlyoutItemStatics2>
    {
        int32_t __stdcall get_AreCheckStatesEnabledProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().AreCheckStatesEnabledProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall SetAreCheckStatesEnabled(void* object, bool value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().SetAreCheckStatesEnabled(*reinterpret_cast<winrt::Windows::UI::Xaml::Controls::MenuFlyoutSubItem const*>(&object), value);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall GetAreCheckStatesEnabled(void* object, bool* result) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *result = detach_from<bool>(this->shim().GetAreCheckStatesEnabled(*reinterpret_cast<winrt::Windows::UI::Xaml::Controls::MenuFlyoutSubItem const*>(&object)));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Controls::IRatingControl> : produce_base<D, winrt::Microsoft::UI::Xaml::Controls::IRatingControl>
    {
        int32_t __stdcall get_Caption(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<hstring>(this->shim().Caption());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_Caption(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Caption(*reinterpret_cast<hstring const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_InitialSetValue(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<int32_t>(this->shim().InitialSetValue());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_InitialSetValue(int32_t value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().InitialSetValue(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_IsClearEnabled(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().IsClearEnabled());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_IsClearEnabled(bool value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().IsClearEnabled(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_IsReadOnly(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().IsReadOnly());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_IsReadOnly(bool value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().IsReadOnly(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_MaxRating(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<int32_t>(this->shim().MaxRating());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_MaxRating(int32_t value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().MaxRating(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_PlaceholderValue(double* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<double>(this->shim().PlaceholderValue());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_PlaceholderValue(double value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().PlaceholderValue(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_ItemInfo(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::UI::Xaml::Controls::RatingItemInfo>(this->shim().ItemInfo());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_ItemInfo(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().ItemInfo(*reinterpret_cast<winrt::Microsoft::UI::Xaml::Controls::RatingItemInfo const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Value(double* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<double>(this->shim().Value());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_Value(double value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Value(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall add_ValueChanged(void* handler, winrt::event_token* token) noexcept final try
        {
            zero_abi<winrt::event_token>(token);
            typename D::abi_guard guard(this->shim());
            *token = detach_from<winrt::event_token>(this->shim().ValueChanged(*reinterpret_cast<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Xaml::Controls::RatingControl, winrt::Windows::Foundation::IInspectable> const*>(&handler)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall remove_ValueChanged(winrt::event_token token) noexcept final
        {
            typename D::abi_guard guard(this->shim());
            this->shim().ValueChanged(*reinterpret_cast<winrt::event_token const*>(&token));
            return 0;
        }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Controls::IRatingControlFactory> : produce_base<D, winrt::Microsoft::UI::Xaml::Controls::IRatingControlFactory>
    {
        int32_t __stdcall CreateInstance(void* baseInterface, void** innerInterface, void** value) noexcept final try
        {
            if (innerInterface) *innerInterface = nullptr;
            winrt::Windows::Foundation::IInspectable winrt_impl_innerInterface;
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::UI::Xaml::Controls::RatingControl>(this->shim().CreateInstance(*reinterpret_cast<winrt::Windows::Foundation::IInspectable const*>(&baseInterface), winrt_impl_innerInterface));
                if (innerInterface) *innerInterface = detach_abi(winrt_impl_innerInterface);
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Controls::IRatingControlStatics> : produce_base<D, winrt::Microsoft::UI::Xaml::Controls::IRatingControlStatics>
    {
        int32_t __stdcall get_CaptionProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().CaptionProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_InitialSetValueProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().InitialSetValueProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_IsClearEnabledProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().IsClearEnabledProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_IsReadOnlyProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().IsReadOnlyProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_MaxRatingProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().MaxRatingProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_PlaceholderValueProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().PlaceholderValueProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_ItemInfoProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().ItemInfoProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_ValueProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().ValueProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Controls::IRatingItemFontInfo> : produce_base<D, winrt::Microsoft::UI::Xaml::Controls::IRatingItemFontInfo>
    {
        int32_t __stdcall get_DisabledGlyph(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<hstring>(this->shim().DisabledGlyph());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_DisabledGlyph(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().DisabledGlyph(*reinterpret_cast<hstring const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Glyph(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<hstring>(this->shim().Glyph());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_Glyph(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Glyph(*reinterpret_cast<hstring const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_PointerOverGlyph(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<hstring>(this->shim().PointerOverGlyph());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_PointerOverGlyph(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().PointerOverGlyph(*reinterpret_cast<hstring const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_PointerOverPlaceholderGlyph(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<hstring>(this->shim().PointerOverPlaceholderGlyph());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_PointerOverPlaceholderGlyph(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().PointerOverPlaceholderGlyph(*reinterpret_cast<hstring const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_PlaceholderGlyph(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<hstring>(this->shim().PlaceholderGlyph());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_PlaceholderGlyph(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().PlaceholderGlyph(*reinterpret_cast<hstring const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_UnsetGlyph(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<hstring>(this->shim().UnsetGlyph());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_UnsetGlyph(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().UnsetGlyph(*reinterpret_cast<hstring const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Controls::IRatingItemFontInfoFactory> : produce_base<D, winrt::Microsoft::UI::Xaml::Controls::IRatingItemFontInfoFactory>
    {
        int32_t __stdcall CreateInstance(void* baseInterface, void** innerInterface, void** value) noexcept final try
        {
            if (innerInterface) *innerInterface = nullptr;
            winrt::Windows::Foundation::IInspectable winrt_impl_innerInterface;
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::UI::Xaml::Controls::RatingItemFontInfo>(this->shim().CreateInstance(*reinterpret_cast<winrt::Windows::Foundation::IInspectable const*>(&baseInterface), winrt_impl_innerInterface));
                if (innerInterface) *innerInterface = detach_abi(winrt_impl_innerInterface);
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Controls::IRatingItemFontInfoStatics> : produce_base<D, winrt::Microsoft::UI::Xaml::Controls::IRatingItemFontInfoStatics>
    {
        int32_t __stdcall get_DisabledGlyphProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().DisabledGlyphProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_GlyphProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().GlyphProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_PlaceholderGlyphProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().PlaceholderGlyphProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_PointerOverGlyphProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().PointerOverGlyphProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_PointerOverPlaceholderGlyphProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().PointerOverPlaceholderGlyphProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_UnsetGlyphProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().UnsetGlyphProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Controls::IRatingItemImageInfo> : produce_base<D, winrt::Microsoft::UI::Xaml::Controls::IRatingItemImageInfo>
    {
        int32_t __stdcall get_DisabledImage(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::Media::ImageSource>(this->shim().DisabledImage());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_DisabledImage(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().DisabledImage(*reinterpret_cast<winrt::Windows::UI::Xaml::Media::ImageSource const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Image(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::Media::ImageSource>(this->shim().Image());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_Image(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Image(*reinterpret_cast<winrt::Windows::UI::Xaml::Media::ImageSource const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_PlaceholderImage(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::Media::ImageSource>(this->shim().PlaceholderImage());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_PlaceholderImage(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().PlaceholderImage(*reinterpret_cast<winrt::Windows::UI::Xaml::Media::ImageSource const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_PointerOverImage(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::Media::ImageSource>(this->shim().PointerOverImage());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_PointerOverImage(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().PointerOverImage(*reinterpret_cast<winrt::Windows::UI::Xaml::Media::ImageSource const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_PointerOverPlaceholderImage(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::Media::ImageSource>(this->shim().PointerOverPlaceholderImage());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_PointerOverPlaceholderImage(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().PointerOverPlaceholderImage(*reinterpret_cast<winrt::Windows::UI::Xaml::Media::ImageSource const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_UnsetImage(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::Media::ImageSource>(this->shim().UnsetImage());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_UnsetImage(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().UnsetImage(*reinterpret_cast<winrt::Windows::UI::Xaml::Media::ImageSource const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Controls::IRatingItemImageInfoFactory> : produce_base<D, winrt::Microsoft::UI::Xaml::Controls::IRatingItemImageInfoFactory>
    {
        int32_t __stdcall CreateInstance(void* baseInterface, void** innerInterface, void** value) noexcept final try
        {
            if (innerInterface) *innerInterface = nullptr;
            winrt::Windows::Foundation::IInspectable winrt_impl_innerInterface;
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::UI::Xaml::Controls::RatingItemImageInfo>(this->shim().CreateInstance(*reinterpret_cast<winrt::Windows::Foundation::IInspectable const*>(&baseInterface), winrt_impl_innerInterface));
                if (innerInterface) *innerInterface = detach_abi(winrt_impl_innerInterface);
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Controls::IRatingItemImageInfoStatics> : produce_base<D, winrt::Microsoft::UI::Xaml::Controls::IRatingItemImageInfoStatics>
    {
        int32_t __stdcall get_DisabledImageProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().DisabledImageProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_ImageProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().ImageProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_PlaceholderImageProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().PlaceholderImageProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_PointerOverImageProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().PointerOverImageProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_PointerOverPlaceholderImageProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().PointerOverPlaceholderImageProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_UnsetImageProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().UnsetImageProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Controls::IRatingItemInfo> : produce_base<D, winrt::Microsoft::UI::Xaml::Controls::IRatingItemInfo>
    {
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Controls::IRatingItemInfoFactory> : produce_base<D, winrt::Microsoft::UI::Xaml::Controls::IRatingItemInfoFactory>
    {
        int32_t __stdcall CreateInstance(void* baseInterface, void** innerInterface, void** value) noexcept final try
        {
            if (innerInterface) *innerInterface = nullptr;
            winrt::Windows::Foundation::IInspectable winrt_impl_innerInterface;
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::UI::Xaml::Controls::RatingItemInfo>(this->shim().CreateInstance(*reinterpret_cast<winrt::Windows::Foundation::IInspectable const*>(&baseInterface), winrt_impl_innerInterface));
                if (innerInterface) *innerInterface = detach_abi(winrt_impl_innerInterface);
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Controls::IRefreshContainer> : produce_base<D, winrt::Microsoft::UI::Xaml::Controls::IRefreshContainer>
    {
        int32_t __stdcall get_Visualizer(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::UI::Xaml::Controls::RefreshVisualizer>(this->shim().Visualizer());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_Visualizer(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Visualizer(*reinterpret_cast<winrt::Microsoft::UI::Xaml::Controls::RefreshVisualizer const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_PullDirection(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::UI::Xaml::Controls::RefreshPullDirection>(this->shim().PullDirection());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_PullDirection(int32_t value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().PullDirection(*reinterpret_cast<winrt::Microsoft::UI::Xaml::Controls::RefreshPullDirection const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall add_RefreshRequested(void* handler, winrt::event_token* token) noexcept final try
        {
            zero_abi<winrt::event_token>(token);
            typename D::abi_guard guard(this->shim());
            *token = detach_from<winrt::event_token>(this->shim().RefreshRequested(*reinterpret_cast<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Xaml::Controls::RefreshContainer, winrt::Microsoft::UI::Xaml::Controls::RefreshRequestedEventArgs> const*>(&handler)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall remove_RefreshRequested(winrt::event_token token) noexcept final
        {
            typename D::abi_guard guard(this->shim());
            this->shim().RefreshRequested(*reinterpret_cast<winrt::event_token const*>(&token));
            return 0;
        }
        int32_t __stdcall RequestRefresh() noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().RequestRefresh();
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Controls::IRefreshContainerFactory> : produce_base<D, winrt::Microsoft::UI::Xaml::Controls::IRefreshContainerFactory>
    {
        int32_t __stdcall CreateInstance(void* baseInterface, void** innerInterface, void** value) noexcept final try
        {
            if (innerInterface) *innerInterface = nullptr;
            winrt::Windows::Foundation::IInspectable winrt_impl_innerInterface;
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::UI::Xaml::Controls::RefreshContainer>(this->shim().CreateInstance(*reinterpret_cast<winrt::Windows::Foundation::IInspectable const*>(&baseInterface), winrt_impl_innerInterface));
                if (innerInterface) *innerInterface = detach_abi(winrt_impl_innerInterface);
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Controls::IRefreshContainerStatics> : produce_base<D, winrt::Microsoft::UI::Xaml::Controls::IRefreshContainerStatics>
    {
        int32_t __stdcall get_VisualizerProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().VisualizerProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_PullDirectionProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().PullDirectionProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Controls::IRefreshInteractionRatioChangedEventArgs> : produce_base<D, winrt::Microsoft::UI::Xaml::Controls::IRefreshInteractionRatioChangedEventArgs>
    {
        int32_t __stdcall get_InteractionRatio(double* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<double>(this->shim().InteractionRatio());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Controls::IRefreshRequestedEventArgs> : produce_base<D, winrt::Microsoft::UI::Xaml::Controls::IRefreshRequestedEventArgs>
    {
        int32_t __stdcall GetDeferral(void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Windows::Foundation::Deferral>(this->shim().GetDeferral());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Controls::IRefreshStateChangedEventArgs> : produce_base<D, winrt::Microsoft::UI::Xaml::Controls::IRefreshStateChangedEventArgs>
    {
        int32_t __stdcall get_OldState(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::UI::Xaml::Controls::RefreshVisualizerState>(this->shim().OldState());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_NewState(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::UI::Xaml::Controls::RefreshVisualizerState>(this->shim().NewState());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Controls::IRefreshVisualizer> : produce_base<D, winrt::Microsoft::UI::Xaml::Controls::IRefreshVisualizer>
    {
        int32_t __stdcall RequestRefresh() noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().RequestRefresh();
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Orientation(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::UI::Xaml::Controls::RefreshVisualizerOrientation>(this->shim().Orientation());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_Orientation(int32_t value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Orientation(*reinterpret_cast<winrt::Microsoft::UI::Xaml::Controls::RefreshVisualizerOrientation const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Content(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::UIElement>(this->shim().Content());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_Content(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Content(*reinterpret_cast<winrt::Windows::UI::Xaml::UIElement const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_State(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::UI::Xaml::Controls::RefreshVisualizerState>(this->shim().State());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall add_RefreshRequested(void* handler, winrt::event_token* token) noexcept final try
        {
            zero_abi<winrt::event_token>(token);
            typename D::abi_guard guard(this->shim());
            *token = detach_from<winrt::event_token>(this->shim().RefreshRequested(*reinterpret_cast<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Xaml::Controls::RefreshVisualizer, winrt::Microsoft::UI::Xaml::Controls::RefreshRequestedEventArgs> const*>(&handler)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall remove_RefreshRequested(winrt::event_token token) noexcept final
        {
            typename D::abi_guard guard(this->shim());
            this->shim().RefreshRequested(*reinterpret_cast<winrt::event_token const*>(&token));
            return 0;
        }
        int32_t __stdcall add_RefreshStateChanged(void* handler, winrt::event_token* token) noexcept final try
        {
            zero_abi<winrt::event_token>(token);
            typename D::abi_guard guard(this->shim());
            *token = detach_from<winrt::event_token>(this->shim().RefreshStateChanged(*reinterpret_cast<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Xaml::Controls::RefreshVisualizer, winrt::Microsoft::UI::Xaml::Controls::RefreshStateChangedEventArgs> const*>(&handler)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall remove_RefreshStateChanged(winrt::event_token token) noexcept final
        {
            typename D::abi_guard guard(this->shim());
            this->shim().RefreshStateChanged(*reinterpret_cast<winrt::event_token const*>(&token));
            return 0;
        }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Controls::IRefreshVisualizerFactory> : produce_base<D, winrt::Microsoft::UI::Xaml::Controls::IRefreshVisualizerFactory>
    {
        int32_t __stdcall CreateInstance(void* baseInterface, void** innerInterface, void** value) noexcept final try
        {
            if (innerInterface) *innerInterface = nullptr;
            winrt::Windows::Foundation::IInspectable winrt_impl_innerInterface;
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::UI::Xaml::Controls::RefreshVisualizer>(this->shim().CreateInstance(*reinterpret_cast<winrt::Windows::Foundation::IInspectable const*>(&baseInterface), winrt_impl_innerInterface));
                if (innerInterface) *innerInterface = detach_abi(winrt_impl_innerInterface);
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Controls::IRefreshVisualizerStatics> : produce_base<D, winrt::Microsoft::UI::Xaml::Controls::IRefreshVisualizerStatics>
    {
        int32_t __stdcall get_InfoProviderProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().InfoProviderProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_OrientationProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().OrientationProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_ContentProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().ContentProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_StateProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().StateProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Controls::IRevealListViewItemPresenter> : produce_base<D, winrt::Microsoft::UI::Xaml::Controls::IRevealListViewItemPresenter>
    {
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Controls::IRevealListViewItemPresenterFactory> : produce_base<D, winrt::Microsoft::UI::Xaml::Controls::IRevealListViewItemPresenterFactory>
    {
        int32_t __stdcall CreateInstance(void* baseInterface, void** innerInterface, void** value) noexcept final try
        {
            if (innerInterface) *innerInterface = nullptr;
            winrt::Windows::Foundation::IInspectable winrt_impl_innerInterface;
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::UI::Xaml::Controls::RevealListViewItemPresenter>(this->shim().CreateInstance(*reinterpret_cast<winrt::Windows::Foundation::IInspectable const*>(&baseInterface), winrt_impl_innerInterface));
                if (innerInterface) *innerInterface = detach_abi(winrt_impl_innerInterface);
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Controls::ISplitButton> : produce_base<D, winrt::Microsoft::UI::Xaml::Controls::ISplitButton>
    {
        int32_t __stdcall get_Flyout(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::Controls::Primitives::FlyoutBase>(this->shim().Flyout());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_Flyout(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Flyout(*reinterpret_cast<winrt::Windows::UI::Xaml::Controls::Primitives::FlyoutBase const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Command(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::Input::ICommand>(this->shim().Command());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_Command(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Command(*reinterpret_cast<winrt::Windows::UI::Xaml::Input::ICommand const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_CommandParameter(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::IInspectable>(this->shim().CommandParameter());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_CommandParameter(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().CommandParameter(*reinterpret_cast<winrt::Windows::Foundation::IInspectable const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall add_Click(void* handler, winrt::event_token* token) noexcept final try
        {
            zero_abi<winrt::event_token>(token);
            typename D::abi_guard guard(this->shim());
            *token = detach_from<winrt::event_token>(this->shim().Click(*reinterpret_cast<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Xaml::Controls::SplitButton, winrt::Microsoft::UI::Xaml::Controls::SplitButtonClickEventArgs> const*>(&handler)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall remove_Click(winrt::event_token token) noexcept final
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Click(*reinterpret_cast<winrt::event_token const*>(&token));
            return 0;
        }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Controls::ISplitButtonClickEventArgs> : produce_base<D, winrt::Microsoft::UI::Xaml::Controls::ISplitButtonClickEventArgs>
    {
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Controls::ISplitButtonFactory> : produce_base<D, winrt::Microsoft::UI::Xaml::Controls::ISplitButtonFactory>
    {
        int32_t __stdcall CreateInstance(void* baseInterface, void** innerInterface, void** value) noexcept final try
        {
            if (innerInterface) *innerInterface = nullptr;
            winrt::Windows::Foundation::IInspectable winrt_impl_innerInterface;
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::UI::Xaml::Controls::SplitButton>(this->shim().CreateInstance(*reinterpret_cast<winrt::Windows::Foundation::IInspectable const*>(&baseInterface), winrt_impl_innerInterface));
                if (innerInterface) *innerInterface = detach_abi(winrt_impl_innerInterface);
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Controls::ISplitButtonStatics> : produce_base<D, winrt::Microsoft::UI::Xaml::Controls::ISplitButtonStatics>
    {
        int32_t __stdcall get_FlyoutProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().FlyoutProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_CommandProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().CommandProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_CommandParameterProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().CommandParameterProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Controls::IStackLayout> : produce_base<D, winrt::Microsoft::UI::Xaml::Controls::IStackLayout>
    {
        int32_t __stdcall get_Orientation(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::Controls::Orientation>(this->shim().Orientation());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_Orientation(int32_t value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Orientation(*reinterpret_cast<winrt::Windows::UI::Xaml::Controls::Orientation const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Spacing(double* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<double>(this->shim().Spacing());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_Spacing(double value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Spacing(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Controls::IStackLayoutFactory> : produce_base<D, winrt::Microsoft::UI::Xaml::Controls::IStackLayoutFactory>
    {
        int32_t __stdcall CreateInstance(void* baseInterface, void** innerInterface, void** value) noexcept final try
        {
            if (innerInterface) *innerInterface = nullptr;
            winrt::Windows::Foundation::IInspectable winrt_impl_innerInterface;
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::UI::Xaml::Controls::StackLayout>(this->shim().CreateInstance(*reinterpret_cast<winrt::Windows::Foundation::IInspectable const*>(&baseInterface), winrt_impl_innerInterface));
                if (innerInterface) *innerInterface = detach_abi(winrt_impl_innerInterface);
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Controls::IStackLayoutStatics> : produce_base<D, winrt::Microsoft::UI::Xaml::Controls::IStackLayoutStatics>
    {
        int32_t __stdcall get_OrientationProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().OrientationProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_SpacingProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().SpacingProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Controls::ISwipeControl> : produce_base<D, winrt::Microsoft::UI::Xaml::Controls::ISwipeControl>
    {
        int32_t __stdcall get_LeftItems(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::UI::Xaml::Controls::SwipeItems>(this->shim().LeftItems());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_LeftItems(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().LeftItems(*reinterpret_cast<winrt::Microsoft::UI::Xaml::Controls::SwipeItems const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_RightItems(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::UI::Xaml::Controls::SwipeItems>(this->shim().RightItems());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_RightItems(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().RightItems(*reinterpret_cast<winrt::Microsoft::UI::Xaml::Controls::SwipeItems const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_TopItems(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::UI::Xaml::Controls::SwipeItems>(this->shim().TopItems());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_TopItems(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().TopItems(*reinterpret_cast<winrt::Microsoft::UI::Xaml::Controls::SwipeItems const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_BottomItems(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::UI::Xaml::Controls::SwipeItems>(this->shim().BottomItems());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_BottomItems(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().BottomItems(*reinterpret_cast<winrt::Microsoft::UI::Xaml::Controls::SwipeItems const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall Close() noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Close();
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Controls::ISwipeControlFactory> : produce_base<D, winrt::Microsoft::UI::Xaml::Controls::ISwipeControlFactory>
    {
        int32_t __stdcall CreateInstance(void* baseInterface, void** innerInterface, void** value) noexcept final try
        {
            if (innerInterface) *innerInterface = nullptr;
            winrt::Windows::Foundation::IInspectable winrt_impl_innerInterface;
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::UI::Xaml::Controls::SwipeControl>(this->shim().CreateInstance(*reinterpret_cast<winrt::Windows::Foundation::IInspectable const*>(&baseInterface), winrt_impl_innerInterface));
                if (innerInterface) *innerInterface = detach_abi(winrt_impl_innerInterface);
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Controls::ISwipeControlStatics> : produce_base<D, winrt::Microsoft::UI::Xaml::Controls::ISwipeControlStatics>
    {
        int32_t __stdcall get_LeftItemsProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().LeftItemsProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_RightItemsProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().RightItemsProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_TopItemsProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().TopItemsProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_BottomItemsProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().BottomItemsProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Controls::ISwipeItem> : produce_base<D, winrt::Microsoft::UI::Xaml::Controls::ISwipeItem>
    {
        int32_t __stdcall get_Text(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<hstring>(this->shim().Text());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_Text(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Text(*reinterpret_cast<hstring const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_IconSource(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::UI::Xaml::Controls::IconSource>(this->shim().IconSource());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_IconSource(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().IconSource(*reinterpret_cast<winrt::Microsoft::UI::Xaml::Controls::IconSource const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Background(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::Media::Brush>(this->shim().Background());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_Background(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Background(*reinterpret_cast<winrt::Windows::UI::Xaml::Media::Brush const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Foreground(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::Media::Brush>(this->shim().Foreground());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_Foreground(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Foreground(*reinterpret_cast<winrt::Windows::UI::Xaml::Media::Brush const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Command(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::Input::ICommand>(this->shim().Command());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_Command(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Command(*reinterpret_cast<winrt::Windows::UI::Xaml::Input::ICommand const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_CommandParameter(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::IInspectable>(this->shim().CommandParameter());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_CommandParameter(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().CommandParameter(*reinterpret_cast<winrt::Windows::Foundation::IInspectable const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_BehaviorOnInvoked(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::UI::Xaml::Controls::SwipeBehaviorOnInvoked>(this->shim().BehaviorOnInvoked());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_BehaviorOnInvoked(int32_t value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().BehaviorOnInvoked(*reinterpret_cast<winrt::Microsoft::UI::Xaml::Controls::SwipeBehaviorOnInvoked const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall add_Invoked(void* handler, winrt::event_token* token) noexcept final try
        {
            zero_abi<winrt::event_token>(token);
            typename D::abi_guard guard(this->shim());
            *token = detach_from<winrt::event_token>(this->shim().Invoked(*reinterpret_cast<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Xaml::Controls::SwipeItem, winrt::Microsoft::UI::Xaml::Controls::SwipeItemInvokedEventArgs> const*>(&handler)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall remove_Invoked(winrt::event_token token) noexcept final
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Invoked(*reinterpret_cast<winrt::event_token const*>(&token));
            return 0;
        }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Controls::ISwipeItemFactory> : produce_base<D, winrt::Microsoft::UI::Xaml::Controls::ISwipeItemFactory>
    {
        int32_t __stdcall CreateInstance(void* baseInterface, void** innerInterface, void** value) noexcept final try
        {
            if (innerInterface) *innerInterface = nullptr;
            winrt::Windows::Foundation::IInspectable winrt_impl_innerInterface;
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::UI::Xaml::Controls::SwipeItem>(this->shim().CreateInstance(*reinterpret_cast<winrt::Windows::Foundation::IInspectable const*>(&baseInterface), winrt_impl_innerInterface));
                if (innerInterface) *innerInterface = detach_abi(winrt_impl_innerInterface);
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Controls::ISwipeItemInvokedEventArgs> : produce_base<D, winrt::Microsoft::UI::Xaml::Controls::ISwipeItemInvokedEventArgs>
    {
        int32_t __stdcall get_SwipeControl(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::UI::Xaml::Controls::SwipeControl>(this->shim().SwipeControl());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Controls::ISwipeItemStatics> : produce_base<D, winrt::Microsoft::UI::Xaml::Controls::ISwipeItemStatics>
    {
        int32_t __stdcall get_IconSourceProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().IconSourceProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_TextProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().TextProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_BackgroundProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().BackgroundProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_ForegroundProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().ForegroundProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_CommandProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().CommandProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_CommandParameterProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().CommandParameterProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_BehaviorOnInvokedProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().BehaviorOnInvokedProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Controls::ISwipeItems> : produce_base<D, winrt::Microsoft::UI::Xaml::Controls::ISwipeItems>
    {
        int32_t __stdcall get_Mode(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::UI::Xaml::Controls::SwipeMode>(this->shim().Mode());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_Mode(int32_t value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Mode(*reinterpret_cast<winrt::Microsoft::UI::Xaml::Controls::SwipeMode const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Controls::ISwipeItemsFactory> : produce_base<D, winrt::Microsoft::UI::Xaml::Controls::ISwipeItemsFactory>
    {
        int32_t __stdcall CreateInstance(void* baseInterface, void** innerInterface, void** value) noexcept final try
        {
            if (innerInterface) *innerInterface = nullptr;
            winrt::Windows::Foundation::IInspectable winrt_impl_innerInterface;
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::UI::Xaml::Controls::SwipeItems>(this->shim().CreateInstance(*reinterpret_cast<winrt::Windows::Foundation::IInspectable const*>(&baseInterface), winrt_impl_innerInterface));
                if (innerInterface) *innerInterface = detach_abi(winrt_impl_innerInterface);
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Controls::ISwipeItemsStatics> : produce_base<D, winrt::Microsoft::UI::Xaml::Controls::ISwipeItemsStatics>
    {
        int32_t __stdcall get_ModeProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().ModeProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Controls::ISymbolIconSource> : produce_base<D, winrt::Microsoft::UI::Xaml::Controls::ISymbolIconSource>
    {
        int32_t __stdcall get_Symbol(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::Controls::Symbol>(this->shim().Symbol());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_Symbol(int32_t value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Symbol(*reinterpret_cast<winrt::Windows::UI::Xaml::Controls::Symbol const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Controls::ISymbolIconSourceFactory> : produce_base<D, winrt::Microsoft::UI::Xaml::Controls::ISymbolIconSourceFactory>
    {
        int32_t __stdcall CreateInstance(void* baseInterface, void** innerInterface, void** value) noexcept final try
        {
            if (innerInterface) *innerInterface = nullptr;
            winrt::Windows::Foundation::IInspectable winrt_impl_innerInterface;
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::UI::Xaml::Controls::SymbolIconSource>(this->shim().CreateInstance(*reinterpret_cast<winrt::Windows::Foundation::IInspectable const*>(&baseInterface), winrt_impl_innerInterface));
                if (innerInterface) *innerInterface = detach_abi(winrt_impl_innerInterface);
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Controls::ISymbolIconSourceStatics> : produce_base<D, winrt::Microsoft::UI::Xaml::Controls::ISymbolIconSourceStatics>
    {
        int32_t __stdcall get_SymbolProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().SymbolProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Controls::ITabView> : produce_base<D, winrt::Microsoft::UI::Xaml::Controls::ITabView>
    {
        int32_t __stdcall get_TabWidthMode(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::UI::Xaml::Controls::TabViewWidthMode>(this->shim().TabWidthMode());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_TabWidthMode(int32_t value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().TabWidthMode(*reinterpret_cast<winrt::Microsoft::UI::Xaml::Controls::TabViewWidthMode const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_CloseButtonOverlayMode(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::UI::Xaml::Controls::TabViewCloseButtonOverlayMode>(this->shim().CloseButtonOverlayMode());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_CloseButtonOverlayMode(int32_t value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().CloseButtonOverlayMode(*reinterpret_cast<winrt::Microsoft::UI::Xaml::Controls::TabViewCloseButtonOverlayMode const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_TabStripHeader(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::IInspectable>(this->shim().TabStripHeader());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_TabStripHeader(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().TabStripHeader(*reinterpret_cast<winrt::Windows::Foundation::IInspectable const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_TabStripHeaderTemplate(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DataTemplate>(this->shim().TabStripHeaderTemplate());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_TabStripHeaderTemplate(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().TabStripHeaderTemplate(*reinterpret_cast<winrt::Windows::UI::Xaml::DataTemplate const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_TabStripFooter(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::IInspectable>(this->shim().TabStripFooter());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_TabStripFooter(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().TabStripFooter(*reinterpret_cast<winrt::Windows::Foundation::IInspectable const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_TabStripFooterTemplate(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DataTemplate>(this->shim().TabStripFooterTemplate());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_TabStripFooterTemplate(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().TabStripFooterTemplate(*reinterpret_cast<winrt::Windows::UI::Xaml::DataTemplate const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_IsAddTabButtonVisible(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().IsAddTabButtonVisible());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_IsAddTabButtonVisible(bool value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().IsAddTabButtonVisible(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_AddTabButtonCommand(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::Input::ICommand>(this->shim().AddTabButtonCommand());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_AddTabButtonCommand(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().AddTabButtonCommand(*reinterpret_cast<winrt::Windows::UI::Xaml::Input::ICommand const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_AddTabButtonCommandParameter(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::IInspectable>(this->shim().AddTabButtonCommandParameter());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_AddTabButtonCommandParameter(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().AddTabButtonCommandParameter(*reinterpret_cast<winrt::Windows::Foundation::IInspectable const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall add_TabCloseRequested(void* handler, winrt::event_token* token) noexcept final try
        {
            zero_abi<winrt::event_token>(token);
            typename D::abi_guard guard(this->shim());
            *token = detach_from<winrt::event_token>(this->shim().TabCloseRequested(*reinterpret_cast<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Xaml::Controls::TabView, winrt::Microsoft::UI::Xaml::Controls::TabViewTabCloseRequestedEventArgs> const*>(&handler)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall remove_TabCloseRequested(winrt::event_token token) noexcept final
        {
            typename D::abi_guard guard(this->shim());
            this->shim().TabCloseRequested(*reinterpret_cast<winrt::event_token const*>(&token));
            return 0;
        }
        int32_t __stdcall add_TabDroppedOutside(void* handler, winrt::event_token* token) noexcept final try
        {
            zero_abi<winrt::event_token>(token);
            typename D::abi_guard guard(this->shim());
            *token = detach_from<winrt::event_token>(this->shim().TabDroppedOutside(*reinterpret_cast<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Xaml::Controls::TabView, winrt::Microsoft::UI::Xaml::Controls::TabViewTabDroppedOutsideEventArgs> const*>(&handler)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall remove_TabDroppedOutside(winrt::event_token token) noexcept final
        {
            typename D::abi_guard guard(this->shim());
            this->shim().TabDroppedOutside(*reinterpret_cast<winrt::event_token const*>(&token));
            return 0;
        }
        int32_t __stdcall add_AddTabButtonClick(void* handler, winrt::event_token* token) noexcept final try
        {
            zero_abi<winrt::event_token>(token);
            typename D::abi_guard guard(this->shim());
            *token = detach_from<winrt::event_token>(this->shim().AddTabButtonClick(*reinterpret_cast<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Xaml::Controls::TabView, winrt::Windows::Foundation::IInspectable> const*>(&handler)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall remove_AddTabButtonClick(winrt::event_token token) noexcept final
        {
            typename D::abi_guard guard(this->shim());
            this->shim().AddTabButtonClick(*reinterpret_cast<winrt::event_token const*>(&token));
            return 0;
        }
        int32_t __stdcall add_TabItemsChanged(void* handler, winrt::event_token* token) noexcept final try
        {
            zero_abi<winrt::event_token>(token);
            typename D::abi_guard guard(this->shim());
            *token = detach_from<winrt::event_token>(this->shim().TabItemsChanged(*reinterpret_cast<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Xaml::Controls::TabView, winrt::Windows::Foundation::Collections::IVectorChangedEventArgs> const*>(&handler)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall remove_TabItemsChanged(winrt::event_token token) noexcept final
        {
            typename D::abi_guard guard(this->shim());
            this->shim().TabItemsChanged(*reinterpret_cast<winrt::event_token const*>(&token));
            return 0;
        }
        int32_t __stdcall get_TabItemsSource(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::IInspectable>(this->shim().TabItemsSource());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_TabItemsSource(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().TabItemsSource(*reinterpret_cast<winrt::Windows::Foundation::IInspectable const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_TabItems(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::Collections::IVector<winrt::Windows::Foundation::IInspectable>>(this->shim().TabItems());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_TabItemTemplate(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DataTemplate>(this->shim().TabItemTemplate());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_TabItemTemplate(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().TabItemTemplate(*reinterpret_cast<winrt::Windows::UI::Xaml::DataTemplate const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_TabItemTemplateSelector(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::Controls::DataTemplateSelector>(this->shim().TabItemTemplateSelector());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_TabItemTemplateSelector(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().TabItemTemplateSelector(*reinterpret_cast<winrt::Windows::UI::Xaml::Controls::DataTemplateSelector const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_CanDragTabs(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().CanDragTabs());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_CanDragTabs(bool value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().CanDragTabs(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_CanReorderTabs(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().CanReorderTabs());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_CanReorderTabs(bool value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().CanReorderTabs(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_AllowDropTabs(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().AllowDropTabs());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_AllowDropTabs(bool value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().AllowDropTabs(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_SelectedIndex(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<int32_t>(this->shim().SelectedIndex());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_SelectedIndex(int32_t value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().SelectedIndex(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_SelectedItem(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::IInspectable>(this->shim().SelectedItem());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_SelectedItem(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().SelectedItem(*reinterpret_cast<winrt::Windows::Foundation::IInspectable const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall ContainerFromItem(void* item, void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Windows::UI::Xaml::DependencyObject>(this->shim().ContainerFromItem(*reinterpret_cast<winrt::Windows::Foundation::IInspectable const*>(&item)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall ContainerFromIndex(int32_t index, void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Windows::UI::Xaml::DependencyObject>(this->shim().ContainerFromIndex(index));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall add_SelectionChanged(void* handler, winrt::event_token* token) noexcept final try
        {
            zero_abi<winrt::event_token>(token);
            typename D::abi_guard guard(this->shim());
            *token = detach_from<winrt::event_token>(this->shim().SelectionChanged(*reinterpret_cast<winrt::Windows::UI::Xaml::Controls::SelectionChangedEventHandler const*>(&handler)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall remove_SelectionChanged(winrt::event_token token) noexcept final
        {
            typename D::abi_guard guard(this->shim());
            this->shim().SelectionChanged(*reinterpret_cast<winrt::event_token const*>(&token));
            return 0;
        }
        int32_t __stdcall add_TabDragStarting(void* handler, winrt::event_token* token) noexcept final try
        {
            zero_abi<winrt::event_token>(token);
            typename D::abi_guard guard(this->shim());
            *token = detach_from<winrt::event_token>(this->shim().TabDragStarting(*reinterpret_cast<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Xaml::Controls::TabView, winrt::Microsoft::UI::Xaml::Controls::TabViewTabDragStartingEventArgs> const*>(&handler)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall remove_TabDragStarting(winrt::event_token token) noexcept final
        {
            typename D::abi_guard guard(this->shim());
            this->shim().TabDragStarting(*reinterpret_cast<winrt::event_token const*>(&token));
            return 0;
        }
        int32_t __stdcall add_TabDragCompleted(void* handler, winrt::event_token* token) noexcept final try
        {
            zero_abi<winrt::event_token>(token);
            typename D::abi_guard guard(this->shim());
            *token = detach_from<winrt::event_token>(this->shim().TabDragCompleted(*reinterpret_cast<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Xaml::Controls::TabView, winrt::Microsoft::UI::Xaml::Controls::TabViewTabDragCompletedEventArgs> const*>(&handler)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall remove_TabDragCompleted(winrt::event_token token) noexcept final
        {
            typename D::abi_guard guard(this->shim());
            this->shim().TabDragCompleted(*reinterpret_cast<winrt::event_token const*>(&token));
            return 0;
        }
        int32_t __stdcall add_TabStripDragOver(void* handler, winrt::event_token* token) noexcept final try
        {
            zero_abi<winrt::event_token>(token);
            typename D::abi_guard guard(this->shim());
            *token = detach_from<winrt::event_token>(this->shim().TabStripDragOver(*reinterpret_cast<winrt::Windows::UI::Xaml::DragEventHandler const*>(&handler)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall remove_TabStripDragOver(winrt::event_token token) noexcept final
        {
            typename D::abi_guard guard(this->shim());
            this->shim().TabStripDragOver(*reinterpret_cast<winrt::event_token const*>(&token));
            return 0;
        }
        int32_t __stdcall add_TabStripDrop(void* handler, winrt::event_token* token) noexcept final try
        {
            zero_abi<winrt::event_token>(token);
            typename D::abi_guard guard(this->shim());
            *token = detach_from<winrt::event_token>(this->shim().TabStripDrop(*reinterpret_cast<winrt::Windows::UI::Xaml::DragEventHandler const*>(&handler)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall remove_TabStripDrop(winrt::event_token token) noexcept final
        {
            typename D::abi_guard guard(this->shim());
            this->shim().TabStripDrop(*reinterpret_cast<winrt::event_token const*>(&token));
            return 0;
        }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Controls::ITabViewFactory> : produce_base<D, winrt::Microsoft::UI::Xaml::Controls::ITabViewFactory>
    {
        int32_t __stdcall CreateInstance(void* baseInterface, void** innerInterface, void** value) noexcept final try
        {
            if (innerInterface) *innerInterface = nullptr;
            winrt::Windows::Foundation::IInspectable winrt_impl_innerInterface;
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::UI::Xaml::Controls::TabView>(this->shim().CreateInstance(*reinterpret_cast<winrt::Windows::Foundation::IInspectable const*>(&baseInterface), winrt_impl_innerInterface));
                if (innerInterface) *innerInterface = detach_abi(winrt_impl_innerInterface);
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Controls::ITabViewItem> : produce_base<D, winrt::Microsoft::UI::Xaml::Controls::ITabViewItem>
    {
        int32_t __stdcall get_Header(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::IInspectable>(this->shim().Header());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_Header(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Header(*reinterpret_cast<winrt::Windows::Foundation::IInspectable const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_HeaderTemplate(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DataTemplate>(this->shim().HeaderTemplate());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_HeaderTemplate(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().HeaderTemplate(*reinterpret_cast<winrt::Windows::UI::Xaml::DataTemplate const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_IconSource(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::UI::Xaml::Controls::IconSource>(this->shim().IconSource());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_IconSource(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().IconSource(*reinterpret_cast<winrt::Microsoft::UI::Xaml::Controls::IconSource const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_IsClosable(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().IsClosable());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_IsClosable(bool value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().IsClosable(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_TabViewTemplateSettings(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::UI::Xaml::Controls::TabViewItemTemplateSettings>(this->shim().TabViewTemplateSettings());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall add_CloseRequested(void* handler, winrt::event_token* token) noexcept final try
        {
            zero_abi<winrt::event_token>(token);
            typename D::abi_guard guard(this->shim());
            *token = detach_from<winrt::event_token>(this->shim().CloseRequested(*reinterpret_cast<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Xaml::Controls::TabViewItem, winrt::Microsoft::UI::Xaml::Controls::TabViewTabCloseRequestedEventArgs> const*>(&handler)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall remove_CloseRequested(winrt::event_token token) noexcept final
        {
            typename D::abi_guard guard(this->shim());
            this->shim().CloseRequested(*reinterpret_cast<winrt::event_token const*>(&token));
            return 0;
        }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Controls::ITabViewItemFactory> : produce_base<D, winrt::Microsoft::UI::Xaml::Controls::ITabViewItemFactory>
    {
        int32_t __stdcall CreateInstance(void* baseInterface, void** innerInterface, void** value) noexcept final try
        {
            if (innerInterface) *innerInterface = nullptr;
            winrt::Windows::Foundation::IInspectable winrt_impl_innerInterface;
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::UI::Xaml::Controls::TabViewItem>(this->shim().CreateInstance(*reinterpret_cast<winrt::Windows::Foundation::IInspectable const*>(&baseInterface), winrt_impl_innerInterface));
                if (innerInterface) *innerInterface = detach_abi(winrt_impl_innerInterface);
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Controls::ITabViewItemStatics> : produce_base<D, winrt::Microsoft::UI::Xaml::Controls::ITabViewItemStatics>
    {
        int32_t __stdcall get_HeaderProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().HeaderProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_HeaderTemplateProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().HeaderTemplateProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_IconSourceProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().IconSourceProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_IsClosableProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().IsClosableProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_TabViewTemplateSettingsProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().TabViewTemplateSettingsProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Controls::ITabViewItemTemplateSettings> : produce_base<D, winrt::Microsoft::UI::Xaml::Controls::ITabViewItemTemplateSettings>
    {
        int32_t __stdcall get_IconElement(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::Controls::IconElement>(this->shim().IconElement());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_IconElement(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().IconElement(*reinterpret_cast<winrt::Windows::UI::Xaml::Controls::IconElement const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Controls::ITabViewItemTemplateSettings2> : produce_base<D, winrt::Microsoft::UI::Xaml::Controls::ITabViewItemTemplateSettings2>
    {
        int32_t __stdcall get_TabGeometry(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::Media::Geometry>(this->shim().TabGeometry());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_TabGeometry(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().TabGeometry(*reinterpret_cast<winrt::Windows::UI::Xaml::Media::Geometry const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Controls::ITabViewItemTemplateSettingsFactory> : produce_base<D, winrt::Microsoft::UI::Xaml::Controls::ITabViewItemTemplateSettingsFactory>
    {
        int32_t __stdcall CreateInstance(void* baseInterface, void** innerInterface, void** value) noexcept final try
        {
            if (innerInterface) *innerInterface = nullptr;
            winrt::Windows::Foundation::IInspectable winrt_impl_innerInterface;
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::UI::Xaml::Controls::TabViewItemTemplateSettings>(this->shim().CreateInstance(*reinterpret_cast<winrt::Windows::Foundation::IInspectable const*>(&baseInterface), winrt_impl_innerInterface));
                if (innerInterface) *innerInterface = detach_abi(winrt_impl_innerInterface);
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Controls::ITabViewItemTemplateSettingsStatics> : produce_base<D, winrt::Microsoft::UI::Xaml::Controls::ITabViewItemTemplateSettingsStatics>
    {
        int32_t __stdcall get_IconElementProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().IconElementProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Controls::ITabViewItemTemplateSettingsStatics2> : produce_base<D, winrt::Microsoft::UI::Xaml::Controls::ITabViewItemTemplateSettingsStatics2>
    {
        int32_t __stdcall get_TabGeometryProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().TabGeometryProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Controls::ITabViewStatics> : produce_base<D, winrt::Microsoft::UI::Xaml::Controls::ITabViewStatics>
    {
        int32_t __stdcall get_TabWidthModeProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().TabWidthModeProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_TabStripHeaderProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().TabStripHeaderProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_TabStripHeaderTemplateProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().TabStripHeaderTemplateProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_TabStripFooterProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().TabStripFooterProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_TabStripFooterTemplateProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().TabStripFooterTemplateProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_IsAddTabButtonVisibleProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().IsAddTabButtonVisibleProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_AddTabButtonCommandProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().AddTabButtonCommandProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_AddTabButtonCommandParameterProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().AddTabButtonCommandParameterProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_TabItemsSourceProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().TabItemsSourceProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_TabItemsProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().TabItemsProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_TabItemTemplateProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().TabItemTemplateProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_TabItemTemplateSelectorProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().TabItemTemplateSelectorProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_CloseButtonOverlayModeProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().CloseButtonOverlayModeProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_CanDragTabsProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().CanDragTabsProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_CanReorderTabsProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().CanReorderTabsProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_AllowDropTabsProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().AllowDropTabsProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_SelectedIndexProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().SelectedIndexProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_SelectedItemProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().SelectedItemProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Controls::ITabViewTabCloseRequestedEventArgs> : produce_base<D, winrt::Microsoft::UI::Xaml::Controls::ITabViewTabCloseRequestedEventArgs>
    {
        int32_t __stdcall get_Item(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::IInspectable>(this->shim().Item());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Tab(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::UI::Xaml::Controls::TabViewItem>(this->shim().Tab());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Controls::ITabViewTabDragCompletedEventArgs> : produce_base<D, winrt::Microsoft::UI::Xaml::Controls::ITabViewTabDragCompletedEventArgs>
    {
        int32_t __stdcall get_DropResult(uint32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::ApplicationModel::DataTransfer::DataPackageOperation>(this->shim().DropResult());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Item(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::IInspectable>(this->shim().Item());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Tab(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::UI::Xaml::Controls::TabViewItem>(this->shim().Tab());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Controls::ITabViewTabDragStartingEventArgs> : produce_base<D, winrt::Microsoft::UI::Xaml::Controls::ITabViewTabDragStartingEventArgs>
    {
        int32_t __stdcall get_Cancel(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().Cancel());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_Cancel(bool value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Cancel(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Data(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::ApplicationModel::DataTransfer::DataPackage>(this->shim().Data());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Item(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::IInspectable>(this->shim().Item());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Tab(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::UI::Xaml::Controls::TabViewItem>(this->shim().Tab());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Controls::ITabViewTabDroppedOutsideEventArgs> : produce_base<D, winrt::Microsoft::UI::Xaml::Controls::ITabViewTabDroppedOutsideEventArgs>
    {
        int32_t __stdcall get_Item(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::IInspectable>(this->shim().Item());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Tab(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::UI::Xaml::Controls::TabViewItem>(this->shim().Tab());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Controls::ITeachingTip> : produce_base<D, winrt::Microsoft::UI::Xaml::Controls::ITeachingTip>
    {
        int32_t __stdcall get_Title(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<hstring>(this->shim().Title());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_Title(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Title(*reinterpret_cast<hstring const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Subtitle(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<hstring>(this->shim().Subtitle());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_Subtitle(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Subtitle(*reinterpret_cast<hstring const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_IsOpen(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().IsOpen());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_IsOpen(bool value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().IsOpen(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Target(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::FrameworkElement>(this->shim().Target());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_Target(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Target(*reinterpret_cast<winrt::Windows::UI::Xaml::FrameworkElement const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_TailVisibility(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::UI::Xaml::Controls::TeachingTipTailVisibility>(this->shim().TailVisibility());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_TailVisibility(int32_t value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().TailVisibility(*reinterpret_cast<winrt::Microsoft::UI::Xaml::Controls::TeachingTipTailVisibility const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_ActionButtonContent(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::IInspectable>(this->shim().ActionButtonContent());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_ActionButtonContent(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().ActionButtonContent(*reinterpret_cast<winrt::Windows::Foundation::IInspectable const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_ActionButtonStyle(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::Style>(this->shim().ActionButtonStyle());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_ActionButtonStyle(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().ActionButtonStyle(*reinterpret_cast<winrt::Windows::UI::Xaml::Style const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_ActionButtonCommand(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::Input::ICommand>(this->shim().ActionButtonCommand());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_ActionButtonCommand(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().ActionButtonCommand(*reinterpret_cast<winrt::Windows::UI::Xaml::Input::ICommand const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_ActionButtonCommandParameter(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::IInspectable>(this->shim().ActionButtonCommandParameter());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_ActionButtonCommandParameter(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().ActionButtonCommandParameter(*reinterpret_cast<winrt::Windows::Foundation::IInspectable const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_CloseButtonContent(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::IInspectable>(this->shim().CloseButtonContent());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_CloseButtonContent(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().CloseButtonContent(*reinterpret_cast<winrt::Windows::Foundation::IInspectable const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_CloseButtonStyle(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::Style>(this->shim().CloseButtonStyle());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_CloseButtonStyle(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().CloseButtonStyle(*reinterpret_cast<winrt::Windows::UI::Xaml::Style const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_CloseButtonCommand(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::Input::ICommand>(this->shim().CloseButtonCommand());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_CloseButtonCommand(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().CloseButtonCommand(*reinterpret_cast<winrt::Windows::UI::Xaml::Input::ICommand const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_CloseButtonCommandParameter(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::IInspectable>(this->shim().CloseButtonCommandParameter());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_CloseButtonCommandParameter(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().CloseButtonCommandParameter(*reinterpret_cast<winrt::Windows::Foundation::IInspectable const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_PlacementMargin(struct struct_Windows_UI_Xaml_Thickness* value) noexcept final try
        {
            zero_abi<winrt::Windows::UI::Xaml::Thickness>(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::Thickness>(this->shim().PlacementMargin());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_PlacementMargin(struct struct_Windows_UI_Xaml_Thickness value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().PlacementMargin(*reinterpret_cast<winrt::Windows::UI::Xaml::Thickness const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_ShouldConstrainToRootBounds(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().ShouldConstrainToRootBounds());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_ShouldConstrainToRootBounds(bool value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().ShouldConstrainToRootBounds(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_IsLightDismissEnabled(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().IsLightDismissEnabled());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_IsLightDismissEnabled(bool value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().IsLightDismissEnabled(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_PreferredPlacement(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::UI::Xaml::Controls::TeachingTipPlacementMode>(this->shim().PreferredPlacement());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_PreferredPlacement(int32_t value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().PreferredPlacement(*reinterpret_cast<winrt::Microsoft::UI::Xaml::Controls::TeachingTipPlacementMode const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_HeroContentPlacement(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::UI::Xaml::Controls::TeachingTipHeroContentPlacementMode>(this->shim().HeroContentPlacement());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_HeroContentPlacement(int32_t value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().HeroContentPlacement(*reinterpret_cast<winrt::Microsoft::UI::Xaml::Controls::TeachingTipHeroContentPlacementMode const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_HeroContent(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::UIElement>(this->shim().HeroContent());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_HeroContent(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().HeroContent(*reinterpret_cast<winrt::Windows::UI::Xaml::UIElement const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_IconSource(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::UI::Xaml::Controls::IconSource>(this->shim().IconSource());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_IconSource(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().IconSource(*reinterpret_cast<winrt::Microsoft::UI::Xaml::Controls::IconSource const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_TemplateSettings(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::UI::Xaml::Controls::TeachingTipTemplateSettings>(this->shim().TemplateSettings());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall add_ActionButtonClick(void* handler, winrt::event_token* token) noexcept final try
        {
            zero_abi<winrt::event_token>(token);
            typename D::abi_guard guard(this->shim());
            *token = detach_from<winrt::event_token>(this->shim().ActionButtonClick(*reinterpret_cast<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Xaml::Controls::TeachingTip, winrt::Windows::Foundation::IInspectable> const*>(&handler)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall remove_ActionButtonClick(winrt::event_token token) noexcept final
        {
            typename D::abi_guard guard(this->shim());
            this->shim().ActionButtonClick(*reinterpret_cast<winrt::event_token const*>(&token));
            return 0;
        }
        int32_t __stdcall add_CloseButtonClick(void* handler, winrt::event_token* token) noexcept final try
        {
            zero_abi<winrt::event_token>(token);
            typename D::abi_guard guard(this->shim());
            *token = detach_from<winrt::event_token>(this->shim().CloseButtonClick(*reinterpret_cast<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Xaml::Controls::TeachingTip, winrt::Windows::Foundation::IInspectable> const*>(&handler)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall remove_CloseButtonClick(winrt::event_token token) noexcept final
        {
            typename D::abi_guard guard(this->shim());
            this->shim().CloseButtonClick(*reinterpret_cast<winrt::event_token const*>(&token));
            return 0;
        }
        int32_t __stdcall add_Closing(void* handler, winrt::event_token* token) noexcept final try
        {
            zero_abi<winrt::event_token>(token);
            typename D::abi_guard guard(this->shim());
            *token = detach_from<winrt::event_token>(this->shim().Closing(*reinterpret_cast<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Xaml::Controls::TeachingTip, winrt::Microsoft::UI::Xaml::Controls::TeachingTipClosingEventArgs> const*>(&handler)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall remove_Closing(winrt::event_token token) noexcept final
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Closing(*reinterpret_cast<winrt::event_token const*>(&token));
            return 0;
        }
        int32_t __stdcall add_Closed(void* handler, winrt::event_token* token) noexcept final try
        {
            zero_abi<winrt::event_token>(token);
            typename D::abi_guard guard(this->shim());
            *token = detach_from<winrt::event_token>(this->shim().Closed(*reinterpret_cast<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Xaml::Controls::TeachingTip, winrt::Microsoft::UI::Xaml::Controls::TeachingTipClosedEventArgs> const*>(&handler)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall remove_Closed(winrt::event_token token) noexcept final
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Closed(*reinterpret_cast<winrt::event_token const*>(&token));
            return 0;
        }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Controls::ITeachingTipClosedEventArgs> : produce_base<D, winrt::Microsoft::UI::Xaml::Controls::ITeachingTipClosedEventArgs>
    {
        int32_t __stdcall get_Reason(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::UI::Xaml::Controls::TeachingTipCloseReason>(this->shim().Reason());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Controls::ITeachingTipClosingEventArgs> : produce_base<D, winrt::Microsoft::UI::Xaml::Controls::ITeachingTipClosingEventArgs>
    {
        int32_t __stdcall get_Reason(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::UI::Xaml::Controls::TeachingTipCloseReason>(this->shim().Reason());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Cancel(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().Cancel());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_Cancel(bool value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Cancel(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall GetDeferral(void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Windows::Foundation::Deferral>(this->shim().GetDeferral());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Controls::ITeachingTipFactory> : produce_base<D, winrt::Microsoft::UI::Xaml::Controls::ITeachingTipFactory>
    {
        int32_t __stdcall CreateInstance(void* baseInterface, void** innerInterface, void** value) noexcept final try
        {
            if (innerInterface) *innerInterface = nullptr;
            winrt::Windows::Foundation::IInspectable winrt_impl_innerInterface;
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::UI::Xaml::Controls::TeachingTip>(this->shim().CreateInstance(*reinterpret_cast<winrt::Windows::Foundation::IInspectable const*>(&baseInterface), winrt_impl_innerInterface));
                if (innerInterface) *innerInterface = detach_abi(winrt_impl_innerInterface);
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Controls::ITeachingTipStatics> : produce_base<D, winrt::Microsoft::UI::Xaml::Controls::ITeachingTipStatics>
    {
        int32_t __stdcall get_IsOpenProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().IsOpenProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_TargetProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().TargetProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_TailVisibilityProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().TailVisibilityProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_TitleProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().TitleProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_SubtitleProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().SubtitleProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_ActionButtonContentProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().ActionButtonContentProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_ActionButtonStyleProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().ActionButtonStyleProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_ActionButtonCommandProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().ActionButtonCommandProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_ActionButtonCommandParameterProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().ActionButtonCommandParameterProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_CloseButtonContentProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().CloseButtonContentProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_CloseButtonStyleProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().CloseButtonStyleProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_CloseButtonCommandProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().CloseButtonCommandProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_CloseButtonCommandParameterProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().CloseButtonCommandParameterProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_PlacementMarginProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().PlacementMarginProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_ShouldConstrainToRootBoundsProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().ShouldConstrainToRootBoundsProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_IsLightDismissEnabledProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().IsLightDismissEnabledProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_PreferredPlacementProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().PreferredPlacementProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_HeroContentPlacementProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().HeroContentPlacementProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_HeroContentProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().HeroContentProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_IconSourceProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().IconSourceProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_TemplateSettingsProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().TemplateSettingsProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Controls::ITeachingTipTemplateSettings> : produce_base<D, winrt::Microsoft::UI::Xaml::Controls::ITeachingTipTemplateSettings>
    {
        int32_t __stdcall get_TopRightHighlightMargin(struct struct_Windows_UI_Xaml_Thickness* value) noexcept final try
        {
            zero_abi<winrt::Windows::UI::Xaml::Thickness>(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::Thickness>(this->shim().TopRightHighlightMargin());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_TopRightHighlightMargin(struct struct_Windows_UI_Xaml_Thickness value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().TopRightHighlightMargin(*reinterpret_cast<winrt::Windows::UI::Xaml::Thickness const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_TopLeftHighlightMargin(struct struct_Windows_UI_Xaml_Thickness* value) noexcept final try
        {
            zero_abi<winrt::Windows::UI::Xaml::Thickness>(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::Thickness>(this->shim().TopLeftHighlightMargin());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_TopLeftHighlightMargin(struct struct_Windows_UI_Xaml_Thickness value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().TopLeftHighlightMargin(*reinterpret_cast<winrt::Windows::UI::Xaml::Thickness const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_IconElement(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::Controls::IconElement>(this->shim().IconElement());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_IconElement(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().IconElement(*reinterpret_cast<winrt::Windows::UI::Xaml::Controls::IconElement const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Controls::ITeachingTipTemplateSettingsFactory> : produce_base<D, winrt::Microsoft::UI::Xaml::Controls::ITeachingTipTemplateSettingsFactory>
    {
        int32_t __stdcall CreateInstance(void* baseInterface, void** innerInterface, void** value) noexcept final try
        {
            if (innerInterface) *innerInterface = nullptr;
            winrt::Windows::Foundation::IInspectable winrt_impl_innerInterface;
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::UI::Xaml::Controls::TeachingTipTemplateSettings>(this->shim().CreateInstance(*reinterpret_cast<winrt::Windows::Foundation::IInspectable const*>(&baseInterface), winrt_impl_innerInterface));
                if (innerInterface) *innerInterface = detach_abi(winrt_impl_innerInterface);
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Controls::ITeachingTipTemplateSettingsStatics> : produce_base<D, winrt::Microsoft::UI::Xaml::Controls::ITeachingTipTemplateSettingsStatics>
    {
        int32_t __stdcall get_TopRightHighlightMarginProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().TopRightHighlightMarginProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_TopLeftHighlightMarginProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().TopLeftHighlightMarginProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_IconElementProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().IconElementProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Controls::ITextCommandBarFlyout> : produce_base<D, winrt::Microsoft::UI::Xaml::Controls::ITextCommandBarFlyout>
    {
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Controls::ITextCommandBarFlyoutFactory> : produce_base<D, winrt::Microsoft::UI::Xaml::Controls::ITextCommandBarFlyoutFactory>
    {
        int32_t __stdcall CreateInstance(void* baseInterface, void** innerInterface, void** value) noexcept final try
        {
            if (innerInterface) *innerInterface = nullptr;
            winrt::Windows::Foundation::IInspectable winrt_impl_innerInterface;
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::UI::Xaml::Controls::TextCommandBarFlyout>(this->shim().CreateInstance(*reinterpret_cast<winrt::Windows::Foundation::IInspectable const*>(&baseInterface), winrt_impl_innerInterface));
                if (innerInterface) *innerInterface = detach_abi(winrt_impl_innerInterface);
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Controls::IToggleSplitButton> : produce_base<D, winrt::Microsoft::UI::Xaml::Controls::IToggleSplitButton>
    {
        int32_t __stdcall get_IsChecked(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().IsChecked());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_IsChecked(bool value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().IsChecked(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall add_IsCheckedChanged(void* handler, winrt::event_token* token) noexcept final try
        {
            zero_abi<winrt::event_token>(token);
            typename D::abi_guard guard(this->shim());
            *token = detach_from<winrt::event_token>(this->shim().IsCheckedChanged(*reinterpret_cast<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Xaml::Controls::ToggleSplitButton, winrt::Microsoft::UI::Xaml::Controls::ToggleSplitButtonIsCheckedChangedEventArgs> const*>(&handler)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall remove_IsCheckedChanged(winrt::event_token token) noexcept final
        {
            typename D::abi_guard guard(this->shim());
            this->shim().IsCheckedChanged(*reinterpret_cast<winrt::event_token const*>(&token));
            return 0;
        }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Controls::IToggleSplitButtonFactory> : produce_base<D, winrt::Microsoft::UI::Xaml::Controls::IToggleSplitButtonFactory>
    {
        int32_t __stdcall CreateInstance(void* baseInterface, void** innerInterface, void** value) noexcept final try
        {
            if (innerInterface) *innerInterface = nullptr;
            winrt::Windows::Foundation::IInspectable winrt_impl_innerInterface;
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::UI::Xaml::Controls::ToggleSplitButton>(this->shim().CreateInstance(*reinterpret_cast<winrt::Windows::Foundation::IInspectable const*>(&baseInterface), winrt_impl_innerInterface));
                if (innerInterface) *innerInterface = detach_abi(winrt_impl_innerInterface);
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Controls::IToggleSplitButtonIsCheckedChangedEventArgs> : produce_base<D, winrt::Microsoft::UI::Xaml::Controls::IToggleSplitButtonIsCheckedChangedEventArgs>
    {
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Controls::IToggleSplitButtonStatics> : produce_base<D, winrt::Microsoft::UI::Xaml::Controls::IToggleSplitButtonStatics>
    {
        int32_t __stdcall get_IsCheckedProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().IsCheckedProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Controls::ITreeView> : produce_base<D, winrt::Microsoft::UI::Xaml::Controls::ITreeView>
    {
        int32_t __stdcall get_RootNodes(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::Collections::IVector<winrt::Microsoft::UI::Xaml::Controls::TreeViewNode>>(this->shim().RootNodes());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_SelectionMode(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::UI::Xaml::Controls::TreeViewSelectionMode>(this->shim().SelectionMode());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_SelectionMode(int32_t value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().SelectionMode(*reinterpret_cast<winrt::Microsoft::UI::Xaml::Controls::TreeViewSelectionMode const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_SelectedNodes(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::Collections::IVector<winrt::Microsoft::UI::Xaml::Controls::TreeViewNode>>(this->shim().SelectedNodes());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall Expand(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Expand(*reinterpret_cast<winrt::Microsoft::UI::Xaml::Controls::TreeViewNode const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall Collapse(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Collapse(*reinterpret_cast<winrt::Microsoft::UI::Xaml::Controls::TreeViewNode const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall SelectAll() noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().SelectAll();
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall add_ItemInvoked(void* handler, winrt::event_token* token) noexcept final try
        {
            zero_abi<winrt::event_token>(token);
            typename D::abi_guard guard(this->shim());
            *token = detach_from<winrt::event_token>(this->shim().ItemInvoked(*reinterpret_cast<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Xaml::Controls::TreeView, winrt::Microsoft::UI::Xaml::Controls::TreeViewItemInvokedEventArgs> const*>(&handler)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall remove_ItemInvoked(winrt::event_token token) noexcept final
        {
            typename D::abi_guard guard(this->shim());
            this->shim().ItemInvoked(*reinterpret_cast<winrt::event_token const*>(&token));
            return 0;
        }
        int32_t __stdcall add_Expanding(void* handler, winrt::event_token* token) noexcept final try
        {
            zero_abi<winrt::event_token>(token);
            typename D::abi_guard guard(this->shim());
            *token = detach_from<winrt::event_token>(this->shim().Expanding(*reinterpret_cast<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Xaml::Controls::TreeView, winrt::Microsoft::UI::Xaml::Controls::TreeViewExpandingEventArgs> const*>(&handler)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall remove_Expanding(winrt::event_token token) noexcept final
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Expanding(*reinterpret_cast<winrt::event_token const*>(&token));
            return 0;
        }
        int32_t __stdcall add_Collapsed(void* handler, winrt::event_token* token) noexcept final try
        {
            zero_abi<winrt::event_token>(token);
            typename D::abi_guard guard(this->shim());
            *token = detach_from<winrt::event_token>(this->shim().Collapsed(*reinterpret_cast<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Xaml::Controls::TreeView, winrt::Microsoft::UI::Xaml::Controls::TreeViewCollapsedEventArgs> const*>(&handler)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall remove_Collapsed(winrt::event_token token) noexcept final
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Collapsed(*reinterpret_cast<winrt::event_token const*>(&token));
            return 0;
        }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Controls::ITreeView2> : produce_base<D, winrt::Microsoft::UI::Xaml::Controls::ITreeView2>
    {
        int32_t __stdcall NodeFromContainer(void* container, void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Microsoft::UI::Xaml::Controls::TreeViewNode>(this->shim().NodeFromContainer(*reinterpret_cast<winrt::Windows::UI::Xaml::DependencyObject const*>(&container)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall ContainerFromNode(void* node, void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Windows::UI::Xaml::DependencyObject>(this->shim().ContainerFromNode(*reinterpret_cast<winrt::Microsoft::UI::Xaml::Controls::TreeViewNode const*>(&node)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall ItemFromContainer(void* container, void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Windows::Foundation::IInspectable>(this->shim().ItemFromContainer(*reinterpret_cast<winrt::Windows::UI::Xaml::DependencyObject const*>(&container)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall ContainerFromItem(void* item, void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Windows::UI::Xaml::DependencyObject>(this->shim().ContainerFromItem(*reinterpret_cast<winrt::Windows::Foundation::IInspectable const*>(&item)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_CanDragItems(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().CanDragItems());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_CanDragItems(bool value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().CanDragItems(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_CanReorderItems(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().CanReorderItems());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_CanReorderItems(bool value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().CanReorderItems(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_ItemTemplate(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DataTemplate>(this->shim().ItemTemplate());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_ItemTemplate(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().ItemTemplate(*reinterpret_cast<winrt::Windows::UI::Xaml::DataTemplate const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_ItemTemplateSelector(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::Controls::DataTemplateSelector>(this->shim().ItemTemplateSelector());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_ItemTemplateSelector(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().ItemTemplateSelector(*reinterpret_cast<winrt::Windows::UI::Xaml::Controls::DataTemplateSelector const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_ItemContainerStyle(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::Style>(this->shim().ItemContainerStyle());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_ItemContainerStyle(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().ItemContainerStyle(*reinterpret_cast<winrt::Windows::UI::Xaml::Style const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_ItemContainerStyleSelector(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::Controls::StyleSelector>(this->shim().ItemContainerStyleSelector());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_ItemContainerStyleSelector(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().ItemContainerStyleSelector(*reinterpret_cast<winrt::Windows::UI::Xaml::Controls::StyleSelector const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_ItemContainerTransitions(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::Media::Animation::TransitionCollection>(this->shim().ItemContainerTransitions());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_ItemContainerTransitions(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().ItemContainerTransitions(*reinterpret_cast<winrt::Windows::UI::Xaml::Media::Animation::TransitionCollection const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_ItemsSource(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::IInspectable>(this->shim().ItemsSource());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_ItemsSource(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().ItemsSource(*reinterpret_cast<winrt::Windows::Foundation::IInspectable const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall add_DragItemsStarting(void* handler, winrt::event_token* token) noexcept final try
        {
            zero_abi<winrt::event_token>(token);
            typename D::abi_guard guard(this->shim());
            *token = detach_from<winrt::event_token>(this->shim().DragItemsStarting(*reinterpret_cast<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Xaml::Controls::TreeView, winrt::Microsoft::UI::Xaml::Controls::TreeViewDragItemsStartingEventArgs> const*>(&handler)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall remove_DragItemsStarting(winrt::event_token token) noexcept final
        {
            typename D::abi_guard guard(this->shim());
            this->shim().DragItemsStarting(*reinterpret_cast<winrt::event_token const*>(&token));
            return 0;
        }
        int32_t __stdcall add_DragItemsCompleted(void* handler, winrt::event_token* token) noexcept final try
        {
            zero_abi<winrt::event_token>(token);
            typename D::abi_guard guard(this->shim());
            *token = detach_from<winrt::event_token>(this->shim().DragItemsCompleted(*reinterpret_cast<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Xaml::Controls::TreeView, winrt::Microsoft::UI::Xaml::Controls::TreeViewDragItemsCompletedEventArgs> const*>(&handler)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall remove_DragItemsCompleted(winrt::event_token token) noexcept final
        {
            typename D::abi_guard guard(this->shim());
            this->shim().DragItemsCompleted(*reinterpret_cast<winrt::event_token const*>(&token));
            return 0;
        }
        int32_t __stdcall get_SelectedNode(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::UI::Xaml::Controls::TreeViewNode>(this->shim().SelectedNode());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_SelectedNode(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().SelectedNode(*reinterpret_cast<winrt::Microsoft::UI::Xaml::Controls::TreeViewNode const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_SelectedItem(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::IInspectable>(this->shim().SelectedItem());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_SelectedItem(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().SelectedItem(*reinterpret_cast<winrt::Windows::Foundation::IInspectable const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_SelectedItems(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::Collections::IVector<winrt::Windows::Foundation::IInspectable>>(this->shim().SelectedItems());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Controls::ITreeViewCollapsedEventArgs> : produce_base<D, winrt::Microsoft::UI::Xaml::Controls::ITreeViewCollapsedEventArgs>
    {
        int32_t __stdcall get_Node(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::UI::Xaml::Controls::TreeViewNode>(this->shim().Node());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Controls::ITreeViewCollapsedEventArgs2> : produce_base<D, winrt::Microsoft::UI::Xaml::Controls::ITreeViewCollapsedEventArgs2>
    {
        int32_t __stdcall get_Item(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::IInspectable>(this->shim().Item());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Controls::ITreeViewDragItemsCompletedEventArgs> : produce_base<D, winrt::Microsoft::UI::Xaml::Controls::ITreeViewDragItemsCompletedEventArgs>
    {
        int32_t __stdcall get_DropResult(uint32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::ApplicationModel::DataTransfer::DataPackageOperation>(this->shim().DropResult());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Items(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::Collections::IVectorView<winrt::Windows::Foundation::IInspectable>>(this->shim().Items());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Controls::ITreeViewDragItemsCompletedEventArgs2> : produce_base<D, winrt::Microsoft::UI::Xaml::Controls::ITreeViewDragItemsCompletedEventArgs2>
    {
        int32_t __stdcall get_NewParentItem(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::IInspectable>(this->shim().NewParentItem());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Controls::ITreeViewDragItemsStartingEventArgs> : produce_base<D, winrt::Microsoft::UI::Xaml::Controls::ITreeViewDragItemsStartingEventArgs>
    {
        int32_t __stdcall get_Cancel(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().Cancel());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_Cancel(bool value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Cancel(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Data(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::ApplicationModel::DataTransfer::DataPackage>(this->shim().Data());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Items(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::Collections::IVector<winrt::Windows::Foundation::IInspectable>>(this->shim().Items());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Controls::ITreeViewExpandingEventArgs> : produce_base<D, winrt::Microsoft::UI::Xaml::Controls::ITreeViewExpandingEventArgs>
    {
        int32_t __stdcall get_Node(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::UI::Xaml::Controls::TreeViewNode>(this->shim().Node());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Controls::ITreeViewExpandingEventArgs2> : produce_base<D, winrt::Microsoft::UI::Xaml::Controls::ITreeViewExpandingEventArgs2>
    {
        int32_t __stdcall get_Item(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::IInspectable>(this->shim().Item());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Controls::ITreeViewFactory> : produce_base<D, winrt::Microsoft::UI::Xaml::Controls::ITreeViewFactory>
    {
        int32_t __stdcall CreateInstance(void* baseInterface, void** innerInterface, void** value) noexcept final try
        {
            if (innerInterface) *innerInterface = nullptr;
            winrt::Windows::Foundation::IInspectable winrt_impl_innerInterface;
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::UI::Xaml::Controls::TreeView>(this->shim().CreateInstance(*reinterpret_cast<winrt::Windows::Foundation::IInspectable const*>(&baseInterface), winrt_impl_innerInterface));
                if (innerInterface) *innerInterface = detach_abi(winrt_impl_innerInterface);
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Controls::ITreeViewItem> : produce_base<D, winrt::Microsoft::UI::Xaml::Controls::ITreeViewItem>
    {
        int32_t __stdcall get_GlyphOpacity(double* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<double>(this->shim().GlyphOpacity());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_GlyphOpacity(double value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().GlyphOpacity(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_GlyphBrush(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::Media::Brush>(this->shim().GlyphBrush());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_GlyphBrush(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().GlyphBrush(*reinterpret_cast<winrt::Windows::UI::Xaml::Media::Brush const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_ExpandedGlyph(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<hstring>(this->shim().ExpandedGlyph());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_ExpandedGlyph(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().ExpandedGlyph(*reinterpret_cast<hstring const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_CollapsedGlyph(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<hstring>(this->shim().CollapsedGlyph());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_CollapsedGlyph(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().CollapsedGlyph(*reinterpret_cast<hstring const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_GlyphSize(double* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<double>(this->shim().GlyphSize());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_GlyphSize(double value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().GlyphSize(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_IsExpanded(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().IsExpanded());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_IsExpanded(bool value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().IsExpanded(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_TreeViewItemTemplateSettings(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::UI::Xaml::Controls::TreeViewItemTemplateSettings>(this->shim().TreeViewItemTemplateSettings());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Controls::ITreeViewItem2> : produce_base<D, winrt::Microsoft::UI::Xaml::Controls::ITreeViewItem2>
    {
        int32_t __stdcall get_HasUnrealizedChildren(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().HasUnrealizedChildren());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_HasUnrealizedChildren(bool value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().HasUnrealizedChildren(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_ItemsSource(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::IInspectable>(this->shim().ItemsSource());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_ItemsSource(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().ItemsSource(*reinterpret_cast<winrt::Windows::Foundation::IInspectable const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Controls::ITreeViewItemFactory> : produce_base<D, winrt::Microsoft::UI::Xaml::Controls::ITreeViewItemFactory>
    {
        int32_t __stdcall CreateInstance(void* baseInterface, void** innerInterface, void** value) noexcept final try
        {
            if (innerInterface) *innerInterface = nullptr;
            winrt::Windows::Foundation::IInspectable winrt_impl_innerInterface;
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::UI::Xaml::Controls::TreeViewItem>(this->shim().CreateInstance(*reinterpret_cast<winrt::Windows::Foundation::IInspectable const*>(&baseInterface), winrt_impl_innerInterface));
                if (innerInterface) *innerInterface = detach_abi(winrt_impl_innerInterface);
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Controls::ITreeViewItemInvokedEventArgs> : produce_base<D, winrt::Microsoft::UI::Xaml::Controls::ITreeViewItemInvokedEventArgs>
    {
        int32_t __stdcall get_InvokedItem(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::IInspectable>(this->shim().InvokedItem());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_Handled(bool value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Handled(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Handled(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().Handled());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Controls::ITreeViewItemStatics> : produce_base<D, winrt::Microsoft::UI::Xaml::Controls::ITreeViewItemStatics>
    {
        int32_t __stdcall get_GlyphOpacityProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().GlyphOpacityProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_GlyphBrushProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().GlyphBrushProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_ExpandedGlyphProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().ExpandedGlyphProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_CollapsedGlyphProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().CollapsedGlyphProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_GlyphSizeProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().GlyphSizeProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_IsExpandedProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().IsExpandedProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_TreeViewItemTemplateSettingsProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().TreeViewItemTemplateSettingsProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Controls::ITreeViewItemStatics2> : produce_base<D, winrt::Microsoft::UI::Xaml::Controls::ITreeViewItemStatics2>
    {
        int32_t __stdcall get_HasUnrealizedChildrenProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().HasUnrealizedChildrenProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_ItemsSourceProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().ItemsSourceProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Controls::ITreeViewItemTemplateSettings> : produce_base<D, winrt::Microsoft::UI::Xaml::Controls::ITreeViewItemTemplateSettings>
    {
        int32_t __stdcall get_ExpandedGlyphVisibility(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::Visibility>(this->shim().ExpandedGlyphVisibility());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_CollapsedGlyphVisibility(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::Visibility>(this->shim().CollapsedGlyphVisibility());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Indentation(struct struct_Windows_UI_Xaml_Thickness* value) noexcept final try
        {
            zero_abi<winrt::Windows::UI::Xaml::Thickness>(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::Thickness>(this->shim().Indentation());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_DragItemsCount(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<int32_t>(this->shim().DragItemsCount());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Controls::ITreeViewItemTemplateSettingsFactory> : produce_base<D, winrt::Microsoft::UI::Xaml::Controls::ITreeViewItemTemplateSettingsFactory>
    {
        int32_t __stdcall CreateInstance(void* baseInterface, void** innerInterface, void** value) noexcept final try
        {
            if (innerInterface) *innerInterface = nullptr;
            winrt::Windows::Foundation::IInspectable winrt_impl_innerInterface;
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::UI::Xaml::Controls::TreeViewItemTemplateSettings>(this->shim().CreateInstance(*reinterpret_cast<winrt::Windows::Foundation::IInspectable const*>(&baseInterface), winrt_impl_innerInterface));
                if (innerInterface) *innerInterface = detach_abi(winrt_impl_innerInterface);
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Controls::ITreeViewItemTemplateSettingsStatics> : produce_base<D, winrt::Microsoft::UI::Xaml::Controls::ITreeViewItemTemplateSettingsStatics>
    {
        int32_t __stdcall get_ExpandedGlyphVisibilityProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().ExpandedGlyphVisibilityProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_CollapsedGlyphVisibilityProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().CollapsedGlyphVisibilityProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_IndentationProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().IndentationProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_DragItemsCountProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().DragItemsCountProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Controls::ITreeViewList> : produce_base<D, winrt::Microsoft::UI::Xaml::Controls::ITreeViewList>
    {
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Controls::ITreeViewListFactory> : produce_base<D, winrt::Microsoft::UI::Xaml::Controls::ITreeViewListFactory>
    {
        int32_t __stdcall CreateInstance(void* baseInterface, void** innerInterface, void** value) noexcept final try
        {
            if (innerInterface) *innerInterface = nullptr;
            winrt::Windows::Foundation::IInspectable winrt_impl_innerInterface;
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::UI::Xaml::Controls::TreeViewList>(this->shim().CreateInstance(*reinterpret_cast<winrt::Windows::Foundation::IInspectable const*>(&baseInterface), winrt_impl_innerInterface));
                if (innerInterface) *innerInterface = detach_abi(winrt_impl_innerInterface);
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Controls::ITreeViewNode> : produce_base<D, winrt::Microsoft::UI::Xaml::Controls::ITreeViewNode>
    {
        int32_t __stdcall get_Content(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::IInspectable>(this->shim().Content());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_Content(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Content(*reinterpret_cast<winrt::Windows::Foundation::IInspectable const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Parent(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::UI::Xaml::Controls::TreeViewNode>(this->shim().Parent());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_IsExpanded(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().IsExpanded());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_IsExpanded(bool value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().IsExpanded(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_HasChildren(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().HasChildren());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Depth(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<int32_t>(this->shim().Depth());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_HasUnrealizedChildren(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().HasUnrealizedChildren());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_HasUnrealizedChildren(bool value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().HasUnrealizedChildren(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Children(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::Collections::IVector<winrt::Microsoft::UI::Xaml::Controls::TreeViewNode>>(this->shim().Children());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Controls::ITreeViewNodeFactory> : produce_base<D, winrt::Microsoft::UI::Xaml::Controls::ITreeViewNodeFactory>
    {
        int32_t __stdcall CreateInstance(void* baseInterface, void** innerInterface, void** value) noexcept final try
        {
            if (innerInterface) *innerInterface = nullptr;
            winrt::Windows::Foundation::IInspectable winrt_impl_innerInterface;
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::UI::Xaml::Controls::TreeViewNode>(this->shim().CreateInstance(*reinterpret_cast<winrt::Windows::Foundation::IInspectable const*>(&baseInterface), winrt_impl_innerInterface));
                if (innerInterface) *innerInterface = detach_abi(winrt_impl_innerInterface);
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Controls::ITreeViewNodeStatics> : produce_base<D, winrt::Microsoft::UI::Xaml::Controls::ITreeViewNodeStatics>
    {
        int32_t __stdcall get_ContentProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().ContentProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_DepthProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().DepthProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_IsExpandedProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().IsExpandedProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_HasChildrenProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().HasChildrenProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Controls::ITreeViewStatics> : produce_base<D, winrt::Microsoft::UI::Xaml::Controls::ITreeViewStatics>
    {
        int32_t __stdcall get_SelectedItemProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().SelectedItemProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_SelectionModeProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().SelectionModeProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Controls::ITreeViewStatics2> : produce_base<D, winrt::Microsoft::UI::Xaml::Controls::ITreeViewStatics2>
    {
        int32_t __stdcall get_CanDragItemsProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().CanDragItemsProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_CanReorderItemsProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().CanReorderItemsProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_ItemTemplateProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().ItemTemplateProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_ItemTemplateSelectorProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().ItemTemplateSelectorProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_ItemContainerStyleProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().ItemContainerStyleProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_ItemContainerStyleSelectorProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().ItemContainerStyleSelectorProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_ItemContainerTransitionsProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().ItemContainerTransitionsProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_ItemsSourceProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().ItemsSourceProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Controls::ITwoPaneView> : produce_base<D, winrt::Microsoft::UI::Xaml::Controls::ITwoPaneView>
    {
        int32_t __stdcall get_Pane1(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::UIElement>(this->shim().Pane1());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_Pane1(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Pane1(*reinterpret_cast<winrt::Windows::UI::Xaml::UIElement const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Pane2(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::UIElement>(this->shim().Pane2());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_Pane2(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Pane2(*reinterpret_cast<winrt::Windows::UI::Xaml::UIElement const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Pane1Length(struct struct_Windows_UI_Xaml_GridLength* value) noexcept final try
        {
            zero_abi<winrt::Windows::UI::Xaml::GridLength>(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::GridLength>(this->shim().Pane1Length());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_Pane1Length(struct struct_Windows_UI_Xaml_GridLength value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Pane1Length(*reinterpret_cast<winrt::Windows::UI::Xaml::GridLength const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Pane2Length(struct struct_Windows_UI_Xaml_GridLength* value) noexcept final try
        {
            zero_abi<winrt::Windows::UI::Xaml::GridLength>(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::GridLength>(this->shim().Pane2Length());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_Pane2Length(struct struct_Windows_UI_Xaml_GridLength value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Pane2Length(*reinterpret_cast<winrt::Windows::UI::Xaml::GridLength const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_PanePriority(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::UI::Xaml::Controls::TwoPaneViewPriority>(this->shim().PanePriority());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_PanePriority(int32_t value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().PanePriority(*reinterpret_cast<winrt::Microsoft::UI::Xaml::Controls::TwoPaneViewPriority const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Mode(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::UI::Xaml::Controls::TwoPaneViewMode>(this->shim().Mode());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_WideModeConfiguration(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::UI::Xaml::Controls::TwoPaneViewWideModeConfiguration>(this->shim().WideModeConfiguration());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_WideModeConfiguration(int32_t value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().WideModeConfiguration(*reinterpret_cast<winrt::Microsoft::UI::Xaml::Controls::TwoPaneViewWideModeConfiguration const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_TallModeConfiguration(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::UI::Xaml::Controls::TwoPaneViewTallModeConfiguration>(this->shim().TallModeConfiguration());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_TallModeConfiguration(int32_t value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().TallModeConfiguration(*reinterpret_cast<winrt::Microsoft::UI::Xaml::Controls::TwoPaneViewTallModeConfiguration const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_MinWideModeWidth(double* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<double>(this->shim().MinWideModeWidth());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_MinWideModeWidth(double value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().MinWideModeWidth(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_MinTallModeHeight(double* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<double>(this->shim().MinTallModeHeight());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_MinTallModeHeight(double value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().MinTallModeHeight(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall add_ModeChanged(void* handler, winrt::event_token* token) noexcept final try
        {
            zero_abi<winrt::event_token>(token);
            typename D::abi_guard guard(this->shim());
            *token = detach_from<winrt::event_token>(this->shim().ModeChanged(*reinterpret_cast<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Xaml::Controls::TwoPaneView, winrt::Windows::Foundation::IInspectable> const*>(&handler)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall remove_ModeChanged(winrt::event_token token) noexcept final
        {
            typename D::abi_guard guard(this->shim());
            this->shim().ModeChanged(*reinterpret_cast<winrt::event_token const*>(&token));
            return 0;
        }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Controls::ITwoPaneViewFactory> : produce_base<D, winrt::Microsoft::UI::Xaml::Controls::ITwoPaneViewFactory>
    {
        int32_t __stdcall CreateInstance(void* baseInterface, void** innerInterface, void** value) noexcept final try
        {
            if (innerInterface) *innerInterface = nullptr;
            winrt::Windows::Foundation::IInspectable winrt_impl_innerInterface;
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::UI::Xaml::Controls::TwoPaneView>(this->shim().CreateInstance(*reinterpret_cast<winrt::Windows::Foundation::IInspectable const*>(&baseInterface), winrt_impl_innerInterface));
                if (innerInterface) *innerInterface = detach_abi(winrt_impl_innerInterface);
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Controls::ITwoPaneViewStatics> : produce_base<D, winrt::Microsoft::UI::Xaml::Controls::ITwoPaneViewStatics>
    {
        int32_t __stdcall get_Pane1Property(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().Pane1Property());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Pane2Property(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().Pane2Property());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Pane1LengthProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().Pane1LengthProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Pane2LengthProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().Pane2LengthProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_PanePriorityProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().PanePriorityProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_ModeProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().ModeProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_WideModeConfigurationProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().WideModeConfigurationProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_TallModeConfigurationProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().TallModeConfigurationProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_MinWideModeWidthProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().MinWideModeWidthProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_MinTallModeHeightProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().MinTallModeHeightProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Controls::IUniformGridLayout> : produce_base<D, winrt::Microsoft::UI::Xaml::Controls::IUniformGridLayout>
    {
        int32_t __stdcall get_Orientation(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::Controls::Orientation>(this->shim().Orientation());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_Orientation(int32_t value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Orientation(*reinterpret_cast<winrt::Windows::UI::Xaml::Controls::Orientation const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_MinItemWidth(double* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<double>(this->shim().MinItemWidth());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_MinItemWidth(double value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().MinItemWidth(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_MinItemHeight(double* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<double>(this->shim().MinItemHeight());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_MinItemHeight(double value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().MinItemHeight(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_MinRowSpacing(double* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<double>(this->shim().MinRowSpacing());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_MinRowSpacing(double value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().MinRowSpacing(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_MinColumnSpacing(double* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<double>(this->shim().MinColumnSpacing());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_MinColumnSpacing(double value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().MinColumnSpacing(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_ItemsJustification(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::UI::Xaml::Controls::UniformGridLayoutItemsJustification>(this->shim().ItemsJustification());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_ItemsJustification(int32_t value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().ItemsJustification(*reinterpret_cast<winrt::Microsoft::UI::Xaml::Controls::UniformGridLayoutItemsJustification const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_ItemsStretch(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::UI::Xaml::Controls::UniformGridLayoutItemsStretch>(this->shim().ItemsStretch());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_ItemsStretch(int32_t value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().ItemsStretch(*reinterpret_cast<winrt::Microsoft::UI::Xaml::Controls::UniformGridLayoutItemsStretch const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_MaximumRowsOrColumns(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<int32_t>(this->shim().MaximumRowsOrColumns());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_MaximumRowsOrColumns(int32_t value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().MaximumRowsOrColumns(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Controls::IUniformGridLayoutFactory> : produce_base<D, winrt::Microsoft::UI::Xaml::Controls::IUniformGridLayoutFactory>
    {
        int32_t __stdcall CreateInstance(void* baseInterface, void** innerInterface, void** value) noexcept final try
        {
            if (innerInterface) *innerInterface = nullptr;
            winrt::Windows::Foundation::IInspectable winrt_impl_innerInterface;
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::UI::Xaml::Controls::UniformGridLayout>(this->shim().CreateInstance(*reinterpret_cast<winrt::Windows::Foundation::IInspectable const*>(&baseInterface), winrt_impl_innerInterface));
                if (innerInterface) *innerInterface = detach_abi(winrt_impl_innerInterface);
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Controls::IUniformGridLayoutStatics> : produce_base<D, winrt::Microsoft::UI::Xaml::Controls::IUniformGridLayoutStatics>
    {
        int32_t __stdcall get_OrientationProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().OrientationProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_MinItemWidthProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().MinItemWidthProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_MinItemHeightProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().MinItemHeightProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_MinRowSpacingProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().MinRowSpacingProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_MinColumnSpacingProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().MinColumnSpacingProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_ItemsJustificationProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().ItemsJustificationProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_ItemsStretchProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().ItemsStretchProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_MaximumRowsOrColumnsProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().MaximumRowsOrColumnsProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Controls::IVirtualizingLayout> : produce_base<D, winrt::Microsoft::UI::Xaml::Controls::IVirtualizingLayout>
    {
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Controls::IVirtualizingLayoutContext> : produce_base<D, winrt::Microsoft::UI::Xaml::Controls::IVirtualizingLayoutContext>
    {
        int32_t __stdcall get_ItemCount(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<int32_t>(this->shim().ItemCount());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall GetItemAt(int32_t index, void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Windows::Foundation::IInspectable>(this->shim().GetItemAt(index));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_RealizationRect(winrt::Windows::Foundation::Rect* value) noexcept final try
        {
            zero_abi<winrt::Windows::Foundation::Rect>(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::Rect>(this->shim().RealizationRect());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall GetOrCreateElementAt(int32_t index, void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Windows::UI::Xaml::UIElement>(this->shim().GetOrCreateElementAt(index));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall GetOrCreateElementAt2(int32_t index, uint32_t options, void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Windows::UI::Xaml::UIElement>(this->shim().GetOrCreateElementAt(index, *reinterpret_cast<winrt::Microsoft::UI::Xaml::Controls::ElementRealizationOptions const*>(&options)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall RecycleElement(void* element) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().RecycleElement(*reinterpret_cast<winrt::Windows::UI::Xaml::UIElement const*>(&element));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_RecommendedAnchorIndex(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<int32_t>(this->shim().RecommendedAnchorIndex());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_LayoutOrigin(winrt::Windows::Foundation::Point* value) noexcept final try
        {
            zero_abi<winrt::Windows::Foundation::Point>(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::Point>(this->shim().LayoutOrigin());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_LayoutOrigin(winrt::Windows::Foundation::Point value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().LayoutOrigin(*reinterpret_cast<winrt::Windows::Foundation::Point const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Controls::IVirtualizingLayoutContextFactory> : produce_base<D, winrt::Microsoft::UI::Xaml::Controls::IVirtualizingLayoutContextFactory>
    {
        int32_t __stdcall CreateInstance(void* baseInterface, void** innerInterface, void** value) noexcept final try
        {
            if (innerInterface) *innerInterface = nullptr;
            winrt::Windows::Foundation::IInspectable winrt_impl_innerInterface;
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::UI::Xaml::Controls::VirtualizingLayoutContext>(this->shim().CreateInstance(*reinterpret_cast<winrt::Windows::Foundation::IInspectable const*>(&baseInterface), winrt_impl_innerInterface));
                if (innerInterface) *innerInterface = detach_abi(winrt_impl_innerInterface);
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Controls::IVirtualizingLayoutContextOverrides> : produce_base<D, winrt::Microsoft::UI::Xaml::Controls::IVirtualizingLayoutContextOverrides>
    {
        int32_t __stdcall ItemCountCore(int32_t* result) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *result = detach_from<int32_t>(this->shim().ItemCountCore());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall GetItemAtCore(int32_t index, void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Windows::Foundation::IInspectable>(this->shim().GetItemAtCore(index));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall RealizationRectCore(winrt::Windows::Foundation::Rect* result) noexcept final try
        {
            zero_abi<winrt::Windows::Foundation::Rect>(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Windows::Foundation::Rect>(this->shim().RealizationRectCore());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall GetOrCreateElementAtCore(int32_t index, uint32_t options, void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Windows::UI::Xaml::UIElement>(this->shim().GetOrCreateElementAtCore(index, *reinterpret_cast<winrt::Microsoft::UI::Xaml::Controls::ElementRealizationOptions const*>(&options)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall RecycleElementCore(void* element) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().RecycleElementCore(*reinterpret_cast<winrt::Windows::UI::Xaml::UIElement const*>(&element));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_RecommendedAnchorIndexCore(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<int32_t>(this->shim().RecommendedAnchorIndexCore());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_LayoutOriginCore(winrt::Windows::Foundation::Point* value) noexcept final try
        {
            zero_abi<winrt::Windows::Foundation::Point>(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::Point>(this->shim().LayoutOriginCore());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_LayoutOriginCore(winrt::Windows::Foundation::Point value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().LayoutOriginCore(*reinterpret_cast<winrt::Windows::Foundation::Point const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Controls::IVirtualizingLayoutFactory> : produce_base<D, winrt::Microsoft::UI::Xaml::Controls::IVirtualizingLayoutFactory>
    {
        int32_t __stdcall CreateInstance(void* baseInterface, void** innerInterface, void** value) noexcept final try
        {
            if (innerInterface) *innerInterface = nullptr;
            winrt::Windows::Foundation::IInspectable winrt_impl_innerInterface;
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::UI::Xaml::Controls::VirtualizingLayout>(this->shim().CreateInstance(*reinterpret_cast<winrt::Windows::Foundation::IInspectable const*>(&baseInterface), winrt_impl_innerInterface));
                if (innerInterface) *innerInterface = detach_abi(winrt_impl_innerInterface);
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Controls::IVirtualizingLayoutOverrides> : produce_base<D, winrt::Microsoft::UI::Xaml::Controls::IVirtualizingLayoutOverrides>
    {
        int32_t __stdcall InitializeForContextCore(void* context) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().InitializeForContextCore(*reinterpret_cast<winrt::Microsoft::UI::Xaml::Controls::VirtualizingLayoutContext const*>(&context));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall UninitializeForContextCore(void* context) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().UninitializeForContextCore(*reinterpret_cast<winrt::Microsoft::UI::Xaml::Controls::VirtualizingLayoutContext const*>(&context));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall MeasureOverride(void* context, winrt::Windows::Foundation::Size availableSize, winrt::Windows::Foundation::Size* result) noexcept final try
        {
            zero_abi<winrt::Windows::Foundation::Size>(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Windows::Foundation::Size>(this->shim().MeasureOverride(*reinterpret_cast<winrt::Microsoft::UI::Xaml::Controls::VirtualizingLayoutContext const*>(&context), *reinterpret_cast<winrt::Windows::Foundation::Size const*>(&availableSize)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall ArrangeOverride(void* context, winrt::Windows::Foundation::Size finalSize, winrt::Windows::Foundation::Size* result) noexcept final try
        {
            zero_abi<winrt::Windows::Foundation::Size>(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Windows::Foundation::Size>(this->shim().ArrangeOverride(*reinterpret_cast<winrt::Microsoft::UI::Xaml::Controls::VirtualizingLayoutContext const*>(&context), *reinterpret_cast<winrt::Windows::Foundation::Size const*>(&finalSize)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall OnItemsChangedCore(void* context, void* source, void* args) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().OnItemsChangedCore(*reinterpret_cast<winrt::Microsoft::UI::Xaml::Controls::VirtualizingLayoutContext const*>(&context), *reinterpret_cast<winrt::Windows::Foundation::IInspectable const*>(&source), *reinterpret_cast<winrt::Windows::UI::Xaml::Interop::NotifyCollectionChangedEventArgs const*>(&args));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Controls::IWebView2> : produce_base<D, winrt::Microsoft::UI::Xaml::Controls::IWebView2>
    {
        int32_t __stdcall get_CoreWebView2(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::Web::WebView2::Core::CoreWebView2>(this->shim().CoreWebView2());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall EnsureCoreWebView2Async(void** operation) noexcept final try
        {
            clear_abi(operation);
            typename D::abi_guard guard(this->shim());
            *operation = detach_from<winrt::Windows::Foundation::IAsyncAction>(this->shim().EnsureCoreWebView2Async());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall ExecuteScriptAsync(void* javascriptCode, void** operation) noexcept final try
        {
            clear_abi(operation);
            typename D::abi_guard guard(this->shim());
            *operation = detach_from<winrt::Windows::Foundation::IAsyncOperation<hstring>>(this->shim().ExecuteScriptAsync(*reinterpret_cast<hstring const*>(&javascriptCode)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Source(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::Uri>(this->shim().Source());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_Source(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Source(*reinterpret_cast<winrt::Windows::Foundation::Uri const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_CanGoForward(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().CanGoForward());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_CanGoForward(bool value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().CanGoForward(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_CanGoBack(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().CanGoBack());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_CanGoBack(bool value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().CanGoBack(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall Reload() noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Reload();
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall GoForward() noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().GoForward();
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall GoBack() noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().GoBack();
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall NavigateToString(void* htmlContent) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().NavigateToString(*reinterpret_cast<hstring const*>(&htmlContent));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall Close() noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Close();
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall add_NavigationCompleted(void* handler, winrt::event_token* token) noexcept final try
        {
            zero_abi<winrt::event_token>(token);
            typename D::abi_guard guard(this->shim());
            *token = detach_from<winrt::event_token>(this->shim().NavigationCompleted(*reinterpret_cast<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Xaml::Controls::WebView2, winrt::Microsoft::Web::WebView2::Core::CoreWebView2NavigationCompletedEventArgs> const*>(&handler)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall remove_NavigationCompleted(winrt::event_token token) noexcept final
        {
            typename D::abi_guard guard(this->shim());
            this->shim().NavigationCompleted(*reinterpret_cast<winrt::event_token const*>(&token));
            return 0;
        }
        int32_t __stdcall add_WebMessageReceived(void* handler, winrt::event_token* token) noexcept final try
        {
            zero_abi<winrt::event_token>(token);
            typename D::abi_guard guard(this->shim());
            *token = detach_from<winrt::event_token>(this->shim().WebMessageReceived(*reinterpret_cast<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Xaml::Controls::WebView2, winrt::Microsoft::Web::WebView2::Core::CoreWebView2WebMessageReceivedEventArgs> const*>(&handler)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall remove_WebMessageReceived(winrt::event_token token) noexcept final
        {
            typename D::abi_guard guard(this->shim());
            this->shim().WebMessageReceived(*reinterpret_cast<winrt::event_token const*>(&token));
            return 0;
        }
        int32_t __stdcall add_NavigationStarting(void* handler, winrt::event_token* token) noexcept final try
        {
            zero_abi<winrt::event_token>(token);
            typename D::abi_guard guard(this->shim());
            *token = detach_from<winrt::event_token>(this->shim().NavigationStarting(*reinterpret_cast<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Xaml::Controls::WebView2, winrt::Microsoft::Web::WebView2::Core::CoreWebView2NavigationStartingEventArgs> const*>(&handler)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall remove_NavigationStarting(winrt::event_token token) noexcept final
        {
            typename D::abi_guard guard(this->shim());
            this->shim().NavigationStarting(*reinterpret_cast<winrt::event_token const*>(&token));
            return 0;
        }
        int32_t __stdcall add_CoreProcessFailed(void* handler, winrt::event_token* token) noexcept final try
        {
            zero_abi<winrt::event_token>(token);
            typename D::abi_guard guard(this->shim());
            *token = detach_from<winrt::event_token>(this->shim().CoreProcessFailed(*reinterpret_cast<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Xaml::Controls::WebView2, winrt::Microsoft::Web::WebView2::Core::CoreWebView2ProcessFailedEventArgs> const*>(&handler)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall remove_CoreProcessFailed(winrt::event_token token) noexcept final
        {
            typename D::abi_guard guard(this->shim());
            this->shim().CoreProcessFailed(*reinterpret_cast<winrt::event_token const*>(&token));
            return 0;
        }
        int32_t __stdcall add_CoreWebView2Initialized(void* handler, winrt::event_token* token) noexcept final try
        {
            zero_abi<winrt::event_token>(token);
            typename D::abi_guard guard(this->shim());
            *token = detach_from<winrt::event_token>(this->shim().CoreWebView2Initialized(*reinterpret_cast<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Xaml::Controls::WebView2, winrt::Microsoft::UI::Xaml::Controls::CoreWebView2InitializedEventArgs> const*>(&handler)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall remove_CoreWebView2Initialized(winrt::event_token token) noexcept final
        {
            typename D::abi_guard guard(this->shim());
            this->shim().CoreWebView2Initialized(*reinterpret_cast<winrt::event_token const*>(&token));
            return 0;
        }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Controls::IWebView2Factory> : produce_base<D, winrt::Microsoft::UI::Xaml::Controls::IWebView2Factory>
    {
        int32_t __stdcall CreateInstance(void* baseInterface, void** innerInterface, void** value) noexcept final try
        {
            if (innerInterface) *innerInterface = nullptr;
            winrt::Windows::Foundation::IInspectable winrt_impl_innerInterface;
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::UI::Xaml::Controls::WebView2>(this->shim().CreateInstance(*reinterpret_cast<winrt::Windows::Foundation::IInspectable const*>(&baseInterface), winrt_impl_innerInterface));
                if (innerInterface) *innerInterface = detach_abi(winrt_impl_innerInterface);
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Controls::IWebView2Statics> : produce_base<D, winrt::Microsoft::UI::Xaml::Controls::IWebView2Statics>
    {
        int32_t __stdcall get_SourceProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().SourceProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_CanGoForwardProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().CanGoForwardProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_CanGoBackProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().CanGoBackProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Controls::IXamlControlsResources> : produce_base<D, winrt::Microsoft::UI::Xaml::Controls::IXamlControlsResources>
    {
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Controls::IXamlControlsResources3> : produce_base<D, winrt::Microsoft::UI::Xaml::Controls::IXamlControlsResources3>
    {
        int32_t __stdcall get_ControlsResourcesVersion(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::UI::Xaml::Controls::ControlsResourcesVersion>(this->shim().ControlsResourcesVersion());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_ControlsResourcesVersion(int32_t value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().ControlsResourcesVersion(*reinterpret_cast<winrt::Microsoft::UI::Xaml::Controls::ControlsResourcesVersion const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Controls::IXamlControlsResourcesStatics> : produce_base<D, winrt::Microsoft::UI::Xaml::Controls::IXamlControlsResourcesStatics>
    {
        int32_t __stdcall EnsureRevealLights(void* element) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().EnsureRevealLights(*reinterpret_cast<winrt::Windows::UI::Xaml::UIElement const*>(&element));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Controls::IXamlControlsResourcesStatics3> : produce_base<D, winrt::Microsoft::UI::Xaml::Controls::IXamlControlsResourcesStatics3>
    {
        int32_t __stdcall get_ControlsResourcesVersionProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Xaml::DependencyProperty>(this->shim().ControlsResourcesVersionProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
template <typename T, typename D>
struct WINRT_IMPL_EMPTY_BASES produce_dispatch_to_overridable<T, D, winrt::Microsoft::UI::Xaml::Controls::IElementFactoryOverrides>
    : produce_dispatch_to_overridable_base<T, D, winrt::Microsoft::UI::Xaml::Controls::IElementFactoryOverrides>
{
    auto GetElementCore(winrt::Microsoft::UI::Xaml::Controls::ElementFactoryGetArgs const& args)
    {
        if (auto overridable = this->shim_overridable())
        {
            return overridable.GetElementCore(args);
        }

        return this->shim().GetElementCore(args);
    }
    auto RecycleElementCore(winrt::Microsoft::UI::Xaml::Controls::ElementFactoryRecycleArgs const& args)
    {
        if (auto overridable = this->shim_overridable())
        {
            return overridable.RecycleElementCore(args);
        }

        return this->shim().RecycleElementCore(args);
    }
};
template <typename T, typename D>
struct WINRT_IMPL_EMPTY_BASES produce_dispatch_to_overridable<T, D, winrt::Microsoft::UI::Xaml::Controls::ILayoutContextOverrides>
    : produce_dispatch_to_overridable_base<T, D, winrt::Microsoft::UI::Xaml::Controls::ILayoutContextOverrides>
{
    auto LayoutStateCore()
    {
        if (auto overridable = this->shim_overridable())
        {
            return overridable.LayoutStateCore();
        }

        return this->shim().LayoutStateCore();
    }
    auto LayoutStateCore(winrt::Windows::Foundation::IInspectable const& value)
    {
        if (auto overridable = this->shim_overridable())
        {
            return overridable.LayoutStateCore(value);
        }

        return this->shim().LayoutStateCore(value);
    }
};
template <typename T, typename D>
struct WINRT_IMPL_EMPTY_BASES produce_dispatch_to_overridable<T, D, winrt::Microsoft::UI::Xaml::Controls::INonVirtualizingLayoutOverrides>
    : produce_dispatch_to_overridable_base<T, D, winrt::Microsoft::UI::Xaml::Controls::INonVirtualizingLayoutOverrides>
{
    auto InitializeForContextCore(winrt::Microsoft::UI::Xaml::Controls::NonVirtualizingLayoutContext const& context)
    {
        if (auto overridable = this->shim_overridable())
        {
            return overridable.InitializeForContextCore(context);
        }

        return this->shim().InitializeForContextCore(context);
    }
    auto UninitializeForContextCore(winrt::Microsoft::UI::Xaml::Controls::NonVirtualizingLayoutContext const& context)
    {
        if (auto overridable = this->shim_overridable())
        {
            return overridable.UninitializeForContextCore(context);
        }

        return this->shim().UninitializeForContextCore(context);
    }
    auto MeasureOverride(winrt::Microsoft::UI::Xaml::Controls::NonVirtualizingLayoutContext const& context, winrt::Windows::Foundation::Size const& availableSize)
    {
        if (auto overridable = this->shim_overridable())
        {
            return overridable.MeasureOverride(context, availableSize);
        }

        return this->shim().MeasureOverride(context, availableSize);
    }
    auto ArrangeOverride(winrt::Microsoft::UI::Xaml::Controls::NonVirtualizingLayoutContext const& context, winrt::Windows::Foundation::Size const& finalSize)
    {
        if (auto overridable = this->shim_overridable())
        {
            return overridable.ArrangeOverride(context, finalSize);
        }

        return this->shim().ArrangeOverride(context, finalSize);
    }
};
template <typename T, typename D>
struct WINRT_IMPL_EMPTY_BASES produce_dispatch_to_overridable<T, D, winrt::Microsoft::UI::Xaml::Controls::INonVirtualizingLayoutContextOverrides>
    : produce_dispatch_to_overridable_base<T, D, winrt::Microsoft::UI::Xaml::Controls::INonVirtualizingLayoutContextOverrides>
{
    auto ChildrenCore()
    {
        if (auto overridable = this->shim_overridable())
        {
            return overridable.ChildrenCore();
        }

        return this->shim().ChildrenCore();
    }
};
template <typename T, typename D>
struct WINRT_IMPL_EMPTY_BASES produce_dispatch_to_overridable<T, D, winrt::Microsoft::UI::Xaml::Controls::IVirtualizingLayoutOverrides>
    : produce_dispatch_to_overridable_base<T, D, winrt::Microsoft::UI::Xaml::Controls::IVirtualizingLayoutOverrides>
{
    auto InitializeForContextCore(winrt::Microsoft::UI::Xaml::Controls::VirtualizingLayoutContext const& context)
    {
        if (auto overridable = this->shim_overridable())
        {
            return overridable.InitializeForContextCore(context);
        }

        return this->shim().InitializeForContextCore(context);
    }
    auto UninitializeForContextCore(winrt::Microsoft::UI::Xaml::Controls::VirtualizingLayoutContext const& context)
    {
        if (auto overridable = this->shim_overridable())
        {
            return overridable.UninitializeForContextCore(context);
        }

        return this->shim().UninitializeForContextCore(context);
    }
    auto MeasureOverride(winrt::Microsoft::UI::Xaml::Controls::VirtualizingLayoutContext const& context, winrt::Windows::Foundation::Size const& availableSize)
    {
        if (auto overridable = this->shim_overridable())
        {
            return overridable.MeasureOverride(context, availableSize);
        }

        return this->shim().MeasureOverride(context, availableSize);
    }
    auto ArrangeOverride(winrt::Microsoft::UI::Xaml::Controls::VirtualizingLayoutContext const& context, winrt::Windows::Foundation::Size const& finalSize)
    {
        if (auto overridable = this->shim_overridable())
        {
            return overridable.ArrangeOverride(context, finalSize);
        }

        return this->shim().ArrangeOverride(context, finalSize);
    }
    auto OnItemsChangedCore(winrt::Microsoft::UI::Xaml::Controls::VirtualizingLayoutContext const& context, winrt::Windows::Foundation::IInspectable const& source, winrt::Windows::UI::Xaml::Interop::NotifyCollectionChangedEventArgs const& args)
    {
        if (auto overridable = this->shim_overridable())
        {
            return overridable.OnItemsChangedCore(context, source, args);
        }

        return this->shim().OnItemsChangedCore(context, source, args);
    }
};
template <typename T, typename D>
struct WINRT_IMPL_EMPTY_BASES produce_dispatch_to_overridable<T, D, winrt::Microsoft::UI::Xaml::Controls::IVirtualizingLayoutContextOverrides>
    : produce_dispatch_to_overridable_base<T, D, winrt::Microsoft::UI::Xaml::Controls::IVirtualizingLayoutContextOverrides>
{
    auto ItemCountCore()
    {
        if (auto overridable = this->shim_overridable())
        {
            return overridable.ItemCountCore();
        }

        return this->shim().ItemCountCore();
    }
    auto GetItemAtCore(int32_t index)
    {
        if (auto overridable = this->shim_overridable())
        {
            return overridable.GetItemAtCore(index);
        }

        return this->shim().GetItemAtCore(index);
    }
    auto RealizationRectCore()
    {
        if (auto overridable = this->shim_overridable())
        {
            return overridable.RealizationRectCore();
        }

        return this->shim().RealizationRectCore();
    }
    auto GetOrCreateElementAtCore(int32_t index, winrt::Microsoft::UI::Xaml::Controls::ElementRealizationOptions const& options)
    {
        if (auto overridable = this->shim_overridable())
        {
            return overridable.GetOrCreateElementAtCore(index, options);
        }

        return this->shim().GetOrCreateElementAtCore(index, options);
    }
    auto RecycleElementCore(winrt::Windows::UI::Xaml::UIElement const& element)
    {
        if (auto overridable = this->shim_overridable())
        {
            return overridable.RecycleElementCore(element);
        }

        return this->shim().RecycleElementCore(element);
    }
    auto RecommendedAnchorIndexCore()
    {
        if (auto overridable = this->shim_overridable())
        {
            return overridable.RecommendedAnchorIndexCore();
        }

        return this->shim().RecommendedAnchorIndexCore();
    }
    auto LayoutOriginCore()
    {
        if (auto overridable = this->shim_overridable())
        {
            return overridable.LayoutOriginCore();
        }

        return this->shim().LayoutOriginCore();
    }
    auto LayoutOriginCore(winrt::Windows::Foundation::Point const& value)
    {
        if (auto overridable = this->shim_overridable())
        {
            return overridable.LayoutOriginCore(value);
        }

        return this->shim().LayoutOriginCore(value);
    }
};
}
WINRT_EXPORT namespace winrt::Microsoft::UI::Xaml::Controls
{
    constexpr auto operator|(ElementRealizationOptions const left, ElementRealizationOptions const right) noexcept
    {
        return static_cast<ElementRealizationOptions>(impl::to_underlying_type(left) | impl::to_underlying_type(right));
    }
    constexpr auto operator|=(ElementRealizationOptions& left, ElementRealizationOptions const right) noexcept
    {
        left = left | right;
        return left;
    }
    constexpr auto operator&(ElementRealizationOptions const left, ElementRealizationOptions const right) noexcept
    {
        return static_cast<ElementRealizationOptions>(impl::to_underlying_type(left) & impl::to_underlying_type(right));
    }
    constexpr auto operator&=(ElementRealizationOptions& left, ElementRealizationOptions const right) noexcept
    {
        left = left & right;
        return left;
    }
    constexpr auto operator~(ElementRealizationOptions const value) noexcept
    {
        return static_cast<ElementRealizationOptions>(~impl::to_underlying_type(value));
    }
    constexpr auto operator^(ElementRealizationOptions const left, ElementRealizationOptions const right) noexcept
    {
        return static_cast<ElementRealizationOptions>(impl::to_underlying_type(left) ^ impl::to_underlying_type(right));
    }
    constexpr auto operator^=(ElementRealizationOptions& left, ElementRealizationOptions const right) noexcept
    {
        left = left ^ right;
        return left;
    }
    inline AnimatedIcon::AnimatedIcon()
    {
        winrt::Windows::Foundation::IInspectable baseInterface, innerInterface;
        *this = impl::call_factory<AnimatedIcon, IAnimatedIconFactory>([&](IAnimatedIconFactory const& f) { return f.CreateInstance(baseInterface, innerInterface); });
    }
    inline auto AnimatedIcon::StateProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(IAnimatedIconStatics const&), AnimatedIcon, IAnimatedIconStatics>([](IAnimatedIconStatics const& f) { return f.StateProperty(); });
    }
    inline auto AnimatedIcon::SetState(winrt::Windows::UI::Xaml::DependencyObject const& object, param::hstring const& value)
    {
        impl::call_factory<AnimatedIcon, IAnimatedIconStatics>([&](IAnimatedIconStatics const& f) { return f.SetState(object, value); });
    }
    inline auto AnimatedIcon::GetState(winrt::Windows::UI::Xaml::DependencyObject const& object)
    {
        return impl::call_factory<AnimatedIcon, IAnimatedIconStatics>([&](IAnimatedIconStatics const& f) { return f.GetState(object); });
    }
    inline auto AnimatedIcon::SourceProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(IAnimatedIconStatics const&), AnimatedIcon, IAnimatedIconStatics>([](IAnimatedIconStatics const& f) { return f.SourceProperty(); });
    }
    inline auto AnimatedIcon::FallbackIconSourceProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(IAnimatedIconStatics const&), AnimatedIcon, IAnimatedIconStatics>([](IAnimatedIconStatics const& f) { return f.FallbackIconSourceProperty(); });
    }
    inline auto AnimatedIcon::MirroredWhenRightToLeftProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(IAnimatedIconStatics const&), AnimatedIcon, IAnimatedIconStatics>([](IAnimatedIconStatics const& f) { return f.MirroredWhenRightToLeftProperty(); });
    }
    inline AnimatedIconSource::AnimatedIconSource()
    {
        winrt::Windows::Foundation::IInspectable baseInterface, innerInterface;
        *this = impl::call_factory<AnimatedIconSource, IAnimatedIconSourceFactory>([&](IAnimatedIconSourceFactory const& f) { return f.CreateInstance(baseInterface, innerInterface); });
    }
    inline auto AnimatedIconSource::SourceProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(IAnimatedIconSourceStatics const&), AnimatedIconSource, IAnimatedIconSourceStatics>([](IAnimatedIconSourceStatics const& f) { return f.SourceProperty(); });
    }
    inline auto AnimatedIconSource::FallbackIconSourceProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(IAnimatedIconSourceStatics const&), AnimatedIconSource, IAnimatedIconSourceStatics>([](IAnimatedIconSourceStatics const& f) { return f.FallbackIconSourceProperty(); });
    }
    inline auto AnimatedIconSource::MirroredWhenRightToLeftProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(IAnimatedIconSourceStatics const&), AnimatedIconSource, IAnimatedIconSourceStatics>([](IAnimatedIconSourceStatics const& f) { return f.MirroredWhenRightToLeftProperty(); });
    }
    inline AnimatedVisualPlayer::AnimatedVisualPlayer()
    {
        winrt::Windows::Foundation::IInspectable baseInterface, innerInterface;
        *this = impl::call_factory<AnimatedVisualPlayer, IAnimatedVisualPlayerFactory>([&](IAnimatedVisualPlayerFactory const& f) { return f.CreateInstance(baseInterface, innerInterface); });
    }
    inline auto AnimatedVisualPlayer::AutoPlayProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(IAnimatedVisualPlayerStatics const&), AnimatedVisualPlayer, IAnimatedVisualPlayerStatics>([](IAnimatedVisualPlayerStatics const& f) { return f.AutoPlayProperty(); });
    }
    inline auto AnimatedVisualPlayer::DiagnosticsProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(IAnimatedVisualPlayerStatics const&), AnimatedVisualPlayer, IAnimatedVisualPlayerStatics>([](IAnimatedVisualPlayerStatics const& f) { return f.DiagnosticsProperty(); });
    }
    inline auto AnimatedVisualPlayer::DurationProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(IAnimatedVisualPlayerStatics const&), AnimatedVisualPlayer, IAnimatedVisualPlayerStatics>([](IAnimatedVisualPlayerStatics const& f) { return f.DurationProperty(); });
    }
    inline auto AnimatedVisualPlayer::FallbackContentProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(IAnimatedVisualPlayerStatics const&), AnimatedVisualPlayer, IAnimatedVisualPlayerStatics>([](IAnimatedVisualPlayerStatics const& f) { return f.FallbackContentProperty(); });
    }
    inline auto AnimatedVisualPlayer::IsAnimatedVisualLoadedProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(IAnimatedVisualPlayerStatics const&), AnimatedVisualPlayer, IAnimatedVisualPlayerStatics>([](IAnimatedVisualPlayerStatics const& f) { return f.IsAnimatedVisualLoadedProperty(); });
    }
    inline auto AnimatedVisualPlayer::IsPlayingProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(IAnimatedVisualPlayerStatics const&), AnimatedVisualPlayer, IAnimatedVisualPlayerStatics>([](IAnimatedVisualPlayerStatics const& f) { return f.IsPlayingProperty(); });
    }
    inline auto AnimatedVisualPlayer::PlaybackRateProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(IAnimatedVisualPlayerStatics const&), AnimatedVisualPlayer, IAnimatedVisualPlayerStatics>([](IAnimatedVisualPlayerStatics const& f) { return f.PlaybackRateProperty(); });
    }
    inline auto AnimatedVisualPlayer::SourceProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(IAnimatedVisualPlayerStatics const&), AnimatedVisualPlayer, IAnimatedVisualPlayerStatics>([](IAnimatedVisualPlayerStatics const& f) { return f.SourceProperty(); });
    }
    inline auto AnimatedVisualPlayer::StretchProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(IAnimatedVisualPlayerStatics const&), AnimatedVisualPlayer, IAnimatedVisualPlayerStatics>([](IAnimatedVisualPlayerStatics const& f) { return f.StretchProperty(); });
    }
    inline auto AnimatedVisualPlayer::AnimationOptimizationProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(IAnimatedVisualPlayerStatics2 const&), AnimatedVisualPlayer, IAnimatedVisualPlayerStatics2>([](IAnimatedVisualPlayerStatics2 const& f) { return f.AnimationOptimizationProperty(); });
    }
    inline auto BackdropMaterial::ApplyToRootOrPageBackgroundProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(IBackdropMaterialStatics const&), BackdropMaterial, IBackdropMaterialStatics>([](IBackdropMaterialStatics const& f) { return f.ApplyToRootOrPageBackgroundProperty(); });
    }
    inline auto BackdropMaterial::SetApplyToRootOrPageBackground(winrt::Windows::UI::Xaml::Controls::Control const& element, bool value)
    {
        impl::call_factory<BackdropMaterial, IBackdropMaterialStatics>([&](IBackdropMaterialStatics const& f) { return f.SetApplyToRootOrPageBackground(element, value); });
    }
    inline auto BackdropMaterial::GetApplyToRootOrPageBackground(winrt::Windows::UI::Xaml::Controls::Control const& element)
    {
        return impl::call_factory<BackdropMaterial, IBackdropMaterialStatics>([&](IBackdropMaterialStatics const& f) { return f.GetApplyToRootOrPageBackground(element); });
    }
    inline BitmapIconSource::BitmapIconSource()
    {
        winrt::Windows::Foundation::IInspectable baseInterface, innerInterface;
        *this = impl::call_factory<BitmapIconSource, IBitmapIconSourceFactory>([&](IBitmapIconSourceFactory const& f) { return f.CreateInstance(baseInterface, innerInterface); });
    }
    inline auto BitmapIconSource::UriSourceProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(IBitmapIconSourceStatics const&), BitmapIconSource, IBitmapIconSourceStatics>([](IBitmapIconSourceStatics const& f) { return f.UriSourceProperty(); });
    }
    inline auto BitmapIconSource::ShowAsMonochromeProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(IBitmapIconSourceStatics const&), BitmapIconSource, IBitmapIconSourceStatics>([](IBitmapIconSourceStatics const& f) { return f.ShowAsMonochromeProperty(); });
    }
    inline BreadcrumbBar::BreadcrumbBar()
    {
        winrt::Windows::Foundation::IInspectable baseInterface, innerInterface;
        *this = impl::call_factory<BreadcrumbBar, IBreadcrumbBarFactory>([&](IBreadcrumbBarFactory const& f) { return f.CreateInstance(baseInterface, innerInterface); });
    }
    inline auto BreadcrumbBar::ItemsSourceProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(IBreadcrumbBarStatics const&), BreadcrumbBar, IBreadcrumbBarStatics>([](IBreadcrumbBarStatics const& f) { return f.ItemsSourceProperty(); });
    }
    inline auto BreadcrumbBar::ItemTemplateProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(IBreadcrumbBarStatics const&), BreadcrumbBar, IBreadcrumbBarStatics>([](IBreadcrumbBarStatics const& f) { return f.ItemTemplateProperty(); });
    }
    inline BreadcrumbBarItem::BreadcrumbBarItem()
    {
        winrt::Windows::Foundation::IInspectable baseInterface, innerInterface;
        *this = impl::call_factory<BreadcrumbBarItem, IBreadcrumbBarItemFactory>([&](IBreadcrumbBarItemFactory const& f) { return f.CreateInstance(baseInterface, innerInterface); });
    }
    inline ColorPicker::ColorPicker()
    {
        winrt::Windows::Foundation::IInspectable baseInterface, innerInterface;
        *this = impl::call_factory<ColorPicker, IColorPickerFactory>([&](IColorPickerFactory const& f) { return f.CreateInstance(baseInterface, innerInterface); });
    }
    inline auto ColorPicker::ColorProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(IColorPickerStatics const&), ColorPicker, IColorPickerStatics>([](IColorPickerStatics const& f) { return f.ColorProperty(); });
    }
    inline auto ColorPicker::PreviousColorProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(IColorPickerStatics const&), ColorPicker, IColorPickerStatics>([](IColorPickerStatics const& f) { return f.PreviousColorProperty(); });
    }
    inline auto ColorPicker::IsAlphaEnabledProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(IColorPickerStatics const&), ColorPicker, IColorPickerStatics>([](IColorPickerStatics const& f) { return f.IsAlphaEnabledProperty(); });
    }
    inline auto ColorPicker::IsColorSpectrumVisibleProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(IColorPickerStatics const&), ColorPicker, IColorPickerStatics>([](IColorPickerStatics const& f) { return f.IsColorSpectrumVisibleProperty(); });
    }
    inline auto ColorPicker::IsColorPreviewVisibleProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(IColorPickerStatics const&), ColorPicker, IColorPickerStatics>([](IColorPickerStatics const& f) { return f.IsColorPreviewVisibleProperty(); });
    }
    inline auto ColorPicker::IsColorSliderVisibleProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(IColorPickerStatics const&), ColorPicker, IColorPickerStatics>([](IColorPickerStatics const& f) { return f.IsColorSliderVisibleProperty(); });
    }
    inline auto ColorPicker::IsAlphaSliderVisibleProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(IColorPickerStatics const&), ColorPicker, IColorPickerStatics>([](IColorPickerStatics const& f) { return f.IsAlphaSliderVisibleProperty(); });
    }
    inline auto ColorPicker::IsMoreButtonVisibleProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(IColorPickerStatics const&), ColorPicker, IColorPickerStatics>([](IColorPickerStatics const& f) { return f.IsMoreButtonVisibleProperty(); });
    }
    inline auto ColorPicker::IsColorChannelTextInputVisibleProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(IColorPickerStatics const&), ColorPicker, IColorPickerStatics>([](IColorPickerStatics const& f) { return f.IsColorChannelTextInputVisibleProperty(); });
    }
    inline auto ColorPicker::IsAlphaTextInputVisibleProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(IColorPickerStatics const&), ColorPicker, IColorPickerStatics>([](IColorPickerStatics const& f) { return f.IsAlphaTextInputVisibleProperty(); });
    }
    inline auto ColorPicker::IsHexInputVisibleProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(IColorPickerStatics const&), ColorPicker, IColorPickerStatics>([](IColorPickerStatics const& f) { return f.IsHexInputVisibleProperty(); });
    }
    inline auto ColorPicker::MinHueProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(IColorPickerStatics const&), ColorPicker, IColorPickerStatics>([](IColorPickerStatics const& f) { return f.MinHueProperty(); });
    }
    inline auto ColorPicker::MaxHueProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(IColorPickerStatics const&), ColorPicker, IColorPickerStatics>([](IColorPickerStatics const& f) { return f.MaxHueProperty(); });
    }
    inline auto ColorPicker::MinSaturationProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(IColorPickerStatics const&), ColorPicker, IColorPickerStatics>([](IColorPickerStatics const& f) { return f.MinSaturationProperty(); });
    }
    inline auto ColorPicker::MaxSaturationProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(IColorPickerStatics const&), ColorPicker, IColorPickerStatics>([](IColorPickerStatics const& f) { return f.MaxSaturationProperty(); });
    }
    inline auto ColorPicker::MinValueProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(IColorPickerStatics const&), ColorPicker, IColorPickerStatics>([](IColorPickerStatics const& f) { return f.MinValueProperty(); });
    }
    inline auto ColorPicker::MaxValueProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(IColorPickerStatics const&), ColorPicker, IColorPickerStatics>([](IColorPickerStatics const& f) { return f.MaxValueProperty(); });
    }
    inline auto ColorPicker::ColorSpectrumShapeProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(IColorPickerStatics const&), ColorPicker, IColorPickerStatics>([](IColorPickerStatics const& f) { return f.ColorSpectrumShapeProperty(); });
    }
    inline auto ColorPicker::ColorSpectrumComponentsProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(IColorPickerStatics const&), ColorPicker, IColorPickerStatics>([](IColorPickerStatics const& f) { return f.ColorSpectrumComponentsProperty(); });
    }
    inline auto ColorPicker::OrientationProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(IColorPickerStatics2 const&), ColorPicker, IColorPickerStatics2>([](IColorPickerStatics2 const& f) { return f.OrientationProperty(); });
    }
    inline CommandBarFlyout::CommandBarFlyout()
    {
        winrt::Windows::Foundation::IInspectable baseInterface, innerInterface;
        *this = impl::call_factory<CommandBarFlyout, ICommandBarFlyoutFactory>([&](ICommandBarFlyoutFactory const& f) { return f.CreateInstance(baseInterface, innerInterface); });
    }
    inline DropDownButton::DropDownButton()
    {
        winrt::Windows::Foundation::IInspectable baseInterface, innerInterface;
        *this = impl::call_factory<DropDownButton, IDropDownButtonFactory>([&](IDropDownButtonFactory const& f) { return f.CreateInstance(baseInterface, innerInterface); });
    }
    inline ElementFactory::ElementFactory()
    {
        winrt::Windows::Foundation::IInspectable baseInterface, innerInterface;
        *this = impl::call_factory<ElementFactory, IElementFactoryFactory>([&](IElementFactoryFactory const& f) { return f.CreateInstance(baseInterface, innerInterface); });
    }
    inline ElementFactoryGetArgs::ElementFactoryGetArgs() :
        ElementFactoryGetArgs(impl::call_factory_cast<ElementFactoryGetArgs(*)(winrt::Windows::Foundation::IActivationFactory const&), ElementFactoryGetArgs>([](winrt::Windows::Foundation::IActivationFactory const& f) { return f.template ActivateInstance<ElementFactoryGetArgs>(); }))
    {
    }
    inline ElementFactoryRecycleArgs::ElementFactoryRecycleArgs() :
        ElementFactoryRecycleArgs(impl::call_factory_cast<ElementFactoryRecycleArgs(*)(winrt::Windows::Foundation::IActivationFactory const&), ElementFactoryRecycleArgs>([](winrt::Windows::Foundation::IActivationFactory const& f) { return f.template ActivateInstance<ElementFactoryRecycleArgs>(); }))
    {
    }
    inline Expander::Expander()
    {
        winrt::Windows::Foundation::IInspectable baseInterface, innerInterface;
        *this = impl::call_factory<Expander, IExpanderFactory>([&](IExpanderFactory const& f) { return f.CreateInstance(baseInterface, innerInterface); });
    }
    inline auto Expander::HeaderProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(IExpanderStatics const&), Expander, IExpanderStatics>([](IExpanderStatics const& f) { return f.HeaderProperty(); });
    }
    inline auto Expander::HeaderTemplateProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(IExpanderStatics const&), Expander, IExpanderStatics>([](IExpanderStatics const& f) { return f.HeaderTemplateProperty(); });
    }
    inline auto Expander::HeaderTemplateSelectorProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(IExpanderStatics const&), Expander, IExpanderStatics>([](IExpanderStatics const& f) { return f.HeaderTemplateSelectorProperty(); });
    }
    inline auto Expander::IsExpandedProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(IExpanderStatics const&), Expander, IExpanderStatics>([](IExpanderStatics const& f) { return f.IsExpandedProperty(); });
    }
    inline auto Expander::ExpandDirectionProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(IExpanderStatics const&), Expander, IExpanderStatics>([](IExpanderStatics const& f) { return f.ExpandDirectionProperty(); });
    }
    inline FontIconSource::FontIconSource()
    {
        winrt::Windows::Foundation::IInspectable baseInterface, innerInterface;
        *this = impl::call_factory<FontIconSource, IFontIconSourceFactory>([&](IFontIconSourceFactory const& f) { return f.CreateInstance(baseInterface, innerInterface); });
    }
    inline auto FontIconSource::GlyphProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(IFontIconSourceStatics const&), FontIconSource, IFontIconSourceStatics>([](IFontIconSourceStatics const& f) { return f.GlyphProperty(); });
    }
    inline auto FontIconSource::FontSizeProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(IFontIconSourceStatics const&), FontIconSource, IFontIconSourceStatics>([](IFontIconSourceStatics const& f) { return f.FontSizeProperty(); });
    }
    inline auto FontIconSource::FontFamilyProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(IFontIconSourceStatics const&), FontIconSource, IFontIconSourceStatics>([](IFontIconSourceStatics const& f) { return f.FontFamilyProperty(); });
    }
    inline auto FontIconSource::FontWeightProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(IFontIconSourceStatics const&), FontIconSource, IFontIconSourceStatics>([](IFontIconSourceStatics const& f) { return f.FontWeightProperty(); });
    }
    inline auto FontIconSource::FontStyleProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(IFontIconSourceStatics const&), FontIconSource, IFontIconSourceStatics>([](IFontIconSourceStatics const& f) { return f.FontStyleProperty(); });
    }
    inline auto FontIconSource::IsTextScaleFactorEnabledProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(IFontIconSourceStatics const&), FontIconSource, IFontIconSourceStatics>([](IFontIconSourceStatics const& f) { return f.IsTextScaleFactorEnabledProperty(); });
    }
    inline auto FontIconSource::MirroredWhenRightToLeftProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(IFontIconSourceStatics const&), FontIconSource, IFontIconSourceStatics>([](IFontIconSourceStatics const& f) { return f.MirroredWhenRightToLeftProperty(); });
    }
    inline auto IconSource::ForegroundProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(IIconSourceStatics const&), IconSource, IIconSourceStatics>([](IIconSourceStatics const& f) { return f.ForegroundProperty(); });
    }
    inline ImageIcon::ImageIcon()
    {
        winrt::Windows::Foundation::IInspectable baseInterface, innerInterface;
        *this = impl::call_factory<ImageIcon, IImageIconFactory>([&](IImageIconFactory const& f) { return f.CreateInstance(baseInterface, innerInterface); });
    }
    inline auto ImageIcon::SourceProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(IImageIconStatics const&), ImageIcon, IImageIconStatics>([](IImageIconStatics const& f) { return f.SourceProperty(); });
    }
    inline ImageIconSource::ImageIconSource()
    {
        winrt::Windows::Foundation::IInspectable baseInterface, innerInterface;
        *this = impl::call_factory<ImageIconSource, IImageIconSourceFactory>([&](IImageIconSourceFactory const& f) { return f.CreateInstance(baseInterface, innerInterface); });
    }
    inline auto ImageIconSource::ImageSourceProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(IImageIconSourceStatics const&), ImageIconSource, IImageIconSourceStatics>([](IImageIconSourceStatics const& f) { return f.ImageSourceProperty(); });
    }
    inline InfoBadge::InfoBadge()
    {
        winrt::Windows::Foundation::IInspectable baseInterface, innerInterface;
        *this = impl::call_factory<InfoBadge, IInfoBadgeFactory>([&](IInfoBadgeFactory const& f) { return f.CreateInstance(baseInterface, innerInterface); });
    }
    inline auto InfoBadge::ValueProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(IInfoBadgeStatics const&), InfoBadge, IInfoBadgeStatics>([](IInfoBadgeStatics const& f) { return f.ValueProperty(); });
    }
    inline auto InfoBadge::IconSourceProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(IInfoBadgeStatics const&), InfoBadge, IInfoBadgeStatics>([](IInfoBadgeStatics const& f) { return f.IconSourceProperty(); });
    }
    inline auto InfoBadge::TemplateSettingsProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(IInfoBadgeStatics const&), InfoBadge, IInfoBadgeStatics>([](IInfoBadgeStatics const& f) { return f.TemplateSettingsProperty(); });
    }
    inline InfoBadgeTemplateSettings::InfoBadgeTemplateSettings()
    {
        winrt::Windows::Foundation::IInspectable baseInterface, innerInterface;
        *this = impl::call_factory<InfoBadgeTemplateSettings, IInfoBadgeTemplateSettingsFactory>([&](IInfoBadgeTemplateSettingsFactory const& f) { return f.CreateInstance(baseInterface, innerInterface); });
    }
    inline auto InfoBadgeTemplateSettings::InfoBadgeCornerRadiusProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(IInfoBadgeTemplateSettingsStatics const&), InfoBadgeTemplateSettings, IInfoBadgeTemplateSettingsStatics>([](IInfoBadgeTemplateSettingsStatics const& f) { return f.InfoBadgeCornerRadiusProperty(); });
    }
    inline auto InfoBadgeTemplateSettings::IconElementProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(IInfoBadgeTemplateSettingsStatics const&), InfoBadgeTemplateSettings, IInfoBadgeTemplateSettingsStatics>([](IInfoBadgeTemplateSettingsStatics const& f) { return f.IconElementProperty(); });
    }
    inline InfoBar::InfoBar()
    {
        winrt::Windows::Foundation::IInspectable baseInterface, innerInterface;
        *this = impl::call_factory<InfoBar, IInfoBarFactory>([&](IInfoBarFactory const& f) { return f.CreateInstance(baseInterface, innerInterface); });
    }
    inline auto InfoBar::IsOpenProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(IInfoBarStatics const&), InfoBar, IInfoBarStatics>([](IInfoBarStatics const& f) { return f.IsOpenProperty(); });
    }
    inline auto InfoBar::TitleProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(IInfoBarStatics const&), InfoBar, IInfoBarStatics>([](IInfoBarStatics const& f) { return f.TitleProperty(); });
    }
    inline auto InfoBar::MessageProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(IInfoBarStatics const&), InfoBar, IInfoBarStatics>([](IInfoBarStatics const& f) { return f.MessageProperty(); });
    }
    inline auto InfoBar::SeverityProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(IInfoBarStatics const&), InfoBar, IInfoBarStatics>([](IInfoBarStatics const& f) { return f.SeverityProperty(); });
    }
    inline auto InfoBar::IconSourceProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(IInfoBarStatics const&), InfoBar, IInfoBarStatics>([](IInfoBarStatics const& f) { return f.IconSourceProperty(); });
    }
    inline auto InfoBar::IsIconVisibleProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(IInfoBarStatics const&), InfoBar, IInfoBarStatics>([](IInfoBarStatics const& f) { return f.IsIconVisibleProperty(); });
    }
    inline auto InfoBar::IsClosableProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(IInfoBarStatics const&), InfoBar, IInfoBarStatics>([](IInfoBarStatics const& f) { return f.IsClosableProperty(); });
    }
    inline auto InfoBar::CloseButtonStyleProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(IInfoBarStatics const&), InfoBar, IInfoBarStatics>([](IInfoBarStatics const& f) { return f.CloseButtonStyleProperty(); });
    }
    inline auto InfoBar::CloseButtonCommandProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(IInfoBarStatics const&), InfoBar, IInfoBarStatics>([](IInfoBarStatics const& f) { return f.CloseButtonCommandProperty(); });
    }
    inline auto InfoBar::CloseButtonCommandParameterProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(IInfoBarStatics const&), InfoBar, IInfoBarStatics>([](IInfoBarStatics const& f) { return f.CloseButtonCommandParameterProperty(); });
    }
    inline auto InfoBar::ActionButtonProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(IInfoBarStatics const&), InfoBar, IInfoBarStatics>([](IInfoBarStatics const& f) { return f.ActionButtonProperty(); });
    }
    inline auto InfoBar::ContentProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(IInfoBarStatics const&), InfoBar, IInfoBarStatics>([](IInfoBarStatics const& f) { return f.ContentProperty(); });
    }
    inline auto InfoBar::ContentTemplateProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(IInfoBarStatics const&), InfoBar, IInfoBarStatics>([](IInfoBarStatics const& f) { return f.ContentTemplateProperty(); });
    }
    inline auto InfoBar::TemplateSettingsProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(IInfoBarStatics const&), InfoBar, IInfoBarStatics>([](IInfoBarStatics const& f) { return f.TemplateSettingsProperty(); });
    }
    inline InfoBarTemplateSettings::InfoBarTemplateSettings()
    {
        winrt::Windows::Foundation::IInspectable baseInterface, innerInterface;
        *this = impl::call_factory<InfoBarTemplateSettings, IInfoBarTemplateSettingsFactory>([&](IInfoBarTemplateSettingsFactory const& f) { return f.CreateInstance(baseInterface, innerInterface); });
    }
    inline auto InfoBarTemplateSettings::IconElementProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(IInfoBarTemplateSettingsStatics const&), InfoBarTemplateSettings, IInfoBarTemplateSettingsStatics>([](IInfoBarTemplateSettingsStatics const& f) { return f.IconElementProperty(); });
    }
    inline ItemsRepeater::ItemsRepeater()
    {
        winrt::Windows::Foundation::IInspectable baseInterface, innerInterface;
        *this = impl::call_factory<ItemsRepeater, IItemsRepeaterFactory>([&](IItemsRepeaterFactory const& f) { return f.CreateInstance(baseInterface, innerInterface); });
    }
    inline auto ItemsRepeater::ItemsSourceProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(IItemsRepeaterStatics const&), ItemsRepeater, IItemsRepeaterStatics>([](IItemsRepeaterStatics const& f) { return f.ItemsSourceProperty(); });
    }
    inline auto ItemsRepeater::ItemTemplateProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(IItemsRepeaterStatics const&), ItemsRepeater, IItemsRepeaterStatics>([](IItemsRepeaterStatics const& f) { return f.ItemTemplateProperty(); });
    }
    inline auto ItemsRepeater::LayoutProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(IItemsRepeaterStatics const&), ItemsRepeater, IItemsRepeaterStatics>([](IItemsRepeaterStatics const& f) { return f.LayoutProperty(); });
    }
    inline auto ItemsRepeater::HorizontalCacheLengthProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(IItemsRepeaterStatics const&), ItemsRepeater, IItemsRepeaterStatics>([](IItemsRepeaterStatics const& f) { return f.HorizontalCacheLengthProperty(); });
    }
    inline auto ItemsRepeater::VerticalCacheLengthProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(IItemsRepeaterStatics const&), ItemsRepeater, IItemsRepeaterStatics>([](IItemsRepeaterStatics const& f) { return f.VerticalCacheLengthProperty(); });
    }
    inline auto ItemsRepeater::BackgroundProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(IItemsRepeaterStatics const&), ItemsRepeater, IItemsRepeaterStatics>([](IItemsRepeaterStatics const& f) { return f.BackgroundProperty(); });
    }
    inline ItemsRepeaterScrollHost::ItemsRepeaterScrollHost() :
        ItemsRepeaterScrollHost(impl::call_factory_cast<ItemsRepeaterScrollHost(*)(winrt::Windows::Foundation::IActivationFactory const&), ItemsRepeaterScrollHost>([](winrt::Windows::Foundation::IActivationFactory const& f) { return f.template ActivateInstance<ItemsRepeaterScrollHost>(); }))
    {
    }
    inline ItemsSourceView::ItemsSourceView(winrt::Windows::Foundation::IInspectable const& source)
    {
        winrt::Windows::Foundation::IInspectable baseInterface, innerInterface;
        *this = impl::call_factory<ItemsSourceView, IItemsSourceViewFactory>([&](IItemsSourceViewFactory const& f) { return f.CreateInstance(source, baseInterface, innerInterface); });
    }
    inline MenuBar::MenuBar()
    {
        winrt::Windows::Foundation::IInspectable baseInterface, innerInterface;
        *this = impl::call_factory<MenuBar, IMenuBarFactory>([&](IMenuBarFactory const& f) { return f.CreateInstance(baseInterface, innerInterface); });
    }
    inline auto MenuBar::ItemsProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(IMenuBarStatics const&), MenuBar, IMenuBarStatics>([](IMenuBarStatics const& f) { return f.ItemsProperty(); });
    }
    inline MenuBarItem::MenuBarItem()
    {
        winrt::Windows::Foundation::IInspectable baseInterface, innerInterface;
        *this = impl::call_factory<MenuBarItem, IMenuBarItemFactory>([&](IMenuBarItemFactory const& f) { return f.CreateInstance(baseInterface, innerInterface); });
    }
    inline auto MenuBarItem::TitleProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(IMenuBarItemStatics const&), MenuBarItem, IMenuBarItemStatics>([](IMenuBarItemStatics const& f) { return f.TitleProperty(); });
    }
    inline auto MenuBarItem::ItemsProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(IMenuBarItemStatics const&), MenuBarItem, IMenuBarItemStatics>([](IMenuBarItemStatics const& f) { return f.ItemsProperty(); });
    }
    inline MenuBarItemFlyout::MenuBarItemFlyout()
    {
        winrt::Windows::Foundation::IInspectable baseInterface, innerInterface;
        *this = impl::call_factory<MenuBarItemFlyout, IMenuBarItemFlyoutFactory>([&](IMenuBarItemFlyoutFactory const& f) { return f.CreateInstance(baseInterface, innerInterface); });
    }
    inline NavigationView::NavigationView()
    {
        winrt::Windows::Foundation::IInspectable baseInterface, innerInterface;
        *this = impl::call_factory<NavigationView, INavigationViewFactory>([&](INavigationViewFactory const& f) { return f.CreateInstance(baseInterface, innerInterface); });
    }
    inline auto NavigationView::IsPaneOpenProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(INavigationViewStatics const&), NavigationView, INavigationViewStatics>([](INavigationViewStatics const& f) { return f.IsPaneOpenProperty(); });
    }
    inline auto NavigationView::CompactModeThresholdWidthProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(INavigationViewStatics const&), NavigationView, INavigationViewStatics>([](INavigationViewStatics const& f) { return f.CompactModeThresholdWidthProperty(); });
    }
    inline auto NavigationView::ExpandedModeThresholdWidthProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(INavigationViewStatics const&), NavigationView, INavigationViewStatics>([](INavigationViewStatics const& f) { return f.ExpandedModeThresholdWidthProperty(); });
    }
    inline auto NavigationView::FooterMenuItemsProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(INavigationViewStatics const&), NavigationView, INavigationViewStatics>([](INavigationViewStatics const& f) { return f.FooterMenuItemsProperty(); });
    }
    inline auto NavigationView::FooterMenuItemsSourceProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(INavigationViewStatics const&), NavigationView, INavigationViewStatics>([](INavigationViewStatics const& f) { return f.FooterMenuItemsSourceProperty(); });
    }
    inline auto NavigationView::PaneFooterProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(INavigationViewStatics const&), NavigationView, INavigationViewStatics>([](INavigationViewStatics const& f) { return f.PaneFooterProperty(); });
    }
    inline auto NavigationView::HeaderProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(INavigationViewStatics const&), NavigationView, INavigationViewStatics>([](INavigationViewStatics const& f) { return f.HeaderProperty(); });
    }
    inline auto NavigationView::HeaderTemplateProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(INavigationViewStatics const&), NavigationView, INavigationViewStatics>([](INavigationViewStatics const& f) { return f.HeaderTemplateProperty(); });
    }
    inline auto NavigationView::DisplayModeProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(INavigationViewStatics const&), NavigationView, INavigationViewStatics>([](INavigationViewStatics const& f) { return f.DisplayModeProperty(); });
    }
    inline auto NavigationView::IsSettingsVisibleProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(INavigationViewStatics const&), NavigationView, INavigationViewStatics>([](INavigationViewStatics const& f) { return f.IsSettingsVisibleProperty(); });
    }
    inline auto NavigationView::IsPaneToggleButtonVisibleProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(INavigationViewStatics const&), NavigationView, INavigationViewStatics>([](INavigationViewStatics const& f) { return f.IsPaneToggleButtonVisibleProperty(); });
    }
    inline auto NavigationView::AlwaysShowHeaderProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(INavigationViewStatics const&), NavigationView, INavigationViewStatics>([](INavigationViewStatics const& f) { return f.AlwaysShowHeaderProperty(); });
    }
    inline auto NavigationView::CompactPaneLengthProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(INavigationViewStatics const&), NavigationView, INavigationViewStatics>([](INavigationViewStatics const& f) { return f.CompactPaneLengthProperty(); });
    }
    inline auto NavigationView::OpenPaneLengthProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(INavigationViewStatics const&), NavigationView, INavigationViewStatics>([](INavigationViewStatics const& f) { return f.OpenPaneLengthProperty(); });
    }
    inline auto NavigationView::PaneToggleButtonStyleProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(INavigationViewStatics const&), NavigationView, INavigationViewStatics>([](INavigationViewStatics const& f) { return f.PaneToggleButtonStyleProperty(); });
    }
    inline auto NavigationView::MenuItemsProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(INavigationViewStatics const&), NavigationView, INavigationViewStatics>([](INavigationViewStatics const& f) { return f.MenuItemsProperty(); });
    }
    inline auto NavigationView::MenuItemsSourceProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(INavigationViewStatics const&), NavigationView, INavigationViewStatics>([](INavigationViewStatics const& f) { return f.MenuItemsSourceProperty(); });
    }
    inline auto NavigationView::SelectedItemProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(INavigationViewStatics const&), NavigationView, INavigationViewStatics>([](INavigationViewStatics const& f) { return f.SelectedItemProperty(); });
    }
    inline auto NavigationView::SettingsItemProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(INavigationViewStatics const&), NavigationView, INavigationViewStatics>([](INavigationViewStatics const& f) { return f.SettingsItemProperty(); });
    }
    inline auto NavigationView::AutoSuggestBoxProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(INavigationViewStatics const&), NavigationView, INavigationViewStatics>([](INavigationViewStatics const& f) { return f.AutoSuggestBoxProperty(); });
    }
    inline auto NavigationView::MenuItemTemplateProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(INavigationViewStatics const&), NavigationView, INavigationViewStatics>([](INavigationViewStatics const& f) { return f.MenuItemTemplateProperty(); });
    }
    inline auto NavigationView::MenuItemTemplateSelectorProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(INavigationViewStatics const&), NavigationView, INavigationViewStatics>([](INavigationViewStatics const& f) { return f.MenuItemTemplateSelectorProperty(); });
    }
    inline auto NavigationView::MenuItemContainerStyleProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(INavigationViewStatics const&), NavigationView, INavigationViewStatics>([](INavigationViewStatics const& f) { return f.MenuItemContainerStyleProperty(); });
    }
    inline auto NavigationView::MenuItemContainerStyleSelectorProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(INavigationViewStatics const&), NavigationView, INavigationViewStatics>([](INavigationViewStatics const& f) { return f.MenuItemContainerStyleSelectorProperty(); });
    }
    inline auto NavigationView::IsTitleBarAutoPaddingEnabledProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(INavigationViewStatics const&), NavigationView, INavigationViewStatics>([](INavigationViewStatics const& f) { return f.IsTitleBarAutoPaddingEnabledProperty(); });
    }
    inline auto NavigationView::IsBackButtonVisibleProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(INavigationViewStatics2 const&), NavigationView, INavigationViewStatics2>([](INavigationViewStatics2 const& f) { return f.IsBackButtonVisibleProperty(); });
    }
    inline auto NavigationView::IsBackEnabledProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(INavigationViewStatics2 const&), NavigationView, INavigationViewStatics2>([](INavigationViewStatics2 const& f) { return f.IsBackEnabledProperty(); });
    }
    inline auto NavigationView::PaneTitleProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(INavigationViewStatics2 const&), NavigationView, INavigationViewStatics2>([](INavigationViewStatics2 const& f) { return f.PaneTitleProperty(); });
    }
    inline auto NavigationView::PaneDisplayModeProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(INavigationViewStatics2 const&), NavigationView, INavigationViewStatics2>([](INavigationViewStatics2 const& f) { return f.PaneDisplayModeProperty(); });
    }
    inline auto NavigationView::PaneHeaderProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(INavigationViewStatics2 const&), NavigationView, INavigationViewStatics2>([](INavigationViewStatics2 const& f) { return f.PaneHeaderProperty(); });
    }
    inline auto NavigationView::PaneCustomContentProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(INavigationViewStatics2 const&), NavigationView, INavigationViewStatics2>([](INavigationViewStatics2 const& f) { return f.PaneCustomContentProperty(); });
    }
    inline auto NavigationView::ContentOverlayProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(INavigationViewStatics2 const&), NavigationView, INavigationViewStatics2>([](INavigationViewStatics2 const& f) { return f.ContentOverlayProperty(); });
    }
    inline auto NavigationView::IsPaneVisibleProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(INavigationViewStatics2 const&), NavigationView, INavigationViewStatics2>([](INavigationViewStatics2 const& f) { return f.IsPaneVisibleProperty(); });
    }
    inline auto NavigationView::SelectionFollowsFocusProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(INavigationViewStatics2 const&), NavigationView, INavigationViewStatics2>([](INavigationViewStatics2 const& f) { return f.SelectionFollowsFocusProperty(); });
    }
    inline auto NavigationView::TemplateSettingsProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(INavigationViewStatics2 const&), NavigationView, INavigationViewStatics2>([](INavigationViewStatics2 const& f) { return f.TemplateSettingsProperty(); });
    }
    inline auto NavigationView::ShoulderNavigationEnabledProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(INavigationViewStatics2 const&), NavigationView, INavigationViewStatics2>([](INavigationViewStatics2 const& f) { return f.ShoulderNavigationEnabledProperty(); });
    }
    inline auto NavigationView::OverflowLabelModeProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(INavigationViewStatics2 const&), NavigationView, INavigationViewStatics2>([](INavigationViewStatics2 const& f) { return f.OverflowLabelModeProperty(); });
    }
    inline NavigationViewItem::NavigationViewItem()
    {
        winrt::Windows::Foundation::IInspectable baseInterface, innerInterface;
        *this = impl::call_factory<NavigationViewItem, INavigationViewItemFactory>([&](INavigationViewItemFactory const& f) { return f.CreateInstance(baseInterface, innerInterface); });
    }
    inline auto NavigationViewItem::IconProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(INavigationViewItemStatics const&), NavigationViewItem, INavigationViewItemStatics>([](INavigationViewItemStatics const& f) { return f.IconProperty(); });
    }
    inline auto NavigationViewItem::CompactPaneLengthProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(INavigationViewItemStatics const&), NavigationViewItem, INavigationViewItemStatics>([](INavigationViewItemStatics const& f) { return f.CompactPaneLengthProperty(); });
    }
    inline auto NavigationViewItem::SelectsOnInvokedProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(INavigationViewItemStatics2 const&), NavigationViewItem, INavigationViewItemStatics2>([](INavigationViewItemStatics2 const& f) { return f.SelectsOnInvokedProperty(); });
    }
    inline auto NavigationViewItem::IsExpandedProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(INavigationViewItemStatics2 const&), NavigationViewItem, INavigationViewItemStatics2>([](INavigationViewItemStatics2 const& f) { return f.IsExpandedProperty(); });
    }
    inline auto NavigationViewItem::HasUnrealizedChildrenProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(INavigationViewItemStatics2 const&), NavigationViewItem, INavigationViewItemStatics2>([](INavigationViewItemStatics2 const& f) { return f.HasUnrealizedChildrenProperty(); });
    }
    inline auto NavigationViewItem::IsChildSelectedProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(INavigationViewItemStatics2 const&), NavigationViewItem, INavigationViewItemStatics2>([](INavigationViewItemStatics2 const& f) { return f.IsChildSelectedProperty(); });
    }
    inline auto NavigationViewItem::MenuItemsProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(INavigationViewItemStatics2 const&), NavigationViewItem, INavigationViewItemStatics2>([](INavigationViewItemStatics2 const& f) { return f.MenuItemsProperty(); });
    }
    inline auto NavigationViewItem::MenuItemsSourceProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(INavigationViewItemStatics2 const&), NavigationViewItem, INavigationViewItemStatics2>([](INavigationViewItemStatics2 const& f) { return f.MenuItemsSourceProperty(); });
    }
    inline auto NavigationViewItem::InfoBadgeProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(INavigationViewItemStatics3 const&), NavigationViewItem, INavigationViewItemStatics3>([](INavigationViewItemStatics3 const& f) { return f.InfoBadgeProperty(); });
    }
    inline auto NavigationViewItemBase::IsSelectedProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(INavigationViewItemBaseStatics const&), NavigationViewItemBase, INavigationViewItemBaseStatics>([](INavigationViewItemBaseStatics const& f) { return f.IsSelectedProperty(); });
    }
    inline NavigationViewItemHeader::NavigationViewItemHeader()
    {
        winrt::Windows::Foundation::IInspectable baseInterface, innerInterface;
        *this = impl::call_factory<NavigationViewItemHeader, INavigationViewItemHeaderFactory>([&](INavigationViewItemHeaderFactory const& f) { return f.CreateInstance(baseInterface, innerInterface); });
    }
    inline NavigationViewItemInvokedEventArgs::NavigationViewItemInvokedEventArgs() :
        NavigationViewItemInvokedEventArgs(impl::call_factory_cast<NavigationViewItemInvokedEventArgs(*)(winrt::Windows::Foundation::IActivationFactory const&), NavigationViewItemInvokedEventArgs>([](winrt::Windows::Foundation::IActivationFactory const& f) { return f.template ActivateInstance<NavigationViewItemInvokedEventArgs>(); }))
    {
    }
    inline NavigationViewItemSeparator::NavigationViewItemSeparator()
    {
        winrt::Windows::Foundation::IInspectable baseInterface, innerInterface;
        *this = impl::call_factory<NavigationViewItemSeparator, INavigationViewItemSeparatorFactory>([&](INavigationViewItemSeparatorFactory const& f) { return f.CreateInstance(baseInterface, innerInterface); });
    }
    inline NavigationViewTemplateSettings::NavigationViewTemplateSettings()
    {
        winrt::Windows::Foundation::IInspectable baseInterface, innerInterface;
        *this = impl::call_factory<NavigationViewTemplateSettings, INavigationViewTemplateSettingsFactory>([&](INavigationViewTemplateSettingsFactory const& f) { return f.CreateInstance(baseInterface, innerInterface); });
    }
    inline auto NavigationViewTemplateSettings::TopPaddingProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(INavigationViewTemplateSettingsStatics const&), NavigationViewTemplateSettings, INavigationViewTemplateSettingsStatics>([](INavigationViewTemplateSettingsStatics const& f) { return f.TopPaddingProperty(); });
    }
    inline auto NavigationViewTemplateSettings::OverflowButtonVisibilityProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(INavigationViewTemplateSettingsStatics const&), NavigationViewTemplateSettings, INavigationViewTemplateSettingsStatics>([](INavigationViewTemplateSettingsStatics const& f) { return f.OverflowButtonVisibilityProperty(); });
    }
    inline auto NavigationViewTemplateSettings::PaneToggleButtonVisibilityProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(INavigationViewTemplateSettingsStatics const&), NavigationViewTemplateSettings, INavigationViewTemplateSettingsStatics>([](INavigationViewTemplateSettingsStatics const& f) { return f.PaneToggleButtonVisibilityProperty(); });
    }
    inline auto NavigationViewTemplateSettings::BackButtonVisibilityProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(INavigationViewTemplateSettingsStatics const&), NavigationViewTemplateSettings, INavigationViewTemplateSettingsStatics>([](INavigationViewTemplateSettingsStatics const& f) { return f.BackButtonVisibilityProperty(); });
    }
    inline auto NavigationViewTemplateSettings::TopPaneVisibilityProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(INavigationViewTemplateSettingsStatics const&), NavigationViewTemplateSettings, INavigationViewTemplateSettingsStatics>([](INavigationViewTemplateSettingsStatics const& f) { return f.TopPaneVisibilityProperty(); });
    }
    inline auto NavigationViewTemplateSettings::LeftPaneVisibilityProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(INavigationViewTemplateSettingsStatics const&), NavigationViewTemplateSettings, INavigationViewTemplateSettingsStatics>([](INavigationViewTemplateSettingsStatics const& f) { return f.LeftPaneVisibilityProperty(); });
    }
    inline auto NavigationViewTemplateSettings::SingleSelectionFollowsFocusProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(INavigationViewTemplateSettingsStatics const&), NavigationViewTemplateSettings, INavigationViewTemplateSettingsStatics>([](INavigationViewTemplateSettingsStatics const& f) { return f.SingleSelectionFollowsFocusProperty(); });
    }
    inline auto NavigationViewTemplateSettings::PaneToggleButtonWidthProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(INavigationViewTemplateSettingsStatics const&), NavigationViewTemplateSettings, INavigationViewTemplateSettingsStatics>([](INavigationViewTemplateSettingsStatics const& f) { return f.PaneToggleButtonWidthProperty(); });
    }
    inline auto NavigationViewTemplateSettings::SmallerPaneToggleButtonWidthProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(INavigationViewTemplateSettingsStatics const&), NavigationViewTemplateSettings, INavigationViewTemplateSettingsStatics>([](INavigationViewTemplateSettingsStatics const& f) { return f.SmallerPaneToggleButtonWidthProperty(); });
    }
    inline auto NavigationViewTemplateSettings::OpenPaneLengthProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(INavigationViewTemplateSettingsStatics2 const&), NavigationViewTemplateSettings, INavigationViewTemplateSettingsStatics2>([](INavigationViewTemplateSettingsStatics2 const& f) { return f.OpenPaneLengthProperty(); });
    }
    inline NonVirtualizingLayout::NonVirtualizingLayout()
    {
        winrt::Windows::Foundation::IInspectable baseInterface, innerInterface;
        *this = impl::call_factory<NonVirtualizingLayout, INonVirtualizingLayoutFactory>([&](INonVirtualizingLayoutFactory const& f) { return f.CreateInstance(baseInterface, innerInterface); });
    }
    inline NonVirtualizingLayoutContext::NonVirtualizingLayoutContext()
    {
        winrt::Windows::Foundation::IInspectable baseInterface, innerInterface;
        *this = impl::call_factory<NonVirtualizingLayoutContext, INonVirtualizingLayoutContextFactory>([&](INonVirtualizingLayoutContextFactory const& f) { return f.CreateInstance(baseInterface, innerInterface); });
    }
    inline NumberBox::NumberBox()
    {
        winrt::Windows::Foundation::IInspectable baseInterface, innerInterface;
        *this = impl::call_factory<NumberBox, INumberBoxFactory>([&](INumberBoxFactory const& f) { return f.CreateInstance(baseInterface, innerInterface); });
    }
    inline auto NumberBox::MinimumProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(INumberBoxStatics const&), NumberBox, INumberBoxStatics>([](INumberBoxStatics const& f) { return f.MinimumProperty(); });
    }
    inline auto NumberBox::MaximumProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(INumberBoxStatics const&), NumberBox, INumberBoxStatics>([](INumberBoxStatics const& f) { return f.MaximumProperty(); });
    }
    inline auto NumberBox::ValueProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(INumberBoxStatics const&), NumberBox, INumberBoxStatics>([](INumberBoxStatics const& f) { return f.ValueProperty(); });
    }
    inline auto NumberBox::SmallChangeProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(INumberBoxStatics const&), NumberBox, INumberBoxStatics>([](INumberBoxStatics const& f) { return f.SmallChangeProperty(); });
    }
    inline auto NumberBox::LargeChangeProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(INumberBoxStatics const&), NumberBox, INumberBoxStatics>([](INumberBoxStatics const& f) { return f.LargeChangeProperty(); });
    }
    inline auto NumberBox::TextProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(INumberBoxStatics const&), NumberBox, INumberBoxStatics>([](INumberBoxStatics const& f) { return f.TextProperty(); });
    }
    inline auto NumberBox::HeaderProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(INumberBoxStatics const&), NumberBox, INumberBoxStatics>([](INumberBoxStatics const& f) { return f.HeaderProperty(); });
    }
    inline auto NumberBox::HeaderTemplateProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(INumberBoxStatics const&), NumberBox, INumberBoxStatics>([](INumberBoxStatics const& f) { return f.HeaderTemplateProperty(); });
    }
    inline auto NumberBox::PlaceholderTextProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(INumberBoxStatics const&), NumberBox, INumberBoxStatics>([](INumberBoxStatics const& f) { return f.PlaceholderTextProperty(); });
    }
    inline auto NumberBox::SelectionFlyoutProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(INumberBoxStatics const&), NumberBox, INumberBoxStatics>([](INumberBoxStatics const& f) { return f.SelectionFlyoutProperty(); });
    }
    inline auto NumberBox::SelectionHighlightColorProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(INumberBoxStatics const&), NumberBox, INumberBoxStatics>([](INumberBoxStatics const& f) { return f.SelectionHighlightColorProperty(); });
    }
    inline auto NumberBox::TextReadingOrderProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(INumberBoxStatics const&), NumberBox, INumberBoxStatics>([](INumberBoxStatics const& f) { return f.TextReadingOrderProperty(); });
    }
    inline auto NumberBox::PreventKeyboardDisplayOnProgrammaticFocusProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(INumberBoxStatics const&), NumberBox, INumberBoxStatics>([](INumberBoxStatics const& f) { return f.PreventKeyboardDisplayOnProgrammaticFocusProperty(); });
    }
    inline auto NumberBox::DescriptionProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(INumberBoxStatics const&), NumberBox, INumberBoxStatics>([](INumberBoxStatics const& f) { return f.DescriptionProperty(); });
    }
    inline auto NumberBox::ValidationModeProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(INumberBoxStatics const&), NumberBox, INumberBoxStatics>([](INumberBoxStatics const& f) { return f.ValidationModeProperty(); });
    }
    inline auto NumberBox::SpinButtonPlacementModeProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(INumberBoxStatics const&), NumberBox, INumberBoxStatics>([](INumberBoxStatics const& f) { return f.SpinButtonPlacementModeProperty(); });
    }
    inline auto NumberBox::IsWrapEnabledProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(INumberBoxStatics const&), NumberBox, INumberBoxStatics>([](INumberBoxStatics const& f) { return f.IsWrapEnabledProperty(); });
    }
    inline auto NumberBox::AcceptsExpressionProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(INumberBoxStatics const&), NumberBox, INumberBoxStatics>([](INumberBoxStatics const& f) { return f.AcceptsExpressionProperty(); });
    }
    inline auto NumberBox::NumberFormatterProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(INumberBoxStatics const&), NumberBox, INumberBoxStatics>([](INumberBoxStatics const& f) { return f.NumberFormatterProperty(); });
    }
    inline ParallaxView::ParallaxView()
    {
        winrt::Windows::Foundation::IInspectable baseInterface, innerInterface;
        *this = impl::call_factory<ParallaxView, IParallaxViewFactory>([&](IParallaxViewFactory const& f) { return f.CreateInstance(baseInterface, innerInterface); });
    }
    inline auto ParallaxView::ChildProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(IParallaxViewStatics const&), ParallaxView, IParallaxViewStatics>([](IParallaxViewStatics const& f) { return f.ChildProperty(); });
    }
    inline auto ParallaxView::HorizontalSourceEndOffsetProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(IParallaxViewStatics const&), ParallaxView, IParallaxViewStatics>([](IParallaxViewStatics const& f) { return f.HorizontalSourceEndOffsetProperty(); });
    }
    inline auto ParallaxView::HorizontalSourceOffsetKindProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(IParallaxViewStatics const&), ParallaxView, IParallaxViewStatics>([](IParallaxViewStatics const& f) { return f.HorizontalSourceOffsetKindProperty(); });
    }
    inline auto ParallaxView::HorizontalSourceStartOffsetProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(IParallaxViewStatics const&), ParallaxView, IParallaxViewStatics>([](IParallaxViewStatics const& f) { return f.HorizontalSourceStartOffsetProperty(); });
    }
    inline auto ParallaxView::MaxHorizontalShiftRatioProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(IParallaxViewStatics const&), ParallaxView, IParallaxViewStatics>([](IParallaxViewStatics const& f) { return f.MaxHorizontalShiftRatioProperty(); });
    }
    inline auto ParallaxView::HorizontalShiftProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(IParallaxViewStatics const&), ParallaxView, IParallaxViewStatics>([](IParallaxViewStatics const& f) { return f.HorizontalShiftProperty(); });
    }
    inline auto ParallaxView::IsHorizontalShiftClampedProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(IParallaxViewStatics const&), ParallaxView, IParallaxViewStatics>([](IParallaxViewStatics const& f) { return f.IsHorizontalShiftClampedProperty(); });
    }
    inline auto ParallaxView::IsVerticalShiftClampedProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(IParallaxViewStatics const&), ParallaxView, IParallaxViewStatics>([](IParallaxViewStatics const& f) { return f.IsVerticalShiftClampedProperty(); });
    }
    inline auto ParallaxView::SourceProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(IParallaxViewStatics const&), ParallaxView, IParallaxViewStatics>([](IParallaxViewStatics const& f) { return f.SourceProperty(); });
    }
    inline auto ParallaxView::VerticalSourceEndOffsetProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(IParallaxViewStatics const&), ParallaxView, IParallaxViewStatics>([](IParallaxViewStatics const& f) { return f.VerticalSourceEndOffsetProperty(); });
    }
    inline auto ParallaxView::VerticalSourceOffsetKindProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(IParallaxViewStatics const&), ParallaxView, IParallaxViewStatics>([](IParallaxViewStatics const& f) { return f.VerticalSourceOffsetKindProperty(); });
    }
    inline auto ParallaxView::VerticalSourceStartOffsetProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(IParallaxViewStatics const&), ParallaxView, IParallaxViewStatics>([](IParallaxViewStatics const& f) { return f.VerticalSourceStartOffsetProperty(); });
    }
    inline auto ParallaxView::MaxVerticalShiftRatioProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(IParallaxViewStatics const&), ParallaxView, IParallaxViewStatics>([](IParallaxViewStatics const& f) { return f.MaxVerticalShiftRatioProperty(); });
    }
    inline auto ParallaxView::VerticalShiftProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(IParallaxViewStatics const&), ParallaxView, IParallaxViewStatics>([](IParallaxViewStatics const& f) { return f.VerticalShiftProperty(); });
    }
    inline PathIconSource::PathIconSource()
    {
        winrt::Windows::Foundation::IInspectable baseInterface, innerInterface;
        *this = impl::call_factory<PathIconSource, IPathIconSourceFactory>([&](IPathIconSourceFactory const& f) { return f.CreateInstance(baseInterface, innerInterface); });
    }
    inline auto PathIconSource::DataProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(IPathIconSourceStatics const&), PathIconSource, IPathIconSourceStatics>([](IPathIconSourceStatics const& f) { return f.DataProperty(); });
    }
    inline PersonPicture::PersonPicture()
    {
        winrt::Windows::Foundation::IInspectable baseInterface, innerInterface;
        *this = impl::call_factory<PersonPicture, IPersonPictureFactory>([&](IPersonPictureFactory const& f) { return f.CreateInstance(baseInterface, innerInterface); });
    }
    inline auto PersonPicture::BadgeNumberProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(IPersonPictureStatics const&), PersonPicture, IPersonPictureStatics>([](IPersonPictureStatics const& f) { return f.BadgeNumberProperty(); });
    }
    inline auto PersonPicture::BadgeGlyphProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(IPersonPictureStatics const&), PersonPicture, IPersonPictureStatics>([](IPersonPictureStatics const& f) { return f.BadgeGlyphProperty(); });
    }
    inline auto PersonPicture::BadgeImageSourceProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(IPersonPictureStatics const&), PersonPicture, IPersonPictureStatics>([](IPersonPictureStatics const& f) { return f.BadgeImageSourceProperty(); });
    }
    inline auto PersonPicture::BadgeTextProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(IPersonPictureStatics const&), PersonPicture, IPersonPictureStatics>([](IPersonPictureStatics const& f) { return f.BadgeTextProperty(); });
    }
    inline auto PersonPicture::IsGroupProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(IPersonPictureStatics const&), PersonPicture, IPersonPictureStatics>([](IPersonPictureStatics const& f) { return f.IsGroupProperty(); });
    }
    inline auto PersonPicture::ContactProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(IPersonPictureStatics const&), PersonPicture, IPersonPictureStatics>([](IPersonPictureStatics const& f) { return f.ContactProperty(); });
    }
    inline auto PersonPicture::DisplayNameProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(IPersonPictureStatics const&), PersonPicture, IPersonPictureStatics>([](IPersonPictureStatics const& f) { return f.DisplayNameProperty(); });
    }
    inline auto PersonPicture::InitialsProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(IPersonPictureStatics const&), PersonPicture, IPersonPictureStatics>([](IPersonPictureStatics const& f) { return f.InitialsProperty(); });
    }
    inline auto PersonPicture::PreferSmallImageProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(IPersonPictureStatics const&), PersonPicture, IPersonPictureStatics>([](IPersonPictureStatics const& f) { return f.PreferSmallImageProperty(); });
    }
    inline auto PersonPicture::ProfilePictureProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(IPersonPictureStatics const&), PersonPicture, IPersonPictureStatics>([](IPersonPictureStatics const& f) { return f.ProfilePictureProperty(); });
    }
    inline PipsPager::PipsPager()
    {
        winrt::Windows::Foundation::IInspectable baseInterface, innerInterface;
        *this = impl::call_factory<PipsPager, IPipsPagerFactory>([&](IPipsPagerFactory const& f) { return f.CreateInstance(baseInterface, innerInterface); });
    }
    inline auto PipsPager::NumberOfPagesProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(IPipsPagerStatics const&), PipsPager, IPipsPagerStatics>([](IPipsPagerStatics const& f) { return f.NumberOfPagesProperty(); });
    }
    inline auto PipsPager::SelectedPageIndexProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(IPipsPagerStatics const&), PipsPager, IPipsPagerStatics>([](IPipsPagerStatics const& f) { return f.SelectedPageIndexProperty(); });
    }
    inline auto PipsPager::MaxVisiblePipsProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(IPipsPagerStatics const&), PipsPager, IPipsPagerStatics>([](IPipsPagerStatics const& f) { return f.MaxVisiblePipsProperty(); });
    }
    inline auto PipsPager::OrientationProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(IPipsPagerStatics const&), PipsPager, IPipsPagerStatics>([](IPipsPagerStatics const& f) { return f.OrientationProperty(); });
    }
    inline auto PipsPager::PreviousButtonVisibilityProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(IPipsPagerStatics const&), PipsPager, IPipsPagerStatics>([](IPipsPagerStatics const& f) { return f.PreviousButtonVisibilityProperty(); });
    }
    inline auto PipsPager::NextButtonVisibilityProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(IPipsPagerStatics const&), PipsPager, IPipsPagerStatics>([](IPipsPagerStatics const& f) { return f.NextButtonVisibilityProperty(); });
    }
    inline auto PipsPager::PreviousButtonStyleProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(IPipsPagerStatics const&), PipsPager, IPipsPagerStatics>([](IPipsPagerStatics const& f) { return f.PreviousButtonStyleProperty(); });
    }
    inline auto PipsPager::NextButtonStyleProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(IPipsPagerStatics const&), PipsPager, IPipsPagerStatics>([](IPipsPagerStatics const& f) { return f.NextButtonStyleProperty(); });
    }
    inline auto PipsPager::SelectedPipStyleProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(IPipsPagerStatics const&), PipsPager, IPipsPagerStatics>([](IPipsPagerStatics const& f) { return f.SelectedPipStyleProperty(); });
    }
    inline auto PipsPager::NormalPipStyleProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(IPipsPagerStatics const&), PipsPager, IPipsPagerStatics>([](IPipsPagerStatics const& f) { return f.NormalPipStyleProperty(); });
    }
    inline ProgressBar::ProgressBar()
    {
        winrt::Windows::Foundation::IInspectable baseInterface, innerInterface;
        *this = impl::call_factory<ProgressBar, IProgressBarFactory>([&](IProgressBarFactory const& f) { return f.CreateInstance(baseInterface, innerInterface); });
    }
    inline auto ProgressBar::IsIndeterminateProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(IProgressBarStatics const&), ProgressBar, IProgressBarStatics>([](IProgressBarStatics const& f) { return f.IsIndeterminateProperty(); });
    }
    inline auto ProgressBar::ShowErrorProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(IProgressBarStatics const&), ProgressBar, IProgressBarStatics>([](IProgressBarStatics const& f) { return f.ShowErrorProperty(); });
    }
    inline auto ProgressBar::ShowPausedProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(IProgressBarStatics const&), ProgressBar, IProgressBarStatics>([](IProgressBarStatics const& f) { return f.ShowPausedProperty(); });
    }
    inline ProgressRing::ProgressRing()
    {
        winrt::Windows::Foundation::IInspectable baseInterface, innerInterface;
        *this = impl::call_factory<ProgressRing, IProgressRingFactory>([&](IProgressRingFactory const& f) { return f.CreateInstance(baseInterface, innerInterface); });
    }
    inline auto ProgressRing::IsActiveProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(IProgressRingStatics const&), ProgressRing, IProgressRingStatics>([](IProgressRingStatics const& f) { return f.IsActiveProperty(); });
    }
    inline auto ProgressRing::IsIndeterminateProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(IProgressRingStatics const&), ProgressRing, IProgressRingStatics>([](IProgressRingStatics const& f) { return f.IsIndeterminateProperty(); });
    }
    inline auto ProgressRing::ValueProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(IProgressRingStatics const&), ProgressRing, IProgressRingStatics>([](IProgressRingStatics const& f) { return f.ValueProperty(); });
    }
    inline auto ProgressRing::MinimumProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(IProgressRingStatics const&), ProgressRing, IProgressRingStatics>([](IProgressRingStatics const& f) { return f.MinimumProperty(); });
    }
    inline auto ProgressRing::MaximumProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(IProgressRingStatics const&), ProgressRing, IProgressRingStatics>([](IProgressRingStatics const& f) { return f.MaximumProperty(); });
    }
    inline RadioButtons::RadioButtons()
    {
        winrt::Windows::Foundation::IInspectable baseInterface, innerInterface;
        *this = impl::call_factory<RadioButtons, IRadioButtonsFactory>([&](IRadioButtonsFactory const& f) { return f.CreateInstance(baseInterface, innerInterface); });
    }
    inline auto RadioButtons::ItemsSourceProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(IRadioButtonsStatics const&), RadioButtons, IRadioButtonsStatics>([](IRadioButtonsStatics const& f) { return f.ItemsSourceProperty(); });
    }
    inline auto RadioButtons::ItemsProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(IRadioButtonsStatics const&), RadioButtons, IRadioButtonsStatics>([](IRadioButtonsStatics const& f) { return f.ItemsProperty(); });
    }
    inline auto RadioButtons::ItemTemplateProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(IRadioButtonsStatics const&), RadioButtons, IRadioButtonsStatics>([](IRadioButtonsStatics const& f) { return f.ItemTemplateProperty(); });
    }
    inline auto RadioButtons::SelectedIndexProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(IRadioButtonsStatics const&), RadioButtons, IRadioButtonsStatics>([](IRadioButtonsStatics const& f) { return f.SelectedIndexProperty(); });
    }
    inline auto RadioButtons::SelectedItemProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(IRadioButtonsStatics const&), RadioButtons, IRadioButtonsStatics>([](IRadioButtonsStatics const& f) { return f.SelectedItemProperty(); });
    }
    inline auto RadioButtons::MaxColumnsProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(IRadioButtonsStatics const&), RadioButtons, IRadioButtonsStatics>([](IRadioButtonsStatics const& f) { return f.MaxColumnsProperty(); });
    }
    inline auto RadioButtons::HeaderProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(IRadioButtonsStatics const&), RadioButtons, IRadioButtonsStatics>([](IRadioButtonsStatics const& f) { return f.HeaderProperty(); });
    }
    inline auto RadioButtons::HeaderTemplateProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(IRadioButtonsStatics const&), RadioButtons, IRadioButtonsStatics>([](IRadioButtonsStatics const& f) { return f.HeaderTemplateProperty(); });
    }
    inline RadioMenuFlyoutItem::RadioMenuFlyoutItem()
    {
        winrt::Windows::Foundation::IInspectable baseInterface, innerInterface;
        *this = impl::call_factory<RadioMenuFlyoutItem, IRadioMenuFlyoutItemFactory>([&](IRadioMenuFlyoutItemFactory const& f) { return f.CreateInstance(baseInterface, innerInterface); });
    }
    inline auto RadioMenuFlyoutItem::IsCheckedProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(IRadioMenuFlyoutItemStatics const&), RadioMenuFlyoutItem, IRadioMenuFlyoutItemStatics>([](IRadioMenuFlyoutItemStatics const& f) { return f.IsCheckedProperty(); });
    }
    inline auto RadioMenuFlyoutItem::GroupNameProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(IRadioMenuFlyoutItemStatics const&), RadioMenuFlyoutItem, IRadioMenuFlyoutItemStatics>([](IRadioMenuFlyoutItemStatics const& f) { return f.GroupNameProperty(); });
    }
    inline auto RadioMenuFlyoutItem::AreCheckStatesEnabledProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(IRadioMenuFlyoutItemStatics2 const&), RadioMenuFlyoutItem, IRadioMenuFlyoutItemStatics2>([](IRadioMenuFlyoutItemStatics2 const& f) { return f.AreCheckStatesEnabledProperty(); });
    }
    inline auto RadioMenuFlyoutItem::SetAreCheckStatesEnabled(winrt::Windows::UI::Xaml::Controls::MenuFlyoutSubItem const& object, bool value)
    {
        impl::call_factory<RadioMenuFlyoutItem, IRadioMenuFlyoutItemStatics2>([&](IRadioMenuFlyoutItemStatics2 const& f) { return f.SetAreCheckStatesEnabled(object, value); });
    }
    inline auto RadioMenuFlyoutItem::GetAreCheckStatesEnabled(winrt::Windows::UI::Xaml::Controls::MenuFlyoutSubItem const& object)
    {
        return impl::call_factory<RadioMenuFlyoutItem, IRadioMenuFlyoutItemStatics2>([&](IRadioMenuFlyoutItemStatics2 const& f) { return f.GetAreCheckStatesEnabled(object); });
    }
    inline RatingControl::RatingControl()
    {
        winrt::Windows::Foundation::IInspectable baseInterface, innerInterface;
        *this = impl::call_factory<RatingControl, IRatingControlFactory>([&](IRatingControlFactory const& f) { return f.CreateInstance(baseInterface, innerInterface); });
    }
    inline auto RatingControl::CaptionProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(IRatingControlStatics const&), RatingControl, IRatingControlStatics>([](IRatingControlStatics const& f) { return f.CaptionProperty(); });
    }
    inline auto RatingControl::InitialSetValueProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(IRatingControlStatics const&), RatingControl, IRatingControlStatics>([](IRatingControlStatics const& f) { return f.InitialSetValueProperty(); });
    }
    inline auto RatingControl::IsClearEnabledProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(IRatingControlStatics const&), RatingControl, IRatingControlStatics>([](IRatingControlStatics const& f) { return f.IsClearEnabledProperty(); });
    }
    inline auto RatingControl::IsReadOnlyProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(IRatingControlStatics const&), RatingControl, IRatingControlStatics>([](IRatingControlStatics const& f) { return f.IsReadOnlyProperty(); });
    }
    inline auto RatingControl::MaxRatingProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(IRatingControlStatics const&), RatingControl, IRatingControlStatics>([](IRatingControlStatics const& f) { return f.MaxRatingProperty(); });
    }
    inline auto RatingControl::PlaceholderValueProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(IRatingControlStatics const&), RatingControl, IRatingControlStatics>([](IRatingControlStatics const& f) { return f.PlaceholderValueProperty(); });
    }
    inline auto RatingControl::ItemInfoProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(IRatingControlStatics const&), RatingControl, IRatingControlStatics>([](IRatingControlStatics const& f) { return f.ItemInfoProperty(); });
    }
    inline auto RatingControl::ValueProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(IRatingControlStatics const&), RatingControl, IRatingControlStatics>([](IRatingControlStatics const& f) { return f.ValueProperty(); });
    }
    inline RatingItemFontInfo::RatingItemFontInfo()
    {
        winrt::Windows::Foundation::IInspectable baseInterface, innerInterface;
        *this = impl::call_factory<RatingItemFontInfo, IRatingItemFontInfoFactory>([&](IRatingItemFontInfoFactory const& f) { return f.CreateInstance(baseInterface, innerInterface); });
    }
    inline auto RatingItemFontInfo::DisabledGlyphProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(IRatingItemFontInfoStatics const&), RatingItemFontInfo, IRatingItemFontInfoStatics>([](IRatingItemFontInfoStatics const& f) { return f.DisabledGlyphProperty(); });
    }
    inline auto RatingItemFontInfo::GlyphProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(IRatingItemFontInfoStatics const&), RatingItemFontInfo, IRatingItemFontInfoStatics>([](IRatingItemFontInfoStatics const& f) { return f.GlyphProperty(); });
    }
    inline auto RatingItemFontInfo::PlaceholderGlyphProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(IRatingItemFontInfoStatics const&), RatingItemFontInfo, IRatingItemFontInfoStatics>([](IRatingItemFontInfoStatics const& f) { return f.PlaceholderGlyphProperty(); });
    }
    inline auto RatingItemFontInfo::PointerOverGlyphProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(IRatingItemFontInfoStatics const&), RatingItemFontInfo, IRatingItemFontInfoStatics>([](IRatingItemFontInfoStatics const& f) { return f.PointerOverGlyphProperty(); });
    }
    inline auto RatingItemFontInfo::PointerOverPlaceholderGlyphProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(IRatingItemFontInfoStatics const&), RatingItemFontInfo, IRatingItemFontInfoStatics>([](IRatingItemFontInfoStatics const& f) { return f.PointerOverPlaceholderGlyphProperty(); });
    }
    inline auto RatingItemFontInfo::UnsetGlyphProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(IRatingItemFontInfoStatics const&), RatingItemFontInfo, IRatingItemFontInfoStatics>([](IRatingItemFontInfoStatics const& f) { return f.UnsetGlyphProperty(); });
    }
    inline RatingItemImageInfo::RatingItemImageInfo()
    {
        winrt::Windows::Foundation::IInspectable baseInterface, innerInterface;
        *this = impl::call_factory<RatingItemImageInfo, IRatingItemImageInfoFactory>([&](IRatingItemImageInfoFactory const& f) { return f.CreateInstance(baseInterface, innerInterface); });
    }
    inline auto RatingItemImageInfo::DisabledImageProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(IRatingItemImageInfoStatics const&), RatingItemImageInfo, IRatingItemImageInfoStatics>([](IRatingItemImageInfoStatics const& f) { return f.DisabledImageProperty(); });
    }
    inline auto RatingItemImageInfo::ImageProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(IRatingItemImageInfoStatics const&), RatingItemImageInfo, IRatingItemImageInfoStatics>([](IRatingItemImageInfoStatics const& f) { return f.ImageProperty(); });
    }
    inline auto RatingItemImageInfo::PlaceholderImageProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(IRatingItemImageInfoStatics const&), RatingItemImageInfo, IRatingItemImageInfoStatics>([](IRatingItemImageInfoStatics const& f) { return f.PlaceholderImageProperty(); });
    }
    inline auto RatingItemImageInfo::PointerOverImageProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(IRatingItemImageInfoStatics const&), RatingItemImageInfo, IRatingItemImageInfoStatics>([](IRatingItemImageInfoStatics const& f) { return f.PointerOverImageProperty(); });
    }
    inline auto RatingItemImageInfo::PointerOverPlaceholderImageProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(IRatingItemImageInfoStatics const&), RatingItemImageInfo, IRatingItemImageInfoStatics>([](IRatingItemImageInfoStatics const& f) { return f.PointerOverPlaceholderImageProperty(); });
    }
    inline auto RatingItemImageInfo::UnsetImageProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(IRatingItemImageInfoStatics const&), RatingItemImageInfo, IRatingItemImageInfoStatics>([](IRatingItemImageInfoStatics const& f) { return f.UnsetImageProperty(); });
    }
    inline RatingItemInfo::RatingItemInfo()
    {
        winrt::Windows::Foundation::IInspectable baseInterface, innerInterface;
        *this = impl::call_factory<RatingItemInfo, IRatingItemInfoFactory>([&](IRatingItemInfoFactory const& f) { return f.CreateInstance(baseInterface, innerInterface); });
    }
    inline RefreshContainer::RefreshContainer()
    {
        winrt::Windows::Foundation::IInspectable baseInterface, innerInterface;
        *this = impl::call_factory<RefreshContainer, IRefreshContainerFactory>([&](IRefreshContainerFactory const& f) { return f.CreateInstance(baseInterface, innerInterface); });
    }
    inline auto RefreshContainer::VisualizerProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(IRefreshContainerStatics const&), RefreshContainer, IRefreshContainerStatics>([](IRefreshContainerStatics const& f) { return f.VisualizerProperty(); });
    }
    inline auto RefreshContainer::PullDirectionProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(IRefreshContainerStatics const&), RefreshContainer, IRefreshContainerStatics>([](IRefreshContainerStatics const& f) { return f.PullDirectionProperty(); });
    }
    inline RefreshVisualizer::RefreshVisualizer()
    {
        winrt::Windows::Foundation::IInspectable baseInterface, innerInterface;
        *this = impl::call_factory<RefreshVisualizer, IRefreshVisualizerFactory>([&](IRefreshVisualizerFactory const& f) { return f.CreateInstance(baseInterface, innerInterface); });
    }
    inline auto RefreshVisualizer::InfoProviderProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(IRefreshVisualizerStatics const&), RefreshVisualizer, IRefreshVisualizerStatics>([](IRefreshVisualizerStatics const& f) { return f.InfoProviderProperty(); });
    }
    inline auto RefreshVisualizer::OrientationProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(IRefreshVisualizerStatics const&), RefreshVisualizer, IRefreshVisualizerStatics>([](IRefreshVisualizerStatics const& f) { return f.OrientationProperty(); });
    }
    inline auto RefreshVisualizer::ContentProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(IRefreshVisualizerStatics const&), RefreshVisualizer, IRefreshVisualizerStatics>([](IRefreshVisualizerStatics const& f) { return f.ContentProperty(); });
    }
    inline auto RefreshVisualizer::StateProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(IRefreshVisualizerStatics const&), RefreshVisualizer, IRefreshVisualizerStatics>([](IRefreshVisualizerStatics const& f) { return f.StateProperty(); });
    }
    inline RevealListViewItemPresenter::RevealListViewItemPresenter()
    {
        winrt::Windows::Foundation::IInspectable baseInterface, innerInterface;
        *this = impl::call_factory<RevealListViewItemPresenter, IRevealListViewItemPresenterFactory>([&](IRevealListViewItemPresenterFactory const& f) { return f.CreateInstance(baseInterface, innerInterface); });
    }
    inline SplitButton::SplitButton()
    {
        winrt::Windows::Foundation::IInspectable baseInterface, innerInterface;
        *this = impl::call_factory<SplitButton, ISplitButtonFactory>([&](ISplitButtonFactory const& f) { return f.CreateInstance(baseInterface, innerInterface); });
    }
    inline auto SplitButton::FlyoutProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(ISplitButtonStatics const&), SplitButton, ISplitButtonStatics>([](ISplitButtonStatics const& f) { return f.FlyoutProperty(); });
    }
    inline auto SplitButton::CommandProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(ISplitButtonStatics const&), SplitButton, ISplitButtonStatics>([](ISplitButtonStatics const& f) { return f.CommandProperty(); });
    }
    inline auto SplitButton::CommandParameterProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(ISplitButtonStatics const&), SplitButton, ISplitButtonStatics>([](ISplitButtonStatics const& f) { return f.CommandParameterProperty(); });
    }
    inline StackLayout::StackLayout()
    {
        winrt::Windows::Foundation::IInspectable baseInterface, innerInterface;
        *this = impl::call_factory<StackLayout, IStackLayoutFactory>([&](IStackLayoutFactory const& f) { return f.CreateInstance(baseInterface, innerInterface); });
    }
    inline auto StackLayout::OrientationProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(IStackLayoutStatics const&), StackLayout, IStackLayoutStatics>([](IStackLayoutStatics const& f) { return f.OrientationProperty(); });
    }
    inline auto StackLayout::SpacingProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(IStackLayoutStatics const&), StackLayout, IStackLayoutStatics>([](IStackLayoutStatics const& f) { return f.SpacingProperty(); });
    }
    inline SwipeControl::SwipeControl()
    {
        winrt::Windows::Foundation::IInspectable baseInterface, innerInterface;
        *this = impl::call_factory<SwipeControl, ISwipeControlFactory>([&](ISwipeControlFactory const& f) { return f.CreateInstance(baseInterface, innerInterface); });
    }
    inline auto SwipeControl::LeftItemsProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(ISwipeControlStatics const&), SwipeControl, ISwipeControlStatics>([](ISwipeControlStatics const& f) { return f.LeftItemsProperty(); });
    }
    inline auto SwipeControl::RightItemsProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(ISwipeControlStatics const&), SwipeControl, ISwipeControlStatics>([](ISwipeControlStatics const& f) { return f.RightItemsProperty(); });
    }
    inline auto SwipeControl::TopItemsProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(ISwipeControlStatics const&), SwipeControl, ISwipeControlStatics>([](ISwipeControlStatics const& f) { return f.TopItemsProperty(); });
    }
    inline auto SwipeControl::BottomItemsProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(ISwipeControlStatics const&), SwipeControl, ISwipeControlStatics>([](ISwipeControlStatics const& f) { return f.BottomItemsProperty(); });
    }
    inline SwipeItem::SwipeItem()
    {
        winrt::Windows::Foundation::IInspectable baseInterface, innerInterface;
        *this = impl::call_factory<SwipeItem, ISwipeItemFactory>([&](ISwipeItemFactory const& f) { return f.CreateInstance(baseInterface, innerInterface); });
    }
    inline auto SwipeItem::IconSourceProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(ISwipeItemStatics const&), SwipeItem, ISwipeItemStatics>([](ISwipeItemStatics const& f) { return f.IconSourceProperty(); });
    }
    inline auto SwipeItem::TextProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(ISwipeItemStatics const&), SwipeItem, ISwipeItemStatics>([](ISwipeItemStatics const& f) { return f.TextProperty(); });
    }
    inline auto SwipeItem::BackgroundProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(ISwipeItemStatics const&), SwipeItem, ISwipeItemStatics>([](ISwipeItemStatics const& f) { return f.BackgroundProperty(); });
    }
    inline auto SwipeItem::ForegroundProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(ISwipeItemStatics const&), SwipeItem, ISwipeItemStatics>([](ISwipeItemStatics const& f) { return f.ForegroundProperty(); });
    }
    inline auto SwipeItem::CommandProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(ISwipeItemStatics const&), SwipeItem, ISwipeItemStatics>([](ISwipeItemStatics const& f) { return f.CommandProperty(); });
    }
    inline auto SwipeItem::CommandParameterProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(ISwipeItemStatics const&), SwipeItem, ISwipeItemStatics>([](ISwipeItemStatics const& f) { return f.CommandParameterProperty(); });
    }
    inline auto SwipeItem::BehaviorOnInvokedProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(ISwipeItemStatics const&), SwipeItem, ISwipeItemStatics>([](ISwipeItemStatics const& f) { return f.BehaviorOnInvokedProperty(); });
    }
    inline SwipeItems::SwipeItems()
    {
        winrt::Windows::Foundation::IInspectable baseInterface, innerInterface;
        *this = impl::call_factory<SwipeItems, ISwipeItemsFactory>([&](ISwipeItemsFactory const& f) { return f.CreateInstance(baseInterface, innerInterface); });
    }
    inline auto SwipeItems::ModeProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(ISwipeItemsStatics const&), SwipeItems, ISwipeItemsStatics>([](ISwipeItemsStatics const& f) { return f.ModeProperty(); });
    }
    inline SymbolIconSource::SymbolIconSource()
    {
        winrt::Windows::Foundation::IInspectable baseInterface, innerInterface;
        *this = impl::call_factory<SymbolIconSource, ISymbolIconSourceFactory>([&](ISymbolIconSourceFactory const& f) { return f.CreateInstance(baseInterface, innerInterface); });
    }
    inline auto SymbolIconSource::SymbolProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(ISymbolIconSourceStatics const&), SymbolIconSource, ISymbolIconSourceStatics>([](ISymbolIconSourceStatics const& f) { return f.SymbolProperty(); });
    }
    inline TabView::TabView()
    {
        winrt::Windows::Foundation::IInspectable baseInterface, innerInterface;
        *this = impl::call_factory<TabView, ITabViewFactory>([&](ITabViewFactory const& f) { return f.CreateInstance(baseInterface, innerInterface); });
    }
    inline auto TabView::TabWidthModeProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(ITabViewStatics const&), TabView, ITabViewStatics>([](ITabViewStatics const& f) { return f.TabWidthModeProperty(); });
    }
    inline auto TabView::TabStripHeaderProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(ITabViewStatics const&), TabView, ITabViewStatics>([](ITabViewStatics const& f) { return f.TabStripHeaderProperty(); });
    }
    inline auto TabView::TabStripHeaderTemplateProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(ITabViewStatics const&), TabView, ITabViewStatics>([](ITabViewStatics const& f) { return f.TabStripHeaderTemplateProperty(); });
    }
    inline auto TabView::TabStripFooterProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(ITabViewStatics const&), TabView, ITabViewStatics>([](ITabViewStatics const& f) { return f.TabStripFooterProperty(); });
    }
    inline auto TabView::TabStripFooterTemplateProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(ITabViewStatics const&), TabView, ITabViewStatics>([](ITabViewStatics const& f) { return f.TabStripFooterTemplateProperty(); });
    }
    inline auto TabView::IsAddTabButtonVisibleProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(ITabViewStatics const&), TabView, ITabViewStatics>([](ITabViewStatics const& f) { return f.IsAddTabButtonVisibleProperty(); });
    }
    inline auto TabView::AddTabButtonCommandProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(ITabViewStatics const&), TabView, ITabViewStatics>([](ITabViewStatics const& f) { return f.AddTabButtonCommandProperty(); });
    }
    inline auto TabView::AddTabButtonCommandParameterProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(ITabViewStatics const&), TabView, ITabViewStatics>([](ITabViewStatics const& f) { return f.AddTabButtonCommandParameterProperty(); });
    }
    inline auto TabView::TabItemsSourceProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(ITabViewStatics const&), TabView, ITabViewStatics>([](ITabViewStatics const& f) { return f.TabItemsSourceProperty(); });
    }
    inline auto TabView::TabItemsProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(ITabViewStatics const&), TabView, ITabViewStatics>([](ITabViewStatics const& f) { return f.TabItemsProperty(); });
    }
    inline auto TabView::TabItemTemplateProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(ITabViewStatics const&), TabView, ITabViewStatics>([](ITabViewStatics const& f) { return f.TabItemTemplateProperty(); });
    }
    inline auto TabView::TabItemTemplateSelectorProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(ITabViewStatics const&), TabView, ITabViewStatics>([](ITabViewStatics const& f) { return f.TabItemTemplateSelectorProperty(); });
    }
    inline auto TabView::CloseButtonOverlayModeProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(ITabViewStatics const&), TabView, ITabViewStatics>([](ITabViewStatics const& f) { return f.CloseButtonOverlayModeProperty(); });
    }
    inline auto TabView::CanDragTabsProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(ITabViewStatics const&), TabView, ITabViewStatics>([](ITabViewStatics const& f) { return f.CanDragTabsProperty(); });
    }
    inline auto TabView::CanReorderTabsProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(ITabViewStatics const&), TabView, ITabViewStatics>([](ITabViewStatics const& f) { return f.CanReorderTabsProperty(); });
    }
    inline auto TabView::AllowDropTabsProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(ITabViewStatics const&), TabView, ITabViewStatics>([](ITabViewStatics const& f) { return f.AllowDropTabsProperty(); });
    }
    inline auto TabView::SelectedIndexProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(ITabViewStatics const&), TabView, ITabViewStatics>([](ITabViewStatics const& f) { return f.SelectedIndexProperty(); });
    }
    inline auto TabView::SelectedItemProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(ITabViewStatics const&), TabView, ITabViewStatics>([](ITabViewStatics const& f) { return f.SelectedItemProperty(); });
    }
    inline TabViewItem::TabViewItem()
    {
        winrt::Windows::Foundation::IInspectable baseInterface, innerInterface;
        *this = impl::call_factory<TabViewItem, ITabViewItemFactory>([&](ITabViewItemFactory const& f) { return f.CreateInstance(baseInterface, innerInterface); });
    }
    inline auto TabViewItem::HeaderProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(ITabViewItemStatics const&), TabViewItem, ITabViewItemStatics>([](ITabViewItemStatics const& f) { return f.HeaderProperty(); });
    }
    inline auto TabViewItem::HeaderTemplateProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(ITabViewItemStatics const&), TabViewItem, ITabViewItemStatics>([](ITabViewItemStatics const& f) { return f.HeaderTemplateProperty(); });
    }
    inline auto TabViewItem::IconSourceProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(ITabViewItemStatics const&), TabViewItem, ITabViewItemStatics>([](ITabViewItemStatics const& f) { return f.IconSourceProperty(); });
    }
    inline auto TabViewItem::IsClosableProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(ITabViewItemStatics const&), TabViewItem, ITabViewItemStatics>([](ITabViewItemStatics const& f) { return f.IsClosableProperty(); });
    }
    inline auto TabViewItem::TabViewTemplateSettingsProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(ITabViewItemStatics const&), TabViewItem, ITabViewItemStatics>([](ITabViewItemStatics const& f) { return f.TabViewTemplateSettingsProperty(); });
    }
    inline TabViewItemTemplateSettings::TabViewItemTemplateSettings()
    {
        winrt::Windows::Foundation::IInspectable baseInterface, innerInterface;
        *this = impl::call_factory<TabViewItemTemplateSettings, ITabViewItemTemplateSettingsFactory>([&](ITabViewItemTemplateSettingsFactory const& f) { return f.CreateInstance(baseInterface, innerInterface); });
    }
    inline auto TabViewItemTemplateSettings::IconElementProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(ITabViewItemTemplateSettingsStatics const&), TabViewItemTemplateSettings, ITabViewItemTemplateSettingsStatics>([](ITabViewItemTemplateSettingsStatics const& f) { return f.IconElementProperty(); });
    }
    inline auto TabViewItemTemplateSettings::TabGeometryProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(ITabViewItemTemplateSettingsStatics2 const&), TabViewItemTemplateSettings, ITabViewItemTemplateSettingsStatics2>([](ITabViewItemTemplateSettingsStatics2 const& f) { return f.TabGeometryProperty(); });
    }
    inline TeachingTip::TeachingTip()
    {
        winrt::Windows::Foundation::IInspectable baseInterface, innerInterface;
        *this = impl::call_factory<TeachingTip, ITeachingTipFactory>([&](ITeachingTipFactory const& f) { return f.CreateInstance(baseInterface, innerInterface); });
    }
    inline auto TeachingTip::IsOpenProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(ITeachingTipStatics const&), TeachingTip, ITeachingTipStatics>([](ITeachingTipStatics const& f) { return f.IsOpenProperty(); });
    }
    inline auto TeachingTip::TargetProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(ITeachingTipStatics const&), TeachingTip, ITeachingTipStatics>([](ITeachingTipStatics const& f) { return f.TargetProperty(); });
    }
    inline auto TeachingTip::TailVisibilityProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(ITeachingTipStatics const&), TeachingTip, ITeachingTipStatics>([](ITeachingTipStatics const& f) { return f.TailVisibilityProperty(); });
    }
    inline auto TeachingTip::TitleProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(ITeachingTipStatics const&), TeachingTip, ITeachingTipStatics>([](ITeachingTipStatics const& f) { return f.TitleProperty(); });
    }
    inline auto TeachingTip::SubtitleProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(ITeachingTipStatics const&), TeachingTip, ITeachingTipStatics>([](ITeachingTipStatics const& f) { return f.SubtitleProperty(); });
    }
    inline auto TeachingTip::ActionButtonContentProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(ITeachingTipStatics const&), TeachingTip, ITeachingTipStatics>([](ITeachingTipStatics const& f) { return f.ActionButtonContentProperty(); });
    }
    inline auto TeachingTip::ActionButtonStyleProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(ITeachingTipStatics const&), TeachingTip, ITeachingTipStatics>([](ITeachingTipStatics const& f) { return f.ActionButtonStyleProperty(); });
    }
    inline auto TeachingTip::ActionButtonCommandProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(ITeachingTipStatics const&), TeachingTip, ITeachingTipStatics>([](ITeachingTipStatics const& f) { return f.ActionButtonCommandProperty(); });
    }
    inline auto TeachingTip::ActionButtonCommandParameterProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(ITeachingTipStatics const&), TeachingTip, ITeachingTipStatics>([](ITeachingTipStatics const& f) { return f.ActionButtonCommandParameterProperty(); });
    }
    inline auto TeachingTip::CloseButtonContentProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(ITeachingTipStatics const&), TeachingTip, ITeachingTipStatics>([](ITeachingTipStatics const& f) { return f.CloseButtonContentProperty(); });
    }
    inline auto TeachingTip::CloseButtonStyleProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(ITeachingTipStatics const&), TeachingTip, ITeachingTipStatics>([](ITeachingTipStatics const& f) { return f.CloseButtonStyleProperty(); });
    }
    inline auto TeachingTip::CloseButtonCommandProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(ITeachingTipStatics const&), TeachingTip, ITeachingTipStatics>([](ITeachingTipStatics const& f) { return f.CloseButtonCommandProperty(); });
    }
    inline auto TeachingTip::CloseButtonCommandParameterProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(ITeachingTipStatics const&), TeachingTip, ITeachingTipStatics>([](ITeachingTipStatics const& f) { return f.CloseButtonCommandParameterProperty(); });
    }
    inline auto TeachingTip::PlacementMarginProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(ITeachingTipStatics const&), TeachingTip, ITeachingTipStatics>([](ITeachingTipStatics const& f) { return f.PlacementMarginProperty(); });
    }
    inline auto TeachingTip::ShouldConstrainToRootBoundsProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(ITeachingTipStatics const&), TeachingTip, ITeachingTipStatics>([](ITeachingTipStatics const& f) { return f.ShouldConstrainToRootBoundsProperty(); });
    }
    inline auto TeachingTip::IsLightDismissEnabledProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(ITeachingTipStatics const&), TeachingTip, ITeachingTipStatics>([](ITeachingTipStatics const& f) { return f.IsLightDismissEnabledProperty(); });
    }
    inline auto TeachingTip::PreferredPlacementProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(ITeachingTipStatics const&), TeachingTip, ITeachingTipStatics>([](ITeachingTipStatics const& f) { return f.PreferredPlacementProperty(); });
    }
    inline auto TeachingTip::HeroContentPlacementProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(ITeachingTipStatics const&), TeachingTip, ITeachingTipStatics>([](ITeachingTipStatics const& f) { return f.HeroContentPlacementProperty(); });
    }
    inline auto TeachingTip::HeroContentProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(ITeachingTipStatics const&), TeachingTip, ITeachingTipStatics>([](ITeachingTipStatics const& f) { return f.HeroContentProperty(); });
    }
    inline auto TeachingTip::IconSourceProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(ITeachingTipStatics const&), TeachingTip, ITeachingTipStatics>([](ITeachingTipStatics const& f) { return f.IconSourceProperty(); });
    }
    inline auto TeachingTip::TemplateSettingsProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(ITeachingTipStatics const&), TeachingTip, ITeachingTipStatics>([](ITeachingTipStatics const& f) { return f.TemplateSettingsProperty(); });
    }
    inline TeachingTipTemplateSettings::TeachingTipTemplateSettings()
    {
        winrt::Windows::Foundation::IInspectable baseInterface, innerInterface;
        *this = impl::call_factory<TeachingTipTemplateSettings, ITeachingTipTemplateSettingsFactory>([&](ITeachingTipTemplateSettingsFactory const& f) { return f.CreateInstance(baseInterface, innerInterface); });
    }
    inline auto TeachingTipTemplateSettings::TopRightHighlightMarginProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(ITeachingTipTemplateSettingsStatics const&), TeachingTipTemplateSettings, ITeachingTipTemplateSettingsStatics>([](ITeachingTipTemplateSettingsStatics const& f) { return f.TopRightHighlightMarginProperty(); });
    }
    inline auto TeachingTipTemplateSettings::TopLeftHighlightMarginProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(ITeachingTipTemplateSettingsStatics const&), TeachingTipTemplateSettings, ITeachingTipTemplateSettingsStatics>([](ITeachingTipTemplateSettingsStatics const& f) { return f.TopLeftHighlightMarginProperty(); });
    }
    inline auto TeachingTipTemplateSettings::IconElementProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(ITeachingTipTemplateSettingsStatics const&), TeachingTipTemplateSettings, ITeachingTipTemplateSettingsStatics>([](ITeachingTipTemplateSettingsStatics const& f) { return f.IconElementProperty(); });
    }
    inline TextCommandBarFlyout::TextCommandBarFlyout()
    {
        winrt::Windows::Foundation::IInspectable baseInterface, innerInterface;
        *this = impl::call_factory<TextCommandBarFlyout, ITextCommandBarFlyoutFactory>([&](ITextCommandBarFlyoutFactory const& f) { return f.CreateInstance(baseInterface, innerInterface); });
    }
    inline ToggleSplitButton::ToggleSplitButton()
    {
        winrt::Windows::Foundation::IInspectable baseInterface, innerInterface;
        *this = impl::call_factory<ToggleSplitButton, IToggleSplitButtonFactory>([&](IToggleSplitButtonFactory const& f) { return f.CreateInstance(baseInterface, innerInterface); });
    }
    inline auto ToggleSplitButton::IsCheckedProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(IToggleSplitButtonStatics const&), ToggleSplitButton, IToggleSplitButtonStatics>([](IToggleSplitButtonStatics const& f) { return f.IsCheckedProperty(); });
    }
    inline TreeView::TreeView()
    {
        winrt::Windows::Foundation::IInspectable baseInterface, innerInterface;
        *this = impl::call_factory<TreeView, ITreeViewFactory>([&](ITreeViewFactory const& f) { return f.CreateInstance(baseInterface, innerInterface); });
    }
    inline auto TreeView::SelectedItemProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(ITreeViewStatics const&), TreeView, ITreeViewStatics>([](ITreeViewStatics const& f) { return f.SelectedItemProperty(); });
    }
    inline auto TreeView::SelectionModeProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(ITreeViewStatics const&), TreeView, ITreeViewStatics>([](ITreeViewStatics const& f) { return f.SelectionModeProperty(); });
    }
    inline auto TreeView::CanDragItemsProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(ITreeViewStatics2 const&), TreeView, ITreeViewStatics2>([](ITreeViewStatics2 const& f) { return f.CanDragItemsProperty(); });
    }
    inline auto TreeView::CanReorderItemsProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(ITreeViewStatics2 const&), TreeView, ITreeViewStatics2>([](ITreeViewStatics2 const& f) { return f.CanReorderItemsProperty(); });
    }
    inline auto TreeView::ItemTemplateProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(ITreeViewStatics2 const&), TreeView, ITreeViewStatics2>([](ITreeViewStatics2 const& f) { return f.ItemTemplateProperty(); });
    }
    inline auto TreeView::ItemTemplateSelectorProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(ITreeViewStatics2 const&), TreeView, ITreeViewStatics2>([](ITreeViewStatics2 const& f) { return f.ItemTemplateSelectorProperty(); });
    }
    inline auto TreeView::ItemContainerStyleProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(ITreeViewStatics2 const&), TreeView, ITreeViewStatics2>([](ITreeViewStatics2 const& f) { return f.ItemContainerStyleProperty(); });
    }
    inline auto TreeView::ItemContainerStyleSelectorProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(ITreeViewStatics2 const&), TreeView, ITreeViewStatics2>([](ITreeViewStatics2 const& f) { return f.ItemContainerStyleSelectorProperty(); });
    }
    inline auto TreeView::ItemContainerTransitionsProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(ITreeViewStatics2 const&), TreeView, ITreeViewStatics2>([](ITreeViewStatics2 const& f) { return f.ItemContainerTransitionsProperty(); });
    }
    inline auto TreeView::ItemsSourceProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(ITreeViewStatics2 const&), TreeView, ITreeViewStatics2>([](ITreeViewStatics2 const& f) { return f.ItemsSourceProperty(); });
    }
    inline TreeViewItem::TreeViewItem()
    {
        winrt::Windows::Foundation::IInspectable baseInterface, innerInterface;
        *this = impl::call_factory<TreeViewItem, ITreeViewItemFactory>([&](ITreeViewItemFactory const& f) { return f.CreateInstance(baseInterface, innerInterface); });
    }
    inline auto TreeViewItem::GlyphOpacityProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(ITreeViewItemStatics const&), TreeViewItem, ITreeViewItemStatics>([](ITreeViewItemStatics const& f) { return f.GlyphOpacityProperty(); });
    }
    inline auto TreeViewItem::GlyphBrushProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(ITreeViewItemStatics const&), TreeViewItem, ITreeViewItemStatics>([](ITreeViewItemStatics const& f) { return f.GlyphBrushProperty(); });
    }
    inline auto TreeViewItem::ExpandedGlyphProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(ITreeViewItemStatics const&), TreeViewItem, ITreeViewItemStatics>([](ITreeViewItemStatics const& f) { return f.ExpandedGlyphProperty(); });
    }
    inline auto TreeViewItem::CollapsedGlyphProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(ITreeViewItemStatics const&), TreeViewItem, ITreeViewItemStatics>([](ITreeViewItemStatics const& f) { return f.CollapsedGlyphProperty(); });
    }
    inline auto TreeViewItem::GlyphSizeProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(ITreeViewItemStatics const&), TreeViewItem, ITreeViewItemStatics>([](ITreeViewItemStatics const& f) { return f.GlyphSizeProperty(); });
    }
    inline auto TreeViewItem::IsExpandedProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(ITreeViewItemStatics const&), TreeViewItem, ITreeViewItemStatics>([](ITreeViewItemStatics const& f) { return f.IsExpandedProperty(); });
    }
    inline auto TreeViewItem::TreeViewItemTemplateSettingsProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(ITreeViewItemStatics const&), TreeViewItem, ITreeViewItemStatics>([](ITreeViewItemStatics const& f) { return f.TreeViewItemTemplateSettingsProperty(); });
    }
    inline auto TreeViewItem::HasUnrealizedChildrenProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(ITreeViewItemStatics2 const&), TreeViewItem, ITreeViewItemStatics2>([](ITreeViewItemStatics2 const& f) { return f.HasUnrealizedChildrenProperty(); });
    }
    inline auto TreeViewItem::ItemsSourceProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(ITreeViewItemStatics2 const&), TreeViewItem, ITreeViewItemStatics2>([](ITreeViewItemStatics2 const& f) { return f.ItemsSourceProperty(); });
    }
    inline TreeViewItemTemplateSettings::TreeViewItemTemplateSettings()
    {
        winrt::Windows::Foundation::IInspectable baseInterface, innerInterface;
        *this = impl::call_factory<TreeViewItemTemplateSettings, ITreeViewItemTemplateSettingsFactory>([&](ITreeViewItemTemplateSettingsFactory const& f) { return f.CreateInstance(baseInterface, innerInterface); });
    }
    inline auto TreeViewItemTemplateSettings::ExpandedGlyphVisibilityProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(ITreeViewItemTemplateSettingsStatics const&), TreeViewItemTemplateSettings, ITreeViewItemTemplateSettingsStatics>([](ITreeViewItemTemplateSettingsStatics const& f) { return f.ExpandedGlyphVisibilityProperty(); });
    }
    inline auto TreeViewItemTemplateSettings::CollapsedGlyphVisibilityProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(ITreeViewItemTemplateSettingsStatics const&), TreeViewItemTemplateSettings, ITreeViewItemTemplateSettingsStatics>([](ITreeViewItemTemplateSettingsStatics const& f) { return f.CollapsedGlyphVisibilityProperty(); });
    }
    inline auto TreeViewItemTemplateSettings::IndentationProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(ITreeViewItemTemplateSettingsStatics const&), TreeViewItemTemplateSettings, ITreeViewItemTemplateSettingsStatics>([](ITreeViewItemTemplateSettingsStatics const& f) { return f.IndentationProperty(); });
    }
    inline auto TreeViewItemTemplateSettings::DragItemsCountProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(ITreeViewItemTemplateSettingsStatics const&), TreeViewItemTemplateSettings, ITreeViewItemTemplateSettingsStatics>([](ITreeViewItemTemplateSettingsStatics const& f) { return f.DragItemsCountProperty(); });
    }
    inline TreeViewList::TreeViewList()
    {
        winrt::Windows::Foundation::IInspectable baseInterface, innerInterface;
        *this = impl::call_factory<TreeViewList, ITreeViewListFactory>([&](ITreeViewListFactory const& f) { return f.CreateInstance(baseInterface, innerInterface); });
    }
    inline TreeViewNode::TreeViewNode()
    {
        winrt::Windows::Foundation::IInspectable baseInterface, innerInterface;
        *this = impl::call_factory<TreeViewNode, ITreeViewNodeFactory>([&](ITreeViewNodeFactory const& f) { return f.CreateInstance(baseInterface, innerInterface); });
    }
    inline auto TreeViewNode::ContentProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(ITreeViewNodeStatics const&), TreeViewNode, ITreeViewNodeStatics>([](ITreeViewNodeStatics const& f) { return f.ContentProperty(); });
    }
    inline auto TreeViewNode::DepthProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(ITreeViewNodeStatics const&), TreeViewNode, ITreeViewNodeStatics>([](ITreeViewNodeStatics const& f) { return f.DepthProperty(); });
    }
    inline auto TreeViewNode::IsExpandedProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(ITreeViewNodeStatics const&), TreeViewNode, ITreeViewNodeStatics>([](ITreeViewNodeStatics const& f) { return f.IsExpandedProperty(); });
    }
    inline auto TreeViewNode::HasChildrenProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(ITreeViewNodeStatics const&), TreeViewNode, ITreeViewNodeStatics>([](ITreeViewNodeStatics const& f) { return f.HasChildrenProperty(); });
    }
    inline TwoPaneView::TwoPaneView()
    {
        winrt::Windows::Foundation::IInspectable baseInterface, innerInterface;
        *this = impl::call_factory<TwoPaneView, ITwoPaneViewFactory>([&](ITwoPaneViewFactory const& f) { return f.CreateInstance(baseInterface, innerInterface); });
    }
    inline auto TwoPaneView::Pane1Property()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(ITwoPaneViewStatics const&), TwoPaneView, ITwoPaneViewStatics>([](ITwoPaneViewStatics const& f) { return f.Pane1Property(); });
    }
    inline auto TwoPaneView::Pane2Property()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(ITwoPaneViewStatics const&), TwoPaneView, ITwoPaneViewStatics>([](ITwoPaneViewStatics const& f) { return f.Pane2Property(); });
    }
    inline auto TwoPaneView::Pane1LengthProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(ITwoPaneViewStatics const&), TwoPaneView, ITwoPaneViewStatics>([](ITwoPaneViewStatics const& f) { return f.Pane1LengthProperty(); });
    }
    inline auto TwoPaneView::Pane2LengthProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(ITwoPaneViewStatics const&), TwoPaneView, ITwoPaneViewStatics>([](ITwoPaneViewStatics const& f) { return f.Pane2LengthProperty(); });
    }
    inline auto TwoPaneView::PanePriorityProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(ITwoPaneViewStatics const&), TwoPaneView, ITwoPaneViewStatics>([](ITwoPaneViewStatics const& f) { return f.PanePriorityProperty(); });
    }
    inline auto TwoPaneView::ModeProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(ITwoPaneViewStatics const&), TwoPaneView, ITwoPaneViewStatics>([](ITwoPaneViewStatics const& f) { return f.ModeProperty(); });
    }
    inline auto TwoPaneView::WideModeConfigurationProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(ITwoPaneViewStatics const&), TwoPaneView, ITwoPaneViewStatics>([](ITwoPaneViewStatics const& f) { return f.WideModeConfigurationProperty(); });
    }
    inline auto TwoPaneView::TallModeConfigurationProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(ITwoPaneViewStatics const&), TwoPaneView, ITwoPaneViewStatics>([](ITwoPaneViewStatics const& f) { return f.TallModeConfigurationProperty(); });
    }
    inline auto TwoPaneView::MinWideModeWidthProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(ITwoPaneViewStatics const&), TwoPaneView, ITwoPaneViewStatics>([](ITwoPaneViewStatics const& f) { return f.MinWideModeWidthProperty(); });
    }
    inline auto TwoPaneView::MinTallModeHeightProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(ITwoPaneViewStatics const&), TwoPaneView, ITwoPaneViewStatics>([](ITwoPaneViewStatics const& f) { return f.MinTallModeHeightProperty(); });
    }
    inline UniformGridLayout::UniformGridLayout()
    {
        winrt::Windows::Foundation::IInspectable baseInterface, innerInterface;
        *this = impl::call_factory<UniformGridLayout, IUniformGridLayoutFactory>([&](IUniformGridLayoutFactory const& f) { return f.CreateInstance(baseInterface, innerInterface); });
    }
    inline auto UniformGridLayout::OrientationProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(IUniformGridLayoutStatics const&), UniformGridLayout, IUniformGridLayoutStatics>([](IUniformGridLayoutStatics const& f) { return f.OrientationProperty(); });
    }
    inline auto UniformGridLayout::MinItemWidthProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(IUniformGridLayoutStatics const&), UniformGridLayout, IUniformGridLayoutStatics>([](IUniformGridLayoutStatics const& f) { return f.MinItemWidthProperty(); });
    }
    inline auto UniformGridLayout::MinItemHeightProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(IUniformGridLayoutStatics const&), UniformGridLayout, IUniformGridLayoutStatics>([](IUniformGridLayoutStatics const& f) { return f.MinItemHeightProperty(); });
    }
    inline auto UniformGridLayout::MinRowSpacingProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(IUniformGridLayoutStatics const&), UniformGridLayout, IUniformGridLayoutStatics>([](IUniformGridLayoutStatics const& f) { return f.MinRowSpacingProperty(); });
    }
    inline auto UniformGridLayout::MinColumnSpacingProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(IUniformGridLayoutStatics const&), UniformGridLayout, IUniformGridLayoutStatics>([](IUniformGridLayoutStatics const& f) { return f.MinColumnSpacingProperty(); });
    }
    inline auto UniformGridLayout::ItemsJustificationProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(IUniformGridLayoutStatics const&), UniformGridLayout, IUniformGridLayoutStatics>([](IUniformGridLayoutStatics const& f) { return f.ItemsJustificationProperty(); });
    }
    inline auto UniformGridLayout::ItemsStretchProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(IUniformGridLayoutStatics const&), UniformGridLayout, IUniformGridLayoutStatics>([](IUniformGridLayoutStatics const& f) { return f.ItemsStretchProperty(); });
    }
    inline auto UniformGridLayout::MaximumRowsOrColumnsProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(IUniformGridLayoutStatics const&), UniformGridLayout, IUniformGridLayoutStatics>([](IUniformGridLayoutStatics const& f) { return f.MaximumRowsOrColumnsProperty(); });
    }
    inline VirtualizingLayout::VirtualizingLayout()
    {
        winrt::Windows::Foundation::IInspectable baseInterface, innerInterface;
        *this = impl::call_factory<VirtualizingLayout, IVirtualizingLayoutFactory>([&](IVirtualizingLayoutFactory const& f) { return f.CreateInstance(baseInterface, innerInterface); });
    }
    inline VirtualizingLayoutContext::VirtualizingLayoutContext()
    {
        winrt::Windows::Foundation::IInspectable baseInterface, innerInterface;
        *this = impl::call_factory<VirtualizingLayoutContext, IVirtualizingLayoutContextFactory>([&](IVirtualizingLayoutContextFactory const& f) { return f.CreateInstance(baseInterface, innerInterface); });
    }
    inline WebView2::WebView2()
    {
        winrt::Windows::Foundation::IInspectable baseInterface, innerInterface;
        *this = impl::call_factory<WebView2, IWebView2Factory>([&](IWebView2Factory const& f) { return f.CreateInstance(baseInterface, innerInterface); });
    }
    inline auto WebView2::SourceProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(IWebView2Statics const&), WebView2, IWebView2Statics>([](IWebView2Statics const& f) { return f.SourceProperty(); });
    }
    inline auto WebView2::CanGoForwardProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(IWebView2Statics const&), WebView2, IWebView2Statics>([](IWebView2Statics const& f) { return f.CanGoForwardProperty(); });
    }
    inline auto WebView2::CanGoBackProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(IWebView2Statics const&), WebView2, IWebView2Statics>([](IWebView2Statics const& f) { return f.CanGoBackProperty(); });
    }
    inline XamlControlsResources::XamlControlsResources() :
        XamlControlsResources(impl::call_factory_cast<XamlControlsResources(*)(winrt::Windows::Foundation::IActivationFactory const&), XamlControlsResources>([](winrt::Windows::Foundation::IActivationFactory const& f) { return f.template ActivateInstance<XamlControlsResources>(); }))
    {
    }
    inline auto XamlControlsResources::EnsureRevealLights(winrt::Windows::UI::Xaml::UIElement const& element)
    {
        impl::call_factory<XamlControlsResources, IXamlControlsResourcesStatics>([&](IXamlControlsResourcesStatics const& f) { return f.EnsureRevealLights(element); });
    }
    inline auto XamlControlsResources::ControlsResourcesVersionProperty()
    {
        return impl::call_factory_cast<winrt::Windows::UI::Xaml::DependencyProperty(*)(IXamlControlsResourcesStatics3 const&), XamlControlsResources, IXamlControlsResourcesStatics3>([](IXamlControlsResourcesStatics3 const& f) { return f.ControlsResourcesVersionProperty(); });
    }
    template <typename D> auto IElementFactoryOverridesT<D>::GetElementCore(winrt::Microsoft::UI::Xaml::Controls::ElementFactoryGetArgs const& args) const
    {
        return shim().template try_as<IElementFactoryOverrides>().GetElementCore(args);
    }
    template <typename D> auto IElementFactoryOverridesT<D>::RecycleElementCore(winrt::Microsoft::UI::Xaml::Controls::ElementFactoryRecycleArgs const& args) const
    {
        return shim().template try_as<IElementFactoryOverrides>().RecycleElementCore(args);
    }
    template <typename D> auto ILayoutContextOverridesT<D>::LayoutStateCore() const
    {
        return shim().template try_as<ILayoutContextOverrides>().LayoutStateCore();
    }
    template <typename D> auto ILayoutContextOverridesT<D>::LayoutStateCore(winrt::Windows::Foundation::IInspectable const& value) const
    {
        return shim().template try_as<ILayoutContextOverrides>().LayoutStateCore(value);
    }
    template <typename D> auto INonVirtualizingLayoutOverridesT<D>::InitializeForContextCore(winrt::Microsoft::UI::Xaml::Controls::NonVirtualizingLayoutContext const& context) const
    {
        return shim().template try_as<INonVirtualizingLayoutOverrides>().InitializeForContextCore(context);
    }
    template <typename D> auto INonVirtualizingLayoutOverridesT<D>::UninitializeForContextCore(winrt::Microsoft::UI::Xaml::Controls::NonVirtualizingLayoutContext const& context) const
    {
        return shim().template try_as<INonVirtualizingLayoutOverrides>().UninitializeForContextCore(context);
    }
    template <typename D> auto INonVirtualizingLayoutOverridesT<D>::MeasureOverride(winrt::Microsoft::UI::Xaml::Controls::NonVirtualizingLayoutContext const& context, winrt::Windows::Foundation::Size const& availableSize) const
    {
        return shim().template try_as<INonVirtualizingLayoutOverrides>().MeasureOverride(context, availableSize);
    }
    template <typename D> auto INonVirtualizingLayoutOverridesT<D>::ArrangeOverride(winrt::Microsoft::UI::Xaml::Controls::NonVirtualizingLayoutContext const& context, winrt::Windows::Foundation::Size const& finalSize) const
    {
        return shim().template try_as<INonVirtualizingLayoutOverrides>().ArrangeOverride(context, finalSize);
    }
    template <typename D> auto INonVirtualizingLayoutContextOverridesT<D>::ChildrenCore() const
    {
        return shim().template try_as<INonVirtualizingLayoutContextOverrides>().ChildrenCore();
    }
    template <typename D> auto IVirtualizingLayoutOverridesT<D>::InitializeForContextCore(winrt::Microsoft::UI::Xaml::Controls::VirtualizingLayoutContext const& context) const
    {
        return shim().template try_as<IVirtualizingLayoutOverrides>().InitializeForContextCore(context);
    }
    template <typename D> auto IVirtualizingLayoutOverridesT<D>::UninitializeForContextCore(winrt::Microsoft::UI::Xaml::Controls::VirtualizingLayoutContext const& context) const
    {
        return shim().template try_as<IVirtualizingLayoutOverrides>().UninitializeForContextCore(context);
    }
    template <typename D> auto IVirtualizingLayoutOverridesT<D>::MeasureOverride(winrt::Microsoft::UI::Xaml::Controls::VirtualizingLayoutContext const& context, winrt::Windows::Foundation::Size const& availableSize) const
    {
        return shim().template try_as<IVirtualizingLayoutOverrides>().MeasureOverride(context, availableSize);
    }
    template <typename D> auto IVirtualizingLayoutOverridesT<D>::ArrangeOverride(winrt::Microsoft::UI::Xaml::Controls::VirtualizingLayoutContext const& context, winrt::Windows::Foundation::Size const& finalSize) const
    {
        return shim().template try_as<IVirtualizingLayoutOverrides>().ArrangeOverride(context, finalSize);
    }
    template <typename D> auto IVirtualizingLayoutOverridesT<D>::OnItemsChangedCore(winrt::Microsoft::UI::Xaml::Controls::VirtualizingLayoutContext const& context, winrt::Windows::Foundation::IInspectable const& source, winrt::Windows::UI::Xaml::Interop::NotifyCollectionChangedEventArgs const& args) const
    {
        return shim().template try_as<IVirtualizingLayoutOverrides>().OnItemsChangedCore(context, source, args);
    }
    template <typename D> auto IVirtualizingLayoutContextOverridesT<D>::ItemCountCore() const
    {
        return shim().template try_as<IVirtualizingLayoutContextOverrides>().ItemCountCore();
    }
    template <typename D> auto IVirtualizingLayoutContextOverridesT<D>::GetItemAtCore(int32_t index) const
    {
        return shim().template try_as<IVirtualizingLayoutContextOverrides>().GetItemAtCore(index);
    }
    template <typename D> auto IVirtualizingLayoutContextOverridesT<D>::RealizationRectCore() const
    {
        return shim().template try_as<IVirtualizingLayoutContextOverrides>().RealizationRectCore();
    }
    template <typename D> auto IVirtualizingLayoutContextOverridesT<D>::GetOrCreateElementAtCore(int32_t index, winrt::Microsoft::UI::Xaml::Controls::ElementRealizationOptions const& options) const
    {
        return shim().template try_as<IVirtualizingLayoutContextOverrides>().GetOrCreateElementAtCore(index, options);
    }
    template <typename D> auto IVirtualizingLayoutContextOverridesT<D>::RecycleElementCore(winrt::Windows::UI::Xaml::UIElement const& element) const
    {
        return shim().template try_as<IVirtualizingLayoutContextOverrides>().RecycleElementCore(element);
    }
    template <typename D> auto IVirtualizingLayoutContextOverridesT<D>::RecommendedAnchorIndexCore() const
    {
        return shim().template try_as<IVirtualizingLayoutContextOverrides>().RecommendedAnchorIndexCore();
    }
    template <typename D> auto IVirtualizingLayoutContextOverridesT<D>::LayoutOriginCore() const
    {
        return shim().template try_as<IVirtualizingLayoutContextOverrides>().LayoutOriginCore();
    }
    template <typename D> auto IVirtualizingLayoutContextOverridesT<D>::LayoutOriginCore(winrt::Windows::Foundation::Point const& value) const
    {
        return shim().template try_as<IVirtualizingLayoutContextOverrides>().LayoutOriginCore(value);
    }
    template <typename D, typename... Interfaces>
    struct AnimatedIconT :
        implements<D, winrt::Windows::UI::Xaml::IFrameworkElementOverrides, winrt::Windows::UI::Xaml::IFrameworkElementOverrides2, winrt::Windows::UI::Xaml::IUIElementOverrides, winrt::Windows::UI::Xaml::IUIElementOverrides7, winrt::Windows::UI::Xaml::IUIElementOverrides8, winrt::Windows::UI::Xaml::IUIElementOverrides9, composing, Interfaces...>,
        impl::require<D, winrt::Microsoft::UI::Xaml::Controls::IAnimatedIcon, winrt::Windows::UI::Xaml::Controls::IIconElement, winrt::Windows::UI::Xaml::IFrameworkElement, winrt::Windows::UI::Xaml::IFrameworkElement2, winrt::Windows::UI::Xaml::IFrameworkElement3, winrt::Windows::UI::Xaml::IFrameworkElement4, winrt::Windows::UI::Xaml::IFrameworkElement6, winrt::Windows::UI::Xaml::IFrameworkElement7, winrt::Windows::UI::Xaml::IUIElement, winrt::Windows::UI::Xaml::IUIElement2, winrt::Windows::UI::Xaml::IUIElement3, winrt::Windows::UI::Xaml::IUIElement4, winrt::Windows::UI::Xaml::IUIElement5, winrt::Windows::UI::Xaml::IUIElement7, winrt::Windows::UI::Xaml::IUIElement8, winrt::Windows::UI::Xaml::IUIElement9, winrt::Windows::UI::Xaml::IUIElement10, winrt::Windows::UI::Composition::IAnimationObject, winrt::Windows::UI::Composition::IVisualElement, winrt::Windows::UI::Xaml::IDependencyObject, winrt::Windows::UI::Xaml::IDependencyObject2>,
        protected impl::require<D, winrt::Windows::UI::Xaml::IFrameworkElementProtected7>,
        impl::base<D, AnimatedIcon, winrt::Windows::UI::Xaml::Controls::IconElement, winrt::Windows::UI::Xaml::FrameworkElement, winrt::Windows::UI::Xaml::UIElement, winrt::Windows::UI::Xaml::DependencyObject>,
        winrt::Windows::UI::Xaml::IFrameworkElementOverridesT<D>, winrt::Windows::UI::Xaml::IFrameworkElementOverrides2T<D>, winrt::Windows::UI::Xaml::IUIElementOverridesT<D>, winrt::Windows::UI::Xaml::IUIElementOverrides7T<D>, winrt::Windows::UI::Xaml::IUIElementOverrides8T<D>, winrt::Windows::UI::Xaml::IUIElementOverrides9T<D>
    {
        using composable = AnimatedIcon;
        friend impl::consume_t<D, winrt::Windows::UI::Xaml::IFrameworkElementProtected7>;
        friend impl::require_one<D, winrt::Windows::UI::Xaml::IFrameworkElementProtected7>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::IFrameworkElementOverrides>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::IFrameworkElementOverrides2>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::IUIElementOverrides>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::IUIElementOverrides7>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::IUIElementOverrides8>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::IUIElementOverrides9>;
    protected:
        AnimatedIconT()
        {
            impl::call_factory<AnimatedIcon, IAnimatedIconFactory>([&](IAnimatedIconFactory const& f) { [[maybe_unused]] auto winrt_impl_discarded = f.CreateInstance(*this, this->m_inner); });
        }
    };
    template <typename D, typename... Interfaces>
    struct AnimatedIconSourceT :
        implements<D, winrt::Windows::Foundation::IInspectable, composing, Interfaces...>,
        impl::require<D, winrt::Microsoft::UI::Xaml::Controls::IAnimatedIconSource, winrt::Microsoft::UI::Xaml::Controls::IIconSource, winrt::Windows::UI::Xaml::IDependencyObject, winrt::Windows::UI::Xaml::IDependencyObject2>,
        impl::base<D, AnimatedIconSource, winrt::Microsoft::UI::Xaml::Controls::IconSource, winrt::Windows::UI::Xaml::DependencyObject>
    {
        using composable = AnimatedIconSource;
    protected:
        AnimatedIconSourceT()
        {
            impl::call_factory<AnimatedIconSource, IAnimatedIconSourceFactory>([&](IAnimatedIconSourceFactory const& f) { [[maybe_unused]] auto winrt_impl_discarded = f.CreateInstance(*this, this->m_inner); });
        }
    };
    template <typename D, typename... Interfaces>
    struct AnimatedVisualPlayerT :
        implements<D, winrt::Windows::UI::Xaml::IFrameworkElementOverrides, winrt::Windows::UI::Xaml::IFrameworkElementOverrides2, winrt::Windows::UI::Xaml::IUIElementOverrides, winrt::Windows::UI::Xaml::IUIElementOverrides7, winrt::Windows::UI::Xaml::IUIElementOverrides8, winrt::Windows::UI::Xaml::IUIElementOverrides9, composing, Interfaces...>,
        impl::require<D, winrt::Microsoft::UI::Xaml::Controls::IAnimatedVisualPlayer, winrt::Microsoft::UI::Xaml::Controls::IAnimatedVisualPlayer2, winrt::Windows::UI::Xaml::IFrameworkElement, winrt::Windows::UI::Xaml::IFrameworkElement2, winrt::Windows::UI::Xaml::IFrameworkElement3, winrt::Windows::UI::Xaml::IFrameworkElement4, winrt::Windows::UI::Xaml::IFrameworkElement6, winrt::Windows::UI::Xaml::IFrameworkElement7, winrt::Windows::UI::Xaml::IUIElement, winrt::Windows::UI::Xaml::IUIElement2, winrt::Windows::UI::Xaml::IUIElement3, winrt::Windows::UI::Xaml::IUIElement4, winrt::Windows::UI::Xaml::IUIElement5, winrt::Windows::UI::Xaml::IUIElement7, winrt::Windows::UI::Xaml::IUIElement8, winrt::Windows::UI::Xaml::IUIElement9, winrt::Windows::UI::Xaml::IUIElement10, winrt::Windows::UI::Composition::IAnimationObject, winrt::Windows::UI::Composition::IVisualElement, winrt::Windows::UI::Xaml::IDependencyObject, winrt::Windows::UI::Xaml::IDependencyObject2>,
        protected impl::require<D, winrt::Windows::UI::Xaml::IFrameworkElementProtected7>,
        impl::base<D, AnimatedVisualPlayer, winrt::Windows::UI::Xaml::FrameworkElement, winrt::Windows::UI::Xaml::UIElement, winrt::Windows::UI::Xaml::DependencyObject>,
        winrt::Windows::UI::Xaml::IFrameworkElementOverridesT<D>, winrt::Windows::UI::Xaml::IFrameworkElementOverrides2T<D>, winrt::Windows::UI::Xaml::IUIElementOverridesT<D>, winrt::Windows::UI::Xaml::IUIElementOverrides7T<D>, winrt::Windows::UI::Xaml::IUIElementOverrides8T<D>, winrt::Windows::UI::Xaml::IUIElementOverrides9T<D>
    {
        using composable = AnimatedVisualPlayer;
        friend impl::consume_t<D, winrt::Windows::UI::Xaml::IFrameworkElementProtected7>;
        friend impl::require_one<D, winrt::Windows::UI::Xaml::IFrameworkElementProtected7>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::IFrameworkElementOverrides>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::IFrameworkElementOverrides2>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::IUIElementOverrides>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::IUIElementOverrides7>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::IUIElementOverrides8>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::IUIElementOverrides9>;
    protected:
        AnimatedVisualPlayerT()
        {
            impl::call_factory<AnimatedVisualPlayer, IAnimatedVisualPlayerFactory>([&](IAnimatedVisualPlayerFactory const& f) { [[maybe_unused]] auto winrt_impl_discarded = f.CreateInstance(*this, this->m_inner); });
        }
    };
    template <typename D, typename... Interfaces>
    struct BitmapIconSourceT :
        implements<D, winrt::Windows::Foundation::IInspectable, composing, Interfaces...>,
        impl::require<D, winrt::Microsoft::UI::Xaml::Controls::IBitmapIconSource, winrt::Microsoft::UI::Xaml::Controls::IIconSource, winrt::Windows::UI::Xaml::IDependencyObject, winrt::Windows::UI::Xaml::IDependencyObject2>,
        impl::base<D, BitmapIconSource, winrt::Microsoft::UI::Xaml::Controls::IconSource, winrt::Windows::UI::Xaml::DependencyObject>
    {
        using composable = BitmapIconSource;
    protected:
        BitmapIconSourceT()
        {
            impl::call_factory<BitmapIconSource, IBitmapIconSourceFactory>([&](IBitmapIconSourceFactory const& f) { [[maybe_unused]] auto winrt_impl_discarded = f.CreateInstance(*this, this->m_inner); });
        }
    };
    template <typename D, typename... Interfaces>
    struct BreadcrumbBarT :
        implements<D, winrt::Windows::UI::Xaml::Controls::IControlOverrides, winrt::Windows::UI::Xaml::Controls::IControlOverrides6, winrt::Windows::UI::Xaml::IFrameworkElementOverrides, winrt::Windows::UI::Xaml::IFrameworkElementOverrides2, winrt::Windows::UI::Xaml::IUIElementOverrides, winrt::Windows::UI::Xaml::IUIElementOverrides7, winrt::Windows::UI::Xaml::IUIElementOverrides8, winrt::Windows::UI::Xaml::IUIElementOverrides9, composing, Interfaces...>,
        impl::require<D, winrt::Microsoft::UI::Xaml::Controls::IBreadcrumbBar, winrt::Windows::UI::Xaml::Controls::IControl, winrt::Windows::UI::Xaml::Controls::IControl2, winrt::Windows::UI::Xaml::Controls::IControl3, winrt::Windows::UI::Xaml::Controls::IControl4, winrt::Windows::UI::Xaml::Controls::IControl5, winrt::Windows::UI::Xaml::Controls::IControl7, winrt::Windows::UI::Xaml::IFrameworkElement, winrt::Windows::UI::Xaml::IFrameworkElement2, winrt::Windows::UI::Xaml::IFrameworkElement3, winrt::Windows::UI::Xaml::IFrameworkElement4, winrt::Windows::UI::Xaml::IFrameworkElement6, winrt::Windows::UI::Xaml::IFrameworkElement7, winrt::Windows::UI::Xaml::IUIElement, winrt::Windows::UI::Xaml::IUIElement2, winrt::Windows::UI::Xaml::IUIElement3, winrt::Windows::UI::Xaml::IUIElement4, winrt::Windows::UI::Xaml::IUIElement5, winrt::Windows::UI::Xaml::IUIElement7, winrt::Windows::UI::Xaml::IUIElement8, winrt::Windows::UI::Xaml::IUIElement9, winrt::Windows::UI::Xaml::IUIElement10, winrt::Windows::UI::Composition::IAnimationObject, winrt::Windows::UI::Composition::IVisualElement, winrt::Windows::UI::Xaml::IDependencyObject, winrt::Windows::UI::Xaml::IDependencyObject2>,
        protected impl::require<D, winrt::Windows::UI::Xaml::Controls::IControlProtected, winrt::Windows::UI::Xaml::IFrameworkElementProtected7>,
        impl::base<D, BreadcrumbBar, winrt::Windows::UI::Xaml::Controls::Control, winrt::Windows::UI::Xaml::FrameworkElement, winrt::Windows::UI::Xaml::UIElement, winrt::Windows::UI::Xaml::DependencyObject>,
        winrt::Windows::UI::Xaml::Controls::IControlOverridesT<D>, winrt::Windows::UI::Xaml::Controls::IControlOverrides6T<D>, winrt::Windows::UI::Xaml::IFrameworkElementOverridesT<D>, winrt::Windows::UI::Xaml::IFrameworkElementOverrides2T<D>, winrt::Windows::UI::Xaml::IUIElementOverridesT<D>, winrt::Windows::UI::Xaml::IUIElementOverrides7T<D>, winrt::Windows::UI::Xaml::IUIElementOverrides8T<D>, winrt::Windows::UI::Xaml::IUIElementOverrides9T<D>
    {
        using composable = BreadcrumbBar;
        friend impl::consume_t<D, winrt::Windows::UI::Xaml::Controls::IControlProtected>;
        friend impl::require_one<D, winrt::Windows::UI::Xaml::Controls::IControlProtected>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::Controls::IControlOverrides>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::Controls::IControlOverrides6>;
        friend impl::consume_t<D, winrt::Windows::UI::Xaml::IFrameworkElementProtected7>;
        friend impl::require_one<D, winrt::Windows::UI::Xaml::IFrameworkElementProtected7>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::IFrameworkElementOverrides>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::IFrameworkElementOverrides2>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::IUIElementOverrides>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::IUIElementOverrides7>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::IUIElementOverrides8>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::IUIElementOverrides9>;
    protected:
        BreadcrumbBarT()
        {
            impl::call_factory<BreadcrumbBar, IBreadcrumbBarFactory>([&](IBreadcrumbBarFactory const& f) { [[maybe_unused]] auto winrt_impl_discarded = f.CreateInstance(*this, this->m_inner); });
        }
    };
    template <typename D, typename... Interfaces>
    struct BreadcrumbBarItemT :
        implements<D, winrt::Windows::UI::Xaml::Controls::IContentControlOverrides, winrt::Windows::UI::Xaml::Controls::IControlOverrides, winrt::Windows::UI::Xaml::Controls::IControlOverrides6, winrt::Windows::UI::Xaml::IFrameworkElementOverrides, winrt::Windows::UI::Xaml::IFrameworkElementOverrides2, winrt::Windows::UI::Xaml::IUIElementOverrides, winrt::Windows::UI::Xaml::IUIElementOverrides7, winrt::Windows::UI::Xaml::IUIElementOverrides8, winrt::Windows::UI::Xaml::IUIElementOverrides9, composing, Interfaces...>,
        impl::require<D, winrt::Microsoft::UI::Xaml::Controls::IBreadcrumbBarItem, winrt::Windows::UI::Xaml::Controls::IContentControl, winrt::Windows::UI::Xaml::Controls::IContentControl2, winrt::Windows::UI::Xaml::Controls::IControl, winrt::Windows::UI::Xaml::Controls::IControl2, winrt::Windows::UI::Xaml::Controls::IControl3, winrt::Windows::UI::Xaml::Controls::IControl4, winrt::Windows::UI::Xaml::Controls::IControl5, winrt::Windows::UI::Xaml::Controls::IControl7, winrt::Windows::UI::Xaml::IFrameworkElement, winrt::Windows::UI::Xaml::IFrameworkElement2, winrt::Windows::UI::Xaml::IFrameworkElement3, winrt::Windows::UI::Xaml::IFrameworkElement4, winrt::Windows::UI::Xaml::IFrameworkElement6, winrt::Windows::UI::Xaml::IFrameworkElement7, winrt::Windows::UI::Xaml::IUIElement, winrt::Windows::UI::Xaml::IUIElement2, winrt::Windows::UI::Xaml::IUIElement3, winrt::Windows::UI::Xaml::IUIElement4, winrt::Windows::UI::Xaml::IUIElement5, winrt::Windows::UI::Xaml::IUIElement7, winrt::Windows::UI::Xaml::IUIElement8, winrt::Windows::UI::Xaml::IUIElement9, winrt::Windows::UI::Xaml::IUIElement10, winrt::Windows::UI::Composition::IAnimationObject, winrt::Windows::UI::Composition::IVisualElement, winrt::Windows::UI::Xaml::IDependencyObject, winrt::Windows::UI::Xaml::IDependencyObject2>,
        protected impl::require<D, winrt::Windows::UI::Xaml::Controls::IControlProtected, winrt::Windows::UI::Xaml::IFrameworkElementProtected7>,
        impl::base<D, BreadcrumbBarItem, winrt::Windows::UI::Xaml::Controls::ContentControl, winrt::Windows::UI::Xaml::Controls::Control, winrt::Windows::UI::Xaml::FrameworkElement, winrt::Windows::UI::Xaml::UIElement, winrt::Windows::UI::Xaml::DependencyObject>,
        winrt::Windows::UI::Xaml::Controls::IContentControlOverridesT<D>, winrt::Windows::UI::Xaml::Controls::IControlOverridesT<D>, winrt::Windows::UI::Xaml::Controls::IControlOverrides6T<D>, winrt::Windows::UI::Xaml::IFrameworkElementOverridesT<D>, winrt::Windows::UI::Xaml::IFrameworkElementOverrides2T<D>, winrt::Windows::UI::Xaml::IUIElementOverridesT<D>, winrt::Windows::UI::Xaml::IUIElementOverrides7T<D>, winrt::Windows::UI::Xaml::IUIElementOverrides8T<D>, winrt::Windows::UI::Xaml::IUIElementOverrides9T<D>
    {
        using composable = BreadcrumbBarItem;
        friend impl::produce<D, winrt::Windows::UI::Xaml::Controls::IContentControlOverrides>;
        friend impl::consume_t<D, winrt::Windows::UI::Xaml::Controls::IControlProtected>;
        friend impl::require_one<D, winrt::Windows::UI::Xaml::Controls::IControlProtected>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::Controls::IControlOverrides>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::Controls::IControlOverrides6>;
        friend impl::consume_t<D, winrt::Windows::UI::Xaml::IFrameworkElementProtected7>;
        friend impl::require_one<D, winrt::Windows::UI::Xaml::IFrameworkElementProtected7>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::IFrameworkElementOverrides>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::IFrameworkElementOverrides2>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::IUIElementOverrides>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::IUIElementOverrides7>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::IUIElementOverrides8>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::IUIElementOverrides9>;
    protected:
        BreadcrumbBarItemT()
        {
            impl::call_factory<BreadcrumbBarItem, IBreadcrumbBarItemFactory>([&](IBreadcrumbBarItemFactory const& f) { [[maybe_unused]] auto winrt_impl_discarded = f.CreateInstance(*this, this->m_inner); });
        }
    };
    template <typename D, typename... Interfaces>
    struct ColorPickerT :
        implements<D, winrt::Windows::UI::Xaml::Controls::IControlOverrides, winrt::Windows::UI::Xaml::Controls::IControlOverrides6, winrt::Windows::UI::Xaml::IFrameworkElementOverrides, winrt::Windows::UI::Xaml::IFrameworkElementOverrides2, winrt::Windows::UI::Xaml::IUIElementOverrides, winrt::Windows::UI::Xaml::IUIElementOverrides7, winrt::Windows::UI::Xaml::IUIElementOverrides8, winrt::Windows::UI::Xaml::IUIElementOverrides9, composing, Interfaces...>,
        impl::require<D, winrt::Microsoft::UI::Xaml::Controls::IColorPicker, winrt::Microsoft::UI::Xaml::Controls::IColorPicker2, winrt::Windows::UI::Xaml::Controls::IControl, winrt::Windows::UI::Xaml::Controls::IControl2, winrt::Windows::UI::Xaml::Controls::IControl3, winrt::Windows::UI::Xaml::Controls::IControl4, winrt::Windows::UI::Xaml::Controls::IControl5, winrt::Windows::UI::Xaml::Controls::IControl7, winrt::Windows::UI::Xaml::IFrameworkElement, winrt::Windows::UI::Xaml::IFrameworkElement2, winrt::Windows::UI::Xaml::IFrameworkElement3, winrt::Windows::UI::Xaml::IFrameworkElement4, winrt::Windows::UI::Xaml::IFrameworkElement6, winrt::Windows::UI::Xaml::IFrameworkElement7, winrt::Windows::UI::Xaml::IUIElement, winrt::Windows::UI::Xaml::IUIElement2, winrt::Windows::UI::Xaml::IUIElement3, winrt::Windows::UI::Xaml::IUIElement4, winrt::Windows::UI::Xaml::IUIElement5, winrt::Windows::UI::Xaml::IUIElement7, winrt::Windows::UI::Xaml::IUIElement8, winrt::Windows::UI::Xaml::IUIElement9, winrt::Windows::UI::Xaml::IUIElement10, winrt::Windows::UI::Composition::IAnimationObject, winrt::Windows::UI::Composition::IVisualElement, winrt::Windows::UI::Xaml::IDependencyObject, winrt::Windows::UI::Xaml::IDependencyObject2>,
        protected impl::require<D, winrt::Windows::UI::Xaml::Controls::IControlProtected, winrt::Windows::UI::Xaml::IFrameworkElementProtected7>,
        impl::base<D, ColorPicker, winrt::Windows::UI::Xaml::Controls::Control, winrt::Windows::UI::Xaml::FrameworkElement, winrt::Windows::UI::Xaml::UIElement, winrt::Windows::UI::Xaml::DependencyObject>,
        winrt::Windows::UI::Xaml::Controls::IControlOverridesT<D>, winrt::Windows::UI::Xaml::Controls::IControlOverrides6T<D>, winrt::Windows::UI::Xaml::IFrameworkElementOverridesT<D>, winrt::Windows::UI::Xaml::IFrameworkElementOverrides2T<D>, winrt::Windows::UI::Xaml::IUIElementOverridesT<D>, winrt::Windows::UI::Xaml::IUIElementOverrides7T<D>, winrt::Windows::UI::Xaml::IUIElementOverrides8T<D>, winrt::Windows::UI::Xaml::IUIElementOverrides9T<D>
    {
        using composable = ColorPicker;
        friend impl::consume_t<D, winrt::Windows::UI::Xaml::Controls::IControlProtected>;
        friend impl::require_one<D, winrt::Windows::UI::Xaml::Controls::IControlProtected>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::Controls::IControlOverrides>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::Controls::IControlOverrides6>;
        friend impl::consume_t<D, winrt::Windows::UI::Xaml::IFrameworkElementProtected7>;
        friend impl::require_one<D, winrt::Windows::UI::Xaml::IFrameworkElementProtected7>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::IFrameworkElementOverrides>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::IFrameworkElementOverrides2>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::IUIElementOverrides>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::IUIElementOverrides7>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::IUIElementOverrides8>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::IUIElementOverrides9>;
    protected:
        ColorPickerT()
        {
            impl::call_factory<ColorPicker, IColorPickerFactory>([&](IColorPickerFactory const& f) { [[maybe_unused]] auto winrt_impl_discarded = f.CreateInstance(*this, this->m_inner); });
        }
    };
    template <typename D, typename... Interfaces>
    struct CommandBarFlyoutT :
        implements<D, winrt::Windows::UI::Xaml::Controls::Primitives::IFlyoutBaseOverrides, winrt::Windows::UI::Xaml::Controls::Primitives::IFlyoutBaseOverrides4, composing, Interfaces...>,
        impl::require<D, winrt::Microsoft::UI::Xaml::Controls::ICommandBarFlyout, winrt::Microsoft::UI::Xaml::Controls::ICommandBarFlyout2, winrt::Windows::UI::Xaml::Controls::Primitives::IFlyoutBase, winrt::Windows::UI::Xaml::Controls::Primitives::IFlyoutBase2, winrt::Windows::UI::Xaml::Controls::Primitives::IFlyoutBase3, winrt::Windows::UI::Xaml::Controls::Primitives::IFlyoutBase4, winrt::Windows::UI::Xaml::Controls::Primitives::IFlyoutBase5, winrt::Windows::UI::Xaml::Controls::Primitives::IFlyoutBase6, winrt::Windows::UI::Xaml::IDependencyObject, winrt::Windows::UI::Xaml::IDependencyObject2>,
        impl::base<D, CommandBarFlyout, winrt::Windows::UI::Xaml::Controls::Primitives::FlyoutBase, winrt::Windows::UI::Xaml::DependencyObject>,
        winrt::Windows::UI::Xaml::Controls::Primitives::IFlyoutBaseOverridesT<D>, winrt::Windows::UI::Xaml::Controls::Primitives::IFlyoutBaseOverrides4T<D>
    {
        using composable = CommandBarFlyout;
        friend impl::produce<D, winrt::Windows::UI::Xaml::Controls::Primitives::IFlyoutBaseOverrides>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::Controls::Primitives::IFlyoutBaseOverrides4>;
    protected:
        CommandBarFlyoutT()
        {
            impl::call_factory<CommandBarFlyout, ICommandBarFlyoutFactory>([&](ICommandBarFlyoutFactory const& f) { [[maybe_unused]] auto winrt_impl_discarded = f.CreateInstance(*this, this->m_inner); });
        }
        using impl::consume_t<D, winrt::Windows::UI::Xaml::Controls::Primitives::IFlyoutBase>::ShowAt;
        using impl::consume_t<D, winrt::Windows::UI::Xaml::Controls::Primitives::IFlyoutBase5>::ShowAt;
    };
    template <typename D, typename... Interfaces>
    struct DropDownButtonT :
        implements<D, winrt::Windows::UI::Xaml::Controls::IContentControlOverrides, winrt::Windows::UI::Xaml::Controls::IControlOverrides, winrt::Windows::UI::Xaml::Controls::IControlOverrides6, winrt::Windows::UI::Xaml::IFrameworkElementOverrides, winrt::Windows::UI::Xaml::IFrameworkElementOverrides2, winrt::Windows::UI::Xaml::IUIElementOverrides, winrt::Windows::UI::Xaml::IUIElementOverrides7, winrt::Windows::UI::Xaml::IUIElementOverrides8, winrt::Windows::UI::Xaml::IUIElementOverrides9, composing, Interfaces...>,
        impl::require<D, winrt::Microsoft::UI::Xaml::Controls::IDropDownButton, winrt::Windows::UI::Xaml::Controls::IButton, winrt::Windows::UI::Xaml::Controls::IButtonWithFlyout, winrt::Windows::UI::Xaml::Controls::Primitives::IButtonBase, winrt::Windows::UI::Xaml::Controls::IContentControl, winrt::Windows::UI::Xaml::Controls::IContentControl2, winrt::Windows::UI::Xaml::Controls::IControl, winrt::Windows::UI::Xaml::Controls::IControl2, winrt::Windows::UI::Xaml::Controls::IControl3, winrt::Windows::UI::Xaml::Controls::IControl4, winrt::Windows::UI::Xaml::Controls::IControl5, winrt::Windows::UI::Xaml::Controls::IControl7, winrt::Windows::UI::Xaml::IFrameworkElement, winrt::Windows::UI::Xaml::IFrameworkElement2, winrt::Windows::UI::Xaml::IFrameworkElement3, winrt::Windows::UI::Xaml::IFrameworkElement4, winrt::Windows::UI::Xaml::IFrameworkElement6, winrt::Windows::UI::Xaml::IFrameworkElement7, winrt::Windows::UI::Xaml::IUIElement, winrt::Windows::UI::Xaml::IUIElement2, winrt::Windows::UI::Xaml::IUIElement3, winrt::Windows::UI::Xaml::IUIElement4, winrt::Windows::UI::Xaml::IUIElement5, winrt::Windows::UI::Xaml::IUIElement7, winrt::Windows::UI::Xaml::IUIElement8, winrt::Windows::UI::Xaml::IUIElement9, winrt::Windows::UI::Xaml::IUIElement10, winrt::Windows::UI::Composition::IAnimationObject, winrt::Windows::UI::Composition::IVisualElement, winrt::Windows::UI::Xaml::IDependencyObject, winrt::Windows::UI::Xaml::IDependencyObject2>,
        protected impl::require<D, winrt::Windows::UI::Xaml::Controls::IControlProtected, winrt::Windows::UI::Xaml::IFrameworkElementProtected7>,
        impl::base<D, DropDownButton, winrt::Windows::UI::Xaml::Controls::Button, winrt::Windows::UI::Xaml::Controls::Primitives::ButtonBase, winrt::Windows::UI::Xaml::Controls::ContentControl, winrt::Windows::UI::Xaml::Controls::Control, winrt::Windows::UI::Xaml::FrameworkElement, winrt::Windows::UI::Xaml::UIElement, winrt::Windows::UI::Xaml::DependencyObject>,
        winrt::Windows::UI::Xaml::Controls::IContentControlOverridesT<D>, winrt::Windows::UI::Xaml::Controls::IControlOverridesT<D>, winrt::Windows::UI::Xaml::Controls::IControlOverrides6T<D>, winrt::Windows::UI::Xaml::IFrameworkElementOverridesT<D>, winrt::Windows::UI::Xaml::IFrameworkElementOverrides2T<D>, winrt::Windows::UI::Xaml::IUIElementOverridesT<D>, winrt::Windows::UI::Xaml::IUIElementOverrides7T<D>, winrt::Windows::UI::Xaml::IUIElementOverrides8T<D>, winrt::Windows::UI::Xaml::IUIElementOverrides9T<D>
    {
        using composable = DropDownButton;
        friend impl::produce<D, winrt::Windows::UI::Xaml::Controls::IContentControlOverrides>;
        friend impl::consume_t<D, winrt::Windows::UI::Xaml::Controls::IControlProtected>;
        friend impl::require_one<D, winrt::Windows::UI::Xaml::Controls::IControlProtected>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::Controls::IControlOverrides>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::Controls::IControlOverrides6>;
        friend impl::consume_t<D, winrt::Windows::UI::Xaml::IFrameworkElementProtected7>;
        friend impl::require_one<D, winrt::Windows::UI::Xaml::IFrameworkElementProtected7>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::IFrameworkElementOverrides>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::IFrameworkElementOverrides2>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::IUIElementOverrides>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::IUIElementOverrides7>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::IUIElementOverrides8>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::IUIElementOverrides9>;
    protected:
        DropDownButtonT()
        {
            impl::call_factory<DropDownButton, IDropDownButtonFactory>([&](IDropDownButtonFactory const& f) { [[maybe_unused]] auto winrt_impl_discarded = f.CreateInstance(*this, this->m_inner); });
        }
    };
    template <typename D, typename... Interfaces>
    struct ElementFactoryT :
        implements<D, winrt::Microsoft::UI::Xaml::Controls::IElementFactoryOverrides, composing, Interfaces...>,
        impl::require<D, winrt::Microsoft::UI::Xaml::Controls::IElementFactory, winrt::Windows::UI::Xaml::IDependencyObject, winrt::Windows::UI::Xaml::IDependencyObject2>,
        impl::base<D, ElementFactory, winrt::Windows::UI::Xaml::DependencyObject>,
        winrt::Microsoft::UI::Xaml::Controls::IElementFactoryOverridesT<D>
    {
        using composable = ElementFactory;
        friend impl::produce<D, winrt::Microsoft::UI::Xaml::Controls::IElementFactoryOverrides>;
    protected:
        ElementFactoryT()
        {
            impl::call_factory<ElementFactory, IElementFactoryFactory>([&](IElementFactoryFactory const& f) { [[maybe_unused]] auto winrt_impl_discarded = f.CreateInstance(*this, this->m_inner); });
        }
    };
    template <typename D, typename... Interfaces>
    struct ExpanderT :
        implements<D, winrt::Windows::UI::Xaml::Controls::IContentControlOverrides, winrt::Windows::UI::Xaml::Controls::IControlOverrides, winrt::Windows::UI::Xaml::Controls::IControlOverrides6, winrt::Windows::UI::Xaml::IFrameworkElementOverrides, winrt::Windows::UI::Xaml::IFrameworkElementOverrides2, winrt::Windows::UI::Xaml::IUIElementOverrides, winrt::Windows::UI::Xaml::IUIElementOverrides7, winrt::Windows::UI::Xaml::IUIElementOverrides8, winrt::Windows::UI::Xaml::IUIElementOverrides9, composing, Interfaces...>,
        impl::require<D, winrt::Microsoft::UI::Xaml::Controls::IExpander, winrt::Windows::UI::Xaml::Controls::IContentControl, winrt::Windows::UI::Xaml::Controls::IContentControl2, winrt::Windows::UI::Xaml::Controls::IControl, winrt::Windows::UI::Xaml::Controls::IControl2, winrt::Windows::UI::Xaml::Controls::IControl3, winrt::Windows::UI::Xaml::Controls::IControl4, winrt::Windows::UI::Xaml::Controls::IControl5, winrt::Windows::UI::Xaml::Controls::IControl7, winrt::Windows::UI::Xaml::IFrameworkElement, winrt::Windows::UI::Xaml::IFrameworkElement2, winrt::Windows::UI::Xaml::IFrameworkElement3, winrt::Windows::UI::Xaml::IFrameworkElement4, winrt::Windows::UI::Xaml::IFrameworkElement6, winrt::Windows::UI::Xaml::IFrameworkElement7, winrt::Windows::UI::Xaml::IUIElement, winrt::Windows::UI::Xaml::IUIElement2, winrt::Windows::UI::Xaml::IUIElement3, winrt::Windows::UI::Xaml::IUIElement4, winrt::Windows::UI::Xaml::IUIElement5, winrt::Windows::UI::Xaml::IUIElement7, winrt::Windows::UI::Xaml::IUIElement8, winrt::Windows::UI::Xaml::IUIElement9, winrt::Windows::UI::Xaml::IUIElement10, winrt::Windows::UI::Composition::IAnimationObject, winrt::Windows::UI::Composition::IVisualElement, winrt::Windows::UI::Xaml::IDependencyObject, winrt::Windows::UI::Xaml::IDependencyObject2>,
        protected impl::require<D, winrt::Windows::UI::Xaml::Controls::IControlProtected, winrt::Windows::UI::Xaml::IFrameworkElementProtected7>,
        impl::base<D, Expander, winrt::Windows::UI::Xaml::Controls::ContentControl, winrt::Windows::UI::Xaml::Controls::Control, winrt::Windows::UI::Xaml::FrameworkElement, winrt::Windows::UI::Xaml::UIElement, winrt::Windows::UI::Xaml::DependencyObject>,
        winrt::Windows::UI::Xaml::Controls::IContentControlOverridesT<D>, winrt::Windows::UI::Xaml::Controls::IControlOverridesT<D>, winrt::Windows::UI::Xaml::Controls::IControlOverrides6T<D>, winrt::Windows::UI::Xaml::IFrameworkElementOverridesT<D>, winrt::Windows::UI::Xaml::IFrameworkElementOverrides2T<D>, winrt::Windows::UI::Xaml::IUIElementOverridesT<D>, winrt::Windows::UI::Xaml::IUIElementOverrides7T<D>, winrt::Windows::UI::Xaml::IUIElementOverrides8T<D>, winrt::Windows::UI::Xaml::IUIElementOverrides9T<D>
    {
        using composable = Expander;
        friend impl::produce<D, winrt::Windows::UI::Xaml::Controls::IContentControlOverrides>;
        friend impl::consume_t<D, winrt::Windows::UI::Xaml::Controls::IControlProtected>;
        friend impl::require_one<D, winrt::Windows::UI::Xaml::Controls::IControlProtected>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::Controls::IControlOverrides>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::Controls::IControlOverrides6>;
        friend impl::consume_t<D, winrt::Windows::UI::Xaml::IFrameworkElementProtected7>;
        friend impl::require_one<D, winrt::Windows::UI::Xaml::IFrameworkElementProtected7>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::IFrameworkElementOverrides>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::IFrameworkElementOverrides2>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::IUIElementOverrides>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::IUIElementOverrides7>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::IUIElementOverrides8>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::IUIElementOverrides9>;
    protected:
        ExpanderT()
        {
            impl::call_factory<Expander, IExpanderFactory>([&](IExpanderFactory const& f) { [[maybe_unused]] auto winrt_impl_discarded = f.CreateInstance(*this, this->m_inner); });
        }
    };
    template <typename D, typename... Interfaces>
    struct FontIconSourceT :
        implements<D, winrt::Windows::Foundation::IInspectable, composing, Interfaces...>,
        impl::require<D, winrt::Microsoft::UI::Xaml::Controls::IFontIconSource, winrt::Microsoft::UI::Xaml::Controls::IIconSource, winrt::Windows::UI::Xaml::IDependencyObject, winrt::Windows::UI::Xaml::IDependencyObject2>,
        impl::base<D, FontIconSource, winrt::Microsoft::UI::Xaml::Controls::IconSource, winrt::Windows::UI::Xaml::DependencyObject>
    {
        using composable = FontIconSource;
    protected:
        FontIconSourceT()
        {
            impl::call_factory<FontIconSource, IFontIconSourceFactory>([&](IFontIconSourceFactory const& f) { [[maybe_unused]] auto winrt_impl_discarded = f.CreateInstance(*this, this->m_inner); });
        }
    };
    template <typename D, typename... Interfaces>
    struct ImageIconT :
        implements<D, winrt::Windows::UI::Xaml::IFrameworkElementOverrides, winrt::Windows::UI::Xaml::IFrameworkElementOverrides2, winrt::Windows::UI::Xaml::IUIElementOverrides, winrt::Windows::UI::Xaml::IUIElementOverrides7, winrt::Windows::UI::Xaml::IUIElementOverrides8, winrt::Windows::UI::Xaml::IUIElementOverrides9, composing, Interfaces...>,
        impl::require<D, winrt::Microsoft::UI::Xaml::Controls::IImageIcon, winrt::Windows::UI::Xaml::Controls::IIconElement, winrt::Windows::UI::Xaml::IFrameworkElement, winrt::Windows::UI::Xaml::IFrameworkElement2, winrt::Windows::UI::Xaml::IFrameworkElement3, winrt::Windows::UI::Xaml::IFrameworkElement4, winrt::Windows::UI::Xaml::IFrameworkElement6, winrt::Windows::UI::Xaml::IFrameworkElement7, winrt::Windows::UI::Xaml::IUIElement, winrt::Windows::UI::Xaml::IUIElement2, winrt::Windows::UI::Xaml::IUIElement3, winrt::Windows::UI::Xaml::IUIElement4, winrt::Windows::UI::Xaml::IUIElement5, winrt::Windows::UI::Xaml::IUIElement7, winrt::Windows::UI::Xaml::IUIElement8, winrt::Windows::UI::Xaml::IUIElement9, winrt::Windows::UI::Xaml::IUIElement10, winrt::Windows::UI::Composition::IAnimationObject, winrt::Windows::UI::Composition::IVisualElement, winrt::Windows::UI::Xaml::IDependencyObject, winrt::Windows::UI::Xaml::IDependencyObject2>,
        protected impl::require<D, winrt::Windows::UI::Xaml::IFrameworkElementProtected7>,
        impl::base<D, ImageIcon, winrt::Windows::UI::Xaml::Controls::IconElement, winrt::Windows::UI::Xaml::FrameworkElement, winrt::Windows::UI::Xaml::UIElement, winrt::Windows::UI::Xaml::DependencyObject>,
        winrt::Windows::UI::Xaml::IFrameworkElementOverridesT<D>, winrt::Windows::UI::Xaml::IFrameworkElementOverrides2T<D>, winrt::Windows::UI::Xaml::IUIElementOverridesT<D>, winrt::Windows::UI::Xaml::IUIElementOverrides7T<D>, winrt::Windows::UI::Xaml::IUIElementOverrides8T<D>, winrt::Windows::UI::Xaml::IUIElementOverrides9T<D>
    {
        using composable = ImageIcon;
        friend impl::consume_t<D, winrt::Windows::UI::Xaml::IFrameworkElementProtected7>;
        friend impl::require_one<D, winrt::Windows::UI::Xaml::IFrameworkElementProtected7>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::IFrameworkElementOverrides>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::IFrameworkElementOverrides2>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::IUIElementOverrides>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::IUIElementOverrides7>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::IUIElementOverrides8>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::IUIElementOverrides9>;
    protected:
        ImageIconT()
        {
            impl::call_factory<ImageIcon, IImageIconFactory>([&](IImageIconFactory const& f) { [[maybe_unused]] auto winrt_impl_discarded = f.CreateInstance(*this, this->m_inner); });
        }
    };
    template <typename D, typename... Interfaces>
    struct ImageIconSourceT :
        implements<D, winrt::Windows::Foundation::IInspectable, composing, Interfaces...>,
        impl::require<D, winrt::Microsoft::UI::Xaml::Controls::IImageIconSource, winrt::Microsoft::UI::Xaml::Controls::IIconSource, winrt::Windows::UI::Xaml::IDependencyObject, winrt::Windows::UI::Xaml::IDependencyObject2>,
        impl::base<D, ImageIconSource, winrt::Microsoft::UI::Xaml::Controls::IconSource, winrt::Windows::UI::Xaml::DependencyObject>
    {
        using composable = ImageIconSource;
    protected:
        ImageIconSourceT()
        {
            impl::call_factory<ImageIconSource, IImageIconSourceFactory>([&](IImageIconSourceFactory const& f) { [[maybe_unused]] auto winrt_impl_discarded = f.CreateInstance(*this, this->m_inner); });
        }
    };
    template <typename D, typename... Interfaces>
    struct InfoBadgeT :
        implements<D, winrt::Windows::UI::Xaml::Controls::IControlOverrides, winrt::Windows::UI::Xaml::Controls::IControlOverrides6, winrt::Windows::UI::Xaml::IFrameworkElementOverrides, winrt::Windows::UI::Xaml::IFrameworkElementOverrides2, winrt::Windows::UI::Xaml::IUIElementOverrides, winrt::Windows::UI::Xaml::IUIElementOverrides7, winrt::Windows::UI::Xaml::IUIElementOverrides8, winrt::Windows::UI::Xaml::IUIElementOverrides9, composing, Interfaces...>,
        impl::require<D, winrt::Microsoft::UI::Xaml::Controls::IInfoBadge, winrt::Windows::UI::Xaml::Controls::IControl, winrt::Windows::UI::Xaml::Controls::IControl2, winrt::Windows::UI::Xaml::Controls::IControl3, winrt::Windows::UI::Xaml::Controls::IControl4, winrt::Windows::UI::Xaml::Controls::IControl5, winrt::Windows::UI::Xaml::Controls::IControl7, winrt::Windows::UI::Xaml::IFrameworkElement, winrt::Windows::UI::Xaml::IFrameworkElement2, winrt::Windows::UI::Xaml::IFrameworkElement3, winrt::Windows::UI::Xaml::IFrameworkElement4, winrt::Windows::UI::Xaml::IFrameworkElement6, winrt::Windows::UI::Xaml::IFrameworkElement7, winrt::Windows::UI::Xaml::IUIElement, winrt::Windows::UI::Xaml::IUIElement2, winrt::Windows::UI::Xaml::IUIElement3, winrt::Windows::UI::Xaml::IUIElement4, winrt::Windows::UI::Xaml::IUIElement5, winrt::Windows::UI::Xaml::IUIElement7, winrt::Windows::UI::Xaml::IUIElement8, winrt::Windows::UI::Xaml::IUIElement9, winrt::Windows::UI::Xaml::IUIElement10, winrt::Windows::UI::Composition::IAnimationObject, winrt::Windows::UI::Composition::IVisualElement, winrt::Windows::UI::Xaml::IDependencyObject, winrt::Windows::UI::Xaml::IDependencyObject2>,
        protected impl::require<D, winrt::Windows::UI::Xaml::Controls::IControlProtected, winrt::Windows::UI::Xaml::IFrameworkElementProtected7>,
        impl::base<D, InfoBadge, winrt::Windows::UI::Xaml::Controls::Control, winrt::Windows::UI::Xaml::FrameworkElement, winrt::Windows::UI::Xaml::UIElement, winrt::Windows::UI::Xaml::DependencyObject>,
        winrt::Windows::UI::Xaml::Controls::IControlOverridesT<D>, winrt::Windows::UI::Xaml::Controls::IControlOverrides6T<D>, winrt::Windows::UI::Xaml::IFrameworkElementOverridesT<D>, winrt::Windows::UI::Xaml::IFrameworkElementOverrides2T<D>, winrt::Windows::UI::Xaml::IUIElementOverridesT<D>, winrt::Windows::UI::Xaml::IUIElementOverrides7T<D>, winrt::Windows::UI::Xaml::IUIElementOverrides8T<D>, winrt::Windows::UI::Xaml::IUIElementOverrides9T<D>
    {
        using composable = InfoBadge;
        friend impl::consume_t<D, winrt::Windows::UI::Xaml::Controls::IControlProtected>;
        friend impl::require_one<D, winrt::Windows::UI::Xaml::Controls::IControlProtected>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::Controls::IControlOverrides>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::Controls::IControlOverrides6>;
        friend impl::consume_t<D, winrt::Windows::UI::Xaml::IFrameworkElementProtected7>;
        friend impl::require_one<D, winrt::Windows::UI::Xaml::IFrameworkElementProtected7>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::IFrameworkElementOverrides>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::IFrameworkElementOverrides2>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::IUIElementOverrides>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::IUIElementOverrides7>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::IUIElementOverrides8>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::IUIElementOverrides9>;
    protected:
        InfoBadgeT()
        {
            impl::call_factory<InfoBadge, IInfoBadgeFactory>([&](IInfoBadgeFactory const& f) { [[maybe_unused]] auto winrt_impl_discarded = f.CreateInstance(*this, this->m_inner); });
        }
    };
    template <typename D, typename... Interfaces>
    struct InfoBadgeTemplateSettingsT :
        implements<D, winrt::Windows::Foundation::IInspectable, composing, Interfaces...>,
        impl::require<D, winrt::Microsoft::UI::Xaml::Controls::IInfoBadgeTemplateSettings, winrt::Windows::UI::Xaml::IDependencyObject, winrt::Windows::UI::Xaml::IDependencyObject2>,
        impl::base<D, InfoBadgeTemplateSettings, winrt::Windows::UI::Xaml::DependencyObject>
    {
        using composable = InfoBadgeTemplateSettings;
    protected:
        InfoBadgeTemplateSettingsT()
        {
            impl::call_factory<InfoBadgeTemplateSettings, IInfoBadgeTemplateSettingsFactory>([&](IInfoBadgeTemplateSettingsFactory const& f) { [[maybe_unused]] auto winrt_impl_discarded = f.CreateInstance(*this, this->m_inner); });
        }
    };
    template <typename D, typename... Interfaces>
    struct InfoBarT :
        implements<D, winrt::Windows::UI::Xaml::Controls::IControlOverrides, winrt::Windows::UI::Xaml::Controls::IControlOverrides6, winrt::Windows::UI::Xaml::IFrameworkElementOverrides, winrt::Windows::UI::Xaml::IFrameworkElementOverrides2, winrt::Windows::UI::Xaml::IUIElementOverrides, winrt::Windows::UI::Xaml::IUIElementOverrides7, winrt::Windows::UI::Xaml::IUIElementOverrides8, winrt::Windows::UI::Xaml::IUIElementOverrides9, composing, Interfaces...>,
        impl::require<D, winrt::Microsoft::UI::Xaml::Controls::IInfoBar, winrt::Windows::UI::Xaml::Controls::IControl, winrt::Windows::UI::Xaml::Controls::IControl2, winrt::Windows::UI::Xaml::Controls::IControl3, winrt::Windows::UI::Xaml::Controls::IControl4, winrt::Windows::UI::Xaml::Controls::IControl5, winrt::Windows::UI::Xaml::Controls::IControl7, winrt::Windows::UI::Xaml::IFrameworkElement, winrt::Windows::UI::Xaml::IFrameworkElement2, winrt::Windows::UI::Xaml::IFrameworkElement3, winrt::Windows::UI::Xaml::IFrameworkElement4, winrt::Windows::UI::Xaml::IFrameworkElement6, winrt::Windows::UI::Xaml::IFrameworkElement7, winrt::Windows::UI::Xaml::IUIElement, winrt::Windows::UI::Xaml::IUIElement2, winrt::Windows::UI::Xaml::IUIElement3, winrt::Windows::UI::Xaml::IUIElement4, winrt::Windows::UI::Xaml::IUIElement5, winrt::Windows::UI::Xaml::IUIElement7, winrt::Windows::UI::Xaml::IUIElement8, winrt::Windows::UI::Xaml::IUIElement9, winrt::Windows::UI::Xaml::IUIElement10, winrt::Windows::UI::Composition::IAnimationObject, winrt::Windows::UI::Composition::IVisualElement, winrt::Windows::UI::Xaml::IDependencyObject, winrt::Windows::UI::Xaml::IDependencyObject2>,
        protected impl::require<D, winrt::Windows::UI::Xaml::Controls::IControlProtected, winrt::Windows::UI::Xaml::IFrameworkElementProtected7>,
        impl::base<D, InfoBar, winrt::Windows::UI::Xaml::Controls::Control, winrt::Windows::UI::Xaml::FrameworkElement, winrt::Windows::UI::Xaml::UIElement, winrt::Windows::UI::Xaml::DependencyObject>,
        winrt::Windows::UI::Xaml::Controls::IControlOverridesT<D>, winrt::Windows::UI::Xaml::Controls::IControlOverrides6T<D>, winrt::Windows::UI::Xaml::IFrameworkElementOverridesT<D>, winrt::Windows::UI::Xaml::IFrameworkElementOverrides2T<D>, winrt::Windows::UI::Xaml::IUIElementOverridesT<D>, winrt::Windows::UI::Xaml::IUIElementOverrides7T<D>, winrt::Windows::UI::Xaml::IUIElementOverrides8T<D>, winrt::Windows::UI::Xaml::IUIElementOverrides9T<D>
    {
        using composable = InfoBar;
        friend impl::consume_t<D, winrt::Windows::UI::Xaml::Controls::IControlProtected>;
        friend impl::require_one<D, winrt::Windows::UI::Xaml::Controls::IControlProtected>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::Controls::IControlOverrides>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::Controls::IControlOverrides6>;
        friend impl::consume_t<D, winrt::Windows::UI::Xaml::IFrameworkElementProtected7>;
        friend impl::require_one<D, winrt::Windows::UI::Xaml::IFrameworkElementProtected7>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::IFrameworkElementOverrides>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::IFrameworkElementOverrides2>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::IUIElementOverrides>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::IUIElementOverrides7>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::IUIElementOverrides8>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::IUIElementOverrides9>;
    protected:
        InfoBarT()
        {
            impl::call_factory<InfoBar, IInfoBarFactory>([&](IInfoBarFactory const& f) { [[maybe_unused]] auto winrt_impl_discarded = f.CreateInstance(*this, this->m_inner); });
        }
    };
    template <typename D, typename... Interfaces>
    struct InfoBarTemplateSettingsT :
        implements<D, winrt::Windows::Foundation::IInspectable, composing, Interfaces...>,
        impl::require<D, winrt::Microsoft::UI::Xaml::Controls::IInfoBarTemplateSettings, winrt::Windows::UI::Xaml::IDependencyObject, winrt::Windows::UI::Xaml::IDependencyObject2>,
        impl::base<D, InfoBarTemplateSettings, winrt::Windows::UI::Xaml::DependencyObject>
    {
        using composable = InfoBarTemplateSettings;
    protected:
        InfoBarTemplateSettingsT()
        {
            impl::call_factory<InfoBarTemplateSettings, IInfoBarTemplateSettingsFactory>([&](IInfoBarTemplateSettingsFactory const& f) { [[maybe_unused]] auto winrt_impl_discarded = f.CreateInstance(*this, this->m_inner); });
        }
    };
    template <typename D, typename... Interfaces>
    struct ItemsRepeaterT :
        implements<D, winrt::Windows::UI::Xaml::IFrameworkElementOverrides, winrt::Windows::UI::Xaml::IFrameworkElementOverrides2, winrt::Windows::UI::Xaml::IUIElementOverrides, winrt::Windows::UI::Xaml::IUIElementOverrides7, winrt::Windows::UI::Xaml::IUIElementOverrides8, winrt::Windows::UI::Xaml::IUIElementOverrides9, composing, Interfaces...>,
        impl::require<D, winrt::Microsoft::UI::Xaml::Controls::IItemsRepeater, winrt::Windows::UI::Xaml::IFrameworkElement, winrt::Windows::UI::Xaml::IFrameworkElement2, winrt::Windows::UI::Xaml::IFrameworkElement3, winrt::Windows::UI::Xaml::IFrameworkElement4, winrt::Windows::UI::Xaml::IFrameworkElement6, winrt::Windows::UI::Xaml::IFrameworkElement7, winrt::Windows::UI::Xaml::IUIElement, winrt::Windows::UI::Xaml::IUIElement2, winrt::Windows::UI::Xaml::IUIElement3, winrt::Windows::UI::Xaml::IUIElement4, winrt::Windows::UI::Xaml::IUIElement5, winrt::Windows::UI::Xaml::IUIElement7, winrt::Windows::UI::Xaml::IUIElement8, winrt::Windows::UI::Xaml::IUIElement9, winrt::Windows::UI::Xaml::IUIElement10, winrt::Windows::UI::Composition::IAnimationObject, winrt::Windows::UI::Composition::IVisualElement, winrt::Windows::UI::Xaml::IDependencyObject, winrt::Windows::UI::Xaml::IDependencyObject2>,
        protected impl::require<D, winrt::Windows::UI::Xaml::IFrameworkElementProtected7>,
        impl::base<D, ItemsRepeater, winrt::Windows::UI::Xaml::FrameworkElement, winrt::Windows::UI::Xaml::UIElement, winrt::Windows::UI::Xaml::DependencyObject>,
        winrt::Windows::UI::Xaml::IFrameworkElementOverridesT<D>, winrt::Windows::UI::Xaml::IFrameworkElementOverrides2T<D>, winrt::Windows::UI::Xaml::IUIElementOverridesT<D>, winrt::Windows::UI::Xaml::IUIElementOverrides7T<D>, winrt::Windows::UI::Xaml::IUIElementOverrides8T<D>, winrt::Windows::UI::Xaml::IUIElementOverrides9T<D>
    {
        using composable = ItemsRepeater;
        friend impl::consume_t<D, winrt::Windows::UI::Xaml::IFrameworkElementProtected7>;
        friend impl::require_one<D, winrt::Windows::UI::Xaml::IFrameworkElementProtected7>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::IFrameworkElementOverrides>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::IFrameworkElementOverrides2>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::IUIElementOverrides>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::IUIElementOverrides7>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::IUIElementOverrides8>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::IUIElementOverrides9>;
    protected:
        ItemsRepeaterT()
        {
            impl::call_factory<ItemsRepeater, IItemsRepeaterFactory>([&](IItemsRepeaterFactory const& f) { [[maybe_unused]] auto winrt_impl_discarded = f.CreateInstance(*this, this->m_inner); });
        }
    };
    template <typename D, typename... Interfaces>
    struct ItemsSourceViewT :
        implements<D, winrt::Windows::Foundation::IInspectable, composing, Interfaces...>,
        impl::require<D, winrt::Microsoft::UI::Xaml::Controls::IItemsSourceView, winrt::Windows::UI::Xaml::Interop::INotifyCollectionChanged>,
        impl::base<D, ItemsSourceView>
    {
        using composable = ItemsSourceView;
    protected:
        ItemsSourceViewT(winrt::Windows::Foundation::IInspectable const& source)
        {
            impl::call_factory<ItemsSourceView, IItemsSourceViewFactory>([&](IItemsSourceViewFactory const& f) { [[maybe_unused]] auto winrt_impl_discarded = f.CreateInstance(source, *this, this->m_inner); });
        }
    };
    template <typename D, typename... Interfaces>
    struct MenuBarT :
        implements<D, winrt::Windows::UI::Xaml::Controls::IControlOverrides, winrt::Windows::UI::Xaml::Controls::IControlOverrides6, winrt::Windows::UI::Xaml::IFrameworkElementOverrides, winrt::Windows::UI::Xaml::IFrameworkElementOverrides2, winrt::Windows::UI::Xaml::IUIElementOverrides, winrt::Windows::UI::Xaml::IUIElementOverrides7, winrt::Windows::UI::Xaml::IUIElementOverrides8, winrt::Windows::UI::Xaml::IUIElementOverrides9, composing, Interfaces...>,
        impl::require<D, winrt::Microsoft::UI::Xaml::Controls::IMenuBar, winrt::Windows::UI::Xaml::Controls::IControl, winrt::Windows::UI::Xaml::Controls::IControl2, winrt::Windows::UI::Xaml::Controls::IControl3, winrt::Windows::UI::Xaml::Controls::IControl4, winrt::Windows::UI::Xaml::Controls::IControl5, winrt::Windows::UI::Xaml::Controls::IControl7, winrt::Windows::UI::Xaml::IFrameworkElement, winrt::Windows::UI::Xaml::IFrameworkElement2, winrt::Windows::UI::Xaml::IFrameworkElement3, winrt::Windows::UI::Xaml::IFrameworkElement4, winrt::Windows::UI::Xaml::IFrameworkElement6, winrt::Windows::UI::Xaml::IFrameworkElement7, winrt::Windows::UI::Xaml::IUIElement, winrt::Windows::UI::Xaml::IUIElement2, winrt::Windows::UI::Xaml::IUIElement3, winrt::Windows::UI::Xaml::IUIElement4, winrt::Windows::UI::Xaml::IUIElement5, winrt::Windows::UI::Xaml::IUIElement7, winrt::Windows::UI::Xaml::IUIElement8, winrt::Windows::UI::Xaml::IUIElement9, winrt::Windows::UI::Xaml::IUIElement10, winrt::Windows::UI::Composition::IAnimationObject, winrt::Windows::UI::Composition::IVisualElement, winrt::Windows::UI::Xaml::IDependencyObject, winrt::Windows::UI::Xaml::IDependencyObject2>,
        protected impl::require<D, winrt::Windows::UI::Xaml::Controls::IControlProtected, winrt::Windows::UI::Xaml::IFrameworkElementProtected7>,
        impl::base<D, MenuBar, winrt::Windows::UI::Xaml::Controls::Control, winrt::Windows::UI::Xaml::FrameworkElement, winrt::Windows::UI::Xaml::UIElement, winrt::Windows::UI::Xaml::DependencyObject>,
        winrt::Windows::UI::Xaml::Controls::IControlOverridesT<D>, winrt::Windows::UI::Xaml::Controls::IControlOverrides6T<D>, winrt::Windows::UI::Xaml::IFrameworkElementOverridesT<D>, winrt::Windows::UI::Xaml::IFrameworkElementOverrides2T<D>, winrt::Windows::UI::Xaml::IUIElementOverridesT<D>, winrt::Windows::UI::Xaml::IUIElementOverrides7T<D>, winrt::Windows::UI::Xaml::IUIElementOverrides8T<D>, winrt::Windows::UI::Xaml::IUIElementOverrides9T<D>
    {
        using composable = MenuBar;
        friend impl::consume_t<D, winrt::Windows::UI::Xaml::Controls::IControlProtected>;
        friend impl::require_one<D, winrt::Windows::UI::Xaml::Controls::IControlProtected>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::Controls::IControlOverrides>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::Controls::IControlOverrides6>;
        friend impl::consume_t<D, winrt::Windows::UI::Xaml::IFrameworkElementProtected7>;
        friend impl::require_one<D, winrt::Windows::UI::Xaml::IFrameworkElementProtected7>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::IFrameworkElementOverrides>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::IFrameworkElementOverrides2>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::IUIElementOverrides>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::IUIElementOverrides7>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::IUIElementOverrides8>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::IUIElementOverrides9>;
    protected:
        MenuBarT()
        {
            impl::call_factory<MenuBar, IMenuBarFactory>([&](IMenuBarFactory const& f) { [[maybe_unused]] auto winrt_impl_discarded = f.CreateInstance(*this, this->m_inner); });
        }
    };
    template <typename D, typename... Interfaces>
    struct MenuBarItemT :
        implements<D, winrt::Windows::UI::Xaml::Controls::IControlOverrides, winrt::Windows::UI::Xaml::Controls::IControlOverrides6, winrt::Windows::UI::Xaml::IFrameworkElementOverrides, winrt::Windows::UI::Xaml::IFrameworkElementOverrides2, winrt::Windows::UI::Xaml::IUIElementOverrides, winrt::Windows::UI::Xaml::IUIElementOverrides7, winrt::Windows::UI::Xaml::IUIElementOverrides8, winrt::Windows::UI::Xaml::IUIElementOverrides9, composing, Interfaces...>,
        impl::require<D, winrt::Microsoft::UI::Xaml::Controls::IMenuBarItem, winrt::Windows::UI::Xaml::Controls::IControl, winrt::Windows::UI::Xaml::Controls::IControl2, winrt::Windows::UI::Xaml::Controls::IControl3, winrt::Windows::UI::Xaml::Controls::IControl4, winrt::Windows::UI::Xaml::Controls::IControl5, winrt::Windows::UI::Xaml::Controls::IControl7, winrt::Windows::UI::Xaml::IFrameworkElement, winrt::Windows::UI::Xaml::IFrameworkElement2, winrt::Windows::UI::Xaml::IFrameworkElement3, winrt::Windows::UI::Xaml::IFrameworkElement4, winrt::Windows::UI::Xaml::IFrameworkElement6, winrt::Windows::UI::Xaml::IFrameworkElement7, winrt::Windows::UI::Xaml::IUIElement, winrt::Windows::UI::Xaml::IUIElement2, winrt::Windows::UI::Xaml::IUIElement3, winrt::Windows::UI::Xaml::IUIElement4, winrt::Windows::UI::Xaml::IUIElement5, winrt::Windows::UI::Xaml::IUIElement7, winrt::Windows::UI::Xaml::IUIElement8, winrt::Windows::UI::Xaml::IUIElement9, winrt::Windows::UI::Xaml::IUIElement10, winrt::Windows::UI::Composition::IAnimationObject, winrt::Windows::UI::Composition::IVisualElement, winrt::Windows::UI::Xaml::IDependencyObject, winrt::Windows::UI::Xaml::IDependencyObject2>,
        protected impl::require<D, winrt::Windows::UI::Xaml::Controls::IControlProtected, winrt::Windows::UI::Xaml::IFrameworkElementProtected7>,
        impl::base<D, MenuBarItem, winrt::Windows::UI::Xaml::Controls::Control, winrt::Windows::UI::Xaml::FrameworkElement, winrt::Windows::UI::Xaml::UIElement, winrt::Windows::UI::Xaml::DependencyObject>,
        winrt::Windows::UI::Xaml::Controls::IControlOverridesT<D>, winrt::Windows::UI::Xaml::Controls::IControlOverrides6T<D>, winrt::Windows::UI::Xaml::IFrameworkElementOverridesT<D>, winrt::Windows::UI::Xaml::IFrameworkElementOverrides2T<D>, winrt::Windows::UI::Xaml::IUIElementOverridesT<D>, winrt::Windows::UI::Xaml::IUIElementOverrides7T<D>, winrt::Windows::UI::Xaml::IUIElementOverrides8T<D>, winrt::Windows::UI::Xaml::IUIElementOverrides9T<D>
    {
        using composable = MenuBarItem;
        friend impl::consume_t<D, winrt::Windows::UI::Xaml::Controls::IControlProtected>;
        friend impl::require_one<D, winrt::Windows::UI::Xaml::Controls::IControlProtected>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::Controls::IControlOverrides>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::Controls::IControlOverrides6>;
        friend impl::consume_t<D, winrt::Windows::UI::Xaml::IFrameworkElementProtected7>;
        friend impl::require_one<D, winrt::Windows::UI::Xaml::IFrameworkElementProtected7>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::IFrameworkElementOverrides>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::IFrameworkElementOverrides2>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::IUIElementOverrides>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::IUIElementOverrides7>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::IUIElementOverrides8>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::IUIElementOverrides9>;
    protected:
        MenuBarItemT()
        {
            impl::call_factory<MenuBarItem, IMenuBarItemFactory>([&](IMenuBarItemFactory const& f) { [[maybe_unused]] auto winrt_impl_discarded = f.CreateInstance(*this, this->m_inner); });
        }
    };
    template <typename D, typename... Interfaces>
    struct MenuBarItemFlyoutT :
        implements<D, winrt::Windows::UI::Xaml::Controls::Primitives::IFlyoutBaseOverrides, winrt::Windows::UI::Xaml::Controls::Primitives::IFlyoutBaseOverrides4, composing, Interfaces...>,
        impl::require<D, winrt::Microsoft::UI::Xaml::Controls::IMenuBarItemFlyout, winrt::Windows::UI::Xaml::Controls::IMenuFlyout, winrt::Windows::UI::Xaml::Controls::IMenuFlyout2, winrt::Windows::UI::Xaml::Controls::Primitives::IFlyoutBase, winrt::Windows::UI::Xaml::Controls::Primitives::IFlyoutBase2, winrt::Windows::UI::Xaml::Controls::Primitives::IFlyoutBase3, winrt::Windows::UI::Xaml::Controls::Primitives::IFlyoutBase4, winrt::Windows::UI::Xaml::Controls::Primitives::IFlyoutBase5, winrt::Windows::UI::Xaml::Controls::Primitives::IFlyoutBase6, winrt::Windows::UI::Xaml::IDependencyObject, winrt::Windows::UI::Xaml::IDependencyObject2>,
        impl::base<D, MenuBarItemFlyout, winrt::Windows::UI::Xaml::Controls::MenuFlyout, winrt::Windows::UI::Xaml::Controls::Primitives::FlyoutBase, winrt::Windows::UI::Xaml::DependencyObject>,
        winrt::Windows::UI::Xaml::Controls::Primitives::IFlyoutBaseOverridesT<D>, winrt::Windows::UI::Xaml::Controls::Primitives::IFlyoutBaseOverrides4T<D>
    {
        using composable = MenuBarItemFlyout;
        friend impl::produce<D, winrt::Windows::UI::Xaml::Controls::Primitives::IFlyoutBaseOverrides>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::Controls::Primitives::IFlyoutBaseOverrides4>;
    protected:
        MenuBarItemFlyoutT()
        {
            impl::call_factory<MenuBarItemFlyout, IMenuBarItemFlyoutFactory>([&](IMenuBarItemFlyoutFactory const& f) { [[maybe_unused]] auto winrt_impl_discarded = f.CreateInstance(*this, this->m_inner); });
        }
        using impl::consume_t<D, winrt::Windows::UI::Xaml::Controls::IMenuFlyout2>::ShowAt;
        using impl::consume_t<D, winrt::Windows::UI::Xaml::Controls::Primitives::IFlyoutBase>::ShowAt;
        using impl::consume_t<D, winrt::Windows::UI::Xaml::Controls::Primitives::IFlyoutBase5>::ShowAt;
    };
    template <typename D, typename... Interfaces>
    struct NavigationViewT :
        implements<D, winrt::Windows::UI::Xaml::Controls::IContentControlOverrides, winrt::Windows::UI::Xaml::Controls::IControlOverrides, winrt::Windows::UI::Xaml::Controls::IControlOverrides6, winrt::Windows::UI::Xaml::IFrameworkElementOverrides, winrt::Windows::UI::Xaml::IFrameworkElementOverrides2, winrt::Windows::UI::Xaml::IUIElementOverrides, winrt::Windows::UI::Xaml::IUIElementOverrides7, winrt::Windows::UI::Xaml::IUIElementOverrides8, winrt::Windows::UI::Xaml::IUIElementOverrides9, composing, Interfaces...>,
        impl::require<D, winrt::Microsoft::UI::Xaml::Controls::INavigationView, winrt::Microsoft::UI::Xaml::Controls::INavigationView2, winrt::Windows::UI::Xaml::Controls::IContentControl, winrt::Windows::UI::Xaml::Controls::IContentControl2, winrt::Windows::UI::Xaml::Controls::IControl, winrt::Windows::UI::Xaml::Controls::IControl2, winrt::Windows::UI::Xaml::Controls::IControl3, winrt::Windows::UI::Xaml::Controls::IControl4, winrt::Windows::UI::Xaml::Controls::IControl5, winrt::Windows::UI::Xaml::Controls::IControl7, winrt::Windows::UI::Xaml::IFrameworkElement, winrt::Windows::UI::Xaml::IFrameworkElement2, winrt::Windows::UI::Xaml::IFrameworkElement3, winrt::Windows::UI::Xaml::IFrameworkElement4, winrt::Windows::UI::Xaml::IFrameworkElement6, winrt::Windows::UI::Xaml::IFrameworkElement7, winrt::Windows::UI::Xaml::IUIElement, winrt::Windows::UI::Xaml::IUIElement2, winrt::Windows::UI::Xaml::IUIElement3, winrt::Windows::UI::Xaml::IUIElement4, winrt::Windows::UI::Xaml::IUIElement5, winrt::Windows::UI::Xaml::IUIElement7, winrt::Windows::UI::Xaml::IUIElement8, winrt::Windows::UI::Xaml::IUIElement9, winrt::Windows::UI::Xaml::IUIElement10, winrt::Windows::UI::Composition::IAnimationObject, winrt::Windows::UI::Composition::IVisualElement, winrt::Windows::UI::Xaml::IDependencyObject, winrt::Windows::UI::Xaml::IDependencyObject2>,
        protected impl::require<D, winrt::Windows::UI::Xaml::Controls::IControlProtected, winrt::Windows::UI::Xaml::IFrameworkElementProtected7>,
        impl::base<D, NavigationView, winrt::Windows::UI::Xaml::Controls::ContentControl, winrt::Windows::UI::Xaml::Controls::Control, winrt::Windows::UI::Xaml::FrameworkElement, winrt::Windows::UI::Xaml::UIElement, winrt::Windows::UI::Xaml::DependencyObject>,
        winrt::Windows::UI::Xaml::Controls::IContentControlOverridesT<D>, winrt::Windows::UI::Xaml::Controls::IControlOverridesT<D>, winrt::Windows::UI::Xaml::Controls::IControlOverrides6T<D>, winrt::Windows::UI::Xaml::IFrameworkElementOverridesT<D>, winrt::Windows::UI::Xaml::IFrameworkElementOverrides2T<D>, winrt::Windows::UI::Xaml::IUIElementOverridesT<D>, winrt::Windows::UI::Xaml::IUIElementOverrides7T<D>, winrt::Windows::UI::Xaml::IUIElementOverrides8T<D>, winrt::Windows::UI::Xaml::IUIElementOverrides9T<D>
    {
        using composable = NavigationView;
        friend impl::produce<D, winrt::Windows::UI::Xaml::Controls::IContentControlOverrides>;
        friend impl::consume_t<D, winrt::Windows::UI::Xaml::Controls::IControlProtected>;
        friend impl::require_one<D, winrt::Windows::UI::Xaml::Controls::IControlProtected>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::Controls::IControlOverrides>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::Controls::IControlOverrides6>;
        friend impl::consume_t<D, winrt::Windows::UI::Xaml::IFrameworkElementProtected7>;
        friend impl::require_one<D, winrt::Windows::UI::Xaml::IFrameworkElementProtected7>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::IFrameworkElementOverrides>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::IFrameworkElementOverrides2>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::IUIElementOverrides>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::IUIElementOverrides7>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::IUIElementOverrides8>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::IUIElementOverrides9>;
    protected:
        NavigationViewT()
        {
            impl::call_factory<NavigationView, INavigationViewFactory>([&](INavigationViewFactory const& f) { [[maybe_unused]] auto winrt_impl_discarded = f.CreateInstance(*this, this->m_inner); });
        }
    };
    template <typename D, typename... Interfaces>
    struct NavigationViewItemT :
        implements<D, winrt::Windows::UI::Xaml::Controls::IContentControlOverrides, winrt::Windows::UI::Xaml::Controls::IControlOverrides, winrt::Windows::UI::Xaml::Controls::IControlOverrides6, winrt::Windows::UI::Xaml::IFrameworkElementOverrides, winrt::Windows::UI::Xaml::IFrameworkElementOverrides2, winrt::Windows::UI::Xaml::IUIElementOverrides, winrt::Windows::UI::Xaml::IUIElementOverrides7, winrt::Windows::UI::Xaml::IUIElementOverrides8, winrt::Windows::UI::Xaml::IUIElementOverrides9, composing, Interfaces...>,
        impl::require<D, winrt::Microsoft::UI::Xaml::Controls::INavigationViewItem, winrt::Microsoft::UI::Xaml::Controls::INavigationViewItem2, winrt::Microsoft::UI::Xaml::Controls::INavigationViewItem3, winrt::Microsoft::UI::Xaml::Controls::INavigationViewItemBase, winrt::Microsoft::UI::Xaml::Controls::INavigationViewItemBase2, winrt::Windows::UI::Xaml::Controls::IContentControl, winrt::Windows::UI::Xaml::Controls::IContentControl2, winrt::Windows::UI::Xaml::Controls::IControl, winrt::Windows::UI::Xaml::Controls::IControl2, winrt::Windows::UI::Xaml::Controls::IControl3, winrt::Windows::UI::Xaml::Controls::IControl4, winrt::Windows::UI::Xaml::Controls::IControl5, winrt::Windows::UI::Xaml::Controls::IControl7, winrt::Windows::UI::Xaml::IFrameworkElement, winrt::Windows::UI::Xaml::IFrameworkElement2, winrt::Windows::UI::Xaml::IFrameworkElement3, winrt::Windows::UI::Xaml::IFrameworkElement4, winrt::Windows::UI::Xaml::IFrameworkElement6, winrt::Windows::UI::Xaml::IFrameworkElement7, winrt::Windows::UI::Xaml::IUIElement, winrt::Windows::UI::Xaml::IUIElement2, winrt::Windows::UI::Xaml::IUIElement3, winrt::Windows::UI::Xaml::IUIElement4, winrt::Windows::UI::Xaml::IUIElement5, winrt::Windows::UI::Xaml::IUIElement7, winrt::Windows::UI::Xaml::IUIElement8, winrt::Windows::UI::Xaml::IUIElement9, winrt::Windows::UI::Xaml::IUIElement10, winrt::Windows::UI::Composition::IAnimationObject, winrt::Windows::UI::Composition::IVisualElement, winrt::Windows::UI::Xaml::IDependencyObject, winrt::Windows::UI::Xaml::IDependencyObject2>,
        protected impl::require<D, winrt::Windows::UI::Xaml::Controls::IControlProtected, winrt::Windows::UI::Xaml::IFrameworkElementProtected7>,
        impl::base<D, NavigationViewItem, winrt::Microsoft::UI::Xaml::Controls::NavigationViewItemBase, winrt::Windows::UI::Xaml::Controls::ContentControl, winrt::Windows::UI::Xaml::Controls::Control, winrt::Windows::UI::Xaml::FrameworkElement, winrt::Windows::UI::Xaml::UIElement, winrt::Windows::UI::Xaml::DependencyObject>,
        winrt::Windows::UI::Xaml::Controls::IContentControlOverridesT<D>, winrt::Windows::UI::Xaml::Controls::IControlOverridesT<D>, winrt::Windows::UI::Xaml::Controls::IControlOverrides6T<D>, winrt::Windows::UI::Xaml::IFrameworkElementOverridesT<D>, winrt::Windows::UI::Xaml::IFrameworkElementOverrides2T<D>, winrt::Windows::UI::Xaml::IUIElementOverridesT<D>, winrt::Windows::UI::Xaml::IUIElementOverrides7T<D>, winrt::Windows::UI::Xaml::IUIElementOverrides8T<D>, winrt::Windows::UI::Xaml::IUIElementOverrides9T<D>
    {
        using composable = NavigationViewItem;
        friend impl::produce<D, winrt::Windows::UI::Xaml::Controls::IContentControlOverrides>;
        friend impl::consume_t<D, winrt::Windows::UI::Xaml::Controls::IControlProtected>;
        friend impl::require_one<D, winrt::Windows::UI::Xaml::Controls::IControlProtected>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::Controls::IControlOverrides>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::Controls::IControlOverrides6>;
        friend impl::consume_t<D, winrt::Windows::UI::Xaml::IFrameworkElementProtected7>;
        friend impl::require_one<D, winrt::Windows::UI::Xaml::IFrameworkElementProtected7>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::IFrameworkElementOverrides>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::IFrameworkElementOverrides2>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::IUIElementOverrides>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::IUIElementOverrides7>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::IUIElementOverrides8>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::IUIElementOverrides9>;
    protected:
        NavigationViewItemT()
        {
            impl::call_factory<NavigationViewItem, INavigationViewItemFactory>([&](INavigationViewItemFactory const& f) { [[maybe_unused]] auto winrt_impl_discarded = f.CreateInstance(*this, this->m_inner); });
        }
    };
    template <typename D, typename... Interfaces>
    struct NavigationViewItemHeaderT :
        implements<D, winrt::Windows::UI::Xaml::Controls::IContentControlOverrides, winrt::Windows::UI::Xaml::Controls::IControlOverrides, winrt::Windows::UI::Xaml::Controls::IControlOverrides6, winrt::Windows::UI::Xaml::IFrameworkElementOverrides, winrt::Windows::UI::Xaml::IFrameworkElementOverrides2, winrt::Windows::UI::Xaml::IUIElementOverrides, winrt::Windows::UI::Xaml::IUIElementOverrides7, winrt::Windows::UI::Xaml::IUIElementOverrides8, winrt::Windows::UI::Xaml::IUIElementOverrides9, composing, Interfaces...>,
        impl::require<D, winrt::Microsoft::UI::Xaml::Controls::INavigationViewItemHeader, winrt::Microsoft::UI::Xaml::Controls::INavigationViewItemBase, winrt::Microsoft::UI::Xaml::Controls::INavigationViewItemBase2, winrt::Windows::UI::Xaml::Controls::IContentControl, winrt::Windows::UI::Xaml::Controls::IContentControl2, winrt::Windows::UI::Xaml::Controls::IControl, winrt::Windows::UI::Xaml::Controls::IControl2, winrt::Windows::UI::Xaml::Controls::IControl3, winrt::Windows::UI::Xaml::Controls::IControl4, winrt::Windows::UI::Xaml::Controls::IControl5, winrt::Windows::UI::Xaml::Controls::IControl7, winrt::Windows::UI::Xaml::IFrameworkElement, winrt::Windows::UI::Xaml::IFrameworkElement2, winrt::Windows::UI::Xaml::IFrameworkElement3, winrt::Windows::UI::Xaml::IFrameworkElement4, winrt::Windows::UI::Xaml::IFrameworkElement6, winrt::Windows::UI::Xaml::IFrameworkElement7, winrt::Windows::UI::Xaml::IUIElement, winrt::Windows::UI::Xaml::IUIElement2, winrt::Windows::UI::Xaml::IUIElement3, winrt::Windows::UI::Xaml::IUIElement4, winrt::Windows::UI::Xaml::IUIElement5, winrt::Windows::UI::Xaml::IUIElement7, winrt::Windows::UI::Xaml::IUIElement8, winrt::Windows::UI::Xaml::IUIElement9, winrt::Windows::UI::Xaml::IUIElement10, winrt::Windows::UI::Composition::IAnimationObject, winrt::Windows::UI::Composition::IVisualElement, winrt::Windows::UI::Xaml::IDependencyObject, winrt::Windows::UI::Xaml::IDependencyObject2>,
        protected impl::require<D, winrt::Windows::UI::Xaml::Controls::IControlProtected, winrt::Windows::UI::Xaml::IFrameworkElementProtected7>,
        impl::base<D, NavigationViewItemHeader, winrt::Microsoft::UI::Xaml::Controls::NavigationViewItemBase, winrt::Windows::UI::Xaml::Controls::ContentControl, winrt::Windows::UI::Xaml::Controls::Control, winrt::Windows::UI::Xaml::FrameworkElement, winrt::Windows::UI::Xaml::UIElement, winrt::Windows::UI::Xaml::DependencyObject>,
        winrt::Windows::UI::Xaml::Controls::IContentControlOverridesT<D>, winrt::Windows::UI::Xaml::Controls::IControlOverridesT<D>, winrt::Windows::UI::Xaml::Controls::IControlOverrides6T<D>, winrt::Windows::UI::Xaml::IFrameworkElementOverridesT<D>, winrt::Windows::UI::Xaml::IFrameworkElementOverrides2T<D>, winrt::Windows::UI::Xaml::IUIElementOverridesT<D>, winrt::Windows::UI::Xaml::IUIElementOverrides7T<D>, winrt::Windows::UI::Xaml::IUIElementOverrides8T<D>, winrt::Windows::UI::Xaml::IUIElementOverrides9T<D>
    {
        using composable = NavigationViewItemHeader;
        friend impl::produce<D, winrt::Windows::UI::Xaml::Controls::IContentControlOverrides>;
        friend impl::consume_t<D, winrt::Windows::UI::Xaml::Controls::IControlProtected>;
        friend impl::require_one<D, winrt::Windows::UI::Xaml::Controls::IControlProtected>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::Controls::IControlOverrides>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::Controls::IControlOverrides6>;
        friend impl::consume_t<D, winrt::Windows::UI::Xaml::IFrameworkElementProtected7>;
        friend impl::require_one<D, winrt::Windows::UI::Xaml::IFrameworkElementProtected7>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::IFrameworkElementOverrides>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::IFrameworkElementOverrides2>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::IUIElementOverrides>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::IUIElementOverrides7>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::IUIElementOverrides8>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::IUIElementOverrides9>;
    protected:
        NavigationViewItemHeaderT()
        {
            impl::call_factory<NavigationViewItemHeader, INavigationViewItemHeaderFactory>([&](INavigationViewItemHeaderFactory const& f) { [[maybe_unused]] auto winrt_impl_discarded = f.CreateInstance(*this, this->m_inner); });
        }
    };
    template <typename D, typename... Interfaces>
    struct NavigationViewItemSeparatorT :
        implements<D, winrt::Windows::UI::Xaml::Controls::IContentControlOverrides, winrt::Windows::UI::Xaml::Controls::IControlOverrides, winrt::Windows::UI::Xaml::Controls::IControlOverrides6, winrt::Windows::UI::Xaml::IFrameworkElementOverrides, winrt::Windows::UI::Xaml::IFrameworkElementOverrides2, winrt::Windows::UI::Xaml::IUIElementOverrides, winrt::Windows::UI::Xaml::IUIElementOverrides7, winrt::Windows::UI::Xaml::IUIElementOverrides8, winrt::Windows::UI::Xaml::IUIElementOverrides9, composing, Interfaces...>,
        impl::require<D, winrt::Microsoft::UI::Xaml::Controls::INavigationViewItemSeparator, winrt::Microsoft::UI::Xaml::Controls::INavigationViewItemBase, winrt::Microsoft::UI::Xaml::Controls::INavigationViewItemBase2, winrt::Windows::UI::Xaml::Controls::IContentControl, winrt::Windows::UI::Xaml::Controls::IContentControl2, winrt::Windows::UI::Xaml::Controls::IControl, winrt::Windows::UI::Xaml::Controls::IControl2, winrt::Windows::UI::Xaml::Controls::IControl3, winrt::Windows::UI::Xaml::Controls::IControl4, winrt::Windows::UI::Xaml::Controls::IControl5, winrt::Windows::UI::Xaml::Controls::IControl7, winrt::Windows::UI::Xaml::IFrameworkElement, winrt::Windows::UI::Xaml::IFrameworkElement2, winrt::Windows::UI::Xaml::IFrameworkElement3, winrt::Windows::UI::Xaml::IFrameworkElement4, winrt::Windows::UI::Xaml::IFrameworkElement6, winrt::Windows::UI::Xaml::IFrameworkElement7, winrt::Windows::UI::Xaml::IUIElement, winrt::Windows::UI::Xaml::IUIElement2, winrt::Windows::UI::Xaml::IUIElement3, winrt::Windows::UI::Xaml::IUIElement4, winrt::Windows::UI::Xaml::IUIElement5, winrt::Windows::UI::Xaml::IUIElement7, winrt::Windows::UI::Xaml::IUIElement8, winrt::Windows::UI::Xaml::IUIElement9, winrt::Windows::UI::Xaml::IUIElement10, winrt::Windows::UI::Composition::IAnimationObject, winrt::Windows::UI::Composition::IVisualElement, winrt::Windows::UI::Xaml::IDependencyObject, winrt::Windows::UI::Xaml::IDependencyObject2>,
        protected impl::require<D, winrt::Windows::UI::Xaml::Controls::IControlProtected, winrt::Windows::UI::Xaml::IFrameworkElementProtected7>,
        impl::base<D, NavigationViewItemSeparator, winrt::Microsoft::UI::Xaml::Controls::NavigationViewItemBase, winrt::Windows::UI::Xaml::Controls::ContentControl, winrt::Windows::UI::Xaml::Controls::Control, winrt::Windows::UI::Xaml::FrameworkElement, winrt::Windows::UI::Xaml::UIElement, winrt::Windows::UI::Xaml::DependencyObject>,
        winrt::Windows::UI::Xaml::Controls::IContentControlOverridesT<D>, winrt::Windows::UI::Xaml::Controls::IControlOverridesT<D>, winrt::Windows::UI::Xaml::Controls::IControlOverrides6T<D>, winrt::Windows::UI::Xaml::IFrameworkElementOverridesT<D>, winrt::Windows::UI::Xaml::IFrameworkElementOverrides2T<D>, winrt::Windows::UI::Xaml::IUIElementOverridesT<D>, winrt::Windows::UI::Xaml::IUIElementOverrides7T<D>, winrt::Windows::UI::Xaml::IUIElementOverrides8T<D>, winrt::Windows::UI::Xaml::IUIElementOverrides9T<D>
    {
        using composable = NavigationViewItemSeparator;
        friend impl::produce<D, winrt::Windows::UI::Xaml::Controls::IContentControlOverrides>;
        friend impl::consume_t<D, winrt::Windows::UI::Xaml::Controls::IControlProtected>;
        friend impl::require_one<D, winrt::Windows::UI::Xaml::Controls::IControlProtected>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::Controls::IControlOverrides>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::Controls::IControlOverrides6>;
        friend impl::consume_t<D, winrt::Windows::UI::Xaml::IFrameworkElementProtected7>;
        friend impl::require_one<D, winrt::Windows::UI::Xaml::IFrameworkElementProtected7>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::IFrameworkElementOverrides>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::IFrameworkElementOverrides2>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::IUIElementOverrides>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::IUIElementOverrides7>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::IUIElementOverrides8>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::IUIElementOverrides9>;
    protected:
        NavigationViewItemSeparatorT()
        {
            impl::call_factory<NavigationViewItemSeparator, INavigationViewItemSeparatorFactory>([&](INavigationViewItemSeparatorFactory const& f) { [[maybe_unused]] auto winrt_impl_discarded = f.CreateInstance(*this, this->m_inner); });
        }
    };
    template <typename D, typename... Interfaces>
    struct NavigationViewTemplateSettingsT :
        implements<D, winrt::Windows::Foundation::IInspectable, composing, Interfaces...>,
        impl::require<D, winrt::Microsoft::UI::Xaml::Controls::INavigationViewTemplateSettings, winrt::Microsoft::UI::Xaml::Controls::INavigationViewTemplateSettings2, winrt::Windows::UI::Xaml::IDependencyObject, winrt::Windows::UI::Xaml::IDependencyObject2>,
        impl::base<D, NavigationViewTemplateSettings, winrt::Windows::UI::Xaml::DependencyObject>
    {
        using composable = NavigationViewTemplateSettings;
    protected:
        NavigationViewTemplateSettingsT()
        {
            impl::call_factory<NavigationViewTemplateSettings, INavigationViewTemplateSettingsFactory>([&](INavigationViewTemplateSettingsFactory const& f) { [[maybe_unused]] auto winrt_impl_discarded = f.CreateInstance(*this, this->m_inner); });
        }
    };
    template <typename D, typename... Interfaces>
    struct NonVirtualizingLayoutT :
        implements<D, winrt::Microsoft::UI::Xaml::Controls::INonVirtualizingLayoutOverrides, composing, Interfaces...>,
        impl::require<D, winrt::Microsoft::UI::Xaml::Controls::INonVirtualizingLayout, winrt::Microsoft::UI::Xaml::Controls::ILayout, winrt::Windows::UI::Xaml::IDependencyObject, winrt::Windows::UI::Xaml::IDependencyObject2>,
        protected impl::require<D, winrt::Microsoft::UI::Xaml::Controls::ILayoutProtected>,
        impl::base<D, NonVirtualizingLayout, winrt::Microsoft::UI::Xaml::Controls::Layout, winrt::Windows::UI::Xaml::DependencyObject>,
        winrt::Microsoft::UI::Xaml::Controls::INonVirtualizingLayoutOverridesT<D>
    {
        using composable = NonVirtualizingLayout;
        friend impl::produce<D, winrt::Microsoft::UI::Xaml::Controls::INonVirtualizingLayoutOverrides>;
        friend impl::consume_t<D, winrt::Microsoft::UI::Xaml::Controls::ILayoutProtected>;
        friend impl::require_one<D, winrt::Microsoft::UI::Xaml::Controls::ILayoutProtected>;
    protected:
        NonVirtualizingLayoutT()
        {
            impl::call_factory<NonVirtualizingLayout, INonVirtualizingLayoutFactory>([&](INonVirtualizingLayoutFactory const& f) { [[maybe_unused]] auto winrt_impl_discarded = f.CreateInstance(*this, this->m_inner); });
        }
    };
    template <typename D, typename... Interfaces>
    struct NonVirtualizingLayoutContextT :
        implements<D, winrt::Microsoft::UI::Xaml::Controls::INonVirtualizingLayoutContextOverrides, winrt::Microsoft::UI::Xaml::Controls::ILayoutContextOverrides, composing, Interfaces...>,
        impl::require<D, winrt::Microsoft::UI::Xaml::Controls::INonVirtualizingLayoutContext, winrt::Microsoft::UI::Xaml::Controls::ILayoutContext, winrt::Windows::UI::Xaml::IDependencyObject, winrt::Windows::UI::Xaml::IDependencyObject2>,
        impl::base<D, NonVirtualizingLayoutContext, winrt::Microsoft::UI::Xaml::Controls::LayoutContext, winrt::Windows::UI::Xaml::DependencyObject>,
        winrt::Microsoft::UI::Xaml::Controls::INonVirtualizingLayoutContextOverridesT<D>, winrt::Microsoft::UI::Xaml::Controls::ILayoutContextOverridesT<D>
    {
        using composable = NonVirtualizingLayoutContext;
        friend impl::produce<D, winrt::Microsoft::UI::Xaml::Controls::INonVirtualizingLayoutContextOverrides>;
        friend impl::produce<D, winrt::Microsoft::UI::Xaml::Controls::ILayoutContextOverrides>;
    protected:
        NonVirtualizingLayoutContextT()
        {
            impl::call_factory<NonVirtualizingLayoutContext, INonVirtualizingLayoutContextFactory>([&](INonVirtualizingLayoutContextFactory const& f) { [[maybe_unused]] auto winrt_impl_discarded = f.CreateInstance(*this, this->m_inner); });
        }
    };
    template <typename D, typename... Interfaces>
    struct NumberBoxT :
        implements<D, winrt::Windows::UI::Xaml::Controls::IControlOverrides, winrt::Windows::UI::Xaml::Controls::IControlOverrides6, winrt::Windows::UI::Xaml::IFrameworkElementOverrides, winrt::Windows::UI::Xaml::IFrameworkElementOverrides2, winrt::Windows::UI::Xaml::IUIElementOverrides, winrt::Windows::UI::Xaml::IUIElementOverrides7, winrt::Windows::UI::Xaml::IUIElementOverrides8, winrt::Windows::UI::Xaml::IUIElementOverrides9, composing, Interfaces...>,
        impl::require<D, winrt::Microsoft::UI::Xaml::Controls::INumberBox, winrt::Windows::UI::Xaml::Controls::IControl, winrt::Windows::UI::Xaml::Controls::IControl2, winrt::Windows::UI::Xaml::Controls::IControl3, winrt::Windows::UI::Xaml::Controls::IControl4, winrt::Windows::UI::Xaml::Controls::IControl5, winrt::Windows::UI::Xaml::Controls::IControl7, winrt::Windows::UI::Xaml::IFrameworkElement, winrt::Windows::UI::Xaml::IFrameworkElement2, winrt::Windows::UI::Xaml::IFrameworkElement3, winrt::Windows::UI::Xaml::IFrameworkElement4, winrt::Windows::UI::Xaml::IFrameworkElement6, winrt::Windows::UI::Xaml::IFrameworkElement7, winrt::Windows::UI::Xaml::IUIElement, winrt::Windows::UI::Xaml::IUIElement2, winrt::Windows::UI::Xaml::IUIElement3, winrt::Windows::UI::Xaml::IUIElement4, winrt::Windows::UI::Xaml::IUIElement5, winrt::Windows::UI::Xaml::IUIElement7, winrt::Windows::UI::Xaml::IUIElement8, winrt::Windows::UI::Xaml::IUIElement9, winrt::Windows::UI::Xaml::IUIElement10, winrt::Windows::UI::Composition::IAnimationObject, winrt::Windows::UI::Composition::IVisualElement, winrt::Windows::UI::Xaml::IDependencyObject, winrt::Windows::UI::Xaml::IDependencyObject2>,
        protected impl::require<D, winrt::Windows::UI::Xaml::Controls::IControlProtected, winrt::Windows::UI::Xaml::IFrameworkElementProtected7>,
        impl::base<D, NumberBox, winrt::Windows::UI::Xaml::Controls::Control, winrt::Windows::UI::Xaml::FrameworkElement, winrt::Windows::UI::Xaml::UIElement, winrt::Windows::UI::Xaml::DependencyObject>,
        winrt::Windows::UI::Xaml::Controls::IControlOverridesT<D>, winrt::Windows::UI::Xaml::Controls::IControlOverrides6T<D>, winrt::Windows::UI::Xaml::IFrameworkElementOverridesT<D>, winrt::Windows::UI::Xaml::IFrameworkElementOverrides2T<D>, winrt::Windows::UI::Xaml::IUIElementOverridesT<D>, winrt::Windows::UI::Xaml::IUIElementOverrides7T<D>, winrt::Windows::UI::Xaml::IUIElementOverrides8T<D>, winrt::Windows::UI::Xaml::IUIElementOverrides9T<D>
    {
        using composable = NumberBox;
        friend impl::consume_t<D, winrt::Windows::UI::Xaml::Controls::IControlProtected>;
        friend impl::require_one<D, winrt::Windows::UI::Xaml::Controls::IControlProtected>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::Controls::IControlOverrides>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::Controls::IControlOverrides6>;
        friend impl::consume_t<D, winrt::Windows::UI::Xaml::IFrameworkElementProtected7>;
        friend impl::require_one<D, winrt::Windows::UI::Xaml::IFrameworkElementProtected7>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::IFrameworkElementOverrides>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::IFrameworkElementOverrides2>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::IUIElementOverrides>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::IUIElementOverrides7>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::IUIElementOverrides8>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::IUIElementOverrides9>;
    protected:
        NumberBoxT()
        {
            impl::call_factory<NumberBox, INumberBoxFactory>([&](INumberBoxFactory const& f) { [[maybe_unused]] auto winrt_impl_discarded = f.CreateInstance(*this, this->m_inner); });
        }
    };
    template <typename D, typename... Interfaces>
    struct ParallaxViewT :
        implements<D, winrt::Windows::UI::Xaml::IFrameworkElementOverrides, winrt::Windows::UI::Xaml::IFrameworkElementOverrides2, winrt::Windows::UI::Xaml::IUIElementOverrides, winrt::Windows::UI::Xaml::IUIElementOverrides7, winrt::Windows::UI::Xaml::IUIElementOverrides8, winrt::Windows::UI::Xaml::IUIElementOverrides9, composing, Interfaces...>,
        impl::require<D, winrt::Microsoft::UI::Xaml::Controls::IParallaxView, winrt::Windows::UI::Xaml::IFrameworkElement, winrt::Windows::UI::Xaml::IFrameworkElement2, winrt::Windows::UI::Xaml::IFrameworkElement3, winrt::Windows::UI::Xaml::IFrameworkElement4, winrt::Windows::UI::Xaml::IFrameworkElement6, winrt::Windows::UI::Xaml::IFrameworkElement7, winrt::Windows::UI::Xaml::IUIElement, winrt::Windows::UI::Xaml::IUIElement2, winrt::Windows::UI::Xaml::IUIElement3, winrt::Windows::UI::Xaml::IUIElement4, winrt::Windows::UI::Xaml::IUIElement5, winrt::Windows::UI::Xaml::IUIElement7, winrt::Windows::UI::Xaml::IUIElement8, winrt::Windows::UI::Xaml::IUIElement9, winrt::Windows::UI::Xaml::IUIElement10, winrt::Windows::UI::Composition::IAnimationObject, winrt::Windows::UI::Composition::IVisualElement, winrt::Windows::UI::Xaml::IDependencyObject, winrt::Windows::UI::Xaml::IDependencyObject2>,
        protected impl::require<D, winrt::Windows::UI::Xaml::IFrameworkElementProtected7>,
        impl::base<D, ParallaxView, winrt::Windows::UI::Xaml::FrameworkElement, winrt::Windows::UI::Xaml::UIElement, winrt::Windows::UI::Xaml::DependencyObject>,
        winrt::Windows::UI::Xaml::IFrameworkElementOverridesT<D>, winrt::Windows::UI::Xaml::IFrameworkElementOverrides2T<D>, winrt::Windows::UI::Xaml::IUIElementOverridesT<D>, winrt::Windows::UI::Xaml::IUIElementOverrides7T<D>, winrt::Windows::UI::Xaml::IUIElementOverrides8T<D>, winrt::Windows::UI::Xaml::IUIElementOverrides9T<D>
    {
        using composable = ParallaxView;
        friend impl::consume_t<D, winrt::Windows::UI::Xaml::IFrameworkElementProtected7>;
        friend impl::require_one<D, winrt::Windows::UI::Xaml::IFrameworkElementProtected7>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::IFrameworkElementOverrides>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::IFrameworkElementOverrides2>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::IUIElementOverrides>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::IUIElementOverrides7>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::IUIElementOverrides8>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::IUIElementOverrides9>;
    protected:
        ParallaxViewT()
        {
            impl::call_factory<ParallaxView, IParallaxViewFactory>([&](IParallaxViewFactory const& f) { [[maybe_unused]] auto winrt_impl_discarded = f.CreateInstance(*this, this->m_inner); });
        }
    };
    template <typename D, typename... Interfaces>
    struct PathIconSourceT :
        implements<D, winrt::Windows::Foundation::IInspectable, composing, Interfaces...>,
        impl::require<D, winrt::Microsoft::UI::Xaml::Controls::IPathIconSource, winrt::Microsoft::UI::Xaml::Controls::IIconSource, winrt::Windows::UI::Xaml::IDependencyObject, winrt::Windows::UI::Xaml::IDependencyObject2>,
        impl::base<D, PathIconSource, winrt::Microsoft::UI::Xaml::Controls::IconSource, winrt::Windows::UI::Xaml::DependencyObject>
    {
        using composable = PathIconSource;
    protected:
        PathIconSourceT()
        {
            impl::call_factory<PathIconSource, IPathIconSourceFactory>([&](IPathIconSourceFactory const& f) { [[maybe_unused]] auto winrt_impl_discarded = f.CreateInstance(*this, this->m_inner); });
        }
    };
    template <typename D, typename... Interfaces>
    struct PersonPictureT :
        implements<D, winrt::Windows::UI::Xaml::Controls::IControlOverrides, winrt::Windows::UI::Xaml::Controls::IControlOverrides6, winrt::Windows::UI::Xaml::IFrameworkElementOverrides, winrt::Windows::UI::Xaml::IFrameworkElementOverrides2, winrt::Windows::UI::Xaml::IUIElementOverrides, winrt::Windows::UI::Xaml::IUIElementOverrides7, winrt::Windows::UI::Xaml::IUIElementOverrides8, winrt::Windows::UI::Xaml::IUIElementOverrides9, composing, Interfaces...>,
        impl::require<D, winrt::Microsoft::UI::Xaml::Controls::IPersonPicture, winrt::Windows::UI::Xaml::Controls::IControl, winrt::Windows::UI::Xaml::Controls::IControl2, winrt::Windows::UI::Xaml::Controls::IControl3, winrt::Windows::UI::Xaml::Controls::IControl4, winrt::Windows::UI::Xaml::Controls::IControl5, winrt::Windows::UI::Xaml::Controls::IControl7, winrt::Windows::UI::Xaml::IFrameworkElement, winrt::Windows::UI::Xaml::IFrameworkElement2, winrt::Windows::UI::Xaml::IFrameworkElement3, winrt::Windows::UI::Xaml::IFrameworkElement4, winrt::Windows::UI::Xaml::IFrameworkElement6, winrt::Windows::UI::Xaml::IFrameworkElement7, winrt::Windows::UI::Xaml::IUIElement, winrt::Windows::UI::Xaml::IUIElement2, winrt::Windows::UI::Xaml::IUIElement3, winrt::Windows::UI::Xaml::IUIElement4, winrt::Windows::UI::Xaml::IUIElement5, winrt::Windows::UI::Xaml::IUIElement7, winrt::Windows::UI::Xaml::IUIElement8, winrt::Windows::UI::Xaml::IUIElement9, winrt::Windows::UI::Xaml::IUIElement10, winrt::Windows::UI::Composition::IAnimationObject, winrt::Windows::UI::Composition::IVisualElement, winrt::Windows::UI::Xaml::IDependencyObject, winrt::Windows::UI::Xaml::IDependencyObject2>,
        protected impl::require<D, winrt::Windows::UI::Xaml::Controls::IControlProtected, winrt::Windows::UI::Xaml::IFrameworkElementProtected7>,
        impl::base<D, PersonPicture, winrt::Windows::UI::Xaml::Controls::Control, winrt::Windows::UI::Xaml::FrameworkElement, winrt::Windows::UI::Xaml::UIElement, winrt::Windows::UI::Xaml::DependencyObject>,
        winrt::Windows::UI::Xaml::Controls::IControlOverridesT<D>, winrt::Windows::UI::Xaml::Controls::IControlOverrides6T<D>, winrt::Windows::UI::Xaml::IFrameworkElementOverridesT<D>, winrt::Windows::UI::Xaml::IFrameworkElementOverrides2T<D>, winrt::Windows::UI::Xaml::IUIElementOverridesT<D>, winrt::Windows::UI::Xaml::IUIElementOverrides7T<D>, winrt::Windows::UI::Xaml::IUIElementOverrides8T<D>, winrt::Windows::UI::Xaml::IUIElementOverrides9T<D>
    {
        using composable = PersonPicture;
        friend impl::consume_t<D, winrt::Windows::UI::Xaml::Controls::IControlProtected>;
        friend impl::require_one<D, winrt::Windows::UI::Xaml::Controls::IControlProtected>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::Controls::IControlOverrides>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::Controls::IControlOverrides6>;
        friend impl::consume_t<D, winrt::Windows::UI::Xaml::IFrameworkElementProtected7>;
        friend impl::require_one<D, winrt::Windows::UI::Xaml::IFrameworkElementProtected7>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::IFrameworkElementOverrides>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::IFrameworkElementOverrides2>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::IUIElementOverrides>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::IUIElementOverrides7>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::IUIElementOverrides8>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::IUIElementOverrides9>;
    protected:
        PersonPictureT()
        {
            impl::call_factory<PersonPicture, IPersonPictureFactory>([&](IPersonPictureFactory const& f) { [[maybe_unused]] auto winrt_impl_discarded = f.CreateInstance(*this, this->m_inner); });
        }
    };
    template <typename D, typename... Interfaces>
    struct PipsPagerT :
        implements<D, winrt::Windows::UI::Xaml::Controls::IControlOverrides, winrt::Windows::UI::Xaml::Controls::IControlOverrides6, winrt::Windows::UI::Xaml::IFrameworkElementOverrides, winrt::Windows::UI::Xaml::IFrameworkElementOverrides2, winrt::Windows::UI::Xaml::IUIElementOverrides, winrt::Windows::UI::Xaml::IUIElementOverrides7, winrt::Windows::UI::Xaml::IUIElementOverrides8, winrt::Windows::UI::Xaml::IUIElementOverrides9, composing, Interfaces...>,
        impl::require<D, winrt::Microsoft::UI::Xaml::Controls::IPipsPager, winrt::Windows::UI::Xaml::Controls::IControl, winrt::Windows::UI::Xaml::Controls::IControl2, winrt::Windows::UI::Xaml::Controls::IControl3, winrt::Windows::UI::Xaml::Controls::IControl4, winrt::Windows::UI::Xaml::Controls::IControl5, winrt::Windows::UI::Xaml::Controls::IControl7, winrt::Windows::UI::Xaml::IFrameworkElement, winrt::Windows::UI::Xaml::IFrameworkElement2, winrt::Windows::UI::Xaml::IFrameworkElement3, winrt::Windows::UI::Xaml::IFrameworkElement4, winrt::Windows::UI::Xaml::IFrameworkElement6, winrt::Windows::UI::Xaml::IFrameworkElement7, winrt::Windows::UI::Xaml::IUIElement, winrt::Windows::UI::Xaml::IUIElement2, winrt::Windows::UI::Xaml::IUIElement3, winrt::Windows::UI::Xaml::IUIElement4, winrt::Windows::UI::Xaml::IUIElement5, winrt::Windows::UI::Xaml::IUIElement7, winrt::Windows::UI::Xaml::IUIElement8, winrt::Windows::UI::Xaml::IUIElement9, winrt::Windows::UI::Xaml::IUIElement10, winrt::Windows::UI::Composition::IAnimationObject, winrt::Windows::UI::Composition::IVisualElement, winrt::Windows::UI::Xaml::IDependencyObject, winrt::Windows::UI::Xaml::IDependencyObject2>,
        protected impl::require<D, winrt::Windows::UI::Xaml::Controls::IControlProtected, winrt::Windows::UI::Xaml::IFrameworkElementProtected7>,
        impl::base<D, PipsPager, winrt::Windows::UI::Xaml::Controls::Control, winrt::Windows::UI::Xaml::FrameworkElement, winrt::Windows::UI::Xaml::UIElement, winrt::Windows::UI::Xaml::DependencyObject>,
        winrt::Windows::UI::Xaml::Controls::IControlOverridesT<D>, winrt::Windows::UI::Xaml::Controls::IControlOverrides6T<D>, winrt::Windows::UI::Xaml::IFrameworkElementOverridesT<D>, winrt::Windows::UI::Xaml::IFrameworkElementOverrides2T<D>, winrt::Windows::UI::Xaml::IUIElementOverridesT<D>, winrt::Windows::UI::Xaml::IUIElementOverrides7T<D>, winrt::Windows::UI::Xaml::IUIElementOverrides8T<D>, winrt::Windows::UI::Xaml::IUIElementOverrides9T<D>
    {
        using composable = PipsPager;
        friend impl::consume_t<D, winrt::Windows::UI::Xaml::Controls::IControlProtected>;
        friend impl::require_one<D, winrt::Windows::UI::Xaml::Controls::IControlProtected>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::Controls::IControlOverrides>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::Controls::IControlOverrides6>;
        friend impl::consume_t<D, winrt::Windows::UI::Xaml::IFrameworkElementProtected7>;
        friend impl::require_one<D, winrt::Windows::UI::Xaml::IFrameworkElementProtected7>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::IFrameworkElementOverrides>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::IFrameworkElementOverrides2>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::IUIElementOverrides>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::IUIElementOverrides7>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::IUIElementOverrides8>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::IUIElementOverrides9>;
    protected:
        PipsPagerT()
        {
            impl::call_factory<PipsPager, IPipsPagerFactory>([&](IPipsPagerFactory const& f) { [[maybe_unused]] auto winrt_impl_discarded = f.CreateInstance(*this, this->m_inner); });
        }
    };
    template <typename D, typename... Interfaces>
    struct ProgressBarT :
        implements<D, winrt::Windows::UI::Xaml::Controls::Primitives::IRangeBaseOverrides, winrt::Windows::UI::Xaml::Controls::IControlOverrides, winrt::Windows::UI::Xaml::Controls::IControlOverrides6, winrt::Windows::UI::Xaml::IFrameworkElementOverrides, winrt::Windows::UI::Xaml::IFrameworkElementOverrides2, winrt::Windows::UI::Xaml::IUIElementOverrides, winrt::Windows::UI::Xaml::IUIElementOverrides7, winrt::Windows::UI::Xaml::IUIElementOverrides8, winrt::Windows::UI::Xaml::IUIElementOverrides9, composing, Interfaces...>,
        impl::require<D, winrt::Microsoft::UI::Xaml::Controls::IProgressBar, winrt::Windows::UI::Xaml::Controls::Primitives::IRangeBase, winrt::Windows::UI::Xaml::Controls::IControl, winrt::Windows::UI::Xaml::Controls::IControl2, winrt::Windows::UI::Xaml::Controls::IControl3, winrt::Windows::UI::Xaml::Controls::IControl4, winrt::Windows::UI::Xaml::Controls::IControl5, winrt::Windows::UI::Xaml::Controls::IControl7, winrt::Windows::UI::Xaml::IFrameworkElement, winrt::Windows::UI::Xaml::IFrameworkElement2, winrt::Windows::UI::Xaml::IFrameworkElement3, winrt::Windows::UI::Xaml::IFrameworkElement4, winrt::Windows::UI::Xaml::IFrameworkElement6, winrt::Windows::UI::Xaml::IFrameworkElement7, winrt::Windows::UI::Xaml::IUIElement, winrt::Windows::UI::Xaml::IUIElement2, winrt::Windows::UI::Xaml::IUIElement3, winrt::Windows::UI::Xaml::IUIElement4, winrt::Windows::UI::Xaml::IUIElement5, winrt::Windows::UI::Xaml::IUIElement7, winrt::Windows::UI::Xaml::IUIElement8, winrt::Windows::UI::Xaml::IUIElement9, winrt::Windows::UI::Xaml::IUIElement10, winrt::Windows::UI::Composition::IAnimationObject, winrt::Windows::UI::Composition::IVisualElement, winrt::Windows::UI::Xaml::IDependencyObject, winrt::Windows::UI::Xaml::IDependencyObject2>,
        protected impl::require<D, winrt::Windows::UI::Xaml::Controls::IControlProtected, winrt::Windows::UI::Xaml::IFrameworkElementProtected7>,
        impl::base<D, ProgressBar, winrt::Windows::UI::Xaml::Controls::Primitives::RangeBase, winrt::Windows::UI::Xaml::Controls::Control, winrt::Windows::UI::Xaml::FrameworkElement, winrt::Windows::UI::Xaml::UIElement, winrt::Windows::UI::Xaml::DependencyObject>,
        winrt::Windows::UI::Xaml::Controls::Primitives::IRangeBaseOverridesT<D>, winrt::Windows::UI::Xaml::Controls::IControlOverridesT<D>, winrt::Windows::UI::Xaml::Controls::IControlOverrides6T<D>, winrt::Windows::UI::Xaml::IFrameworkElementOverridesT<D>, winrt::Windows::UI::Xaml::IFrameworkElementOverrides2T<D>, winrt::Windows::UI::Xaml::IUIElementOverridesT<D>, winrt::Windows::UI::Xaml::IUIElementOverrides7T<D>, winrt::Windows::UI::Xaml::IUIElementOverrides8T<D>, winrt::Windows::UI::Xaml::IUIElementOverrides9T<D>
    {
        using composable = ProgressBar;
        friend impl::produce<D, winrt::Windows::UI::Xaml::Controls::Primitives::IRangeBaseOverrides>;
        friend impl::consume_t<D, winrt::Windows::UI::Xaml::Controls::IControlProtected>;
        friend impl::require_one<D, winrt::Windows::UI::Xaml::Controls::IControlProtected>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::Controls::IControlOverrides>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::Controls::IControlOverrides6>;
        friend impl::consume_t<D, winrt::Windows::UI::Xaml::IFrameworkElementProtected7>;
        friend impl::require_one<D, winrt::Windows::UI::Xaml::IFrameworkElementProtected7>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::IFrameworkElementOverrides>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::IFrameworkElementOverrides2>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::IUIElementOverrides>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::IUIElementOverrides7>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::IUIElementOverrides8>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::IUIElementOverrides9>;
    protected:
        ProgressBarT()
        {
            impl::call_factory<ProgressBar, IProgressBarFactory>([&](IProgressBarFactory const& f) { [[maybe_unused]] auto winrt_impl_discarded = f.CreateInstance(*this, this->m_inner); });
        }
    };
    template <typename D, typename... Interfaces>
    struct ProgressRingT :
        implements<D, winrt::Windows::UI::Xaml::Controls::IControlOverrides, winrt::Windows::UI::Xaml::Controls::IControlOverrides6, winrt::Windows::UI::Xaml::IFrameworkElementOverrides, winrt::Windows::UI::Xaml::IFrameworkElementOverrides2, winrt::Windows::UI::Xaml::IUIElementOverrides, winrt::Windows::UI::Xaml::IUIElementOverrides7, winrt::Windows::UI::Xaml::IUIElementOverrides8, winrt::Windows::UI::Xaml::IUIElementOverrides9, composing, Interfaces...>,
        impl::require<D, winrt::Microsoft::UI::Xaml::Controls::IProgressRing, winrt::Windows::UI::Xaml::Controls::IControl, winrt::Windows::UI::Xaml::Controls::IControl2, winrt::Windows::UI::Xaml::Controls::IControl3, winrt::Windows::UI::Xaml::Controls::IControl4, winrt::Windows::UI::Xaml::Controls::IControl5, winrt::Windows::UI::Xaml::Controls::IControl7, winrt::Windows::UI::Xaml::IFrameworkElement, winrt::Windows::UI::Xaml::IFrameworkElement2, winrt::Windows::UI::Xaml::IFrameworkElement3, winrt::Windows::UI::Xaml::IFrameworkElement4, winrt::Windows::UI::Xaml::IFrameworkElement6, winrt::Windows::UI::Xaml::IFrameworkElement7, winrt::Windows::UI::Xaml::IUIElement, winrt::Windows::UI::Xaml::IUIElement2, winrt::Windows::UI::Xaml::IUIElement3, winrt::Windows::UI::Xaml::IUIElement4, winrt::Windows::UI::Xaml::IUIElement5, winrt::Windows::UI::Xaml::IUIElement7, winrt::Windows::UI::Xaml::IUIElement8, winrt::Windows::UI::Xaml::IUIElement9, winrt::Windows::UI::Xaml::IUIElement10, winrt::Windows::UI::Composition::IAnimationObject, winrt::Windows::UI::Composition::IVisualElement, winrt::Windows::UI::Xaml::IDependencyObject, winrt::Windows::UI::Xaml::IDependencyObject2>,
        protected impl::require<D, winrt::Windows::UI::Xaml::Controls::IControlProtected, winrt::Windows::UI::Xaml::IFrameworkElementProtected7>,
        impl::base<D, ProgressRing, winrt::Windows::UI::Xaml::Controls::Control, winrt::Windows::UI::Xaml::FrameworkElement, winrt::Windows::UI::Xaml::UIElement, winrt::Windows::UI::Xaml::DependencyObject>,
        winrt::Windows::UI::Xaml::Controls::IControlOverridesT<D>, winrt::Windows::UI::Xaml::Controls::IControlOverrides6T<D>, winrt::Windows::UI::Xaml::IFrameworkElementOverridesT<D>, winrt::Windows::UI::Xaml::IFrameworkElementOverrides2T<D>, winrt::Windows::UI::Xaml::IUIElementOverridesT<D>, winrt::Windows::UI::Xaml::IUIElementOverrides7T<D>, winrt::Windows::UI::Xaml::IUIElementOverrides8T<D>, winrt::Windows::UI::Xaml::IUIElementOverrides9T<D>
    {
        using composable = ProgressRing;
        friend impl::consume_t<D, winrt::Windows::UI::Xaml::Controls::IControlProtected>;
        friend impl::require_one<D, winrt::Windows::UI::Xaml::Controls::IControlProtected>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::Controls::IControlOverrides>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::Controls::IControlOverrides6>;
        friend impl::consume_t<D, winrt::Windows::UI::Xaml::IFrameworkElementProtected7>;
        friend impl::require_one<D, winrt::Windows::UI::Xaml::IFrameworkElementProtected7>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::IFrameworkElementOverrides>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::IFrameworkElementOverrides2>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::IUIElementOverrides>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::IUIElementOverrides7>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::IUIElementOverrides8>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::IUIElementOverrides9>;
    protected:
        ProgressRingT()
        {
            impl::call_factory<ProgressRing, IProgressRingFactory>([&](IProgressRingFactory const& f) { [[maybe_unused]] auto winrt_impl_discarded = f.CreateInstance(*this, this->m_inner); });
        }
    };
    template <typename D, typename... Interfaces>
    struct RadioButtonsT :
        implements<D, winrt::Windows::UI::Xaml::Controls::IControlOverrides, winrt::Windows::UI::Xaml::Controls::IControlOverrides6, winrt::Windows::UI::Xaml::IFrameworkElementOverrides, winrt::Windows::UI::Xaml::IFrameworkElementOverrides2, winrt::Windows::UI::Xaml::IUIElementOverrides, winrt::Windows::UI::Xaml::IUIElementOverrides7, winrt::Windows::UI::Xaml::IUIElementOverrides8, winrt::Windows::UI::Xaml::IUIElementOverrides9, composing, Interfaces...>,
        impl::require<D, winrt::Microsoft::UI::Xaml::Controls::IRadioButtons, winrt::Windows::UI::Xaml::Controls::IControl, winrt::Windows::UI::Xaml::Controls::IControl2, winrt::Windows::UI::Xaml::Controls::IControl3, winrt::Windows::UI::Xaml::Controls::IControl4, winrt::Windows::UI::Xaml::Controls::IControl5, winrt::Windows::UI::Xaml::Controls::IControl7, winrt::Windows::UI::Xaml::IFrameworkElement, winrt::Windows::UI::Xaml::IFrameworkElement2, winrt::Windows::UI::Xaml::IFrameworkElement3, winrt::Windows::UI::Xaml::IFrameworkElement4, winrt::Windows::UI::Xaml::IFrameworkElement6, winrt::Windows::UI::Xaml::IFrameworkElement7, winrt::Windows::UI::Xaml::IUIElement, winrt::Windows::UI::Xaml::IUIElement2, winrt::Windows::UI::Xaml::IUIElement3, winrt::Windows::UI::Xaml::IUIElement4, winrt::Windows::UI::Xaml::IUIElement5, winrt::Windows::UI::Xaml::IUIElement7, winrt::Windows::UI::Xaml::IUIElement8, winrt::Windows::UI::Xaml::IUIElement9, winrt::Windows::UI::Xaml::IUIElement10, winrt::Windows::UI::Composition::IAnimationObject, winrt::Windows::UI::Composition::IVisualElement, winrt::Windows::UI::Xaml::IDependencyObject, winrt::Windows::UI::Xaml::IDependencyObject2>,
        protected impl::require<D, winrt::Windows::UI::Xaml::Controls::IControlProtected, winrt::Windows::UI::Xaml::IFrameworkElementProtected7>,
        impl::base<D, RadioButtons, winrt::Windows::UI::Xaml::Controls::Control, winrt::Windows::UI::Xaml::FrameworkElement, winrt::Windows::UI::Xaml::UIElement, winrt::Windows::UI::Xaml::DependencyObject>,
        winrt::Windows::UI::Xaml::Controls::IControlOverridesT<D>, winrt::Windows::UI::Xaml::Controls::IControlOverrides6T<D>, winrt::Windows::UI::Xaml::IFrameworkElementOverridesT<D>, winrt::Windows::UI::Xaml::IFrameworkElementOverrides2T<D>, winrt::Windows::UI::Xaml::IUIElementOverridesT<D>, winrt::Windows::UI::Xaml::IUIElementOverrides7T<D>, winrt::Windows::UI::Xaml::IUIElementOverrides8T<D>, winrt::Windows::UI::Xaml::IUIElementOverrides9T<D>
    {
        using composable = RadioButtons;
        friend impl::consume_t<D, winrt::Windows::UI::Xaml::Controls::IControlProtected>;
        friend impl::require_one<D, winrt::Windows::UI::Xaml::Controls::IControlProtected>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::Controls::IControlOverrides>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::Controls::IControlOverrides6>;
        friend impl::consume_t<D, winrt::Windows::UI::Xaml::IFrameworkElementProtected7>;
        friend impl::require_one<D, winrt::Windows::UI::Xaml::IFrameworkElementProtected7>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::IFrameworkElementOverrides>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::IFrameworkElementOverrides2>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::IUIElementOverrides>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::IUIElementOverrides7>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::IUIElementOverrides8>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::IUIElementOverrides9>;
    protected:
        RadioButtonsT()
        {
            impl::call_factory<RadioButtons, IRadioButtonsFactory>([&](IRadioButtonsFactory const& f) { [[maybe_unused]] auto winrt_impl_discarded = f.CreateInstance(*this, this->m_inner); });
        }
    };
    template <typename D, typename... Interfaces>
    struct RadioMenuFlyoutItemT :
        implements<D, winrt::Windows::UI::Xaml::Controls::IControlOverrides, winrt::Windows::UI::Xaml::Controls::IControlOverrides6, winrt::Windows::UI::Xaml::IFrameworkElementOverrides, winrt::Windows::UI::Xaml::IFrameworkElementOverrides2, winrt::Windows::UI::Xaml::IUIElementOverrides, winrt::Windows::UI::Xaml::IUIElementOverrides7, winrt::Windows::UI::Xaml::IUIElementOverrides8, winrt::Windows::UI::Xaml::IUIElementOverrides9, composing, Interfaces...>,
        impl::require<D, winrt::Microsoft::UI::Xaml::Controls::IRadioMenuFlyoutItem, winrt::Windows::UI::Xaml::Controls::IMenuFlyoutItem, winrt::Windows::UI::Xaml::Controls::IMenuFlyoutItem2, winrt::Windows::UI::Xaml::Controls::IMenuFlyoutItem3, winrt::Windows::UI::Xaml::Controls::IMenuFlyoutItemBase, winrt::Windows::UI::Xaml::Controls::IControl, winrt::Windows::UI::Xaml::Controls::IControl2, winrt::Windows::UI::Xaml::Controls::IControl3, winrt::Windows::UI::Xaml::Controls::IControl4, winrt::Windows::UI::Xaml::Controls::IControl5, winrt::Windows::UI::Xaml::Controls::IControl7, winrt::Windows::UI::Xaml::IFrameworkElement, winrt::Windows::UI::Xaml::IFrameworkElement2, winrt::Windows::UI::Xaml::IFrameworkElement3, winrt::Windows::UI::Xaml::IFrameworkElement4, winrt::Windows::UI::Xaml::IFrameworkElement6, winrt::Windows::UI::Xaml::IFrameworkElement7, winrt::Windows::UI::Xaml::IUIElement, winrt::Windows::UI::Xaml::IUIElement2, winrt::Windows::UI::Xaml::IUIElement3, winrt::Windows::UI::Xaml::IUIElement4, winrt::Windows::UI::Xaml::IUIElement5, winrt::Windows::UI::Xaml::IUIElement7, winrt::Windows::UI::Xaml::IUIElement8, winrt::Windows::UI::Xaml::IUIElement9, winrt::Windows::UI::Xaml::IUIElement10, winrt::Windows::UI::Composition::IAnimationObject, winrt::Windows::UI::Composition::IVisualElement, winrt::Windows::UI::Xaml::IDependencyObject, winrt::Windows::UI::Xaml::IDependencyObject2>,
        protected impl::require<D, winrt::Windows::UI::Xaml::Controls::IControlProtected, winrt::Windows::UI::Xaml::IFrameworkElementProtected7>,
        impl::base<D, RadioMenuFlyoutItem, winrt::Windows::UI::Xaml::Controls::MenuFlyoutItem, winrt::Windows::UI::Xaml::Controls::MenuFlyoutItemBase, winrt::Windows::UI::Xaml::Controls::Control, winrt::Windows::UI::Xaml::FrameworkElement, winrt::Windows::UI::Xaml::UIElement, winrt::Windows::UI::Xaml::DependencyObject>,
        winrt::Windows::UI::Xaml::Controls::IControlOverridesT<D>, winrt::Windows::UI::Xaml::Controls::IControlOverrides6T<D>, winrt::Windows::UI::Xaml::IFrameworkElementOverridesT<D>, winrt::Windows::UI::Xaml::IFrameworkElementOverrides2T<D>, winrt::Windows::UI::Xaml::IUIElementOverridesT<D>, winrt::Windows::UI::Xaml::IUIElementOverrides7T<D>, winrt::Windows::UI::Xaml::IUIElementOverrides8T<D>, winrt::Windows::UI::Xaml::IUIElementOverrides9T<D>
    {
        using composable = RadioMenuFlyoutItem;
        friend impl::consume_t<D, winrt::Windows::UI::Xaml::Controls::IControlProtected>;
        friend impl::require_one<D, winrt::Windows::UI::Xaml::Controls::IControlProtected>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::Controls::IControlOverrides>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::Controls::IControlOverrides6>;
        friend impl::consume_t<D, winrt::Windows::UI::Xaml::IFrameworkElementProtected7>;
        friend impl::require_one<D, winrt::Windows::UI::Xaml::IFrameworkElementProtected7>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::IFrameworkElementOverrides>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::IFrameworkElementOverrides2>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::IUIElementOverrides>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::IUIElementOverrides7>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::IUIElementOverrides8>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::IUIElementOverrides9>;
    protected:
        RadioMenuFlyoutItemT()
        {
            impl::call_factory<RadioMenuFlyoutItem, IRadioMenuFlyoutItemFactory>([&](IRadioMenuFlyoutItemFactory const& f) { [[maybe_unused]] auto winrt_impl_discarded = f.CreateInstance(*this, this->m_inner); });
        }
    };
    template <typename D, typename... Interfaces>
    struct RatingControlT :
        implements<D, winrt::Windows::UI::Xaml::Controls::IControlOverrides, winrt::Windows::UI::Xaml::Controls::IControlOverrides6, winrt::Windows::UI::Xaml::IFrameworkElementOverrides, winrt::Windows::UI::Xaml::IFrameworkElementOverrides2, winrt::Windows::UI::Xaml::IUIElementOverrides, winrt::Windows::UI::Xaml::IUIElementOverrides7, winrt::Windows::UI::Xaml::IUIElementOverrides8, winrt::Windows::UI::Xaml::IUIElementOverrides9, composing, Interfaces...>,
        impl::require<D, winrt::Microsoft::UI::Xaml::Controls::IRatingControl, winrt::Windows::UI::Xaml::Controls::IControl, winrt::Windows::UI::Xaml::Controls::IControl2, winrt::Windows::UI::Xaml::Controls::IControl3, winrt::Windows::UI::Xaml::Controls::IControl4, winrt::Windows::UI::Xaml::Controls::IControl5, winrt::Windows::UI::Xaml::Controls::IControl7, winrt::Windows::UI::Xaml::IFrameworkElement, winrt::Windows::UI::Xaml::IFrameworkElement2, winrt::Windows::UI::Xaml::IFrameworkElement3, winrt::Windows::UI::Xaml::IFrameworkElement4, winrt::Windows::UI::Xaml::IFrameworkElement6, winrt::Windows::UI::Xaml::IFrameworkElement7, winrt::Windows::UI::Xaml::IUIElement, winrt::Windows::UI::Xaml::IUIElement2, winrt::Windows::UI::Xaml::IUIElement3, winrt::Windows::UI::Xaml::IUIElement4, winrt::Windows::UI::Xaml::IUIElement5, winrt::Windows::UI::Xaml::IUIElement7, winrt::Windows::UI::Xaml::IUIElement8, winrt::Windows::UI::Xaml::IUIElement9, winrt::Windows::UI::Xaml::IUIElement10, winrt::Windows::UI::Composition::IAnimationObject, winrt::Windows::UI::Composition::IVisualElement, winrt::Windows::UI::Xaml::IDependencyObject, winrt::Windows::UI::Xaml::IDependencyObject2>,
        protected impl::require<D, winrt::Windows::UI::Xaml::Controls::IControlProtected, winrt::Windows::UI::Xaml::IFrameworkElementProtected7>,
        impl::base<D, RatingControl, winrt::Windows::UI::Xaml::Controls::Control, winrt::Windows::UI::Xaml::FrameworkElement, winrt::Windows::UI::Xaml::UIElement, winrt::Windows::UI::Xaml::DependencyObject>,
        winrt::Windows::UI::Xaml::Controls::IControlOverridesT<D>, winrt::Windows::UI::Xaml::Controls::IControlOverrides6T<D>, winrt::Windows::UI::Xaml::IFrameworkElementOverridesT<D>, winrt::Windows::UI::Xaml::IFrameworkElementOverrides2T<D>, winrt::Windows::UI::Xaml::IUIElementOverridesT<D>, winrt::Windows::UI::Xaml::IUIElementOverrides7T<D>, winrt::Windows::UI::Xaml::IUIElementOverrides8T<D>, winrt::Windows::UI::Xaml::IUIElementOverrides9T<D>
    {
        using composable = RatingControl;
        friend impl::consume_t<D, winrt::Windows::UI::Xaml::Controls::IControlProtected>;
        friend impl::require_one<D, winrt::Windows::UI::Xaml::Controls::IControlProtected>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::Controls::IControlOverrides>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::Controls::IControlOverrides6>;
        friend impl::consume_t<D, winrt::Windows::UI::Xaml::IFrameworkElementProtected7>;
        friend impl::require_one<D, winrt::Windows::UI::Xaml::IFrameworkElementProtected7>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::IFrameworkElementOverrides>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::IFrameworkElementOverrides2>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::IUIElementOverrides>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::IUIElementOverrides7>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::IUIElementOverrides8>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::IUIElementOverrides9>;
    protected:
        RatingControlT()
        {
            impl::call_factory<RatingControl, IRatingControlFactory>([&](IRatingControlFactory const& f) { [[maybe_unused]] auto winrt_impl_discarded = f.CreateInstance(*this, this->m_inner); });
        }
    };
    template <typename D, typename... Interfaces>
    struct RatingItemFontInfoT :
        implements<D, winrt::Windows::Foundation::IInspectable, composing, Interfaces...>,
        impl::require<D, winrt::Microsoft::UI::Xaml::Controls::IRatingItemFontInfo, winrt::Microsoft::UI::Xaml::Controls::IRatingItemInfo, winrt::Windows::UI::Xaml::IDependencyObject, winrt::Windows::UI::Xaml::IDependencyObject2>,
        impl::base<D, RatingItemFontInfo, winrt::Microsoft::UI::Xaml::Controls::RatingItemInfo, winrt::Windows::UI::Xaml::DependencyObject>
    {
        using composable = RatingItemFontInfo;
    protected:
        RatingItemFontInfoT()
        {
            impl::call_factory<RatingItemFontInfo, IRatingItemFontInfoFactory>([&](IRatingItemFontInfoFactory const& f) { [[maybe_unused]] auto winrt_impl_discarded = f.CreateInstance(*this, this->m_inner); });
        }
    };
    template <typename D, typename... Interfaces>
    struct RatingItemImageInfoT :
        implements<D, winrt::Windows::Foundation::IInspectable, composing, Interfaces...>,
        impl::require<D, winrt::Microsoft::UI::Xaml::Controls::IRatingItemImageInfo, winrt::Microsoft::UI::Xaml::Controls::IRatingItemInfo, winrt::Windows::UI::Xaml::IDependencyObject, winrt::Windows::UI::Xaml::IDependencyObject2>,
        impl::base<D, RatingItemImageInfo, winrt::Microsoft::UI::Xaml::Controls::RatingItemInfo, winrt::Windows::UI::Xaml::DependencyObject>
    {
        using composable = RatingItemImageInfo;
    protected:
        RatingItemImageInfoT()
        {
            impl::call_factory<RatingItemImageInfo, IRatingItemImageInfoFactory>([&](IRatingItemImageInfoFactory const& f) { [[maybe_unused]] auto winrt_impl_discarded = f.CreateInstance(*this, this->m_inner); });
        }
    };
    template <typename D, typename... Interfaces>
    struct RatingItemInfoT :
        implements<D, winrt::Windows::Foundation::IInspectable, composing, Interfaces...>,
        impl::require<D, winrt::Microsoft::UI::Xaml::Controls::IRatingItemInfo, winrt::Windows::UI::Xaml::IDependencyObject, winrt::Windows::UI::Xaml::IDependencyObject2>,
        impl::base<D, RatingItemInfo, winrt::Windows::UI::Xaml::DependencyObject>
    {
        using composable = RatingItemInfo;
    protected:
        RatingItemInfoT()
        {
            impl::call_factory<RatingItemInfo, IRatingItemInfoFactory>([&](IRatingItemInfoFactory const& f) { [[maybe_unused]] auto winrt_impl_discarded = f.CreateInstance(*this, this->m_inner); });
        }
    };
    template <typename D, typename... Interfaces>
    struct RefreshContainerT :
        implements<D, winrt::Windows::UI::Xaml::Controls::IContentControlOverrides, winrt::Windows::UI::Xaml::Controls::IControlOverrides, winrt::Windows::UI::Xaml::Controls::IControlOverrides6, winrt::Windows::UI::Xaml::IFrameworkElementOverrides, winrt::Windows::UI::Xaml::IFrameworkElementOverrides2, winrt::Windows::UI::Xaml::IUIElementOverrides, winrt::Windows::UI::Xaml::IUIElementOverrides7, winrt::Windows::UI::Xaml::IUIElementOverrides8, winrt::Windows::UI::Xaml::IUIElementOverrides9, composing, Interfaces...>,
        impl::require<D, winrt::Microsoft::UI::Xaml::Controls::IRefreshContainer, winrt::Windows::UI::Xaml::Controls::IContentControl, winrt::Windows::UI::Xaml::Controls::IContentControl2, winrt::Windows::UI::Xaml::Controls::IControl, winrt::Windows::UI::Xaml::Controls::IControl2, winrt::Windows::UI::Xaml::Controls::IControl3, winrt::Windows::UI::Xaml::Controls::IControl4, winrt::Windows::UI::Xaml::Controls::IControl5, winrt::Windows::UI::Xaml::Controls::IControl7, winrt::Windows::UI::Xaml::IFrameworkElement, winrt::Windows::UI::Xaml::IFrameworkElement2, winrt::Windows::UI::Xaml::IFrameworkElement3, winrt::Windows::UI::Xaml::IFrameworkElement4, winrt::Windows::UI::Xaml::IFrameworkElement6, winrt::Windows::UI::Xaml::IFrameworkElement7, winrt::Windows::UI::Xaml::IUIElement, winrt::Windows::UI::Xaml::IUIElement2, winrt::Windows::UI::Xaml::IUIElement3, winrt::Windows::UI::Xaml::IUIElement4, winrt::Windows::UI::Xaml::IUIElement5, winrt::Windows::UI::Xaml::IUIElement7, winrt::Windows::UI::Xaml::IUIElement8, winrt::Windows::UI::Xaml::IUIElement9, winrt::Windows::UI::Xaml::IUIElement10, winrt::Windows::UI::Composition::IAnimationObject, winrt::Windows::UI::Composition::IVisualElement, winrt::Windows::UI::Xaml::IDependencyObject, winrt::Windows::UI::Xaml::IDependencyObject2>,
        protected impl::require<D, winrt::Windows::UI::Xaml::Controls::IControlProtected, winrt::Windows::UI::Xaml::IFrameworkElementProtected7>,
        impl::base<D, RefreshContainer, winrt::Windows::UI::Xaml::Controls::ContentControl, winrt::Windows::UI::Xaml::Controls::Control, winrt::Windows::UI::Xaml::FrameworkElement, winrt::Windows::UI::Xaml::UIElement, winrt::Windows::UI::Xaml::DependencyObject>,
        winrt::Windows::UI::Xaml::Controls::IContentControlOverridesT<D>, winrt::Windows::UI::Xaml::Controls::IControlOverridesT<D>, winrt::Windows::UI::Xaml::Controls::IControlOverrides6T<D>, winrt::Windows::UI::Xaml::IFrameworkElementOverridesT<D>, winrt::Windows::UI::Xaml::IFrameworkElementOverrides2T<D>, winrt::Windows::UI::Xaml::IUIElementOverridesT<D>, winrt::Windows::UI::Xaml::IUIElementOverrides7T<D>, winrt::Windows::UI::Xaml::IUIElementOverrides8T<D>, winrt::Windows::UI::Xaml::IUIElementOverrides9T<D>
    {
        using composable = RefreshContainer;
        friend impl::produce<D, winrt::Windows::UI::Xaml::Controls::IContentControlOverrides>;
        friend impl::consume_t<D, winrt::Windows::UI::Xaml::Controls::IControlProtected>;
        friend impl::require_one<D, winrt::Windows::UI::Xaml::Controls::IControlProtected>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::Controls::IControlOverrides>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::Controls::IControlOverrides6>;
        friend impl::consume_t<D, winrt::Windows::UI::Xaml::IFrameworkElementProtected7>;
        friend impl::require_one<D, winrt::Windows::UI::Xaml::IFrameworkElementProtected7>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::IFrameworkElementOverrides>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::IFrameworkElementOverrides2>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::IUIElementOverrides>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::IUIElementOverrides7>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::IUIElementOverrides8>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::IUIElementOverrides9>;
    protected:
        RefreshContainerT()
        {
            impl::call_factory<RefreshContainer, IRefreshContainerFactory>([&](IRefreshContainerFactory const& f) { [[maybe_unused]] auto winrt_impl_discarded = f.CreateInstance(*this, this->m_inner); });
        }
    };
    template <typename D, typename... Interfaces>
    struct RefreshVisualizerT :
        implements<D, winrt::Windows::UI::Xaml::Controls::IControlOverrides, winrt::Windows::UI::Xaml::Controls::IControlOverrides6, winrt::Windows::UI::Xaml::IFrameworkElementOverrides, winrt::Windows::UI::Xaml::IFrameworkElementOverrides2, winrt::Windows::UI::Xaml::IUIElementOverrides, winrt::Windows::UI::Xaml::IUIElementOverrides7, winrt::Windows::UI::Xaml::IUIElementOverrides8, winrt::Windows::UI::Xaml::IUIElementOverrides9, composing, Interfaces...>,
        impl::require<D, winrt::Microsoft::UI::Xaml::Controls::IRefreshVisualizer, winrt::Windows::UI::Xaml::Controls::IControl, winrt::Windows::UI::Xaml::Controls::IControl2, winrt::Windows::UI::Xaml::Controls::IControl3, winrt::Windows::UI::Xaml::Controls::IControl4, winrt::Windows::UI::Xaml::Controls::IControl5, winrt::Windows::UI::Xaml::Controls::IControl7, winrt::Windows::UI::Xaml::IFrameworkElement, winrt::Windows::UI::Xaml::IFrameworkElement2, winrt::Windows::UI::Xaml::IFrameworkElement3, winrt::Windows::UI::Xaml::IFrameworkElement4, winrt::Windows::UI::Xaml::IFrameworkElement6, winrt::Windows::UI::Xaml::IFrameworkElement7, winrt::Windows::UI::Xaml::IUIElement, winrt::Windows::UI::Xaml::IUIElement2, winrt::Windows::UI::Xaml::IUIElement3, winrt::Windows::UI::Xaml::IUIElement4, winrt::Windows::UI::Xaml::IUIElement5, winrt::Windows::UI::Xaml::IUIElement7, winrt::Windows::UI::Xaml::IUIElement8, winrt::Windows::UI::Xaml::IUIElement9, winrt::Windows::UI::Xaml::IUIElement10, winrt::Windows::UI::Composition::IAnimationObject, winrt::Windows::UI::Composition::IVisualElement, winrt::Windows::UI::Xaml::IDependencyObject, winrt::Windows::UI::Xaml::IDependencyObject2>,
        protected impl::require<D, winrt::Windows::UI::Xaml::Controls::IControlProtected, winrt::Windows::UI::Xaml::IFrameworkElementProtected7>,
        impl::base<D, RefreshVisualizer, winrt::Windows::UI::Xaml::Controls::Control, winrt::Windows::UI::Xaml::FrameworkElement, winrt::Windows::UI::Xaml::UIElement, winrt::Windows::UI::Xaml::DependencyObject>,
        winrt::Windows::UI::Xaml::Controls::IControlOverridesT<D>, winrt::Windows::UI::Xaml::Controls::IControlOverrides6T<D>, winrt::Windows::UI::Xaml::IFrameworkElementOverridesT<D>, winrt::Windows::UI::Xaml::IFrameworkElementOverrides2T<D>, winrt::Windows::UI::Xaml::IUIElementOverridesT<D>, winrt::Windows::UI::Xaml::IUIElementOverrides7T<D>, winrt::Windows::UI::Xaml::IUIElementOverrides8T<D>, winrt::Windows::UI::Xaml::IUIElementOverrides9T<D>
    {
        using composable = RefreshVisualizer;
        friend impl::consume_t<D, winrt::Windows::UI::Xaml::Controls::IControlProtected>;
        friend impl::require_one<D, winrt::Windows::UI::Xaml::Controls::IControlProtected>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::Controls::IControlOverrides>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::Controls::IControlOverrides6>;
        friend impl::consume_t<D, winrt::Windows::UI::Xaml::IFrameworkElementProtected7>;
        friend impl::require_one<D, winrt::Windows::UI::Xaml::IFrameworkElementProtected7>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::IFrameworkElementOverrides>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::IFrameworkElementOverrides2>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::IUIElementOverrides>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::IUIElementOverrides7>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::IUIElementOverrides8>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::IUIElementOverrides9>;
    protected:
        RefreshVisualizerT()
        {
            impl::call_factory<RefreshVisualizer, IRefreshVisualizerFactory>([&](IRefreshVisualizerFactory const& f) { [[maybe_unused]] auto winrt_impl_discarded = f.CreateInstance(*this, this->m_inner); });
        }
    };
    template <typename D, typename... Interfaces>
    struct RevealListViewItemPresenterT :
        implements<D, winrt::Windows::UI::Xaml::Controls::IContentPresenterOverrides, winrt::Windows::UI::Xaml::IFrameworkElementOverrides, winrt::Windows::UI::Xaml::IFrameworkElementOverrides2, winrt::Windows::UI::Xaml::IUIElementOverrides, winrt::Windows::UI::Xaml::IUIElementOverrides7, winrt::Windows::UI::Xaml::IUIElementOverrides8, winrt::Windows::UI::Xaml::IUIElementOverrides9, composing, Interfaces...>,
        impl::require<D, winrt::Microsoft::UI::Xaml::Controls::IRevealListViewItemPresenter, winrt::Windows::UI::Xaml::Controls::Primitives::IListViewItemPresenter, winrt::Windows::UI::Xaml::Controls::Primitives::IListViewItemPresenter2, winrt::Windows::UI::Xaml::Controls::Primitives::IListViewItemPresenter3, winrt::Windows::UI::Xaml::Controls::Primitives::IListViewItemPresenter4, winrt::Windows::UI::Xaml::Controls::IContentPresenter, winrt::Windows::UI::Xaml::Controls::IContentPresenter2, winrt::Windows::UI::Xaml::Controls::IContentPresenter3, winrt::Windows::UI::Xaml::Controls::IContentPresenter4, winrt::Windows::UI::Xaml::Controls::IContentPresenter5, winrt::Windows::UI::Xaml::IFrameworkElement, winrt::Windows::UI::Xaml::IFrameworkElement2, winrt::Windows::UI::Xaml::IFrameworkElement3, winrt::Windows::UI::Xaml::IFrameworkElement4, winrt::Windows::UI::Xaml::IFrameworkElement6, winrt::Windows::UI::Xaml::IFrameworkElement7, winrt::Windows::UI::Xaml::IUIElement, winrt::Windows::UI::Xaml::IUIElement2, winrt::Windows::UI::Xaml::IUIElement3, winrt::Windows::UI::Xaml::IUIElement4, winrt::Windows::UI::Xaml::IUIElement5, winrt::Windows::UI::Xaml::IUIElement7, winrt::Windows::UI::Xaml::IUIElement8, winrt::Windows::UI::Xaml::IUIElement9, winrt::Windows::UI::Xaml::IUIElement10, winrt::Windows::UI::Composition::IAnimationObject, winrt::Windows::UI::Composition::IVisualElement, winrt::Windows::UI::Xaml::IDependencyObject, winrt::Windows::UI::Xaml::IDependencyObject2>,
        protected impl::require<D, winrt::Windows::UI::Xaml::IFrameworkElementProtected7>,
        impl::base<D, RevealListViewItemPresenter, winrt::Windows::UI::Xaml::Controls::Primitives::ListViewItemPresenter, winrt::Windows::UI::Xaml::Controls::ContentPresenter, winrt::Windows::UI::Xaml::FrameworkElement, winrt::Windows::UI::Xaml::UIElement, winrt::Windows::UI::Xaml::DependencyObject>,
        winrt::Windows::UI::Xaml::Controls::IContentPresenterOverridesT<D>, winrt::Windows::UI::Xaml::IFrameworkElementOverridesT<D>, winrt::Windows::UI::Xaml::IFrameworkElementOverrides2T<D>, winrt::Windows::UI::Xaml::IUIElementOverridesT<D>, winrt::Windows::UI::Xaml::IUIElementOverrides7T<D>, winrt::Windows::UI::Xaml::IUIElementOverrides8T<D>, winrt::Windows::UI::Xaml::IUIElementOverrides9T<D>
    {
        using composable = RevealListViewItemPresenter;
        friend impl::produce<D, winrt::Windows::UI::Xaml::Controls::IContentPresenterOverrides>;
        friend impl::consume_t<D, winrt::Windows::UI::Xaml::IFrameworkElementProtected7>;
        friend impl::require_one<D, winrt::Windows::UI::Xaml::IFrameworkElementProtected7>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::IFrameworkElementOverrides>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::IFrameworkElementOverrides2>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::IUIElementOverrides>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::IUIElementOverrides7>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::IUIElementOverrides8>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::IUIElementOverrides9>;
    protected:
        RevealListViewItemPresenterT()
        {
            impl::call_factory<RevealListViewItemPresenter, IRevealListViewItemPresenterFactory>([&](IRevealListViewItemPresenterFactory const& f) { [[maybe_unused]] auto winrt_impl_discarded = f.CreateInstance(*this, this->m_inner); });
        }
    };
    template <typename D, typename... Interfaces>
    struct SplitButtonT :
        implements<D, winrt::Windows::UI::Xaml::Controls::IContentControlOverrides, winrt::Windows::UI::Xaml::Controls::IControlOverrides, winrt::Windows::UI::Xaml::Controls::IControlOverrides6, winrt::Windows::UI::Xaml::IFrameworkElementOverrides, winrt::Windows::UI::Xaml::IFrameworkElementOverrides2, winrt::Windows::UI::Xaml::IUIElementOverrides, winrt::Windows::UI::Xaml::IUIElementOverrides7, winrt::Windows::UI::Xaml::IUIElementOverrides8, winrt::Windows::UI::Xaml::IUIElementOverrides9, composing, Interfaces...>,
        impl::require<D, winrt::Microsoft::UI::Xaml::Controls::ISplitButton, winrt::Windows::UI::Xaml::Controls::IContentControl, winrt::Windows::UI::Xaml::Controls::IContentControl2, winrt::Windows::UI::Xaml::Controls::IControl, winrt::Windows::UI::Xaml::Controls::IControl2, winrt::Windows::UI::Xaml::Controls::IControl3, winrt::Windows::UI::Xaml::Controls::IControl4, winrt::Windows::UI::Xaml::Controls::IControl5, winrt::Windows::UI::Xaml::Controls::IControl7, winrt::Windows::UI::Xaml::IFrameworkElement, winrt::Windows::UI::Xaml::IFrameworkElement2, winrt::Windows::UI::Xaml::IFrameworkElement3, winrt::Windows::UI::Xaml::IFrameworkElement4, winrt::Windows::UI::Xaml::IFrameworkElement6, winrt::Windows::UI::Xaml::IFrameworkElement7, winrt::Windows::UI::Xaml::IUIElement, winrt::Windows::UI::Xaml::IUIElement2, winrt::Windows::UI::Xaml::IUIElement3, winrt::Windows::UI::Xaml::IUIElement4, winrt::Windows::UI::Xaml::IUIElement5, winrt::Windows::UI::Xaml::IUIElement7, winrt::Windows::UI::Xaml::IUIElement8, winrt::Windows::UI::Xaml::IUIElement9, winrt::Windows::UI::Xaml::IUIElement10, winrt::Windows::UI::Composition::IAnimationObject, winrt::Windows::UI::Composition::IVisualElement, winrt::Windows::UI::Xaml::IDependencyObject, winrt::Windows::UI::Xaml::IDependencyObject2>,
        protected impl::require<D, winrt::Windows::UI::Xaml::Controls::IControlProtected, winrt::Windows::UI::Xaml::IFrameworkElementProtected7>,
        impl::base<D, SplitButton, winrt::Windows::UI::Xaml::Controls::ContentControl, winrt::Windows::UI::Xaml::Controls::Control, winrt::Windows::UI::Xaml::FrameworkElement, winrt::Windows::UI::Xaml::UIElement, winrt::Windows::UI::Xaml::DependencyObject>,
        winrt::Windows::UI::Xaml::Controls::IContentControlOverridesT<D>, winrt::Windows::UI::Xaml::Controls::IControlOverridesT<D>, winrt::Windows::UI::Xaml::Controls::IControlOverrides6T<D>, winrt::Windows::UI::Xaml::IFrameworkElementOverridesT<D>, winrt::Windows::UI::Xaml::IFrameworkElementOverrides2T<D>, winrt::Windows::UI::Xaml::IUIElementOverridesT<D>, winrt::Windows::UI::Xaml::IUIElementOverrides7T<D>, winrt::Windows::UI::Xaml::IUIElementOverrides8T<D>, winrt::Windows::UI::Xaml::IUIElementOverrides9T<D>
    {
        using composable = SplitButton;
        friend impl::produce<D, winrt::Windows::UI::Xaml::Controls::IContentControlOverrides>;
        friend impl::consume_t<D, winrt::Windows::UI::Xaml::Controls::IControlProtected>;
        friend impl::require_one<D, winrt::Windows::UI::Xaml::Controls::IControlProtected>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::Controls::IControlOverrides>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::Controls::IControlOverrides6>;
        friend impl::consume_t<D, winrt::Windows::UI::Xaml::IFrameworkElementProtected7>;
        friend impl::require_one<D, winrt::Windows::UI::Xaml::IFrameworkElementProtected7>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::IFrameworkElementOverrides>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::IFrameworkElementOverrides2>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::IUIElementOverrides>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::IUIElementOverrides7>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::IUIElementOverrides8>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::IUIElementOverrides9>;
    protected:
        SplitButtonT()
        {
            impl::call_factory<SplitButton, ISplitButtonFactory>([&](ISplitButtonFactory const& f) { [[maybe_unused]] auto winrt_impl_discarded = f.CreateInstance(*this, this->m_inner); });
        }
    };
    template <typename D, typename... Interfaces>
    struct StackLayoutT :
        implements<D, winrt::Microsoft::UI::Xaml::Controls::IVirtualizingLayoutOverrides, composing, Interfaces...>,
        impl::require<D, winrt::Microsoft::UI::Xaml::Controls::IStackLayout, winrt::Microsoft::UI::Xaml::Controls::IVirtualizingLayout, winrt::Microsoft::UI::Xaml::Controls::ILayout, winrt::Windows::UI::Xaml::IDependencyObject, winrt::Windows::UI::Xaml::IDependencyObject2>,
        protected impl::require<D, winrt::Microsoft::UI::Xaml::Controls::ILayoutProtected>,
        impl::base<D, StackLayout, winrt::Microsoft::UI::Xaml::Controls::VirtualizingLayout, winrt::Microsoft::UI::Xaml::Controls::Layout, winrt::Windows::UI::Xaml::DependencyObject>,
        winrt::Microsoft::UI::Xaml::Controls::IVirtualizingLayoutOverridesT<D>
    {
        using composable = StackLayout;
        friend impl::produce<D, winrt::Microsoft::UI::Xaml::Controls::IVirtualizingLayoutOverrides>;
        friend impl::consume_t<D, winrt::Microsoft::UI::Xaml::Controls::ILayoutProtected>;
        friend impl::require_one<D, winrt::Microsoft::UI::Xaml::Controls::ILayoutProtected>;
    protected:
        StackLayoutT()
        {
            impl::call_factory<StackLayout, IStackLayoutFactory>([&](IStackLayoutFactory const& f) { [[maybe_unused]] auto winrt_impl_discarded = f.CreateInstance(*this, this->m_inner); });
        }
    };
    template <typename D, typename... Interfaces>
    struct SwipeControlT :
        implements<D, winrt::Windows::UI::Xaml::Controls::IContentControlOverrides, winrt::Windows::UI::Xaml::Controls::IControlOverrides, winrt::Windows::UI::Xaml::Controls::IControlOverrides6, winrt::Windows::UI::Xaml::IFrameworkElementOverrides, winrt::Windows::UI::Xaml::IFrameworkElementOverrides2, winrt::Windows::UI::Xaml::IUIElementOverrides, winrt::Windows::UI::Xaml::IUIElementOverrides7, winrt::Windows::UI::Xaml::IUIElementOverrides8, winrt::Windows::UI::Xaml::IUIElementOverrides9, composing, Interfaces...>,
        impl::require<D, winrt::Microsoft::UI::Xaml::Controls::ISwipeControl, winrt::Windows::UI::Xaml::Controls::IContentControl, winrt::Windows::UI::Xaml::Controls::IContentControl2, winrt::Windows::UI::Xaml::Controls::IControl, winrt::Windows::UI::Xaml::Controls::IControl2, winrt::Windows::UI::Xaml::Controls::IControl3, winrt::Windows::UI::Xaml::Controls::IControl4, winrt::Windows::UI::Xaml::Controls::IControl5, winrt::Windows::UI::Xaml::Controls::IControl7, winrt::Windows::UI::Xaml::IFrameworkElement, winrt::Windows::UI::Xaml::IFrameworkElement2, winrt::Windows::UI::Xaml::IFrameworkElement3, winrt::Windows::UI::Xaml::IFrameworkElement4, winrt::Windows::UI::Xaml::IFrameworkElement6, winrt::Windows::UI::Xaml::IFrameworkElement7, winrt::Windows::UI::Xaml::IUIElement, winrt::Windows::UI::Xaml::IUIElement2, winrt::Windows::UI::Xaml::IUIElement3, winrt::Windows::UI::Xaml::IUIElement4, winrt::Windows::UI::Xaml::IUIElement5, winrt::Windows::UI::Xaml::IUIElement7, winrt::Windows::UI::Xaml::IUIElement8, winrt::Windows::UI::Xaml::IUIElement9, winrt::Windows::UI::Xaml::IUIElement10, winrt::Windows::UI::Composition::IAnimationObject, winrt::Windows::UI::Composition::IVisualElement, winrt::Windows::UI::Xaml::IDependencyObject, winrt::Windows::UI::Xaml::IDependencyObject2>,
        protected impl::require<D, winrt::Windows::UI::Xaml::Controls::IControlProtected, winrt::Windows::UI::Xaml::IFrameworkElementProtected7>,
        impl::base<D, SwipeControl, winrt::Windows::UI::Xaml::Controls::ContentControl, winrt::Windows::UI::Xaml::Controls::Control, winrt::Windows::UI::Xaml::FrameworkElement, winrt::Windows::UI::Xaml::UIElement, winrt::Windows::UI::Xaml::DependencyObject>,
        winrt::Windows::UI::Xaml::Controls::IContentControlOverridesT<D>, winrt::Windows::UI::Xaml::Controls::IControlOverridesT<D>, winrt::Windows::UI::Xaml::Controls::IControlOverrides6T<D>, winrt::Windows::UI::Xaml::IFrameworkElementOverridesT<D>, winrt::Windows::UI::Xaml::IFrameworkElementOverrides2T<D>, winrt::Windows::UI::Xaml::IUIElementOverridesT<D>, winrt::Windows::UI::Xaml::IUIElementOverrides7T<D>, winrt::Windows::UI::Xaml::IUIElementOverrides8T<D>, winrt::Windows::UI::Xaml::IUIElementOverrides9T<D>
    {
        using composable = SwipeControl;
        friend impl::produce<D, winrt::Windows::UI::Xaml::Controls::IContentControlOverrides>;
        friend impl::consume_t<D, winrt::Windows::UI::Xaml::Controls::IControlProtected>;
        friend impl::require_one<D, winrt::Windows::UI::Xaml::Controls::IControlProtected>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::Controls::IControlOverrides>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::Controls::IControlOverrides6>;
        friend impl::consume_t<D, winrt::Windows::UI::Xaml::IFrameworkElementProtected7>;
        friend impl::require_one<D, winrt::Windows::UI::Xaml::IFrameworkElementProtected7>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::IFrameworkElementOverrides>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::IFrameworkElementOverrides2>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::IUIElementOverrides>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::IUIElementOverrides7>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::IUIElementOverrides8>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::IUIElementOverrides9>;
    protected:
        SwipeControlT()
        {
            impl::call_factory<SwipeControl, ISwipeControlFactory>([&](ISwipeControlFactory const& f) { [[maybe_unused]] auto winrt_impl_discarded = f.CreateInstance(*this, this->m_inner); });
        }
    };
    template <typename D, typename... Interfaces>
    struct SwipeItemT :
        implements<D, winrt::Windows::Foundation::IInspectable, composing, Interfaces...>,
        impl::require<D, winrt::Microsoft::UI::Xaml::Controls::ISwipeItem, winrt::Windows::UI::Xaml::IDependencyObject, winrt::Windows::UI::Xaml::IDependencyObject2>,
        impl::base<D, SwipeItem, winrt::Windows::UI::Xaml::DependencyObject>
    {
        using composable = SwipeItem;
    protected:
        SwipeItemT()
        {
            impl::call_factory<SwipeItem, ISwipeItemFactory>([&](ISwipeItemFactory const& f) { [[maybe_unused]] auto winrt_impl_discarded = f.CreateInstance(*this, this->m_inner); });
        }
    };
    template <typename D, typename... Interfaces>
    struct SwipeItemsT :
        implements<D, winrt::Windows::Foundation::IInspectable, composing, Interfaces...>,
        impl::require<D, winrt::Microsoft::UI::Xaml::Controls::ISwipeItems, winrt::Windows::Foundation::Collections::IIterable<winrt::Microsoft::UI::Xaml::Controls::SwipeItem>, winrt::Windows::Foundation::Collections::IVector<winrt::Microsoft::UI::Xaml::Controls::SwipeItem>, winrt::Windows::UI::Xaml::IDependencyObject, winrt::Windows::UI::Xaml::IDependencyObject2>,
        impl::base<D, SwipeItems, winrt::Windows::UI::Xaml::DependencyObject>
    {
        using composable = SwipeItems;
    protected:
        SwipeItemsT()
        {
            impl::call_factory<SwipeItems, ISwipeItemsFactory>([&](ISwipeItemsFactory const& f) { [[maybe_unused]] auto winrt_impl_discarded = f.CreateInstance(*this, this->m_inner); });
        }
    };
    template <typename D, typename... Interfaces>
    struct SymbolIconSourceT :
        implements<D, winrt::Windows::Foundation::IInspectable, composing, Interfaces...>,
        impl::require<D, winrt::Microsoft::UI::Xaml::Controls::ISymbolIconSource, winrt::Microsoft::UI::Xaml::Controls::IIconSource, winrt::Windows::UI::Xaml::IDependencyObject, winrt::Windows::UI::Xaml::IDependencyObject2>,
        impl::base<D, SymbolIconSource, winrt::Microsoft::UI::Xaml::Controls::IconSource, winrt::Windows::UI::Xaml::DependencyObject>
    {
        using composable = SymbolIconSource;
    protected:
        SymbolIconSourceT()
        {
            impl::call_factory<SymbolIconSource, ISymbolIconSourceFactory>([&](ISymbolIconSourceFactory const& f) { [[maybe_unused]] auto winrt_impl_discarded = f.CreateInstance(*this, this->m_inner); });
        }
    };
    template <typename D, typename... Interfaces>
    struct TabViewT :
        implements<D, winrt::Windows::UI::Xaml::Controls::IControlOverrides, winrt::Windows::UI::Xaml::Controls::IControlOverrides6, winrt::Windows::UI::Xaml::IFrameworkElementOverrides, winrt::Windows::UI::Xaml::IFrameworkElementOverrides2, winrt::Windows::UI::Xaml::IUIElementOverrides, winrt::Windows::UI::Xaml::IUIElementOverrides7, winrt::Windows::UI::Xaml::IUIElementOverrides8, winrt::Windows::UI::Xaml::IUIElementOverrides9, composing, Interfaces...>,
        impl::require<D, winrt::Microsoft::UI::Xaml::Controls::ITabView, winrt::Windows::UI::Xaml::Controls::IControl, winrt::Windows::UI::Xaml::Controls::IControl2, winrt::Windows::UI::Xaml::Controls::IControl3, winrt::Windows::UI::Xaml::Controls::IControl4, winrt::Windows::UI::Xaml::Controls::IControl5, winrt::Windows::UI::Xaml::Controls::IControl7, winrt::Windows::UI::Xaml::IFrameworkElement, winrt::Windows::UI::Xaml::IFrameworkElement2, winrt::Windows::UI::Xaml::IFrameworkElement3, winrt::Windows::UI::Xaml::IFrameworkElement4, winrt::Windows::UI::Xaml::IFrameworkElement6, winrt::Windows::UI::Xaml::IFrameworkElement7, winrt::Windows::UI::Xaml::IUIElement, winrt::Windows::UI::Xaml::IUIElement2, winrt::Windows::UI::Xaml::IUIElement3, winrt::Windows::UI::Xaml::IUIElement4, winrt::Windows::UI::Xaml::IUIElement5, winrt::Windows::UI::Xaml::IUIElement7, winrt::Windows::UI::Xaml::IUIElement8, winrt::Windows::UI::Xaml::IUIElement9, winrt::Windows::UI::Xaml::IUIElement10, winrt::Windows::UI::Composition::IAnimationObject, winrt::Windows::UI::Composition::IVisualElement, winrt::Windows::UI::Xaml::IDependencyObject, winrt::Windows::UI::Xaml::IDependencyObject2>,
        protected impl::require<D, winrt::Windows::UI::Xaml::Controls::IControlProtected, winrt::Windows::UI::Xaml::IFrameworkElementProtected7>,
        impl::base<D, TabView, winrt::Windows::UI::Xaml::Controls::Control, winrt::Windows::UI::Xaml::FrameworkElement, winrt::Windows::UI::Xaml::UIElement, winrt::Windows::UI::Xaml::DependencyObject>,
        winrt::Windows::UI::Xaml::Controls::IControlOverridesT<D>, winrt::Windows::UI::Xaml::Controls::IControlOverrides6T<D>, winrt::Windows::UI::Xaml::IFrameworkElementOverridesT<D>, winrt::Windows::UI::Xaml::IFrameworkElementOverrides2T<D>, winrt::Windows::UI::Xaml::IUIElementOverridesT<D>, winrt::Windows::UI::Xaml::IUIElementOverrides7T<D>, winrt::Windows::UI::Xaml::IUIElementOverrides8T<D>, winrt::Windows::UI::Xaml::IUIElementOverrides9T<D>
    {
        using composable = TabView;
        friend impl::consume_t<D, winrt::Windows::UI::Xaml::Controls::IControlProtected>;
        friend impl::require_one<D, winrt::Windows::UI::Xaml::Controls::IControlProtected>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::Controls::IControlOverrides>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::Controls::IControlOverrides6>;
        friend impl::consume_t<D, winrt::Windows::UI::Xaml::IFrameworkElementProtected7>;
        friend impl::require_one<D, winrt::Windows::UI::Xaml::IFrameworkElementProtected7>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::IFrameworkElementOverrides>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::IFrameworkElementOverrides2>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::IUIElementOverrides>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::IUIElementOverrides7>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::IUIElementOverrides8>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::IUIElementOverrides9>;
    protected:
        TabViewT()
        {
            impl::call_factory<TabView, ITabViewFactory>([&](ITabViewFactory const& f) { [[maybe_unused]] auto winrt_impl_discarded = f.CreateInstance(*this, this->m_inner); });
        }
    };
    template <typename D, typename... Interfaces>
    struct TabViewItemT :
        implements<D, winrt::Windows::UI::Xaml::Controls::IContentControlOverrides, winrt::Windows::UI::Xaml::Controls::IControlOverrides, winrt::Windows::UI::Xaml::Controls::IControlOverrides6, winrt::Windows::UI::Xaml::IFrameworkElementOverrides, winrt::Windows::UI::Xaml::IFrameworkElementOverrides2, winrt::Windows::UI::Xaml::IUIElementOverrides, winrt::Windows::UI::Xaml::IUIElementOverrides7, winrt::Windows::UI::Xaml::IUIElementOverrides8, winrt::Windows::UI::Xaml::IUIElementOverrides9, composing, Interfaces...>,
        impl::require<D, winrt::Microsoft::UI::Xaml::Controls::ITabViewItem, winrt::Windows::UI::Xaml::Controls::IListViewItem, winrt::Windows::UI::Xaml::Controls::Primitives::ISelectorItem, winrt::Windows::UI::Xaml::Controls::IContentControl, winrt::Windows::UI::Xaml::Controls::IContentControl2, winrt::Windows::UI::Xaml::Controls::IControl, winrt::Windows::UI::Xaml::Controls::IControl2, winrt::Windows::UI::Xaml::Controls::IControl3, winrt::Windows::UI::Xaml::Controls::IControl4, winrt::Windows::UI::Xaml::Controls::IControl5, winrt::Windows::UI::Xaml::Controls::IControl7, winrt::Windows::UI::Xaml::IFrameworkElement, winrt::Windows::UI::Xaml::IFrameworkElement2, winrt::Windows::UI::Xaml::IFrameworkElement3, winrt::Windows::UI::Xaml::IFrameworkElement4, winrt::Windows::UI::Xaml::IFrameworkElement6, winrt::Windows::UI::Xaml::IFrameworkElement7, winrt::Windows::UI::Xaml::IUIElement, winrt::Windows::UI::Xaml::IUIElement2, winrt::Windows::UI::Xaml::IUIElement3, winrt::Windows::UI::Xaml::IUIElement4, winrt::Windows::UI::Xaml::IUIElement5, winrt::Windows::UI::Xaml::IUIElement7, winrt::Windows::UI::Xaml::IUIElement8, winrt::Windows::UI::Xaml::IUIElement9, winrt::Windows::UI::Xaml::IUIElement10, winrt::Windows::UI::Composition::IAnimationObject, winrt::Windows::UI::Composition::IVisualElement, winrt::Windows::UI::Xaml::IDependencyObject, winrt::Windows::UI::Xaml::IDependencyObject2>,
        protected impl::require<D, winrt::Windows::UI::Xaml::Controls::IControlProtected, winrt::Windows::UI::Xaml::IFrameworkElementProtected7>,
        impl::base<D, TabViewItem, winrt::Windows::UI::Xaml::Controls::ListViewItem, winrt::Windows::UI::Xaml::Controls::Primitives::SelectorItem, winrt::Windows::UI::Xaml::Controls::ContentControl, winrt::Windows::UI::Xaml::Controls::Control, winrt::Windows::UI::Xaml::FrameworkElement, winrt::Windows::UI::Xaml::UIElement, winrt::Windows::UI::Xaml::DependencyObject>,
        winrt::Windows::UI::Xaml::Controls::IContentControlOverridesT<D>, winrt::Windows::UI::Xaml::Controls::IControlOverridesT<D>, winrt::Windows::UI::Xaml::Controls::IControlOverrides6T<D>, winrt::Windows::UI::Xaml::IFrameworkElementOverridesT<D>, winrt::Windows::UI::Xaml::IFrameworkElementOverrides2T<D>, winrt::Windows::UI::Xaml::IUIElementOverridesT<D>, winrt::Windows::UI::Xaml::IUIElementOverrides7T<D>, winrt::Windows::UI::Xaml::IUIElementOverrides8T<D>, winrt::Windows::UI::Xaml::IUIElementOverrides9T<D>
    {
        using composable = TabViewItem;
        friend impl::produce<D, winrt::Windows::UI::Xaml::Controls::IContentControlOverrides>;
        friend impl::consume_t<D, winrt::Windows::UI::Xaml::Controls::IControlProtected>;
        friend impl::require_one<D, winrt::Windows::UI::Xaml::Controls::IControlProtected>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::Controls::IControlOverrides>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::Controls::IControlOverrides6>;
        friend impl::consume_t<D, winrt::Windows::UI::Xaml::IFrameworkElementProtected7>;
        friend impl::require_one<D, winrt::Windows::UI::Xaml::IFrameworkElementProtected7>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::IFrameworkElementOverrides>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::IFrameworkElementOverrides2>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::IUIElementOverrides>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::IUIElementOverrides7>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::IUIElementOverrides8>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::IUIElementOverrides9>;
    protected:
        TabViewItemT()
        {
            impl::call_factory<TabViewItem, ITabViewItemFactory>([&](ITabViewItemFactory const& f) { [[maybe_unused]] auto winrt_impl_discarded = f.CreateInstance(*this, this->m_inner); });
        }
    };
    template <typename D, typename... Interfaces>
    struct TabViewItemTemplateSettingsT :
        implements<D, winrt::Windows::Foundation::IInspectable, composing, Interfaces...>,
        impl::require<D, winrt::Microsoft::UI::Xaml::Controls::ITabViewItemTemplateSettings, winrt::Microsoft::UI::Xaml::Controls::ITabViewItemTemplateSettings2, winrt::Windows::UI::Xaml::IDependencyObject, winrt::Windows::UI::Xaml::IDependencyObject2>,
        impl::base<D, TabViewItemTemplateSettings, winrt::Windows::UI::Xaml::DependencyObject>
    {
        using composable = TabViewItemTemplateSettings;
    protected:
        TabViewItemTemplateSettingsT()
        {
            impl::call_factory<TabViewItemTemplateSettings, ITabViewItemTemplateSettingsFactory>([&](ITabViewItemTemplateSettingsFactory const& f) { [[maybe_unused]] auto winrt_impl_discarded = f.CreateInstance(*this, this->m_inner); });
        }
    };
    template <typename D, typename... Interfaces>
    struct TeachingTipT :
        implements<D, winrt::Windows::UI::Xaml::Controls::IContentControlOverrides, winrt::Windows::UI::Xaml::Controls::IControlOverrides, winrt::Windows::UI::Xaml::Controls::IControlOverrides6, winrt::Windows::UI::Xaml::IFrameworkElementOverrides, winrt::Windows::UI::Xaml::IFrameworkElementOverrides2, winrt::Windows::UI::Xaml::IUIElementOverrides, winrt::Windows::UI::Xaml::IUIElementOverrides7, winrt::Windows::UI::Xaml::IUIElementOverrides8, winrt::Windows::UI::Xaml::IUIElementOverrides9, composing, Interfaces...>,
        impl::require<D, winrt::Microsoft::UI::Xaml::Controls::ITeachingTip, winrt::Windows::UI::Xaml::Controls::IContentControl, winrt::Windows::UI::Xaml::Controls::IContentControl2, winrt::Windows::UI::Xaml::Controls::IControl, winrt::Windows::UI::Xaml::Controls::IControl2, winrt::Windows::UI::Xaml::Controls::IControl3, winrt::Windows::UI::Xaml::Controls::IControl4, winrt::Windows::UI::Xaml::Controls::IControl5, winrt::Windows::UI::Xaml::Controls::IControl7, winrt::Windows::UI::Xaml::IFrameworkElement, winrt::Windows::UI::Xaml::IFrameworkElement2, winrt::Windows::UI::Xaml::IFrameworkElement3, winrt::Windows::UI::Xaml::IFrameworkElement4, winrt::Windows::UI::Xaml::IFrameworkElement6, winrt::Windows::UI::Xaml::IFrameworkElement7, winrt::Windows::UI::Xaml::IUIElement, winrt::Windows::UI::Xaml::IUIElement2, winrt::Windows::UI::Xaml::IUIElement3, winrt::Windows::UI::Xaml::IUIElement4, winrt::Windows::UI::Xaml::IUIElement5, winrt::Windows::UI::Xaml::IUIElement7, winrt::Windows::UI::Xaml::IUIElement8, winrt::Windows::UI::Xaml::IUIElement9, winrt::Windows::UI::Xaml::IUIElement10, winrt::Windows::UI::Composition::IAnimationObject, winrt::Windows::UI::Composition::IVisualElement, winrt::Windows::UI::Xaml::IDependencyObject, winrt::Windows::UI::Xaml::IDependencyObject2>,
        protected impl::require<D, winrt::Windows::UI::Xaml::Controls::IControlProtected, winrt::Windows::UI::Xaml::IFrameworkElementProtected7>,
        impl::base<D, TeachingTip, winrt::Windows::UI::Xaml::Controls::ContentControl, winrt::Windows::UI::Xaml::Controls::Control, winrt::Windows::UI::Xaml::FrameworkElement, winrt::Windows::UI::Xaml::UIElement, winrt::Windows::UI::Xaml::DependencyObject>,
        winrt::Windows::UI::Xaml::Controls::IContentControlOverridesT<D>, winrt::Windows::UI::Xaml::Controls::IControlOverridesT<D>, winrt::Windows::UI::Xaml::Controls::IControlOverrides6T<D>, winrt::Windows::UI::Xaml::IFrameworkElementOverridesT<D>, winrt::Windows::UI::Xaml::IFrameworkElementOverrides2T<D>, winrt::Windows::UI::Xaml::IUIElementOverridesT<D>, winrt::Windows::UI::Xaml::IUIElementOverrides7T<D>, winrt::Windows::UI::Xaml::IUIElementOverrides8T<D>, winrt::Windows::UI::Xaml::IUIElementOverrides9T<D>
    {
        using composable = TeachingTip;
        friend impl::produce<D, winrt::Windows::UI::Xaml::Controls::IContentControlOverrides>;
        friend impl::consume_t<D, winrt::Windows::UI::Xaml::Controls::IControlProtected>;
        friend impl::require_one<D, winrt::Windows::UI::Xaml::Controls::IControlProtected>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::Controls::IControlOverrides>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::Controls::IControlOverrides6>;
        friend impl::consume_t<D, winrt::Windows::UI::Xaml::IFrameworkElementProtected7>;
        friend impl::require_one<D, winrt::Windows::UI::Xaml::IFrameworkElementProtected7>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::IFrameworkElementOverrides>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::IFrameworkElementOverrides2>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::IUIElementOverrides>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::IUIElementOverrides7>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::IUIElementOverrides8>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::IUIElementOverrides9>;
    protected:
        TeachingTipT()
        {
            impl::call_factory<TeachingTip, ITeachingTipFactory>([&](ITeachingTipFactory const& f) { [[maybe_unused]] auto winrt_impl_discarded = f.CreateInstance(*this, this->m_inner); });
        }
    };
    template <typename D, typename... Interfaces>
    struct TeachingTipTemplateSettingsT :
        implements<D, winrt::Windows::Foundation::IInspectable, composing, Interfaces...>,
        impl::require<D, winrt::Microsoft::UI::Xaml::Controls::ITeachingTipTemplateSettings, winrt::Windows::UI::Xaml::IDependencyObject, winrt::Windows::UI::Xaml::IDependencyObject2>,
        impl::base<D, TeachingTipTemplateSettings, winrt::Windows::UI::Xaml::DependencyObject>
    {
        using composable = TeachingTipTemplateSettings;
    protected:
        TeachingTipTemplateSettingsT()
        {
            impl::call_factory<TeachingTipTemplateSettings, ITeachingTipTemplateSettingsFactory>([&](ITeachingTipTemplateSettingsFactory const& f) { [[maybe_unused]] auto winrt_impl_discarded = f.CreateInstance(*this, this->m_inner); });
        }
    };
    template <typename D, typename... Interfaces>
    struct TextCommandBarFlyoutT :
        implements<D, winrt::Windows::UI::Xaml::Controls::Primitives::IFlyoutBaseOverrides, winrt::Windows::UI::Xaml::Controls::Primitives::IFlyoutBaseOverrides4, composing, Interfaces...>,
        impl::require<D, winrt::Microsoft::UI::Xaml::Controls::ITextCommandBarFlyout, winrt::Microsoft::UI::Xaml::Controls::ICommandBarFlyout, winrt::Microsoft::UI::Xaml::Controls::ICommandBarFlyout2, winrt::Windows::UI::Xaml::Controls::Primitives::IFlyoutBase, winrt::Windows::UI::Xaml::Controls::Primitives::IFlyoutBase2, winrt::Windows::UI::Xaml::Controls::Primitives::IFlyoutBase3, winrt::Windows::UI::Xaml::Controls::Primitives::IFlyoutBase4, winrt::Windows::UI::Xaml::Controls::Primitives::IFlyoutBase5, winrt::Windows::UI::Xaml::Controls::Primitives::IFlyoutBase6, winrt::Windows::UI::Xaml::IDependencyObject, winrt::Windows::UI::Xaml::IDependencyObject2>,
        impl::base<D, TextCommandBarFlyout, winrt::Microsoft::UI::Xaml::Controls::CommandBarFlyout, winrt::Windows::UI::Xaml::Controls::Primitives::FlyoutBase, winrt::Windows::UI::Xaml::DependencyObject>,
        winrt::Windows::UI::Xaml::Controls::Primitives::IFlyoutBaseOverridesT<D>, winrt::Windows::UI::Xaml::Controls::Primitives::IFlyoutBaseOverrides4T<D>
    {
        using composable = TextCommandBarFlyout;
        friend impl::produce<D, winrt::Windows::UI::Xaml::Controls::Primitives::IFlyoutBaseOverrides>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::Controls::Primitives::IFlyoutBaseOverrides4>;
    protected:
        TextCommandBarFlyoutT()
        {
            impl::call_factory<TextCommandBarFlyout, ITextCommandBarFlyoutFactory>([&](ITextCommandBarFlyoutFactory const& f) { [[maybe_unused]] auto winrt_impl_discarded = f.CreateInstance(*this, this->m_inner); });
        }
        using impl::consume_t<D, winrt::Windows::UI::Xaml::Controls::Primitives::IFlyoutBase>::ShowAt;
        using impl::consume_t<D, winrt::Windows::UI::Xaml::Controls::Primitives::IFlyoutBase5>::ShowAt;
    };
    template <typename D, typename... Interfaces>
    struct ToggleSplitButtonT :
        implements<D, winrt::Windows::UI::Xaml::Controls::IContentControlOverrides, winrt::Windows::UI::Xaml::Controls::IControlOverrides, winrt::Windows::UI::Xaml::Controls::IControlOverrides6, winrt::Windows::UI::Xaml::IFrameworkElementOverrides, winrt::Windows::UI::Xaml::IFrameworkElementOverrides2, winrt::Windows::UI::Xaml::IUIElementOverrides, winrt::Windows::UI::Xaml::IUIElementOverrides7, winrt::Windows::UI::Xaml::IUIElementOverrides8, winrt::Windows::UI::Xaml::IUIElementOverrides9, composing, Interfaces...>,
        impl::require<D, winrt::Microsoft::UI::Xaml::Controls::IToggleSplitButton, winrt::Microsoft::UI::Xaml::Controls::ISplitButton, winrt::Windows::UI::Xaml::Controls::IContentControl, winrt::Windows::UI::Xaml::Controls::IContentControl2, winrt::Windows::UI::Xaml::Controls::IControl, winrt::Windows::UI::Xaml::Controls::IControl2, winrt::Windows::UI::Xaml::Controls::IControl3, winrt::Windows::UI::Xaml::Controls::IControl4, winrt::Windows::UI::Xaml::Controls::IControl5, winrt::Windows::UI::Xaml::Controls::IControl7, winrt::Windows::UI::Xaml::IFrameworkElement, winrt::Windows::UI::Xaml::IFrameworkElement2, winrt::Windows::UI::Xaml::IFrameworkElement3, winrt::Windows::UI::Xaml::IFrameworkElement4, winrt::Windows::UI::Xaml::IFrameworkElement6, winrt::Windows::UI::Xaml::IFrameworkElement7, winrt::Windows::UI::Xaml::IUIElement, winrt::Windows::UI::Xaml::IUIElement2, winrt::Windows::UI::Xaml::IUIElement3, winrt::Windows::UI::Xaml::IUIElement4, winrt::Windows::UI::Xaml::IUIElement5, winrt::Windows::UI::Xaml::IUIElement7, winrt::Windows::UI::Xaml::IUIElement8, winrt::Windows::UI::Xaml::IUIElement9, winrt::Windows::UI::Xaml::IUIElement10, winrt::Windows::UI::Composition::IAnimationObject, winrt::Windows::UI::Composition::IVisualElement, winrt::Windows::UI::Xaml::IDependencyObject, winrt::Windows::UI::Xaml::IDependencyObject2>,
        protected impl::require<D, winrt::Windows::UI::Xaml::Controls::IControlProtected, winrt::Windows::UI::Xaml::IFrameworkElementProtected7>,
        impl::base<D, ToggleSplitButton, winrt::Microsoft::UI::Xaml::Controls::SplitButton, winrt::Windows::UI::Xaml::Controls::ContentControl, winrt::Windows::UI::Xaml::Controls::Control, winrt::Windows::UI::Xaml::FrameworkElement, winrt::Windows::UI::Xaml::UIElement, winrt::Windows::UI::Xaml::DependencyObject>,
        winrt::Windows::UI::Xaml::Controls::IContentControlOverridesT<D>, winrt::Windows::UI::Xaml::Controls::IControlOverridesT<D>, winrt::Windows::UI::Xaml::Controls::IControlOverrides6T<D>, winrt::Windows::UI::Xaml::IFrameworkElementOverridesT<D>, winrt::Windows::UI::Xaml::IFrameworkElementOverrides2T<D>, winrt::Windows::UI::Xaml::IUIElementOverridesT<D>, winrt::Windows::UI::Xaml::IUIElementOverrides7T<D>, winrt::Windows::UI::Xaml::IUIElementOverrides8T<D>, winrt::Windows::UI::Xaml::IUIElementOverrides9T<D>
    {
        using composable = ToggleSplitButton;
        friend impl::produce<D, winrt::Windows::UI::Xaml::Controls::IContentControlOverrides>;
        friend impl::consume_t<D, winrt::Windows::UI::Xaml::Controls::IControlProtected>;
        friend impl::require_one<D, winrt::Windows::UI::Xaml::Controls::IControlProtected>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::Controls::IControlOverrides>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::Controls::IControlOverrides6>;
        friend impl::consume_t<D, winrt::Windows::UI::Xaml::IFrameworkElementProtected7>;
        friend impl::require_one<D, winrt::Windows::UI::Xaml::IFrameworkElementProtected7>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::IFrameworkElementOverrides>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::IFrameworkElementOverrides2>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::IUIElementOverrides>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::IUIElementOverrides7>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::IUIElementOverrides8>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::IUIElementOverrides9>;
    protected:
        ToggleSplitButtonT()
        {
            impl::call_factory<ToggleSplitButton, IToggleSplitButtonFactory>([&](IToggleSplitButtonFactory const& f) { [[maybe_unused]] auto winrt_impl_discarded = f.CreateInstance(*this, this->m_inner); });
        }
    };
    template <typename D, typename... Interfaces>
    struct TreeViewT :
        implements<D, winrt::Windows::UI::Xaml::Controls::IControlOverrides, winrt::Windows::UI::Xaml::Controls::IControlOverrides6, winrt::Windows::UI::Xaml::IFrameworkElementOverrides, winrt::Windows::UI::Xaml::IFrameworkElementOverrides2, winrt::Windows::UI::Xaml::IUIElementOverrides, winrt::Windows::UI::Xaml::IUIElementOverrides7, winrt::Windows::UI::Xaml::IUIElementOverrides8, winrt::Windows::UI::Xaml::IUIElementOverrides9, composing, Interfaces...>,
        impl::require<D, winrt::Microsoft::UI::Xaml::Controls::ITreeView, winrt::Microsoft::UI::Xaml::Controls::ITreeView2, winrt::Windows::UI::Xaml::Controls::IControl, winrt::Windows::UI::Xaml::Controls::IControl2, winrt::Windows::UI::Xaml::Controls::IControl3, winrt::Windows::UI::Xaml::Controls::IControl4, winrt::Windows::UI::Xaml::Controls::IControl5, winrt::Windows::UI::Xaml::Controls::IControl7, winrt::Windows::UI::Xaml::IFrameworkElement, winrt::Windows::UI::Xaml::IFrameworkElement2, winrt::Windows::UI::Xaml::IFrameworkElement3, winrt::Windows::UI::Xaml::IFrameworkElement4, winrt::Windows::UI::Xaml::IFrameworkElement6, winrt::Windows::UI::Xaml::IFrameworkElement7, winrt::Windows::UI::Xaml::IUIElement, winrt::Windows::UI::Xaml::IUIElement2, winrt::Windows::UI::Xaml::IUIElement3, winrt::Windows::UI::Xaml::IUIElement4, winrt::Windows::UI::Xaml::IUIElement5, winrt::Windows::UI::Xaml::IUIElement7, winrt::Windows::UI::Xaml::IUIElement8, winrt::Windows::UI::Xaml::IUIElement9, winrt::Windows::UI::Xaml::IUIElement10, winrt::Windows::UI::Composition::IAnimationObject, winrt::Windows::UI::Composition::IVisualElement, winrt::Windows::UI::Xaml::IDependencyObject, winrt::Windows::UI::Xaml::IDependencyObject2>,
        protected impl::require<D, winrt::Windows::UI::Xaml::Controls::IControlProtected, winrt::Windows::UI::Xaml::IFrameworkElementProtected7>,
        impl::base<D, TreeView, winrt::Windows::UI::Xaml::Controls::Control, winrt::Windows::UI::Xaml::FrameworkElement, winrt::Windows::UI::Xaml::UIElement, winrt::Windows::UI::Xaml::DependencyObject>,
        winrt::Windows::UI::Xaml::Controls::IControlOverridesT<D>, winrt::Windows::UI::Xaml::Controls::IControlOverrides6T<D>, winrt::Windows::UI::Xaml::IFrameworkElementOverridesT<D>, winrt::Windows::UI::Xaml::IFrameworkElementOverrides2T<D>, winrt::Windows::UI::Xaml::IUIElementOverridesT<D>, winrt::Windows::UI::Xaml::IUIElementOverrides7T<D>, winrt::Windows::UI::Xaml::IUIElementOverrides8T<D>, winrt::Windows::UI::Xaml::IUIElementOverrides9T<D>
    {
        using composable = TreeView;
        friend impl::consume_t<D, winrt::Windows::UI::Xaml::Controls::IControlProtected>;
        friend impl::require_one<D, winrt::Windows::UI::Xaml::Controls::IControlProtected>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::Controls::IControlOverrides>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::Controls::IControlOverrides6>;
        friend impl::consume_t<D, winrt::Windows::UI::Xaml::IFrameworkElementProtected7>;
        friend impl::require_one<D, winrt::Windows::UI::Xaml::IFrameworkElementProtected7>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::IFrameworkElementOverrides>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::IFrameworkElementOverrides2>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::IUIElementOverrides>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::IUIElementOverrides7>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::IUIElementOverrides8>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::IUIElementOverrides9>;
    protected:
        TreeViewT()
        {
            impl::call_factory<TreeView, ITreeViewFactory>([&](ITreeViewFactory const& f) { [[maybe_unused]] auto winrt_impl_discarded = f.CreateInstance(*this, this->m_inner); });
        }
    };
    template <typename D, typename... Interfaces>
    struct TreeViewItemT :
        implements<D, winrt::Windows::UI::Xaml::Controls::IContentControlOverrides, winrt::Windows::UI::Xaml::Controls::IControlOverrides, winrt::Windows::UI::Xaml::Controls::IControlOverrides6, winrt::Windows::UI::Xaml::IFrameworkElementOverrides, winrt::Windows::UI::Xaml::IFrameworkElementOverrides2, winrt::Windows::UI::Xaml::IUIElementOverrides, winrt::Windows::UI::Xaml::IUIElementOverrides7, winrt::Windows::UI::Xaml::IUIElementOverrides8, winrt::Windows::UI::Xaml::IUIElementOverrides9, composing, Interfaces...>,
        impl::require<D, winrt::Microsoft::UI::Xaml::Controls::ITreeViewItem, winrt::Microsoft::UI::Xaml::Controls::ITreeViewItem2, winrt::Windows::UI::Xaml::Controls::IListViewItem, winrt::Windows::UI::Xaml::Controls::Primitives::ISelectorItem, winrt::Windows::UI::Xaml::Controls::IContentControl, winrt::Windows::UI::Xaml::Controls::IContentControl2, winrt::Windows::UI::Xaml::Controls::IControl, winrt::Windows::UI::Xaml::Controls::IControl2, winrt::Windows::UI::Xaml::Controls::IControl3, winrt::Windows::UI::Xaml::Controls::IControl4, winrt::Windows::UI::Xaml::Controls::IControl5, winrt::Windows::UI::Xaml::Controls::IControl7, winrt::Windows::UI::Xaml::IFrameworkElement, winrt::Windows::UI::Xaml::IFrameworkElement2, winrt::Windows::UI::Xaml::IFrameworkElement3, winrt::Windows::UI::Xaml::IFrameworkElement4, winrt::Windows::UI::Xaml::IFrameworkElement6, winrt::Windows::UI::Xaml::IFrameworkElement7, winrt::Windows::UI::Xaml::IUIElement, winrt::Windows::UI::Xaml::IUIElement2, winrt::Windows::UI::Xaml::IUIElement3, winrt::Windows::UI::Xaml::IUIElement4, winrt::Windows::UI::Xaml::IUIElement5, winrt::Windows::UI::Xaml::IUIElement7, winrt::Windows::UI::Xaml::IUIElement8, winrt::Windows::UI::Xaml::IUIElement9, winrt::Windows::UI::Xaml::IUIElement10, winrt::Windows::UI::Composition::IAnimationObject, winrt::Windows::UI::Composition::IVisualElement, winrt::Windows::UI::Xaml::IDependencyObject, winrt::Windows::UI::Xaml::IDependencyObject2>,
        protected impl::require<D, winrt::Windows::UI::Xaml::Controls::IControlProtected, winrt::Windows::UI::Xaml::IFrameworkElementProtected7>,
        impl::base<D, TreeViewItem, winrt::Windows::UI::Xaml::Controls::ListViewItem, winrt::Windows::UI::Xaml::Controls::Primitives::SelectorItem, winrt::Windows::UI::Xaml::Controls::ContentControl, winrt::Windows::UI::Xaml::Controls::Control, winrt::Windows::UI::Xaml::FrameworkElement, winrt::Windows::UI::Xaml::UIElement, winrt::Windows::UI::Xaml::DependencyObject>,
        winrt::Windows::UI::Xaml::Controls::IContentControlOverridesT<D>, winrt::Windows::UI::Xaml::Controls::IControlOverridesT<D>, winrt::Windows::UI::Xaml::Controls::IControlOverrides6T<D>, winrt::Windows::UI::Xaml::IFrameworkElementOverridesT<D>, winrt::Windows::UI::Xaml::IFrameworkElementOverrides2T<D>, winrt::Windows::UI::Xaml::IUIElementOverridesT<D>, winrt::Windows::UI::Xaml::IUIElementOverrides7T<D>, winrt::Windows::UI::Xaml::IUIElementOverrides8T<D>, winrt::Windows::UI::Xaml::IUIElementOverrides9T<D>
    {
        using composable = TreeViewItem;
        friend impl::produce<D, winrt::Windows::UI::Xaml::Controls::IContentControlOverrides>;
        friend impl::consume_t<D, winrt::Windows::UI::Xaml::Controls::IControlProtected>;
        friend impl::require_one<D, winrt::Windows::UI::Xaml::Controls::IControlProtected>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::Controls::IControlOverrides>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::Controls::IControlOverrides6>;
        friend impl::consume_t<D, winrt::Windows::UI::Xaml::IFrameworkElementProtected7>;
        friend impl::require_one<D, winrt::Windows::UI::Xaml::IFrameworkElementProtected7>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::IFrameworkElementOverrides>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::IFrameworkElementOverrides2>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::IUIElementOverrides>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::IUIElementOverrides7>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::IUIElementOverrides8>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::IUIElementOverrides9>;
    protected:
        TreeViewItemT()
        {
            impl::call_factory<TreeViewItem, ITreeViewItemFactory>([&](ITreeViewItemFactory const& f) { [[maybe_unused]] auto winrt_impl_discarded = f.CreateInstance(*this, this->m_inner); });
        }
    };
    template <typename D, typename... Interfaces>
    struct TreeViewItemTemplateSettingsT :
        implements<D, winrt::Windows::Foundation::IInspectable, composing, Interfaces...>,
        impl::require<D, winrt::Microsoft::UI::Xaml::Controls::ITreeViewItemTemplateSettings, winrt::Windows::UI::Xaml::IDependencyObject, winrt::Windows::UI::Xaml::IDependencyObject2>,
        impl::base<D, TreeViewItemTemplateSettings, winrt::Windows::UI::Xaml::DependencyObject>
    {
        using composable = TreeViewItemTemplateSettings;
    protected:
        TreeViewItemTemplateSettingsT()
        {
            impl::call_factory<TreeViewItemTemplateSettings, ITreeViewItemTemplateSettingsFactory>([&](ITreeViewItemTemplateSettingsFactory const& f) { [[maybe_unused]] auto winrt_impl_discarded = f.CreateInstance(*this, this->m_inner); });
        }
    };
    template <typename D, typename... Interfaces>
    struct TreeViewListT :
        implements<D, winrt::Windows::UI::Xaml::Controls::IItemsControlOverrides, winrt::Windows::UI::Xaml::Controls::IControlOverrides, winrt::Windows::UI::Xaml::Controls::IControlOverrides6, winrt::Windows::UI::Xaml::IFrameworkElementOverrides, winrt::Windows::UI::Xaml::IFrameworkElementOverrides2, winrt::Windows::UI::Xaml::IUIElementOverrides, winrt::Windows::UI::Xaml::IUIElementOverrides7, winrt::Windows::UI::Xaml::IUIElementOverrides8, winrt::Windows::UI::Xaml::IUIElementOverrides9, composing, Interfaces...>,
        impl::require<D, winrt::Microsoft::UI::Xaml::Controls::ITreeViewList, winrt::Windows::UI::Xaml::Controls::IListView, winrt::Windows::UI::Xaml::Controls::IListViewBase, winrt::Windows::UI::Xaml::Controls::IListViewBase2, winrt::Windows::UI::Xaml::Controls::IListViewBase3, winrt::Windows::UI::Xaml::Controls::IListViewBase4, winrt::Windows::UI::Xaml::Controls::IListViewBase5, winrt::Windows::UI::Xaml::Controls::IListViewBase6, winrt::Windows::UI::Xaml::Controls::ISemanticZoomInformation, winrt::Windows::UI::Xaml::Controls::Primitives::ISelector, winrt::Windows::UI::Xaml::Controls::IItemsControl, winrt::Windows::UI::Xaml::Controls::IItemsControl2, winrt::Windows::UI::Xaml::Controls::IItemsControl3, winrt::Windows::UI::Xaml::Controls::IItemContainerMapping, winrt::Windows::UI::Xaml::Controls::IControl, winrt::Windows::UI::Xaml::Controls::IControl2, winrt::Windows::UI::Xaml::Controls::IControl3, winrt::Windows::UI::Xaml::Controls::IControl4, winrt::Windows::UI::Xaml::Controls::IControl5, winrt::Windows::UI::Xaml::Controls::IControl7, winrt::Windows::UI::Xaml::IFrameworkElement, winrt::Windows::UI::Xaml::IFrameworkElement2, winrt::Windows::UI::Xaml::IFrameworkElement3, winrt::Windows::UI::Xaml::IFrameworkElement4, winrt::Windows::UI::Xaml::IFrameworkElement6, winrt::Windows::UI::Xaml::IFrameworkElement7, winrt::Windows::UI::Xaml::IUIElement, winrt::Windows::UI::Xaml::IUIElement2, winrt::Windows::UI::Xaml::IUIElement3, winrt::Windows::UI::Xaml::IUIElement4, winrt::Windows::UI::Xaml::IUIElement5, winrt::Windows::UI::Xaml::IUIElement7, winrt::Windows::UI::Xaml::IUIElement8, winrt::Windows::UI::Xaml::IUIElement9, winrt::Windows::UI::Xaml::IUIElement10, winrt::Windows::UI::Composition::IAnimationObject, winrt::Windows::UI::Composition::IVisualElement, winrt::Windows::UI::Xaml::IDependencyObject, winrt::Windows::UI::Xaml::IDependencyObject2>,
        protected impl::require<D, winrt::Windows::UI::Xaml::Controls::IControlProtected, winrt::Windows::UI::Xaml::IFrameworkElementProtected7>,
        impl::base<D, TreeViewList, winrt::Windows::UI::Xaml::Controls::ListView, winrt::Windows::UI::Xaml::Controls::ListViewBase, winrt::Windows::UI::Xaml::Controls::Primitives::Selector, winrt::Windows::UI::Xaml::Controls::ItemsControl, winrt::Windows::UI::Xaml::Controls::Control, winrt::Windows::UI::Xaml::FrameworkElement, winrt::Windows::UI::Xaml::UIElement, winrt::Windows::UI::Xaml::DependencyObject>,
        winrt::Windows::UI::Xaml::Controls::IItemsControlOverridesT<D>, winrt::Windows::UI::Xaml::Controls::IControlOverridesT<D>, winrt::Windows::UI::Xaml::Controls::IControlOverrides6T<D>, winrt::Windows::UI::Xaml::IFrameworkElementOverridesT<D>, winrt::Windows::UI::Xaml::IFrameworkElementOverrides2T<D>, winrt::Windows::UI::Xaml::IUIElementOverridesT<D>, winrt::Windows::UI::Xaml::IUIElementOverrides7T<D>, winrt::Windows::UI::Xaml::IUIElementOverrides8T<D>, winrt::Windows::UI::Xaml::IUIElementOverrides9T<D>
    {
        using composable = TreeViewList;
        friend impl::produce<D, winrt::Windows::UI::Xaml::Controls::IItemsControlOverrides>;
        friend impl::consume_t<D, winrt::Windows::UI::Xaml::Controls::IControlProtected>;
        friend impl::require_one<D, winrt::Windows::UI::Xaml::Controls::IControlProtected>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::Controls::IControlOverrides>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::Controls::IControlOverrides6>;
        friend impl::consume_t<D, winrt::Windows::UI::Xaml::IFrameworkElementProtected7>;
        friend impl::require_one<D, winrt::Windows::UI::Xaml::IFrameworkElementProtected7>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::IFrameworkElementOverrides>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::IFrameworkElementOverrides2>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::IUIElementOverrides>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::IUIElementOverrides7>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::IUIElementOverrides8>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::IUIElementOverrides9>;
    protected:
        TreeViewListT()
        {
            impl::call_factory<TreeViewList, ITreeViewListFactory>([&](ITreeViewListFactory const& f) { [[maybe_unused]] auto winrt_impl_discarded = f.CreateInstance(*this, this->m_inner); });
        }
    };
    template <typename D, typename... Interfaces>
    struct TreeViewNodeT :
        implements<D, winrt::Windows::Foundation::IInspectable, composing, Interfaces...>,
        impl::require<D, winrt::Microsoft::UI::Xaml::Controls::ITreeViewNode, winrt::Windows::UI::Xaml::IDependencyObject, winrt::Windows::UI::Xaml::IDependencyObject2>,
        impl::base<D, TreeViewNode, winrt::Windows::UI::Xaml::DependencyObject>
    {
        using composable = TreeViewNode;
    protected:
        TreeViewNodeT()
        {
            impl::call_factory<TreeViewNode, ITreeViewNodeFactory>([&](ITreeViewNodeFactory const& f) { [[maybe_unused]] auto winrt_impl_discarded = f.CreateInstance(*this, this->m_inner); });
        }
    };
    template <typename D, typename... Interfaces>
    struct TwoPaneViewT :
        implements<D, winrt::Windows::UI::Xaml::Controls::IControlOverrides, winrt::Windows::UI::Xaml::Controls::IControlOverrides6, winrt::Windows::UI::Xaml::IFrameworkElementOverrides, winrt::Windows::UI::Xaml::IFrameworkElementOverrides2, winrt::Windows::UI::Xaml::IUIElementOverrides, winrt::Windows::UI::Xaml::IUIElementOverrides7, winrt::Windows::UI::Xaml::IUIElementOverrides8, winrt::Windows::UI::Xaml::IUIElementOverrides9, composing, Interfaces...>,
        impl::require<D, winrt::Microsoft::UI::Xaml::Controls::ITwoPaneView, winrt::Windows::UI::Xaml::Controls::IControl, winrt::Windows::UI::Xaml::Controls::IControl2, winrt::Windows::UI::Xaml::Controls::IControl3, winrt::Windows::UI::Xaml::Controls::IControl4, winrt::Windows::UI::Xaml::Controls::IControl5, winrt::Windows::UI::Xaml::Controls::IControl7, winrt::Windows::UI::Xaml::IFrameworkElement, winrt::Windows::UI::Xaml::IFrameworkElement2, winrt::Windows::UI::Xaml::IFrameworkElement3, winrt::Windows::UI::Xaml::IFrameworkElement4, winrt::Windows::UI::Xaml::IFrameworkElement6, winrt::Windows::UI::Xaml::IFrameworkElement7, winrt::Windows::UI::Xaml::IUIElement, winrt::Windows::UI::Xaml::IUIElement2, winrt::Windows::UI::Xaml::IUIElement3, winrt::Windows::UI::Xaml::IUIElement4, winrt::Windows::UI::Xaml::IUIElement5, winrt::Windows::UI::Xaml::IUIElement7, winrt::Windows::UI::Xaml::IUIElement8, winrt::Windows::UI::Xaml::IUIElement9, winrt::Windows::UI::Xaml::IUIElement10, winrt::Windows::UI::Composition::IAnimationObject, winrt::Windows::UI::Composition::IVisualElement, winrt::Windows::UI::Xaml::IDependencyObject, winrt::Windows::UI::Xaml::IDependencyObject2>,
        protected impl::require<D, winrt::Windows::UI::Xaml::Controls::IControlProtected, winrt::Windows::UI::Xaml::IFrameworkElementProtected7>,
        impl::base<D, TwoPaneView, winrt::Windows::UI::Xaml::Controls::Control, winrt::Windows::UI::Xaml::FrameworkElement, winrt::Windows::UI::Xaml::UIElement, winrt::Windows::UI::Xaml::DependencyObject>,
        winrt::Windows::UI::Xaml::Controls::IControlOverridesT<D>, winrt::Windows::UI::Xaml::Controls::IControlOverrides6T<D>, winrt::Windows::UI::Xaml::IFrameworkElementOverridesT<D>, winrt::Windows::UI::Xaml::IFrameworkElementOverrides2T<D>, winrt::Windows::UI::Xaml::IUIElementOverridesT<D>, winrt::Windows::UI::Xaml::IUIElementOverrides7T<D>, winrt::Windows::UI::Xaml::IUIElementOverrides8T<D>, winrt::Windows::UI::Xaml::IUIElementOverrides9T<D>
    {
        using composable = TwoPaneView;
        friend impl::consume_t<D, winrt::Windows::UI::Xaml::Controls::IControlProtected>;
        friend impl::require_one<D, winrt::Windows::UI::Xaml::Controls::IControlProtected>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::Controls::IControlOverrides>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::Controls::IControlOverrides6>;
        friend impl::consume_t<D, winrt::Windows::UI::Xaml::IFrameworkElementProtected7>;
        friend impl::require_one<D, winrt::Windows::UI::Xaml::IFrameworkElementProtected7>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::IFrameworkElementOverrides>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::IFrameworkElementOverrides2>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::IUIElementOverrides>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::IUIElementOverrides7>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::IUIElementOverrides8>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::IUIElementOverrides9>;
    protected:
        TwoPaneViewT()
        {
            impl::call_factory<TwoPaneView, ITwoPaneViewFactory>([&](ITwoPaneViewFactory const& f) { [[maybe_unused]] auto winrt_impl_discarded = f.CreateInstance(*this, this->m_inner); });
        }
    };
    template <typename D, typename... Interfaces>
    struct UniformGridLayoutT :
        implements<D, winrt::Microsoft::UI::Xaml::Controls::IVirtualizingLayoutOverrides, composing, Interfaces...>,
        impl::require<D, winrt::Microsoft::UI::Xaml::Controls::IUniformGridLayout, winrt::Microsoft::UI::Xaml::Controls::IVirtualizingLayout, winrt::Microsoft::UI::Xaml::Controls::ILayout, winrt::Windows::UI::Xaml::IDependencyObject, winrt::Windows::UI::Xaml::IDependencyObject2>,
        protected impl::require<D, winrt::Microsoft::UI::Xaml::Controls::ILayoutProtected>,
        impl::base<D, UniformGridLayout, winrt::Microsoft::UI::Xaml::Controls::VirtualizingLayout, winrt::Microsoft::UI::Xaml::Controls::Layout, winrt::Windows::UI::Xaml::DependencyObject>,
        winrt::Microsoft::UI::Xaml::Controls::IVirtualizingLayoutOverridesT<D>
    {
        using composable = UniformGridLayout;
        friend impl::produce<D, winrt::Microsoft::UI::Xaml::Controls::IVirtualizingLayoutOverrides>;
        friend impl::consume_t<D, winrt::Microsoft::UI::Xaml::Controls::ILayoutProtected>;
        friend impl::require_one<D, winrt::Microsoft::UI::Xaml::Controls::ILayoutProtected>;
    protected:
        UniformGridLayoutT()
        {
            impl::call_factory<UniformGridLayout, IUniformGridLayoutFactory>([&](IUniformGridLayoutFactory const& f) { [[maybe_unused]] auto winrt_impl_discarded = f.CreateInstance(*this, this->m_inner); });
        }
    };
    template <typename D, typename... Interfaces>
    struct VirtualizingLayoutT :
        implements<D, winrt::Microsoft::UI::Xaml::Controls::IVirtualizingLayoutOverrides, composing, Interfaces...>,
        impl::require<D, winrt::Microsoft::UI::Xaml::Controls::IVirtualizingLayout, winrt::Microsoft::UI::Xaml::Controls::ILayout, winrt::Windows::UI::Xaml::IDependencyObject, winrt::Windows::UI::Xaml::IDependencyObject2>,
        protected impl::require<D, winrt::Microsoft::UI::Xaml::Controls::ILayoutProtected>,
        impl::base<D, VirtualizingLayout, winrt::Microsoft::UI::Xaml::Controls::Layout, winrt::Windows::UI::Xaml::DependencyObject>,
        winrt::Microsoft::UI::Xaml::Controls::IVirtualizingLayoutOverridesT<D>
    {
        using composable = VirtualizingLayout;
        friend impl::produce<D, winrt::Microsoft::UI::Xaml::Controls::IVirtualizingLayoutOverrides>;
        friend impl::consume_t<D, winrt::Microsoft::UI::Xaml::Controls::ILayoutProtected>;
        friend impl::require_one<D, winrt::Microsoft::UI::Xaml::Controls::ILayoutProtected>;
    protected:
        VirtualizingLayoutT()
        {
            impl::call_factory<VirtualizingLayout, IVirtualizingLayoutFactory>([&](IVirtualizingLayoutFactory const& f) { [[maybe_unused]] auto winrt_impl_discarded = f.CreateInstance(*this, this->m_inner); });
        }
    };
    template <typename D, typename... Interfaces>
    struct VirtualizingLayoutContextT :
        implements<D, winrt::Microsoft::UI::Xaml::Controls::IVirtualizingLayoutContextOverrides, winrt::Microsoft::UI::Xaml::Controls::ILayoutContextOverrides, composing, Interfaces...>,
        impl::require<D, winrt::Microsoft::UI::Xaml::Controls::IVirtualizingLayoutContext, winrt::Microsoft::UI::Xaml::Controls::ILayoutContext, winrt::Windows::UI::Xaml::IDependencyObject, winrt::Windows::UI::Xaml::IDependencyObject2>,
        impl::base<D, VirtualizingLayoutContext, winrt::Microsoft::UI::Xaml::Controls::LayoutContext, winrt::Windows::UI::Xaml::DependencyObject>,
        winrt::Microsoft::UI::Xaml::Controls::IVirtualizingLayoutContextOverridesT<D>, winrt::Microsoft::UI::Xaml::Controls::ILayoutContextOverridesT<D>
    {
        using composable = VirtualizingLayoutContext;
        friend impl::produce<D, winrt::Microsoft::UI::Xaml::Controls::IVirtualizingLayoutContextOverrides>;
        friend impl::produce<D, winrt::Microsoft::UI::Xaml::Controls::ILayoutContextOverrides>;
    protected:
        VirtualizingLayoutContextT()
        {
            impl::call_factory<VirtualizingLayoutContext, IVirtualizingLayoutContextFactory>([&](IVirtualizingLayoutContextFactory const& f) { [[maybe_unused]] auto winrt_impl_discarded = f.CreateInstance(*this, this->m_inner); });
        }
    };
    template <typename D, typename... Interfaces>
    struct WebView2T :
        implements<D, winrt::Windows::UI::Xaml::Controls::IControlOverrides, winrt::Windows::UI::Xaml::Controls::IControlOverrides6, winrt::Windows::UI::Xaml::IFrameworkElementOverrides, winrt::Windows::UI::Xaml::IFrameworkElementOverrides2, winrt::Windows::UI::Xaml::IUIElementOverrides, winrt::Windows::UI::Xaml::IUIElementOverrides7, winrt::Windows::UI::Xaml::IUIElementOverrides8, winrt::Windows::UI::Xaml::IUIElementOverrides9, composing, Interfaces...>,
        impl::require<D, winrt::Microsoft::UI::Xaml::Controls::IWebView2, winrt::Windows::UI::Xaml::Controls::IControl, winrt::Windows::UI::Xaml::Controls::IControl2, winrt::Windows::UI::Xaml::Controls::IControl3, winrt::Windows::UI::Xaml::Controls::IControl4, winrt::Windows::UI::Xaml::Controls::IControl5, winrt::Windows::UI::Xaml::Controls::IControl7, winrt::Windows::UI::Xaml::IFrameworkElement, winrt::Windows::UI::Xaml::IFrameworkElement2, winrt::Windows::UI::Xaml::IFrameworkElement3, winrt::Windows::UI::Xaml::IFrameworkElement4, winrt::Windows::UI::Xaml::IFrameworkElement6, winrt::Windows::UI::Xaml::IFrameworkElement7, winrt::Windows::UI::Xaml::IUIElement, winrt::Windows::UI::Xaml::IUIElement2, winrt::Windows::UI::Xaml::IUIElement3, winrt::Windows::UI::Xaml::IUIElement4, winrt::Windows::UI::Xaml::IUIElement5, winrt::Windows::UI::Xaml::IUIElement7, winrt::Windows::UI::Xaml::IUIElement8, winrt::Windows::UI::Xaml::IUIElement9, winrt::Windows::UI::Xaml::IUIElement10, winrt::Windows::UI::Composition::IAnimationObject, winrt::Windows::UI::Composition::IVisualElement, winrt::Windows::UI::Xaml::IDependencyObject, winrt::Windows::UI::Xaml::IDependencyObject2>,
        protected impl::require<D, winrt::Windows::UI::Xaml::Controls::IControlProtected, winrt::Windows::UI::Xaml::IFrameworkElementProtected7>,
        impl::base<D, WebView2, winrt::Windows::UI::Xaml::Controls::Control, winrt::Windows::UI::Xaml::FrameworkElement, winrt::Windows::UI::Xaml::UIElement, winrt::Windows::UI::Xaml::DependencyObject>,
        winrt::Windows::UI::Xaml::Controls::IControlOverridesT<D>, winrt::Windows::UI::Xaml::Controls::IControlOverrides6T<D>, winrt::Windows::UI::Xaml::IFrameworkElementOverridesT<D>, winrt::Windows::UI::Xaml::IFrameworkElementOverrides2T<D>, winrt::Windows::UI::Xaml::IUIElementOverridesT<D>, winrt::Windows::UI::Xaml::IUIElementOverrides7T<D>, winrt::Windows::UI::Xaml::IUIElementOverrides8T<D>, winrt::Windows::UI::Xaml::IUIElementOverrides9T<D>
    {
        using composable = WebView2;
        friend impl::consume_t<D, winrt::Windows::UI::Xaml::Controls::IControlProtected>;
        friend impl::require_one<D, winrt::Windows::UI::Xaml::Controls::IControlProtected>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::Controls::IControlOverrides>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::Controls::IControlOverrides6>;
        friend impl::consume_t<D, winrt::Windows::UI::Xaml::IFrameworkElementProtected7>;
        friend impl::require_one<D, winrt::Windows::UI::Xaml::IFrameworkElementProtected7>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::IFrameworkElementOverrides>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::IFrameworkElementOverrides2>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::IUIElementOverrides>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::IUIElementOverrides7>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::IUIElementOverrides8>;
        friend impl::produce<D, winrt::Windows::UI::Xaml::IUIElementOverrides9>;
    protected:
        WebView2T()
        {
            impl::call_factory<WebView2, IWebView2Factory>([&](IWebView2Factory const& f) { [[maybe_unused]] auto winrt_impl_discarded = f.CreateInstance(*this, this->m_inner); });
        }
    };
}
namespace std
{
#ifndef WINRT_LEAN_AND_MEAN
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::IAnimatedIcon> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::IAnimatedIconFactory> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::IAnimatedIconSource> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::IAnimatedIconSourceFactory> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::IAnimatedIconSourceStatics> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::IAnimatedIconStatics> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::IAnimatedVisual> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::IAnimatedVisual2> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::IAnimatedVisualPlayer> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::IAnimatedVisualPlayer2> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::IAnimatedVisualPlayerFactory> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::IAnimatedVisualPlayerStatics> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::IAnimatedVisualPlayerStatics2> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::IAnimatedVisualSource> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::IAnimatedVisualSource2> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::IAnimatedVisualSource3> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::IBackdropMaterial> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::IBackdropMaterialFactory> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::IBackdropMaterialStatics> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::IBitmapIconSource> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::IBitmapIconSourceFactory> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::IBitmapIconSourceStatics> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::IBreadcrumbBar> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::IBreadcrumbBarFactory> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::IBreadcrumbBarItem> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::IBreadcrumbBarItemClickedEventArgs> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::IBreadcrumbBarItemFactory> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::IBreadcrumbBarStatics> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::IColorChangedEventArgs> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::IColorPicker> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::IColorPicker2> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::IColorPickerFactory> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::IColorPickerStatics> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::IColorPickerStatics2> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::ICommandBarFlyout> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::ICommandBarFlyout2> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::ICommandBarFlyoutFactory> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::ICoreWebView2InitializedEventArgs> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::IDropDownButton> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::IDropDownButtonFactory> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::IDynamicAnimatedVisualSource> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::IElementFactory> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::IElementFactoryFactory> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::IElementFactoryGetArgs> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::IElementFactoryOverrides> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::IElementFactoryRecycleArgs> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::IExpander> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::IExpanderCollapsedEventArgs> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::IExpanderExpandingEventArgs> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::IExpanderFactory> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::IExpanderStatics> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::IExpanderTemplateSettings> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::IFontIconSource> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::IFontIconSourceFactory> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::IFontIconSourceStatics> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::IIconSource> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::IIconSourceFactory> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::IIconSourceStatics> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::IImageIcon> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::IImageIconFactory> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::IImageIconSource> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::IImageIconSourceFactory> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::IImageIconSourceStatics> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::IImageIconStatics> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::IInfoBadge> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::IInfoBadgeFactory> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::IInfoBadgeStatics> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::IInfoBadgeTemplateSettings> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::IInfoBadgeTemplateSettingsFactory> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::IInfoBadgeTemplateSettingsStatics> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::IInfoBar> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::IInfoBarClosedEventArgs> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::IInfoBarClosedEventArgsFactory> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::IInfoBarClosingEventArgs> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::IInfoBarClosingEventArgsFactory> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::IInfoBarFactory> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::IInfoBarStatics> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::IInfoBarTemplateSettings> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::IInfoBarTemplateSettingsFactory> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::IInfoBarTemplateSettingsStatics> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::IItemsRepeater> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::IItemsRepeaterElementClearingEventArgs> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::IItemsRepeaterElementIndexChangedEventArgs> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::IItemsRepeaterElementPreparedEventArgs> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::IItemsRepeaterFactory> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::IItemsRepeaterScrollHost> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::IItemsRepeaterStatics> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::IItemsSourceView> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::IItemsSourceViewFactory> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::IKeyIndexMapping> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::ILayout> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::ILayoutContext> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::ILayoutContextFactory> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::ILayoutContextOverrides> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::ILayoutFactory> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::ILayoutProtected> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::IMenuBar> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::IMenuBarFactory> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::IMenuBarItem> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::IMenuBarItemFactory> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::IMenuBarItemFlyout> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::IMenuBarItemFlyoutFactory> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::IMenuBarItemStatics> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::IMenuBarStatics> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::INavigationView> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::INavigationView2> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::INavigationViewBackRequestedEventArgs> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::INavigationViewDisplayModeChangedEventArgs> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::INavigationViewFactory> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::INavigationViewItem> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::INavigationViewItem2> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::INavigationViewItem3> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::INavigationViewItemBase> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::INavigationViewItemBase2> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::INavigationViewItemBaseFactory> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::INavigationViewItemBaseStatics> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::INavigationViewItemCollapsedEventArgs> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::INavigationViewItemExpandingEventArgs> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::INavigationViewItemFactory> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::INavigationViewItemHeader> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::INavigationViewItemHeaderFactory> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::INavigationViewItemInvokedEventArgs> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::INavigationViewItemInvokedEventArgs2> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::INavigationViewItemSeparator> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::INavigationViewItemSeparatorFactory> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::INavigationViewItemStatics> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::INavigationViewItemStatics2> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::INavigationViewItemStatics3> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::INavigationViewPaneClosingEventArgs> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::INavigationViewSelectionChangedEventArgs> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::INavigationViewSelectionChangedEventArgs2> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::INavigationViewStatics> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::INavigationViewStatics2> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::INavigationViewTemplateSettings> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::INavigationViewTemplateSettings2> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::INavigationViewTemplateSettingsFactory> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::INavigationViewTemplateSettingsStatics> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::INavigationViewTemplateSettingsStatics2> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::INonVirtualizingLayout> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::INonVirtualizingLayoutContext> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::INonVirtualizingLayoutContextFactory> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::INonVirtualizingLayoutContextOverrides> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::INonVirtualizingLayoutFactory> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::INonVirtualizingLayoutOverrides> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::INumberBox> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::INumberBoxFactory> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::INumberBoxStatics> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::INumberBoxValueChangedEventArgs> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::IParallaxView> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::IParallaxViewFactory> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::IParallaxViewStatics> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::IPathIconSource> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::IPathIconSourceFactory> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::IPathIconSourceStatics> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::IPersonPicture> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::IPersonPictureFactory> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::IPersonPictureStatics> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::IPersonPictureTemplateSettings> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::IPipsPager> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::IPipsPagerFactory> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::IPipsPagerSelectedIndexChangedEventArgs> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::IPipsPagerStatics> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::IPipsPagerTemplateSettings> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::IProgressBar> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::IProgressBarFactory> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::IProgressBarStatics> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::IProgressBarTemplateSettings> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::IProgressRing> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::IProgressRingFactory> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::IProgressRingStatics> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::IProgressRingTemplateSettings> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::IRadioButtons> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::IRadioButtonsFactory> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::IRadioButtonsStatics> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::IRadioMenuFlyoutItem> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::IRadioMenuFlyoutItemFactory> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::IRadioMenuFlyoutItemStatics> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::IRadioMenuFlyoutItemStatics2> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::IRatingControl> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::IRatingControlFactory> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::IRatingControlStatics> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::IRatingItemFontInfo> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::IRatingItemFontInfoFactory> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::IRatingItemFontInfoStatics> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::IRatingItemImageInfo> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::IRatingItemImageInfoFactory> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::IRatingItemImageInfoStatics> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::IRatingItemInfo> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::IRatingItemInfoFactory> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::IRefreshContainer> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::IRefreshContainerFactory> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::IRefreshContainerStatics> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::IRefreshInteractionRatioChangedEventArgs> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::IRefreshRequestedEventArgs> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::IRefreshStateChangedEventArgs> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::IRefreshVisualizer> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::IRefreshVisualizerFactory> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::IRefreshVisualizerStatics> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::IRevealListViewItemPresenter> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::IRevealListViewItemPresenterFactory> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::ISplitButton> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::ISplitButtonClickEventArgs> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::ISplitButtonFactory> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::ISplitButtonStatics> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::IStackLayout> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::IStackLayoutFactory> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::IStackLayoutStatics> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::ISwipeControl> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::ISwipeControlFactory> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::ISwipeControlStatics> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::ISwipeItem> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::ISwipeItemFactory> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::ISwipeItemInvokedEventArgs> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::ISwipeItemStatics> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::ISwipeItems> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::ISwipeItemsFactory> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::ISwipeItemsStatics> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::ISymbolIconSource> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::ISymbolIconSourceFactory> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::ISymbolIconSourceStatics> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::ITabView> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::ITabViewFactory> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::ITabViewItem> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::ITabViewItemFactory> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::ITabViewItemStatics> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::ITabViewItemTemplateSettings> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::ITabViewItemTemplateSettings2> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::ITabViewItemTemplateSettingsFactory> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::ITabViewItemTemplateSettingsStatics> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::ITabViewItemTemplateSettingsStatics2> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::ITabViewStatics> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::ITabViewTabCloseRequestedEventArgs> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::ITabViewTabDragCompletedEventArgs> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::ITabViewTabDragStartingEventArgs> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::ITabViewTabDroppedOutsideEventArgs> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::ITeachingTip> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::ITeachingTipClosedEventArgs> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::ITeachingTipClosingEventArgs> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::ITeachingTipFactory> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::ITeachingTipStatics> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::ITeachingTipTemplateSettings> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::ITeachingTipTemplateSettingsFactory> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::ITeachingTipTemplateSettingsStatics> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::ITextCommandBarFlyout> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::ITextCommandBarFlyoutFactory> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::IToggleSplitButton> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::IToggleSplitButtonFactory> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::IToggleSplitButtonIsCheckedChangedEventArgs> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::IToggleSplitButtonStatics> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::ITreeView> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::ITreeView2> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::ITreeViewCollapsedEventArgs> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::ITreeViewCollapsedEventArgs2> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::ITreeViewDragItemsCompletedEventArgs> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::ITreeViewDragItemsCompletedEventArgs2> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::ITreeViewDragItemsStartingEventArgs> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::ITreeViewExpandingEventArgs> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::ITreeViewExpandingEventArgs2> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::ITreeViewFactory> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::ITreeViewItem> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::ITreeViewItem2> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::ITreeViewItemFactory> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::ITreeViewItemInvokedEventArgs> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::ITreeViewItemStatics> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::ITreeViewItemStatics2> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::ITreeViewItemTemplateSettings> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::ITreeViewItemTemplateSettingsFactory> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::ITreeViewItemTemplateSettingsStatics> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::ITreeViewList> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::ITreeViewListFactory> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::ITreeViewNode> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::ITreeViewNodeFactory> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::ITreeViewNodeStatics> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::ITreeViewStatics> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::ITreeViewStatics2> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::ITwoPaneView> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::ITwoPaneViewFactory> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::ITwoPaneViewStatics> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::IUniformGridLayout> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::IUniformGridLayoutFactory> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::IUniformGridLayoutStatics> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::IVirtualizingLayout> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::IVirtualizingLayoutContext> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::IVirtualizingLayoutContextFactory> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::IVirtualizingLayoutContextOverrides> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::IVirtualizingLayoutFactory> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::IVirtualizingLayoutOverrides> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::IWebView2> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::IWebView2Factory> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::IWebView2Statics> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::IXamlControlsResources> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::IXamlControlsResources3> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::IXamlControlsResourcesStatics> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::IXamlControlsResourcesStatics3> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::AnimatedIcon> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::AnimatedIconSource> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::AnimatedVisualPlayer> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::BackdropMaterial> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::BitmapIconSource> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::BreadcrumbBar> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::BreadcrumbBarItem> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::BreadcrumbBarItemClickedEventArgs> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::ColorChangedEventArgs> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::ColorPicker> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::CommandBarFlyout> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::CoreWebView2InitializedEventArgs> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::DropDownButton> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::ElementFactory> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::ElementFactoryGetArgs> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::ElementFactoryRecycleArgs> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::Expander> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::ExpanderCollapsedEventArgs> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::ExpanderExpandingEventArgs> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::ExpanderTemplateSettings> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::FontIconSource> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::IconSource> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::ImageIcon> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::ImageIconSource> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::InfoBadge> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::InfoBadgeTemplateSettings> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::InfoBar> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::InfoBarClosedEventArgs> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::InfoBarClosingEventArgs> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::InfoBarTemplateSettings> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::ItemsRepeater> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::ItemsRepeaterElementClearingEventArgs> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::ItemsRepeaterElementIndexChangedEventArgs> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::ItemsRepeaterElementPreparedEventArgs> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::ItemsRepeaterScrollHost> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::ItemsSourceView> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::Layout> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::LayoutContext> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::MenuBar> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::MenuBarItem> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::MenuBarItemFlyout> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::NavigationView> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::NavigationViewBackRequestedEventArgs> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::NavigationViewDisplayModeChangedEventArgs> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::NavigationViewItem> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::NavigationViewItemBase> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::NavigationViewItemCollapsedEventArgs> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::NavigationViewItemExpandingEventArgs> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::NavigationViewItemHeader> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::NavigationViewItemInvokedEventArgs> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::NavigationViewItemSeparator> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::NavigationViewPaneClosingEventArgs> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::NavigationViewSelectionChangedEventArgs> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::NavigationViewTemplateSettings> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::NonVirtualizingLayout> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::NonVirtualizingLayoutContext> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::NumberBox> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::NumberBoxValueChangedEventArgs> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::ParallaxView> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::PathIconSource> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::PersonPicture> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::PersonPictureTemplateSettings> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::PipsPager> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::PipsPagerSelectedIndexChangedEventArgs> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::PipsPagerTemplateSettings> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::ProgressBar> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::ProgressBarTemplateSettings> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::ProgressRing> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::ProgressRingTemplateSettings> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::RadioButtons> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::RadioMenuFlyoutItem> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::RatingControl> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::RatingItemFontInfo> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::RatingItemImageInfo> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::RatingItemInfo> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::RefreshContainer> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::RefreshInteractionRatioChangedEventArgs> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::RefreshRequestedEventArgs> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::RefreshStateChangedEventArgs> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::RefreshVisualizer> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::RevealListViewItemPresenter> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::SplitButton> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::SplitButtonClickEventArgs> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::StackLayout> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::SwipeControl> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::SwipeItem> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::SwipeItemInvokedEventArgs> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::SwipeItems> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::SymbolIconSource> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::TabView> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::TabViewItem> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::TabViewItemTemplateSettings> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::TabViewTabCloseRequestedEventArgs> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::TabViewTabDragCompletedEventArgs> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::TabViewTabDragStartingEventArgs> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::TabViewTabDroppedOutsideEventArgs> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::TeachingTip> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::TeachingTipClosedEventArgs> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::TeachingTipClosingEventArgs> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::TeachingTipTemplateSettings> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::TextCommandBarFlyout> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::ToggleSplitButton> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::ToggleSplitButtonIsCheckedChangedEventArgs> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::TreeView> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::TreeViewCollapsedEventArgs> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::TreeViewDragItemsCompletedEventArgs> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::TreeViewDragItemsStartingEventArgs> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::TreeViewExpandingEventArgs> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::TreeViewItem> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::TreeViewItemInvokedEventArgs> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::TreeViewItemTemplateSettings> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::TreeViewList> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::TreeViewNode> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::TwoPaneView> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::UniformGridLayout> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::VirtualizingLayout> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::VirtualizingLayoutContext> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::WebView2> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Controls::XamlControlsResources> : winrt::impl::hash_base {};
#endif
#ifdef __cpp_lib_format
#endif
}
#endif
