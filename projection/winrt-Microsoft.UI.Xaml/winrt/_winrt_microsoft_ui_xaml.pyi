# WARNING: Please don't edit this file. It was generated by Python/WinRT v2.0.0-beta.2

import datetime
import sys
import types
import typing
import uuid as _uuid
from builtins import property as _property

import winrt._winrt
import winrt.system
import winrt.microsoft.ui.composition
import winrt.microsoft.ui.content
import winrt.microsoft.ui.dispatching
import winrt.microsoft.ui.input
import winrt.microsoft.ui.windowing
import winrt.microsoft.ui.xaml.automation.peers
import winrt.microsoft.ui.xaml.controls
import winrt.microsoft.ui.xaml.controls.primitives
import winrt.microsoft.ui.xaml.data
import winrt.microsoft.ui.xaml.input
import winrt.microsoft.ui.xaml.media
import winrt.microsoft.ui.xaml.media.animation
import winrt.microsoft.ui.xaml.media.imaging
import winrt.microsoft.ui.xaml.media.media3d
import winrt.microsoft.windows.applicationmodel.resources
import winrt.windows.applicationmodel.activation
import winrt.windows.applicationmodel.core
import winrt.windows.applicationmodel.datatransfer
import winrt.windows.applicationmodel.datatransfer.dragdrop
import winrt.windows.foundation
import winrt.windows.foundation.collections
import winrt.windows.foundation.numerics
import winrt.windows.graphics.imaging
import winrt.windows.ui
import winrt.windows.ui.core
import winrt.windows.ui.xaml.interop

from winrt.microsoft.ui.xaml import ApplicationHighContrastAdjustment, ApplicationRequiresPointerMode, ApplicationTheme, AutomationTextAttributesEnum, DurationType, ElementHighContrastAdjustment, ElementSoundKind, ElementSoundMode, ElementSoundPlayerState, ElementSpatialAudioMode, ElementTheme, FlowDirection, FocusState, FocusVisualKind, FontCapitals, FontEastAsianLanguage, FontEastAsianWidths, FontFraction, FontNumeralAlignment, FontNumeralStyle, FontVariants, GridUnitType, HorizontalAlignment, LineStackingStrategy, OpticalMarginAlignment, TextAlignment, TextLineBounds, TextReadingOrder, TextTrimming, TextWrapping, Vector3TransitionComponents, VerticalAlignment, Visibility, WindowActivationState
from winrt.microsoft.ui.xaml import ApplicationInitializationCallback, BindingFailedEventHandler, CreateDefaultValueCallback, DependencyPropertyChangedCallback, DependencyPropertyChangedEventHandler, DragEventHandler, EnteredBackgroundEventHandler, ExceptionRoutedEventHandler, LeavingBackgroundEventHandler, PropertyChangedCallback, RoutedEventHandler, SizeChangedEventHandler, SuspendingEventHandler, UnhandledExceptionEventHandler, VisualStateChangedEventHandler

Self = typing.TypeVar('Self')

@typing.final
class CornerRadius:
    top_left: winrt.system.Double
    top_right: winrt.system.Double
    bottom_right: winrt.system.Double
    bottom_left: winrt.system.Double
    def __init__(self, top_left: winrt.system.Double, top_right: winrt.system.Double, bottom_right: winrt.system.Double, bottom_left: winrt.system.Double) -> None: ...

@typing.final
class Duration:
    time_span: datetime.timedelta
    type: DurationType
    def __init__(self, time_span: datetime.timedelta, type: DurationType) -> None: ...

@typing.final
class GridLength:
    value: winrt.system.Double
    grid_unit_type: GridUnitType
    def __init__(self, value: winrt.system.Double, grid_unit_type: GridUnitType) -> None: ...

@typing.final
class Thickness:
    left: winrt.system.Double
    top: winrt.system.Double
    right: winrt.system.Double
    bottom: winrt.system.Double
    def __init__(self, left: winrt.system.Double, top: winrt.system.Double, right: winrt.system.Double, bottom: winrt.system.Double) -> None: ...

@typing.final
class AdaptiveTrigger_Static(type):
    @_property
    def min_window_height_property(cls) -> typing.Optional[DependencyProperty]: ...
    @_property
    def min_window_width_property(cls) -> typing.Optional[DependencyProperty]: ...

@typing.final
class AdaptiveTrigger(winrt.system.Object, metaclass=AdaptiveTrigger_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> AdaptiveTrigger: ...
    def __new__(cls: typing.Type[AdaptiveTrigger]) -> AdaptiveTrigger:...
    @_property
    def min_window_width(self) -> winrt.system.Double: ...
    @min_window_width.setter
    def min_window_width(self, value: winrt.system.Double) -> None: ...
    @_property
    def min_window_height(self) -> winrt.system.Double: ...
    @min_window_height.setter
    def min_window_height(self, value: winrt.system.Double) -> None: ...

@typing.final
class Application_Static(type):
    @typing.overload
    def load_component(cls, component: typing.Optional[winrt.system.Object], resource_locator: typing.Optional[winrt.windows.foundation.Uri], /) -> None: ...
    @typing.overload
    def load_component(cls, component: typing.Optional[winrt.system.Object], resource_locator: typing.Optional[winrt.windows.foundation.Uri], component_resource_location: winrt.microsoft.ui.xaml.controls.primitives.ComponentResourceLocation, /) -> None: ...
    def start(cls, callback: typing.Optional[ApplicationInitializationCallback], /) -> None: ...
    @_property
    def current(cls) -> typing.Optional[Application]: ...

@typing.final
class Application(winrt.system.Object, metaclass=Application_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> Application: ...
    def __new__(cls: typing.Type[Application]) -> Application:...
    def exit(self) -> None: ...
    def on_launched(self, args: typing.Optional[LaunchActivatedEventArgs], /) -> None: ...
    def add_unhandled_exception(self, handler: typing.Optional[UnhandledExceptionEventHandler], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_unhandled_exception(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_resource_manager_requested(self, handler: winrt.windows.foundation.TypedEventHandler[winrt.system.Object, ResourceManagerRequestedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_resource_manager_requested(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    @_property
    def resources(self) -> typing.Optional[ResourceDictionary]: ...
    @resources.setter
    def resources(self, value: typing.Optional[ResourceDictionary]) -> None: ...
    @_property
    def requested_theme(self) -> ApplicationTheme: ...
    @requested_theme.setter
    def requested_theme(self, value: ApplicationTheme) -> None: ...
    @_property
    def high_contrast_adjustment(self) -> ApplicationHighContrastAdjustment: ...
    @high_contrast_adjustment.setter
    def high_contrast_adjustment(self, value: ApplicationHighContrastAdjustment) -> None: ...
    @_property
    def focus_visual_kind(self) -> FocusVisualKind: ...
    @focus_visual_kind.setter
    def focus_visual_kind(self, value: FocusVisualKind) -> None: ...
    @_property
    def debug_settings(self) -> typing.Optional[DebugSettings]: ...

@typing.final
class ApplicationInitializationCallbackParams(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ApplicationInitializationCallbackParams: ...

@typing.final
class BindingFailedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> BindingFailedEventArgs: ...
    @_property
    def message(self) -> str: ...

@typing.final
class BringIntoViewOptions(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> BringIntoViewOptions: ...
    def __new__(cls: typing.Type[BringIntoViewOptions]) -> BringIntoViewOptions:...
    @_property
    def vertical_offset(self) -> winrt.system.Double: ...
    @vertical_offset.setter
    def vertical_offset(self, value: winrt.system.Double) -> None: ...
    @_property
    def vertical_alignment_ratio(self) -> winrt.system.Double: ...
    @vertical_alignment_ratio.setter
    def vertical_alignment_ratio(self, value: winrt.system.Double) -> None: ...
    @_property
    def target_rect(self) -> typing.Optional[typing.Optional[winrt.windows.foundation.Rect]]: ...
    @target_rect.setter
    def target_rect(self, value: typing.Optional[typing.Optional[winrt.windows.foundation.Rect]]) -> None: ...
    @_property
    def horizontal_offset(self) -> winrt.system.Double: ...
    @horizontal_offset.setter
    def horizontal_offset(self, value: winrt.system.Double) -> None: ...
    @_property
    def horizontal_alignment_ratio(self) -> winrt.system.Double: ...
    @horizontal_alignment_ratio.setter
    def horizontal_alignment_ratio(self, value: winrt.system.Double) -> None: ...
    @_property
    def animation_desired(self) -> bool: ...
    @animation_desired.setter
    def animation_desired(self, value: bool) -> None: ...

@typing.final
class BringIntoViewRequestedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> BringIntoViewRequestedEventArgs: ...
    @_property
    def vertical_offset(self) -> winrt.system.Double: ...
    @vertical_offset.setter
    def vertical_offset(self, value: winrt.system.Double) -> None: ...
    @_property
    def target_rect(self) -> winrt.windows.foundation.Rect: ...
    @target_rect.setter
    def target_rect(self, value: winrt.windows.foundation.Rect) -> None: ...
    @_property
    def target_element(self) -> typing.Optional[UIElement]: ...
    @target_element.setter
    def target_element(self, value: typing.Optional[UIElement]) -> None: ...
    @_property
    def horizontal_offset(self) -> winrt.system.Double: ...
    @horizontal_offset.setter
    def horizontal_offset(self, value: winrt.system.Double) -> None: ...
    @_property
    def handled(self) -> bool: ...
    @handled.setter
    def handled(self, value: bool) -> None: ...
    @_property
    def animation_desired(self) -> bool: ...
    @animation_desired.setter
    def animation_desired(self, value: bool) -> None: ...
    @_property
    def horizontal_alignment_ratio(self) -> winrt.system.Double: ...
    @_property
    def vertical_alignment_ratio(self) -> winrt.system.Double: ...

@typing.final
class BrushTransition(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> BrushTransition: ...
    def __new__(cls: typing.Type[BrushTransition]) -> BrushTransition:...
    @_property
    def duration(self) -> datetime.timedelta: ...
    @duration.setter
    def duration(self, value: datetime.timedelta) -> None: ...

@typing.final
class ColorPaletteResources(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ColorPaletteResources: ...
    def __new__(cls: typing.Type[ColorPaletteResources]) -> ColorPaletteResources:...
    @_property
    def list_medium(self) -> typing.Optional[typing.Optional[winrt.windows.ui.Color]]: ...
    @list_medium.setter
    def list_medium(self, value: typing.Optional[typing.Optional[winrt.windows.ui.Color]]) -> None: ...
    @_property
    def list_low(self) -> typing.Optional[typing.Optional[winrt.windows.ui.Color]]: ...
    @list_low.setter
    def list_low(self, value: typing.Optional[typing.Optional[winrt.windows.ui.Color]]) -> None: ...
    @_property
    def error_text(self) -> typing.Optional[typing.Optional[winrt.windows.ui.Color]]: ...
    @error_text.setter
    def error_text(self, value: typing.Optional[typing.Optional[winrt.windows.ui.Color]]) -> None: ...
    @_property
    def chrome_white(self) -> typing.Optional[typing.Optional[winrt.windows.ui.Color]]: ...
    @chrome_white.setter
    def chrome_white(self, value: typing.Optional[typing.Optional[winrt.windows.ui.Color]]) -> None: ...
    @_property
    def chrome_medium_low(self) -> typing.Optional[typing.Optional[winrt.windows.ui.Color]]: ...
    @chrome_medium_low.setter
    def chrome_medium_low(self, value: typing.Optional[typing.Optional[winrt.windows.ui.Color]]) -> None: ...
    @_property
    def chrome_medium(self) -> typing.Optional[typing.Optional[winrt.windows.ui.Color]]: ...
    @chrome_medium.setter
    def chrome_medium(self, value: typing.Optional[typing.Optional[winrt.windows.ui.Color]]) -> None: ...
    @_property
    def chrome_low(self) -> typing.Optional[typing.Optional[winrt.windows.ui.Color]]: ...
    @chrome_low.setter
    def chrome_low(self, value: typing.Optional[typing.Optional[winrt.windows.ui.Color]]) -> None: ...
    @_property
    def chrome_high(self) -> typing.Optional[typing.Optional[winrt.windows.ui.Color]]: ...
    @chrome_high.setter
    def chrome_high(self, value: typing.Optional[typing.Optional[winrt.windows.ui.Color]]) -> None: ...
    @_property
    def chrome_gray(self) -> typing.Optional[typing.Optional[winrt.windows.ui.Color]]: ...
    @chrome_gray.setter
    def chrome_gray(self, value: typing.Optional[typing.Optional[winrt.windows.ui.Color]]) -> None: ...
    @_property
    def chrome_disabled_low(self) -> typing.Optional[typing.Optional[winrt.windows.ui.Color]]: ...
    @chrome_disabled_low.setter
    def chrome_disabled_low(self, value: typing.Optional[typing.Optional[winrt.windows.ui.Color]]) -> None: ...
    @_property
    def chrome_disabled_high(self) -> typing.Optional[typing.Optional[winrt.windows.ui.Color]]: ...
    @chrome_disabled_high.setter
    def chrome_disabled_high(self, value: typing.Optional[typing.Optional[winrt.windows.ui.Color]]) -> None: ...
    @_property
    def chrome_black_medium_low(self) -> typing.Optional[typing.Optional[winrt.windows.ui.Color]]: ...
    @chrome_black_medium_low.setter
    def chrome_black_medium_low(self, value: typing.Optional[typing.Optional[winrt.windows.ui.Color]]) -> None: ...
    @_property
    def chrome_black_medium(self) -> typing.Optional[typing.Optional[winrt.windows.ui.Color]]: ...
    @chrome_black_medium.setter
    def chrome_black_medium(self, value: typing.Optional[typing.Optional[winrt.windows.ui.Color]]) -> None: ...
    @_property
    def chrome_black_low(self) -> typing.Optional[typing.Optional[winrt.windows.ui.Color]]: ...
    @chrome_black_low.setter
    def chrome_black_low(self, value: typing.Optional[typing.Optional[winrt.windows.ui.Color]]) -> None: ...
    @_property
    def chrome_black_high(self) -> typing.Optional[typing.Optional[winrt.windows.ui.Color]]: ...
    @chrome_black_high.setter
    def chrome_black_high(self, value: typing.Optional[typing.Optional[winrt.windows.ui.Color]]) -> None: ...
    @_property
    def chrome_alt_low(self) -> typing.Optional[typing.Optional[winrt.windows.ui.Color]]: ...
    @chrome_alt_low.setter
    def chrome_alt_low(self, value: typing.Optional[typing.Optional[winrt.windows.ui.Color]]) -> None: ...
    @_property
    def base_medium_low(self) -> typing.Optional[typing.Optional[winrt.windows.ui.Color]]: ...
    @base_medium_low.setter
    def base_medium_low(self, value: typing.Optional[typing.Optional[winrt.windows.ui.Color]]) -> None: ...
    @_property
    def base_medium_high(self) -> typing.Optional[typing.Optional[winrt.windows.ui.Color]]: ...
    @base_medium_high.setter
    def base_medium_high(self, value: typing.Optional[typing.Optional[winrt.windows.ui.Color]]) -> None: ...
    @_property
    def base_medium(self) -> typing.Optional[typing.Optional[winrt.windows.ui.Color]]: ...
    @base_medium.setter
    def base_medium(self, value: typing.Optional[typing.Optional[winrt.windows.ui.Color]]) -> None: ...
    @_property
    def base_low(self) -> typing.Optional[typing.Optional[winrt.windows.ui.Color]]: ...
    @base_low.setter
    def base_low(self, value: typing.Optional[typing.Optional[winrt.windows.ui.Color]]) -> None: ...
    @_property
    def base_high(self) -> typing.Optional[typing.Optional[winrt.windows.ui.Color]]: ...
    @base_high.setter
    def base_high(self, value: typing.Optional[typing.Optional[winrt.windows.ui.Color]]) -> None: ...
    @_property
    def alt_medium_low(self) -> typing.Optional[typing.Optional[winrt.windows.ui.Color]]: ...
    @alt_medium_low.setter
    def alt_medium_low(self, value: typing.Optional[typing.Optional[winrt.windows.ui.Color]]) -> None: ...
    @_property
    def alt_medium_high(self) -> typing.Optional[typing.Optional[winrt.windows.ui.Color]]: ...
    @alt_medium_high.setter
    def alt_medium_high(self, value: typing.Optional[typing.Optional[winrt.windows.ui.Color]]) -> None: ...
    @_property
    def alt_medium(self) -> typing.Optional[typing.Optional[winrt.windows.ui.Color]]: ...
    @alt_medium.setter
    def alt_medium(self, value: typing.Optional[typing.Optional[winrt.windows.ui.Color]]) -> None: ...
    @_property
    def alt_low(self) -> typing.Optional[typing.Optional[winrt.windows.ui.Color]]: ...
    @alt_low.setter
    def alt_low(self, value: typing.Optional[typing.Optional[winrt.windows.ui.Color]]) -> None: ...
    @_property
    def alt_high(self) -> typing.Optional[typing.Optional[winrt.windows.ui.Color]]: ...
    @alt_high.setter
    def alt_high(self, value: typing.Optional[typing.Optional[winrt.windows.ui.Color]]) -> None: ...
    @_property
    def accent(self) -> typing.Optional[typing.Optional[winrt.windows.ui.Color]]: ...
    @accent.setter
    def accent(self, value: typing.Optional[typing.Optional[winrt.windows.ui.Color]]) -> None: ...

@typing.final
class CornerRadiusHelper_Static(type):
    def from_radii(cls, top_left: winrt.system.Double, top_right: winrt.system.Double, bottom_right: winrt.system.Double, bottom_left: winrt.system.Double, /) -> CornerRadius: ...
    def from_uniform_radius(cls, uniform_radius: winrt.system.Double, /) -> CornerRadius: ...

@typing.final
class CornerRadiusHelper(winrt.system.Object, metaclass=CornerRadiusHelper_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> CornerRadiusHelper: ...

@typing.final
class DataContextChangedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> DataContextChangedEventArgs: ...
    @_property
    def handled(self) -> bool: ...
    @handled.setter
    def handled(self, value: bool) -> None: ...
    @_property
    def new_value(self) -> typing.Optional[winrt.system.Object]: ...

@typing.final
class DataTemplate_Static(type):
    def get_extension_instance(cls, element: typing.Optional[FrameworkElement], /) -> typing.Optional[IDataTemplateExtension]: ...
    def set_extension_instance(cls, element: typing.Optional[FrameworkElement], value: typing.Optional[IDataTemplateExtension], /) -> None: ...
    @_property
    def extension_instance_property(cls) -> typing.Optional[DependencyProperty]: ...

@typing.final
class DataTemplate(winrt.system.Object, metaclass=DataTemplate_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> DataTemplate: ...
    def __new__(cls: typing.Type[DataTemplate]) -> DataTemplate:...
    def get_element(self, args: typing.Optional[ElementFactoryGetArgs], /) -> typing.Optional[UIElement]: ...
    def load_content(self) -> typing.Optional[DependencyObject]: ...
    def recycle_element(self, args: typing.Optional[ElementFactoryRecycleArgs], /) -> None: ...

@typing.final
class DataTemplateKey(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> DataTemplateKey: ...
    @typing.overload
    def __new__(cls: typing.Type[DataTemplateKey]) -> DataTemplateKey:...
    @typing.overload
    def __new__(cls: typing.Type[DataTemplateKey], data_type: typing.Optional[winrt.system.Object]) -> DataTemplateKey:...
    @_property
    def data_type(self) -> typing.Optional[winrt.system.Object]: ...
    @data_type.setter
    def data_type(self, value: typing.Optional[winrt.system.Object]) -> None: ...

@typing.final
class DebugSettings(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> DebugSettings: ...
    def add_binding_failed(self, handler: typing.Optional[BindingFailedEventHandler], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_binding_failed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_xaml_resource_reference_failed(self, handler: winrt.windows.foundation.TypedEventHandler[DebugSettings, XamlResourceReferenceFailedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_xaml_resource_reference_failed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    @_property
    def is_text_performance_visualization_enabled(self) -> bool: ...
    @is_text_performance_visualization_enabled.setter
    def is_text_performance_visualization_enabled(self, value: bool) -> None: ...
    @_property
    def is_binding_tracing_enabled(self) -> bool: ...
    @is_binding_tracing_enabled.setter
    def is_binding_tracing_enabled(self, value: bool) -> None: ...
    @_property
    def fail_fast_on_errors(self) -> bool: ...
    @fail_fast_on_errors.setter
    def fail_fast_on_errors(self, value: bool) -> None: ...
    @_property
    def enable_frame_rate_counter(self) -> bool: ...
    @enable_frame_rate_counter.setter
    def enable_frame_rate_counter(self, value: bool) -> None: ...
    @_property
    def is_xaml_resource_reference_tracing_enabled(self) -> bool: ...
    @is_xaml_resource_reference_tracing_enabled.setter
    def is_xaml_resource_reference_tracing_enabled(self, value: bool) -> None: ...

@typing.final
class DependencyObject(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> DependencyObject: ...
    def clear_value(self, dp: typing.Optional[DependencyProperty], /) -> None: ...
    def get_animation_base_value(self, dp: typing.Optional[DependencyProperty], /) -> typing.Optional[winrt.system.Object]: ...
    def get_value(self, dp: typing.Optional[DependencyProperty], /) -> typing.Optional[winrt.system.Object]: ...
    def read_local_value(self, dp: typing.Optional[DependencyProperty], /) -> typing.Optional[winrt.system.Object]: ...
    def register_property_changed_callback(self, dp: typing.Optional[DependencyProperty], callback: typing.Optional[DependencyPropertyChangedCallback], /) -> winrt.system.Int64: ...
    def set_value(self, dp: typing.Optional[DependencyProperty], value: typing.Optional[winrt.system.Object], /) -> None: ...
    def unregister_property_changed_callback(self, dp: typing.Optional[DependencyProperty], token: winrt.system.Int64, /) -> None: ...
    @_property
    def dispatcher(self) -> typing.Optional[winrt.windows.ui.core.CoreDispatcher]: ...
    @_property
    def dispatcher_queue(self) -> typing.Optional[winrt.microsoft.ui.dispatching.DispatcherQueue]: ...

@typing.final
class DependencyObjectCollection(winrt.system.Object, winrt._winrt.MutableSequence[DependencyObject]):
    def __len__(self) -> int: ...
    def __iter__(self) -> winrt.windows.foundation.collections.IIterator[DependencyObject]: ...
    @typing.overload
    def __getitem__(self, index: typing.SupportsIndex) -> DependencyObject: ...
    @typing.overload
    def __getitem__(self, index: slice) -> winrt.system.Array[DependencyObject]: ...
    @typing.overload
    def __delitem__(self, index: typing.SupportsIndex) -> None: ...
    @typing.overload
    def __delitem__(self, index: slice) -> None: ...
    @typing.overload
    def __setitem__(self, index: typing.SupportsIndex, value: DependencyObject) -> None: ...
    @typing.overload
    def __setitem__(self, index: slice, value: typing.Iterable[DependencyObject]) -> None: ...
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> DependencyObjectCollection: ...
    def __new__(cls: typing.Type[DependencyObjectCollection]) -> DependencyObjectCollection:...
    def append(self, value: typing.Optional[DependencyObject], /) -> None: ...
    def clear(self) -> None: ...
    def first(self) -> typing.Optional[winrt.windows.foundation.collections.IIterator[DependencyObject]]: ...
    def get_at(self, index: winrt.system.UInt32, /) -> typing.Optional[DependencyObject]: ...
    def get_many(self, start_index: winrt.system.UInt32, items: winrt.system.Array[DependencyObject], /) -> winrt.system.UInt32: ...
    def get_view(self) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[DependencyObject]]: ...
    def index_of(self, value: typing.Optional[DependencyObject], /) -> typing.Tuple[bool, winrt.system.UInt32]: ...
    def insert_at(self, index: winrt.system.UInt32, value: typing.Optional[DependencyObject], /) -> None: ...
    def remove_at(self, index: winrt.system.UInt32, /) -> None: ...
    def remove_at_end(self) -> None: ...
    def replace_all(self, items: winrt.system.Array[DependencyObject], /) -> None: ...
    def set_at(self, index: winrt.system.UInt32, value: typing.Optional[DependencyObject], /) -> None: ...
    def add_vector_changed(self, vhnd: winrt.windows.foundation.collections.VectorChangedEventHandler[DependencyObject], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_vector_changed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    @_property
    def size(self) -> winrt.system.UInt32: ...

@typing.final
class DependencyProperty_Static(type):
    def register(cls, name: str, property_type: winrt.windows.ui.xaml.interop.TypeName, owner_type: winrt.windows.ui.xaml.interop.TypeName, type_metadata: typing.Optional[PropertyMetadata], /) -> typing.Optional[DependencyProperty]: ...
    def register_attached(cls, name: str, property_type: winrt.windows.ui.xaml.interop.TypeName, owner_type: winrt.windows.ui.xaml.interop.TypeName, default_metadata: typing.Optional[PropertyMetadata], /) -> typing.Optional[DependencyProperty]: ...
    @_property
    def unset_value(cls) -> typing.Optional[winrt.system.Object]: ...

@typing.final
class DependencyProperty(winrt.system.Object, metaclass=DependencyProperty_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> DependencyProperty: ...
    def get_metadata(self, for_type: winrt.windows.ui.xaml.interop.TypeName, /) -> typing.Optional[PropertyMetadata]: ...

@typing.final
class DependencyPropertyChangedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> DependencyPropertyChangedEventArgs: ...
    @_property
    def new_value(self) -> typing.Optional[winrt.system.Object]: ...
    @_property
    def old_value(self) -> typing.Optional[winrt.system.Object]: ...
    @_property
    def property(self) -> typing.Optional[DependencyProperty]: ...

@typing.final
class DispatcherTimer(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> DispatcherTimer: ...
    def __new__(cls: typing.Type[DispatcherTimer]) -> DispatcherTimer:...
    def start(self) -> None: ...
    def stop(self) -> None: ...
    def add_tick(self, handler: winrt.windows.foundation.EventHandler[winrt.system.Object], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_tick(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    @_property
    def interval(self) -> datetime.timedelta: ...
    @interval.setter
    def interval(self, value: datetime.timedelta) -> None: ...
    @_property
    def is_enabled(self) -> bool: ...

@typing.final
class DragEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> DragEventArgs: ...
    def get_deferral(self) -> typing.Optional[DragOperationDeferral]: ...
    def get_position(self, relative_to: typing.Optional[UIElement], /) -> winrt.windows.foundation.Point: ...
    @_property
    def handled(self) -> bool: ...
    @handled.setter
    def handled(self, value: bool) -> None: ...
    @_property
    def data(self) -> typing.Optional[winrt.windows.applicationmodel.datatransfer.DataPackage]: ...
    @data.setter
    def data(self, value: typing.Optional[winrt.windows.applicationmodel.datatransfer.DataPackage]) -> None: ...
    @_property
    def accepted_operation(self) -> winrt.windows.applicationmodel.datatransfer.DataPackageOperation: ...
    @accepted_operation.setter
    def accepted_operation(self, value: winrt.windows.applicationmodel.datatransfer.DataPackageOperation) -> None: ...
    @_property
    def allowed_operations(self) -> winrt.windows.applicationmodel.datatransfer.DataPackageOperation: ...
    @_property
    def data_view(self) -> typing.Optional[winrt.windows.applicationmodel.datatransfer.DataPackageView]: ...
    @_property
    def drag_u_i_override(self) -> typing.Optional[DragUIOverride]: ...
    @_property
    def modifiers(self) -> winrt.windows.applicationmodel.datatransfer.dragdrop.DragDropModifiers: ...

@typing.final
class DragOperationDeferral(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> DragOperationDeferral: ...
    def complete(self) -> None: ...

@typing.final
class DragStartingEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> DragStartingEventArgs: ...
    def get_deferral(self) -> typing.Optional[DragOperationDeferral]: ...
    def get_position(self, relative_to: typing.Optional[UIElement], /) -> winrt.windows.foundation.Point: ...
    @_property
    def cancel(self) -> bool: ...
    @cancel.setter
    def cancel(self, value: bool) -> None: ...
    @_property
    def allowed_operations(self) -> winrt.windows.applicationmodel.datatransfer.DataPackageOperation: ...
    @allowed_operations.setter
    def allowed_operations(self, value: winrt.windows.applicationmodel.datatransfer.DataPackageOperation) -> None: ...
    @_property
    def data(self) -> typing.Optional[winrt.windows.applicationmodel.datatransfer.DataPackage]: ...
    @_property
    def drag_u_i(self) -> typing.Optional[DragUI]: ...

@typing.final
class DragUI(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> DragUI: ...
    @typing.overload
    def set_content_from_bitmap_image(self, bitmap_image: typing.Optional[winrt.microsoft.ui.xaml.media.imaging.BitmapImage], /) -> None: ...
    @typing.overload
    def set_content_from_bitmap_image(self, bitmap_image: typing.Optional[winrt.microsoft.ui.xaml.media.imaging.BitmapImage], anchor_point: winrt.windows.foundation.Point, /) -> None: ...
    def set_content_from_data_package(self) -> None: ...
    @typing.overload
    def set_content_from_software_bitmap(self, software_bitmap: typing.Optional[winrt.windows.graphics.imaging.SoftwareBitmap], /) -> None: ...
    @typing.overload
    def set_content_from_software_bitmap(self, software_bitmap: typing.Optional[winrt.windows.graphics.imaging.SoftwareBitmap], anchor_point: winrt.windows.foundation.Point, /) -> None: ...

@typing.final
class DragUIOverride(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> DragUIOverride: ...
    def clear(self) -> None: ...
    @typing.overload
    def set_content_from_bitmap_image(self, bitmap_image: typing.Optional[winrt.microsoft.ui.xaml.media.imaging.BitmapImage], /) -> None: ...
    @typing.overload
    def set_content_from_bitmap_image(self, bitmap_image: typing.Optional[winrt.microsoft.ui.xaml.media.imaging.BitmapImage], anchor_point: winrt.windows.foundation.Point, /) -> None: ...
    @typing.overload
    def set_content_from_software_bitmap(self, software_bitmap: typing.Optional[winrt.windows.graphics.imaging.SoftwareBitmap], /) -> None: ...
    @typing.overload
    def set_content_from_software_bitmap(self, software_bitmap: typing.Optional[winrt.windows.graphics.imaging.SoftwareBitmap], anchor_point: winrt.windows.foundation.Point, /) -> None: ...
    @_property
    def is_glyph_visible(self) -> bool: ...
    @is_glyph_visible.setter
    def is_glyph_visible(self, value: bool) -> None: ...
    @_property
    def is_content_visible(self) -> bool: ...
    @is_content_visible.setter
    def is_content_visible(self, value: bool) -> None: ...
    @_property
    def is_caption_visible(self) -> bool: ...
    @is_caption_visible.setter
    def is_caption_visible(self, value: bool) -> None: ...
    @_property
    def caption(self) -> str: ...
    @caption.setter
    def caption(self, value: str) -> None: ...

@typing.final
class DropCompletedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> DropCompletedEventArgs: ...
    @_property
    def drop_result(self) -> winrt.windows.applicationmodel.datatransfer.DataPackageOperation: ...

@typing.final
class DurationHelper_Static(type):
    def add(cls, target: Duration, duration: Duration, /) -> Duration: ...
    def compare(cls, duration1: Duration, duration2: Duration, /) -> winrt.system.Int32: ...
    def equals(cls, target: Duration, value: Duration, /) -> bool: ...
    def from_time_span(cls, time_span: datetime.timedelta, /) -> Duration: ...
    def get_has_time_span(cls, target: Duration, /) -> bool: ...
    def subtract(cls, target: Duration, duration: Duration, /) -> Duration: ...
    @_property
    def automatic(cls) -> Duration: ...
    @_property
    def forever(cls) -> Duration: ...

@typing.final
class DurationHelper(winrt.system.Object, metaclass=DurationHelper_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> DurationHelper: ...

@typing.final
class EffectiveViewportChangedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> EffectiveViewportChangedEventArgs: ...
    @_property
    def bring_into_view_distance_x(self) -> winrt.system.Double: ...
    @_property
    def bring_into_view_distance_y(self) -> winrt.system.Double: ...
    @_property
    def effective_viewport(self) -> winrt.windows.foundation.Rect: ...
    @_property
    def max_viewport(self) -> winrt.windows.foundation.Rect: ...

@typing.final
class ElementFactoryGetArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ElementFactoryGetArgs: ...
    def __new__(cls: typing.Type[ElementFactoryGetArgs]) -> ElementFactoryGetArgs:...
    @_property
    def parent(self) -> typing.Optional[UIElement]: ...
    @parent.setter
    def parent(self, value: typing.Optional[UIElement]) -> None: ...
    @_property
    def data(self) -> typing.Optional[winrt.system.Object]: ...
    @data.setter
    def data(self, value: typing.Optional[winrt.system.Object]) -> None: ...

@typing.final
class ElementFactoryRecycleArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ElementFactoryRecycleArgs: ...
    def __new__(cls: typing.Type[ElementFactoryRecycleArgs]) -> ElementFactoryRecycleArgs:...
    @_property
    def parent(self) -> typing.Optional[UIElement]: ...
    @parent.setter
    def parent(self, value: typing.Optional[UIElement]) -> None: ...
    @_property
    def element(self) -> typing.Optional[UIElement]: ...
    @element.setter
    def element(self, value: typing.Optional[UIElement]) -> None: ...

@typing.final
class ElementSoundPlayer_Static(type):
    def play(cls, sound: ElementSoundKind, /) -> None: ...
    @_property
    def volume(cls) -> winrt.system.Double: ...
    @volume.setter
    def volume(cls, value: winrt.system.Double) -> None: ...
    @_property
    def state(cls) -> ElementSoundPlayerState: ...
    @state.setter
    def state(cls, value: ElementSoundPlayerState) -> None: ...
    @_property
    def spatial_audio_mode(cls) -> ElementSpatialAudioMode: ...
    @spatial_audio_mode.setter
    def spatial_audio_mode(cls, value: ElementSpatialAudioMode) -> None: ...

@typing.final
class ElementSoundPlayer(winrt.system.Object, metaclass=ElementSoundPlayer_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ElementSoundPlayer: ...

@typing.final
class EventTrigger(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> EventTrigger: ...
    def __new__(cls: typing.Type[EventTrigger]) -> EventTrigger:...
    @_property
    def routed_event(self) -> typing.Optional[RoutedEvent]: ...
    @routed_event.setter
    def routed_event(self, value: typing.Optional[RoutedEvent]) -> None: ...
    @_property
    def actions(self) -> typing.Optional[TriggerActionCollection]: ...

@typing.final
class ExceptionRoutedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ExceptionRoutedEventArgs: ...
    @_property
    def error_message(self) -> str: ...

@typing.final
class FrameworkElement_Static(type):
    def defer_tree(cls, element: typing.Optional[DependencyObject], /) -> None: ...
    @_property
    def actual_height_property(cls) -> typing.Optional[DependencyProperty]: ...
    @_property
    def actual_theme_property(cls) -> typing.Optional[DependencyProperty]: ...
    @_property
    def actual_width_property(cls) -> typing.Optional[DependencyProperty]: ...
    @_property
    def allow_focus_on_interaction_property(cls) -> typing.Optional[DependencyProperty]: ...
    @_property
    def allow_focus_when_disabled_property(cls) -> typing.Optional[DependencyProperty]: ...
    @_property
    def data_context_property(cls) -> typing.Optional[DependencyProperty]: ...
    @_property
    def flow_direction_property(cls) -> typing.Optional[DependencyProperty]: ...
    @_property
    def focus_visual_margin_property(cls) -> typing.Optional[DependencyProperty]: ...
    @_property
    def focus_visual_primary_brush_property(cls) -> typing.Optional[DependencyProperty]: ...
    @_property
    def focus_visual_primary_thickness_property(cls) -> typing.Optional[DependencyProperty]: ...
    @_property
    def focus_visual_secondary_brush_property(cls) -> typing.Optional[DependencyProperty]: ...
    @_property
    def focus_visual_secondary_thickness_property(cls) -> typing.Optional[DependencyProperty]: ...
    @_property
    def height_property(cls) -> typing.Optional[DependencyProperty]: ...
    @_property
    def horizontal_alignment_property(cls) -> typing.Optional[DependencyProperty]: ...
    @_property
    def language_property(cls) -> typing.Optional[DependencyProperty]: ...
    @_property
    def margin_property(cls) -> typing.Optional[DependencyProperty]: ...
    @_property
    def max_height_property(cls) -> typing.Optional[DependencyProperty]: ...
    @_property
    def max_width_property(cls) -> typing.Optional[DependencyProperty]: ...
    @_property
    def min_height_property(cls) -> typing.Optional[DependencyProperty]: ...
    @_property
    def min_width_property(cls) -> typing.Optional[DependencyProperty]: ...
    @_property
    def name_property(cls) -> typing.Optional[DependencyProperty]: ...
    @_property
    def requested_theme_property(cls) -> typing.Optional[DependencyProperty]: ...
    @_property
    def style_property(cls) -> typing.Optional[DependencyProperty]: ...
    @_property
    def tag_property(cls) -> typing.Optional[DependencyProperty]: ...
    @_property
    def vertical_alignment_property(cls) -> typing.Optional[DependencyProperty]: ...
    @_property
    def width_property(cls) -> typing.Optional[DependencyProperty]: ...

@typing.final
class FrameworkElement(winrt.system.Object, metaclass=FrameworkElement_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> FrameworkElement: ...
    def arrange_override(self, final_size: winrt.windows.foundation.Size, /) -> winrt.windows.foundation.Size: ...
    def find_name(self, name: str, /) -> typing.Optional[winrt.system.Object]: ...
    def get_binding_expression(self, dp: typing.Optional[DependencyProperty], /) -> typing.Optional[winrt.microsoft.ui.xaml.data.BindingExpression]: ...
    def go_to_element_state_core(self, state_name: str, use_transitions: bool, /) -> bool: ...
    def invalidate_viewport(self) -> None: ...
    def measure_override(self, available_size: winrt.windows.foundation.Size, /) -> winrt.windows.foundation.Size: ...
    def on_apply_template(self) -> None: ...
    def set_binding(self, dp: typing.Optional[DependencyProperty], binding: typing.Optional[winrt.microsoft.ui.xaml.data.BindingBase], /) -> None: ...
    def add_actual_theme_changed(self, handler: winrt.windows.foundation.TypedEventHandler[FrameworkElement, winrt.system.Object], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_actual_theme_changed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_data_context_changed(self, handler: winrt.windows.foundation.TypedEventHandler[FrameworkElement, DataContextChangedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_data_context_changed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_effective_viewport_changed(self, handler: winrt.windows.foundation.TypedEventHandler[FrameworkElement, EffectiveViewportChangedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_effective_viewport_changed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_layout_updated(self, handler: winrt.windows.foundation.EventHandler[winrt.system.Object], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_layout_updated(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_loaded(self, handler: typing.Optional[RoutedEventHandler], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_loaded(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_loading(self, handler: winrt.windows.foundation.TypedEventHandler[FrameworkElement, winrt.system.Object], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_loading(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_size_changed(self, handler: typing.Optional[SizeChangedEventHandler], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_size_changed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_unloaded(self, handler: typing.Optional[RoutedEventHandler], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_unloaded(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    @_property
    def width(self) -> winrt.system.Double: ...
    @width.setter
    def width(self, value: winrt.system.Double) -> None: ...
    @_property
    def vertical_alignment(self) -> VerticalAlignment: ...
    @vertical_alignment.setter
    def vertical_alignment(self, value: VerticalAlignment) -> None: ...
    @_property
    def tag(self) -> typing.Optional[winrt.system.Object]: ...
    @tag.setter
    def tag(self, value: typing.Optional[winrt.system.Object]) -> None: ...
    @_property
    def style(self) -> typing.Optional[Style]: ...
    @style.setter
    def style(self, value: typing.Optional[Style]) -> None: ...
    @_property
    def resources(self) -> typing.Optional[ResourceDictionary]: ...
    @resources.setter
    def resources(self, value: typing.Optional[ResourceDictionary]) -> None: ...
    @_property
    def requested_theme(self) -> ElementTheme: ...
    @requested_theme.setter
    def requested_theme(self, value: ElementTheme) -> None: ...
    @_property
    def name(self) -> str: ...
    @name.setter
    def name(self, value: str) -> None: ...
    @_property
    def min_width(self) -> winrt.system.Double: ...
    @min_width.setter
    def min_width(self, value: winrt.system.Double) -> None: ...
    @_property
    def min_height(self) -> winrt.system.Double: ...
    @min_height.setter
    def min_height(self, value: winrt.system.Double) -> None: ...
    @_property
    def max_width(self) -> winrt.system.Double: ...
    @max_width.setter
    def max_width(self, value: winrt.system.Double) -> None: ...
    @_property
    def max_height(self) -> winrt.system.Double: ...
    @max_height.setter
    def max_height(self, value: winrt.system.Double) -> None: ...
    @_property
    def margin(self) -> Thickness: ...
    @margin.setter
    def margin(self, value: Thickness) -> None: ...
    @_property
    def language(self) -> str: ...
    @language.setter
    def language(self, value: str) -> None: ...
    @_property
    def horizontal_alignment(self) -> HorizontalAlignment: ...
    @horizontal_alignment.setter
    def horizontal_alignment(self, value: HorizontalAlignment) -> None: ...
    @_property
    def height(self) -> winrt.system.Double: ...
    @height.setter
    def height(self, value: winrt.system.Double) -> None: ...
    @_property
    def focus_visual_secondary_thickness(self) -> Thickness: ...
    @focus_visual_secondary_thickness.setter
    def focus_visual_secondary_thickness(self, value: Thickness) -> None: ...
    @_property
    def focus_visual_secondary_brush(self) -> typing.Optional[winrt.microsoft.ui.xaml.media.Brush]: ...
    @focus_visual_secondary_brush.setter
    def focus_visual_secondary_brush(self, value: typing.Optional[winrt.microsoft.ui.xaml.media.Brush]) -> None: ...
    @_property
    def focus_visual_primary_thickness(self) -> Thickness: ...
    @focus_visual_primary_thickness.setter
    def focus_visual_primary_thickness(self, value: Thickness) -> None: ...
    @_property
    def focus_visual_primary_brush(self) -> typing.Optional[winrt.microsoft.ui.xaml.media.Brush]: ...
    @focus_visual_primary_brush.setter
    def focus_visual_primary_brush(self, value: typing.Optional[winrt.microsoft.ui.xaml.media.Brush]) -> None: ...
    @_property
    def focus_visual_margin(self) -> Thickness: ...
    @focus_visual_margin.setter
    def focus_visual_margin(self, value: Thickness) -> None: ...
    @_property
    def flow_direction(self) -> FlowDirection: ...
    @flow_direction.setter
    def flow_direction(self, value: FlowDirection) -> None: ...
    @_property
    def data_context(self) -> typing.Optional[winrt.system.Object]: ...
    @data_context.setter
    def data_context(self, value: typing.Optional[winrt.system.Object]) -> None: ...
    @_property
    def allow_focus_when_disabled(self) -> bool: ...
    @allow_focus_when_disabled.setter
    def allow_focus_when_disabled(self, value: bool) -> None: ...
    @_property
    def allow_focus_on_interaction(self) -> bool: ...
    @allow_focus_on_interaction.setter
    def allow_focus_on_interaction(self, value: bool) -> None: ...
    @_property
    def actual_height(self) -> winrt.system.Double: ...
    @_property
    def actual_theme(self) -> ElementTheme: ...
    @_property
    def actual_width(self) -> winrt.system.Double: ...
    @_property
    def base_uri(self) -> typing.Optional[winrt.windows.foundation.Uri]: ...
    @_property
    def is_loaded(self) -> bool: ...
    @_property
    def parent(self) -> typing.Optional[DependencyObject]: ...
    @_property
    def triggers(self) -> typing.Optional[TriggerCollection]: ...

@typing.final
class FrameworkTemplate(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> FrameworkTemplate: ...

@typing.final
class FrameworkView(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> FrameworkView: ...
    def __new__(cls: typing.Type[FrameworkView]) -> FrameworkView:...
    def initialize(self, application_view: typing.Optional[winrt.windows.applicationmodel.core.CoreApplicationView], /) -> None: ...
    def load(self, entry_point: str, /) -> None: ...
    def run(self) -> None: ...
    def set_window(self, window: typing.Optional[winrt.windows.ui.core.CoreWindow], /) -> None: ...
    def uninitialize(self) -> None: ...

@typing.final
class FrameworkViewSource(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> FrameworkViewSource: ...
    def __new__(cls: typing.Type[FrameworkViewSource]) -> FrameworkViewSource:...
    def create_view(self) -> typing.Optional[winrt.windows.applicationmodel.core.IFrameworkView]: ...

@typing.final
class GridLengthHelper_Static(type):
    def equals(cls, target: GridLength, value: GridLength, /) -> bool: ...
    def from_pixels(cls, pixels: winrt.system.Double, /) -> GridLength: ...
    def from_value_and_type(cls, value: winrt.system.Double, type: GridUnitType, /) -> GridLength: ...
    def get_is_absolute(cls, target: GridLength, /) -> bool: ...
    def get_is_auto(cls, target: GridLength, /) -> bool: ...
    def get_is_star(cls, target: GridLength, /) -> bool: ...
    @_property
    def auto(cls) -> GridLength: ...

@typing.final
class GridLengthHelper(winrt.system.Object, metaclass=GridLengthHelper_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> GridLengthHelper: ...

@typing.final
class LaunchActivatedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> LaunchActivatedEventArgs: ...
    @_property
    def arguments(self) -> str: ...
    @_property
    def u_w_p_launch_activated_event_args(self) -> typing.Optional[winrt.windows.applicationmodel.activation.LaunchActivatedEventArgs]: ...

@typing.final
class MediaFailedRoutedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MediaFailedRoutedEventArgs: ...
    @_property
    def error_trace(self) -> str: ...

@typing.final
class PointHelper_Static(type):
    def from_coordinates(cls, x: winrt.system.Single, y: winrt.system.Single, /) -> winrt.windows.foundation.Point: ...

@typing.final
class PointHelper(winrt.system.Object, metaclass=PointHelper_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> PointHelper: ...

@typing.final
class PropertyMetadata_Static(type):
    @typing.overload
    def create(cls, default_value: typing.Optional[winrt.system.Object], /) -> typing.Optional[PropertyMetadata]: ...
    @typing.overload
    def create(cls, default_value: typing.Optional[winrt.system.Object], property_changed_callback: typing.Optional[PropertyChangedCallback], /) -> typing.Optional[PropertyMetadata]: ...

@typing.final
class PropertyMetadata(winrt.system.Object, metaclass=PropertyMetadata_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> PropertyMetadata: ...
    @typing.overload
    def __new__(cls: typing.Type[PropertyMetadata], default_value: typing.Optional[winrt.system.Object]) -> PropertyMetadata:...
    @typing.overload
    def __new__(cls: typing.Type[PropertyMetadata], default_value: typing.Optional[winrt.system.Object], property_changed_callback: typing.Optional[PropertyChangedCallback]) -> PropertyMetadata:...
    @_property
    def create_default_value_callback(self) -> typing.Optional[CreateDefaultValueCallback]: ...
    @_property
    def default_value(self) -> typing.Optional[winrt.system.Object]: ...

@typing.final
class PropertyPath(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> PropertyPath: ...
    def __new__(cls: typing.Type[PropertyPath], path: str) -> PropertyPath:...
    @_property
    def path(self) -> str: ...

@typing.final
class RectHelper_Static(type):
    def contains(cls, target: winrt.windows.foundation.Rect, point: winrt.windows.foundation.Point, /) -> bool: ...
    def equals(cls, target: winrt.windows.foundation.Rect, value: winrt.windows.foundation.Rect, /) -> bool: ...
    def from_coordinates_and_dimensions(cls, x: winrt.system.Single, y: winrt.system.Single, width: winrt.system.Single, height: winrt.system.Single, /) -> winrt.windows.foundation.Rect: ...
    def from_location_and_size(cls, location: winrt.windows.foundation.Point, size: winrt.windows.foundation.Size, /) -> winrt.windows.foundation.Rect: ...
    def from_points(cls, point1: winrt.windows.foundation.Point, point2: winrt.windows.foundation.Point, /) -> winrt.windows.foundation.Rect: ...
    def get_bottom(cls, target: winrt.windows.foundation.Rect, /) -> winrt.system.Single: ...
    def get_is_empty(cls, target: winrt.windows.foundation.Rect, /) -> bool: ...
    def get_left(cls, target: winrt.windows.foundation.Rect, /) -> winrt.system.Single: ...
    def get_right(cls, target: winrt.windows.foundation.Rect, /) -> winrt.system.Single: ...
    def get_top(cls, target: winrt.windows.foundation.Rect, /) -> winrt.system.Single: ...
    def intersect(cls, target: winrt.windows.foundation.Rect, rect: winrt.windows.foundation.Rect, /) -> winrt.windows.foundation.Rect: ...
    def union(cls, target: winrt.windows.foundation.Rect, point: winrt.windows.foundation.Point, /) -> winrt.windows.foundation.Rect: ...
    @_property
    def empty(cls) -> winrt.windows.foundation.Rect: ...

@typing.final
class RectHelper(winrt.system.Object, metaclass=RectHelper_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> RectHelper: ...

@typing.final
class ResourceDictionary(winrt.system.Object, winrt._winrt.MutableMapping[winrt.system.Object, winrt.system.Object]):
    def __len__(self) -> int: ...
    def __iter__(self) -> typing.Iterator[winrt.system.Object]: ...
    def __contains__(self, key: object) -> bool:...
    def __setitem__(self, key: winrt.system.Object, value: winrt.system.Object) -> None: ...
    def __getitem__(self, key: winrt.system.Object) -> winrt.system.Object: ...
    def __delitem__(self, key: winrt.system.Object) -> None: ...
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ResourceDictionary: ...
    def __new__(cls: typing.Type[ResourceDictionary]) -> ResourceDictionary:...
    def clear(self) -> None: ...
    def first(self) -> typing.Optional[winrt.windows.foundation.collections.IIterator[winrt.windows.foundation.collections.IKeyValuePair[winrt.system.Object, winrt.system.Object]]]: ...
    def get_view(self) -> typing.Optional[winrt.windows.foundation.collections.IMapView[winrt.system.Object, winrt.system.Object]]: ...
    def has_key(self, key: typing.Optional[winrt.system.Object], /) -> bool: ...
    def insert(self, key: typing.Optional[winrt.system.Object], value: typing.Optional[winrt.system.Object], /) -> bool: ...
    def lookup(self, key: typing.Optional[winrt.system.Object], /) -> typing.Optional[winrt.system.Object]: ...
    def remove(self, key: typing.Optional[winrt.system.Object], /) -> None: ...
    @_property
    def source(self) -> typing.Optional[winrt.windows.foundation.Uri]: ...
    @source.setter
    def source(self, value: typing.Optional[winrt.windows.foundation.Uri]) -> None: ...
    @_property
    def merged_dictionaries(self) -> typing.Optional[winrt.windows.foundation.collections.IVector[ResourceDictionary]]: ...
    @_property
    def theme_dictionaries(self) -> typing.Optional[winrt.windows.foundation.collections.IMap[winrt.system.Object, winrt.system.Object]]: ...
    @_property
    def size(self) -> winrt.system.UInt32: ...

@typing.final
class ResourceManagerRequestedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ResourceManagerRequestedEventArgs: ...
    @_property
    def custom_resource_manager(self) -> typing.Optional[winrt.microsoft.windows.applicationmodel.resources.IResourceManager]: ...
    @custom_resource_manager.setter
    def custom_resource_manager(self, value: typing.Optional[winrt.microsoft.windows.applicationmodel.resources.IResourceManager]) -> None: ...

@typing.final
class RoutedEvent(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> RoutedEvent: ...

@typing.final
class RoutedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> RoutedEventArgs: ...
    def __new__(cls: typing.Type[RoutedEventArgs]) -> RoutedEventArgs:...
    @_property
    def original_source(self) -> typing.Optional[winrt.system.Object]: ...

@typing.final
class ScalarTransition(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ScalarTransition: ...
    def __new__(cls: typing.Type[ScalarTransition]) -> ScalarTransition:...
    @_property
    def duration(self) -> datetime.timedelta: ...
    @duration.setter
    def duration(self, value: datetime.timedelta) -> None: ...

@typing.final
class Setter(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> Setter: ...
    @typing.overload
    def __new__(cls: typing.Type[Setter], target_property: typing.Optional[DependencyProperty], value: typing.Optional[winrt.system.Object]) -> Setter:...
    @typing.overload
    def __new__(cls: typing.Type[Setter]) -> Setter:...
    @_property
    def value(self) -> typing.Optional[winrt.system.Object]: ...
    @value.setter
    def value(self, value: typing.Optional[winrt.system.Object]) -> None: ...
    @_property
    def target(self) -> typing.Optional[TargetPropertyPath]: ...
    @target.setter
    def target(self, value: typing.Optional[TargetPropertyPath]) -> None: ...
    @_property
    def property(self) -> typing.Optional[DependencyProperty]: ...
    @property.setter
    def property(self, value: typing.Optional[DependencyProperty]) -> None: ...

@typing.final
class SetterBase(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> SetterBase: ...
    @_property
    def is_sealed(self) -> bool: ...

@typing.final
class SetterBaseCollection(winrt.system.Object, winrt._winrt.MutableSequence[SetterBase]):
    def __len__(self) -> int: ...
    def __iter__(self) -> winrt.windows.foundation.collections.IIterator[SetterBase]: ...
    @typing.overload
    def __getitem__(self, index: typing.SupportsIndex) -> SetterBase: ...
    @typing.overload
    def __getitem__(self, index: slice) -> winrt.system.Array[SetterBase]: ...
    @typing.overload
    def __delitem__(self, index: typing.SupportsIndex) -> None: ...
    @typing.overload
    def __delitem__(self, index: slice) -> None: ...
    @typing.overload
    def __setitem__(self, index: typing.SupportsIndex, value: SetterBase) -> None: ...
    @typing.overload
    def __setitem__(self, index: slice, value: typing.Iterable[SetterBase]) -> None: ...
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> SetterBaseCollection: ...
    def __new__(cls: typing.Type[SetterBaseCollection]) -> SetterBaseCollection:...
    def append(self, value: typing.Optional[SetterBase], /) -> None: ...
    def clear(self) -> None: ...
    def first(self) -> typing.Optional[winrt.windows.foundation.collections.IIterator[SetterBase]]: ...
    def get_at(self, index: winrt.system.UInt32, /) -> typing.Optional[SetterBase]: ...
    def get_many(self, start_index: winrt.system.UInt32, items: winrt.system.Array[SetterBase], /) -> winrt.system.UInt32: ...
    def get_view(self) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[SetterBase]]: ...
    def index_of(self, value: typing.Optional[SetterBase], /) -> typing.Tuple[bool, winrt.system.UInt32]: ...
    def insert_at(self, index: winrt.system.UInt32, value: typing.Optional[SetterBase], /) -> None: ...
    def remove_at(self, index: winrt.system.UInt32, /) -> None: ...
    def remove_at_end(self) -> None: ...
    def replace_all(self, items: winrt.system.Array[SetterBase], /) -> None: ...
    def set_at(self, index: winrt.system.UInt32, value: typing.Optional[SetterBase], /) -> None: ...
    @_property
    def is_sealed(self) -> bool: ...
    @_property
    def size(self) -> winrt.system.UInt32: ...

@typing.final
class SizeChangedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> SizeChangedEventArgs: ...
    @_property
    def new_size(self) -> winrt.windows.foundation.Size: ...
    @_property
    def previous_size(self) -> winrt.windows.foundation.Size: ...

@typing.final
class SizeHelper_Static(type):
    def equals(cls, target: winrt.windows.foundation.Size, value: winrt.windows.foundation.Size, /) -> bool: ...
    def from_dimensions(cls, width: winrt.system.Single, height: winrt.system.Single, /) -> winrt.windows.foundation.Size: ...
    def get_is_empty(cls, target: winrt.windows.foundation.Size, /) -> bool: ...
    @_property
    def empty(cls) -> winrt.windows.foundation.Size: ...

@typing.final
class SizeHelper(winrt.system.Object, metaclass=SizeHelper_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> SizeHelper: ...

@typing.final
class StateTrigger_Static(type):
    @_property
    def is_active_property(cls) -> typing.Optional[DependencyProperty]: ...

@typing.final
class StateTrigger(winrt.system.Object, metaclass=StateTrigger_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> StateTrigger: ...
    def __new__(cls: typing.Type[StateTrigger]) -> StateTrigger:...
    @_property
    def is_active(self) -> bool: ...
    @is_active.setter
    def is_active(self, value: bool) -> None: ...

@typing.final
class StateTriggerBase(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> StateTriggerBase: ...
    def set_active(self, is_active: bool, /) -> None: ...

@typing.final
class Style(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> Style: ...
    @typing.overload
    def __new__(cls: typing.Type[Style], target_type: winrt.windows.ui.xaml.interop.TypeName) -> Style:...
    @typing.overload
    def __new__(cls: typing.Type[Style]) -> Style:...
    def seal(self) -> None: ...
    @_property
    def target_type(self) -> winrt.windows.ui.xaml.interop.TypeName: ...
    @target_type.setter
    def target_type(self, value: winrt.windows.ui.xaml.interop.TypeName) -> None: ...
    @_property
    def based_on(self) -> typing.Optional[Style]: ...
    @based_on.setter
    def based_on(self, value: typing.Optional[Style]) -> None: ...
    @_property
    def is_sealed(self) -> bool: ...
    @_property
    def setters(self) -> typing.Optional[SetterBaseCollection]: ...

@typing.final
class TargetPropertyPath(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> TargetPropertyPath: ...
    @typing.overload
    def __new__(cls: typing.Type[TargetPropertyPath], target_property: typing.Optional[DependencyProperty]) -> TargetPropertyPath:...
    @typing.overload
    def __new__(cls: typing.Type[TargetPropertyPath]) -> TargetPropertyPath:...
    @_property
    def target(self) -> typing.Optional[winrt.system.Object]: ...
    @target.setter
    def target(self, value: typing.Optional[winrt.system.Object]) -> None: ...
    @_property
    def path(self) -> typing.Optional[PropertyPath]: ...
    @path.setter
    def path(self, value: typing.Optional[PropertyPath]) -> None: ...

@typing.final
class ThicknessHelper_Static(type):
    def from_lengths(cls, left: winrt.system.Double, top: winrt.system.Double, right: winrt.system.Double, bottom: winrt.system.Double, /) -> Thickness: ...
    def from_uniform_length(cls, uniform_length: winrt.system.Double, /) -> Thickness: ...

@typing.final
class ThicknessHelper(winrt.system.Object, metaclass=ThicknessHelper_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ThicknessHelper: ...

@typing.final
class TriggerAction(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> TriggerAction: ...

@typing.final
class TriggerActionCollection(winrt.system.Object, winrt._winrt.MutableSequence[TriggerAction]):
    def __len__(self) -> int: ...
    def __iter__(self) -> winrt.windows.foundation.collections.IIterator[TriggerAction]: ...
    @typing.overload
    def __getitem__(self, index: typing.SupportsIndex) -> TriggerAction: ...
    @typing.overload
    def __getitem__(self, index: slice) -> winrt.system.Array[TriggerAction]: ...
    @typing.overload
    def __delitem__(self, index: typing.SupportsIndex) -> None: ...
    @typing.overload
    def __delitem__(self, index: slice) -> None: ...
    @typing.overload
    def __setitem__(self, index: typing.SupportsIndex, value: TriggerAction) -> None: ...
    @typing.overload
    def __setitem__(self, index: slice, value: typing.Iterable[TriggerAction]) -> None: ...
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> TriggerActionCollection: ...
    def __new__(cls: typing.Type[TriggerActionCollection]) -> TriggerActionCollection:...
    def append(self, value: typing.Optional[TriggerAction], /) -> None: ...
    def clear(self) -> None: ...
    def first(self) -> typing.Optional[winrt.windows.foundation.collections.IIterator[TriggerAction]]: ...
    def get_at(self, index: winrt.system.UInt32, /) -> typing.Optional[TriggerAction]: ...
    def get_many(self, start_index: winrt.system.UInt32, items: winrt.system.Array[TriggerAction], /) -> winrt.system.UInt32: ...
    def get_view(self) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[TriggerAction]]: ...
    def index_of(self, value: typing.Optional[TriggerAction], /) -> typing.Tuple[bool, winrt.system.UInt32]: ...
    def insert_at(self, index: winrt.system.UInt32, value: typing.Optional[TriggerAction], /) -> None: ...
    def remove_at(self, index: winrt.system.UInt32, /) -> None: ...
    def remove_at_end(self) -> None: ...
    def replace_all(self, items: winrt.system.Array[TriggerAction], /) -> None: ...
    def set_at(self, index: winrt.system.UInt32, value: typing.Optional[TriggerAction], /) -> None: ...
    @_property
    def size(self) -> winrt.system.UInt32: ...

@typing.final
class TriggerBase(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> TriggerBase: ...

@typing.final
class TriggerCollection(winrt.system.Object, winrt._winrt.MutableSequence[TriggerBase]):
    def __len__(self) -> int: ...
    def __iter__(self) -> winrt.windows.foundation.collections.IIterator[TriggerBase]: ...
    @typing.overload
    def __getitem__(self, index: typing.SupportsIndex) -> TriggerBase: ...
    @typing.overload
    def __getitem__(self, index: slice) -> winrt.system.Array[TriggerBase]: ...
    @typing.overload
    def __delitem__(self, index: typing.SupportsIndex) -> None: ...
    @typing.overload
    def __delitem__(self, index: slice) -> None: ...
    @typing.overload
    def __setitem__(self, index: typing.SupportsIndex, value: TriggerBase) -> None: ...
    @typing.overload
    def __setitem__(self, index: slice, value: typing.Iterable[TriggerBase]) -> None: ...
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> TriggerCollection: ...
    def append(self, value: typing.Optional[TriggerBase], /) -> None: ...
    def clear(self) -> None: ...
    def first(self) -> typing.Optional[winrt.windows.foundation.collections.IIterator[TriggerBase]]: ...
    def get_at(self, index: winrt.system.UInt32, /) -> typing.Optional[TriggerBase]: ...
    def get_many(self, start_index: winrt.system.UInt32, items: winrt.system.Array[TriggerBase], /) -> winrt.system.UInt32: ...
    def get_view(self) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[TriggerBase]]: ...
    def index_of(self, value: typing.Optional[TriggerBase], /) -> typing.Tuple[bool, winrt.system.UInt32]: ...
    def insert_at(self, index: winrt.system.UInt32, value: typing.Optional[TriggerBase], /) -> None: ...
    def remove_at(self, index: winrt.system.UInt32, /) -> None: ...
    def remove_at_end(self) -> None: ...
    def replace_all(self, items: winrt.system.Array[TriggerBase], /) -> None: ...
    def set_at(self, index: winrt.system.UInt32, value: typing.Optional[TriggerBase], /) -> None: ...
    @_property
    def size(self) -> winrt.system.UInt32: ...

@typing.final
class UIElement_Static(type):
    def register_as_scroll_port(cls, element: typing.Optional[UIElement], /) -> None: ...
    def try_start_direct_manipulation(cls, value: typing.Optional[winrt.microsoft.ui.xaml.input.Pointer], /) -> bool: ...
    @_property
    def access_key_property(cls) -> typing.Optional[DependencyProperty]: ...
    @_property
    def access_key_scope_owner_property(cls) -> typing.Optional[DependencyProperty]: ...
    @_property
    def allow_drop_property(cls) -> typing.Optional[DependencyProperty]: ...
    @_property
    def bring_into_view_requested_event(cls) -> typing.Optional[RoutedEvent]: ...
    @_property
    def cache_mode_property(cls) -> typing.Optional[DependencyProperty]: ...
    @_property
    def can_be_scroll_anchor_property(cls) -> typing.Optional[DependencyProperty]: ...
    @_property
    def can_drag_property(cls) -> typing.Optional[DependencyProperty]: ...
    @_property
    def character_received_event(cls) -> typing.Optional[RoutedEvent]: ...
    @_property
    def clip_property(cls) -> typing.Optional[DependencyProperty]: ...
    @_property
    def composite_mode_property(cls) -> typing.Optional[DependencyProperty]: ...
    @_property
    def context_flyout_property(cls) -> typing.Optional[DependencyProperty]: ...
    @_property
    def context_requested_event(cls) -> typing.Optional[RoutedEvent]: ...
    @_property
    def double_tapped_event(cls) -> typing.Optional[RoutedEvent]: ...
    @_property
    def drag_enter_event(cls) -> typing.Optional[RoutedEvent]: ...
    @_property
    def drag_leave_event(cls) -> typing.Optional[RoutedEvent]: ...
    @_property
    def drag_over_event(cls) -> typing.Optional[RoutedEvent]: ...
    @_property
    def drop_event(cls) -> typing.Optional[RoutedEvent]: ...
    @_property
    def exit_display_mode_on_access_key_invoked_property(cls) -> typing.Optional[DependencyProperty]: ...
    @_property
    def focus_state_property(cls) -> typing.Optional[DependencyProperty]: ...
    @_property
    def getting_focus_event(cls) -> typing.Optional[RoutedEvent]: ...
    @_property
    def high_contrast_adjustment_property(cls) -> typing.Optional[DependencyProperty]: ...
    @_property
    def holding_event(cls) -> typing.Optional[RoutedEvent]: ...
    @_property
    def is_access_key_scope_property(cls) -> typing.Optional[DependencyProperty]: ...
    @_property
    def is_double_tap_enabled_property(cls) -> typing.Optional[DependencyProperty]: ...
    @_property
    def is_hit_test_visible_property(cls) -> typing.Optional[DependencyProperty]: ...
    @_property
    def is_holding_enabled_property(cls) -> typing.Optional[DependencyProperty]: ...
    @_property
    def is_right_tap_enabled_property(cls) -> typing.Optional[DependencyProperty]: ...
    @_property
    def is_tab_stop_property(cls) -> typing.Optional[DependencyProperty]: ...
    @_property
    def is_tap_enabled_property(cls) -> typing.Optional[DependencyProperty]: ...
    @_property
    def key_down_event(cls) -> typing.Optional[RoutedEvent]: ...
    @_property
    def key_tip_horizontal_offset_property(cls) -> typing.Optional[DependencyProperty]: ...
    @_property
    def key_tip_placement_mode_property(cls) -> typing.Optional[DependencyProperty]: ...
    @_property
    def key_tip_target_property(cls) -> typing.Optional[DependencyProperty]: ...
    @_property
    def key_tip_vertical_offset_property(cls) -> typing.Optional[DependencyProperty]: ...
    @_property
    def key_up_event(cls) -> typing.Optional[RoutedEvent]: ...
    @_property
    def keyboard_accelerator_placement_mode_property(cls) -> typing.Optional[DependencyProperty]: ...
    @_property
    def keyboard_accelerator_placement_target_property(cls) -> typing.Optional[DependencyProperty]: ...
    @_property
    def lights_property(cls) -> typing.Optional[DependencyProperty]: ...
    @_property
    def losing_focus_event(cls) -> typing.Optional[RoutedEvent]: ...
    @_property
    def manipulation_completed_event(cls) -> typing.Optional[RoutedEvent]: ...
    @_property
    def manipulation_delta_event(cls) -> typing.Optional[RoutedEvent]: ...
    @_property
    def manipulation_inertia_starting_event(cls) -> typing.Optional[RoutedEvent]: ...
    @_property
    def manipulation_mode_property(cls) -> typing.Optional[DependencyProperty]: ...
    @_property
    def manipulation_started_event(cls) -> typing.Optional[RoutedEvent]: ...
    @_property
    def manipulation_starting_event(cls) -> typing.Optional[RoutedEvent]: ...
    @_property
    def no_focus_candidate_found_event(cls) -> typing.Optional[RoutedEvent]: ...
    @_property
    def opacity_property(cls) -> typing.Optional[DependencyProperty]: ...
    @_property
    def pointer_canceled_event(cls) -> typing.Optional[RoutedEvent]: ...
    @_property
    def pointer_capture_lost_event(cls) -> typing.Optional[RoutedEvent]: ...
    @_property
    def pointer_captures_property(cls) -> typing.Optional[DependencyProperty]: ...
    @_property
    def pointer_entered_event(cls) -> typing.Optional[RoutedEvent]: ...
    @_property
    def pointer_exited_event(cls) -> typing.Optional[RoutedEvent]: ...
    @_property
    def pointer_moved_event(cls) -> typing.Optional[RoutedEvent]: ...
    @_property
    def pointer_pressed_event(cls) -> typing.Optional[RoutedEvent]: ...
    @_property
    def pointer_released_event(cls) -> typing.Optional[RoutedEvent]: ...
    @_property
    def pointer_wheel_changed_event(cls) -> typing.Optional[RoutedEvent]: ...
    @_property
    def preview_key_down_event(cls) -> typing.Optional[RoutedEvent]: ...
    @_property
    def preview_key_up_event(cls) -> typing.Optional[RoutedEvent]: ...
    @_property
    def projection_property(cls) -> typing.Optional[DependencyProperty]: ...
    @_property
    def render_transform_origin_property(cls) -> typing.Optional[DependencyProperty]: ...
    @_property
    def render_transform_property(cls) -> typing.Optional[DependencyProperty]: ...
    @_property
    def right_tapped_event(cls) -> typing.Optional[RoutedEvent]: ...
    @_property
    def shadow_property(cls) -> typing.Optional[DependencyProperty]: ...
    @_property
    def tab_focus_navigation_property(cls) -> typing.Optional[DependencyProperty]: ...
    @_property
    def tab_index_property(cls) -> typing.Optional[DependencyProperty]: ...
    @_property
    def tapped_event(cls) -> typing.Optional[RoutedEvent]: ...
    @_property
    def transform3_d_property(cls) -> typing.Optional[DependencyProperty]: ...
    @_property
    def transitions_property(cls) -> typing.Optional[DependencyProperty]: ...
    @_property
    def use_layout_rounding_property(cls) -> typing.Optional[DependencyProperty]: ...
    @_property
    def use_system_focus_visuals_property(cls) -> typing.Optional[DependencyProperty]: ...
    @_property
    def visibility_property(cls) -> typing.Optional[DependencyProperty]: ...
    @_property
    def x_y_focus_down_navigation_strategy_property(cls) -> typing.Optional[DependencyProperty]: ...
    @_property
    def x_y_focus_down_property(cls) -> typing.Optional[DependencyProperty]: ...
    @_property
    def x_y_focus_keyboard_navigation_property(cls) -> typing.Optional[DependencyProperty]: ...
    @_property
    def x_y_focus_left_navigation_strategy_property(cls) -> typing.Optional[DependencyProperty]: ...
    @_property
    def x_y_focus_left_property(cls) -> typing.Optional[DependencyProperty]: ...
    @_property
    def x_y_focus_right_navigation_strategy_property(cls) -> typing.Optional[DependencyProperty]: ...
    @_property
    def x_y_focus_right_property(cls) -> typing.Optional[DependencyProperty]: ...
    @_property
    def x_y_focus_up_navigation_strategy_property(cls) -> typing.Optional[DependencyProperty]: ...
    @_property
    def x_y_focus_up_property(cls) -> typing.Optional[DependencyProperty]: ...

@typing.final
class UIElement(winrt.system.Object, metaclass=UIElement_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> UIElement: ...
    def add_handler(self, routed_event: typing.Optional[RoutedEvent], handler: typing.Optional[winrt.system.Object], handled_events_too: bool, /) -> None: ...
    def arrange(self, final_rect: winrt.windows.foundation.Rect, /) -> None: ...
    def cancel_direct_manipulations(self) -> bool: ...
    def capture_pointer(self, value: typing.Optional[winrt.microsoft.ui.xaml.input.Pointer], /) -> bool: ...
    def find_sub_elements_for_touch_targeting(self, point: winrt.windows.foundation.Point, bounding_rect: winrt.windows.foundation.Rect, /) -> typing.Optional[winrt.windows.foundation.collections.IIterable[winrt.windows.foundation.collections.IIterable[winrt.windows.foundation.Point]]]: ...
    def focus(self, value: FocusState, /) -> bool: ...
    def get_children_in_tab_focus_order(self) -> typing.Optional[winrt.windows.foundation.collections.IIterable[DependencyObject]]: ...
    def get_visual_internal(self) -> typing.Optional[winrt.microsoft.ui.composition.Visual]: ...
    def invalidate_arrange(self) -> None: ...
    def invalidate_measure(self) -> None: ...
    def measure(self, available_size: winrt.windows.foundation.Size, /) -> None: ...
    def on_bring_into_view_requested(self, e: typing.Optional[BringIntoViewRequestedEventArgs], /) -> None: ...
    def on_create_automation_peer(self) -> typing.Optional[winrt.microsoft.ui.xaml.automation.peers.AutomationPeer]: ...
    def on_disconnect_visual_children(self) -> None: ...
    def on_keyboard_accelerator_invoked(self, args: typing.Optional[winrt.microsoft.ui.xaml.input.KeyboardAcceleratorInvokedEventArgs], /) -> None: ...
    def on_process_keyboard_accelerators(self, args: typing.Optional[winrt.microsoft.ui.xaml.input.ProcessKeyboardAcceleratorEventArgs], /) -> None: ...
    def populate_property_info(self, property_name: str, property_info: typing.Optional[winrt.microsoft.ui.composition.AnimationPropertyInfo], /) -> None: ...
    def populate_property_info_override(self, property_name: str, animation_property_info: typing.Optional[winrt.microsoft.ui.composition.AnimationPropertyInfo], /) -> None: ...
    def release_pointer_capture(self, value: typing.Optional[winrt.microsoft.ui.xaml.input.Pointer], /) -> None: ...
    def release_pointer_captures(self) -> None: ...
    def remove_handler(self, routed_event: typing.Optional[RoutedEvent], handler: typing.Optional[winrt.system.Object], /) -> None: ...
    def start_animation(self, animation: typing.Optional[winrt.microsoft.ui.composition.ICompositionAnimationBase], /) -> None: ...
    @typing.overload
    def start_bring_into_view(self) -> None: ...
    @typing.overload
    def start_bring_into_view(self, options: typing.Optional[BringIntoViewOptions], /) -> None: ...
    def start_drag_async(self, pointer_point: typing.Optional[winrt.microsoft.ui.input.PointerPoint], /) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.applicationmodel.datatransfer.DataPackageOperation]: ...
    def stop_animation(self, animation: typing.Optional[winrt.microsoft.ui.composition.ICompositionAnimationBase], /) -> None: ...
    def transform_to_visual(self, visual: typing.Optional[UIElement], /) -> typing.Optional[winrt.microsoft.ui.xaml.media.GeneralTransform]: ...
    def try_invoke_keyboard_accelerator(self, args: typing.Optional[winrt.microsoft.ui.xaml.input.ProcessKeyboardAcceleratorEventArgs], /) -> None: ...
    def update_layout(self) -> None: ...
    def add_access_key_display_dismissed(self, handler: winrt.windows.foundation.TypedEventHandler[UIElement, winrt.microsoft.ui.xaml.input.AccessKeyDisplayDismissedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_access_key_display_dismissed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_access_key_display_requested(self, handler: winrt.windows.foundation.TypedEventHandler[UIElement, winrt.microsoft.ui.xaml.input.AccessKeyDisplayRequestedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_access_key_display_requested(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_access_key_invoked(self, handler: winrt.windows.foundation.TypedEventHandler[UIElement, winrt.microsoft.ui.xaml.input.AccessKeyInvokedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_access_key_invoked(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_bring_into_view_requested(self, handler: winrt.windows.foundation.TypedEventHandler[UIElement, BringIntoViewRequestedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_bring_into_view_requested(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_character_received(self, handler: winrt.windows.foundation.TypedEventHandler[UIElement, winrt.microsoft.ui.xaml.input.CharacterReceivedRoutedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_character_received(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_context_canceled(self, handler: winrt.windows.foundation.TypedEventHandler[UIElement, RoutedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_context_canceled(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_context_requested(self, handler: winrt.windows.foundation.TypedEventHandler[UIElement, winrt.microsoft.ui.xaml.input.ContextRequestedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_context_requested(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_double_tapped(self, handler: typing.Optional[winrt.microsoft.ui.xaml.input.DoubleTappedEventHandler], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_double_tapped(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_drag_enter(self, handler: typing.Optional[DragEventHandler], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_drag_enter(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_drag_leave(self, handler: typing.Optional[DragEventHandler], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_drag_leave(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_drag_over(self, handler: typing.Optional[DragEventHandler], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_drag_over(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_drag_starting(self, handler: winrt.windows.foundation.TypedEventHandler[UIElement, DragStartingEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_drag_starting(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_drop(self, handler: typing.Optional[DragEventHandler], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_drop(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_drop_completed(self, handler: winrt.windows.foundation.TypedEventHandler[UIElement, DropCompletedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_drop_completed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_getting_focus(self, handler: winrt.windows.foundation.TypedEventHandler[UIElement, winrt.microsoft.ui.xaml.input.GettingFocusEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_getting_focus(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_got_focus(self, handler: typing.Optional[RoutedEventHandler], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_got_focus(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_holding(self, handler: typing.Optional[winrt.microsoft.ui.xaml.input.HoldingEventHandler], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_holding(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_key_down(self, handler: typing.Optional[winrt.microsoft.ui.xaml.input.KeyEventHandler], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_key_down(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_key_up(self, handler: typing.Optional[winrt.microsoft.ui.xaml.input.KeyEventHandler], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_key_up(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_losing_focus(self, handler: winrt.windows.foundation.TypedEventHandler[UIElement, winrt.microsoft.ui.xaml.input.LosingFocusEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_losing_focus(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_lost_focus(self, handler: typing.Optional[RoutedEventHandler], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_lost_focus(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_manipulation_completed(self, handler: typing.Optional[winrt.microsoft.ui.xaml.input.ManipulationCompletedEventHandler], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_manipulation_completed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_manipulation_delta(self, handler: typing.Optional[winrt.microsoft.ui.xaml.input.ManipulationDeltaEventHandler], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_manipulation_delta(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_manipulation_inertia_starting(self, handler: typing.Optional[winrt.microsoft.ui.xaml.input.ManipulationInertiaStartingEventHandler], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_manipulation_inertia_starting(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_manipulation_started(self, handler: typing.Optional[winrt.microsoft.ui.xaml.input.ManipulationStartedEventHandler], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_manipulation_started(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_manipulation_starting(self, handler: typing.Optional[winrt.microsoft.ui.xaml.input.ManipulationStartingEventHandler], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_manipulation_starting(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_no_focus_candidate_found(self, handler: winrt.windows.foundation.TypedEventHandler[UIElement, winrt.microsoft.ui.xaml.input.NoFocusCandidateFoundEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_no_focus_candidate_found(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_pointer_canceled(self, handler: typing.Optional[winrt.microsoft.ui.xaml.input.PointerEventHandler], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_pointer_canceled(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_pointer_capture_lost(self, handler: typing.Optional[winrt.microsoft.ui.xaml.input.PointerEventHandler], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_pointer_capture_lost(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_pointer_entered(self, handler: typing.Optional[winrt.microsoft.ui.xaml.input.PointerEventHandler], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_pointer_entered(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_pointer_exited(self, handler: typing.Optional[winrt.microsoft.ui.xaml.input.PointerEventHandler], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_pointer_exited(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_pointer_moved(self, handler: typing.Optional[winrt.microsoft.ui.xaml.input.PointerEventHandler], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_pointer_moved(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_pointer_pressed(self, handler: typing.Optional[winrt.microsoft.ui.xaml.input.PointerEventHandler], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_pointer_pressed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_pointer_released(self, handler: typing.Optional[winrt.microsoft.ui.xaml.input.PointerEventHandler], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_pointer_released(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_pointer_wheel_changed(self, handler: typing.Optional[winrt.microsoft.ui.xaml.input.PointerEventHandler], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_pointer_wheel_changed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_preview_key_down(self, handler: typing.Optional[winrt.microsoft.ui.xaml.input.KeyEventHandler], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_preview_key_down(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_preview_key_up(self, handler: typing.Optional[winrt.microsoft.ui.xaml.input.KeyEventHandler], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_preview_key_up(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_process_keyboard_accelerators(self, handler: winrt.windows.foundation.TypedEventHandler[UIElement, winrt.microsoft.ui.xaml.input.ProcessKeyboardAcceleratorEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_process_keyboard_accelerators(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_right_tapped(self, handler: typing.Optional[winrt.microsoft.ui.xaml.input.RightTappedEventHandler], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_right_tapped(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_tapped(self, handler: typing.Optional[winrt.microsoft.ui.xaml.input.TappedEventHandler], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_tapped(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    @_property
    def keyboard_accelerator_placement_mode(self) -> winrt.microsoft.ui.xaml.input.KeyboardAcceleratorPlacementMode: ...
    @keyboard_accelerator_placement_mode.setter
    def keyboard_accelerator_placement_mode(self, value: winrt.microsoft.ui.xaml.input.KeyboardAcceleratorPlacementMode) -> None: ...
    @_property
    def rotation_transition(self) -> typing.Optional[ScalarTransition]: ...
    @rotation_transition.setter
    def rotation_transition(self, value: typing.Optional[ScalarTransition]) -> None: ...
    @_property
    def key_tip_target(self) -> typing.Optional[DependencyObject]: ...
    @key_tip_target.setter
    def key_tip_target(self, value: typing.Optional[DependencyObject]) -> None: ...
    @_property
    def key_tip_placement_mode(self) -> winrt.microsoft.ui.xaml.input.KeyTipPlacementMode: ...
    @key_tip_placement_mode.setter
    def key_tip_placement_mode(self, value: winrt.microsoft.ui.xaml.input.KeyTipPlacementMode) -> None: ...
    @_property
    def key_tip_horizontal_offset(self) -> winrt.system.Double: ...
    @key_tip_horizontal_offset.setter
    def key_tip_horizontal_offset(self, value: winrt.system.Double) -> None: ...
    @_property
    def is_tap_enabled(self) -> bool: ...
    @is_tap_enabled.setter
    def is_tap_enabled(self, value: bool) -> None: ...
    @_property
    def is_tab_stop(self) -> bool: ...
    @is_tab_stop.setter
    def is_tab_stop(self, value: bool) -> None: ...
    @_property
    def is_right_tap_enabled(self) -> bool: ...
    @is_right_tap_enabled.setter
    def is_right_tap_enabled(self, value: bool) -> None: ...
    @_property
    def is_holding_enabled(self) -> bool: ...
    @is_holding_enabled.setter
    def is_holding_enabled(self, value: bool) -> None: ...
    @_property
    def is_hit_test_visible(self) -> bool: ...
    @is_hit_test_visible.setter
    def is_hit_test_visible(self, value: bool) -> None: ...
    @_property
    def is_double_tap_enabled(self) -> bool: ...
    @is_double_tap_enabled.setter
    def is_double_tap_enabled(self, value: bool) -> None: ...
    @_property
    def access_key(self) -> str: ...
    @access_key.setter
    def access_key(self, value: str) -> None: ...
    @_property
    def high_contrast_adjustment(self) -> ElementHighContrastAdjustment: ...
    @high_contrast_adjustment.setter
    def high_contrast_adjustment(self, value: ElementHighContrastAdjustment) -> None: ...
    @_property
    def manipulation_mode(self) -> winrt.microsoft.ui.xaml.input.ManipulationModes: ...
    @manipulation_mode.setter
    def manipulation_mode(self, value: winrt.microsoft.ui.xaml.input.ManipulationModes) -> None: ...
    @_property
    def exit_display_mode_on_access_key_invoked(self) -> bool: ...
    @exit_display_mode_on_access_key_invoked.setter
    def exit_display_mode_on_access_key_invoked(self, value: bool) -> None: ...
    @_property
    def opacity_transition(self) -> typing.Optional[ScalarTransition]: ...
    @opacity_transition.setter
    def opacity_transition(self, value: typing.Optional[ScalarTransition]) -> None: ...
    @_property
    def context_flyout(self) -> typing.Optional[winrt.microsoft.ui.xaml.controls.primitives.FlyoutBase]: ...
    @context_flyout.setter
    def context_flyout(self, value: typing.Optional[winrt.microsoft.ui.xaml.controls.primitives.FlyoutBase]) -> None: ...
    @_property
    def composite_mode(self) -> winrt.microsoft.ui.xaml.media.ElementCompositeMode: ...
    @composite_mode.setter
    def composite_mode(self, value: winrt.microsoft.ui.xaml.media.ElementCompositeMode) -> None: ...
    @_property
    def clip(self) -> typing.Optional[winrt.microsoft.ui.xaml.media.RectangleGeometry]: ...
    @clip.setter
    def clip(self, value: typing.Optional[winrt.microsoft.ui.xaml.media.RectangleGeometry]) -> None: ...
    @_property
    def translation(self) -> winrt.windows.foundation.numerics.Vector3: ...
    @translation.setter
    def translation(self, value: winrt.windows.foundation.numerics.Vector3) -> None: ...
    @_property
    def can_drag(self) -> bool: ...
    @can_drag.setter
    def can_drag(self, value: bool) -> None: ...
    @_property
    def can_be_scroll_anchor(self) -> bool: ...
    @can_be_scroll_anchor.setter
    def can_be_scroll_anchor(self, value: bool) -> None: ...
    @_property
    def cache_mode(self) -> typing.Optional[winrt.microsoft.ui.xaml.media.CacheMode]: ...
    @cache_mode.setter
    def cache_mode(self, value: typing.Optional[winrt.microsoft.ui.xaml.media.CacheMode]) -> None: ...
    @_property
    def allow_drop(self) -> bool: ...
    @allow_drop.setter
    def allow_drop(self, value: bool) -> None: ...
    @_property
    def opacity(self) -> winrt.system.Double: ...
    @opacity.setter
    def opacity(self, value: winrt.system.Double) -> None: ...
    @_property
    def keyboard_accelerator_placement_target(self) -> typing.Optional[DependencyObject]: ...
    @keyboard_accelerator_placement_target.setter
    def keyboard_accelerator_placement_target(self, value: typing.Optional[DependencyObject]) -> None: ...
    @_property
    def access_key_scope_owner(self) -> typing.Optional[DependencyObject]: ...
    @access_key_scope_owner.setter
    def access_key_scope_owner(self, value: typing.Optional[DependencyObject]) -> None: ...
    @_property
    def is_access_key_scope(self) -> bool: ...
    @is_access_key_scope.setter
    def is_access_key_scope(self, value: bool) -> None: ...
    @_property
    def key_tip_vertical_offset(self) -> winrt.system.Double: ...
    @key_tip_vertical_offset.setter
    def key_tip_vertical_offset(self, value: winrt.system.Double) -> None: ...
    @_property
    def xaml_root(self) -> typing.Optional[XamlRoot]: ...
    @xaml_root.setter
    def xaml_root(self, value: typing.Optional[XamlRoot]) -> None: ...
    @_property
    def x_y_focus_up_navigation_strategy(self) -> winrt.microsoft.ui.xaml.input.XYFocusNavigationStrategy: ...
    @x_y_focus_up_navigation_strategy.setter
    def x_y_focus_up_navigation_strategy(self, value: winrt.microsoft.ui.xaml.input.XYFocusNavigationStrategy) -> None: ...
    @_property
    def x_y_focus_up(self) -> typing.Optional[DependencyObject]: ...
    @x_y_focus_up.setter
    def x_y_focus_up(self, value: typing.Optional[DependencyObject]) -> None: ...
    @_property
    def x_y_focus_right_navigation_strategy(self) -> winrt.microsoft.ui.xaml.input.XYFocusNavigationStrategy: ...
    @x_y_focus_right_navigation_strategy.setter
    def x_y_focus_right_navigation_strategy(self, value: winrt.microsoft.ui.xaml.input.XYFocusNavigationStrategy) -> None: ...
    @_property
    def x_y_focus_right(self) -> typing.Optional[DependencyObject]: ...
    @x_y_focus_right.setter
    def x_y_focus_right(self, value: typing.Optional[DependencyObject]) -> None: ...
    @_property
    def x_y_focus_left_navigation_strategy(self) -> winrt.microsoft.ui.xaml.input.XYFocusNavigationStrategy: ...
    @x_y_focus_left_navigation_strategy.setter
    def x_y_focus_left_navigation_strategy(self, value: winrt.microsoft.ui.xaml.input.XYFocusNavigationStrategy) -> None: ...
    @_property
    def center_point(self) -> winrt.windows.foundation.numerics.Vector3: ...
    @center_point.setter
    def center_point(self, value: winrt.windows.foundation.numerics.Vector3) -> None: ...
    @_property
    def x_y_focus_keyboard_navigation(self) -> winrt.microsoft.ui.xaml.input.XYFocusKeyboardNavigationMode: ...
    @x_y_focus_keyboard_navigation.setter
    def x_y_focus_keyboard_navigation(self, value: winrt.microsoft.ui.xaml.input.XYFocusKeyboardNavigationMode) -> None: ...
    @_property
    def x_y_focus_down_navigation_strategy(self) -> winrt.microsoft.ui.xaml.input.XYFocusNavigationStrategy: ...
    @x_y_focus_down_navigation_strategy.setter
    def x_y_focus_down_navigation_strategy(self, value: winrt.microsoft.ui.xaml.input.XYFocusNavigationStrategy) -> None: ...
    @_property
    def x_y_focus_down(self) -> typing.Optional[DependencyObject]: ...
    @x_y_focus_down.setter
    def x_y_focus_down(self, value: typing.Optional[DependencyObject]) -> None: ...
    @_property
    def visibility(self) -> Visibility: ...
    @visibility.setter
    def visibility(self, value: Visibility) -> None: ...
    @_property
    def use_system_focus_visuals(self) -> bool: ...
    @use_system_focus_visuals.setter
    def use_system_focus_visuals(self, value: bool) -> None: ...
    @_property
    def use_layout_rounding(self) -> bool: ...
    @use_layout_rounding.setter
    def use_layout_rounding(self, value: bool) -> None: ...
    @_property
    def translation_transition(self) -> typing.Optional[Vector3Transition]: ...
    @translation_transition.setter
    def translation_transition(self, value: typing.Optional[Vector3Transition]) -> None: ...
    @_property
    def x_y_focus_left(self) -> typing.Optional[DependencyObject]: ...
    @x_y_focus_left.setter
    def x_y_focus_left(self, value: typing.Optional[DependencyObject]) -> None: ...
    @_property
    def transitions(self) -> typing.Optional[winrt.microsoft.ui.xaml.media.animation.TransitionCollection]: ...
    @transitions.setter
    def transitions(self, value: typing.Optional[winrt.microsoft.ui.xaml.media.animation.TransitionCollection]) -> None: ...
    @_property
    def transform_matrix(self) -> winrt.windows.foundation.numerics.Matrix4x4: ...
    @transform_matrix.setter
    def transform_matrix(self, value: winrt.windows.foundation.numerics.Matrix4x4) -> None: ...
    @_property
    def rotation(self) -> winrt.system.Single: ...
    @rotation.setter
    def rotation(self, value: winrt.system.Single) -> None: ...
    @_property
    def render_transform_origin(self) -> winrt.windows.foundation.Point: ...
    @render_transform_origin.setter
    def render_transform_origin(self, value: winrt.windows.foundation.Point) -> None: ...
    @_property
    def render_transform(self) -> typing.Optional[winrt.microsoft.ui.xaml.media.Transform]: ...
    @render_transform.setter
    def render_transform(self, value: typing.Optional[winrt.microsoft.ui.xaml.media.Transform]) -> None: ...
    @_property
    def tab_focus_navigation(self) -> winrt.microsoft.ui.xaml.input.KeyboardNavigationMode: ...
    @tab_focus_navigation.setter
    def tab_focus_navigation(self, value: winrt.microsoft.ui.xaml.input.KeyboardNavigationMode) -> None: ...
    @_property
    def rasterization_scale(self) -> winrt.system.Double: ...
    @rasterization_scale.setter
    def rasterization_scale(self, value: winrt.system.Double) -> None: ...
    @_property
    def projection(self) -> typing.Optional[winrt.microsoft.ui.xaml.media.Projection]: ...
    @projection.setter
    def projection(self, value: typing.Optional[winrt.microsoft.ui.xaml.media.Projection]) -> None: ...
    @_property
    def shadow(self) -> typing.Optional[winrt.microsoft.ui.xaml.media.Shadow]: ...
    @shadow.setter
    def shadow(self, value: typing.Optional[winrt.microsoft.ui.xaml.media.Shadow]) -> None: ...
    @_property
    def scale_transition(self) -> typing.Optional[Vector3Transition]: ...
    @scale_transition.setter
    def scale_transition(self, value: typing.Optional[Vector3Transition]) -> None: ...
    @_property
    def scale(self) -> winrt.windows.foundation.numerics.Vector3: ...
    @scale.setter
    def scale(self, value: winrt.windows.foundation.numerics.Vector3) -> None: ...
    @_property
    def tab_index(self) -> winrt.system.Int32: ...
    @tab_index.setter
    def tab_index(self, value: winrt.system.Int32) -> None: ...
    @_property
    def rotation_axis(self) -> winrt.windows.foundation.numerics.Vector3: ...
    @rotation_axis.setter
    def rotation_axis(self, value: winrt.windows.foundation.numerics.Vector3) -> None: ...
    @_property
    def transform3_d(self) -> typing.Optional[winrt.microsoft.ui.xaml.media.media3d.Transform3D]: ...
    @transform3_d.setter
    def transform3_d(self, value: typing.Optional[winrt.microsoft.ui.xaml.media.media3d.Transform3D]) -> None: ...
    @_property
    def desired_size(self) -> winrt.windows.foundation.Size: ...
    @_property
    def focus_state(self) -> FocusState: ...
    @_property
    def keyboard_accelerators(self) -> typing.Optional[winrt.windows.foundation.collections.IVector[winrt.microsoft.ui.xaml.input.KeyboardAccelerator]]: ...
    @_property
    def lights(self) -> typing.Optional[winrt.windows.foundation.collections.IVector[winrt.microsoft.ui.xaml.media.XamlLight]]: ...
    @_property
    def render_size(self) -> winrt.windows.foundation.Size: ...
    @_property
    def pointer_captures(self) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[winrt.microsoft.ui.xaml.input.Pointer]]: ...
    @_property
    def actual_offset(self) -> winrt.windows.foundation.numerics.Vector3: ...
    @_property
    def actual_size(self) -> winrt.windows.foundation.numerics.Vector2: ...
    @_property
    def protected_cursor(self) -> typing.Optional[winrt.microsoft.ui.input.InputCursor]: ...
    @protected_cursor.setter
    def protected_cursor(self, value: typing.Optional[winrt.microsoft.ui.input.InputCursor]) -> None: ...

@typing.final
class UIElementWeakCollection(winrt.system.Object, winrt._winrt.MutableSequence[UIElement]):
    def __len__(self) -> int: ...
    def __iter__(self) -> winrt.windows.foundation.collections.IIterator[UIElement]: ...
    @typing.overload
    def __getitem__(self, index: typing.SupportsIndex) -> UIElement: ...
    @typing.overload
    def __getitem__(self, index: slice) -> winrt.system.Array[UIElement]: ...
    @typing.overload
    def __delitem__(self, index: typing.SupportsIndex) -> None: ...
    @typing.overload
    def __delitem__(self, index: slice) -> None: ...
    @typing.overload
    def __setitem__(self, index: typing.SupportsIndex, value: UIElement) -> None: ...
    @typing.overload
    def __setitem__(self, index: slice, value: typing.Iterable[UIElement]) -> None: ...
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> UIElementWeakCollection: ...
    def __new__(cls: typing.Type[UIElementWeakCollection]) -> UIElementWeakCollection:...
    def append(self, value: typing.Optional[UIElement], /) -> None: ...
    def clear(self) -> None: ...
    def first(self) -> typing.Optional[winrt.windows.foundation.collections.IIterator[UIElement]]: ...
    def get_at(self, index: winrt.system.UInt32, /) -> typing.Optional[UIElement]: ...
    def get_many(self, start_index: winrt.system.UInt32, items: winrt.system.Array[UIElement], /) -> winrt.system.UInt32: ...
    def get_view(self) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[UIElement]]: ...
    def index_of(self, value: typing.Optional[UIElement], /) -> typing.Tuple[bool, winrt.system.UInt32]: ...
    def insert_at(self, index: winrt.system.UInt32, value: typing.Optional[UIElement], /) -> None: ...
    def remove_at(self, index: winrt.system.UInt32, /) -> None: ...
    def remove_at_end(self) -> None: ...
    def replace_all(self, items: winrt.system.Array[UIElement], /) -> None: ...
    def set_at(self, index: winrt.system.UInt32, value: typing.Optional[UIElement], /) -> None: ...
    @_property
    def size(self) -> winrt.system.UInt32: ...

@typing.final
class UnhandledExceptionEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> UnhandledExceptionEventArgs: ...
    @_property
    def handled(self) -> bool: ...
    @handled.setter
    def handled(self, value: bool) -> None: ...
    @_property
    def exception(self) -> winrt.windows.foundation.HResult: ...
    @_property
    def message(self) -> str: ...

@typing.final
class Vector3Transition(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> Vector3Transition: ...
    def __new__(cls: typing.Type[Vector3Transition]) -> Vector3Transition:...
    @_property
    def duration(self) -> datetime.timedelta: ...
    @duration.setter
    def duration(self, value: datetime.timedelta) -> None: ...
    @_property
    def components(self) -> Vector3TransitionComponents: ...
    @components.setter
    def components(self, value: Vector3TransitionComponents) -> None: ...

@typing.final
class VisualState(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> VisualState: ...
    def __new__(cls: typing.Type[VisualState]) -> VisualState:...
    @_property
    def storyboard(self) -> typing.Optional[winrt.microsoft.ui.xaml.media.animation.Storyboard]: ...
    @storyboard.setter
    def storyboard(self, value: typing.Optional[winrt.microsoft.ui.xaml.media.animation.Storyboard]) -> None: ...
    @_property
    def name(self) -> str: ...
    @_property
    def setters(self) -> typing.Optional[SetterBaseCollection]: ...
    @_property
    def state_triggers(self) -> typing.Optional[winrt.windows.foundation.collections.IVector[StateTriggerBase]]: ...

@typing.final
class VisualStateChangedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> VisualStateChangedEventArgs: ...
    def __new__(cls: typing.Type[VisualStateChangedEventArgs]) -> VisualStateChangedEventArgs:...
    @_property
    def old_state(self) -> typing.Optional[VisualState]: ...
    @old_state.setter
    def old_state(self, value: typing.Optional[VisualState]) -> None: ...
    @_property
    def new_state(self) -> typing.Optional[VisualState]: ...
    @new_state.setter
    def new_state(self, value: typing.Optional[VisualState]) -> None: ...
    @_property
    def control(self) -> typing.Optional[winrt.microsoft.ui.xaml.controls.Control]: ...
    @control.setter
    def control(self, value: typing.Optional[winrt.microsoft.ui.xaml.controls.Control]) -> None: ...

@typing.final
class VisualStateGroup(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> VisualStateGroup: ...
    def __new__(cls: typing.Type[VisualStateGroup]) -> VisualStateGroup:...
    def add_current_state_changed(self, handler: typing.Optional[VisualStateChangedEventHandler], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_current_state_changed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_current_state_changing(self, handler: typing.Optional[VisualStateChangedEventHandler], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_current_state_changing(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    @_property
    def current_state(self) -> typing.Optional[VisualState]: ...
    @_property
    def name(self) -> str: ...
    @_property
    def states(self) -> typing.Optional[winrt.windows.foundation.collections.IVector[VisualState]]: ...
    @_property
    def transitions(self) -> typing.Optional[winrt.windows.foundation.collections.IVector[VisualTransition]]: ...

@typing.final
class VisualStateManager_Static(type):
    def get_custom_visual_state_manager(cls, obj: typing.Optional[FrameworkElement], /) -> typing.Optional[VisualStateManager]: ...
    def get_visual_state_groups(cls, obj: typing.Optional[FrameworkElement], /) -> typing.Optional[winrt.windows.foundation.collections.IVector[VisualStateGroup]]: ...
    def go_to_state(cls, control: typing.Optional[winrt.microsoft.ui.xaml.controls.Control], state_name: str, use_transitions: bool, /) -> bool: ...
    def set_custom_visual_state_manager(cls, obj: typing.Optional[FrameworkElement], value: typing.Optional[VisualStateManager], /) -> None: ...
    @_property
    def custom_visual_state_manager_property(cls) -> typing.Optional[DependencyProperty]: ...

@typing.final
class VisualStateManager(winrt.system.Object, metaclass=VisualStateManager_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> VisualStateManager: ...
    def __new__(cls: typing.Type[VisualStateManager]) -> VisualStateManager:...
    def go_to_state_core(self, control: typing.Optional[winrt.microsoft.ui.xaml.controls.Control], template_root: typing.Optional[FrameworkElement], state_name: str, group: typing.Optional[VisualStateGroup], state: typing.Optional[VisualState], use_transitions: bool, /) -> bool: ...
    def raise_current_state_changed(self, state_group: typing.Optional[VisualStateGroup], old_state: typing.Optional[VisualState], new_state: typing.Optional[VisualState], control: typing.Optional[winrt.microsoft.ui.xaml.controls.Control], /) -> None: ...
    def raise_current_state_changing(self, state_group: typing.Optional[VisualStateGroup], old_state: typing.Optional[VisualState], new_state: typing.Optional[VisualState], control: typing.Optional[winrt.microsoft.ui.xaml.controls.Control], /) -> None: ...

@typing.final
class VisualTransition(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> VisualTransition: ...
    def __new__(cls: typing.Type[VisualTransition]) -> VisualTransition:...
    @_property
    def to(self) -> str: ...
    @to.setter
    def to(self, value: str) -> None: ...
    @_property
    def storyboard(self) -> typing.Optional[winrt.microsoft.ui.xaml.media.animation.Storyboard]: ...
    @storyboard.setter
    def storyboard(self, value: typing.Optional[winrt.microsoft.ui.xaml.media.animation.Storyboard]) -> None: ...
    @_property
    def generated_easing_function(self) -> typing.Optional[winrt.microsoft.ui.xaml.media.animation.EasingFunctionBase]: ...
    @generated_easing_function.setter
    def generated_easing_function(self, value: typing.Optional[winrt.microsoft.ui.xaml.media.animation.EasingFunctionBase]) -> None: ...
    @_property
    def generated_duration(self) -> Duration: ...
    @generated_duration.setter
    def generated_duration(self, value: Duration) -> None: ...
    @_property
    def from_(self) -> str: ...
    @from_.setter
    def from_(self, value: str) -> None: ...

@typing.final
class Window_Static(type):
    @_property
    def current(cls) -> typing.Optional[Window]: ...

@typing.final
class Window(winrt.system.Object, metaclass=Window_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> Window: ...
    def __new__(cls: typing.Type[Window]) -> Window:...
    def activate(self) -> None: ...
    def close(self) -> None: ...
    def set_title_bar(self, title_bar: typing.Optional[UIElement], /) -> None: ...
    def add_activated(self, handler: winrt.windows.foundation.TypedEventHandler[winrt.system.Object, WindowActivatedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_activated(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_closed(self, handler: winrt.windows.foundation.TypedEventHandler[winrt.system.Object, WindowEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_closed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_size_changed(self, handler: winrt.windows.foundation.TypedEventHandler[winrt.system.Object, WindowSizeChangedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_size_changed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_visibility_changed(self, handler: winrt.windows.foundation.TypedEventHandler[winrt.system.Object, WindowVisibilityChangedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_visibility_changed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    @_property
    def title(self) -> str: ...
    @title.setter
    def title(self, value: str) -> None: ...
    @_property
    def extends_content_into_title_bar(self) -> bool: ...
    @extends_content_into_title_bar.setter
    def extends_content_into_title_bar(self, value: bool) -> None: ...
    @_property
    def content(self) -> typing.Optional[UIElement]: ...
    @content.setter
    def content(self, value: typing.Optional[UIElement]) -> None: ...
    @_property
    def bounds(self) -> winrt.windows.foundation.Rect: ...
    @_property
    def compositor(self) -> typing.Optional[winrt.microsoft.ui.composition.Compositor]: ...
    @_property
    def core_window(self) -> typing.Optional[winrt.windows.ui.core.CoreWindow]: ...
    @_property
    def dispatcher(self) -> typing.Optional[winrt.windows.ui.core.CoreDispatcher]: ...
    @_property
    def dispatcher_queue(self) -> typing.Optional[winrt.microsoft.ui.dispatching.DispatcherQueue]: ...
    @_property
    def visible(self) -> bool: ...
    @_property
    def system_backdrop(self) -> typing.Optional[winrt.microsoft.ui.xaml.media.SystemBackdrop]: ...
    @system_backdrop.setter
    def system_backdrop(self, value: typing.Optional[winrt.microsoft.ui.xaml.media.SystemBackdrop]) -> None: ...
    @_property
    def app_window(self) -> typing.Optional[winrt.microsoft.ui.windowing.AppWindow]: ...

@typing.final
class WindowActivatedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> WindowActivatedEventArgs: ...
    @_property
    def handled(self) -> bool: ...
    @handled.setter
    def handled(self, value: bool) -> None: ...
    @_property
    def window_activation_state(self) -> WindowActivationState: ...

@typing.final
class WindowEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> WindowEventArgs: ...
    @_property
    def handled(self) -> bool: ...
    @handled.setter
    def handled(self, value: bool) -> None: ...

@typing.final
class WindowSizeChangedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> WindowSizeChangedEventArgs: ...
    @_property
    def handled(self) -> bool: ...
    @handled.setter
    def handled(self, value: bool) -> None: ...
    @_property
    def size(self) -> winrt.windows.foundation.Size: ...

@typing.final
class WindowVisibilityChangedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> WindowVisibilityChangedEventArgs: ...
    @_property
    def handled(self) -> bool: ...
    @handled.setter
    def handled(self, value: bool) -> None: ...
    @_property
    def visible(self) -> bool: ...

@typing.final
class XamlResourceReferenceFailedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> XamlResourceReferenceFailedEventArgs: ...
    @_property
    def message(self) -> str: ...

@typing.final
class XamlRoot(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> XamlRoot: ...
    def add_changed(self, handler: winrt.windows.foundation.TypedEventHandler[XamlRoot, XamlRootChangedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_changed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    @_property
    def content(self) -> typing.Optional[UIElement]: ...
    @_property
    def is_host_visible(self) -> bool: ...
    @_property
    def rasterization_scale(self) -> winrt.system.Double: ...
    @_property
    def size(self) -> winrt.windows.foundation.Size: ...
    @_property
    def content_island_environment(self) -> typing.Optional[winrt.microsoft.ui.content.ContentIslandEnvironment]: ...

@typing.final
class XamlRootChangedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> XamlRootChangedEventArgs: ...

@typing.final
class IDataTemplateExtension(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> IDataTemplateExtension: ...
    def process_binding(self, phase: winrt.system.UInt32, /) -> bool: ...
    def process_bindings(self, arg: typing.Optional[winrt.microsoft.ui.xaml.controls.ContainerContentChangingEventArgs], /) -> winrt.system.Int32: ...
    def reset_template(self) -> None: ...

@typing.final
class IElementFactory(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> IElementFactory: ...
    def get_element(self, args: typing.Optional[ElementFactoryGetArgs], /) -> typing.Optional[UIElement]: ...
    def recycle_element(self, args: typing.Optional[ElementFactoryRecycleArgs], /) -> None: ...

@typing.final
class IXamlServiceProvider(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> IXamlServiceProvider: ...
    def get_service(self, type: winrt.windows.ui.xaml.interop.TypeName, /) -> typing.Optional[winrt.system.Object]: ...

