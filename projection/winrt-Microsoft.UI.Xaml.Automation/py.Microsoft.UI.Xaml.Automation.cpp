// WARNING: Please don't edit this file. It was generated by Python/WinRT v0.0.0

#include "py.Microsoft.UI.Xaml.Automation.h"


namespace py::cpp::Microsoft::UI::Xaml::Automation
{
    // ----- AnnotationPatternIdentifiers class --------------------

    static PyObject* _new_AnnotationPatternIdentifiers(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Xaml::Automation::AnnotationPatternIdentifiers>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Xaml::Automation::AnnotationPatternIdentifiers>::type_name);
        return nullptr;
    }

    static void _dealloc_AnnotationPatternIdentifiers(py::wrapper::Microsoft::UI::Xaml::Automation::AnnotationPatternIdentifiers* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AnnotationPatternIdentifiers_get_AnnotationTypeIdProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.AnnotationPatternIdentifiers", L"AnnotationTypeIdProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Automation::AnnotationPatternIdentifiers::AnnotationTypeIdProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AnnotationPatternIdentifiers_get_AnnotationTypeNameProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.AnnotationPatternIdentifiers", L"AnnotationTypeNameProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Automation::AnnotationPatternIdentifiers::AnnotationTypeNameProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AnnotationPatternIdentifiers_get_AuthorProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.AnnotationPatternIdentifiers", L"AuthorProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Automation::AnnotationPatternIdentifiers::AuthorProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AnnotationPatternIdentifiers_get_DateTimeProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.AnnotationPatternIdentifiers", L"DateTimeProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Automation::AnnotationPatternIdentifiers::DateTimeProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AnnotationPatternIdentifiers_get_TargetProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.AnnotationPatternIdentifiers", L"TargetProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Automation::AnnotationPatternIdentifiers::TargetProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AnnotationPatternIdentifiers(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Automation::AnnotationPatternIdentifiers>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AnnotationPatternIdentifiers(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Automation::AnnotationPatternIdentifiers>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AnnotationPatternIdentifiers[] = {
        { "_assign_array_", _assign_array_AnnotationPatternIdentifiers, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AnnotationPatternIdentifiers), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AnnotationPatternIdentifiers[] = {
        { }
    };

    static PyType_Slot _type_slots_AnnotationPatternIdentifiers[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_AnnotationPatternIdentifiers) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AnnotationPatternIdentifiers) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AnnotationPatternIdentifiers) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AnnotationPatternIdentifiers) },
        { },
    };

    static PyType_Spec type_spec_AnnotationPatternIdentifiers =
    {
        "winrt._winrt_microsoft_ui_xaml_automation.AnnotationPatternIdentifiers",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Automation::AnnotationPatternIdentifiers),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AnnotationPatternIdentifiers
    };

    static PyGetSetDef getset_AnnotationPatternIdentifiers_Static[] = {
        { "annotation_type_id_property", reinterpret_cast<getter>(AnnotationPatternIdentifiers_get_AnnotationTypeIdProperty), nullptr, nullptr, nullptr },
        { "annotation_type_name_property", reinterpret_cast<getter>(AnnotationPatternIdentifiers_get_AnnotationTypeNameProperty), nullptr, nullptr, nullptr },
        { "author_property", reinterpret_cast<getter>(AnnotationPatternIdentifiers_get_AuthorProperty), nullptr, nullptr, nullptr },
        { "date_time_property", reinterpret_cast<getter>(AnnotationPatternIdentifiers_get_DateTimeProperty), nullptr, nullptr, nullptr },
        { "target_property", reinterpret_cast<getter>(AnnotationPatternIdentifiers_get_TargetProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_AnnotationPatternIdentifiers_Static[] = {
        { }
    };

    static PyType_Slot type_slots_AnnotationPatternIdentifiers_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_AnnotationPatternIdentifiers_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_AnnotationPatternIdentifiers_Static) },
        { }
    };

    static PyType_Spec type_spec_AnnotationPatternIdentifiers_Static =
    {
        "winrt._winrt_microsoft_ui_xaml_automation.AnnotationPatternIdentifiers_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_AnnotationPatternIdentifiers_Static
    };

    // ----- AutomationAnnotation class --------------------

    static PyObject* _new_AutomationAnnotation(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Automation::AnnotationType>(args, 0);

                winrt::Microsoft::UI::Xaml::Automation::AutomationAnnotation instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Automation::AnnotationType>(args, 0);
                auto param1 = py::convert_to<winrt::Microsoft::UI::Xaml::UIElement>(args, 1);

                winrt::Microsoft::UI::Xaml::Automation::AutomationAnnotation instance{ param0, param1 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 0)
        {
            try
            {
                winrt::Microsoft::UI::Xaml::Automation::AutomationAnnotation instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_AutomationAnnotation(py::wrapper::Microsoft::UI::Xaml::Automation::AutomationAnnotation* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AutomationAnnotation_get_Type(py::wrapper::Microsoft::UI::Xaml::Automation::AutomationAnnotation* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.AutomationAnnotation", L"Type"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Type());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AutomationAnnotation_put_Type(py::wrapper::Microsoft::UI::Xaml::Automation::AutomationAnnotation* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.AutomationAnnotation", L"Type"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Automation::AnnotationType>(arg);

            self->obj.Type(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AutomationAnnotation_get_Element(py::wrapper::Microsoft::UI::Xaml::Automation::AutomationAnnotation* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.AutomationAnnotation", L"Element"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Element());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AutomationAnnotation_put_Element(py::wrapper::Microsoft::UI::Xaml::Automation::AutomationAnnotation* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.AutomationAnnotation", L"Element"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::UIElement>(arg);

            self->obj.Element(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AutomationAnnotation_get_ElementProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.AutomationAnnotation", L"ElementProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Automation::AutomationAnnotation::ElementProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AutomationAnnotation_get_TypeProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.AutomationAnnotation", L"TypeProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Automation::AutomationAnnotation::TypeProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AutomationAnnotation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Automation::AutomationAnnotation>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AutomationAnnotation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Automation::AutomationAnnotation>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AutomationAnnotation[] = {
        { "_assign_array_", _assign_array_AutomationAnnotation, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AutomationAnnotation), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AutomationAnnotation[] = {
        { "type", reinterpret_cast<getter>(AutomationAnnotation_get_Type), reinterpret_cast<setter>(AutomationAnnotation_put_Type), nullptr, nullptr },
        { "element", reinterpret_cast<getter>(AutomationAnnotation_get_Element), reinterpret_cast<setter>(AutomationAnnotation_put_Element), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AutomationAnnotation[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_AutomationAnnotation) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AutomationAnnotation) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AutomationAnnotation) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AutomationAnnotation) },
        { },
    };

    static PyType_Spec type_spec_AutomationAnnotation =
    {
        "winrt._winrt_microsoft_ui_xaml_automation.AutomationAnnotation",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Automation::AutomationAnnotation),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AutomationAnnotation
    };

    static PyGetSetDef getset_AutomationAnnotation_Static[] = {
        { "element_property", reinterpret_cast<getter>(AutomationAnnotation_get_ElementProperty), nullptr, nullptr, nullptr },
        { "type_property", reinterpret_cast<getter>(AutomationAnnotation_get_TypeProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_AutomationAnnotation_Static[] = {
        { }
    };

    static PyType_Slot type_slots_AutomationAnnotation_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_AutomationAnnotation_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_AutomationAnnotation_Static) },
        { }
    };

    static PyType_Spec type_spec_AutomationAnnotation_Static =
    {
        "winrt._winrt_microsoft_ui_xaml_automation.AutomationAnnotation_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_AutomationAnnotation_Static
    };

    // ----- AutomationElementIdentifiers class --------------------

    static PyObject* _new_AutomationElementIdentifiers(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Xaml::Automation::AutomationElementIdentifiers>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Xaml::Automation::AutomationElementIdentifiers>::type_name);
        return nullptr;
    }

    static void _dealloc_AutomationElementIdentifiers(py::wrapper::Microsoft::UI::Xaml::Automation::AutomationElementIdentifiers* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AutomationElementIdentifiers_get_AcceleratorKeyProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.AutomationElementIdentifiers", L"AcceleratorKeyProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Automation::AutomationElementIdentifiers::AcceleratorKeyProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AutomationElementIdentifiers_get_AccessKeyProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.AutomationElementIdentifiers", L"AccessKeyProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Automation::AutomationElementIdentifiers::AccessKeyProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AutomationElementIdentifiers_get_AnnotationsProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.AutomationElementIdentifiers", L"AnnotationsProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Automation::AutomationElementIdentifiers::AnnotationsProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AutomationElementIdentifiers_get_AutomationIdProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.AutomationElementIdentifiers", L"AutomationIdProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Automation::AutomationElementIdentifiers::AutomationIdProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AutomationElementIdentifiers_get_BoundingRectangleProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.AutomationElementIdentifiers", L"BoundingRectangleProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Automation::AutomationElementIdentifiers::BoundingRectangleProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AutomationElementIdentifiers_get_ClassNameProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.AutomationElementIdentifiers", L"ClassNameProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Automation::AutomationElementIdentifiers::ClassNameProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AutomationElementIdentifiers_get_ClickablePointProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.AutomationElementIdentifiers", L"ClickablePointProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Automation::AutomationElementIdentifiers::ClickablePointProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AutomationElementIdentifiers_get_ControlTypeProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.AutomationElementIdentifiers", L"ControlTypeProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Automation::AutomationElementIdentifiers::ControlTypeProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AutomationElementIdentifiers_get_ControlledPeersProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.AutomationElementIdentifiers", L"ControlledPeersProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Automation::AutomationElementIdentifiers::ControlledPeersProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AutomationElementIdentifiers_get_CultureProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.AutomationElementIdentifiers", L"CultureProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Automation::AutomationElementIdentifiers::CultureProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AutomationElementIdentifiers_get_DescribedByProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.AutomationElementIdentifiers", L"DescribedByProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Automation::AutomationElementIdentifiers::DescribedByProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AutomationElementIdentifiers_get_FlowsFromProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.AutomationElementIdentifiers", L"FlowsFromProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Automation::AutomationElementIdentifiers::FlowsFromProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AutomationElementIdentifiers_get_FlowsToProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.AutomationElementIdentifiers", L"FlowsToProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Automation::AutomationElementIdentifiers::FlowsToProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AutomationElementIdentifiers_get_FullDescriptionProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.AutomationElementIdentifiers", L"FullDescriptionProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Automation::AutomationElementIdentifiers::FullDescriptionProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AutomationElementIdentifiers_get_HasKeyboardFocusProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.AutomationElementIdentifiers", L"HasKeyboardFocusProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Automation::AutomationElementIdentifiers::HasKeyboardFocusProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AutomationElementIdentifiers_get_HeadingLevelProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.AutomationElementIdentifiers", L"HeadingLevelProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Automation::AutomationElementIdentifiers::HeadingLevelProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AutomationElementIdentifiers_get_HelpTextProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.AutomationElementIdentifiers", L"HelpTextProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Automation::AutomationElementIdentifiers::HelpTextProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AutomationElementIdentifiers_get_IsContentElementProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.AutomationElementIdentifiers", L"IsContentElementProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Automation::AutomationElementIdentifiers::IsContentElementProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AutomationElementIdentifiers_get_IsControlElementProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.AutomationElementIdentifiers", L"IsControlElementProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Automation::AutomationElementIdentifiers::IsControlElementProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AutomationElementIdentifiers_get_IsDataValidForFormProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.AutomationElementIdentifiers", L"IsDataValidForFormProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Automation::AutomationElementIdentifiers::IsDataValidForFormProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AutomationElementIdentifiers_get_IsDialogProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.AutomationElementIdentifiers", L"IsDialogProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Automation::AutomationElementIdentifiers::IsDialogProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AutomationElementIdentifiers_get_IsEnabledProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.AutomationElementIdentifiers", L"IsEnabledProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Automation::AutomationElementIdentifiers::IsEnabledProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AutomationElementIdentifiers_get_IsKeyboardFocusableProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.AutomationElementIdentifiers", L"IsKeyboardFocusableProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Automation::AutomationElementIdentifiers::IsKeyboardFocusableProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AutomationElementIdentifiers_get_IsOffscreenProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.AutomationElementIdentifiers", L"IsOffscreenProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Automation::AutomationElementIdentifiers::IsOffscreenProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AutomationElementIdentifiers_get_IsPasswordProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.AutomationElementIdentifiers", L"IsPasswordProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Automation::AutomationElementIdentifiers::IsPasswordProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AutomationElementIdentifiers_get_IsPeripheralProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.AutomationElementIdentifiers", L"IsPeripheralProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Automation::AutomationElementIdentifiers::IsPeripheralProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AutomationElementIdentifiers_get_IsRequiredForFormProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.AutomationElementIdentifiers", L"IsRequiredForFormProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Automation::AutomationElementIdentifiers::IsRequiredForFormProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AutomationElementIdentifiers_get_ItemStatusProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.AutomationElementIdentifiers", L"ItemStatusProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Automation::AutomationElementIdentifiers::ItemStatusProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AutomationElementIdentifiers_get_ItemTypeProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.AutomationElementIdentifiers", L"ItemTypeProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Automation::AutomationElementIdentifiers::ItemTypeProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AutomationElementIdentifiers_get_LabeledByProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.AutomationElementIdentifiers", L"LabeledByProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Automation::AutomationElementIdentifiers::LabeledByProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AutomationElementIdentifiers_get_LandmarkTypeProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.AutomationElementIdentifiers", L"LandmarkTypeProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Automation::AutomationElementIdentifiers::LandmarkTypeProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AutomationElementIdentifiers_get_LevelProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.AutomationElementIdentifiers", L"LevelProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Automation::AutomationElementIdentifiers::LevelProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AutomationElementIdentifiers_get_LiveSettingProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.AutomationElementIdentifiers", L"LiveSettingProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Automation::AutomationElementIdentifiers::LiveSettingProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AutomationElementIdentifiers_get_LocalizedControlTypeProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.AutomationElementIdentifiers", L"LocalizedControlTypeProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Automation::AutomationElementIdentifiers::LocalizedControlTypeProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AutomationElementIdentifiers_get_LocalizedLandmarkTypeProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.AutomationElementIdentifiers", L"LocalizedLandmarkTypeProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Automation::AutomationElementIdentifiers::LocalizedLandmarkTypeProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AutomationElementIdentifiers_get_NameProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.AutomationElementIdentifiers", L"NameProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Automation::AutomationElementIdentifiers::NameProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AutomationElementIdentifiers_get_OrientationProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.AutomationElementIdentifiers", L"OrientationProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Automation::AutomationElementIdentifiers::OrientationProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AutomationElementIdentifiers_get_PositionInSetProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.AutomationElementIdentifiers", L"PositionInSetProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Automation::AutomationElementIdentifiers::PositionInSetProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AutomationElementIdentifiers_get_SizeOfSetProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.AutomationElementIdentifiers", L"SizeOfSetProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Automation::AutomationElementIdentifiers::SizeOfSetProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AutomationElementIdentifiers(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Automation::AutomationElementIdentifiers>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AutomationElementIdentifiers(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Automation::AutomationElementIdentifiers>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AutomationElementIdentifiers[] = {
        { "_assign_array_", _assign_array_AutomationElementIdentifiers, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AutomationElementIdentifiers), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AutomationElementIdentifiers[] = {
        { }
    };

    static PyType_Slot _type_slots_AutomationElementIdentifiers[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_AutomationElementIdentifiers) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AutomationElementIdentifiers) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AutomationElementIdentifiers) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AutomationElementIdentifiers) },
        { },
    };

    static PyType_Spec type_spec_AutomationElementIdentifiers =
    {
        "winrt._winrt_microsoft_ui_xaml_automation.AutomationElementIdentifiers",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Automation::AutomationElementIdentifiers),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AutomationElementIdentifiers
    };

    static PyGetSetDef getset_AutomationElementIdentifiers_Static[] = {
        { "accelerator_key_property", reinterpret_cast<getter>(AutomationElementIdentifiers_get_AcceleratorKeyProperty), nullptr, nullptr, nullptr },
        { "access_key_property", reinterpret_cast<getter>(AutomationElementIdentifiers_get_AccessKeyProperty), nullptr, nullptr, nullptr },
        { "annotations_property", reinterpret_cast<getter>(AutomationElementIdentifiers_get_AnnotationsProperty), nullptr, nullptr, nullptr },
        { "automation_id_property", reinterpret_cast<getter>(AutomationElementIdentifiers_get_AutomationIdProperty), nullptr, nullptr, nullptr },
        { "bounding_rectangle_property", reinterpret_cast<getter>(AutomationElementIdentifiers_get_BoundingRectangleProperty), nullptr, nullptr, nullptr },
        { "class_name_property", reinterpret_cast<getter>(AutomationElementIdentifiers_get_ClassNameProperty), nullptr, nullptr, nullptr },
        { "clickable_point_property", reinterpret_cast<getter>(AutomationElementIdentifiers_get_ClickablePointProperty), nullptr, nullptr, nullptr },
        { "control_type_property", reinterpret_cast<getter>(AutomationElementIdentifiers_get_ControlTypeProperty), nullptr, nullptr, nullptr },
        { "controlled_peers_property", reinterpret_cast<getter>(AutomationElementIdentifiers_get_ControlledPeersProperty), nullptr, nullptr, nullptr },
        { "culture_property", reinterpret_cast<getter>(AutomationElementIdentifiers_get_CultureProperty), nullptr, nullptr, nullptr },
        { "described_by_property", reinterpret_cast<getter>(AutomationElementIdentifiers_get_DescribedByProperty), nullptr, nullptr, nullptr },
        { "flows_from_property", reinterpret_cast<getter>(AutomationElementIdentifiers_get_FlowsFromProperty), nullptr, nullptr, nullptr },
        { "flows_to_property", reinterpret_cast<getter>(AutomationElementIdentifiers_get_FlowsToProperty), nullptr, nullptr, nullptr },
        { "full_description_property", reinterpret_cast<getter>(AutomationElementIdentifiers_get_FullDescriptionProperty), nullptr, nullptr, nullptr },
        { "has_keyboard_focus_property", reinterpret_cast<getter>(AutomationElementIdentifiers_get_HasKeyboardFocusProperty), nullptr, nullptr, nullptr },
        { "heading_level_property", reinterpret_cast<getter>(AutomationElementIdentifiers_get_HeadingLevelProperty), nullptr, nullptr, nullptr },
        { "help_text_property", reinterpret_cast<getter>(AutomationElementIdentifiers_get_HelpTextProperty), nullptr, nullptr, nullptr },
        { "is_content_element_property", reinterpret_cast<getter>(AutomationElementIdentifiers_get_IsContentElementProperty), nullptr, nullptr, nullptr },
        { "is_control_element_property", reinterpret_cast<getter>(AutomationElementIdentifiers_get_IsControlElementProperty), nullptr, nullptr, nullptr },
        { "is_data_valid_for_form_property", reinterpret_cast<getter>(AutomationElementIdentifiers_get_IsDataValidForFormProperty), nullptr, nullptr, nullptr },
        { "is_dialog_property", reinterpret_cast<getter>(AutomationElementIdentifiers_get_IsDialogProperty), nullptr, nullptr, nullptr },
        { "is_enabled_property", reinterpret_cast<getter>(AutomationElementIdentifiers_get_IsEnabledProperty), nullptr, nullptr, nullptr },
        { "is_keyboard_focusable_property", reinterpret_cast<getter>(AutomationElementIdentifiers_get_IsKeyboardFocusableProperty), nullptr, nullptr, nullptr },
        { "is_offscreen_property", reinterpret_cast<getter>(AutomationElementIdentifiers_get_IsOffscreenProperty), nullptr, nullptr, nullptr },
        { "is_password_property", reinterpret_cast<getter>(AutomationElementIdentifiers_get_IsPasswordProperty), nullptr, nullptr, nullptr },
        { "is_peripheral_property", reinterpret_cast<getter>(AutomationElementIdentifiers_get_IsPeripheralProperty), nullptr, nullptr, nullptr },
        { "is_required_for_form_property", reinterpret_cast<getter>(AutomationElementIdentifiers_get_IsRequiredForFormProperty), nullptr, nullptr, nullptr },
        { "item_status_property", reinterpret_cast<getter>(AutomationElementIdentifiers_get_ItemStatusProperty), nullptr, nullptr, nullptr },
        { "item_type_property", reinterpret_cast<getter>(AutomationElementIdentifiers_get_ItemTypeProperty), nullptr, nullptr, nullptr },
        { "labeled_by_property", reinterpret_cast<getter>(AutomationElementIdentifiers_get_LabeledByProperty), nullptr, nullptr, nullptr },
        { "landmark_type_property", reinterpret_cast<getter>(AutomationElementIdentifiers_get_LandmarkTypeProperty), nullptr, nullptr, nullptr },
        { "level_property", reinterpret_cast<getter>(AutomationElementIdentifiers_get_LevelProperty), nullptr, nullptr, nullptr },
        { "live_setting_property", reinterpret_cast<getter>(AutomationElementIdentifiers_get_LiveSettingProperty), nullptr, nullptr, nullptr },
        { "localized_control_type_property", reinterpret_cast<getter>(AutomationElementIdentifiers_get_LocalizedControlTypeProperty), nullptr, nullptr, nullptr },
        { "localized_landmark_type_property", reinterpret_cast<getter>(AutomationElementIdentifiers_get_LocalizedLandmarkTypeProperty), nullptr, nullptr, nullptr },
        { "name_property", reinterpret_cast<getter>(AutomationElementIdentifiers_get_NameProperty), nullptr, nullptr, nullptr },
        { "orientation_property", reinterpret_cast<getter>(AutomationElementIdentifiers_get_OrientationProperty), nullptr, nullptr, nullptr },
        { "position_in_set_property", reinterpret_cast<getter>(AutomationElementIdentifiers_get_PositionInSetProperty), nullptr, nullptr, nullptr },
        { "size_of_set_property", reinterpret_cast<getter>(AutomationElementIdentifiers_get_SizeOfSetProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_AutomationElementIdentifiers_Static[] = {
        { }
    };

    static PyType_Slot type_slots_AutomationElementIdentifiers_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_AutomationElementIdentifiers_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_AutomationElementIdentifiers_Static) },
        { }
    };

    static PyType_Spec type_spec_AutomationElementIdentifiers_Static =
    {
        "winrt._winrt_microsoft_ui_xaml_automation.AutomationElementIdentifiers_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_AutomationElementIdentifiers_Static
    };

    // ----- AutomationProperties class --------------------

    static PyObject* _new_AutomationProperties(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Xaml::Automation::AutomationProperties>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Xaml::Automation::AutomationProperties>::type_name);
        return nullptr;
    }

    static void _dealloc_AutomationProperties(py::wrapper::Microsoft::UI::Xaml::Automation::AutomationProperties* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AutomationProperties_GetAcceleratorKey(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.AutomationProperties", L"GetAcceleratorKey", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyObject>(args, 0);

                return py::convert(winrt::Microsoft::UI::Xaml::Automation::AutomationProperties::GetAcceleratorKey(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationProperties_GetAccessKey(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.AutomationProperties", L"GetAccessKey", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyObject>(args, 0);

                return py::convert(winrt::Microsoft::UI::Xaml::Automation::AutomationProperties::GetAccessKey(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationProperties_GetAccessibilityView(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.AutomationProperties", L"GetAccessibilityView", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyObject>(args, 0);

                return py::convert(winrt::Microsoft::UI::Xaml::Automation::AutomationProperties::GetAccessibilityView(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationProperties_GetAnnotations(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.AutomationProperties", L"GetAnnotations", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyObject>(args, 0);

                return py::convert(winrt::Microsoft::UI::Xaml::Automation::AutomationProperties::GetAnnotations(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationProperties_GetAutomationControlType(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.AutomationProperties", L"GetAutomationControlType", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::UIElement>(args, 0);

                return py::convert(winrt::Microsoft::UI::Xaml::Automation::AutomationProperties::GetAutomationControlType(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationProperties_GetAutomationId(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.AutomationProperties", L"GetAutomationId", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyObject>(args, 0);

                return py::convert(winrt::Microsoft::UI::Xaml::Automation::AutomationProperties::GetAutomationId(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationProperties_GetControlledPeers(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.AutomationProperties", L"GetControlledPeers", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyObject>(args, 0);

                return py::convert(winrt::Microsoft::UI::Xaml::Automation::AutomationProperties::GetControlledPeers(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationProperties_GetCulture(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.AutomationProperties", L"GetCulture", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyObject>(args, 0);

                return py::convert(winrt::Microsoft::UI::Xaml::Automation::AutomationProperties::GetCulture(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationProperties_GetDescribedBy(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.AutomationProperties", L"GetDescribedBy", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyObject>(args, 0);

                return py::convert(winrt::Microsoft::UI::Xaml::Automation::AutomationProperties::GetDescribedBy(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationProperties_GetFlowsFrom(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.AutomationProperties", L"GetFlowsFrom", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyObject>(args, 0);

                return py::convert(winrt::Microsoft::UI::Xaml::Automation::AutomationProperties::GetFlowsFrom(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationProperties_GetFlowsTo(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.AutomationProperties", L"GetFlowsTo", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyObject>(args, 0);

                return py::convert(winrt::Microsoft::UI::Xaml::Automation::AutomationProperties::GetFlowsTo(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationProperties_GetFullDescription(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.AutomationProperties", L"GetFullDescription", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyObject>(args, 0);

                return py::convert(winrt::Microsoft::UI::Xaml::Automation::AutomationProperties::GetFullDescription(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationProperties_GetHeadingLevel(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.AutomationProperties", L"GetHeadingLevel", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyObject>(args, 0);

                return py::convert(winrt::Microsoft::UI::Xaml::Automation::AutomationProperties::GetHeadingLevel(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationProperties_GetHelpText(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.AutomationProperties", L"GetHelpText", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyObject>(args, 0);

                return py::convert(winrt::Microsoft::UI::Xaml::Automation::AutomationProperties::GetHelpText(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationProperties_GetIsDataValidForForm(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.AutomationProperties", L"GetIsDataValidForForm", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyObject>(args, 0);

                return py::convert(winrt::Microsoft::UI::Xaml::Automation::AutomationProperties::GetIsDataValidForForm(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationProperties_GetIsDialog(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.AutomationProperties", L"GetIsDialog", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyObject>(args, 0);

                return py::convert(winrt::Microsoft::UI::Xaml::Automation::AutomationProperties::GetIsDialog(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationProperties_GetIsPeripheral(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.AutomationProperties", L"GetIsPeripheral", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyObject>(args, 0);

                return py::convert(winrt::Microsoft::UI::Xaml::Automation::AutomationProperties::GetIsPeripheral(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationProperties_GetIsRequiredForForm(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.AutomationProperties", L"GetIsRequiredForForm", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyObject>(args, 0);

                return py::convert(winrt::Microsoft::UI::Xaml::Automation::AutomationProperties::GetIsRequiredForForm(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationProperties_GetItemStatus(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.AutomationProperties", L"GetItemStatus", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyObject>(args, 0);

                return py::convert(winrt::Microsoft::UI::Xaml::Automation::AutomationProperties::GetItemStatus(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationProperties_GetItemType(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.AutomationProperties", L"GetItemType", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyObject>(args, 0);

                return py::convert(winrt::Microsoft::UI::Xaml::Automation::AutomationProperties::GetItemType(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationProperties_GetLabeledBy(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.AutomationProperties", L"GetLabeledBy", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyObject>(args, 0);

                return py::convert(winrt::Microsoft::UI::Xaml::Automation::AutomationProperties::GetLabeledBy(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationProperties_GetLandmarkType(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.AutomationProperties", L"GetLandmarkType", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyObject>(args, 0);

                return py::convert(winrt::Microsoft::UI::Xaml::Automation::AutomationProperties::GetLandmarkType(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationProperties_GetLevel(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.AutomationProperties", L"GetLevel", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyObject>(args, 0);

                return py::convert(winrt::Microsoft::UI::Xaml::Automation::AutomationProperties::GetLevel(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationProperties_GetLiveSetting(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.AutomationProperties", L"GetLiveSetting", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyObject>(args, 0);

                return py::convert(winrt::Microsoft::UI::Xaml::Automation::AutomationProperties::GetLiveSetting(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationProperties_GetLocalizedControlType(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.AutomationProperties", L"GetLocalizedControlType", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyObject>(args, 0);

                return py::convert(winrt::Microsoft::UI::Xaml::Automation::AutomationProperties::GetLocalizedControlType(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationProperties_GetLocalizedLandmarkType(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.AutomationProperties", L"GetLocalizedLandmarkType", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyObject>(args, 0);

                return py::convert(winrt::Microsoft::UI::Xaml::Automation::AutomationProperties::GetLocalizedLandmarkType(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationProperties_GetName(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.AutomationProperties", L"GetName", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyObject>(args, 0);

                return py::convert(winrt::Microsoft::UI::Xaml::Automation::AutomationProperties::GetName(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationProperties_GetPositionInSet(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.AutomationProperties", L"GetPositionInSet", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyObject>(args, 0);

                return py::convert(winrt::Microsoft::UI::Xaml::Automation::AutomationProperties::GetPositionInSet(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationProperties_GetSizeOfSet(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.AutomationProperties", L"GetSizeOfSet", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyObject>(args, 0);

                return py::convert(winrt::Microsoft::UI::Xaml::Automation::AutomationProperties::GetSizeOfSet(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationProperties_SetAcceleratorKey(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.AutomationProperties", L"SetAcceleratorKey", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyObject>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                winrt::Microsoft::UI::Xaml::Automation::AutomationProperties::SetAcceleratorKey(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationProperties_SetAccessKey(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.AutomationProperties", L"SetAccessKey", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyObject>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                winrt::Microsoft::UI::Xaml::Automation::AutomationProperties::SetAccessKey(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationProperties_SetAccessibilityView(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.AutomationProperties", L"SetAccessibilityView", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyObject>(args, 0);
                auto param1 = py::convert_to<winrt::Microsoft::UI::Xaml::Automation::Peers::AccessibilityView>(args, 1);

                winrt::Microsoft::UI::Xaml::Automation::AutomationProperties::SetAccessibilityView(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationProperties_SetAutomationControlType(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.AutomationProperties", L"SetAutomationControlType", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::UIElement>(args, 0);
                auto param1 = py::convert_to<winrt::Microsoft::UI::Xaml::Automation::Peers::AutomationControlType>(args, 1);

                winrt::Microsoft::UI::Xaml::Automation::AutomationProperties::SetAutomationControlType(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationProperties_SetAutomationId(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.AutomationProperties", L"SetAutomationId", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyObject>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                winrt::Microsoft::UI::Xaml::Automation::AutomationProperties::SetAutomationId(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationProperties_SetCulture(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.AutomationProperties", L"SetCulture", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyObject>(args, 0);
                auto param1 = py::convert_to<int32_t>(args, 1);

                winrt::Microsoft::UI::Xaml::Automation::AutomationProperties::SetCulture(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationProperties_SetFullDescription(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.AutomationProperties", L"SetFullDescription", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyObject>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                winrt::Microsoft::UI::Xaml::Automation::AutomationProperties::SetFullDescription(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationProperties_SetHeadingLevel(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.AutomationProperties", L"SetHeadingLevel", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyObject>(args, 0);
                auto param1 = py::convert_to<winrt::Microsoft::UI::Xaml::Automation::Peers::AutomationHeadingLevel>(args, 1);

                winrt::Microsoft::UI::Xaml::Automation::AutomationProperties::SetHeadingLevel(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationProperties_SetHelpText(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.AutomationProperties", L"SetHelpText", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyObject>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                winrt::Microsoft::UI::Xaml::Automation::AutomationProperties::SetHelpText(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationProperties_SetIsDataValidForForm(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.AutomationProperties", L"SetIsDataValidForForm", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyObject>(args, 0);
                auto param1 = py::convert_to<bool>(args, 1);

                winrt::Microsoft::UI::Xaml::Automation::AutomationProperties::SetIsDataValidForForm(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationProperties_SetIsDialog(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.AutomationProperties", L"SetIsDialog", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyObject>(args, 0);
                auto param1 = py::convert_to<bool>(args, 1);

                winrt::Microsoft::UI::Xaml::Automation::AutomationProperties::SetIsDialog(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationProperties_SetIsPeripheral(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.AutomationProperties", L"SetIsPeripheral", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyObject>(args, 0);
                auto param1 = py::convert_to<bool>(args, 1);

                winrt::Microsoft::UI::Xaml::Automation::AutomationProperties::SetIsPeripheral(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationProperties_SetIsRequiredForForm(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.AutomationProperties", L"SetIsRequiredForForm", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyObject>(args, 0);
                auto param1 = py::convert_to<bool>(args, 1);

                winrt::Microsoft::UI::Xaml::Automation::AutomationProperties::SetIsRequiredForForm(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationProperties_SetItemStatus(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.AutomationProperties", L"SetItemStatus", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyObject>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                winrt::Microsoft::UI::Xaml::Automation::AutomationProperties::SetItemStatus(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationProperties_SetItemType(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.AutomationProperties", L"SetItemType", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyObject>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                winrt::Microsoft::UI::Xaml::Automation::AutomationProperties::SetItemType(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationProperties_SetLabeledBy(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.AutomationProperties", L"SetLabeledBy", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyObject>(args, 0);
                auto param1 = py::convert_to<winrt::Microsoft::UI::Xaml::UIElement>(args, 1);

                winrt::Microsoft::UI::Xaml::Automation::AutomationProperties::SetLabeledBy(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationProperties_SetLandmarkType(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.AutomationProperties", L"SetLandmarkType", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyObject>(args, 0);
                auto param1 = py::convert_to<winrt::Microsoft::UI::Xaml::Automation::Peers::AutomationLandmarkType>(args, 1);

                winrt::Microsoft::UI::Xaml::Automation::AutomationProperties::SetLandmarkType(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationProperties_SetLevel(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.AutomationProperties", L"SetLevel", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyObject>(args, 0);
                auto param1 = py::convert_to<int32_t>(args, 1);

                winrt::Microsoft::UI::Xaml::Automation::AutomationProperties::SetLevel(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationProperties_SetLiveSetting(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.AutomationProperties", L"SetLiveSetting", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyObject>(args, 0);
                auto param1 = py::convert_to<winrt::Microsoft::UI::Xaml::Automation::Peers::AutomationLiveSetting>(args, 1);

                winrt::Microsoft::UI::Xaml::Automation::AutomationProperties::SetLiveSetting(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationProperties_SetLocalizedControlType(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.AutomationProperties", L"SetLocalizedControlType", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyObject>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                winrt::Microsoft::UI::Xaml::Automation::AutomationProperties::SetLocalizedControlType(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationProperties_SetLocalizedLandmarkType(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.AutomationProperties", L"SetLocalizedLandmarkType", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyObject>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                winrt::Microsoft::UI::Xaml::Automation::AutomationProperties::SetLocalizedLandmarkType(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationProperties_SetName(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.AutomationProperties", L"SetName", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyObject>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                winrt::Microsoft::UI::Xaml::Automation::AutomationProperties::SetName(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationProperties_SetPositionInSet(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.AutomationProperties", L"SetPositionInSet", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyObject>(args, 0);
                auto param1 = py::convert_to<int32_t>(args, 1);

                winrt::Microsoft::UI::Xaml::Automation::AutomationProperties::SetPositionInSet(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationProperties_SetSizeOfSet(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.AutomationProperties", L"SetSizeOfSet", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyObject>(args, 0);
                auto param1 = py::convert_to<int32_t>(args, 1);

                winrt::Microsoft::UI::Xaml::Automation::AutomationProperties::SetSizeOfSet(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationProperties_get_AcceleratorKeyProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.AutomationProperties", L"AcceleratorKeyProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Automation::AutomationProperties::AcceleratorKeyProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AutomationProperties_get_AccessKeyProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.AutomationProperties", L"AccessKeyProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Automation::AutomationProperties::AccessKeyProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AutomationProperties_get_AccessibilityViewProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.AutomationProperties", L"AccessibilityViewProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Automation::AutomationProperties::AccessibilityViewProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AutomationProperties_get_AnnotationsProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.AutomationProperties", L"AnnotationsProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Automation::AutomationProperties::AnnotationsProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AutomationProperties_get_AutomationIdProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.AutomationProperties", L"AutomationIdProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Automation::AutomationProperties::AutomationIdProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AutomationProperties_get_ControlledPeersProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.AutomationProperties", L"ControlledPeersProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Automation::AutomationProperties::ControlledPeersProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AutomationProperties_get_CultureProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.AutomationProperties", L"CultureProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Automation::AutomationProperties::CultureProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AutomationProperties_get_DescribedByProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.AutomationProperties", L"DescribedByProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Automation::AutomationProperties::DescribedByProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AutomationProperties_get_FlowsFromProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.AutomationProperties", L"FlowsFromProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Automation::AutomationProperties::FlowsFromProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AutomationProperties_get_FlowsToProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.AutomationProperties", L"FlowsToProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Automation::AutomationProperties::FlowsToProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AutomationProperties_get_FullDescriptionProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.AutomationProperties", L"FullDescriptionProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Automation::AutomationProperties::FullDescriptionProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AutomationProperties_get_HeadingLevelProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.AutomationProperties", L"HeadingLevelProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Automation::AutomationProperties::HeadingLevelProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AutomationProperties_get_HelpTextProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.AutomationProperties", L"HelpTextProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Automation::AutomationProperties::HelpTextProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AutomationProperties_get_IsDataValidForFormProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.AutomationProperties", L"IsDataValidForFormProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Automation::AutomationProperties::IsDataValidForFormProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AutomationProperties_get_IsDialogProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.AutomationProperties", L"IsDialogProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Automation::AutomationProperties::IsDialogProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AutomationProperties_get_IsPeripheralProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.AutomationProperties", L"IsPeripheralProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Automation::AutomationProperties::IsPeripheralProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AutomationProperties_get_IsRequiredForFormProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.AutomationProperties", L"IsRequiredForFormProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Automation::AutomationProperties::IsRequiredForFormProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AutomationProperties_get_ItemStatusProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.AutomationProperties", L"ItemStatusProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Automation::AutomationProperties::ItemStatusProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AutomationProperties_get_ItemTypeProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.AutomationProperties", L"ItemTypeProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Automation::AutomationProperties::ItemTypeProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AutomationProperties_get_LabeledByProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.AutomationProperties", L"LabeledByProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Automation::AutomationProperties::LabeledByProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AutomationProperties_get_LandmarkTypeProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.AutomationProperties", L"LandmarkTypeProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Automation::AutomationProperties::LandmarkTypeProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AutomationProperties_get_LevelProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.AutomationProperties", L"LevelProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Automation::AutomationProperties::LevelProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AutomationProperties_get_LiveSettingProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.AutomationProperties", L"LiveSettingProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Automation::AutomationProperties::LiveSettingProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AutomationProperties_get_LocalizedControlTypeProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.AutomationProperties", L"LocalizedControlTypeProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Automation::AutomationProperties::LocalizedControlTypeProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AutomationProperties_get_LocalizedLandmarkTypeProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.AutomationProperties", L"LocalizedLandmarkTypeProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Automation::AutomationProperties::LocalizedLandmarkTypeProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AutomationProperties_get_NameProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.AutomationProperties", L"NameProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Automation::AutomationProperties::NameProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AutomationProperties_get_PositionInSetProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.AutomationProperties", L"PositionInSetProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Automation::AutomationProperties::PositionInSetProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AutomationProperties_get_SizeOfSetProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.AutomationProperties", L"SizeOfSetProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Automation::AutomationProperties::SizeOfSetProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AutomationProperties_get_AutomationControlTypeProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.AutomationProperties", L"AutomationControlTypeProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Automation::AutomationProperties::AutomationControlTypeProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AutomationProperties(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Automation::AutomationProperties>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AutomationProperties(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Automation::AutomationProperties>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AutomationProperties[] = {
        { "_assign_array_", _assign_array_AutomationProperties, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AutomationProperties), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AutomationProperties[] = {
        { }
    };

    static PyType_Slot _type_slots_AutomationProperties[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_AutomationProperties) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AutomationProperties) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AutomationProperties) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AutomationProperties) },
        { },
    };

    static PyType_Spec type_spec_AutomationProperties =
    {
        "winrt._winrt_microsoft_ui_xaml_automation.AutomationProperties",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Automation::AutomationProperties),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AutomationProperties
    };

    static PyGetSetDef getset_AutomationProperties_Static[] = {
        { "accelerator_key_property", reinterpret_cast<getter>(AutomationProperties_get_AcceleratorKeyProperty), nullptr, nullptr, nullptr },
        { "access_key_property", reinterpret_cast<getter>(AutomationProperties_get_AccessKeyProperty), nullptr, nullptr, nullptr },
        { "accessibility_view_property", reinterpret_cast<getter>(AutomationProperties_get_AccessibilityViewProperty), nullptr, nullptr, nullptr },
        { "annotations_property", reinterpret_cast<getter>(AutomationProperties_get_AnnotationsProperty), nullptr, nullptr, nullptr },
        { "automation_id_property", reinterpret_cast<getter>(AutomationProperties_get_AutomationIdProperty), nullptr, nullptr, nullptr },
        { "controlled_peers_property", reinterpret_cast<getter>(AutomationProperties_get_ControlledPeersProperty), nullptr, nullptr, nullptr },
        { "culture_property", reinterpret_cast<getter>(AutomationProperties_get_CultureProperty), nullptr, nullptr, nullptr },
        { "described_by_property", reinterpret_cast<getter>(AutomationProperties_get_DescribedByProperty), nullptr, nullptr, nullptr },
        { "flows_from_property", reinterpret_cast<getter>(AutomationProperties_get_FlowsFromProperty), nullptr, nullptr, nullptr },
        { "flows_to_property", reinterpret_cast<getter>(AutomationProperties_get_FlowsToProperty), nullptr, nullptr, nullptr },
        { "full_description_property", reinterpret_cast<getter>(AutomationProperties_get_FullDescriptionProperty), nullptr, nullptr, nullptr },
        { "heading_level_property", reinterpret_cast<getter>(AutomationProperties_get_HeadingLevelProperty), nullptr, nullptr, nullptr },
        { "help_text_property", reinterpret_cast<getter>(AutomationProperties_get_HelpTextProperty), nullptr, nullptr, nullptr },
        { "is_data_valid_for_form_property", reinterpret_cast<getter>(AutomationProperties_get_IsDataValidForFormProperty), nullptr, nullptr, nullptr },
        { "is_dialog_property", reinterpret_cast<getter>(AutomationProperties_get_IsDialogProperty), nullptr, nullptr, nullptr },
        { "is_peripheral_property", reinterpret_cast<getter>(AutomationProperties_get_IsPeripheralProperty), nullptr, nullptr, nullptr },
        { "is_required_for_form_property", reinterpret_cast<getter>(AutomationProperties_get_IsRequiredForFormProperty), nullptr, nullptr, nullptr },
        { "item_status_property", reinterpret_cast<getter>(AutomationProperties_get_ItemStatusProperty), nullptr, nullptr, nullptr },
        { "item_type_property", reinterpret_cast<getter>(AutomationProperties_get_ItemTypeProperty), nullptr, nullptr, nullptr },
        { "labeled_by_property", reinterpret_cast<getter>(AutomationProperties_get_LabeledByProperty), nullptr, nullptr, nullptr },
        { "landmark_type_property", reinterpret_cast<getter>(AutomationProperties_get_LandmarkTypeProperty), nullptr, nullptr, nullptr },
        { "level_property", reinterpret_cast<getter>(AutomationProperties_get_LevelProperty), nullptr, nullptr, nullptr },
        { "live_setting_property", reinterpret_cast<getter>(AutomationProperties_get_LiveSettingProperty), nullptr, nullptr, nullptr },
        { "localized_control_type_property", reinterpret_cast<getter>(AutomationProperties_get_LocalizedControlTypeProperty), nullptr, nullptr, nullptr },
        { "localized_landmark_type_property", reinterpret_cast<getter>(AutomationProperties_get_LocalizedLandmarkTypeProperty), nullptr, nullptr, nullptr },
        { "name_property", reinterpret_cast<getter>(AutomationProperties_get_NameProperty), nullptr, nullptr, nullptr },
        { "position_in_set_property", reinterpret_cast<getter>(AutomationProperties_get_PositionInSetProperty), nullptr, nullptr, nullptr },
        { "size_of_set_property", reinterpret_cast<getter>(AutomationProperties_get_SizeOfSetProperty), nullptr, nullptr, nullptr },
        { "automation_control_type_property", reinterpret_cast<getter>(AutomationProperties_get_AutomationControlTypeProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_AutomationProperties_Static[] = {
        { "get_accelerator_key", reinterpret_cast<PyCFunction>(AutomationProperties_GetAcceleratorKey), METH_VARARGS, nullptr },
        { "get_access_key", reinterpret_cast<PyCFunction>(AutomationProperties_GetAccessKey), METH_VARARGS, nullptr },
        { "get_accessibility_view", reinterpret_cast<PyCFunction>(AutomationProperties_GetAccessibilityView), METH_VARARGS, nullptr },
        { "get_annotations", reinterpret_cast<PyCFunction>(AutomationProperties_GetAnnotations), METH_VARARGS, nullptr },
        { "get_automation_control_type", reinterpret_cast<PyCFunction>(AutomationProperties_GetAutomationControlType), METH_VARARGS, nullptr },
        { "get_automation_id", reinterpret_cast<PyCFunction>(AutomationProperties_GetAutomationId), METH_VARARGS, nullptr },
        { "get_controlled_peers", reinterpret_cast<PyCFunction>(AutomationProperties_GetControlledPeers), METH_VARARGS, nullptr },
        { "get_culture", reinterpret_cast<PyCFunction>(AutomationProperties_GetCulture), METH_VARARGS, nullptr },
        { "get_described_by", reinterpret_cast<PyCFunction>(AutomationProperties_GetDescribedBy), METH_VARARGS, nullptr },
        { "get_flows_from", reinterpret_cast<PyCFunction>(AutomationProperties_GetFlowsFrom), METH_VARARGS, nullptr },
        { "get_flows_to", reinterpret_cast<PyCFunction>(AutomationProperties_GetFlowsTo), METH_VARARGS, nullptr },
        { "get_full_description", reinterpret_cast<PyCFunction>(AutomationProperties_GetFullDescription), METH_VARARGS, nullptr },
        { "get_heading_level", reinterpret_cast<PyCFunction>(AutomationProperties_GetHeadingLevel), METH_VARARGS, nullptr },
        { "get_help_text", reinterpret_cast<PyCFunction>(AutomationProperties_GetHelpText), METH_VARARGS, nullptr },
        { "get_is_data_valid_for_form", reinterpret_cast<PyCFunction>(AutomationProperties_GetIsDataValidForForm), METH_VARARGS, nullptr },
        { "get_is_dialog", reinterpret_cast<PyCFunction>(AutomationProperties_GetIsDialog), METH_VARARGS, nullptr },
        { "get_is_peripheral", reinterpret_cast<PyCFunction>(AutomationProperties_GetIsPeripheral), METH_VARARGS, nullptr },
        { "get_is_required_for_form", reinterpret_cast<PyCFunction>(AutomationProperties_GetIsRequiredForForm), METH_VARARGS, nullptr },
        { "get_item_status", reinterpret_cast<PyCFunction>(AutomationProperties_GetItemStatus), METH_VARARGS, nullptr },
        { "get_item_type", reinterpret_cast<PyCFunction>(AutomationProperties_GetItemType), METH_VARARGS, nullptr },
        { "get_labeled_by", reinterpret_cast<PyCFunction>(AutomationProperties_GetLabeledBy), METH_VARARGS, nullptr },
        { "get_landmark_type", reinterpret_cast<PyCFunction>(AutomationProperties_GetLandmarkType), METH_VARARGS, nullptr },
        { "get_level", reinterpret_cast<PyCFunction>(AutomationProperties_GetLevel), METH_VARARGS, nullptr },
        { "get_live_setting", reinterpret_cast<PyCFunction>(AutomationProperties_GetLiveSetting), METH_VARARGS, nullptr },
        { "get_localized_control_type", reinterpret_cast<PyCFunction>(AutomationProperties_GetLocalizedControlType), METH_VARARGS, nullptr },
        { "get_localized_landmark_type", reinterpret_cast<PyCFunction>(AutomationProperties_GetLocalizedLandmarkType), METH_VARARGS, nullptr },
        { "get_name", reinterpret_cast<PyCFunction>(AutomationProperties_GetName), METH_VARARGS, nullptr },
        { "get_position_in_set", reinterpret_cast<PyCFunction>(AutomationProperties_GetPositionInSet), METH_VARARGS, nullptr },
        { "get_size_of_set", reinterpret_cast<PyCFunction>(AutomationProperties_GetSizeOfSet), METH_VARARGS, nullptr },
        { "set_accelerator_key", reinterpret_cast<PyCFunction>(AutomationProperties_SetAcceleratorKey), METH_VARARGS, nullptr },
        { "set_access_key", reinterpret_cast<PyCFunction>(AutomationProperties_SetAccessKey), METH_VARARGS, nullptr },
        { "set_accessibility_view", reinterpret_cast<PyCFunction>(AutomationProperties_SetAccessibilityView), METH_VARARGS, nullptr },
        { "set_automation_control_type", reinterpret_cast<PyCFunction>(AutomationProperties_SetAutomationControlType), METH_VARARGS, nullptr },
        { "set_automation_id", reinterpret_cast<PyCFunction>(AutomationProperties_SetAutomationId), METH_VARARGS, nullptr },
        { "set_culture", reinterpret_cast<PyCFunction>(AutomationProperties_SetCulture), METH_VARARGS, nullptr },
        { "set_full_description", reinterpret_cast<PyCFunction>(AutomationProperties_SetFullDescription), METH_VARARGS, nullptr },
        { "set_heading_level", reinterpret_cast<PyCFunction>(AutomationProperties_SetHeadingLevel), METH_VARARGS, nullptr },
        { "set_help_text", reinterpret_cast<PyCFunction>(AutomationProperties_SetHelpText), METH_VARARGS, nullptr },
        { "set_is_data_valid_for_form", reinterpret_cast<PyCFunction>(AutomationProperties_SetIsDataValidForForm), METH_VARARGS, nullptr },
        { "set_is_dialog", reinterpret_cast<PyCFunction>(AutomationProperties_SetIsDialog), METH_VARARGS, nullptr },
        { "set_is_peripheral", reinterpret_cast<PyCFunction>(AutomationProperties_SetIsPeripheral), METH_VARARGS, nullptr },
        { "set_is_required_for_form", reinterpret_cast<PyCFunction>(AutomationProperties_SetIsRequiredForForm), METH_VARARGS, nullptr },
        { "set_item_status", reinterpret_cast<PyCFunction>(AutomationProperties_SetItemStatus), METH_VARARGS, nullptr },
        { "set_item_type", reinterpret_cast<PyCFunction>(AutomationProperties_SetItemType), METH_VARARGS, nullptr },
        { "set_labeled_by", reinterpret_cast<PyCFunction>(AutomationProperties_SetLabeledBy), METH_VARARGS, nullptr },
        { "set_landmark_type", reinterpret_cast<PyCFunction>(AutomationProperties_SetLandmarkType), METH_VARARGS, nullptr },
        { "set_level", reinterpret_cast<PyCFunction>(AutomationProperties_SetLevel), METH_VARARGS, nullptr },
        { "set_live_setting", reinterpret_cast<PyCFunction>(AutomationProperties_SetLiveSetting), METH_VARARGS, nullptr },
        { "set_localized_control_type", reinterpret_cast<PyCFunction>(AutomationProperties_SetLocalizedControlType), METH_VARARGS, nullptr },
        { "set_localized_landmark_type", reinterpret_cast<PyCFunction>(AutomationProperties_SetLocalizedLandmarkType), METH_VARARGS, nullptr },
        { "set_name", reinterpret_cast<PyCFunction>(AutomationProperties_SetName), METH_VARARGS, nullptr },
        { "set_position_in_set", reinterpret_cast<PyCFunction>(AutomationProperties_SetPositionInSet), METH_VARARGS, nullptr },
        { "set_size_of_set", reinterpret_cast<PyCFunction>(AutomationProperties_SetSizeOfSet), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_AutomationProperties_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_AutomationProperties_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_AutomationProperties_Static) },
        { }
    };

    static PyType_Spec type_spec_AutomationProperties_Static =
    {
        "winrt._winrt_microsoft_ui_xaml_automation.AutomationProperties_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_AutomationProperties_Static
    };

    // ----- AutomationProperty class --------------------

    static PyObject* _new_AutomationProperty(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Xaml::Automation::AutomationProperty>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Xaml::Automation::AutomationProperty>::type_name);
        return nullptr;
    }

    static void _dealloc_AutomationProperty(py::wrapper::Microsoft::UI::Xaml::Automation::AutomationProperty* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_AutomationProperty(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Automation::AutomationProperty>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AutomationProperty(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Automation::AutomationProperty>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AutomationProperty[] = {
        { "_assign_array_", _assign_array_AutomationProperty, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AutomationProperty), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AutomationProperty[] = {
        { }
    };

    static PyType_Slot _type_slots_AutomationProperty[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_AutomationProperty) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AutomationProperty) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AutomationProperty) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AutomationProperty) },
        { },
    };

    static PyType_Spec type_spec_AutomationProperty =
    {
        "winrt._winrt_microsoft_ui_xaml_automation.AutomationProperty",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Automation::AutomationProperty),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AutomationProperty
    };

    // ----- DockPatternIdentifiers class --------------------

    static PyObject* _new_DockPatternIdentifiers(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Xaml::Automation::DockPatternIdentifiers>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Xaml::Automation::DockPatternIdentifiers>::type_name);
        return nullptr;
    }

    static void _dealloc_DockPatternIdentifiers(py::wrapper::Microsoft::UI::Xaml::Automation::DockPatternIdentifiers* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* DockPatternIdentifiers_get_DockPositionProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.DockPatternIdentifiers", L"DockPositionProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Automation::DockPatternIdentifiers::DockPositionProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_DockPatternIdentifiers(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Automation::DockPatternIdentifiers>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_DockPatternIdentifiers(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Automation::DockPatternIdentifiers>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DockPatternIdentifiers[] = {
        { "_assign_array_", _assign_array_DockPatternIdentifiers, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_DockPatternIdentifiers), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_DockPatternIdentifiers[] = {
        { }
    };

    static PyType_Slot _type_slots_DockPatternIdentifiers[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_DockPatternIdentifiers) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_DockPatternIdentifiers) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_DockPatternIdentifiers) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_DockPatternIdentifiers) },
        { },
    };

    static PyType_Spec type_spec_DockPatternIdentifiers =
    {
        "winrt._winrt_microsoft_ui_xaml_automation.DockPatternIdentifiers",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Automation::DockPatternIdentifiers),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DockPatternIdentifiers
    };

    static PyGetSetDef getset_DockPatternIdentifiers_Static[] = {
        { "dock_position_property", reinterpret_cast<getter>(DockPatternIdentifiers_get_DockPositionProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_DockPatternIdentifiers_Static[] = {
        { }
    };

    static PyType_Slot type_slots_DockPatternIdentifiers_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_DockPatternIdentifiers_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_DockPatternIdentifiers_Static) },
        { }
    };

    static PyType_Spec type_spec_DockPatternIdentifiers_Static =
    {
        "winrt._winrt_microsoft_ui_xaml_automation.DockPatternIdentifiers_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_DockPatternIdentifiers_Static
    };

    // ----- DragPatternIdentifiers class --------------------

    static PyObject* _new_DragPatternIdentifiers(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Xaml::Automation::DragPatternIdentifiers>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Xaml::Automation::DragPatternIdentifiers>::type_name);
        return nullptr;
    }

    static void _dealloc_DragPatternIdentifiers(py::wrapper::Microsoft::UI::Xaml::Automation::DragPatternIdentifiers* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* DragPatternIdentifiers_get_DropEffectProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.DragPatternIdentifiers", L"DropEffectProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Automation::DragPatternIdentifiers::DropEffectProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DragPatternIdentifiers_get_DropEffectsProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.DragPatternIdentifiers", L"DropEffectsProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Automation::DragPatternIdentifiers::DropEffectsProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DragPatternIdentifiers_get_GrabbedItemsProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.DragPatternIdentifiers", L"GrabbedItemsProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Automation::DragPatternIdentifiers::GrabbedItemsProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DragPatternIdentifiers_get_IsGrabbedProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.DragPatternIdentifiers", L"IsGrabbedProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Automation::DragPatternIdentifiers::IsGrabbedProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_DragPatternIdentifiers(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Automation::DragPatternIdentifiers>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_DragPatternIdentifiers(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Automation::DragPatternIdentifiers>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DragPatternIdentifiers[] = {
        { "_assign_array_", _assign_array_DragPatternIdentifiers, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_DragPatternIdentifiers), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_DragPatternIdentifiers[] = {
        { }
    };

    static PyType_Slot _type_slots_DragPatternIdentifiers[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_DragPatternIdentifiers) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_DragPatternIdentifiers) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_DragPatternIdentifiers) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_DragPatternIdentifiers) },
        { },
    };

    static PyType_Spec type_spec_DragPatternIdentifiers =
    {
        "winrt._winrt_microsoft_ui_xaml_automation.DragPatternIdentifiers",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Automation::DragPatternIdentifiers),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DragPatternIdentifiers
    };

    static PyGetSetDef getset_DragPatternIdentifiers_Static[] = {
        { "drop_effect_property", reinterpret_cast<getter>(DragPatternIdentifiers_get_DropEffectProperty), nullptr, nullptr, nullptr },
        { "drop_effects_property", reinterpret_cast<getter>(DragPatternIdentifiers_get_DropEffectsProperty), nullptr, nullptr, nullptr },
        { "grabbed_items_property", reinterpret_cast<getter>(DragPatternIdentifiers_get_GrabbedItemsProperty), nullptr, nullptr, nullptr },
        { "is_grabbed_property", reinterpret_cast<getter>(DragPatternIdentifiers_get_IsGrabbedProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_DragPatternIdentifiers_Static[] = {
        { }
    };

    static PyType_Slot type_slots_DragPatternIdentifiers_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_DragPatternIdentifiers_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_DragPatternIdentifiers_Static) },
        { }
    };

    static PyType_Spec type_spec_DragPatternIdentifiers_Static =
    {
        "winrt._winrt_microsoft_ui_xaml_automation.DragPatternIdentifiers_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_DragPatternIdentifiers_Static
    };

    // ----- DropTargetPatternIdentifiers class --------------------

    static PyObject* _new_DropTargetPatternIdentifiers(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Xaml::Automation::DropTargetPatternIdentifiers>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Xaml::Automation::DropTargetPatternIdentifiers>::type_name);
        return nullptr;
    }

    static void _dealloc_DropTargetPatternIdentifiers(py::wrapper::Microsoft::UI::Xaml::Automation::DropTargetPatternIdentifiers* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* DropTargetPatternIdentifiers_get_DropTargetEffectProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.DropTargetPatternIdentifiers", L"DropTargetEffectProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Automation::DropTargetPatternIdentifiers::DropTargetEffectProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DropTargetPatternIdentifiers_get_DropTargetEffectsProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.DropTargetPatternIdentifiers", L"DropTargetEffectsProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Automation::DropTargetPatternIdentifiers::DropTargetEffectsProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_DropTargetPatternIdentifiers(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Automation::DropTargetPatternIdentifiers>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_DropTargetPatternIdentifiers(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Automation::DropTargetPatternIdentifiers>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DropTargetPatternIdentifiers[] = {
        { "_assign_array_", _assign_array_DropTargetPatternIdentifiers, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_DropTargetPatternIdentifiers), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_DropTargetPatternIdentifiers[] = {
        { }
    };

    static PyType_Slot _type_slots_DropTargetPatternIdentifiers[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_DropTargetPatternIdentifiers) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_DropTargetPatternIdentifiers) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_DropTargetPatternIdentifiers) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_DropTargetPatternIdentifiers) },
        { },
    };

    static PyType_Spec type_spec_DropTargetPatternIdentifiers =
    {
        "winrt._winrt_microsoft_ui_xaml_automation.DropTargetPatternIdentifiers",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Automation::DropTargetPatternIdentifiers),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DropTargetPatternIdentifiers
    };

    static PyGetSetDef getset_DropTargetPatternIdentifiers_Static[] = {
        { "drop_target_effect_property", reinterpret_cast<getter>(DropTargetPatternIdentifiers_get_DropTargetEffectProperty), nullptr, nullptr, nullptr },
        { "drop_target_effects_property", reinterpret_cast<getter>(DropTargetPatternIdentifiers_get_DropTargetEffectsProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_DropTargetPatternIdentifiers_Static[] = {
        { }
    };

    static PyType_Slot type_slots_DropTargetPatternIdentifiers_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_DropTargetPatternIdentifiers_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_DropTargetPatternIdentifiers_Static) },
        { }
    };

    static PyType_Spec type_spec_DropTargetPatternIdentifiers_Static =
    {
        "winrt._winrt_microsoft_ui_xaml_automation.DropTargetPatternIdentifiers_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_DropTargetPatternIdentifiers_Static
    };

    // ----- ExpandCollapsePatternIdentifiers class --------------------

    static PyObject* _new_ExpandCollapsePatternIdentifiers(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Xaml::Automation::ExpandCollapsePatternIdentifiers>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Xaml::Automation::ExpandCollapsePatternIdentifiers>::type_name);
        return nullptr;
    }

    static void _dealloc_ExpandCollapsePatternIdentifiers(py::wrapper::Microsoft::UI::Xaml::Automation::ExpandCollapsePatternIdentifiers* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ExpandCollapsePatternIdentifiers_get_ExpandCollapseStateProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.ExpandCollapsePatternIdentifiers", L"ExpandCollapseStateProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Automation::ExpandCollapsePatternIdentifiers::ExpandCollapseStateProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ExpandCollapsePatternIdentifiers(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Automation::ExpandCollapsePatternIdentifiers>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ExpandCollapsePatternIdentifiers(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Automation::ExpandCollapsePatternIdentifiers>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ExpandCollapsePatternIdentifiers[] = {
        { "_assign_array_", _assign_array_ExpandCollapsePatternIdentifiers, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ExpandCollapsePatternIdentifiers), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ExpandCollapsePatternIdentifiers[] = {
        { }
    };

    static PyType_Slot _type_slots_ExpandCollapsePatternIdentifiers[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ExpandCollapsePatternIdentifiers) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ExpandCollapsePatternIdentifiers) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ExpandCollapsePatternIdentifiers) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ExpandCollapsePatternIdentifiers) },
        { },
    };

    static PyType_Spec type_spec_ExpandCollapsePatternIdentifiers =
    {
        "winrt._winrt_microsoft_ui_xaml_automation.ExpandCollapsePatternIdentifiers",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Automation::ExpandCollapsePatternIdentifiers),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ExpandCollapsePatternIdentifiers
    };

    static PyGetSetDef getset_ExpandCollapsePatternIdentifiers_Static[] = {
        { "expand_collapse_state_property", reinterpret_cast<getter>(ExpandCollapsePatternIdentifiers_get_ExpandCollapseStateProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_ExpandCollapsePatternIdentifiers_Static[] = {
        { }
    };

    static PyType_Slot type_slots_ExpandCollapsePatternIdentifiers_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_ExpandCollapsePatternIdentifiers_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_ExpandCollapsePatternIdentifiers_Static) },
        { }
    };

    static PyType_Spec type_spec_ExpandCollapsePatternIdentifiers_Static =
    {
        "winrt._winrt_microsoft_ui_xaml_automation.ExpandCollapsePatternIdentifiers_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_ExpandCollapsePatternIdentifiers_Static
    };

    // ----- GridItemPatternIdentifiers class --------------------

    static PyObject* _new_GridItemPatternIdentifiers(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Xaml::Automation::GridItemPatternIdentifiers>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Xaml::Automation::GridItemPatternIdentifiers>::type_name);
        return nullptr;
    }

    static void _dealloc_GridItemPatternIdentifiers(py::wrapper::Microsoft::UI::Xaml::Automation::GridItemPatternIdentifiers* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* GridItemPatternIdentifiers_get_ColumnProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.GridItemPatternIdentifiers", L"ColumnProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Automation::GridItemPatternIdentifiers::ColumnProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GridItemPatternIdentifiers_get_ColumnSpanProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.GridItemPatternIdentifiers", L"ColumnSpanProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Automation::GridItemPatternIdentifiers::ColumnSpanProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GridItemPatternIdentifiers_get_ContainingGridProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.GridItemPatternIdentifiers", L"ContainingGridProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Automation::GridItemPatternIdentifiers::ContainingGridProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GridItemPatternIdentifiers_get_RowProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.GridItemPatternIdentifiers", L"RowProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Automation::GridItemPatternIdentifiers::RowProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GridItemPatternIdentifiers_get_RowSpanProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.GridItemPatternIdentifiers", L"RowSpanProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Automation::GridItemPatternIdentifiers::RowSpanProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_GridItemPatternIdentifiers(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Automation::GridItemPatternIdentifiers>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_GridItemPatternIdentifiers(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Automation::GridItemPatternIdentifiers>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_GridItemPatternIdentifiers[] = {
        { "_assign_array_", _assign_array_GridItemPatternIdentifiers, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_GridItemPatternIdentifiers), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_GridItemPatternIdentifiers[] = {
        { }
    };

    static PyType_Slot _type_slots_GridItemPatternIdentifiers[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_GridItemPatternIdentifiers) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_GridItemPatternIdentifiers) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_GridItemPatternIdentifiers) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_GridItemPatternIdentifiers) },
        { },
    };

    static PyType_Spec type_spec_GridItemPatternIdentifiers =
    {
        "winrt._winrt_microsoft_ui_xaml_automation.GridItemPatternIdentifiers",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Automation::GridItemPatternIdentifiers),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_GridItemPatternIdentifiers
    };

    static PyGetSetDef getset_GridItemPatternIdentifiers_Static[] = {
        { "column_property", reinterpret_cast<getter>(GridItemPatternIdentifiers_get_ColumnProperty), nullptr, nullptr, nullptr },
        { "column_span_property", reinterpret_cast<getter>(GridItemPatternIdentifiers_get_ColumnSpanProperty), nullptr, nullptr, nullptr },
        { "containing_grid_property", reinterpret_cast<getter>(GridItemPatternIdentifiers_get_ContainingGridProperty), nullptr, nullptr, nullptr },
        { "row_property", reinterpret_cast<getter>(GridItemPatternIdentifiers_get_RowProperty), nullptr, nullptr, nullptr },
        { "row_span_property", reinterpret_cast<getter>(GridItemPatternIdentifiers_get_RowSpanProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_GridItemPatternIdentifiers_Static[] = {
        { }
    };

    static PyType_Slot type_slots_GridItemPatternIdentifiers_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_GridItemPatternIdentifiers_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_GridItemPatternIdentifiers_Static) },
        { }
    };

    static PyType_Spec type_spec_GridItemPatternIdentifiers_Static =
    {
        "winrt._winrt_microsoft_ui_xaml_automation.GridItemPatternIdentifiers_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_GridItemPatternIdentifiers_Static
    };

    // ----- GridPatternIdentifiers class --------------------

    static PyObject* _new_GridPatternIdentifiers(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Xaml::Automation::GridPatternIdentifiers>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Xaml::Automation::GridPatternIdentifiers>::type_name);
        return nullptr;
    }

    static void _dealloc_GridPatternIdentifiers(py::wrapper::Microsoft::UI::Xaml::Automation::GridPatternIdentifiers* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* GridPatternIdentifiers_get_ColumnCountProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.GridPatternIdentifiers", L"ColumnCountProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Automation::GridPatternIdentifiers::ColumnCountProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GridPatternIdentifiers_get_RowCountProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.GridPatternIdentifiers", L"RowCountProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Automation::GridPatternIdentifiers::RowCountProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_GridPatternIdentifiers(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Automation::GridPatternIdentifiers>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_GridPatternIdentifiers(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Automation::GridPatternIdentifiers>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_GridPatternIdentifiers[] = {
        { "_assign_array_", _assign_array_GridPatternIdentifiers, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_GridPatternIdentifiers), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_GridPatternIdentifiers[] = {
        { }
    };

    static PyType_Slot _type_slots_GridPatternIdentifiers[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_GridPatternIdentifiers) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_GridPatternIdentifiers) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_GridPatternIdentifiers) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_GridPatternIdentifiers) },
        { },
    };

    static PyType_Spec type_spec_GridPatternIdentifiers =
    {
        "winrt._winrt_microsoft_ui_xaml_automation.GridPatternIdentifiers",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Automation::GridPatternIdentifiers),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_GridPatternIdentifiers
    };

    static PyGetSetDef getset_GridPatternIdentifiers_Static[] = {
        { "column_count_property", reinterpret_cast<getter>(GridPatternIdentifiers_get_ColumnCountProperty), nullptr, nullptr, nullptr },
        { "row_count_property", reinterpret_cast<getter>(GridPatternIdentifiers_get_RowCountProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_GridPatternIdentifiers_Static[] = {
        { }
    };

    static PyType_Slot type_slots_GridPatternIdentifiers_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_GridPatternIdentifiers_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_GridPatternIdentifiers_Static) },
        { }
    };

    static PyType_Spec type_spec_GridPatternIdentifiers_Static =
    {
        "winrt._winrt_microsoft_ui_xaml_automation.GridPatternIdentifiers_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_GridPatternIdentifiers_Static
    };

    // ----- MultipleViewPatternIdentifiers class --------------------

    static PyObject* _new_MultipleViewPatternIdentifiers(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Xaml::Automation::MultipleViewPatternIdentifiers>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Xaml::Automation::MultipleViewPatternIdentifiers>::type_name);
        return nullptr;
    }

    static void _dealloc_MultipleViewPatternIdentifiers(py::wrapper::Microsoft::UI::Xaml::Automation::MultipleViewPatternIdentifiers* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MultipleViewPatternIdentifiers_get_CurrentViewProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.MultipleViewPatternIdentifiers", L"CurrentViewProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Automation::MultipleViewPatternIdentifiers::CurrentViewProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MultipleViewPatternIdentifiers_get_SupportedViewsProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.MultipleViewPatternIdentifiers", L"SupportedViewsProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Automation::MultipleViewPatternIdentifiers::SupportedViewsProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MultipleViewPatternIdentifiers(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Automation::MultipleViewPatternIdentifiers>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MultipleViewPatternIdentifiers(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Automation::MultipleViewPatternIdentifiers>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MultipleViewPatternIdentifiers[] = {
        { "_assign_array_", _assign_array_MultipleViewPatternIdentifiers, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MultipleViewPatternIdentifiers), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MultipleViewPatternIdentifiers[] = {
        { }
    };

    static PyType_Slot _type_slots_MultipleViewPatternIdentifiers[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MultipleViewPatternIdentifiers) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MultipleViewPatternIdentifiers) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MultipleViewPatternIdentifiers) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MultipleViewPatternIdentifiers) },
        { },
    };

    static PyType_Spec type_spec_MultipleViewPatternIdentifiers =
    {
        "winrt._winrt_microsoft_ui_xaml_automation.MultipleViewPatternIdentifiers",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Automation::MultipleViewPatternIdentifiers),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MultipleViewPatternIdentifiers
    };

    static PyGetSetDef getset_MultipleViewPatternIdentifiers_Static[] = {
        { "current_view_property", reinterpret_cast<getter>(MultipleViewPatternIdentifiers_get_CurrentViewProperty), nullptr, nullptr, nullptr },
        { "supported_views_property", reinterpret_cast<getter>(MultipleViewPatternIdentifiers_get_SupportedViewsProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_MultipleViewPatternIdentifiers_Static[] = {
        { }
    };

    static PyType_Slot type_slots_MultipleViewPatternIdentifiers_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_MultipleViewPatternIdentifiers_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_MultipleViewPatternIdentifiers_Static) },
        { }
    };

    static PyType_Spec type_spec_MultipleViewPatternIdentifiers_Static =
    {
        "winrt._winrt_microsoft_ui_xaml_automation.MultipleViewPatternIdentifiers_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_MultipleViewPatternIdentifiers_Static
    };

    // ----- RangeValuePatternIdentifiers class --------------------

    static PyObject* _new_RangeValuePatternIdentifiers(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Xaml::Automation::RangeValuePatternIdentifiers>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Xaml::Automation::RangeValuePatternIdentifiers>::type_name);
        return nullptr;
    }

    static void _dealloc_RangeValuePatternIdentifiers(py::wrapper::Microsoft::UI::Xaml::Automation::RangeValuePatternIdentifiers* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* RangeValuePatternIdentifiers_get_IsReadOnlyProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.RangeValuePatternIdentifiers", L"IsReadOnlyProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Automation::RangeValuePatternIdentifiers::IsReadOnlyProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RangeValuePatternIdentifiers_get_LargeChangeProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.RangeValuePatternIdentifiers", L"LargeChangeProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Automation::RangeValuePatternIdentifiers::LargeChangeProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RangeValuePatternIdentifiers_get_MaximumProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.RangeValuePatternIdentifiers", L"MaximumProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Automation::RangeValuePatternIdentifiers::MaximumProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RangeValuePatternIdentifiers_get_MinimumProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.RangeValuePatternIdentifiers", L"MinimumProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Automation::RangeValuePatternIdentifiers::MinimumProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RangeValuePatternIdentifiers_get_SmallChangeProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.RangeValuePatternIdentifiers", L"SmallChangeProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Automation::RangeValuePatternIdentifiers::SmallChangeProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RangeValuePatternIdentifiers_get_ValueProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.RangeValuePatternIdentifiers", L"ValueProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Automation::RangeValuePatternIdentifiers::ValueProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_RangeValuePatternIdentifiers(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Automation::RangeValuePatternIdentifiers>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_RangeValuePatternIdentifiers(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Automation::RangeValuePatternIdentifiers>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_RangeValuePatternIdentifiers[] = {
        { "_assign_array_", _assign_array_RangeValuePatternIdentifiers, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_RangeValuePatternIdentifiers), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_RangeValuePatternIdentifiers[] = {
        { }
    };

    static PyType_Slot _type_slots_RangeValuePatternIdentifiers[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_RangeValuePatternIdentifiers) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_RangeValuePatternIdentifiers) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_RangeValuePatternIdentifiers) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_RangeValuePatternIdentifiers) },
        { },
    };

    static PyType_Spec type_spec_RangeValuePatternIdentifiers =
    {
        "winrt._winrt_microsoft_ui_xaml_automation.RangeValuePatternIdentifiers",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Automation::RangeValuePatternIdentifiers),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_RangeValuePatternIdentifiers
    };

    static PyGetSetDef getset_RangeValuePatternIdentifiers_Static[] = {
        { "is_read_only_property", reinterpret_cast<getter>(RangeValuePatternIdentifiers_get_IsReadOnlyProperty), nullptr, nullptr, nullptr },
        { "large_change_property", reinterpret_cast<getter>(RangeValuePatternIdentifiers_get_LargeChangeProperty), nullptr, nullptr, nullptr },
        { "maximum_property", reinterpret_cast<getter>(RangeValuePatternIdentifiers_get_MaximumProperty), nullptr, nullptr, nullptr },
        { "minimum_property", reinterpret_cast<getter>(RangeValuePatternIdentifiers_get_MinimumProperty), nullptr, nullptr, nullptr },
        { "small_change_property", reinterpret_cast<getter>(RangeValuePatternIdentifiers_get_SmallChangeProperty), nullptr, nullptr, nullptr },
        { "value_property", reinterpret_cast<getter>(RangeValuePatternIdentifiers_get_ValueProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_RangeValuePatternIdentifiers_Static[] = {
        { }
    };

    static PyType_Slot type_slots_RangeValuePatternIdentifiers_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_RangeValuePatternIdentifiers_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_RangeValuePatternIdentifiers_Static) },
        { }
    };

    static PyType_Spec type_spec_RangeValuePatternIdentifiers_Static =
    {
        "winrt._winrt_microsoft_ui_xaml_automation.RangeValuePatternIdentifiers_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_RangeValuePatternIdentifiers_Static
    };

    // ----- ScrollPatternIdentifiers class --------------------

    static PyObject* _new_ScrollPatternIdentifiers(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Xaml::Automation::ScrollPatternIdentifiers>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Xaml::Automation::ScrollPatternIdentifiers>::type_name);
        return nullptr;
    }

    static void _dealloc_ScrollPatternIdentifiers(py::wrapper::Microsoft::UI::Xaml::Automation::ScrollPatternIdentifiers* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ScrollPatternIdentifiers_get_HorizontalScrollPercentProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.ScrollPatternIdentifiers", L"HorizontalScrollPercentProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Automation::ScrollPatternIdentifiers::HorizontalScrollPercentProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ScrollPatternIdentifiers_get_HorizontalViewSizeProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.ScrollPatternIdentifiers", L"HorizontalViewSizeProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Automation::ScrollPatternIdentifiers::HorizontalViewSizeProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ScrollPatternIdentifiers_get_HorizontallyScrollableProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.ScrollPatternIdentifiers", L"HorizontallyScrollableProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Automation::ScrollPatternIdentifiers::HorizontallyScrollableProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ScrollPatternIdentifiers_get_NoScroll(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.ScrollPatternIdentifiers", L"NoScroll"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Automation::ScrollPatternIdentifiers::NoScroll());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ScrollPatternIdentifiers_get_VerticalScrollPercentProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.ScrollPatternIdentifiers", L"VerticalScrollPercentProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Automation::ScrollPatternIdentifiers::VerticalScrollPercentProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ScrollPatternIdentifiers_get_VerticalViewSizeProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.ScrollPatternIdentifiers", L"VerticalViewSizeProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Automation::ScrollPatternIdentifiers::VerticalViewSizeProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ScrollPatternIdentifiers_get_VerticallyScrollableProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.ScrollPatternIdentifiers", L"VerticallyScrollableProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Automation::ScrollPatternIdentifiers::VerticallyScrollableProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ScrollPatternIdentifiers(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Automation::ScrollPatternIdentifiers>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ScrollPatternIdentifiers(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Automation::ScrollPatternIdentifiers>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ScrollPatternIdentifiers[] = {
        { "_assign_array_", _assign_array_ScrollPatternIdentifiers, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ScrollPatternIdentifiers), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ScrollPatternIdentifiers[] = {
        { }
    };

    static PyType_Slot _type_slots_ScrollPatternIdentifiers[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ScrollPatternIdentifiers) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ScrollPatternIdentifiers) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ScrollPatternIdentifiers) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ScrollPatternIdentifiers) },
        { },
    };

    static PyType_Spec type_spec_ScrollPatternIdentifiers =
    {
        "winrt._winrt_microsoft_ui_xaml_automation.ScrollPatternIdentifiers",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Automation::ScrollPatternIdentifiers),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ScrollPatternIdentifiers
    };

    static PyGetSetDef getset_ScrollPatternIdentifiers_Static[] = {
        { "horizontal_scroll_percent_property", reinterpret_cast<getter>(ScrollPatternIdentifiers_get_HorizontalScrollPercentProperty), nullptr, nullptr, nullptr },
        { "horizontal_view_size_property", reinterpret_cast<getter>(ScrollPatternIdentifiers_get_HorizontalViewSizeProperty), nullptr, nullptr, nullptr },
        { "horizontally_scrollable_property", reinterpret_cast<getter>(ScrollPatternIdentifiers_get_HorizontallyScrollableProperty), nullptr, nullptr, nullptr },
        { "no_scroll", reinterpret_cast<getter>(ScrollPatternIdentifiers_get_NoScroll), nullptr, nullptr, nullptr },
        { "vertical_scroll_percent_property", reinterpret_cast<getter>(ScrollPatternIdentifiers_get_VerticalScrollPercentProperty), nullptr, nullptr, nullptr },
        { "vertical_view_size_property", reinterpret_cast<getter>(ScrollPatternIdentifiers_get_VerticalViewSizeProperty), nullptr, nullptr, nullptr },
        { "vertically_scrollable_property", reinterpret_cast<getter>(ScrollPatternIdentifiers_get_VerticallyScrollableProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_ScrollPatternIdentifiers_Static[] = {
        { }
    };

    static PyType_Slot type_slots_ScrollPatternIdentifiers_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_ScrollPatternIdentifiers_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_ScrollPatternIdentifiers_Static) },
        { }
    };

    static PyType_Spec type_spec_ScrollPatternIdentifiers_Static =
    {
        "winrt._winrt_microsoft_ui_xaml_automation.ScrollPatternIdentifiers_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_ScrollPatternIdentifiers_Static
    };

    // ----- SelectionItemPatternIdentifiers class --------------------

    static PyObject* _new_SelectionItemPatternIdentifiers(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Xaml::Automation::SelectionItemPatternIdentifiers>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Xaml::Automation::SelectionItemPatternIdentifiers>::type_name);
        return nullptr;
    }

    static void _dealloc_SelectionItemPatternIdentifiers(py::wrapper::Microsoft::UI::Xaml::Automation::SelectionItemPatternIdentifiers* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SelectionItemPatternIdentifiers_get_IsSelectedProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.SelectionItemPatternIdentifiers", L"IsSelectedProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Automation::SelectionItemPatternIdentifiers::IsSelectedProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SelectionItemPatternIdentifiers_get_SelectionContainerProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.SelectionItemPatternIdentifiers", L"SelectionContainerProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Automation::SelectionItemPatternIdentifiers::SelectionContainerProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SelectionItemPatternIdentifiers(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Automation::SelectionItemPatternIdentifiers>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SelectionItemPatternIdentifiers(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Automation::SelectionItemPatternIdentifiers>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SelectionItemPatternIdentifiers[] = {
        { "_assign_array_", _assign_array_SelectionItemPatternIdentifiers, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SelectionItemPatternIdentifiers), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SelectionItemPatternIdentifiers[] = {
        { }
    };

    static PyType_Slot _type_slots_SelectionItemPatternIdentifiers[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_SelectionItemPatternIdentifiers) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SelectionItemPatternIdentifiers) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SelectionItemPatternIdentifiers) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SelectionItemPatternIdentifiers) },
        { },
    };

    static PyType_Spec type_spec_SelectionItemPatternIdentifiers =
    {
        "winrt._winrt_microsoft_ui_xaml_automation.SelectionItemPatternIdentifiers",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Automation::SelectionItemPatternIdentifiers),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SelectionItemPatternIdentifiers
    };

    static PyGetSetDef getset_SelectionItemPatternIdentifiers_Static[] = {
        { "is_selected_property", reinterpret_cast<getter>(SelectionItemPatternIdentifiers_get_IsSelectedProperty), nullptr, nullptr, nullptr },
        { "selection_container_property", reinterpret_cast<getter>(SelectionItemPatternIdentifiers_get_SelectionContainerProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_SelectionItemPatternIdentifiers_Static[] = {
        { }
    };

    static PyType_Slot type_slots_SelectionItemPatternIdentifiers_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_SelectionItemPatternIdentifiers_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_SelectionItemPatternIdentifiers_Static) },
        { }
    };

    static PyType_Spec type_spec_SelectionItemPatternIdentifiers_Static =
    {
        "winrt._winrt_microsoft_ui_xaml_automation.SelectionItemPatternIdentifiers_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_SelectionItemPatternIdentifiers_Static
    };

    // ----- SelectionPatternIdentifiers class --------------------

    static PyObject* _new_SelectionPatternIdentifiers(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Xaml::Automation::SelectionPatternIdentifiers>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Xaml::Automation::SelectionPatternIdentifiers>::type_name);
        return nullptr;
    }

    static void _dealloc_SelectionPatternIdentifiers(py::wrapper::Microsoft::UI::Xaml::Automation::SelectionPatternIdentifiers* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SelectionPatternIdentifiers_get_CanSelectMultipleProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.SelectionPatternIdentifiers", L"CanSelectMultipleProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Automation::SelectionPatternIdentifiers::CanSelectMultipleProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SelectionPatternIdentifiers_get_IsSelectionRequiredProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.SelectionPatternIdentifiers", L"IsSelectionRequiredProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Automation::SelectionPatternIdentifiers::IsSelectionRequiredProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SelectionPatternIdentifiers_get_SelectionProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.SelectionPatternIdentifiers", L"SelectionProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Automation::SelectionPatternIdentifiers::SelectionProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SelectionPatternIdentifiers(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Automation::SelectionPatternIdentifiers>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SelectionPatternIdentifiers(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Automation::SelectionPatternIdentifiers>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SelectionPatternIdentifiers[] = {
        { "_assign_array_", _assign_array_SelectionPatternIdentifiers, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SelectionPatternIdentifiers), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SelectionPatternIdentifiers[] = {
        { }
    };

    static PyType_Slot _type_slots_SelectionPatternIdentifiers[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_SelectionPatternIdentifiers) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SelectionPatternIdentifiers) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SelectionPatternIdentifiers) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SelectionPatternIdentifiers) },
        { },
    };

    static PyType_Spec type_spec_SelectionPatternIdentifiers =
    {
        "winrt._winrt_microsoft_ui_xaml_automation.SelectionPatternIdentifiers",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Automation::SelectionPatternIdentifiers),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SelectionPatternIdentifiers
    };

    static PyGetSetDef getset_SelectionPatternIdentifiers_Static[] = {
        { "can_select_multiple_property", reinterpret_cast<getter>(SelectionPatternIdentifiers_get_CanSelectMultipleProperty), nullptr, nullptr, nullptr },
        { "is_selection_required_property", reinterpret_cast<getter>(SelectionPatternIdentifiers_get_IsSelectionRequiredProperty), nullptr, nullptr, nullptr },
        { "selection_property", reinterpret_cast<getter>(SelectionPatternIdentifiers_get_SelectionProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_SelectionPatternIdentifiers_Static[] = {
        { }
    };

    static PyType_Slot type_slots_SelectionPatternIdentifiers_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_SelectionPatternIdentifiers_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_SelectionPatternIdentifiers_Static) },
        { }
    };

    static PyType_Spec type_spec_SelectionPatternIdentifiers_Static =
    {
        "winrt._winrt_microsoft_ui_xaml_automation.SelectionPatternIdentifiers_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_SelectionPatternIdentifiers_Static
    };

    // ----- SpreadsheetItemPatternIdentifiers class --------------------

    static PyObject* _new_SpreadsheetItemPatternIdentifiers(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Xaml::Automation::SpreadsheetItemPatternIdentifiers>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Xaml::Automation::SpreadsheetItemPatternIdentifiers>::type_name);
        return nullptr;
    }

    static void _dealloc_SpreadsheetItemPatternIdentifiers(py::wrapper::Microsoft::UI::Xaml::Automation::SpreadsheetItemPatternIdentifiers* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SpreadsheetItemPatternIdentifiers_get_FormulaProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.SpreadsheetItemPatternIdentifiers", L"FormulaProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Automation::SpreadsheetItemPatternIdentifiers::FormulaProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SpreadsheetItemPatternIdentifiers(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Automation::SpreadsheetItemPatternIdentifiers>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SpreadsheetItemPatternIdentifiers(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Automation::SpreadsheetItemPatternIdentifiers>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SpreadsheetItemPatternIdentifiers[] = {
        { "_assign_array_", _assign_array_SpreadsheetItemPatternIdentifiers, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SpreadsheetItemPatternIdentifiers), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SpreadsheetItemPatternIdentifiers[] = {
        { }
    };

    static PyType_Slot _type_slots_SpreadsheetItemPatternIdentifiers[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_SpreadsheetItemPatternIdentifiers) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SpreadsheetItemPatternIdentifiers) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SpreadsheetItemPatternIdentifiers) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SpreadsheetItemPatternIdentifiers) },
        { },
    };

    static PyType_Spec type_spec_SpreadsheetItemPatternIdentifiers =
    {
        "winrt._winrt_microsoft_ui_xaml_automation.SpreadsheetItemPatternIdentifiers",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Automation::SpreadsheetItemPatternIdentifiers),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SpreadsheetItemPatternIdentifiers
    };

    static PyGetSetDef getset_SpreadsheetItemPatternIdentifiers_Static[] = {
        { "formula_property", reinterpret_cast<getter>(SpreadsheetItemPatternIdentifiers_get_FormulaProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_SpreadsheetItemPatternIdentifiers_Static[] = {
        { }
    };

    static PyType_Slot type_slots_SpreadsheetItemPatternIdentifiers_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_SpreadsheetItemPatternIdentifiers_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_SpreadsheetItemPatternIdentifiers_Static) },
        { }
    };

    static PyType_Spec type_spec_SpreadsheetItemPatternIdentifiers_Static =
    {
        "winrt._winrt_microsoft_ui_xaml_automation.SpreadsheetItemPatternIdentifiers_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_SpreadsheetItemPatternIdentifiers_Static
    };

    // ----- StylesPatternIdentifiers class --------------------

    static PyObject* _new_StylesPatternIdentifiers(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Xaml::Automation::StylesPatternIdentifiers>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Xaml::Automation::StylesPatternIdentifiers>::type_name);
        return nullptr;
    }

    static void _dealloc_StylesPatternIdentifiers(py::wrapper::Microsoft::UI::Xaml::Automation::StylesPatternIdentifiers* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* StylesPatternIdentifiers_get_ExtendedPropertiesProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.StylesPatternIdentifiers", L"ExtendedPropertiesProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Automation::StylesPatternIdentifiers::ExtendedPropertiesProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StylesPatternIdentifiers_get_FillColorProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.StylesPatternIdentifiers", L"FillColorProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Automation::StylesPatternIdentifiers::FillColorProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StylesPatternIdentifiers_get_FillPatternColorProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.StylesPatternIdentifiers", L"FillPatternColorProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Automation::StylesPatternIdentifiers::FillPatternColorProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StylesPatternIdentifiers_get_FillPatternStyleProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.StylesPatternIdentifiers", L"FillPatternStyleProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Automation::StylesPatternIdentifiers::FillPatternStyleProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StylesPatternIdentifiers_get_ShapeProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.StylesPatternIdentifiers", L"ShapeProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Automation::StylesPatternIdentifiers::ShapeProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StylesPatternIdentifiers_get_StyleIdProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.StylesPatternIdentifiers", L"StyleIdProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Automation::StylesPatternIdentifiers::StyleIdProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StylesPatternIdentifiers_get_StyleNameProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.StylesPatternIdentifiers", L"StyleNameProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Automation::StylesPatternIdentifiers::StyleNameProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_StylesPatternIdentifiers(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Automation::StylesPatternIdentifiers>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_StylesPatternIdentifiers(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Automation::StylesPatternIdentifiers>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StylesPatternIdentifiers[] = {
        { "_assign_array_", _assign_array_StylesPatternIdentifiers, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_StylesPatternIdentifiers), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_StylesPatternIdentifiers[] = {
        { }
    };

    static PyType_Slot _type_slots_StylesPatternIdentifiers[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_StylesPatternIdentifiers) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_StylesPatternIdentifiers) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_StylesPatternIdentifiers) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_StylesPatternIdentifiers) },
        { },
    };

    static PyType_Spec type_spec_StylesPatternIdentifiers =
    {
        "winrt._winrt_microsoft_ui_xaml_automation.StylesPatternIdentifiers",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Automation::StylesPatternIdentifiers),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StylesPatternIdentifiers
    };

    static PyGetSetDef getset_StylesPatternIdentifiers_Static[] = {
        { "extended_properties_property", reinterpret_cast<getter>(StylesPatternIdentifiers_get_ExtendedPropertiesProperty), nullptr, nullptr, nullptr },
        { "fill_color_property", reinterpret_cast<getter>(StylesPatternIdentifiers_get_FillColorProperty), nullptr, nullptr, nullptr },
        { "fill_pattern_color_property", reinterpret_cast<getter>(StylesPatternIdentifiers_get_FillPatternColorProperty), nullptr, nullptr, nullptr },
        { "fill_pattern_style_property", reinterpret_cast<getter>(StylesPatternIdentifiers_get_FillPatternStyleProperty), nullptr, nullptr, nullptr },
        { "shape_property", reinterpret_cast<getter>(StylesPatternIdentifiers_get_ShapeProperty), nullptr, nullptr, nullptr },
        { "style_id_property", reinterpret_cast<getter>(StylesPatternIdentifiers_get_StyleIdProperty), nullptr, nullptr, nullptr },
        { "style_name_property", reinterpret_cast<getter>(StylesPatternIdentifiers_get_StyleNameProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_StylesPatternIdentifiers_Static[] = {
        { }
    };

    static PyType_Slot type_slots_StylesPatternIdentifiers_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_StylesPatternIdentifiers_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_StylesPatternIdentifiers_Static) },
        { }
    };

    static PyType_Spec type_spec_StylesPatternIdentifiers_Static =
    {
        "winrt._winrt_microsoft_ui_xaml_automation.StylesPatternIdentifiers_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_StylesPatternIdentifiers_Static
    };

    // ----- TableItemPatternIdentifiers class --------------------

    static PyObject* _new_TableItemPatternIdentifiers(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Xaml::Automation::TableItemPatternIdentifiers>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Xaml::Automation::TableItemPatternIdentifiers>::type_name);
        return nullptr;
    }

    static void _dealloc_TableItemPatternIdentifiers(py::wrapper::Microsoft::UI::Xaml::Automation::TableItemPatternIdentifiers* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* TableItemPatternIdentifiers_get_ColumnHeaderItemsProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.TableItemPatternIdentifiers", L"ColumnHeaderItemsProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Automation::TableItemPatternIdentifiers::ColumnHeaderItemsProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TableItemPatternIdentifiers_get_RowHeaderItemsProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.TableItemPatternIdentifiers", L"RowHeaderItemsProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Automation::TableItemPatternIdentifiers::RowHeaderItemsProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_TableItemPatternIdentifiers(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Automation::TableItemPatternIdentifiers>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_TableItemPatternIdentifiers(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Automation::TableItemPatternIdentifiers>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_TableItemPatternIdentifiers[] = {
        { "_assign_array_", _assign_array_TableItemPatternIdentifiers, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_TableItemPatternIdentifiers), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_TableItemPatternIdentifiers[] = {
        { }
    };

    static PyType_Slot _type_slots_TableItemPatternIdentifiers[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_TableItemPatternIdentifiers) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_TableItemPatternIdentifiers) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_TableItemPatternIdentifiers) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_TableItemPatternIdentifiers) },
        { },
    };

    static PyType_Spec type_spec_TableItemPatternIdentifiers =
    {
        "winrt._winrt_microsoft_ui_xaml_automation.TableItemPatternIdentifiers",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Automation::TableItemPatternIdentifiers),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TableItemPatternIdentifiers
    };

    static PyGetSetDef getset_TableItemPatternIdentifiers_Static[] = {
        { "column_header_items_property", reinterpret_cast<getter>(TableItemPatternIdentifiers_get_ColumnHeaderItemsProperty), nullptr, nullptr, nullptr },
        { "row_header_items_property", reinterpret_cast<getter>(TableItemPatternIdentifiers_get_RowHeaderItemsProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_TableItemPatternIdentifiers_Static[] = {
        { }
    };

    static PyType_Slot type_slots_TableItemPatternIdentifiers_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_TableItemPatternIdentifiers_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_TableItemPatternIdentifiers_Static) },
        { }
    };

    static PyType_Spec type_spec_TableItemPatternIdentifiers_Static =
    {
        "winrt._winrt_microsoft_ui_xaml_automation.TableItemPatternIdentifiers_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_TableItemPatternIdentifiers_Static
    };

    // ----- TablePatternIdentifiers class --------------------

    static PyObject* _new_TablePatternIdentifiers(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Xaml::Automation::TablePatternIdentifiers>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Xaml::Automation::TablePatternIdentifiers>::type_name);
        return nullptr;
    }

    static void _dealloc_TablePatternIdentifiers(py::wrapper::Microsoft::UI::Xaml::Automation::TablePatternIdentifiers* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* TablePatternIdentifiers_get_ColumnHeadersProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.TablePatternIdentifiers", L"ColumnHeadersProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Automation::TablePatternIdentifiers::ColumnHeadersProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TablePatternIdentifiers_get_RowHeadersProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.TablePatternIdentifiers", L"RowHeadersProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Automation::TablePatternIdentifiers::RowHeadersProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TablePatternIdentifiers_get_RowOrColumnMajorProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.TablePatternIdentifiers", L"RowOrColumnMajorProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Automation::TablePatternIdentifiers::RowOrColumnMajorProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_TablePatternIdentifiers(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Automation::TablePatternIdentifiers>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_TablePatternIdentifiers(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Automation::TablePatternIdentifiers>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_TablePatternIdentifiers[] = {
        { "_assign_array_", _assign_array_TablePatternIdentifiers, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_TablePatternIdentifiers), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_TablePatternIdentifiers[] = {
        { }
    };

    static PyType_Slot _type_slots_TablePatternIdentifiers[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_TablePatternIdentifiers) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_TablePatternIdentifiers) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_TablePatternIdentifiers) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_TablePatternIdentifiers) },
        { },
    };

    static PyType_Spec type_spec_TablePatternIdentifiers =
    {
        "winrt._winrt_microsoft_ui_xaml_automation.TablePatternIdentifiers",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Automation::TablePatternIdentifiers),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TablePatternIdentifiers
    };

    static PyGetSetDef getset_TablePatternIdentifiers_Static[] = {
        { "column_headers_property", reinterpret_cast<getter>(TablePatternIdentifiers_get_ColumnHeadersProperty), nullptr, nullptr, nullptr },
        { "row_headers_property", reinterpret_cast<getter>(TablePatternIdentifiers_get_RowHeadersProperty), nullptr, nullptr, nullptr },
        { "row_or_column_major_property", reinterpret_cast<getter>(TablePatternIdentifiers_get_RowOrColumnMajorProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_TablePatternIdentifiers_Static[] = {
        { }
    };

    static PyType_Slot type_slots_TablePatternIdentifiers_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_TablePatternIdentifiers_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_TablePatternIdentifiers_Static) },
        { }
    };

    static PyType_Spec type_spec_TablePatternIdentifiers_Static =
    {
        "winrt._winrt_microsoft_ui_xaml_automation.TablePatternIdentifiers_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_TablePatternIdentifiers_Static
    };

    // ----- TogglePatternIdentifiers class --------------------

    static PyObject* _new_TogglePatternIdentifiers(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Xaml::Automation::TogglePatternIdentifiers>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Xaml::Automation::TogglePatternIdentifiers>::type_name);
        return nullptr;
    }

    static void _dealloc_TogglePatternIdentifiers(py::wrapper::Microsoft::UI::Xaml::Automation::TogglePatternIdentifiers* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* TogglePatternIdentifiers_get_ToggleStateProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.TogglePatternIdentifiers", L"ToggleStateProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Automation::TogglePatternIdentifiers::ToggleStateProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_TogglePatternIdentifiers(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Automation::TogglePatternIdentifiers>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_TogglePatternIdentifiers(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Automation::TogglePatternIdentifiers>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_TogglePatternIdentifiers[] = {
        { "_assign_array_", _assign_array_TogglePatternIdentifiers, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_TogglePatternIdentifiers), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_TogglePatternIdentifiers[] = {
        { }
    };

    static PyType_Slot _type_slots_TogglePatternIdentifiers[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_TogglePatternIdentifiers) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_TogglePatternIdentifiers) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_TogglePatternIdentifiers) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_TogglePatternIdentifiers) },
        { },
    };

    static PyType_Spec type_spec_TogglePatternIdentifiers =
    {
        "winrt._winrt_microsoft_ui_xaml_automation.TogglePatternIdentifiers",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Automation::TogglePatternIdentifiers),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TogglePatternIdentifiers
    };

    static PyGetSetDef getset_TogglePatternIdentifiers_Static[] = {
        { "toggle_state_property", reinterpret_cast<getter>(TogglePatternIdentifiers_get_ToggleStateProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_TogglePatternIdentifiers_Static[] = {
        { }
    };

    static PyType_Slot type_slots_TogglePatternIdentifiers_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_TogglePatternIdentifiers_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_TogglePatternIdentifiers_Static) },
        { }
    };

    static PyType_Spec type_spec_TogglePatternIdentifiers_Static =
    {
        "winrt._winrt_microsoft_ui_xaml_automation.TogglePatternIdentifiers_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_TogglePatternIdentifiers_Static
    };

    // ----- TransformPattern2Identifiers class --------------------

    static PyObject* _new_TransformPattern2Identifiers(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Xaml::Automation::TransformPattern2Identifiers>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Xaml::Automation::TransformPattern2Identifiers>::type_name);
        return nullptr;
    }

    static void _dealloc_TransformPattern2Identifiers(py::wrapper::Microsoft::UI::Xaml::Automation::TransformPattern2Identifiers* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* TransformPattern2Identifiers_get_CanZoomProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.TransformPattern2Identifiers", L"CanZoomProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Automation::TransformPattern2Identifiers::CanZoomProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TransformPattern2Identifiers_get_MaxZoomProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.TransformPattern2Identifiers", L"MaxZoomProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Automation::TransformPattern2Identifiers::MaxZoomProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TransformPattern2Identifiers_get_MinZoomProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.TransformPattern2Identifiers", L"MinZoomProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Automation::TransformPattern2Identifiers::MinZoomProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TransformPattern2Identifiers_get_ZoomLevelProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.TransformPattern2Identifiers", L"ZoomLevelProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Automation::TransformPattern2Identifiers::ZoomLevelProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_TransformPattern2Identifiers(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Automation::TransformPattern2Identifiers>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_TransformPattern2Identifiers(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Automation::TransformPattern2Identifiers>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_TransformPattern2Identifiers[] = {
        { "_assign_array_", _assign_array_TransformPattern2Identifiers, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_TransformPattern2Identifiers), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_TransformPattern2Identifiers[] = {
        { }
    };

    static PyType_Slot _type_slots_TransformPattern2Identifiers[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_TransformPattern2Identifiers) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_TransformPattern2Identifiers) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_TransformPattern2Identifiers) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_TransformPattern2Identifiers) },
        { },
    };

    static PyType_Spec type_spec_TransformPattern2Identifiers =
    {
        "winrt._winrt_microsoft_ui_xaml_automation.TransformPattern2Identifiers",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Automation::TransformPattern2Identifiers),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TransformPattern2Identifiers
    };

    static PyGetSetDef getset_TransformPattern2Identifiers_Static[] = {
        { "can_zoom_property", reinterpret_cast<getter>(TransformPattern2Identifiers_get_CanZoomProperty), nullptr, nullptr, nullptr },
        { "max_zoom_property", reinterpret_cast<getter>(TransformPattern2Identifiers_get_MaxZoomProperty), nullptr, nullptr, nullptr },
        { "min_zoom_property", reinterpret_cast<getter>(TransformPattern2Identifiers_get_MinZoomProperty), nullptr, nullptr, nullptr },
        { "zoom_level_property", reinterpret_cast<getter>(TransformPattern2Identifiers_get_ZoomLevelProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_TransformPattern2Identifiers_Static[] = {
        { }
    };

    static PyType_Slot type_slots_TransformPattern2Identifiers_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_TransformPattern2Identifiers_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_TransformPattern2Identifiers_Static) },
        { }
    };

    static PyType_Spec type_spec_TransformPattern2Identifiers_Static =
    {
        "winrt._winrt_microsoft_ui_xaml_automation.TransformPattern2Identifiers_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_TransformPattern2Identifiers_Static
    };

    // ----- TransformPatternIdentifiers class --------------------

    static PyObject* _new_TransformPatternIdentifiers(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Xaml::Automation::TransformPatternIdentifiers>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Xaml::Automation::TransformPatternIdentifiers>::type_name);
        return nullptr;
    }

    static void _dealloc_TransformPatternIdentifiers(py::wrapper::Microsoft::UI::Xaml::Automation::TransformPatternIdentifiers* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* TransformPatternIdentifiers_get_CanMoveProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.TransformPatternIdentifiers", L"CanMoveProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Automation::TransformPatternIdentifiers::CanMoveProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TransformPatternIdentifiers_get_CanResizeProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.TransformPatternIdentifiers", L"CanResizeProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Automation::TransformPatternIdentifiers::CanResizeProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TransformPatternIdentifiers_get_CanRotateProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.TransformPatternIdentifiers", L"CanRotateProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Automation::TransformPatternIdentifiers::CanRotateProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_TransformPatternIdentifiers(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Automation::TransformPatternIdentifiers>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_TransformPatternIdentifiers(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Automation::TransformPatternIdentifiers>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_TransformPatternIdentifiers[] = {
        { "_assign_array_", _assign_array_TransformPatternIdentifiers, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_TransformPatternIdentifiers), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_TransformPatternIdentifiers[] = {
        { }
    };

    static PyType_Slot _type_slots_TransformPatternIdentifiers[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_TransformPatternIdentifiers) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_TransformPatternIdentifiers) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_TransformPatternIdentifiers) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_TransformPatternIdentifiers) },
        { },
    };

    static PyType_Spec type_spec_TransformPatternIdentifiers =
    {
        "winrt._winrt_microsoft_ui_xaml_automation.TransformPatternIdentifiers",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Automation::TransformPatternIdentifiers),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TransformPatternIdentifiers
    };

    static PyGetSetDef getset_TransformPatternIdentifiers_Static[] = {
        { "can_move_property", reinterpret_cast<getter>(TransformPatternIdentifiers_get_CanMoveProperty), nullptr, nullptr, nullptr },
        { "can_resize_property", reinterpret_cast<getter>(TransformPatternIdentifiers_get_CanResizeProperty), nullptr, nullptr, nullptr },
        { "can_rotate_property", reinterpret_cast<getter>(TransformPatternIdentifiers_get_CanRotateProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_TransformPatternIdentifiers_Static[] = {
        { }
    };

    static PyType_Slot type_slots_TransformPatternIdentifiers_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_TransformPatternIdentifiers_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_TransformPatternIdentifiers_Static) },
        { }
    };

    static PyType_Spec type_spec_TransformPatternIdentifiers_Static =
    {
        "winrt._winrt_microsoft_ui_xaml_automation.TransformPatternIdentifiers_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_TransformPatternIdentifiers_Static
    };

    // ----- ValuePatternIdentifiers class --------------------

    static PyObject* _new_ValuePatternIdentifiers(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Xaml::Automation::ValuePatternIdentifiers>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Xaml::Automation::ValuePatternIdentifiers>::type_name);
        return nullptr;
    }

    static void _dealloc_ValuePatternIdentifiers(py::wrapper::Microsoft::UI::Xaml::Automation::ValuePatternIdentifiers* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ValuePatternIdentifiers_get_IsReadOnlyProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.ValuePatternIdentifiers", L"IsReadOnlyProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Automation::ValuePatternIdentifiers::IsReadOnlyProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ValuePatternIdentifiers_get_ValueProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.ValuePatternIdentifiers", L"ValueProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Automation::ValuePatternIdentifiers::ValueProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ValuePatternIdentifiers(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Automation::ValuePatternIdentifiers>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ValuePatternIdentifiers(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Automation::ValuePatternIdentifiers>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ValuePatternIdentifiers[] = {
        { "_assign_array_", _assign_array_ValuePatternIdentifiers, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ValuePatternIdentifiers), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ValuePatternIdentifiers[] = {
        { }
    };

    static PyType_Slot _type_slots_ValuePatternIdentifiers[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ValuePatternIdentifiers) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ValuePatternIdentifiers) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ValuePatternIdentifiers) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ValuePatternIdentifiers) },
        { },
    };

    static PyType_Spec type_spec_ValuePatternIdentifiers =
    {
        "winrt._winrt_microsoft_ui_xaml_automation.ValuePatternIdentifiers",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Automation::ValuePatternIdentifiers),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ValuePatternIdentifiers
    };

    static PyGetSetDef getset_ValuePatternIdentifiers_Static[] = {
        { "is_read_only_property", reinterpret_cast<getter>(ValuePatternIdentifiers_get_IsReadOnlyProperty), nullptr, nullptr, nullptr },
        { "value_property", reinterpret_cast<getter>(ValuePatternIdentifiers_get_ValueProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_ValuePatternIdentifiers_Static[] = {
        { }
    };

    static PyType_Slot type_slots_ValuePatternIdentifiers_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_ValuePatternIdentifiers_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_ValuePatternIdentifiers_Static) },
        { }
    };

    static PyType_Spec type_spec_ValuePatternIdentifiers_Static =
    {
        "winrt._winrt_microsoft_ui_xaml_automation.ValuePatternIdentifiers_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_ValuePatternIdentifiers_Static
    };

    // ----- WindowPatternIdentifiers class --------------------

    static PyObject* _new_WindowPatternIdentifiers(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Xaml::Automation::WindowPatternIdentifiers>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Xaml::Automation::WindowPatternIdentifiers>::type_name);
        return nullptr;
    }

    static void _dealloc_WindowPatternIdentifiers(py::wrapper::Microsoft::UI::Xaml::Automation::WindowPatternIdentifiers* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* WindowPatternIdentifiers_get_CanMaximizeProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.WindowPatternIdentifiers", L"CanMaximizeProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Automation::WindowPatternIdentifiers::CanMaximizeProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WindowPatternIdentifiers_get_CanMinimizeProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.WindowPatternIdentifiers", L"CanMinimizeProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Automation::WindowPatternIdentifiers::CanMinimizeProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WindowPatternIdentifiers_get_IsModalProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.WindowPatternIdentifiers", L"IsModalProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Automation::WindowPatternIdentifiers::IsModalProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WindowPatternIdentifiers_get_IsTopmostProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.WindowPatternIdentifiers", L"IsTopmostProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Automation::WindowPatternIdentifiers::IsTopmostProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WindowPatternIdentifiers_get_WindowInteractionStateProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.WindowPatternIdentifiers", L"WindowInteractionStateProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Automation::WindowPatternIdentifiers::WindowInteractionStateProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WindowPatternIdentifiers_get_WindowVisualStateProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.WindowPatternIdentifiers", L"WindowVisualStateProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Automation::WindowPatternIdentifiers::WindowVisualStateProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_WindowPatternIdentifiers(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Automation::WindowPatternIdentifiers>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_WindowPatternIdentifiers(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Automation::WindowPatternIdentifiers>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_WindowPatternIdentifiers[] = {
        { "_assign_array_", _assign_array_WindowPatternIdentifiers, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_WindowPatternIdentifiers), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_WindowPatternIdentifiers[] = {
        { }
    };

    static PyType_Slot _type_slots_WindowPatternIdentifiers[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_WindowPatternIdentifiers) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_WindowPatternIdentifiers) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_WindowPatternIdentifiers) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_WindowPatternIdentifiers) },
        { },
    };

    static PyType_Spec type_spec_WindowPatternIdentifiers =
    {
        "winrt._winrt_microsoft_ui_xaml_automation.WindowPatternIdentifiers",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Automation::WindowPatternIdentifiers),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_WindowPatternIdentifiers
    };

    static PyGetSetDef getset_WindowPatternIdentifiers_Static[] = {
        { "can_maximize_property", reinterpret_cast<getter>(WindowPatternIdentifiers_get_CanMaximizeProperty), nullptr, nullptr, nullptr },
        { "can_minimize_property", reinterpret_cast<getter>(WindowPatternIdentifiers_get_CanMinimizeProperty), nullptr, nullptr, nullptr },
        { "is_modal_property", reinterpret_cast<getter>(WindowPatternIdentifiers_get_IsModalProperty), nullptr, nullptr, nullptr },
        { "is_topmost_property", reinterpret_cast<getter>(WindowPatternIdentifiers_get_IsTopmostProperty), nullptr, nullptr, nullptr },
        { "window_interaction_state_property", reinterpret_cast<getter>(WindowPatternIdentifiers_get_WindowInteractionStateProperty), nullptr, nullptr, nullptr },
        { "window_visual_state_property", reinterpret_cast<getter>(WindowPatternIdentifiers_get_WindowVisualStateProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_WindowPatternIdentifiers_Static[] = {
        { }
    };

    static PyType_Slot type_slots_WindowPatternIdentifiers_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_WindowPatternIdentifiers_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_WindowPatternIdentifiers_Static) },
        { }
    };

    static PyType_Spec type_spec_WindowPatternIdentifiers_Static =
    {
        "winrt._winrt_microsoft_ui_xaml_automation.WindowPatternIdentifiers_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_WindowPatternIdentifiers_Static
    };

    // ----- Microsoft.UI.Xaml.Automation Initialization --------------------
    PyDoc_STRVAR(module_doc, "Microsoft::UI::Xaml::Automation");


    static PyModuleDef module_def
        = {PyModuleDef_HEAD_INIT,
           "_winrt_microsoft_ui_xaml_automation",
           module_doc,
           0,
           nullptr,
           nullptr,
           nullptr,
           nullptr,
           nullptr};

} // py::cpp::Microsoft::UI::Xaml::Automation

PyMODINIT_FUNC PyInit__winrt_microsoft_ui_xaml_automation(void) noexcept
{
    using namespace py::cpp::Microsoft::UI::Xaml::Automation;

    if (py::import_winrt_runtime() == -1)
    {
        return nullptr;
    }

    py::pyobj_handle module{PyModule_Create(&module_def)};

    if (!module)
    {
        return nullptr;
    }

    auto object_type = py::get_object_type();
    if (!object_type)
    {
        return nullptr;
    }

    py::pyobj_handle object_bases{PyTuple_Pack(1, object_type)};

    if (!object_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_AnnotationPatternIdentifiers_Static{PyType_FromSpec(&type_spec_AnnotationPatternIdentifiers_Static)};
    if (!type_AnnotationPatternIdentifiers_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_AnnotationPatternIdentifiers, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_AnnotationPatternIdentifiers_Static.get())) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_AutomationAnnotation_Static{PyType_FromSpec(&type_spec_AutomationAnnotation_Static)};
    if (!type_AutomationAnnotation_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_AutomationAnnotation, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_AutomationAnnotation_Static.get())) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_AutomationElementIdentifiers_Static{PyType_FromSpec(&type_spec_AutomationElementIdentifiers_Static)};
    if (!type_AutomationElementIdentifiers_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_AutomationElementIdentifiers, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_AutomationElementIdentifiers_Static.get())) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_AutomationProperties_Static{PyType_FromSpec(&type_spec_AutomationProperties_Static)};
    if (!type_AutomationProperties_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_AutomationProperties, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_AutomationProperties_Static.get())) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_AutomationProperty, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_DockPatternIdentifiers_Static{PyType_FromSpec(&type_spec_DockPatternIdentifiers_Static)};
    if (!type_DockPatternIdentifiers_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_DockPatternIdentifiers, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_DockPatternIdentifiers_Static.get())) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_DragPatternIdentifiers_Static{PyType_FromSpec(&type_spec_DragPatternIdentifiers_Static)};
    if (!type_DragPatternIdentifiers_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_DragPatternIdentifiers, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_DragPatternIdentifiers_Static.get())) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_DropTargetPatternIdentifiers_Static{PyType_FromSpec(&type_spec_DropTargetPatternIdentifiers_Static)};
    if (!type_DropTargetPatternIdentifiers_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_DropTargetPatternIdentifiers, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_DropTargetPatternIdentifiers_Static.get())) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_ExpandCollapsePatternIdentifiers_Static{PyType_FromSpec(&type_spec_ExpandCollapsePatternIdentifiers_Static)};
    if (!type_ExpandCollapsePatternIdentifiers_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ExpandCollapsePatternIdentifiers, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_ExpandCollapsePatternIdentifiers_Static.get())) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_GridItemPatternIdentifiers_Static{PyType_FromSpec(&type_spec_GridItemPatternIdentifiers_Static)};
    if (!type_GridItemPatternIdentifiers_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_GridItemPatternIdentifiers, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_GridItemPatternIdentifiers_Static.get())) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_GridPatternIdentifiers_Static{PyType_FromSpec(&type_spec_GridPatternIdentifiers_Static)};
    if (!type_GridPatternIdentifiers_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_GridPatternIdentifiers, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_GridPatternIdentifiers_Static.get())) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_MultipleViewPatternIdentifiers_Static{PyType_FromSpec(&type_spec_MultipleViewPatternIdentifiers_Static)};
    if (!type_MultipleViewPatternIdentifiers_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_MultipleViewPatternIdentifiers, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_MultipleViewPatternIdentifiers_Static.get())) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_RangeValuePatternIdentifiers_Static{PyType_FromSpec(&type_spec_RangeValuePatternIdentifiers_Static)};
    if (!type_RangeValuePatternIdentifiers_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_RangeValuePatternIdentifiers, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_RangeValuePatternIdentifiers_Static.get())) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_ScrollPatternIdentifiers_Static{PyType_FromSpec(&type_spec_ScrollPatternIdentifiers_Static)};
    if (!type_ScrollPatternIdentifiers_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ScrollPatternIdentifiers, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_ScrollPatternIdentifiers_Static.get())) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_SelectionItemPatternIdentifiers_Static{PyType_FromSpec(&type_spec_SelectionItemPatternIdentifiers_Static)};
    if (!type_SelectionItemPatternIdentifiers_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_SelectionItemPatternIdentifiers, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_SelectionItemPatternIdentifiers_Static.get())) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_SelectionPatternIdentifiers_Static{PyType_FromSpec(&type_spec_SelectionPatternIdentifiers_Static)};
    if (!type_SelectionPatternIdentifiers_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_SelectionPatternIdentifiers, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_SelectionPatternIdentifiers_Static.get())) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_SpreadsheetItemPatternIdentifiers_Static{PyType_FromSpec(&type_spec_SpreadsheetItemPatternIdentifiers_Static)};
    if (!type_SpreadsheetItemPatternIdentifiers_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_SpreadsheetItemPatternIdentifiers, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_SpreadsheetItemPatternIdentifiers_Static.get())) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_StylesPatternIdentifiers_Static{PyType_FromSpec(&type_spec_StylesPatternIdentifiers_Static)};
    if (!type_StylesPatternIdentifiers_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_StylesPatternIdentifiers, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_StylesPatternIdentifiers_Static.get())) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_TableItemPatternIdentifiers_Static{PyType_FromSpec(&type_spec_TableItemPatternIdentifiers_Static)};
    if (!type_TableItemPatternIdentifiers_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_TableItemPatternIdentifiers, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_TableItemPatternIdentifiers_Static.get())) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_TablePatternIdentifiers_Static{PyType_FromSpec(&type_spec_TablePatternIdentifiers_Static)};
    if (!type_TablePatternIdentifiers_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_TablePatternIdentifiers, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_TablePatternIdentifiers_Static.get())) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_TogglePatternIdentifiers_Static{PyType_FromSpec(&type_spec_TogglePatternIdentifiers_Static)};
    if (!type_TogglePatternIdentifiers_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_TogglePatternIdentifiers, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_TogglePatternIdentifiers_Static.get())) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_TransformPattern2Identifiers_Static{PyType_FromSpec(&type_spec_TransformPattern2Identifiers_Static)};
    if (!type_TransformPattern2Identifiers_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_TransformPattern2Identifiers, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_TransformPattern2Identifiers_Static.get())) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_TransformPatternIdentifiers_Static{PyType_FromSpec(&type_spec_TransformPatternIdentifiers_Static)};
    if (!type_TransformPatternIdentifiers_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_TransformPatternIdentifiers, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_TransformPatternIdentifiers_Static.get())) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_ValuePatternIdentifiers_Static{PyType_FromSpec(&type_spec_ValuePatternIdentifiers_Static)};
    if (!type_ValuePatternIdentifiers_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ValuePatternIdentifiers, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_ValuePatternIdentifiers_Static.get())) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_WindowPatternIdentifiers_Static{PyType_FromSpec(&type_spec_WindowPatternIdentifiers_Static)};
    if (!type_WindowPatternIdentifiers_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_WindowPatternIdentifiers, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_WindowPatternIdentifiers_Static.get())) == -1)
    {
        return nullptr;
    }


    return module.detach();
}
