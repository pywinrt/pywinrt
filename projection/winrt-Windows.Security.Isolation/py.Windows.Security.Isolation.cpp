// WARNING: Please don't edit this file. It was generated by Python/WinRT v2.2.0

#include "py.Windows.Security.Isolation.h"

namespace py::cpp::Windows::Security::Isolation
{
    // ----- IsolatedWindowsEnvironment class --------------------

    static PyObject* _new_IsolatedWindowsEnvironment(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Security::Isolation::IsolatedWindowsEnvironment>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Security::Isolation::IsolatedWindowsEnvironment>::type_name);
        return nullptr;
    }

    static void _dealloc_IsolatedWindowsEnvironment(py::wrapper::Windows::Security::Isolation::IsolatedWindowsEnvironment* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IsolatedWindowsEnvironment_ChangePriority(py::wrapper::Windows::Security::Isolation::IsolatedWindowsEnvironment* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Security.Isolation.IsolatedWindowsEnvironment", L"ChangePriority", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Security::Isolation::IsolatedWindowsEnvironmentCreationPriority>(args, 0);

                self->obj.ChangePriority(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IsolatedWindowsEnvironment_CreateAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Security.Isolation.IsolatedWindowsEnvironment", L"CreateAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Security::Isolation::IsolatedWindowsEnvironmentOptions>(args, 0);

                return py::convert(winrt::Windows::Security::Isolation::IsolatedWindowsEnvironment::CreateAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Security.Isolation.IsolatedWindowsEnvironment", L"CreateAsync", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Security::Isolation::IsolatedWindowsEnvironmentOptions>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Security::Isolation::IsolatedWindowsEnvironmentTelemetryParameters>(args, 1);

                return py::convert(winrt::Windows::Security::Isolation::IsolatedWindowsEnvironment::CreateAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IsolatedWindowsEnvironment_FindByOwnerId(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Security.Isolation.IsolatedWindowsEnvironment", L"FindByOwnerId", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Security::Isolation::IsolatedWindowsEnvironment::FindByOwnerId(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IsolatedWindowsEnvironment_GetById(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Security.Isolation.IsolatedWindowsEnvironment", L"GetById", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Security::Isolation::IsolatedWindowsEnvironment::GetById(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IsolatedWindowsEnvironment_GetUserInfo(py::wrapper::Windows::Security::Isolation::IsolatedWindowsEnvironment* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Security.Isolation.IsolatedWindowsEnvironment", L"GetUserInfo", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetUserInfo());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IsolatedWindowsEnvironment_LaunchFileWithUIAsync(py::wrapper::Windows::Security::Isolation::IsolatedWindowsEnvironment* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Security.Isolation.IsolatedWindowsEnvironment", L"LaunchFileWithUIAsync", 3);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::hstring>(args, 2);

                return py::convert(self->obj.LaunchFileWithUIAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 4)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Security.Isolation.IsolatedWindowsEnvironment", L"LaunchFileWithUIAsync", 4);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(4);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::hstring>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::Security::Isolation::IsolatedWindowsEnvironmentTelemetryParameters>(args, 3);

                return py::convert(self->obj.LaunchFileWithUIAsync(param0, param1, param2, param3));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IsolatedWindowsEnvironment_PostMessageToReceiverAsync(py::wrapper::Windows::Security::Isolation::IsolatedWindowsEnvironment* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Security.Isolation.IsolatedWindowsEnvironment", L"PostMessageToReceiverAsync", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::guid>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Foundation::IInspectable>>(args, 1);

                return py::convert(self->obj.PostMessageToReceiverAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Security.Isolation.IsolatedWindowsEnvironment", L"PostMessageToReceiverAsync", 3);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::guid>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Foundation::IInspectable>>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Security::Isolation::IsolatedWindowsEnvironmentTelemetryParameters>(args, 2);

                return py::convert(self->obj.PostMessageToReceiverAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IsolatedWindowsEnvironment_RegisterMessageReceiver(py::wrapper::Windows::Security::Isolation::IsolatedWindowsEnvironment* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Security.Isolation.IsolatedWindowsEnvironment", L"RegisterMessageReceiver", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::guid>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Security::Isolation::MessageReceivedCallback>(args, 1);

                self->obj.RegisterMessageReceiver(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IsolatedWindowsEnvironment_ShareFileAsync(py::wrapper::Windows::Security::Isolation::IsolatedWindowsEnvironment* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Security.Isolation.IsolatedWindowsEnvironment", L"ShareFileAsync", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Security::Isolation::IsolatedWindowsEnvironmentShareFileRequestOptions>(args, 1);

                return py::convert(self->obj.ShareFileAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Security.Isolation.IsolatedWindowsEnvironment", L"ShareFileAsync", 3);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Security::Isolation::IsolatedWindowsEnvironmentShareFileRequestOptions>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Security::Isolation::IsolatedWindowsEnvironmentTelemetryParameters>(args, 2);

                return py::convert(self->obj.ShareFileAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IsolatedWindowsEnvironment_ShareFolderAsync(py::wrapper::Windows::Security::Isolation::IsolatedWindowsEnvironment* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Security.Isolation.IsolatedWindowsEnvironment", L"ShareFolderAsync", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Security::Isolation::IsolatedWindowsEnvironmentShareFolderRequestOptions>(args, 1);

                return py::convert(self->obj.ShareFolderAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Security.Isolation.IsolatedWindowsEnvironment", L"ShareFolderAsync", 3);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Security::Isolation::IsolatedWindowsEnvironmentShareFolderRequestOptions>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Security::Isolation::IsolatedWindowsEnvironmentTelemetryParameters>(args, 2);

                return py::convert(self->obj.ShareFolderAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IsolatedWindowsEnvironment_StartProcessSilentlyAsync(py::wrapper::Windows::Security::Isolation::IsolatedWindowsEnvironment* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Security.Isolation.IsolatedWindowsEnvironment", L"StartProcessSilentlyAsync", 3);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Security::Isolation::IsolatedWindowsEnvironmentActivator>(args, 2);

                return py::convert(self->obj.StartProcessSilentlyAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 4)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Security.Isolation.IsolatedWindowsEnvironment", L"StartProcessSilentlyAsync", 4);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(4);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Security::Isolation::IsolatedWindowsEnvironmentActivator>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::Security::Isolation::IsolatedWindowsEnvironmentTelemetryParameters>(args, 3);

                return py::convert(self->obj.StartProcessSilentlyAsync(param0, param1, param2, param3));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IsolatedWindowsEnvironment_TerminateAsync(py::wrapper::Windows::Security::Isolation::IsolatedWindowsEnvironment* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Security.Isolation.IsolatedWindowsEnvironment", L"TerminateAsync", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.TerminateAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Security.Isolation.IsolatedWindowsEnvironment", L"TerminateAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Security::Isolation::IsolatedWindowsEnvironmentTelemetryParameters>(args, 0);

                return py::convert(self->obj.TerminateAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IsolatedWindowsEnvironment_UnregisterMessageReceiver(py::wrapper::Windows::Security::Isolation::IsolatedWindowsEnvironment* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Security.Isolation.IsolatedWindowsEnvironment", L"UnregisterMessageReceiver", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::guid>(args, 0);

                self->obj.UnregisterMessageReceiver(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IsolatedWindowsEnvironment_get_Id(py::wrapper::Windows::Security::Isolation::IsolatedWindowsEnvironment* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Isolation.IsolatedWindowsEnvironment", L"Id");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Id());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_IsolatedWindowsEnvironment(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Security::Isolation::IsolatedWindowsEnvironment>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IsolatedWindowsEnvironment(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Security::Isolation::IsolatedWindowsEnvironment>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IsolatedWindowsEnvironment[] = {
        { "change_priority", reinterpret_cast<PyCFunction>(IsolatedWindowsEnvironment_ChangePriority), METH_VARARGS, nullptr },
        { "get_user_info", reinterpret_cast<PyCFunction>(IsolatedWindowsEnvironment_GetUserInfo), METH_VARARGS, nullptr },
        { "launch_file_with_u_i_async", reinterpret_cast<PyCFunction>(IsolatedWindowsEnvironment_LaunchFileWithUIAsync), METH_VARARGS, nullptr },
        { "post_message_to_receiver_async", reinterpret_cast<PyCFunction>(IsolatedWindowsEnvironment_PostMessageToReceiverAsync), METH_VARARGS, nullptr },
        { "register_message_receiver", reinterpret_cast<PyCFunction>(IsolatedWindowsEnvironment_RegisterMessageReceiver), METH_VARARGS, nullptr },
        { "share_file_async", reinterpret_cast<PyCFunction>(IsolatedWindowsEnvironment_ShareFileAsync), METH_VARARGS, nullptr },
        { "share_folder_async", reinterpret_cast<PyCFunction>(IsolatedWindowsEnvironment_ShareFolderAsync), METH_VARARGS, nullptr },
        { "start_process_silently_async", reinterpret_cast<PyCFunction>(IsolatedWindowsEnvironment_StartProcessSilentlyAsync), METH_VARARGS, nullptr },
        { "terminate_async", reinterpret_cast<PyCFunction>(IsolatedWindowsEnvironment_TerminateAsync), METH_VARARGS, nullptr },
        { "unregister_message_receiver", reinterpret_cast<PyCFunction>(IsolatedWindowsEnvironment_UnregisterMessageReceiver), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_IsolatedWindowsEnvironment, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IsolatedWindowsEnvironment), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IsolatedWindowsEnvironment[] = {
        { "id", reinterpret_cast<getter>(IsolatedWindowsEnvironment_get_Id), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IsolatedWindowsEnvironment[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_IsolatedWindowsEnvironment) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IsolatedWindowsEnvironment) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IsolatedWindowsEnvironment) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IsolatedWindowsEnvironment) },
        { }
    };

    static PyType_Spec type_spec_IsolatedWindowsEnvironment = {
        "winrt._winrt_windows_security_isolation.IsolatedWindowsEnvironment",
        sizeof(py::wrapper::Windows::Security::Isolation::IsolatedWindowsEnvironment),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IsolatedWindowsEnvironment};

    static PyGetSetDef getset_IsolatedWindowsEnvironment_Static[] = {
        { }
    };

    static PyMethodDef methods_IsolatedWindowsEnvironment_Static[] = {
        { "create_async", reinterpret_cast<PyCFunction>(IsolatedWindowsEnvironment_CreateAsync), METH_VARARGS, nullptr },
        { "find_by_owner_id", reinterpret_cast<PyCFunction>(IsolatedWindowsEnvironment_FindByOwnerId), METH_VARARGS, nullptr },
        { "get_by_id", reinterpret_cast<PyCFunction>(IsolatedWindowsEnvironment_GetById), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_IsolatedWindowsEnvironment_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_IsolatedWindowsEnvironment_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_IsolatedWindowsEnvironment_Static) },
        { }
    };

    static PyType_Spec type_spec_IsolatedWindowsEnvironment_Static =
    {
        "winrt._winrt_windows_security_isolation.IsolatedWindowsEnvironment_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_IsolatedWindowsEnvironment_Static
    };

    // ----- IsolatedWindowsEnvironmentCreateResult class --------------------

    static PyObject* _new_IsolatedWindowsEnvironmentCreateResult(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Security::Isolation::IsolatedWindowsEnvironmentCreateResult>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Security::Isolation::IsolatedWindowsEnvironmentCreateResult>::type_name);
        return nullptr;
    }

    static void _dealloc_IsolatedWindowsEnvironmentCreateResult(py::wrapper::Windows::Security::Isolation::IsolatedWindowsEnvironmentCreateResult* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IsolatedWindowsEnvironmentCreateResult_ChangeCreationPriority(py::wrapper::Windows::Security::Isolation::IsolatedWindowsEnvironmentCreateResult* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Security.Isolation.IsolatedWindowsEnvironmentCreateResult", L"ChangeCreationPriority", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Security::Isolation::IsolatedWindowsEnvironmentCreationPriority>(args, 0);

                self->obj.ChangeCreationPriority(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IsolatedWindowsEnvironmentCreateResult_get_Environment(py::wrapper::Windows::Security::Isolation::IsolatedWindowsEnvironmentCreateResult* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Isolation.IsolatedWindowsEnvironmentCreateResult", L"Environment");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Environment());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IsolatedWindowsEnvironmentCreateResult_get_ExtendedError(py::wrapper::Windows::Security::Isolation::IsolatedWindowsEnvironmentCreateResult* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Isolation.IsolatedWindowsEnvironmentCreateResult", L"ExtendedError");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ExtendedError());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IsolatedWindowsEnvironmentCreateResult_get_Status(py::wrapper::Windows::Security::Isolation::IsolatedWindowsEnvironmentCreateResult* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Isolation.IsolatedWindowsEnvironmentCreateResult", L"Status");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_IsolatedWindowsEnvironmentCreateResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Security::Isolation::IsolatedWindowsEnvironmentCreateResult>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IsolatedWindowsEnvironmentCreateResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Security::Isolation::IsolatedWindowsEnvironmentCreateResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IsolatedWindowsEnvironmentCreateResult[] = {
        { "change_creation_priority", reinterpret_cast<PyCFunction>(IsolatedWindowsEnvironmentCreateResult_ChangeCreationPriority), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_IsolatedWindowsEnvironmentCreateResult, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IsolatedWindowsEnvironmentCreateResult), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IsolatedWindowsEnvironmentCreateResult[] = {
        { "environment", reinterpret_cast<getter>(IsolatedWindowsEnvironmentCreateResult_get_Environment), nullptr, nullptr, nullptr },
        { "extended_error", reinterpret_cast<getter>(IsolatedWindowsEnvironmentCreateResult_get_ExtendedError), nullptr, nullptr, nullptr },
        { "status", reinterpret_cast<getter>(IsolatedWindowsEnvironmentCreateResult_get_Status), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IsolatedWindowsEnvironmentCreateResult[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_IsolatedWindowsEnvironmentCreateResult) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IsolatedWindowsEnvironmentCreateResult) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IsolatedWindowsEnvironmentCreateResult) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IsolatedWindowsEnvironmentCreateResult) },
        { }
    };

    static PyType_Spec type_spec_IsolatedWindowsEnvironmentCreateResult = {
        "winrt._winrt_windows_security_isolation.IsolatedWindowsEnvironmentCreateResult",
        sizeof(py::wrapper::Windows::Security::Isolation::IsolatedWindowsEnvironmentCreateResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IsolatedWindowsEnvironmentCreateResult};

    // ----- IsolatedWindowsEnvironmentFile class --------------------

    static PyObject* _new_IsolatedWindowsEnvironmentFile(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Security::Isolation::IsolatedWindowsEnvironmentFile>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Security::Isolation::IsolatedWindowsEnvironmentFile>::type_name);
        return nullptr;
    }

    static void _dealloc_IsolatedWindowsEnvironmentFile(py::wrapper::Windows::Security::Isolation::IsolatedWindowsEnvironmentFile* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IsolatedWindowsEnvironmentFile_Close(py::wrapper::Windows::Security::Isolation::IsolatedWindowsEnvironmentFile* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Security.Isolation.IsolatedWindowsEnvironmentFile", L"Close", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IsolatedWindowsEnvironmentFile_get_HostPath(py::wrapper::Windows::Security::Isolation::IsolatedWindowsEnvironmentFile* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Isolation.IsolatedWindowsEnvironmentFile", L"HostPath");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.HostPath());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IsolatedWindowsEnvironmentFile_get_Id(py::wrapper::Windows::Security::Isolation::IsolatedWindowsEnvironmentFile* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Isolation.IsolatedWindowsEnvironmentFile", L"Id");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Id());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IsolatedWindowsEnvironmentFile_get_GuestPath(py::wrapper::Windows::Security::Isolation::IsolatedWindowsEnvironmentFile* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Isolation.IsolatedWindowsEnvironmentFile", L"GuestPath");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.GuestPath());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IsolatedWindowsEnvironmentFile_get_IsReadOnly(py::wrapper::Windows::Security::Isolation::IsolatedWindowsEnvironmentFile* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Isolation.IsolatedWindowsEnvironmentFile", L"IsReadOnly");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsReadOnly());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_IsolatedWindowsEnvironmentFile(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Security::Isolation::IsolatedWindowsEnvironmentFile>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IsolatedWindowsEnvironmentFile(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Security::Isolation::IsolatedWindowsEnvironmentFile>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IsolatedWindowsEnvironmentFile[] = {
        { "close", reinterpret_cast<PyCFunction>(IsolatedWindowsEnvironmentFile_Close), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_IsolatedWindowsEnvironmentFile, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IsolatedWindowsEnvironmentFile), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IsolatedWindowsEnvironmentFile[] = {
        { "host_path", reinterpret_cast<getter>(IsolatedWindowsEnvironmentFile_get_HostPath), nullptr, nullptr, nullptr },
        { "id", reinterpret_cast<getter>(IsolatedWindowsEnvironmentFile_get_Id), nullptr, nullptr, nullptr },
        { "guest_path", reinterpret_cast<getter>(IsolatedWindowsEnvironmentFile_get_GuestPath), nullptr, nullptr, nullptr },
        { "is_read_only", reinterpret_cast<getter>(IsolatedWindowsEnvironmentFile_get_IsReadOnly), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IsolatedWindowsEnvironmentFile[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_IsolatedWindowsEnvironmentFile) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IsolatedWindowsEnvironmentFile) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IsolatedWindowsEnvironmentFile) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IsolatedWindowsEnvironmentFile) },
        { }
    };

    static PyType_Spec type_spec_IsolatedWindowsEnvironmentFile = {
        "winrt._winrt_windows_security_isolation.IsolatedWindowsEnvironmentFile",
        sizeof(py::wrapper::Windows::Security::Isolation::IsolatedWindowsEnvironmentFile),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IsolatedWindowsEnvironmentFile};

    // ----- IsolatedWindowsEnvironmentHost class --------------------

    static PyObject* _new_IsolatedWindowsEnvironmentHost(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Security::Isolation::IsolatedWindowsEnvironmentHost>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Security::Isolation::IsolatedWindowsEnvironmentHost>::type_name);
        return nullptr;
    }

    static PyObject* IsolatedWindowsEnvironmentHost_get_HostErrors(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Isolation.IsolatedWindowsEnvironmentHost", L"HostErrors");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Security::Isolation::IsolatedWindowsEnvironmentHost::HostErrors());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IsolatedWindowsEnvironmentHost_get_IsReady(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Isolation.IsolatedWindowsEnvironmentHost", L"IsReady");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Security::Isolation::IsolatedWindowsEnvironmentHost::IsReady());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IsolatedWindowsEnvironmentHost[] = {
        { }
    };

    static PyGetSetDef _getset_IsolatedWindowsEnvironmentHost[] = {
        { }
    };

    static PyType_Slot _type_slots_IsolatedWindowsEnvironmentHost[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_IsolatedWindowsEnvironmentHost) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IsolatedWindowsEnvironmentHost) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IsolatedWindowsEnvironmentHost) },
        { }
    };

    static PyType_Spec type_spec_IsolatedWindowsEnvironmentHost = {
        "winrt._winrt_windows_security_isolation.IsolatedWindowsEnvironmentHost",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IsolatedWindowsEnvironmentHost};

    static PyGetSetDef getset_IsolatedWindowsEnvironmentHost_Static[] = {
        { "host_errors", reinterpret_cast<getter>(IsolatedWindowsEnvironmentHost_get_HostErrors), nullptr, nullptr, nullptr },
        { "is_ready", reinterpret_cast<getter>(IsolatedWindowsEnvironmentHost_get_IsReady), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_IsolatedWindowsEnvironmentHost_Static[] = {
        { }
    };

    static PyType_Slot type_slots_IsolatedWindowsEnvironmentHost_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_IsolatedWindowsEnvironmentHost_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_IsolatedWindowsEnvironmentHost_Static) },
        { }
    };

    static PyType_Spec type_spec_IsolatedWindowsEnvironmentHost_Static =
    {
        "winrt._winrt_windows_security_isolation.IsolatedWindowsEnvironmentHost_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_IsolatedWindowsEnvironmentHost_Static
    };

    // ----- IsolatedWindowsEnvironmentLaunchFileResult class --------------------

    static PyObject* _new_IsolatedWindowsEnvironmentLaunchFileResult(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Security::Isolation::IsolatedWindowsEnvironmentLaunchFileResult>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Security::Isolation::IsolatedWindowsEnvironmentLaunchFileResult>::type_name);
        return nullptr;
    }

    static void _dealloc_IsolatedWindowsEnvironmentLaunchFileResult(py::wrapper::Windows::Security::Isolation::IsolatedWindowsEnvironmentLaunchFileResult* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IsolatedWindowsEnvironmentLaunchFileResult_get_ExtendedError(py::wrapper::Windows::Security::Isolation::IsolatedWindowsEnvironmentLaunchFileResult* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Isolation.IsolatedWindowsEnvironmentLaunchFileResult", L"ExtendedError");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ExtendedError());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IsolatedWindowsEnvironmentLaunchFileResult_get_File(py::wrapper::Windows::Security::Isolation::IsolatedWindowsEnvironmentLaunchFileResult* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Isolation.IsolatedWindowsEnvironmentLaunchFileResult", L"File");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.File());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IsolatedWindowsEnvironmentLaunchFileResult_get_Status(py::wrapper::Windows::Security::Isolation::IsolatedWindowsEnvironmentLaunchFileResult* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Isolation.IsolatedWindowsEnvironmentLaunchFileResult", L"Status");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_IsolatedWindowsEnvironmentLaunchFileResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Security::Isolation::IsolatedWindowsEnvironmentLaunchFileResult>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IsolatedWindowsEnvironmentLaunchFileResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Security::Isolation::IsolatedWindowsEnvironmentLaunchFileResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IsolatedWindowsEnvironmentLaunchFileResult[] = {
        { "_assign_array_", _assign_array_IsolatedWindowsEnvironmentLaunchFileResult, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IsolatedWindowsEnvironmentLaunchFileResult), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IsolatedWindowsEnvironmentLaunchFileResult[] = {
        { "extended_error", reinterpret_cast<getter>(IsolatedWindowsEnvironmentLaunchFileResult_get_ExtendedError), nullptr, nullptr, nullptr },
        { "file", reinterpret_cast<getter>(IsolatedWindowsEnvironmentLaunchFileResult_get_File), nullptr, nullptr, nullptr },
        { "status", reinterpret_cast<getter>(IsolatedWindowsEnvironmentLaunchFileResult_get_Status), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IsolatedWindowsEnvironmentLaunchFileResult[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_IsolatedWindowsEnvironmentLaunchFileResult) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IsolatedWindowsEnvironmentLaunchFileResult) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IsolatedWindowsEnvironmentLaunchFileResult) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IsolatedWindowsEnvironmentLaunchFileResult) },
        { }
    };

    static PyType_Spec type_spec_IsolatedWindowsEnvironmentLaunchFileResult = {
        "winrt._winrt_windows_security_isolation.IsolatedWindowsEnvironmentLaunchFileResult",
        sizeof(py::wrapper::Windows::Security::Isolation::IsolatedWindowsEnvironmentLaunchFileResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IsolatedWindowsEnvironmentLaunchFileResult};

    // ----- IsolatedWindowsEnvironmentOptions class --------------------

    static PyObject* _new_IsolatedWindowsEnvironmentOptions(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Security::Isolation::IsolatedWindowsEnvironmentOptions instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_IsolatedWindowsEnvironmentOptions(py::wrapper::Windows::Security::Isolation::IsolatedWindowsEnvironmentOptions* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IsolatedWindowsEnvironmentOptions_ShareHostFolderForUntrustedItems(py::wrapper::Windows::Security::Isolation::IsolatedWindowsEnvironmentOptions* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Security.Isolation.IsolatedWindowsEnvironmentOptions", L"ShareHostFolderForUntrustedItems", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                self->obj.ShareHostFolderForUntrustedItems(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IsolatedWindowsEnvironmentOptions_get_PersistUserProfile(py::wrapper::Windows::Security::Isolation::IsolatedWindowsEnvironmentOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Isolation.IsolatedWindowsEnvironmentOptions", L"PersistUserProfile");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.PersistUserProfile());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IsolatedWindowsEnvironmentOptions_put_PersistUserProfile(py::wrapper::Windows::Security::Isolation::IsolatedWindowsEnvironmentOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Isolation.IsolatedWindowsEnvironmentOptions", L"PersistUserProfile");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.PersistUserProfile(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* IsolatedWindowsEnvironmentOptions_get_EnvironmentOwnerId(py::wrapper::Windows::Security::Isolation::IsolatedWindowsEnvironmentOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Isolation.IsolatedWindowsEnvironmentOptions", L"EnvironmentOwnerId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.EnvironmentOwnerId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IsolatedWindowsEnvironmentOptions_put_EnvironmentOwnerId(py::wrapper::Windows::Security::Isolation::IsolatedWindowsEnvironmentOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Isolation.IsolatedWindowsEnvironmentOptions", L"EnvironmentOwnerId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.EnvironmentOwnerId(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* IsolatedWindowsEnvironmentOptions_get_ClipboardCopyPasteDirections(py::wrapper::Windows::Security::Isolation::IsolatedWindowsEnvironmentOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Isolation.IsolatedWindowsEnvironmentOptions", L"ClipboardCopyPasteDirections");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ClipboardCopyPasteDirections());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IsolatedWindowsEnvironmentOptions_put_ClipboardCopyPasteDirections(py::wrapper::Windows::Security::Isolation::IsolatedWindowsEnvironmentOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Isolation.IsolatedWindowsEnvironmentOptions", L"ClipboardCopyPasteDirections");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Security::Isolation::IsolatedWindowsEnvironmentClipboardCopyPasteDirections>(arg);

            self->obj.ClipboardCopyPasteDirections(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* IsolatedWindowsEnvironmentOptions_get_AvailablePrinters(py::wrapper::Windows::Security::Isolation::IsolatedWindowsEnvironmentOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Isolation.IsolatedWindowsEnvironmentOptions", L"AvailablePrinters");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.AvailablePrinters());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IsolatedWindowsEnvironmentOptions_put_AvailablePrinters(py::wrapper::Windows::Security::Isolation::IsolatedWindowsEnvironmentOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Isolation.IsolatedWindowsEnvironmentOptions", L"AvailablePrinters");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Security::Isolation::IsolatedWindowsEnvironmentAvailablePrinters>(arg);

            self->obj.AvailablePrinters(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* IsolatedWindowsEnvironmentOptions_get_AllowedClipboardFormats(py::wrapper::Windows::Security::Isolation::IsolatedWindowsEnvironmentOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Isolation.IsolatedWindowsEnvironmentOptions", L"AllowedClipboardFormats");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.AllowedClipboardFormats());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IsolatedWindowsEnvironmentOptions_put_AllowedClipboardFormats(py::wrapper::Windows::Security::Isolation::IsolatedWindowsEnvironmentOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Isolation.IsolatedWindowsEnvironmentOptions", L"AllowedClipboardFormats");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Security::Isolation::IsolatedWindowsEnvironmentAllowedClipboardFormats>(arg);

            self->obj.AllowedClipboardFormats(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* IsolatedWindowsEnvironmentOptions_get_AllowGraphicsHardwareAcceleration(py::wrapper::Windows::Security::Isolation::IsolatedWindowsEnvironmentOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Isolation.IsolatedWindowsEnvironmentOptions", L"AllowGraphicsHardwareAcceleration");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.AllowGraphicsHardwareAcceleration());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IsolatedWindowsEnvironmentOptions_put_AllowGraphicsHardwareAcceleration(py::wrapper::Windows::Security::Isolation::IsolatedWindowsEnvironmentOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Isolation.IsolatedWindowsEnvironmentOptions", L"AllowGraphicsHardwareAcceleration");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.AllowGraphicsHardwareAcceleration(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* IsolatedWindowsEnvironmentOptions_get_AllowCameraAndMicrophoneAccess(py::wrapper::Windows::Security::Isolation::IsolatedWindowsEnvironmentOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Isolation.IsolatedWindowsEnvironmentOptions", L"AllowCameraAndMicrophoneAccess");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.AllowCameraAndMicrophoneAccess());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IsolatedWindowsEnvironmentOptions_put_AllowCameraAndMicrophoneAccess(py::wrapper::Windows::Security::Isolation::IsolatedWindowsEnvironmentOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Isolation.IsolatedWindowsEnvironmentOptions", L"AllowCameraAndMicrophoneAccess");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.AllowCameraAndMicrophoneAccess(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* IsolatedWindowsEnvironmentOptions_get_SharedFolderNameInEnvironment(py::wrapper::Windows::Security::Isolation::IsolatedWindowsEnvironmentOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Isolation.IsolatedWindowsEnvironmentOptions", L"SharedFolderNameInEnvironment");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SharedFolderNameInEnvironment());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IsolatedWindowsEnvironmentOptions_get_SharedHostFolderPath(py::wrapper::Windows::Security::Isolation::IsolatedWindowsEnvironmentOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Isolation.IsolatedWindowsEnvironmentOptions", L"SharedHostFolderPath");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SharedHostFolderPath());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IsolatedWindowsEnvironmentOptions_get_WindowAnnotationOverride(py::wrapper::Windows::Security::Isolation::IsolatedWindowsEnvironmentOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Isolation.IsolatedWindowsEnvironmentOptions", L"WindowAnnotationOverride");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.WindowAnnotationOverride());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IsolatedWindowsEnvironmentOptions_put_WindowAnnotationOverride(py::wrapper::Windows::Security::Isolation::IsolatedWindowsEnvironmentOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Isolation.IsolatedWindowsEnvironmentOptions", L"WindowAnnotationOverride");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.WindowAnnotationOverride(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* IsolatedWindowsEnvironmentOptions_get_CreationPriority(py::wrapper::Windows::Security::Isolation::IsolatedWindowsEnvironmentOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Isolation.IsolatedWindowsEnvironmentOptions", L"CreationPriority");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CreationPriority());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IsolatedWindowsEnvironmentOptions_put_CreationPriority(py::wrapper::Windows::Security::Isolation::IsolatedWindowsEnvironmentOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Isolation.IsolatedWindowsEnvironmentOptions", L"CreationPriority");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Security::Isolation::IsolatedWindowsEnvironmentCreationPriority>(arg);

            self->obj.CreationPriority(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* IsolatedWindowsEnvironmentOptions_get_AllowedClipboardFormatsToHost(py::wrapper::Windows::Security::Isolation::IsolatedWindowsEnvironmentOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Isolation.IsolatedWindowsEnvironmentOptions", L"AllowedClipboardFormatsToHost");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.AllowedClipboardFormatsToHost());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IsolatedWindowsEnvironmentOptions_put_AllowedClipboardFormatsToHost(py::wrapper::Windows::Security::Isolation::IsolatedWindowsEnvironmentOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Isolation.IsolatedWindowsEnvironmentOptions", L"AllowedClipboardFormatsToHost");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Security::Isolation::IsolatedWindowsEnvironmentAllowedClipboardFormats>(arg);

            self->obj.AllowedClipboardFormatsToHost(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* IsolatedWindowsEnvironmentOptions_get_AllowedClipboardFormatsToEnvironment(py::wrapper::Windows::Security::Isolation::IsolatedWindowsEnvironmentOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Isolation.IsolatedWindowsEnvironmentOptions", L"AllowedClipboardFormatsToEnvironment");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.AllowedClipboardFormatsToEnvironment());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IsolatedWindowsEnvironmentOptions_put_AllowedClipboardFormatsToEnvironment(py::wrapper::Windows::Security::Isolation::IsolatedWindowsEnvironmentOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Isolation.IsolatedWindowsEnvironmentOptions", L"AllowedClipboardFormatsToEnvironment");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Security::Isolation::IsolatedWindowsEnvironmentAllowedClipboardFormats>(arg);

            self->obj.AllowedClipboardFormatsToEnvironment(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_IsolatedWindowsEnvironmentOptions(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Security::Isolation::IsolatedWindowsEnvironmentOptions>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IsolatedWindowsEnvironmentOptions(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Security::Isolation::IsolatedWindowsEnvironmentOptions>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IsolatedWindowsEnvironmentOptions[] = {
        { "share_host_folder_for_untrusted_items", reinterpret_cast<PyCFunction>(IsolatedWindowsEnvironmentOptions_ShareHostFolderForUntrustedItems), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_IsolatedWindowsEnvironmentOptions, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IsolatedWindowsEnvironmentOptions), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IsolatedWindowsEnvironmentOptions[] = {
        { "persist_user_profile", reinterpret_cast<getter>(IsolatedWindowsEnvironmentOptions_get_PersistUserProfile), reinterpret_cast<setter>(IsolatedWindowsEnvironmentOptions_put_PersistUserProfile), nullptr, nullptr },
        { "environment_owner_id", reinterpret_cast<getter>(IsolatedWindowsEnvironmentOptions_get_EnvironmentOwnerId), reinterpret_cast<setter>(IsolatedWindowsEnvironmentOptions_put_EnvironmentOwnerId), nullptr, nullptr },
        { "clipboard_copy_paste_directions", reinterpret_cast<getter>(IsolatedWindowsEnvironmentOptions_get_ClipboardCopyPasteDirections), reinterpret_cast<setter>(IsolatedWindowsEnvironmentOptions_put_ClipboardCopyPasteDirections), nullptr, nullptr },
        { "available_printers", reinterpret_cast<getter>(IsolatedWindowsEnvironmentOptions_get_AvailablePrinters), reinterpret_cast<setter>(IsolatedWindowsEnvironmentOptions_put_AvailablePrinters), nullptr, nullptr },
        { "allowed_clipboard_formats", reinterpret_cast<getter>(IsolatedWindowsEnvironmentOptions_get_AllowedClipboardFormats), reinterpret_cast<setter>(IsolatedWindowsEnvironmentOptions_put_AllowedClipboardFormats), nullptr, nullptr },
        { "allow_graphics_hardware_acceleration", reinterpret_cast<getter>(IsolatedWindowsEnvironmentOptions_get_AllowGraphicsHardwareAcceleration), reinterpret_cast<setter>(IsolatedWindowsEnvironmentOptions_put_AllowGraphicsHardwareAcceleration), nullptr, nullptr },
        { "allow_camera_and_microphone_access", reinterpret_cast<getter>(IsolatedWindowsEnvironmentOptions_get_AllowCameraAndMicrophoneAccess), reinterpret_cast<setter>(IsolatedWindowsEnvironmentOptions_put_AllowCameraAndMicrophoneAccess), nullptr, nullptr },
        { "shared_folder_name_in_environment", reinterpret_cast<getter>(IsolatedWindowsEnvironmentOptions_get_SharedFolderNameInEnvironment), nullptr, nullptr, nullptr },
        { "shared_host_folder_path", reinterpret_cast<getter>(IsolatedWindowsEnvironmentOptions_get_SharedHostFolderPath), nullptr, nullptr, nullptr },
        { "window_annotation_override", reinterpret_cast<getter>(IsolatedWindowsEnvironmentOptions_get_WindowAnnotationOverride), reinterpret_cast<setter>(IsolatedWindowsEnvironmentOptions_put_WindowAnnotationOverride), nullptr, nullptr },
        { "creation_priority", reinterpret_cast<getter>(IsolatedWindowsEnvironmentOptions_get_CreationPriority), reinterpret_cast<setter>(IsolatedWindowsEnvironmentOptions_put_CreationPriority), nullptr, nullptr },
        { "allowed_clipboard_formats_to_host", reinterpret_cast<getter>(IsolatedWindowsEnvironmentOptions_get_AllowedClipboardFormatsToHost), reinterpret_cast<setter>(IsolatedWindowsEnvironmentOptions_put_AllowedClipboardFormatsToHost), nullptr, nullptr },
        { "allowed_clipboard_formats_to_environment", reinterpret_cast<getter>(IsolatedWindowsEnvironmentOptions_get_AllowedClipboardFormatsToEnvironment), reinterpret_cast<setter>(IsolatedWindowsEnvironmentOptions_put_AllowedClipboardFormatsToEnvironment), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IsolatedWindowsEnvironmentOptions[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_IsolatedWindowsEnvironmentOptions) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IsolatedWindowsEnvironmentOptions) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IsolatedWindowsEnvironmentOptions) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IsolatedWindowsEnvironmentOptions) },
        { }
    };

    static PyType_Spec type_spec_IsolatedWindowsEnvironmentOptions = {
        "winrt._winrt_windows_security_isolation.IsolatedWindowsEnvironmentOptions",
        sizeof(py::wrapper::Windows::Security::Isolation::IsolatedWindowsEnvironmentOptions),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IsolatedWindowsEnvironmentOptions};

    // ----- IsolatedWindowsEnvironmentOwnerRegistration class --------------------

    static PyObject* _new_IsolatedWindowsEnvironmentOwnerRegistration(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Security::Isolation::IsolatedWindowsEnvironmentOwnerRegistration>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Security::Isolation::IsolatedWindowsEnvironmentOwnerRegistration>::type_name);
        return nullptr;
    }

    static PyObject* IsolatedWindowsEnvironmentOwnerRegistration_Register(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Security.Isolation.IsolatedWindowsEnvironmentOwnerRegistration", L"Register", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Security::Isolation::IsolatedWindowsEnvironmentOwnerRegistrationData>(args, 1);

                return py::convert(winrt::Windows::Security::Isolation::IsolatedWindowsEnvironmentOwnerRegistration::Register(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IsolatedWindowsEnvironmentOwnerRegistration_Unregister(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Security.Isolation.IsolatedWindowsEnvironmentOwnerRegistration", L"Unregister", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                winrt::Windows::Security::Isolation::IsolatedWindowsEnvironmentOwnerRegistration::Unregister(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyMethodDef _methods_IsolatedWindowsEnvironmentOwnerRegistration[] = {
        { }
    };

    static PyGetSetDef _getset_IsolatedWindowsEnvironmentOwnerRegistration[] = {
        { }
    };

    static PyType_Slot _type_slots_IsolatedWindowsEnvironmentOwnerRegistration[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_IsolatedWindowsEnvironmentOwnerRegistration) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IsolatedWindowsEnvironmentOwnerRegistration) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IsolatedWindowsEnvironmentOwnerRegistration) },
        { }
    };

    static PyType_Spec type_spec_IsolatedWindowsEnvironmentOwnerRegistration = {
        "winrt._winrt_windows_security_isolation.IsolatedWindowsEnvironmentOwnerRegistration",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IsolatedWindowsEnvironmentOwnerRegistration};

    static PyGetSetDef getset_IsolatedWindowsEnvironmentOwnerRegistration_Static[] = {
        { }
    };

    static PyMethodDef methods_IsolatedWindowsEnvironmentOwnerRegistration_Static[] = {
        { "register", reinterpret_cast<PyCFunction>(IsolatedWindowsEnvironmentOwnerRegistration_Register), METH_VARARGS, nullptr },
        { "unregister", reinterpret_cast<PyCFunction>(IsolatedWindowsEnvironmentOwnerRegistration_Unregister), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_IsolatedWindowsEnvironmentOwnerRegistration_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_IsolatedWindowsEnvironmentOwnerRegistration_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_IsolatedWindowsEnvironmentOwnerRegistration_Static) },
        { }
    };

    static PyType_Spec type_spec_IsolatedWindowsEnvironmentOwnerRegistration_Static =
    {
        "winrt._winrt_windows_security_isolation.IsolatedWindowsEnvironmentOwnerRegistration_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_IsolatedWindowsEnvironmentOwnerRegistration_Static
    };

    // ----- IsolatedWindowsEnvironmentOwnerRegistrationData class --------------------

    static PyObject* _new_IsolatedWindowsEnvironmentOwnerRegistrationData(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Security::Isolation::IsolatedWindowsEnvironmentOwnerRegistrationData instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_IsolatedWindowsEnvironmentOwnerRegistrationData(py::wrapper::Windows::Security::Isolation::IsolatedWindowsEnvironmentOwnerRegistrationData* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IsolatedWindowsEnvironmentOwnerRegistrationData_get_ActivationFileExtensions(py::wrapper::Windows::Security::Isolation::IsolatedWindowsEnvironmentOwnerRegistrationData* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Isolation.IsolatedWindowsEnvironmentOwnerRegistrationData", L"ActivationFileExtensions");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ActivationFileExtensions());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IsolatedWindowsEnvironmentOwnerRegistrationData_get_ProcessesRunnableAsSystem(py::wrapper::Windows::Security::Isolation::IsolatedWindowsEnvironmentOwnerRegistrationData* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Isolation.IsolatedWindowsEnvironmentOwnerRegistrationData", L"ProcessesRunnableAsSystem");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ProcessesRunnableAsSystem());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IsolatedWindowsEnvironmentOwnerRegistrationData_get_ProcessesRunnableAsUser(py::wrapper::Windows::Security::Isolation::IsolatedWindowsEnvironmentOwnerRegistrationData* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Isolation.IsolatedWindowsEnvironmentOwnerRegistrationData", L"ProcessesRunnableAsUser");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ProcessesRunnableAsUser());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IsolatedWindowsEnvironmentOwnerRegistrationData_get_ShareableFolders(py::wrapper::Windows::Security::Isolation::IsolatedWindowsEnvironmentOwnerRegistrationData* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Isolation.IsolatedWindowsEnvironmentOwnerRegistrationData", L"ShareableFolders");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ShareableFolders());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_IsolatedWindowsEnvironmentOwnerRegistrationData(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Security::Isolation::IsolatedWindowsEnvironmentOwnerRegistrationData>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IsolatedWindowsEnvironmentOwnerRegistrationData(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Security::Isolation::IsolatedWindowsEnvironmentOwnerRegistrationData>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IsolatedWindowsEnvironmentOwnerRegistrationData[] = {
        { "_assign_array_", _assign_array_IsolatedWindowsEnvironmentOwnerRegistrationData, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IsolatedWindowsEnvironmentOwnerRegistrationData), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IsolatedWindowsEnvironmentOwnerRegistrationData[] = {
        { "activation_file_extensions", reinterpret_cast<getter>(IsolatedWindowsEnvironmentOwnerRegistrationData_get_ActivationFileExtensions), nullptr, nullptr, nullptr },
        { "processes_runnable_as_system", reinterpret_cast<getter>(IsolatedWindowsEnvironmentOwnerRegistrationData_get_ProcessesRunnableAsSystem), nullptr, nullptr, nullptr },
        { "processes_runnable_as_user", reinterpret_cast<getter>(IsolatedWindowsEnvironmentOwnerRegistrationData_get_ProcessesRunnableAsUser), nullptr, nullptr, nullptr },
        { "shareable_folders", reinterpret_cast<getter>(IsolatedWindowsEnvironmentOwnerRegistrationData_get_ShareableFolders), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IsolatedWindowsEnvironmentOwnerRegistrationData[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_IsolatedWindowsEnvironmentOwnerRegistrationData) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IsolatedWindowsEnvironmentOwnerRegistrationData) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IsolatedWindowsEnvironmentOwnerRegistrationData) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IsolatedWindowsEnvironmentOwnerRegistrationData) },
        { }
    };

    static PyType_Spec type_spec_IsolatedWindowsEnvironmentOwnerRegistrationData = {
        "winrt._winrt_windows_security_isolation.IsolatedWindowsEnvironmentOwnerRegistrationData",
        sizeof(py::wrapper::Windows::Security::Isolation::IsolatedWindowsEnvironmentOwnerRegistrationData),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IsolatedWindowsEnvironmentOwnerRegistrationData};

    // ----- IsolatedWindowsEnvironmentOwnerRegistrationResult class --------------------

    static PyObject* _new_IsolatedWindowsEnvironmentOwnerRegistrationResult(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Security::Isolation::IsolatedWindowsEnvironmentOwnerRegistrationResult>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Security::Isolation::IsolatedWindowsEnvironmentOwnerRegistrationResult>::type_name);
        return nullptr;
    }

    static void _dealloc_IsolatedWindowsEnvironmentOwnerRegistrationResult(py::wrapper::Windows::Security::Isolation::IsolatedWindowsEnvironmentOwnerRegistrationResult* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IsolatedWindowsEnvironmentOwnerRegistrationResult_get_ExtendedError(py::wrapper::Windows::Security::Isolation::IsolatedWindowsEnvironmentOwnerRegistrationResult* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Isolation.IsolatedWindowsEnvironmentOwnerRegistrationResult", L"ExtendedError");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ExtendedError());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IsolatedWindowsEnvironmentOwnerRegistrationResult_get_Status(py::wrapper::Windows::Security::Isolation::IsolatedWindowsEnvironmentOwnerRegistrationResult* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Isolation.IsolatedWindowsEnvironmentOwnerRegistrationResult", L"Status");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_IsolatedWindowsEnvironmentOwnerRegistrationResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Security::Isolation::IsolatedWindowsEnvironmentOwnerRegistrationResult>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IsolatedWindowsEnvironmentOwnerRegistrationResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Security::Isolation::IsolatedWindowsEnvironmentOwnerRegistrationResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IsolatedWindowsEnvironmentOwnerRegistrationResult[] = {
        { "_assign_array_", _assign_array_IsolatedWindowsEnvironmentOwnerRegistrationResult, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IsolatedWindowsEnvironmentOwnerRegistrationResult), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IsolatedWindowsEnvironmentOwnerRegistrationResult[] = {
        { "extended_error", reinterpret_cast<getter>(IsolatedWindowsEnvironmentOwnerRegistrationResult_get_ExtendedError), nullptr, nullptr, nullptr },
        { "status", reinterpret_cast<getter>(IsolatedWindowsEnvironmentOwnerRegistrationResult_get_Status), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IsolatedWindowsEnvironmentOwnerRegistrationResult[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_IsolatedWindowsEnvironmentOwnerRegistrationResult) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IsolatedWindowsEnvironmentOwnerRegistrationResult) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IsolatedWindowsEnvironmentOwnerRegistrationResult) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IsolatedWindowsEnvironmentOwnerRegistrationResult) },
        { }
    };

    static PyType_Spec type_spec_IsolatedWindowsEnvironmentOwnerRegistrationResult = {
        "winrt._winrt_windows_security_isolation.IsolatedWindowsEnvironmentOwnerRegistrationResult",
        sizeof(py::wrapper::Windows::Security::Isolation::IsolatedWindowsEnvironmentOwnerRegistrationResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IsolatedWindowsEnvironmentOwnerRegistrationResult};

    // ----- IsolatedWindowsEnvironmentPostMessageResult class --------------------

    static PyObject* _new_IsolatedWindowsEnvironmentPostMessageResult(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Security::Isolation::IsolatedWindowsEnvironmentPostMessageResult>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Security::Isolation::IsolatedWindowsEnvironmentPostMessageResult>::type_name);
        return nullptr;
    }

    static void _dealloc_IsolatedWindowsEnvironmentPostMessageResult(py::wrapper::Windows::Security::Isolation::IsolatedWindowsEnvironmentPostMessageResult* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IsolatedWindowsEnvironmentPostMessageResult_get_ExtendedError(py::wrapper::Windows::Security::Isolation::IsolatedWindowsEnvironmentPostMessageResult* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Isolation.IsolatedWindowsEnvironmentPostMessageResult", L"ExtendedError");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ExtendedError());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IsolatedWindowsEnvironmentPostMessageResult_get_Status(py::wrapper::Windows::Security::Isolation::IsolatedWindowsEnvironmentPostMessageResult* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Isolation.IsolatedWindowsEnvironmentPostMessageResult", L"Status");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_IsolatedWindowsEnvironmentPostMessageResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Security::Isolation::IsolatedWindowsEnvironmentPostMessageResult>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IsolatedWindowsEnvironmentPostMessageResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Security::Isolation::IsolatedWindowsEnvironmentPostMessageResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IsolatedWindowsEnvironmentPostMessageResult[] = {
        { "_assign_array_", _assign_array_IsolatedWindowsEnvironmentPostMessageResult, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IsolatedWindowsEnvironmentPostMessageResult), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IsolatedWindowsEnvironmentPostMessageResult[] = {
        { "extended_error", reinterpret_cast<getter>(IsolatedWindowsEnvironmentPostMessageResult_get_ExtendedError), nullptr, nullptr, nullptr },
        { "status", reinterpret_cast<getter>(IsolatedWindowsEnvironmentPostMessageResult_get_Status), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IsolatedWindowsEnvironmentPostMessageResult[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_IsolatedWindowsEnvironmentPostMessageResult) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IsolatedWindowsEnvironmentPostMessageResult) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IsolatedWindowsEnvironmentPostMessageResult) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IsolatedWindowsEnvironmentPostMessageResult) },
        { }
    };

    static PyType_Spec type_spec_IsolatedWindowsEnvironmentPostMessageResult = {
        "winrt._winrt_windows_security_isolation.IsolatedWindowsEnvironmentPostMessageResult",
        sizeof(py::wrapper::Windows::Security::Isolation::IsolatedWindowsEnvironmentPostMessageResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IsolatedWindowsEnvironmentPostMessageResult};

    // ----- IsolatedWindowsEnvironmentProcess class --------------------

    static PyObject* _new_IsolatedWindowsEnvironmentProcess(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Security::Isolation::IsolatedWindowsEnvironmentProcess>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Security::Isolation::IsolatedWindowsEnvironmentProcess>::type_name);
        return nullptr;
    }

    static void _dealloc_IsolatedWindowsEnvironmentProcess(py::wrapper::Windows::Security::Isolation::IsolatedWindowsEnvironmentProcess* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IsolatedWindowsEnvironmentProcess_WaitForExit(py::wrapper::Windows::Security::Isolation::IsolatedWindowsEnvironmentProcess* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Security.Isolation.IsolatedWindowsEnvironmentProcess", L"WaitForExit", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.WaitForExit();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IsolatedWindowsEnvironmentProcess_WaitForExitAsync(py::wrapper::Windows::Security::Isolation::IsolatedWindowsEnvironmentProcess* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Security.Isolation.IsolatedWindowsEnvironmentProcess", L"WaitForExitAsync", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.WaitForExitAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IsolatedWindowsEnvironmentProcess_WaitForExitWithTimeout(py::wrapper::Windows::Security::Isolation::IsolatedWindowsEnvironmentProcess* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Security.Isolation.IsolatedWindowsEnvironmentProcess", L"WaitForExitWithTimeout", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint32_t>(args, 0);

                self->obj.WaitForExitWithTimeout(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IsolatedWindowsEnvironmentProcess_get_ExitCode(py::wrapper::Windows::Security::Isolation::IsolatedWindowsEnvironmentProcess* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Isolation.IsolatedWindowsEnvironmentProcess", L"ExitCode");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ExitCode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IsolatedWindowsEnvironmentProcess_get_State(py::wrapper::Windows::Security::Isolation::IsolatedWindowsEnvironmentProcess* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Isolation.IsolatedWindowsEnvironmentProcess", L"State");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.State());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_IsolatedWindowsEnvironmentProcess(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Security::Isolation::IsolatedWindowsEnvironmentProcess>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IsolatedWindowsEnvironmentProcess(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Security::Isolation::IsolatedWindowsEnvironmentProcess>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IsolatedWindowsEnvironmentProcess[] = {
        { "wait_for_exit", reinterpret_cast<PyCFunction>(IsolatedWindowsEnvironmentProcess_WaitForExit), METH_VARARGS, nullptr },
        { "wait_for_exit_async", reinterpret_cast<PyCFunction>(IsolatedWindowsEnvironmentProcess_WaitForExitAsync), METH_VARARGS, nullptr },
        { "wait_for_exit_with_timeout", reinterpret_cast<PyCFunction>(IsolatedWindowsEnvironmentProcess_WaitForExitWithTimeout), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_IsolatedWindowsEnvironmentProcess, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IsolatedWindowsEnvironmentProcess), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IsolatedWindowsEnvironmentProcess[] = {
        { "exit_code", reinterpret_cast<getter>(IsolatedWindowsEnvironmentProcess_get_ExitCode), nullptr, nullptr, nullptr },
        { "state", reinterpret_cast<getter>(IsolatedWindowsEnvironmentProcess_get_State), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IsolatedWindowsEnvironmentProcess[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_IsolatedWindowsEnvironmentProcess) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IsolatedWindowsEnvironmentProcess) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IsolatedWindowsEnvironmentProcess) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IsolatedWindowsEnvironmentProcess) },
        { }
    };

    static PyType_Spec type_spec_IsolatedWindowsEnvironmentProcess = {
        "winrt._winrt_windows_security_isolation.IsolatedWindowsEnvironmentProcess",
        sizeof(py::wrapper::Windows::Security::Isolation::IsolatedWindowsEnvironmentProcess),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IsolatedWindowsEnvironmentProcess};

    // ----- IsolatedWindowsEnvironmentShareFileRequestOptions class --------------------

    static PyObject* _new_IsolatedWindowsEnvironmentShareFileRequestOptions(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Security::Isolation::IsolatedWindowsEnvironmentShareFileRequestOptions instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_IsolatedWindowsEnvironmentShareFileRequestOptions(py::wrapper::Windows::Security::Isolation::IsolatedWindowsEnvironmentShareFileRequestOptions* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IsolatedWindowsEnvironmentShareFileRequestOptions_get_AllowWrite(py::wrapper::Windows::Security::Isolation::IsolatedWindowsEnvironmentShareFileRequestOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Isolation.IsolatedWindowsEnvironmentShareFileRequestOptions", L"AllowWrite");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.AllowWrite());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IsolatedWindowsEnvironmentShareFileRequestOptions_put_AllowWrite(py::wrapper::Windows::Security::Isolation::IsolatedWindowsEnvironmentShareFileRequestOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Isolation.IsolatedWindowsEnvironmentShareFileRequestOptions", L"AllowWrite");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.AllowWrite(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_IsolatedWindowsEnvironmentShareFileRequestOptions(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Security::Isolation::IsolatedWindowsEnvironmentShareFileRequestOptions>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IsolatedWindowsEnvironmentShareFileRequestOptions(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Security::Isolation::IsolatedWindowsEnvironmentShareFileRequestOptions>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IsolatedWindowsEnvironmentShareFileRequestOptions[] = {
        { "_assign_array_", _assign_array_IsolatedWindowsEnvironmentShareFileRequestOptions, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IsolatedWindowsEnvironmentShareFileRequestOptions), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IsolatedWindowsEnvironmentShareFileRequestOptions[] = {
        { "allow_write", reinterpret_cast<getter>(IsolatedWindowsEnvironmentShareFileRequestOptions_get_AllowWrite), reinterpret_cast<setter>(IsolatedWindowsEnvironmentShareFileRequestOptions_put_AllowWrite), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IsolatedWindowsEnvironmentShareFileRequestOptions[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_IsolatedWindowsEnvironmentShareFileRequestOptions) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IsolatedWindowsEnvironmentShareFileRequestOptions) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IsolatedWindowsEnvironmentShareFileRequestOptions) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IsolatedWindowsEnvironmentShareFileRequestOptions) },
        { }
    };

    static PyType_Spec type_spec_IsolatedWindowsEnvironmentShareFileRequestOptions = {
        "winrt._winrt_windows_security_isolation.IsolatedWindowsEnvironmentShareFileRequestOptions",
        sizeof(py::wrapper::Windows::Security::Isolation::IsolatedWindowsEnvironmentShareFileRequestOptions),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IsolatedWindowsEnvironmentShareFileRequestOptions};

    // ----- IsolatedWindowsEnvironmentShareFileResult class --------------------

    static PyObject* _new_IsolatedWindowsEnvironmentShareFileResult(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Security::Isolation::IsolatedWindowsEnvironmentShareFileResult>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Security::Isolation::IsolatedWindowsEnvironmentShareFileResult>::type_name);
        return nullptr;
    }

    static void _dealloc_IsolatedWindowsEnvironmentShareFileResult(py::wrapper::Windows::Security::Isolation::IsolatedWindowsEnvironmentShareFileResult* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IsolatedWindowsEnvironmentShareFileResult_get_ExtendedError(py::wrapper::Windows::Security::Isolation::IsolatedWindowsEnvironmentShareFileResult* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Isolation.IsolatedWindowsEnvironmentShareFileResult", L"ExtendedError");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ExtendedError());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IsolatedWindowsEnvironmentShareFileResult_get_File(py::wrapper::Windows::Security::Isolation::IsolatedWindowsEnvironmentShareFileResult* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Isolation.IsolatedWindowsEnvironmentShareFileResult", L"File");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.File());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IsolatedWindowsEnvironmentShareFileResult_get_Status(py::wrapper::Windows::Security::Isolation::IsolatedWindowsEnvironmentShareFileResult* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Isolation.IsolatedWindowsEnvironmentShareFileResult", L"Status");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_IsolatedWindowsEnvironmentShareFileResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Security::Isolation::IsolatedWindowsEnvironmentShareFileResult>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IsolatedWindowsEnvironmentShareFileResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Security::Isolation::IsolatedWindowsEnvironmentShareFileResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IsolatedWindowsEnvironmentShareFileResult[] = {
        { "_assign_array_", _assign_array_IsolatedWindowsEnvironmentShareFileResult, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IsolatedWindowsEnvironmentShareFileResult), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IsolatedWindowsEnvironmentShareFileResult[] = {
        { "extended_error", reinterpret_cast<getter>(IsolatedWindowsEnvironmentShareFileResult_get_ExtendedError), nullptr, nullptr, nullptr },
        { "file", reinterpret_cast<getter>(IsolatedWindowsEnvironmentShareFileResult_get_File), nullptr, nullptr, nullptr },
        { "status", reinterpret_cast<getter>(IsolatedWindowsEnvironmentShareFileResult_get_Status), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IsolatedWindowsEnvironmentShareFileResult[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_IsolatedWindowsEnvironmentShareFileResult) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IsolatedWindowsEnvironmentShareFileResult) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IsolatedWindowsEnvironmentShareFileResult) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IsolatedWindowsEnvironmentShareFileResult) },
        { }
    };

    static PyType_Spec type_spec_IsolatedWindowsEnvironmentShareFileResult = {
        "winrt._winrt_windows_security_isolation.IsolatedWindowsEnvironmentShareFileResult",
        sizeof(py::wrapper::Windows::Security::Isolation::IsolatedWindowsEnvironmentShareFileResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IsolatedWindowsEnvironmentShareFileResult};

    // ----- IsolatedWindowsEnvironmentShareFolderRequestOptions class --------------------

    static PyObject* _new_IsolatedWindowsEnvironmentShareFolderRequestOptions(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Security::Isolation::IsolatedWindowsEnvironmentShareFolderRequestOptions instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_IsolatedWindowsEnvironmentShareFolderRequestOptions(py::wrapper::Windows::Security::Isolation::IsolatedWindowsEnvironmentShareFolderRequestOptions* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IsolatedWindowsEnvironmentShareFolderRequestOptions_get_AllowWrite(py::wrapper::Windows::Security::Isolation::IsolatedWindowsEnvironmentShareFolderRequestOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Isolation.IsolatedWindowsEnvironmentShareFolderRequestOptions", L"AllowWrite");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.AllowWrite());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IsolatedWindowsEnvironmentShareFolderRequestOptions_put_AllowWrite(py::wrapper::Windows::Security::Isolation::IsolatedWindowsEnvironmentShareFolderRequestOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Isolation.IsolatedWindowsEnvironmentShareFolderRequestOptions", L"AllowWrite");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.AllowWrite(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_IsolatedWindowsEnvironmentShareFolderRequestOptions(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Security::Isolation::IsolatedWindowsEnvironmentShareFolderRequestOptions>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IsolatedWindowsEnvironmentShareFolderRequestOptions(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Security::Isolation::IsolatedWindowsEnvironmentShareFolderRequestOptions>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IsolatedWindowsEnvironmentShareFolderRequestOptions[] = {
        { "_assign_array_", _assign_array_IsolatedWindowsEnvironmentShareFolderRequestOptions, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IsolatedWindowsEnvironmentShareFolderRequestOptions), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IsolatedWindowsEnvironmentShareFolderRequestOptions[] = {
        { "allow_write", reinterpret_cast<getter>(IsolatedWindowsEnvironmentShareFolderRequestOptions_get_AllowWrite), reinterpret_cast<setter>(IsolatedWindowsEnvironmentShareFolderRequestOptions_put_AllowWrite), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IsolatedWindowsEnvironmentShareFolderRequestOptions[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_IsolatedWindowsEnvironmentShareFolderRequestOptions) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IsolatedWindowsEnvironmentShareFolderRequestOptions) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IsolatedWindowsEnvironmentShareFolderRequestOptions) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IsolatedWindowsEnvironmentShareFolderRequestOptions) },
        { }
    };

    static PyType_Spec type_spec_IsolatedWindowsEnvironmentShareFolderRequestOptions = {
        "winrt._winrt_windows_security_isolation.IsolatedWindowsEnvironmentShareFolderRequestOptions",
        sizeof(py::wrapper::Windows::Security::Isolation::IsolatedWindowsEnvironmentShareFolderRequestOptions),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IsolatedWindowsEnvironmentShareFolderRequestOptions};

    // ----- IsolatedWindowsEnvironmentShareFolderResult class --------------------

    static PyObject* _new_IsolatedWindowsEnvironmentShareFolderResult(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Security::Isolation::IsolatedWindowsEnvironmentShareFolderResult>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Security::Isolation::IsolatedWindowsEnvironmentShareFolderResult>::type_name);
        return nullptr;
    }

    static void _dealloc_IsolatedWindowsEnvironmentShareFolderResult(py::wrapper::Windows::Security::Isolation::IsolatedWindowsEnvironmentShareFolderResult* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IsolatedWindowsEnvironmentShareFolderResult_get_ExtendedError(py::wrapper::Windows::Security::Isolation::IsolatedWindowsEnvironmentShareFolderResult* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Isolation.IsolatedWindowsEnvironmentShareFolderResult", L"ExtendedError");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ExtendedError());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IsolatedWindowsEnvironmentShareFolderResult_get_Status(py::wrapper::Windows::Security::Isolation::IsolatedWindowsEnvironmentShareFolderResult* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Isolation.IsolatedWindowsEnvironmentShareFolderResult", L"Status");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_IsolatedWindowsEnvironmentShareFolderResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Security::Isolation::IsolatedWindowsEnvironmentShareFolderResult>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IsolatedWindowsEnvironmentShareFolderResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Security::Isolation::IsolatedWindowsEnvironmentShareFolderResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IsolatedWindowsEnvironmentShareFolderResult[] = {
        { "_assign_array_", _assign_array_IsolatedWindowsEnvironmentShareFolderResult, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IsolatedWindowsEnvironmentShareFolderResult), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IsolatedWindowsEnvironmentShareFolderResult[] = {
        { "extended_error", reinterpret_cast<getter>(IsolatedWindowsEnvironmentShareFolderResult_get_ExtendedError), nullptr, nullptr, nullptr },
        { "status", reinterpret_cast<getter>(IsolatedWindowsEnvironmentShareFolderResult_get_Status), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IsolatedWindowsEnvironmentShareFolderResult[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_IsolatedWindowsEnvironmentShareFolderResult) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IsolatedWindowsEnvironmentShareFolderResult) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IsolatedWindowsEnvironmentShareFolderResult) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IsolatedWindowsEnvironmentShareFolderResult) },
        { }
    };

    static PyType_Spec type_spec_IsolatedWindowsEnvironmentShareFolderResult = {
        "winrt._winrt_windows_security_isolation.IsolatedWindowsEnvironmentShareFolderResult",
        sizeof(py::wrapper::Windows::Security::Isolation::IsolatedWindowsEnvironmentShareFolderResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IsolatedWindowsEnvironmentShareFolderResult};

    // ----- IsolatedWindowsEnvironmentStartProcessResult class --------------------

    static PyObject* _new_IsolatedWindowsEnvironmentStartProcessResult(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Security::Isolation::IsolatedWindowsEnvironmentStartProcessResult>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Security::Isolation::IsolatedWindowsEnvironmentStartProcessResult>::type_name);
        return nullptr;
    }

    static void _dealloc_IsolatedWindowsEnvironmentStartProcessResult(py::wrapper::Windows::Security::Isolation::IsolatedWindowsEnvironmentStartProcessResult* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IsolatedWindowsEnvironmentStartProcessResult_get_ExtendedError(py::wrapper::Windows::Security::Isolation::IsolatedWindowsEnvironmentStartProcessResult* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Isolation.IsolatedWindowsEnvironmentStartProcessResult", L"ExtendedError");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ExtendedError());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IsolatedWindowsEnvironmentStartProcessResult_get_Process(py::wrapper::Windows::Security::Isolation::IsolatedWindowsEnvironmentStartProcessResult* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Isolation.IsolatedWindowsEnvironmentStartProcessResult", L"Process");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Process());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IsolatedWindowsEnvironmentStartProcessResult_get_Status(py::wrapper::Windows::Security::Isolation::IsolatedWindowsEnvironmentStartProcessResult* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Isolation.IsolatedWindowsEnvironmentStartProcessResult", L"Status");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_IsolatedWindowsEnvironmentStartProcessResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Security::Isolation::IsolatedWindowsEnvironmentStartProcessResult>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IsolatedWindowsEnvironmentStartProcessResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Security::Isolation::IsolatedWindowsEnvironmentStartProcessResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IsolatedWindowsEnvironmentStartProcessResult[] = {
        { "_assign_array_", _assign_array_IsolatedWindowsEnvironmentStartProcessResult, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IsolatedWindowsEnvironmentStartProcessResult), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IsolatedWindowsEnvironmentStartProcessResult[] = {
        { "extended_error", reinterpret_cast<getter>(IsolatedWindowsEnvironmentStartProcessResult_get_ExtendedError), nullptr, nullptr, nullptr },
        { "process", reinterpret_cast<getter>(IsolatedWindowsEnvironmentStartProcessResult_get_Process), nullptr, nullptr, nullptr },
        { "status", reinterpret_cast<getter>(IsolatedWindowsEnvironmentStartProcessResult_get_Status), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IsolatedWindowsEnvironmentStartProcessResult[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_IsolatedWindowsEnvironmentStartProcessResult) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IsolatedWindowsEnvironmentStartProcessResult) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IsolatedWindowsEnvironmentStartProcessResult) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IsolatedWindowsEnvironmentStartProcessResult) },
        { }
    };

    static PyType_Spec type_spec_IsolatedWindowsEnvironmentStartProcessResult = {
        "winrt._winrt_windows_security_isolation.IsolatedWindowsEnvironmentStartProcessResult",
        sizeof(py::wrapper::Windows::Security::Isolation::IsolatedWindowsEnvironmentStartProcessResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IsolatedWindowsEnvironmentStartProcessResult};

    // ----- IsolatedWindowsEnvironmentTelemetryParameters class --------------------

    static PyObject* _new_IsolatedWindowsEnvironmentTelemetryParameters(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Security::Isolation::IsolatedWindowsEnvironmentTelemetryParameters instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_IsolatedWindowsEnvironmentTelemetryParameters(py::wrapper::Windows::Security::Isolation::IsolatedWindowsEnvironmentTelemetryParameters* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IsolatedWindowsEnvironmentTelemetryParameters_get_CorrelationId(py::wrapper::Windows::Security::Isolation::IsolatedWindowsEnvironmentTelemetryParameters* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Isolation.IsolatedWindowsEnvironmentTelemetryParameters", L"CorrelationId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CorrelationId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IsolatedWindowsEnvironmentTelemetryParameters_put_CorrelationId(py::wrapper::Windows::Security::Isolation::IsolatedWindowsEnvironmentTelemetryParameters* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Isolation.IsolatedWindowsEnvironmentTelemetryParameters", L"CorrelationId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::guid>(arg);

            self->obj.CorrelationId(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_IsolatedWindowsEnvironmentTelemetryParameters(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Security::Isolation::IsolatedWindowsEnvironmentTelemetryParameters>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IsolatedWindowsEnvironmentTelemetryParameters(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Security::Isolation::IsolatedWindowsEnvironmentTelemetryParameters>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IsolatedWindowsEnvironmentTelemetryParameters[] = {
        { "_assign_array_", _assign_array_IsolatedWindowsEnvironmentTelemetryParameters, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IsolatedWindowsEnvironmentTelemetryParameters), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IsolatedWindowsEnvironmentTelemetryParameters[] = {
        { "correlation_id", reinterpret_cast<getter>(IsolatedWindowsEnvironmentTelemetryParameters_get_CorrelationId), reinterpret_cast<setter>(IsolatedWindowsEnvironmentTelemetryParameters_put_CorrelationId), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IsolatedWindowsEnvironmentTelemetryParameters[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_IsolatedWindowsEnvironmentTelemetryParameters) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IsolatedWindowsEnvironmentTelemetryParameters) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IsolatedWindowsEnvironmentTelemetryParameters) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IsolatedWindowsEnvironmentTelemetryParameters) },
        { }
    };

    static PyType_Spec type_spec_IsolatedWindowsEnvironmentTelemetryParameters = {
        "winrt._winrt_windows_security_isolation.IsolatedWindowsEnvironmentTelemetryParameters",
        sizeof(py::wrapper::Windows::Security::Isolation::IsolatedWindowsEnvironmentTelemetryParameters),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IsolatedWindowsEnvironmentTelemetryParameters};

    // ----- IsolatedWindowsEnvironmentUserInfo class --------------------

    static PyObject* _new_IsolatedWindowsEnvironmentUserInfo(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Security::Isolation::IsolatedWindowsEnvironmentUserInfo>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Security::Isolation::IsolatedWindowsEnvironmentUserInfo>::type_name);
        return nullptr;
    }

    static void _dealloc_IsolatedWindowsEnvironmentUserInfo(py::wrapper::Windows::Security::Isolation::IsolatedWindowsEnvironmentUserInfo* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IsolatedWindowsEnvironmentUserInfo_TryWaitForSignInAsync(py::wrapper::Windows::Security::Isolation::IsolatedWindowsEnvironmentUserInfo* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Security.Isolation.IsolatedWindowsEnvironmentUserInfo", L"TryWaitForSignInAsync", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.TryWaitForSignInAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IsolatedWindowsEnvironmentUserInfo_TryWaitForSignInWithProgressAsync(py::wrapper::Windows::Security::Isolation::IsolatedWindowsEnvironmentUserInfo* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Security.Isolation.IsolatedWindowsEnvironmentUserInfo", L"TryWaitForSignInWithProgressAsync", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.TryWaitForSignInWithProgressAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IsolatedWindowsEnvironmentUserInfo_get_EnvironmentUserName(py::wrapper::Windows::Security::Isolation::IsolatedWindowsEnvironmentUserInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Isolation.IsolatedWindowsEnvironmentUserInfo", L"EnvironmentUserName");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.EnvironmentUserName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IsolatedWindowsEnvironmentUserInfo_get_EnvironmentUserSid(py::wrapper::Windows::Security::Isolation::IsolatedWindowsEnvironmentUserInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Isolation.IsolatedWindowsEnvironmentUserInfo", L"EnvironmentUserSid");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.EnvironmentUserSid());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_IsolatedWindowsEnvironmentUserInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Security::Isolation::IsolatedWindowsEnvironmentUserInfo>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IsolatedWindowsEnvironmentUserInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Security::Isolation::IsolatedWindowsEnvironmentUserInfo>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IsolatedWindowsEnvironmentUserInfo[] = {
        { "try_wait_for_sign_in_async", reinterpret_cast<PyCFunction>(IsolatedWindowsEnvironmentUserInfo_TryWaitForSignInAsync), METH_VARARGS, nullptr },
        { "try_wait_for_sign_in_with_progress_async", reinterpret_cast<PyCFunction>(IsolatedWindowsEnvironmentUserInfo_TryWaitForSignInWithProgressAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_IsolatedWindowsEnvironmentUserInfo, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IsolatedWindowsEnvironmentUserInfo), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IsolatedWindowsEnvironmentUserInfo[] = {
        { "environment_user_name", reinterpret_cast<getter>(IsolatedWindowsEnvironmentUserInfo_get_EnvironmentUserName), nullptr, nullptr, nullptr },
        { "environment_user_sid", reinterpret_cast<getter>(IsolatedWindowsEnvironmentUserInfo_get_EnvironmentUserSid), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IsolatedWindowsEnvironmentUserInfo[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_IsolatedWindowsEnvironmentUserInfo) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IsolatedWindowsEnvironmentUserInfo) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IsolatedWindowsEnvironmentUserInfo) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IsolatedWindowsEnvironmentUserInfo) },
        { }
    };

    static PyType_Spec type_spec_IsolatedWindowsEnvironmentUserInfo = {
        "winrt._winrt_windows_security_isolation.IsolatedWindowsEnvironmentUserInfo",
        sizeof(py::wrapper::Windows::Security::Isolation::IsolatedWindowsEnvironmentUserInfo),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IsolatedWindowsEnvironmentUserInfo};

    // ----- IsolatedWindowsHostMessenger class --------------------

    static PyObject* _new_IsolatedWindowsHostMessenger(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Security::Isolation::IsolatedWindowsHostMessenger>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Security::Isolation::IsolatedWindowsHostMessenger>::type_name);
        return nullptr;
    }

    static PyObject* IsolatedWindowsHostMessenger_GetFileId(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Security.Isolation.IsolatedWindowsHostMessenger", L"GetFileId", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Security::Isolation::IsolatedWindowsHostMessenger::GetFileId(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IsolatedWindowsHostMessenger_PostMessageToReceiver(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Security.Isolation.IsolatedWindowsHostMessenger", L"PostMessageToReceiver", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::guid>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IVectorView<winrt::Windows::Foundation::IInspectable>>(args, 1);

                winrt::Windows::Security::Isolation::IsolatedWindowsHostMessenger::PostMessageToReceiver(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IsolatedWindowsHostMessenger_RegisterHostMessageReceiver(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Security.Isolation.IsolatedWindowsHostMessenger", L"RegisterHostMessageReceiver", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::guid>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Security::Isolation::HostMessageReceivedCallback>(args, 1);

                winrt::Windows::Security::Isolation::IsolatedWindowsHostMessenger::RegisterHostMessageReceiver(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IsolatedWindowsHostMessenger_UnregisterHostMessageReceiver(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Security.Isolation.IsolatedWindowsHostMessenger", L"UnregisterHostMessageReceiver", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::guid>(args, 0);

                winrt::Windows::Security::Isolation::IsolatedWindowsHostMessenger::UnregisterHostMessageReceiver(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyMethodDef _methods_IsolatedWindowsHostMessenger[] = {
        { }
    };

    static PyGetSetDef _getset_IsolatedWindowsHostMessenger[] = {
        { }
    };

    static PyType_Slot _type_slots_IsolatedWindowsHostMessenger[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_IsolatedWindowsHostMessenger) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IsolatedWindowsHostMessenger) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IsolatedWindowsHostMessenger) },
        { }
    };

    static PyType_Spec type_spec_IsolatedWindowsHostMessenger = {
        "winrt._winrt_windows_security_isolation.IsolatedWindowsHostMessenger",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IsolatedWindowsHostMessenger};

    static PyGetSetDef getset_IsolatedWindowsHostMessenger_Static[] = {
        { }
    };

    static PyMethodDef methods_IsolatedWindowsHostMessenger_Static[] = {
        { "get_file_id", reinterpret_cast<PyCFunction>(IsolatedWindowsHostMessenger_GetFileId), METH_VARARGS, nullptr },
        { "post_message_to_receiver", reinterpret_cast<PyCFunction>(IsolatedWindowsHostMessenger_PostMessageToReceiver), METH_VARARGS, nullptr },
        { "register_host_message_receiver", reinterpret_cast<PyCFunction>(IsolatedWindowsHostMessenger_RegisterHostMessageReceiver), METH_VARARGS, nullptr },
        { "unregister_host_message_receiver", reinterpret_cast<PyCFunction>(IsolatedWindowsHostMessenger_UnregisterHostMessageReceiver), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_IsolatedWindowsHostMessenger_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_IsolatedWindowsHostMessenger_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_IsolatedWindowsHostMessenger_Static) },
        { }
    };

    static PyType_Spec type_spec_IsolatedWindowsHostMessenger_Static =
    {
        "winrt._winrt_windows_security_isolation.IsolatedWindowsHostMessenger_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_IsolatedWindowsHostMessenger_Static
    };

    // ----- IsolatedWindowsEnvironmentCreateProgress struct --------------------

    winrt_struct_wrapper<winrt::Windows::Security::Isolation::IsolatedWindowsEnvironmentCreateProgress>* _new_IsolatedWindowsEnvironmentCreateProgress(PyTypeObject* subclass, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        auto self = reinterpret_cast<winrt_struct_wrapper<winrt::Windows::Security::Isolation::IsolatedWindowsEnvironmentCreateProgress>*>(subclass->tp_alloc(subclass, 0));

        if (!self)
        {
            return nullptr;
        }

        std::construct_at(&self->obj);

        return self;
    }

    int _init_IsolatedWindowsEnvironmentCreateProgress(winrt_struct_wrapper<winrt::Windows::Security::Isolation::IsolatedWindowsEnvironmentCreateProgress>* self, PyObject* args, PyObject* kwds) noexcept
    {
        auto tuple_size = PyTuple_Size(args);

        if ((tuple_size == 0) && (kwds == nullptr))
        {
            self->obj = {};
            return 0;
        }

        int32_t _State{};
        uint32_t _PercentComplete{};

        static const char* kwlist[] = {"state", "percent_complete", nullptr};
        if (!PyArg_ParseTupleAndKeywords(args, kwds, "iI", const_cast<char**>(kwlist), &_State, &_PercentComplete))
        {
            return -1;
        }

        try
        {
            self->obj.State = static_cast<winrt::Windows::Security::Isolation::IsolatedWindowsEnvironmentProgressState>(_State);
            self->obj.PercentComplete = _PercentComplete;

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static void _dealloc_IsolatedWindowsEnvironmentCreateProgress(py::wrapper::Windows::Security::Isolation::IsolatedWindowsEnvironmentCreateProgress* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_IsolatedWindowsEnvironmentCreateProgress(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Security::Isolation::IsolatedWindowsEnvironmentCreateProgress>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyMethodDef _methods_IsolatedWindowsEnvironmentCreateProgress[] = {
        { "_assign_array_", _assign_array_IsolatedWindowsEnvironmentCreateProgress, METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyObject* IsolatedWindowsEnvironmentCreateProgress_get_State(py::wrapper::Windows::Security::Isolation::IsolatedWindowsEnvironmentCreateProgress* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.State);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IsolatedWindowsEnvironmentCreateProgress_set_State(py::wrapper::Windows::Security::Isolation::IsolatedWindowsEnvironmentCreateProgress* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.State = py::converter<winrt::Windows::Security::Isolation::IsolatedWindowsEnvironmentProgressState>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* IsolatedWindowsEnvironmentCreateProgress_get_PercentComplete(py::wrapper::Windows::Security::Isolation::IsolatedWindowsEnvironmentCreateProgress* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PercentComplete);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IsolatedWindowsEnvironmentCreateProgress_set_PercentComplete(py::wrapper::Windows::Security::Isolation::IsolatedWindowsEnvironmentCreateProgress* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.PercentComplete = py::converter<uint32_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyGetSetDef _getset_IsolatedWindowsEnvironmentCreateProgress[] = {
        { "state", reinterpret_cast<getter>(IsolatedWindowsEnvironmentCreateProgress_get_State), reinterpret_cast<setter>(IsolatedWindowsEnvironmentCreateProgress_set_State), nullptr, nullptr },
        { "percent_complete", reinterpret_cast<getter>(IsolatedWindowsEnvironmentCreateProgress_get_PercentComplete), reinterpret_cast<setter>(IsolatedWindowsEnvironmentCreateProgress_set_PercentComplete), nullptr, nullptr },
        { }
    };

    static PyObject* _richcompare_IsolatedWindowsEnvironmentCreateProgress(py::wrapper::Windows::Security::Isolation::IsolatedWindowsEnvironmentCreateProgress* self, PyObject* other, int op) noexcept
    {
        try
        {
            auto _other = py::converter<winrt::Windows::Security::Isolation::IsolatedWindowsEnvironmentCreateProgress>::convert_to(other);

            if (op == Py_EQ)
            {
                if (self->obj == _other)
                {
                    Py_RETURN_TRUE;
                }

                Py_RETURN_FALSE;
            }

            if (op == Py_NE)
            {
                if (self->obj != _other)
                {
                    Py_RETURN_TRUE;
                }

                Py_RETURN_FALSE;
            }

            Py_RETURN_NOTIMPLEMENTED;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _repr_IsolatedWindowsEnvironmentCreateProgress(PyObject* self) noexcept
    {
        py::pyobj_handle State{PyObject_GetAttrString(self, "state")};
        if (!State)
        {
            return nullptr;
        }

        py::pyobj_handle PercentComplete{PyObject_GetAttrString(self, "percent_complete")};
        if (!PercentComplete)
        {
            return nullptr;
        }

        return PyUnicode_FromFormat("IsolatedWindowsEnvironmentCreateProgress(state=%R, percent_complete=%R)", State.get(), PercentComplete.get());
    }

    static PyType_Slot _type_slots_IsolatedWindowsEnvironmentCreateProgress[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_IsolatedWindowsEnvironmentCreateProgress) },
        { Py_tp_init, reinterpret_cast<void*>(_init_IsolatedWindowsEnvironmentCreateProgress) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IsolatedWindowsEnvironmentCreateProgress) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IsolatedWindowsEnvironmentCreateProgress) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IsolatedWindowsEnvironmentCreateProgress) },
        { Py_tp_richcompare, reinterpret_cast<void*>(_richcompare_IsolatedWindowsEnvironmentCreateProgress) },
        { Py_tp_repr, reinterpret_cast<void*>(_repr_IsolatedWindowsEnvironmentCreateProgress) },
        { }
    };

    static PyType_Spec type_spec_IsolatedWindowsEnvironmentCreateProgress = {
        "winrt._winrt_windows_security_isolation.IsolatedWindowsEnvironmentCreateProgress",
        sizeof(py::wrapper::Windows::Security::Isolation::IsolatedWindowsEnvironmentCreateProgress),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IsolatedWindowsEnvironmentCreateProgress};

    // ----- Windows.Security.Isolation Initialization --------------------

    PyDoc_STRVAR(module_doc, "Windows.Security.Isolation");

    static PyModuleDef module_def = {
        PyModuleDef_HEAD_INIT,
        "_winrt_windows_security_isolation",
        module_doc,
        0,
        nullptr,
        nullptr,
        nullptr,
        nullptr,
        nullptr};
} // py::cpp::Windows::Security::Isolation

PyMODINIT_FUNC PyInit__winrt_windows_security_isolation(void) noexcept
{
    using namespace py::cpp::Windows::Security::Isolation;

    if (py::import_winrt_runtime() == -1)
    {
        return nullptr;
    }

    py::pyobj_handle module{PyModule_Create(&module_def)};

    if (!module)
    {
        return nullptr;
    }

    auto object_type = py::get_object_type();
    if (!object_type)
    {
        return nullptr;
    }

    py::pyobj_handle object_bases{PyTuple_Pack(1, object_type)};

    if (!object_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_IsolatedWindowsEnvironment_Static{PyType_FromSpec(&type_spec_IsolatedWindowsEnvironment_Static)};
    if (!type_IsolatedWindowsEnvironment_Static)
    {
        return nullptr;
    }

    py::pytype_handle IsolatedWindowsEnvironment_type{py::register_python_type(module.get(), &type_spec_IsolatedWindowsEnvironment, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_IsolatedWindowsEnvironment_Static.get()))};
    if (!IsolatedWindowsEnvironment_type)
    {
        return nullptr;
    }

    py::pytype_handle IsolatedWindowsEnvironmentCreateResult_type{py::register_python_type(module.get(), &type_spec_IsolatedWindowsEnvironmentCreateResult, object_bases.get(), nullptr)};
    if (!IsolatedWindowsEnvironmentCreateResult_type)
    {
        return nullptr;
    }

    py::pytype_handle IsolatedWindowsEnvironmentFile_type{py::register_python_type(module.get(), &type_spec_IsolatedWindowsEnvironmentFile, object_bases.get(), nullptr)};
    if (!IsolatedWindowsEnvironmentFile_type)
    {
        return nullptr;
    }

    py::pyobj_handle type_IsolatedWindowsEnvironmentHost_Static{PyType_FromSpec(&type_spec_IsolatedWindowsEnvironmentHost_Static)};
    if (!type_IsolatedWindowsEnvironmentHost_Static)
    {
        return nullptr;
    }

    py::pytype_handle IsolatedWindowsEnvironmentHost_type{py::register_python_type(module.get(), &type_spec_IsolatedWindowsEnvironmentHost, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_IsolatedWindowsEnvironmentHost_Static.get()))};
    if (!IsolatedWindowsEnvironmentHost_type)
    {
        return nullptr;
    }

    py::pytype_handle IsolatedWindowsEnvironmentLaunchFileResult_type{py::register_python_type(module.get(), &type_spec_IsolatedWindowsEnvironmentLaunchFileResult, object_bases.get(), nullptr)};
    if (!IsolatedWindowsEnvironmentLaunchFileResult_type)
    {
        return nullptr;
    }

    py::pytype_handle IsolatedWindowsEnvironmentOptions_type{py::register_python_type(module.get(), &type_spec_IsolatedWindowsEnvironmentOptions, object_bases.get(), nullptr)};
    if (!IsolatedWindowsEnvironmentOptions_type)
    {
        return nullptr;
    }

    py::pyobj_handle type_IsolatedWindowsEnvironmentOwnerRegistration_Static{PyType_FromSpec(&type_spec_IsolatedWindowsEnvironmentOwnerRegistration_Static)};
    if (!type_IsolatedWindowsEnvironmentOwnerRegistration_Static)
    {
        return nullptr;
    }

    py::pytype_handle IsolatedWindowsEnvironmentOwnerRegistration_type{py::register_python_type(module.get(), &type_spec_IsolatedWindowsEnvironmentOwnerRegistration, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_IsolatedWindowsEnvironmentOwnerRegistration_Static.get()))};
    if (!IsolatedWindowsEnvironmentOwnerRegistration_type)
    {
        return nullptr;
    }

    py::pytype_handle IsolatedWindowsEnvironmentOwnerRegistrationData_type{py::register_python_type(module.get(), &type_spec_IsolatedWindowsEnvironmentOwnerRegistrationData, object_bases.get(), nullptr)};
    if (!IsolatedWindowsEnvironmentOwnerRegistrationData_type)
    {
        return nullptr;
    }

    py::pytype_handle IsolatedWindowsEnvironmentOwnerRegistrationResult_type{py::register_python_type(module.get(), &type_spec_IsolatedWindowsEnvironmentOwnerRegistrationResult, object_bases.get(), nullptr)};
    if (!IsolatedWindowsEnvironmentOwnerRegistrationResult_type)
    {
        return nullptr;
    }

    py::pytype_handle IsolatedWindowsEnvironmentPostMessageResult_type{py::register_python_type(module.get(), &type_spec_IsolatedWindowsEnvironmentPostMessageResult, object_bases.get(), nullptr)};
    if (!IsolatedWindowsEnvironmentPostMessageResult_type)
    {
        return nullptr;
    }

    py::pytype_handle IsolatedWindowsEnvironmentProcess_type{py::register_python_type(module.get(), &type_spec_IsolatedWindowsEnvironmentProcess, object_bases.get(), nullptr)};
    if (!IsolatedWindowsEnvironmentProcess_type)
    {
        return nullptr;
    }

    py::pytype_handle IsolatedWindowsEnvironmentShareFileRequestOptions_type{py::register_python_type(module.get(), &type_spec_IsolatedWindowsEnvironmentShareFileRequestOptions, object_bases.get(), nullptr)};
    if (!IsolatedWindowsEnvironmentShareFileRequestOptions_type)
    {
        return nullptr;
    }

    py::pytype_handle IsolatedWindowsEnvironmentShareFileResult_type{py::register_python_type(module.get(), &type_spec_IsolatedWindowsEnvironmentShareFileResult, object_bases.get(), nullptr)};
    if (!IsolatedWindowsEnvironmentShareFileResult_type)
    {
        return nullptr;
    }

    py::pytype_handle IsolatedWindowsEnvironmentShareFolderRequestOptions_type{py::register_python_type(module.get(), &type_spec_IsolatedWindowsEnvironmentShareFolderRequestOptions, object_bases.get(), nullptr)};
    if (!IsolatedWindowsEnvironmentShareFolderRequestOptions_type)
    {
        return nullptr;
    }

    py::pytype_handle IsolatedWindowsEnvironmentShareFolderResult_type{py::register_python_type(module.get(), &type_spec_IsolatedWindowsEnvironmentShareFolderResult, object_bases.get(), nullptr)};
    if (!IsolatedWindowsEnvironmentShareFolderResult_type)
    {
        return nullptr;
    }

    py::pytype_handle IsolatedWindowsEnvironmentStartProcessResult_type{py::register_python_type(module.get(), &type_spec_IsolatedWindowsEnvironmentStartProcessResult, object_bases.get(), nullptr)};
    if (!IsolatedWindowsEnvironmentStartProcessResult_type)
    {
        return nullptr;
    }

    py::pytype_handle IsolatedWindowsEnvironmentTelemetryParameters_type{py::register_python_type(module.get(), &type_spec_IsolatedWindowsEnvironmentTelemetryParameters, object_bases.get(), nullptr)};
    if (!IsolatedWindowsEnvironmentTelemetryParameters_type)
    {
        return nullptr;
    }

    py::pytype_handle IsolatedWindowsEnvironmentUserInfo_type{py::register_python_type(module.get(), &type_spec_IsolatedWindowsEnvironmentUserInfo, object_bases.get(), nullptr)};
    if (!IsolatedWindowsEnvironmentUserInfo_type)
    {
        return nullptr;
    }

    py::pyobj_handle type_IsolatedWindowsHostMessenger_Static{PyType_FromSpec(&type_spec_IsolatedWindowsHostMessenger_Static)};
    if (!type_IsolatedWindowsHostMessenger_Static)
    {
        return nullptr;
    }

    py::pytype_handle IsolatedWindowsHostMessenger_type{py::register_python_type(module.get(), &type_spec_IsolatedWindowsHostMessenger, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_IsolatedWindowsHostMessenger_Static.get()))};
    if (!IsolatedWindowsHostMessenger_type)
    {
        return nullptr;
    }

    py::pytype_handle IsolatedWindowsEnvironmentCreateProgress_type{py::register_python_type(module.get(), &type_spec_IsolatedWindowsEnvironmentCreateProgress, nullptr, nullptr)};
    if (!IsolatedWindowsEnvironmentCreateProgress_type)
    {
        return nullptr;
    }


    return module.detach();
}
