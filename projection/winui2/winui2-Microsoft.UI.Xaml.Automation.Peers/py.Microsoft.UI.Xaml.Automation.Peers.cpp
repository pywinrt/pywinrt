// WARNING: Please don't edit this file. It was generated by Python/WinRT v0.0.0

#include "py.Microsoft.UI.Xaml.Automation.Peers.h"

namespace py::cpp::Microsoft::UI::Xaml::Automation::Peers
{
    // ----- AnimatedVisualPlayerAutomationPeer class --------------------

    struct PyWinrtAnimatedVisualPlayerAutomationPeer;
    using BasePyWinrtAnimatedVisualPlayerAutomationPeer = winrt::Microsoft::UI::Xaml::Automation::Peers::AnimatedVisualPlayerAutomationPeerT<PyWinrtAnimatedVisualPlayerAutomationPeer, py::IPywinrtObject>;

    struct PyWinrtAnimatedVisualPlayerAutomationPeer : py::py_obj_ref, BasePyWinrtAnimatedVisualPlayerAutomationPeer
    {
        PyWinrtAnimatedVisualPlayerAutomationPeer(PyObject* py_obj, winrt::Microsoft::UI::Xaml::Controls::AnimatedVisualPlayer owner) : py::py_obj_ref(py_obj), BasePyWinrtAnimatedVisualPlayerAutomationPeer(owner) {}

        int32_t __stdcall GetPyObject(PyObject*& obj) override
        {
            obj = py::py_obj_ref::get_py_obj();
            return 0;
        }

        int32_t __stdcall GetComposableInner(winrt::Windows::Foundation::IInspectable& inner) override
        {
            inner = m_inner;
            return winrt::impl::error_ok;
        }

        static void toggle_reference(PyWinrtAnimatedVisualPlayerAutomationPeer* instance, bool is_last_reference)
        {
            py::py_obj_ref::toggle_reference(instance, is_last_reference);
        }

        int32_t query_interface_tearoff(winrt::guid const& id, void** result) const noexcept override
        {
            return py::py_obj_ref::query_interface_tearoff(id, result);
        }

        std::vector<winrt::guid> get_iids_tearoff() const noexcept override
        {
            return py::py_obj_ref::get_iids_tearoff();
        }
    };

    static PyObject* _new_AnimatedVisualPlayerAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_GET_SIZE(args);

        auto self_type = get_python_type_for<winrt::Microsoft::UI::Xaml::Automation::Peers::AnimatedVisualPlayerAutomationPeer>();
        if (!self_type)
        {
            return nullptr;
        }

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::AnimatedVisualPlayer>(args, 0);

                if (type != self_type)
                {
                    py::pyobj_handle self{type->tp_alloc(type, 0)};
                    if (!self)
                    {
                        return nullptr;
                    }

                    std::construct_at(&reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj, nullptr);

                    auto obj_impl = winrt::make_self<PyWinrtAnimatedVisualPlayerAutomationPeer>(self.get(), param0);

                    auto obj = py::make_py_obj<PyWinrtAnimatedVisualPlayerAutomationPeer>(obj_impl, type, self.get());
                    if (!obj)
                    {
                        return nullptr;
                    }

                    reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj = std::move(obj);

                    return self.detach();
                }

                winrt::Microsoft::UI::Xaml::Automation::Peers::AnimatedVisualPlayerAutomationPeer instance{param0};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_AnimatedVisualPlayerAutomationPeer(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_AnimatedVisualPlayerAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Automation::Peers::AnimatedVisualPlayerAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AnimatedVisualPlayerAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Automation::Peers::AnimatedVisualPlayerAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AnimatedVisualPlayerAutomationPeer[] = {
        { "_assign_array_", _assign_array_AnimatedVisualPlayerAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AnimatedVisualPlayerAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_AnimatedVisualPlayerAutomationPeer[] = {
        { }};

    static PyType_Slot _type_slots_AnimatedVisualPlayerAutomationPeer[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_AnimatedVisualPlayerAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AnimatedVisualPlayerAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AnimatedVisualPlayerAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AnimatedVisualPlayerAutomationPeer) },
        { }};

    static PyType_Spec type_spec_AnimatedVisualPlayerAutomationPeer = {
        "winui2._winui2_microsoft_ui_xaml_automation_peers.AnimatedVisualPlayerAutomationPeer",
        sizeof(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_AnimatedVisualPlayerAutomationPeer};

    static PyGetSetDef getset_AnimatedVisualPlayerAutomationPeer_Static[] = {
        { }};

    static PyMethodDef methods_AnimatedVisualPlayerAutomationPeer_Static[] = {
        { }};

    static PyType_Slot type_slots_AnimatedVisualPlayerAutomationPeer_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_AnimatedVisualPlayerAutomationPeer_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_AnimatedVisualPlayerAutomationPeer_Static) },
        { }
    };

    static PyType_Spec type_spec_AnimatedVisualPlayerAutomationPeer_Static = {
        "winui2._winui2_microsoft_ui_xaml_automation_peers.AnimatedVisualPlayerAutomationPeer_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_AnimatedVisualPlayerAutomationPeer_Static};

    // ----- BreadcrumbBarItemAutomationPeer class --------------------

    struct PyWinrtBreadcrumbBarItemAutomationPeer;
    using BasePyWinrtBreadcrumbBarItemAutomationPeer = winrt::Microsoft::UI::Xaml::Automation::Peers::BreadcrumbBarItemAutomationPeerT<PyWinrtBreadcrumbBarItemAutomationPeer, py::IPywinrtObject>;

    struct PyWinrtBreadcrumbBarItemAutomationPeer : py::py_obj_ref, BasePyWinrtBreadcrumbBarItemAutomationPeer
    {
        PyWinrtBreadcrumbBarItemAutomationPeer(PyObject* py_obj, winrt::Microsoft::UI::Xaml::Controls::BreadcrumbBarItem owner) : py::py_obj_ref(py_obj), BasePyWinrtBreadcrumbBarItemAutomationPeer(owner) {}

        int32_t __stdcall GetPyObject(PyObject*& obj) override
        {
            obj = py::py_obj_ref::get_py_obj();
            return 0;
        }

        int32_t __stdcall GetComposableInner(winrt::Windows::Foundation::IInspectable& inner) override
        {
            inner = m_inner;
            return winrt::impl::error_ok;
        }

        static void toggle_reference(PyWinrtBreadcrumbBarItemAutomationPeer* instance, bool is_last_reference)
        {
            py::py_obj_ref::toggle_reference(instance, is_last_reference);
        }

        int32_t query_interface_tearoff(winrt::guid const& id, void** result) const noexcept override
        {
            return py::py_obj_ref::query_interface_tearoff(id, result);
        }

        std::vector<winrt::guid> get_iids_tearoff() const noexcept override
        {
            return py::py_obj_ref::get_iids_tearoff();
        }
    };

    static PyObject* _new_BreadcrumbBarItemAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_GET_SIZE(args);

        auto self_type = get_python_type_for<winrt::Microsoft::UI::Xaml::Automation::Peers::BreadcrumbBarItemAutomationPeer>();
        if (!self_type)
        {
            return nullptr;
        }

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::BreadcrumbBarItem>(args, 0);

                if (type != self_type)
                {
                    py::pyobj_handle self{type->tp_alloc(type, 0)};
                    if (!self)
                    {
                        return nullptr;
                    }

                    std::construct_at(&reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj, nullptr);

                    auto obj_impl = winrt::make_self<PyWinrtBreadcrumbBarItemAutomationPeer>(self.get(), param0);

                    auto obj = py::make_py_obj<PyWinrtBreadcrumbBarItemAutomationPeer>(obj_impl, type, self.get());
                    if (!obj)
                    {
                        return nullptr;
                    }

                    reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj = std::move(obj);

                    return self.detach();
                }

                winrt::Microsoft::UI::Xaml::Automation::Peers::BreadcrumbBarItemAutomationPeer instance{param0};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_BreadcrumbBarItemAutomationPeer(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* BreadcrumbBarItemAutomationPeer_Invoke(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.Peers.BreadcrumbBarItemAutomationPeer", L"Invoke", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.try_as<winrt::Microsoft::UI::Xaml::Automation::Peers::BreadcrumbBarItemAutomationPeer>().Invoke();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_BreadcrumbBarItemAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Automation::Peers::BreadcrumbBarItemAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_BreadcrumbBarItemAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Automation::Peers::BreadcrumbBarItemAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_BreadcrumbBarItemAutomationPeer[] = {
        { "invoke", reinterpret_cast<PyCFunction>(BreadcrumbBarItemAutomationPeer_Invoke), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_BreadcrumbBarItemAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_BreadcrumbBarItemAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_BreadcrumbBarItemAutomationPeer[] = {
        { }};

    static PyType_Slot _type_slots_BreadcrumbBarItemAutomationPeer[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_BreadcrumbBarItemAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_BreadcrumbBarItemAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_BreadcrumbBarItemAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_BreadcrumbBarItemAutomationPeer) },
        { }};

    static PyType_Spec type_spec_BreadcrumbBarItemAutomationPeer = {
        "winui2._winui2_microsoft_ui_xaml_automation_peers.BreadcrumbBarItemAutomationPeer",
        sizeof(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_BreadcrumbBarItemAutomationPeer};

    static PyGetSetDef getset_BreadcrumbBarItemAutomationPeer_Static[] = {
        { }};

    static PyMethodDef methods_BreadcrumbBarItemAutomationPeer_Static[] = {
        { }};

    static PyType_Slot type_slots_BreadcrumbBarItemAutomationPeer_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_BreadcrumbBarItemAutomationPeer_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_BreadcrumbBarItemAutomationPeer_Static) },
        { }
    };

    static PyType_Spec type_spec_BreadcrumbBarItemAutomationPeer_Static = {
        "winui2._winui2_microsoft_ui_xaml_automation_peers.BreadcrumbBarItemAutomationPeer_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_BreadcrumbBarItemAutomationPeer_Static};

    // ----- ColorPickerSliderAutomationPeer class --------------------

    struct PyWinrtColorPickerSliderAutomationPeer;
    using BasePyWinrtColorPickerSliderAutomationPeer = winrt::Microsoft::UI::Xaml::Automation::Peers::ColorPickerSliderAutomationPeerT<PyWinrtColorPickerSliderAutomationPeer, py::IPywinrtObject>;

    struct PyWinrtColorPickerSliderAutomationPeer : py::py_obj_ref, BasePyWinrtColorPickerSliderAutomationPeer
    {
        PyWinrtColorPickerSliderAutomationPeer(PyObject* py_obj, winrt::Microsoft::UI::Xaml::Controls::Primitives::ColorPickerSlider owner) : py::py_obj_ref(py_obj), BasePyWinrtColorPickerSliderAutomationPeer(owner) {}

        int32_t __stdcall GetPyObject(PyObject*& obj) override
        {
            obj = py::py_obj_ref::get_py_obj();
            return 0;
        }

        int32_t __stdcall GetComposableInner(winrt::Windows::Foundation::IInspectable& inner) override
        {
            inner = m_inner;
            return winrt::impl::error_ok;
        }

        static void toggle_reference(PyWinrtColorPickerSliderAutomationPeer* instance, bool is_last_reference)
        {
            py::py_obj_ref::toggle_reference(instance, is_last_reference);
        }

        int32_t query_interface_tearoff(winrt::guid const& id, void** result) const noexcept override
        {
            return py::py_obj_ref::query_interface_tearoff(id, result);
        }

        std::vector<winrt::guid> get_iids_tearoff() const noexcept override
        {
            return py::py_obj_ref::get_iids_tearoff();
        }
    };

    static PyObject* _new_ColorPickerSliderAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_GET_SIZE(args);

        auto self_type = get_python_type_for<winrt::Microsoft::UI::Xaml::Automation::Peers::ColorPickerSliderAutomationPeer>();
        if (!self_type)
        {
            return nullptr;
        }

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::Primitives::ColorPickerSlider>(args, 0);

                if (type != self_type)
                {
                    py::pyobj_handle self{type->tp_alloc(type, 0)};
                    if (!self)
                    {
                        return nullptr;
                    }

                    std::construct_at(&reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj, nullptr);

                    auto obj_impl = winrt::make_self<PyWinrtColorPickerSliderAutomationPeer>(self.get(), param0);

                    auto obj = py::make_py_obj<PyWinrtColorPickerSliderAutomationPeer>(obj_impl, type, self.get());
                    if (!obj)
                    {
                        return nullptr;
                    }

                    reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj = std::move(obj);

                    return self.detach();
                }

                winrt::Microsoft::UI::Xaml::Automation::Peers::ColorPickerSliderAutomationPeer instance{param0};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ColorPickerSliderAutomationPeer(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_ColorPickerSliderAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Automation::Peers::ColorPickerSliderAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ColorPickerSliderAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Automation::Peers::ColorPickerSliderAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ColorPickerSliderAutomationPeer[] = {
        { "_assign_array_", _assign_array_ColorPickerSliderAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ColorPickerSliderAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_ColorPickerSliderAutomationPeer[] = {
        { }};

    static PyType_Slot _type_slots_ColorPickerSliderAutomationPeer[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ColorPickerSliderAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ColorPickerSliderAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ColorPickerSliderAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ColorPickerSliderAutomationPeer) },
        { }};

    static PyType_Spec type_spec_ColorPickerSliderAutomationPeer = {
        "winui2._winui2_microsoft_ui_xaml_automation_peers.ColorPickerSliderAutomationPeer",
        sizeof(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_ColorPickerSliderAutomationPeer};

    static PyGetSetDef getset_ColorPickerSliderAutomationPeer_Static[] = {
        { }};

    static PyMethodDef methods_ColorPickerSliderAutomationPeer_Static[] = {
        { }};

    static PyType_Slot type_slots_ColorPickerSliderAutomationPeer_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_ColorPickerSliderAutomationPeer_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_ColorPickerSliderAutomationPeer_Static) },
        { }
    };

    static PyType_Spec type_spec_ColorPickerSliderAutomationPeer_Static = {
        "winui2._winui2_microsoft_ui_xaml_automation_peers.ColorPickerSliderAutomationPeer_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_ColorPickerSliderAutomationPeer_Static};

    // ----- ColorSpectrumAutomationPeer class --------------------

    struct PyWinrtColorSpectrumAutomationPeer;
    using BasePyWinrtColorSpectrumAutomationPeer = winrt::Microsoft::UI::Xaml::Automation::Peers::ColorSpectrumAutomationPeerT<PyWinrtColorSpectrumAutomationPeer, py::IPywinrtObject>;

    struct PyWinrtColorSpectrumAutomationPeer : py::py_obj_ref, BasePyWinrtColorSpectrumAutomationPeer
    {
        PyWinrtColorSpectrumAutomationPeer(PyObject* py_obj, winrt::Microsoft::UI::Xaml::Controls::Primitives::ColorSpectrum owner) : py::py_obj_ref(py_obj), BasePyWinrtColorSpectrumAutomationPeer(owner) {}

        int32_t __stdcall GetPyObject(PyObject*& obj) override
        {
            obj = py::py_obj_ref::get_py_obj();
            return 0;
        }

        int32_t __stdcall GetComposableInner(winrt::Windows::Foundation::IInspectable& inner) override
        {
            inner = m_inner;
            return winrt::impl::error_ok;
        }

        static void toggle_reference(PyWinrtColorSpectrumAutomationPeer* instance, bool is_last_reference)
        {
            py::py_obj_ref::toggle_reference(instance, is_last_reference);
        }

        int32_t query_interface_tearoff(winrt::guid const& id, void** result) const noexcept override
        {
            return py::py_obj_ref::query_interface_tearoff(id, result);
        }

        std::vector<winrt::guid> get_iids_tearoff() const noexcept override
        {
            return py::py_obj_ref::get_iids_tearoff();
        }
    };

    static PyObject* _new_ColorSpectrumAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_GET_SIZE(args);

        auto self_type = get_python_type_for<winrt::Microsoft::UI::Xaml::Automation::Peers::ColorSpectrumAutomationPeer>();
        if (!self_type)
        {
            return nullptr;
        }

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::Primitives::ColorSpectrum>(args, 0);

                if (type != self_type)
                {
                    py::pyobj_handle self{type->tp_alloc(type, 0)};
                    if (!self)
                    {
                        return nullptr;
                    }

                    std::construct_at(&reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj, nullptr);

                    auto obj_impl = winrt::make_self<PyWinrtColorSpectrumAutomationPeer>(self.get(), param0);

                    auto obj = py::make_py_obj<PyWinrtColorSpectrumAutomationPeer>(obj_impl, type, self.get());
                    if (!obj)
                    {
                        return nullptr;
                    }

                    reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj = std::move(obj);

                    return self.detach();
                }

                winrt::Microsoft::UI::Xaml::Automation::Peers::ColorSpectrumAutomationPeer instance{param0};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ColorSpectrumAutomationPeer(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_ColorSpectrumAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Automation::Peers::ColorSpectrumAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ColorSpectrumAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Automation::Peers::ColorSpectrumAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ColorSpectrumAutomationPeer[] = {
        { "_assign_array_", _assign_array_ColorSpectrumAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ColorSpectrumAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_ColorSpectrumAutomationPeer[] = {
        { }};

    static PyType_Slot _type_slots_ColorSpectrumAutomationPeer[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ColorSpectrumAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ColorSpectrumAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ColorSpectrumAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ColorSpectrumAutomationPeer) },
        { }};

    static PyType_Spec type_spec_ColorSpectrumAutomationPeer = {
        "winui2._winui2_microsoft_ui_xaml_automation_peers.ColorSpectrumAutomationPeer",
        sizeof(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_ColorSpectrumAutomationPeer};

    static PyGetSetDef getset_ColorSpectrumAutomationPeer_Static[] = {
        { }};

    static PyMethodDef methods_ColorSpectrumAutomationPeer_Static[] = {
        { }};

    static PyType_Slot type_slots_ColorSpectrumAutomationPeer_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_ColorSpectrumAutomationPeer_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_ColorSpectrumAutomationPeer_Static) },
        { }
    };

    static PyType_Spec type_spec_ColorSpectrumAutomationPeer_Static = {
        "winui2._winui2_microsoft_ui_xaml_automation_peers.ColorSpectrumAutomationPeer_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_ColorSpectrumAutomationPeer_Static};

    // ----- DropDownButtonAutomationPeer class --------------------

    struct PyWinrtDropDownButtonAutomationPeer;
    using BasePyWinrtDropDownButtonAutomationPeer = winrt::Microsoft::UI::Xaml::Automation::Peers::DropDownButtonAutomationPeerT<PyWinrtDropDownButtonAutomationPeer, py::IPywinrtObject>;

    struct PyWinrtDropDownButtonAutomationPeer : py::py_obj_ref, BasePyWinrtDropDownButtonAutomationPeer
    {
        PyWinrtDropDownButtonAutomationPeer(PyObject* py_obj, winrt::Microsoft::UI::Xaml::Controls::DropDownButton owner) : py::py_obj_ref(py_obj), BasePyWinrtDropDownButtonAutomationPeer(owner) {}

        int32_t __stdcall GetPyObject(PyObject*& obj) override
        {
            obj = py::py_obj_ref::get_py_obj();
            return 0;
        }

        int32_t __stdcall GetComposableInner(winrt::Windows::Foundation::IInspectable& inner) override
        {
            inner = m_inner;
            return winrt::impl::error_ok;
        }

        static void toggle_reference(PyWinrtDropDownButtonAutomationPeer* instance, bool is_last_reference)
        {
            py::py_obj_ref::toggle_reference(instance, is_last_reference);
        }

        int32_t query_interface_tearoff(winrt::guid const& id, void** result) const noexcept override
        {
            return py::py_obj_ref::query_interface_tearoff(id, result);
        }

        std::vector<winrt::guid> get_iids_tearoff() const noexcept override
        {
            return py::py_obj_ref::get_iids_tearoff();
        }
    };

    static PyObject* _new_DropDownButtonAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_GET_SIZE(args);

        auto self_type = get_python_type_for<winrt::Microsoft::UI::Xaml::Automation::Peers::DropDownButtonAutomationPeer>();
        if (!self_type)
        {
            return nullptr;
        }

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::DropDownButton>(args, 0);

                if (type != self_type)
                {
                    py::pyobj_handle self{type->tp_alloc(type, 0)};
                    if (!self)
                    {
                        return nullptr;
                    }

                    std::construct_at(&reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj, nullptr);

                    auto obj_impl = winrt::make_self<PyWinrtDropDownButtonAutomationPeer>(self.get(), param0);

                    auto obj = py::make_py_obj<PyWinrtDropDownButtonAutomationPeer>(obj_impl, type, self.get());
                    if (!obj)
                    {
                        return nullptr;
                    }

                    reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj = std::move(obj);

                    return self.detach();
                }

                winrt::Microsoft::UI::Xaml::Automation::Peers::DropDownButtonAutomationPeer instance{param0};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_DropDownButtonAutomationPeer(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* DropDownButtonAutomationPeer_Collapse(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.Peers.DropDownButtonAutomationPeer", L"Collapse", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.try_as<winrt::Microsoft::UI::Xaml::Automation::Peers::DropDownButtonAutomationPeer>().Collapse();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DropDownButtonAutomationPeer_Expand(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.Peers.DropDownButtonAutomationPeer", L"Expand", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.try_as<winrt::Microsoft::UI::Xaml::Automation::Peers::DropDownButtonAutomationPeer>().Expand();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DropDownButtonAutomationPeer_get_ExpandCollapseState(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.Peers.DropDownButtonAutomationPeer", L"ExpandCollapseState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Automation::Peers::DropDownButtonAutomationPeer>().ExpandCollapseState();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_DropDownButtonAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Automation::Peers::DropDownButtonAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_DropDownButtonAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Automation::Peers::DropDownButtonAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DropDownButtonAutomationPeer[] = {
        { "collapse", reinterpret_cast<PyCFunction>(DropDownButtonAutomationPeer_Collapse), METH_VARARGS, nullptr },
        { "expand", reinterpret_cast<PyCFunction>(DropDownButtonAutomationPeer_Expand), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_DropDownButtonAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_DropDownButtonAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_DropDownButtonAutomationPeer[] = {
        { "expand_collapse_state", reinterpret_cast<getter>(DropDownButtonAutomationPeer_get_ExpandCollapseState), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_DropDownButtonAutomationPeer[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_DropDownButtonAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_DropDownButtonAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_DropDownButtonAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_DropDownButtonAutomationPeer) },
        { }};

    static PyType_Spec type_spec_DropDownButtonAutomationPeer = {
        "winui2._winui2_microsoft_ui_xaml_automation_peers.DropDownButtonAutomationPeer",
        sizeof(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_DropDownButtonAutomationPeer};

    static PyGetSetDef getset_DropDownButtonAutomationPeer_Static[] = {
        { }};

    static PyMethodDef methods_DropDownButtonAutomationPeer_Static[] = {
        { }};

    static PyType_Slot type_slots_DropDownButtonAutomationPeer_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_DropDownButtonAutomationPeer_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_DropDownButtonAutomationPeer_Static) },
        { }
    };

    static PyType_Spec type_spec_DropDownButtonAutomationPeer_Static = {
        "winui2._winui2_microsoft_ui_xaml_automation_peers.DropDownButtonAutomationPeer_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_DropDownButtonAutomationPeer_Static};

    // ----- ExpanderAutomationPeer class --------------------

    struct PyWinrtExpanderAutomationPeer;
    using BasePyWinrtExpanderAutomationPeer = winrt::Microsoft::UI::Xaml::Automation::Peers::ExpanderAutomationPeerT<PyWinrtExpanderAutomationPeer, py::IPywinrtObject>;

    struct PyWinrtExpanderAutomationPeer : py::py_obj_ref, BasePyWinrtExpanderAutomationPeer
    {
        PyWinrtExpanderAutomationPeer(PyObject* py_obj, winrt::Microsoft::UI::Xaml::Controls::Expander owner) : py::py_obj_ref(py_obj), BasePyWinrtExpanderAutomationPeer(owner) {}

        int32_t __stdcall GetPyObject(PyObject*& obj) override
        {
            obj = py::py_obj_ref::get_py_obj();
            return 0;
        }

        int32_t __stdcall GetComposableInner(winrt::Windows::Foundation::IInspectable& inner) override
        {
            inner = m_inner;
            return winrt::impl::error_ok;
        }

        static void toggle_reference(PyWinrtExpanderAutomationPeer* instance, bool is_last_reference)
        {
            py::py_obj_ref::toggle_reference(instance, is_last_reference);
        }

        int32_t query_interface_tearoff(winrt::guid const& id, void** result) const noexcept override
        {
            return py::py_obj_ref::query_interface_tearoff(id, result);
        }

        std::vector<winrt::guid> get_iids_tearoff() const noexcept override
        {
            return py::py_obj_ref::get_iids_tearoff();
        }
    };

    static PyObject* _new_ExpanderAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_GET_SIZE(args);

        auto self_type = get_python_type_for<winrt::Microsoft::UI::Xaml::Automation::Peers::ExpanderAutomationPeer>();
        if (!self_type)
        {
            return nullptr;
        }

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::Expander>(args, 0);

                if (type != self_type)
                {
                    py::pyobj_handle self{type->tp_alloc(type, 0)};
                    if (!self)
                    {
                        return nullptr;
                    }

                    std::construct_at(&reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj, nullptr);

                    auto obj_impl = winrt::make_self<PyWinrtExpanderAutomationPeer>(self.get(), param0);

                    auto obj = py::make_py_obj<PyWinrtExpanderAutomationPeer>(obj_impl, type, self.get());
                    if (!obj)
                    {
                        return nullptr;
                    }

                    reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj = std::move(obj);

                    return self.detach();
                }

                winrt::Microsoft::UI::Xaml::Automation::Peers::ExpanderAutomationPeer instance{param0};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ExpanderAutomationPeer(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ExpanderAutomationPeer_Collapse(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.Peers.ExpanderAutomationPeer", L"Collapse", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.try_as<winrt::Microsoft::UI::Xaml::Automation::Peers::ExpanderAutomationPeer>().Collapse();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ExpanderAutomationPeer_Expand(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.Peers.ExpanderAutomationPeer", L"Expand", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.try_as<winrt::Microsoft::UI::Xaml::Automation::Peers::ExpanderAutomationPeer>().Expand();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ExpanderAutomationPeer_get_ExpandCollapseState(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.Peers.ExpanderAutomationPeer", L"ExpandCollapseState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Automation::Peers::ExpanderAutomationPeer>().ExpandCollapseState();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ExpanderAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Automation::Peers::ExpanderAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ExpanderAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Automation::Peers::ExpanderAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ExpanderAutomationPeer[] = {
        { "collapse", reinterpret_cast<PyCFunction>(ExpanderAutomationPeer_Collapse), METH_VARARGS, nullptr },
        { "expand", reinterpret_cast<PyCFunction>(ExpanderAutomationPeer_Expand), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_ExpanderAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ExpanderAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_ExpanderAutomationPeer[] = {
        { "expand_collapse_state", reinterpret_cast<getter>(ExpanderAutomationPeer_get_ExpandCollapseState), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_ExpanderAutomationPeer[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ExpanderAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ExpanderAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ExpanderAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ExpanderAutomationPeer) },
        { }};

    static PyType_Spec type_spec_ExpanderAutomationPeer = {
        "winui2._winui2_microsoft_ui_xaml_automation_peers.ExpanderAutomationPeer",
        sizeof(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_ExpanderAutomationPeer};

    static PyGetSetDef getset_ExpanderAutomationPeer_Static[] = {
        { }};

    static PyMethodDef methods_ExpanderAutomationPeer_Static[] = {
        { }};

    static PyType_Slot type_slots_ExpanderAutomationPeer_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_ExpanderAutomationPeer_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_ExpanderAutomationPeer_Static) },
        { }
    };

    static PyType_Spec type_spec_ExpanderAutomationPeer_Static = {
        "winui2._winui2_microsoft_ui_xaml_automation_peers.ExpanderAutomationPeer_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_ExpanderAutomationPeer_Static};

    // ----- InfoBarAutomationPeer class --------------------

    struct PyWinrtInfoBarAutomationPeer;
    using BasePyWinrtInfoBarAutomationPeer = winrt::Microsoft::UI::Xaml::Automation::Peers::InfoBarAutomationPeerT<PyWinrtInfoBarAutomationPeer, py::IPywinrtObject>;

    struct PyWinrtInfoBarAutomationPeer : py::py_obj_ref, BasePyWinrtInfoBarAutomationPeer
    {
        PyWinrtInfoBarAutomationPeer(PyObject* py_obj, winrt::Microsoft::UI::Xaml::Controls::InfoBar owner) : py::py_obj_ref(py_obj), BasePyWinrtInfoBarAutomationPeer(owner) {}

        int32_t __stdcall GetPyObject(PyObject*& obj) override
        {
            obj = py::py_obj_ref::get_py_obj();
            return 0;
        }

        int32_t __stdcall GetComposableInner(winrt::Windows::Foundation::IInspectable& inner) override
        {
            inner = m_inner;
            return winrt::impl::error_ok;
        }

        static void toggle_reference(PyWinrtInfoBarAutomationPeer* instance, bool is_last_reference)
        {
            py::py_obj_ref::toggle_reference(instance, is_last_reference);
        }

        int32_t query_interface_tearoff(winrt::guid const& id, void** result) const noexcept override
        {
            return py::py_obj_ref::query_interface_tearoff(id, result);
        }

        std::vector<winrt::guid> get_iids_tearoff() const noexcept override
        {
            return py::py_obj_ref::get_iids_tearoff();
        }
    };

    static PyObject* _new_InfoBarAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_GET_SIZE(args);

        auto self_type = get_python_type_for<winrt::Microsoft::UI::Xaml::Automation::Peers::InfoBarAutomationPeer>();
        if (!self_type)
        {
            return nullptr;
        }

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::InfoBar>(args, 0);

                if (type != self_type)
                {
                    py::pyobj_handle self{type->tp_alloc(type, 0)};
                    if (!self)
                    {
                        return nullptr;
                    }

                    std::construct_at(&reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj, nullptr);

                    auto obj_impl = winrt::make_self<PyWinrtInfoBarAutomationPeer>(self.get(), param0);

                    auto obj = py::make_py_obj<PyWinrtInfoBarAutomationPeer>(obj_impl, type, self.get());
                    if (!obj)
                    {
                        return nullptr;
                    }

                    reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj = std::move(obj);

                    return self.detach();
                }

                winrt::Microsoft::UI::Xaml::Automation::Peers::InfoBarAutomationPeer instance{param0};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_InfoBarAutomationPeer(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_InfoBarAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Automation::Peers::InfoBarAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_InfoBarAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Automation::Peers::InfoBarAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_InfoBarAutomationPeer[] = {
        { "_assign_array_", _assign_array_InfoBarAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_InfoBarAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_InfoBarAutomationPeer[] = {
        { }};

    static PyType_Slot _type_slots_InfoBarAutomationPeer[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_InfoBarAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_InfoBarAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_InfoBarAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_InfoBarAutomationPeer) },
        { }};

    static PyType_Spec type_spec_InfoBarAutomationPeer = {
        "winui2._winui2_microsoft_ui_xaml_automation_peers.InfoBarAutomationPeer",
        sizeof(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_InfoBarAutomationPeer};

    static PyGetSetDef getset_InfoBarAutomationPeer_Static[] = {
        { }};

    static PyMethodDef methods_InfoBarAutomationPeer_Static[] = {
        { }};

    static PyType_Slot type_slots_InfoBarAutomationPeer_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_InfoBarAutomationPeer_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_InfoBarAutomationPeer_Static) },
        { }
    };

    static PyType_Spec type_spec_InfoBarAutomationPeer_Static = {
        "winui2._winui2_microsoft_ui_xaml_automation_peers.InfoBarAutomationPeer_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_InfoBarAutomationPeer_Static};

    // ----- MenuBarAutomationPeer class --------------------

    struct PyWinrtMenuBarAutomationPeer;
    using BasePyWinrtMenuBarAutomationPeer = winrt::Microsoft::UI::Xaml::Automation::Peers::MenuBarAutomationPeerT<PyWinrtMenuBarAutomationPeer, py::IPywinrtObject>;

    struct PyWinrtMenuBarAutomationPeer : py::py_obj_ref, BasePyWinrtMenuBarAutomationPeer
    {
        PyWinrtMenuBarAutomationPeer(PyObject* py_obj, winrt::Microsoft::UI::Xaml::Controls::MenuBar owner) : py::py_obj_ref(py_obj), BasePyWinrtMenuBarAutomationPeer(owner) {}

        int32_t __stdcall GetPyObject(PyObject*& obj) override
        {
            obj = py::py_obj_ref::get_py_obj();
            return 0;
        }

        int32_t __stdcall GetComposableInner(winrt::Windows::Foundation::IInspectable& inner) override
        {
            inner = m_inner;
            return winrt::impl::error_ok;
        }

        static void toggle_reference(PyWinrtMenuBarAutomationPeer* instance, bool is_last_reference)
        {
            py::py_obj_ref::toggle_reference(instance, is_last_reference);
        }

        int32_t query_interface_tearoff(winrt::guid const& id, void** result) const noexcept override
        {
            return py::py_obj_ref::query_interface_tearoff(id, result);
        }

        std::vector<winrt::guid> get_iids_tearoff() const noexcept override
        {
            return py::py_obj_ref::get_iids_tearoff();
        }
    };

    static PyObject* _new_MenuBarAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_GET_SIZE(args);

        auto self_type = get_python_type_for<winrt::Microsoft::UI::Xaml::Automation::Peers::MenuBarAutomationPeer>();
        if (!self_type)
        {
            return nullptr;
        }

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::MenuBar>(args, 0);

                if (type != self_type)
                {
                    py::pyobj_handle self{type->tp_alloc(type, 0)};
                    if (!self)
                    {
                        return nullptr;
                    }

                    std::construct_at(&reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj, nullptr);

                    auto obj_impl = winrt::make_self<PyWinrtMenuBarAutomationPeer>(self.get(), param0);

                    auto obj = py::make_py_obj<PyWinrtMenuBarAutomationPeer>(obj_impl, type, self.get());
                    if (!obj)
                    {
                        return nullptr;
                    }

                    reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj = std::move(obj);

                    return self.detach();
                }

                winrt::Microsoft::UI::Xaml::Automation::Peers::MenuBarAutomationPeer instance{param0};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_MenuBarAutomationPeer(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_MenuBarAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Automation::Peers::MenuBarAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MenuBarAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Automation::Peers::MenuBarAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MenuBarAutomationPeer[] = {
        { "_assign_array_", _assign_array_MenuBarAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MenuBarAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_MenuBarAutomationPeer[] = {
        { }};

    static PyType_Slot _type_slots_MenuBarAutomationPeer[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_MenuBarAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MenuBarAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MenuBarAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MenuBarAutomationPeer) },
        { }};

    static PyType_Spec type_spec_MenuBarAutomationPeer = {
        "winui2._winui2_microsoft_ui_xaml_automation_peers.MenuBarAutomationPeer",
        sizeof(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_MenuBarAutomationPeer};

    static PyGetSetDef getset_MenuBarAutomationPeer_Static[] = {
        { }};

    static PyMethodDef methods_MenuBarAutomationPeer_Static[] = {
        { }};

    static PyType_Slot type_slots_MenuBarAutomationPeer_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_MenuBarAutomationPeer_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_MenuBarAutomationPeer_Static) },
        { }
    };

    static PyType_Spec type_spec_MenuBarAutomationPeer_Static = {
        "winui2._winui2_microsoft_ui_xaml_automation_peers.MenuBarAutomationPeer_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_MenuBarAutomationPeer_Static};

    // ----- MenuBarItemAutomationPeer class --------------------

    struct PyWinrtMenuBarItemAutomationPeer;
    using BasePyWinrtMenuBarItemAutomationPeer = winrt::Microsoft::UI::Xaml::Automation::Peers::MenuBarItemAutomationPeerT<PyWinrtMenuBarItemAutomationPeer, py::IPywinrtObject>;

    struct PyWinrtMenuBarItemAutomationPeer : py::py_obj_ref, BasePyWinrtMenuBarItemAutomationPeer
    {
        PyWinrtMenuBarItemAutomationPeer(PyObject* py_obj, winrt::Microsoft::UI::Xaml::Controls::MenuBarItem owner) : py::py_obj_ref(py_obj), BasePyWinrtMenuBarItemAutomationPeer(owner) {}

        int32_t __stdcall GetPyObject(PyObject*& obj) override
        {
            obj = py::py_obj_ref::get_py_obj();
            return 0;
        }

        int32_t __stdcall GetComposableInner(winrt::Windows::Foundation::IInspectable& inner) override
        {
            inner = m_inner;
            return winrt::impl::error_ok;
        }

        static void toggle_reference(PyWinrtMenuBarItemAutomationPeer* instance, bool is_last_reference)
        {
            py::py_obj_ref::toggle_reference(instance, is_last_reference);
        }

        int32_t query_interface_tearoff(winrt::guid const& id, void** result) const noexcept override
        {
            return py::py_obj_ref::query_interface_tearoff(id, result);
        }

        std::vector<winrt::guid> get_iids_tearoff() const noexcept override
        {
            return py::py_obj_ref::get_iids_tearoff();
        }
    };

    static PyObject* _new_MenuBarItemAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_GET_SIZE(args);

        auto self_type = get_python_type_for<winrt::Microsoft::UI::Xaml::Automation::Peers::MenuBarItemAutomationPeer>();
        if (!self_type)
        {
            return nullptr;
        }

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::MenuBarItem>(args, 0);

                if (type != self_type)
                {
                    py::pyobj_handle self{type->tp_alloc(type, 0)};
                    if (!self)
                    {
                        return nullptr;
                    }

                    std::construct_at(&reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj, nullptr);

                    auto obj_impl = winrt::make_self<PyWinrtMenuBarItemAutomationPeer>(self.get(), param0);

                    auto obj = py::make_py_obj<PyWinrtMenuBarItemAutomationPeer>(obj_impl, type, self.get());
                    if (!obj)
                    {
                        return nullptr;
                    }

                    reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj = std::move(obj);

                    return self.detach();
                }

                winrt::Microsoft::UI::Xaml::Automation::Peers::MenuBarItemAutomationPeer instance{param0};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_MenuBarItemAutomationPeer(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MenuBarItemAutomationPeer_Collapse(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.Peers.MenuBarItemAutomationPeer", L"Collapse", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.try_as<winrt::Microsoft::UI::Xaml::Automation::Peers::MenuBarItemAutomationPeer>().Collapse();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MenuBarItemAutomationPeer_Expand(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.Peers.MenuBarItemAutomationPeer", L"Expand", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.try_as<winrt::Microsoft::UI::Xaml::Automation::Peers::MenuBarItemAutomationPeer>().Expand();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MenuBarItemAutomationPeer_Invoke(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.Peers.MenuBarItemAutomationPeer", L"Invoke", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.try_as<winrt::Microsoft::UI::Xaml::Automation::Peers::MenuBarItemAutomationPeer>().Invoke();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MenuBarItemAutomationPeer_get_ExpandCollapseState(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.Peers.MenuBarItemAutomationPeer", L"ExpandCollapseState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Automation::Peers::MenuBarItemAutomationPeer>().ExpandCollapseState();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MenuBarItemAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Automation::Peers::MenuBarItemAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MenuBarItemAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Automation::Peers::MenuBarItemAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MenuBarItemAutomationPeer[] = {
        { "collapse", reinterpret_cast<PyCFunction>(MenuBarItemAutomationPeer_Collapse), METH_VARARGS, nullptr },
        { "expand", reinterpret_cast<PyCFunction>(MenuBarItemAutomationPeer_Expand), METH_VARARGS, nullptr },
        { "invoke", reinterpret_cast<PyCFunction>(MenuBarItemAutomationPeer_Invoke), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_MenuBarItemAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MenuBarItemAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_MenuBarItemAutomationPeer[] = {
        { "expand_collapse_state", reinterpret_cast<getter>(MenuBarItemAutomationPeer_get_ExpandCollapseState), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_MenuBarItemAutomationPeer[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_MenuBarItemAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MenuBarItemAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MenuBarItemAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MenuBarItemAutomationPeer) },
        { }};

    static PyType_Spec type_spec_MenuBarItemAutomationPeer = {
        "winui2._winui2_microsoft_ui_xaml_automation_peers.MenuBarItemAutomationPeer",
        sizeof(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_MenuBarItemAutomationPeer};

    static PyGetSetDef getset_MenuBarItemAutomationPeer_Static[] = {
        { }};

    static PyMethodDef methods_MenuBarItemAutomationPeer_Static[] = {
        { }};

    static PyType_Slot type_slots_MenuBarItemAutomationPeer_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_MenuBarItemAutomationPeer_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_MenuBarItemAutomationPeer_Static) },
        { }
    };

    static PyType_Spec type_spec_MenuBarItemAutomationPeer_Static = {
        "winui2._winui2_microsoft_ui_xaml_automation_peers.MenuBarItemAutomationPeer_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_MenuBarItemAutomationPeer_Static};

    // ----- NavigationViewAutomationPeer class --------------------

    struct PyWinrtNavigationViewAutomationPeer;
    using BasePyWinrtNavigationViewAutomationPeer = winrt::Microsoft::UI::Xaml::Automation::Peers::NavigationViewAutomationPeerT<PyWinrtNavigationViewAutomationPeer, py::IPywinrtObject>;

    struct PyWinrtNavigationViewAutomationPeer : py::py_obj_ref, BasePyWinrtNavigationViewAutomationPeer
    {
        PyWinrtNavigationViewAutomationPeer(PyObject* py_obj, winrt::Microsoft::UI::Xaml::Controls::NavigationView owner) : py::py_obj_ref(py_obj), BasePyWinrtNavigationViewAutomationPeer(owner) {}

        int32_t __stdcall GetPyObject(PyObject*& obj) override
        {
            obj = py::py_obj_ref::get_py_obj();
            return 0;
        }

        int32_t __stdcall GetComposableInner(winrt::Windows::Foundation::IInspectable& inner) override
        {
            inner = m_inner;
            return winrt::impl::error_ok;
        }

        static void toggle_reference(PyWinrtNavigationViewAutomationPeer* instance, bool is_last_reference)
        {
            py::py_obj_ref::toggle_reference(instance, is_last_reference);
        }

        int32_t query_interface_tearoff(winrt::guid const& id, void** result) const noexcept override
        {
            return py::py_obj_ref::query_interface_tearoff(id, result);
        }

        std::vector<winrt::guid> get_iids_tearoff() const noexcept override
        {
            return py::py_obj_ref::get_iids_tearoff();
        }
    };

    static PyObject* _new_NavigationViewAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_GET_SIZE(args);

        auto self_type = get_python_type_for<winrt::Microsoft::UI::Xaml::Automation::Peers::NavigationViewAutomationPeer>();
        if (!self_type)
        {
            return nullptr;
        }

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::NavigationView>(args, 0);

                if (type != self_type)
                {
                    py::pyobj_handle self{type->tp_alloc(type, 0)};
                    if (!self)
                    {
                        return nullptr;
                    }

                    std::construct_at(&reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj, nullptr);

                    auto obj_impl = winrt::make_self<PyWinrtNavigationViewAutomationPeer>(self.get(), param0);

                    auto obj = py::make_py_obj<PyWinrtNavigationViewAutomationPeer>(obj_impl, type, self.get());
                    if (!obj)
                    {
                        return nullptr;
                    }

                    reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj = std::move(obj);

                    return self.detach();
                }

                winrt::Microsoft::UI::Xaml::Automation::Peers::NavigationViewAutomationPeer instance{param0};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_NavigationViewAutomationPeer(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_NavigationViewAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Automation::Peers::NavigationViewAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_NavigationViewAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Automation::Peers::NavigationViewAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_NavigationViewAutomationPeer[] = {
        { "_assign_array_", _assign_array_NavigationViewAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_NavigationViewAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_NavigationViewAutomationPeer[] = {
        { }};

    static PyType_Slot _type_slots_NavigationViewAutomationPeer[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_NavigationViewAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_NavigationViewAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_NavigationViewAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_NavigationViewAutomationPeer) },
        { }};

    static PyType_Spec type_spec_NavigationViewAutomationPeer = {
        "winui2._winui2_microsoft_ui_xaml_automation_peers.NavigationViewAutomationPeer",
        sizeof(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_NavigationViewAutomationPeer};

    static PyGetSetDef getset_NavigationViewAutomationPeer_Static[] = {
        { }};

    static PyMethodDef methods_NavigationViewAutomationPeer_Static[] = {
        { }};

    static PyType_Slot type_slots_NavigationViewAutomationPeer_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_NavigationViewAutomationPeer_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_NavigationViewAutomationPeer_Static) },
        { }
    };

    static PyType_Spec type_spec_NavigationViewAutomationPeer_Static = {
        "winui2._winui2_microsoft_ui_xaml_automation_peers.NavigationViewAutomationPeer_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_NavigationViewAutomationPeer_Static};

    // ----- NavigationViewItemAutomationPeer class --------------------

    struct PyWinrtNavigationViewItemAutomationPeer;
    using BasePyWinrtNavigationViewItemAutomationPeer = winrt::Microsoft::UI::Xaml::Automation::Peers::NavigationViewItemAutomationPeerT<PyWinrtNavigationViewItemAutomationPeer, py::IPywinrtObject>;

    struct PyWinrtNavigationViewItemAutomationPeer : py::py_obj_ref, BasePyWinrtNavigationViewItemAutomationPeer
    {
        PyWinrtNavigationViewItemAutomationPeer(PyObject* py_obj, winrt::Microsoft::UI::Xaml::Controls::NavigationViewItem owner) : py::py_obj_ref(py_obj), BasePyWinrtNavigationViewItemAutomationPeer(owner) {}

        int32_t __stdcall GetPyObject(PyObject*& obj) override
        {
            obj = py::py_obj_ref::get_py_obj();
            return 0;
        }

        int32_t __stdcall GetComposableInner(winrt::Windows::Foundation::IInspectable& inner) override
        {
            inner = m_inner;
            return winrt::impl::error_ok;
        }

        static void toggle_reference(PyWinrtNavigationViewItemAutomationPeer* instance, bool is_last_reference)
        {
            py::py_obj_ref::toggle_reference(instance, is_last_reference);
        }

        int32_t query_interface_tearoff(winrt::guid const& id, void** result) const noexcept override
        {
            return py::py_obj_ref::query_interface_tearoff(id, result);
        }

        std::vector<winrt::guid> get_iids_tearoff() const noexcept override
        {
            return py::py_obj_ref::get_iids_tearoff();
        }
    };

    static PyObject* _new_NavigationViewItemAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_GET_SIZE(args);

        auto self_type = get_python_type_for<winrt::Microsoft::UI::Xaml::Automation::Peers::NavigationViewItemAutomationPeer>();
        if (!self_type)
        {
            return nullptr;
        }

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::NavigationViewItem>(args, 0);

                if (type != self_type)
                {
                    py::pyobj_handle self{type->tp_alloc(type, 0)};
                    if (!self)
                    {
                        return nullptr;
                    }

                    std::construct_at(&reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj, nullptr);

                    auto obj_impl = winrt::make_self<PyWinrtNavigationViewItemAutomationPeer>(self.get(), param0);

                    auto obj = py::make_py_obj<PyWinrtNavigationViewItemAutomationPeer>(obj_impl, type, self.get());
                    if (!obj)
                    {
                        return nullptr;
                    }

                    reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj = std::move(obj);

                    return self.detach();
                }

                winrt::Microsoft::UI::Xaml::Automation::Peers::NavigationViewItemAutomationPeer instance{param0};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_NavigationViewItemAutomationPeer(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* NavigationViewItemAutomationPeer_Collapse(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.Peers.NavigationViewItemAutomationPeer", L"Collapse", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.try_as<winrt::Microsoft::UI::Xaml::Automation::Peers::NavigationViewItemAutomationPeer>().Collapse();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* NavigationViewItemAutomationPeer_Expand(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.Peers.NavigationViewItemAutomationPeer", L"Expand", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.try_as<winrt::Microsoft::UI::Xaml::Automation::Peers::NavigationViewItemAutomationPeer>().Expand();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* NavigationViewItemAutomationPeer_get_ExpandCollapseState(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.Peers.NavigationViewItemAutomationPeer", L"ExpandCollapseState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Automation::Peers::NavigationViewItemAutomationPeer>().ExpandCollapseState();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_NavigationViewItemAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Automation::Peers::NavigationViewItemAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_NavigationViewItemAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Automation::Peers::NavigationViewItemAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_NavigationViewItemAutomationPeer[] = {
        { "collapse", reinterpret_cast<PyCFunction>(NavigationViewItemAutomationPeer_Collapse), METH_VARARGS, nullptr },
        { "expand", reinterpret_cast<PyCFunction>(NavigationViewItemAutomationPeer_Expand), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_NavigationViewItemAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_NavigationViewItemAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_NavigationViewItemAutomationPeer[] = {
        { "expand_collapse_state", reinterpret_cast<getter>(NavigationViewItemAutomationPeer_get_ExpandCollapseState), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_NavigationViewItemAutomationPeer[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_NavigationViewItemAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_NavigationViewItemAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_NavigationViewItemAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_NavigationViewItemAutomationPeer) },
        { }};

    static PyType_Spec type_spec_NavigationViewItemAutomationPeer = {
        "winui2._winui2_microsoft_ui_xaml_automation_peers.NavigationViewItemAutomationPeer",
        sizeof(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_NavigationViewItemAutomationPeer};

    static PyGetSetDef getset_NavigationViewItemAutomationPeer_Static[] = {
        { }};

    static PyMethodDef methods_NavigationViewItemAutomationPeer_Static[] = {
        { }};

    static PyType_Slot type_slots_NavigationViewItemAutomationPeer_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_NavigationViewItemAutomationPeer_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_NavigationViewItemAutomationPeer_Static) },
        { }
    };

    static PyType_Spec type_spec_NavigationViewItemAutomationPeer_Static = {
        "winui2._winui2_microsoft_ui_xaml_automation_peers.NavigationViewItemAutomationPeer_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_NavigationViewItemAutomationPeer_Static};

    // ----- NumberBoxAutomationPeer class --------------------

    struct PyWinrtNumberBoxAutomationPeer;
    using BasePyWinrtNumberBoxAutomationPeer = winrt::Microsoft::UI::Xaml::Automation::Peers::NumberBoxAutomationPeerT<PyWinrtNumberBoxAutomationPeer, py::IPywinrtObject>;

    struct PyWinrtNumberBoxAutomationPeer : py::py_obj_ref, BasePyWinrtNumberBoxAutomationPeer
    {
        PyWinrtNumberBoxAutomationPeer(PyObject* py_obj, winrt::Microsoft::UI::Xaml::Controls::NumberBox owner) : py::py_obj_ref(py_obj), BasePyWinrtNumberBoxAutomationPeer(owner) {}

        int32_t __stdcall GetPyObject(PyObject*& obj) override
        {
            obj = py::py_obj_ref::get_py_obj();
            return 0;
        }

        int32_t __stdcall GetComposableInner(winrt::Windows::Foundation::IInspectable& inner) override
        {
            inner = m_inner;
            return winrt::impl::error_ok;
        }

        static void toggle_reference(PyWinrtNumberBoxAutomationPeer* instance, bool is_last_reference)
        {
            py::py_obj_ref::toggle_reference(instance, is_last_reference);
        }

        int32_t query_interface_tearoff(winrt::guid const& id, void** result) const noexcept override
        {
            return py::py_obj_ref::query_interface_tearoff(id, result);
        }

        std::vector<winrt::guid> get_iids_tearoff() const noexcept override
        {
            return py::py_obj_ref::get_iids_tearoff();
        }
    };

    static PyObject* _new_NumberBoxAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_GET_SIZE(args);

        auto self_type = get_python_type_for<winrt::Microsoft::UI::Xaml::Automation::Peers::NumberBoxAutomationPeer>();
        if (!self_type)
        {
            return nullptr;
        }

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::NumberBox>(args, 0);

                if (type != self_type)
                {
                    py::pyobj_handle self{type->tp_alloc(type, 0)};
                    if (!self)
                    {
                        return nullptr;
                    }

                    std::construct_at(&reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj, nullptr);

                    auto obj_impl = winrt::make_self<PyWinrtNumberBoxAutomationPeer>(self.get(), param0);

                    auto obj = py::make_py_obj<PyWinrtNumberBoxAutomationPeer>(obj_impl, type, self.get());
                    if (!obj)
                    {
                        return nullptr;
                    }

                    reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj = std::move(obj);

                    return self.detach();
                }

                winrt::Microsoft::UI::Xaml::Automation::Peers::NumberBoxAutomationPeer instance{param0};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_NumberBoxAutomationPeer(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_NumberBoxAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Automation::Peers::NumberBoxAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_NumberBoxAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Automation::Peers::NumberBoxAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_NumberBoxAutomationPeer[] = {
        { "_assign_array_", _assign_array_NumberBoxAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_NumberBoxAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_NumberBoxAutomationPeer[] = {
        { }};

    static PyType_Slot _type_slots_NumberBoxAutomationPeer[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_NumberBoxAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_NumberBoxAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_NumberBoxAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_NumberBoxAutomationPeer) },
        { }};

    static PyType_Spec type_spec_NumberBoxAutomationPeer = {
        "winui2._winui2_microsoft_ui_xaml_automation_peers.NumberBoxAutomationPeer",
        sizeof(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_NumberBoxAutomationPeer};

    static PyGetSetDef getset_NumberBoxAutomationPeer_Static[] = {
        { }};

    static PyMethodDef methods_NumberBoxAutomationPeer_Static[] = {
        { }};

    static PyType_Slot type_slots_NumberBoxAutomationPeer_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_NumberBoxAutomationPeer_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_NumberBoxAutomationPeer_Static) },
        { }
    };

    static PyType_Spec type_spec_NumberBoxAutomationPeer_Static = {
        "winui2._winui2_microsoft_ui_xaml_automation_peers.NumberBoxAutomationPeer_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_NumberBoxAutomationPeer_Static};

    // ----- PersonPictureAutomationPeer class --------------------

    struct PyWinrtPersonPictureAutomationPeer;
    using BasePyWinrtPersonPictureAutomationPeer = winrt::Microsoft::UI::Xaml::Automation::Peers::PersonPictureAutomationPeerT<PyWinrtPersonPictureAutomationPeer, py::IPywinrtObject>;

    struct PyWinrtPersonPictureAutomationPeer : py::py_obj_ref, BasePyWinrtPersonPictureAutomationPeer
    {
        PyWinrtPersonPictureAutomationPeer(PyObject* py_obj, winrt::Microsoft::UI::Xaml::Controls::PersonPicture owner) : py::py_obj_ref(py_obj), BasePyWinrtPersonPictureAutomationPeer(owner) {}

        int32_t __stdcall GetPyObject(PyObject*& obj) override
        {
            obj = py::py_obj_ref::get_py_obj();
            return 0;
        }

        int32_t __stdcall GetComposableInner(winrt::Windows::Foundation::IInspectable& inner) override
        {
            inner = m_inner;
            return winrt::impl::error_ok;
        }

        static void toggle_reference(PyWinrtPersonPictureAutomationPeer* instance, bool is_last_reference)
        {
            py::py_obj_ref::toggle_reference(instance, is_last_reference);
        }

        int32_t query_interface_tearoff(winrt::guid const& id, void** result) const noexcept override
        {
            return py::py_obj_ref::query_interface_tearoff(id, result);
        }

        std::vector<winrt::guid> get_iids_tearoff() const noexcept override
        {
            return py::py_obj_ref::get_iids_tearoff();
        }
    };

    static PyObject* _new_PersonPictureAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_GET_SIZE(args);

        auto self_type = get_python_type_for<winrt::Microsoft::UI::Xaml::Automation::Peers::PersonPictureAutomationPeer>();
        if (!self_type)
        {
            return nullptr;
        }

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::PersonPicture>(args, 0);

                if (type != self_type)
                {
                    py::pyobj_handle self{type->tp_alloc(type, 0)};
                    if (!self)
                    {
                        return nullptr;
                    }

                    std::construct_at(&reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj, nullptr);

                    auto obj_impl = winrt::make_self<PyWinrtPersonPictureAutomationPeer>(self.get(), param0);

                    auto obj = py::make_py_obj<PyWinrtPersonPictureAutomationPeer>(obj_impl, type, self.get());
                    if (!obj)
                    {
                        return nullptr;
                    }

                    reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj = std::move(obj);

                    return self.detach();
                }

                winrt::Microsoft::UI::Xaml::Automation::Peers::PersonPictureAutomationPeer instance{param0};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_PersonPictureAutomationPeer(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_PersonPictureAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Automation::Peers::PersonPictureAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PersonPictureAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Automation::Peers::PersonPictureAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PersonPictureAutomationPeer[] = {
        { "_assign_array_", _assign_array_PersonPictureAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PersonPictureAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_PersonPictureAutomationPeer[] = {
        { }};

    static PyType_Slot _type_slots_PersonPictureAutomationPeer[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_PersonPictureAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PersonPictureAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PersonPictureAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PersonPictureAutomationPeer) },
        { }};

    static PyType_Spec type_spec_PersonPictureAutomationPeer = {
        "winui2._winui2_microsoft_ui_xaml_automation_peers.PersonPictureAutomationPeer",
        sizeof(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_PersonPictureAutomationPeer};

    static PyGetSetDef getset_PersonPictureAutomationPeer_Static[] = {
        { }};

    static PyMethodDef methods_PersonPictureAutomationPeer_Static[] = {
        { }};

    static PyType_Slot type_slots_PersonPictureAutomationPeer_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_PersonPictureAutomationPeer_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_PersonPictureAutomationPeer_Static) },
        { }
    };

    static PyType_Spec type_spec_PersonPictureAutomationPeer_Static = {
        "winui2._winui2_microsoft_ui_xaml_automation_peers.PersonPictureAutomationPeer_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_PersonPictureAutomationPeer_Static};

    // ----- PipsPagerAutomationPeer class --------------------

    struct PyWinrtPipsPagerAutomationPeer;
    using BasePyWinrtPipsPagerAutomationPeer = winrt::Microsoft::UI::Xaml::Automation::Peers::PipsPagerAutomationPeerT<PyWinrtPipsPagerAutomationPeer, py::IPywinrtObject>;

    struct PyWinrtPipsPagerAutomationPeer : py::py_obj_ref, BasePyWinrtPipsPagerAutomationPeer
    {
        PyWinrtPipsPagerAutomationPeer(PyObject* py_obj, winrt::Microsoft::UI::Xaml::Controls::PipsPager owner) : py::py_obj_ref(py_obj), BasePyWinrtPipsPagerAutomationPeer(owner) {}

        int32_t __stdcall GetPyObject(PyObject*& obj) override
        {
            obj = py::py_obj_ref::get_py_obj();
            return 0;
        }

        int32_t __stdcall GetComposableInner(winrt::Windows::Foundation::IInspectable& inner) override
        {
            inner = m_inner;
            return winrt::impl::error_ok;
        }

        static void toggle_reference(PyWinrtPipsPagerAutomationPeer* instance, bool is_last_reference)
        {
            py::py_obj_ref::toggle_reference(instance, is_last_reference);
        }

        int32_t query_interface_tearoff(winrt::guid const& id, void** result) const noexcept override
        {
            return py::py_obj_ref::query_interface_tearoff(id, result);
        }

        std::vector<winrt::guid> get_iids_tearoff() const noexcept override
        {
            return py::py_obj_ref::get_iids_tearoff();
        }
    };

    static PyObject* _new_PipsPagerAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_GET_SIZE(args);

        auto self_type = get_python_type_for<winrt::Microsoft::UI::Xaml::Automation::Peers::PipsPagerAutomationPeer>();
        if (!self_type)
        {
            return nullptr;
        }

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::PipsPager>(args, 0);

                if (type != self_type)
                {
                    py::pyobj_handle self{type->tp_alloc(type, 0)};
                    if (!self)
                    {
                        return nullptr;
                    }

                    std::construct_at(&reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj, nullptr);

                    auto obj_impl = winrt::make_self<PyWinrtPipsPagerAutomationPeer>(self.get(), param0);

                    auto obj = py::make_py_obj<PyWinrtPipsPagerAutomationPeer>(obj_impl, type, self.get());
                    if (!obj)
                    {
                        return nullptr;
                    }

                    reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj = std::move(obj);

                    return self.detach();
                }

                winrt::Microsoft::UI::Xaml::Automation::Peers::PipsPagerAutomationPeer instance{param0};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_PipsPagerAutomationPeer(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_PipsPagerAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Automation::Peers::PipsPagerAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PipsPagerAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Automation::Peers::PipsPagerAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PipsPagerAutomationPeer[] = {
        { "_assign_array_", _assign_array_PipsPagerAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PipsPagerAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_PipsPagerAutomationPeer[] = {
        { }};

    static PyType_Slot _type_slots_PipsPagerAutomationPeer[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_PipsPagerAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PipsPagerAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PipsPagerAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PipsPagerAutomationPeer) },
        { }};

    static PyType_Spec type_spec_PipsPagerAutomationPeer = {
        "winui2._winui2_microsoft_ui_xaml_automation_peers.PipsPagerAutomationPeer",
        sizeof(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_PipsPagerAutomationPeer};

    static PyGetSetDef getset_PipsPagerAutomationPeer_Static[] = {
        { }};

    static PyMethodDef methods_PipsPagerAutomationPeer_Static[] = {
        { }};

    static PyType_Slot type_slots_PipsPagerAutomationPeer_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_PipsPagerAutomationPeer_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_PipsPagerAutomationPeer_Static) },
        { }
    };

    static PyType_Spec type_spec_PipsPagerAutomationPeer_Static = {
        "winui2._winui2_microsoft_ui_xaml_automation_peers.PipsPagerAutomationPeer_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_PipsPagerAutomationPeer_Static};

    // ----- ProgressBarAutomationPeer class --------------------

    struct PyWinrtProgressBarAutomationPeer;
    using BasePyWinrtProgressBarAutomationPeer = winrt::Microsoft::UI::Xaml::Automation::Peers::ProgressBarAutomationPeerT<PyWinrtProgressBarAutomationPeer, py::IPywinrtObject>;

    struct PyWinrtProgressBarAutomationPeer : py::py_obj_ref, BasePyWinrtProgressBarAutomationPeer
    {
        PyWinrtProgressBarAutomationPeer(PyObject* py_obj, winrt::Microsoft::UI::Xaml::Controls::ProgressBar owner) : py::py_obj_ref(py_obj), BasePyWinrtProgressBarAutomationPeer(owner) {}

        int32_t __stdcall GetPyObject(PyObject*& obj) override
        {
            obj = py::py_obj_ref::get_py_obj();
            return 0;
        }

        int32_t __stdcall GetComposableInner(winrt::Windows::Foundation::IInspectable& inner) override
        {
            inner = m_inner;
            return winrt::impl::error_ok;
        }

        static void toggle_reference(PyWinrtProgressBarAutomationPeer* instance, bool is_last_reference)
        {
            py::py_obj_ref::toggle_reference(instance, is_last_reference);
        }

        int32_t query_interface_tearoff(winrt::guid const& id, void** result) const noexcept override
        {
            return py::py_obj_ref::query_interface_tearoff(id, result);
        }

        std::vector<winrt::guid> get_iids_tearoff() const noexcept override
        {
            return py::py_obj_ref::get_iids_tearoff();
        }
    };

    static PyObject* _new_ProgressBarAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_GET_SIZE(args);

        auto self_type = get_python_type_for<winrt::Microsoft::UI::Xaml::Automation::Peers::ProgressBarAutomationPeer>();
        if (!self_type)
        {
            return nullptr;
        }

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::ProgressBar>(args, 0);

                if (type != self_type)
                {
                    py::pyobj_handle self{type->tp_alloc(type, 0)};
                    if (!self)
                    {
                        return nullptr;
                    }

                    std::construct_at(&reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj, nullptr);

                    auto obj_impl = winrt::make_self<PyWinrtProgressBarAutomationPeer>(self.get(), param0);

                    auto obj = py::make_py_obj<PyWinrtProgressBarAutomationPeer>(obj_impl, type, self.get());
                    if (!obj)
                    {
                        return nullptr;
                    }

                    reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj = std::move(obj);

                    return self.detach();
                }

                winrt::Microsoft::UI::Xaml::Automation::Peers::ProgressBarAutomationPeer instance{param0};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ProgressBarAutomationPeer(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_ProgressBarAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Automation::Peers::ProgressBarAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ProgressBarAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Automation::Peers::ProgressBarAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ProgressBarAutomationPeer[] = {
        { "_assign_array_", _assign_array_ProgressBarAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ProgressBarAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_ProgressBarAutomationPeer[] = {
        { }};

    static PyType_Slot _type_slots_ProgressBarAutomationPeer[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ProgressBarAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ProgressBarAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ProgressBarAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ProgressBarAutomationPeer) },
        { }};

    static PyType_Spec type_spec_ProgressBarAutomationPeer = {
        "winui2._winui2_microsoft_ui_xaml_automation_peers.ProgressBarAutomationPeer",
        sizeof(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_ProgressBarAutomationPeer};

    static PyGetSetDef getset_ProgressBarAutomationPeer_Static[] = {
        { }};

    static PyMethodDef methods_ProgressBarAutomationPeer_Static[] = {
        { }};

    static PyType_Slot type_slots_ProgressBarAutomationPeer_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_ProgressBarAutomationPeer_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_ProgressBarAutomationPeer_Static) },
        { }
    };

    static PyType_Spec type_spec_ProgressBarAutomationPeer_Static = {
        "winui2._winui2_microsoft_ui_xaml_automation_peers.ProgressBarAutomationPeer_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_ProgressBarAutomationPeer_Static};

    // ----- ProgressRingAutomationPeer class --------------------

    struct PyWinrtProgressRingAutomationPeer;
    using BasePyWinrtProgressRingAutomationPeer = winrt::Microsoft::UI::Xaml::Automation::Peers::ProgressRingAutomationPeerT<PyWinrtProgressRingAutomationPeer, py::IPywinrtObject>;

    struct PyWinrtProgressRingAutomationPeer : py::py_obj_ref, BasePyWinrtProgressRingAutomationPeer
    {
        PyWinrtProgressRingAutomationPeer(PyObject* py_obj, winrt::Microsoft::UI::Xaml::Controls::ProgressRing owner) : py::py_obj_ref(py_obj), BasePyWinrtProgressRingAutomationPeer(owner) {}

        int32_t __stdcall GetPyObject(PyObject*& obj) override
        {
            obj = py::py_obj_ref::get_py_obj();
            return 0;
        }

        int32_t __stdcall GetComposableInner(winrt::Windows::Foundation::IInspectable& inner) override
        {
            inner = m_inner;
            return winrt::impl::error_ok;
        }

        static void toggle_reference(PyWinrtProgressRingAutomationPeer* instance, bool is_last_reference)
        {
            py::py_obj_ref::toggle_reference(instance, is_last_reference);
        }

        int32_t query_interface_tearoff(winrt::guid const& id, void** result) const noexcept override
        {
            return py::py_obj_ref::query_interface_tearoff(id, result);
        }

        std::vector<winrt::guid> get_iids_tearoff() const noexcept override
        {
            return py::py_obj_ref::get_iids_tearoff();
        }
    };

    static PyObject* _new_ProgressRingAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_GET_SIZE(args);

        auto self_type = get_python_type_for<winrt::Microsoft::UI::Xaml::Automation::Peers::ProgressRingAutomationPeer>();
        if (!self_type)
        {
            return nullptr;
        }

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::ProgressRing>(args, 0);

                if (type != self_type)
                {
                    py::pyobj_handle self{type->tp_alloc(type, 0)};
                    if (!self)
                    {
                        return nullptr;
                    }

                    std::construct_at(&reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj, nullptr);

                    auto obj_impl = winrt::make_self<PyWinrtProgressRingAutomationPeer>(self.get(), param0);

                    auto obj = py::make_py_obj<PyWinrtProgressRingAutomationPeer>(obj_impl, type, self.get());
                    if (!obj)
                    {
                        return nullptr;
                    }

                    reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj = std::move(obj);

                    return self.detach();
                }

                winrt::Microsoft::UI::Xaml::Automation::Peers::ProgressRingAutomationPeer instance{param0};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ProgressRingAutomationPeer(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ProgressRingAutomationPeer_SetValue(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.Peers.ProgressRingAutomationPeer", L"SetValue", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<double>(args, 0);

                {
                    auto _gil = release_gil();
                    self->obj.try_as<winrt::Microsoft::UI::Xaml::Automation::Peers::ProgressRingAutomationPeer>().SetValue(param0);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ProgressRingAutomationPeer_get_IsReadOnly(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.Peers.ProgressRingAutomationPeer", L"IsReadOnly");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Automation::Peers::ProgressRingAutomationPeer>().IsReadOnly();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ProgressRingAutomationPeer_get_LargeChange(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.Peers.ProgressRingAutomationPeer", L"LargeChange");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Automation::Peers::ProgressRingAutomationPeer>().LargeChange();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ProgressRingAutomationPeer_get_Maximum(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.Peers.ProgressRingAutomationPeer", L"Maximum");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Automation::Peers::ProgressRingAutomationPeer>().Maximum();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ProgressRingAutomationPeer_get_Minimum(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.Peers.ProgressRingAutomationPeer", L"Minimum");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Automation::Peers::ProgressRingAutomationPeer>().Minimum();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ProgressRingAutomationPeer_get_SmallChange(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.Peers.ProgressRingAutomationPeer", L"SmallChange");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Automation::Peers::ProgressRingAutomationPeer>().SmallChange();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ProgressRingAutomationPeer_get_Value(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.Peers.ProgressRingAutomationPeer", L"Value");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Automation::Peers::ProgressRingAutomationPeer>().Value();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ProgressRingAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Automation::Peers::ProgressRingAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ProgressRingAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Automation::Peers::ProgressRingAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ProgressRingAutomationPeer[] = {
        { "set_value", reinterpret_cast<PyCFunction>(ProgressRingAutomationPeer_SetValue), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_ProgressRingAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ProgressRingAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_ProgressRingAutomationPeer[] = {
        { "is_read_only", reinterpret_cast<getter>(ProgressRingAutomationPeer_get_IsReadOnly), nullptr, nullptr, nullptr },
        { "large_change", reinterpret_cast<getter>(ProgressRingAutomationPeer_get_LargeChange), nullptr, nullptr, nullptr },
        { "maximum", reinterpret_cast<getter>(ProgressRingAutomationPeer_get_Maximum), nullptr, nullptr, nullptr },
        { "minimum", reinterpret_cast<getter>(ProgressRingAutomationPeer_get_Minimum), nullptr, nullptr, nullptr },
        { "small_change", reinterpret_cast<getter>(ProgressRingAutomationPeer_get_SmallChange), nullptr, nullptr, nullptr },
        { "value", reinterpret_cast<getter>(ProgressRingAutomationPeer_get_Value), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_ProgressRingAutomationPeer[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ProgressRingAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ProgressRingAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ProgressRingAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ProgressRingAutomationPeer) },
        { }};

    static PyType_Spec type_spec_ProgressRingAutomationPeer = {
        "winui2._winui2_microsoft_ui_xaml_automation_peers.ProgressRingAutomationPeer",
        sizeof(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_ProgressRingAutomationPeer};

    static PyGetSetDef getset_ProgressRingAutomationPeer_Static[] = {
        { }};

    static PyMethodDef methods_ProgressRingAutomationPeer_Static[] = {
        { }};

    static PyType_Slot type_slots_ProgressRingAutomationPeer_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_ProgressRingAutomationPeer_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_ProgressRingAutomationPeer_Static) },
        { }
    };

    static PyType_Spec type_spec_ProgressRingAutomationPeer_Static = {
        "winui2._winui2_microsoft_ui_xaml_automation_peers.ProgressRingAutomationPeer_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_ProgressRingAutomationPeer_Static};

    // ----- RadioButtonsAutomationPeer class --------------------

    struct PyWinrtRadioButtonsAutomationPeer;
    using BasePyWinrtRadioButtonsAutomationPeer = winrt::Microsoft::UI::Xaml::Automation::Peers::RadioButtonsAutomationPeerT<PyWinrtRadioButtonsAutomationPeer, py::IPywinrtObject>;

    struct PyWinrtRadioButtonsAutomationPeer : py::py_obj_ref, BasePyWinrtRadioButtonsAutomationPeer
    {
        PyWinrtRadioButtonsAutomationPeer(PyObject* py_obj, winrt::Microsoft::UI::Xaml::Controls::RadioButtons owner) : py::py_obj_ref(py_obj), BasePyWinrtRadioButtonsAutomationPeer(owner) {}

        int32_t __stdcall GetPyObject(PyObject*& obj) override
        {
            obj = py::py_obj_ref::get_py_obj();
            return 0;
        }

        int32_t __stdcall GetComposableInner(winrt::Windows::Foundation::IInspectable& inner) override
        {
            inner = m_inner;
            return winrt::impl::error_ok;
        }

        static void toggle_reference(PyWinrtRadioButtonsAutomationPeer* instance, bool is_last_reference)
        {
            py::py_obj_ref::toggle_reference(instance, is_last_reference);
        }

        int32_t query_interface_tearoff(winrt::guid const& id, void** result) const noexcept override
        {
            return py::py_obj_ref::query_interface_tearoff(id, result);
        }

        std::vector<winrt::guid> get_iids_tearoff() const noexcept override
        {
            return py::py_obj_ref::get_iids_tearoff();
        }
    };

    static PyObject* _new_RadioButtonsAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_GET_SIZE(args);

        auto self_type = get_python_type_for<winrt::Microsoft::UI::Xaml::Automation::Peers::RadioButtonsAutomationPeer>();
        if (!self_type)
        {
            return nullptr;
        }

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::RadioButtons>(args, 0);

                if (type != self_type)
                {
                    py::pyobj_handle self{type->tp_alloc(type, 0)};
                    if (!self)
                    {
                        return nullptr;
                    }

                    std::construct_at(&reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj, nullptr);

                    auto obj_impl = winrt::make_self<PyWinrtRadioButtonsAutomationPeer>(self.get(), param0);

                    auto obj = py::make_py_obj<PyWinrtRadioButtonsAutomationPeer>(obj_impl, type, self.get());
                    if (!obj)
                    {
                        return nullptr;
                    }

                    reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj = std::move(obj);

                    return self.detach();
                }

                winrt::Microsoft::UI::Xaml::Automation::Peers::RadioButtonsAutomationPeer instance{param0};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_RadioButtonsAutomationPeer(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_RadioButtonsAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Automation::Peers::RadioButtonsAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_RadioButtonsAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Automation::Peers::RadioButtonsAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_RadioButtonsAutomationPeer[] = {
        { "_assign_array_", _assign_array_RadioButtonsAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_RadioButtonsAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_RadioButtonsAutomationPeer[] = {
        { }};

    static PyType_Slot _type_slots_RadioButtonsAutomationPeer[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_RadioButtonsAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_RadioButtonsAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_RadioButtonsAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_RadioButtonsAutomationPeer) },
        { }};

    static PyType_Spec type_spec_RadioButtonsAutomationPeer = {
        "winui2._winui2_microsoft_ui_xaml_automation_peers.RadioButtonsAutomationPeer",
        sizeof(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_RadioButtonsAutomationPeer};

    static PyGetSetDef getset_RadioButtonsAutomationPeer_Static[] = {
        { }};

    static PyMethodDef methods_RadioButtonsAutomationPeer_Static[] = {
        { }};

    static PyType_Slot type_slots_RadioButtonsAutomationPeer_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_RadioButtonsAutomationPeer_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_RadioButtonsAutomationPeer_Static) },
        { }
    };

    static PyType_Spec type_spec_RadioButtonsAutomationPeer_Static = {
        "winui2._winui2_microsoft_ui_xaml_automation_peers.RadioButtonsAutomationPeer_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_RadioButtonsAutomationPeer_Static};

    // ----- RatingControlAutomationPeer class --------------------

    struct PyWinrtRatingControlAutomationPeer;
    using BasePyWinrtRatingControlAutomationPeer = winrt::Microsoft::UI::Xaml::Automation::Peers::RatingControlAutomationPeerT<PyWinrtRatingControlAutomationPeer, py::IPywinrtObject>;

    struct PyWinrtRatingControlAutomationPeer : py::py_obj_ref, BasePyWinrtRatingControlAutomationPeer
    {
        PyWinrtRatingControlAutomationPeer(PyObject* py_obj, winrt::Microsoft::UI::Xaml::Controls::RatingControl owner) : py::py_obj_ref(py_obj), BasePyWinrtRatingControlAutomationPeer(owner) {}

        int32_t __stdcall GetPyObject(PyObject*& obj) override
        {
            obj = py::py_obj_ref::get_py_obj();
            return 0;
        }

        int32_t __stdcall GetComposableInner(winrt::Windows::Foundation::IInspectable& inner) override
        {
            inner = m_inner;
            return winrt::impl::error_ok;
        }

        static void toggle_reference(PyWinrtRatingControlAutomationPeer* instance, bool is_last_reference)
        {
            py::py_obj_ref::toggle_reference(instance, is_last_reference);
        }

        int32_t query_interface_tearoff(winrt::guid const& id, void** result) const noexcept override
        {
            return py::py_obj_ref::query_interface_tearoff(id, result);
        }

        std::vector<winrt::guid> get_iids_tearoff() const noexcept override
        {
            return py::py_obj_ref::get_iids_tearoff();
        }
    };

    static PyObject* _new_RatingControlAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_GET_SIZE(args);

        auto self_type = get_python_type_for<winrt::Microsoft::UI::Xaml::Automation::Peers::RatingControlAutomationPeer>();
        if (!self_type)
        {
            return nullptr;
        }

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::RatingControl>(args, 0);

                if (type != self_type)
                {
                    py::pyobj_handle self{type->tp_alloc(type, 0)};
                    if (!self)
                    {
                        return nullptr;
                    }

                    std::construct_at(&reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj, nullptr);

                    auto obj_impl = winrt::make_self<PyWinrtRatingControlAutomationPeer>(self.get(), param0);

                    auto obj = py::make_py_obj<PyWinrtRatingControlAutomationPeer>(obj_impl, type, self.get());
                    if (!obj)
                    {
                        return nullptr;
                    }

                    reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj = std::move(obj);

                    return self.detach();
                }

                winrt::Microsoft::UI::Xaml::Automation::Peers::RatingControlAutomationPeer instance{param0};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_RatingControlAutomationPeer(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_RatingControlAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Automation::Peers::RatingControlAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_RatingControlAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Automation::Peers::RatingControlAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_RatingControlAutomationPeer[] = {
        { "_assign_array_", _assign_array_RatingControlAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_RatingControlAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_RatingControlAutomationPeer[] = {
        { }};

    static PyType_Slot _type_slots_RatingControlAutomationPeer[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_RatingControlAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_RatingControlAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_RatingControlAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_RatingControlAutomationPeer) },
        { }};

    static PyType_Spec type_spec_RatingControlAutomationPeer = {
        "winui2._winui2_microsoft_ui_xaml_automation_peers.RatingControlAutomationPeer",
        sizeof(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_RatingControlAutomationPeer};

    static PyGetSetDef getset_RatingControlAutomationPeer_Static[] = {
        { }};

    static PyMethodDef methods_RatingControlAutomationPeer_Static[] = {
        { }};

    static PyType_Slot type_slots_RatingControlAutomationPeer_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_RatingControlAutomationPeer_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_RatingControlAutomationPeer_Static) },
        { }
    };

    static PyType_Spec type_spec_RatingControlAutomationPeer_Static = {
        "winui2._winui2_microsoft_ui_xaml_automation_peers.RatingControlAutomationPeer_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_RatingControlAutomationPeer_Static};

    // ----- RepeaterAutomationPeer class --------------------

    struct PyWinrtRepeaterAutomationPeer;
    using BasePyWinrtRepeaterAutomationPeer = winrt::Microsoft::UI::Xaml::Automation::Peers::RepeaterAutomationPeerT<PyWinrtRepeaterAutomationPeer, py::IPywinrtObject>;

    struct PyWinrtRepeaterAutomationPeer : py::py_obj_ref, BasePyWinrtRepeaterAutomationPeer
    {
        PyWinrtRepeaterAutomationPeer(PyObject* py_obj, winrt::Microsoft::UI::Xaml::Controls::ItemsRepeater owner) : py::py_obj_ref(py_obj), BasePyWinrtRepeaterAutomationPeer(owner) {}

        int32_t __stdcall GetPyObject(PyObject*& obj) override
        {
            obj = py::py_obj_ref::get_py_obj();
            return 0;
        }

        int32_t __stdcall GetComposableInner(winrt::Windows::Foundation::IInspectable& inner) override
        {
            inner = m_inner;
            return winrt::impl::error_ok;
        }

        static void toggle_reference(PyWinrtRepeaterAutomationPeer* instance, bool is_last_reference)
        {
            py::py_obj_ref::toggle_reference(instance, is_last_reference);
        }

        int32_t query_interface_tearoff(winrt::guid const& id, void** result) const noexcept override
        {
            return py::py_obj_ref::query_interface_tearoff(id, result);
        }

        std::vector<winrt::guid> get_iids_tearoff() const noexcept override
        {
            return py::py_obj_ref::get_iids_tearoff();
        }
    };

    static PyObject* _new_RepeaterAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_GET_SIZE(args);

        auto self_type = get_python_type_for<winrt::Microsoft::UI::Xaml::Automation::Peers::RepeaterAutomationPeer>();
        if (!self_type)
        {
            return nullptr;
        }

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::ItemsRepeater>(args, 0);

                if (type != self_type)
                {
                    py::pyobj_handle self{type->tp_alloc(type, 0)};
                    if (!self)
                    {
                        return nullptr;
                    }

                    std::construct_at(&reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj, nullptr);

                    auto obj_impl = winrt::make_self<PyWinrtRepeaterAutomationPeer>(self.get(), param0);

                    auto obj = py::make_py_obj<PyWinrtRepeaterAutomationPeer>(obj_impl, type, self.get());
                    if (!obj)
                    {
                        return nullptr;
                    }

                    reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj = std::move(obj);

                    return self.detach();
                }

                winrt::Microsoft::UI::Xaml::Automation::Peers::RepeaterAutomationPeer instance{param0};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_RepeaterAutomationPeer(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_RepeaterAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Automation::Peers::RepeaterAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_RepeaterAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Automation::Peers::RepeaterAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_RepeaterAutomationPeer[] = {
        { "_assign_array_", _assign_array_RepeaterAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_RepeaterAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_RepeaterAutomationPeer[] = {
        { }};

    static PyType_Slot _type_slots_RepeaterAutomationPeer[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_RepeaterAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_RepeaterAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_RepeaterAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_RepeaterAutomationPeer) },
        { }};

    static PyType_Spec type_spec_RepeaterAutomationPeer = {
        "winui2._winui2_microsoft_ui_xaml_automation_peers.RepeaterAutomationPeer",
        sizeof(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_RepeaterAutomationPeer};

    static PyGetSetDef getset_RepeaterAutomationPeer_Static[] = {
        { }};

    static PyMethodDef methods_RepeaterAutomationPeer_Static[] = {
        { }};

    static PyType_Slot type_slots_RepeaterAutomationPeer_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_RepeaterAutomationPeer_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_RepeaterAutomationPeer_Static) },
        { }
    };

    static PyType_Spec type_spec_RepeaterAutomationPeer_Static = {
        "winui2._winui2_microsoft_ui_xaml_automation_peers.RepeaterAutomationPeer_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_RepeaterAutomationPeer_Static};

    // ----- SplitButtonAutomationPeer class --------------------

    struct PyWinrtSplitButtonAutomationPeer;
    using BasePyWinrtSplitButtonAutomationPeer = winrt::Microsoft::UI::Xaml::Automation::Peers::SplitButtonAutomationPeerT<PyWinrtSplitButtonAutomationPeer, py::IPywinrtObject>;

    struct PyWinrtSplitButtonAutomationPeer : py::py_obj_ref, BasePyWinrtSplitButtonAutomationPeer
    {
        PyWinrtSplitButtonAutomationPeer(PyObject* py_obj, winrt::Microsoft::UI::Xaml::Controls::SplitButton owner) : py::py_obj_ref(py_obj), BasePyWinrtSplitButtonAutomationPeer(owner) {}

        int32_t __stdcall GetPyObject(PyObject*& obj) override
        {
            obj = py::py_obj_ref::get_py_obj();
            return 0;
        }

        int32_t __stdcall GetComposableInner(winrt::Windows::Foundation::IInspectable& inner) override
        {
            inner = m_inner;
            return winrt::impl::error_ok;
        }

        static void toggle_reference(PyWinrtSplitButtonAutomationPeer* instance, bool is_last_reference)
        {
            py::py_obj_ref::toggle_reference(instance, is_last_reference);
        }

        int32_t query_interface_tearoff(winrt::guid const& id, void** result) const noexcept override
        {
            return py::py_obj_ref::query_interface_tearoff(id, result);
        }

        std::vector<winrt::guid> get_iids_tearoff() const noexcept override
        {
            return py::py_obj_ref::get_iids_tearoff();
        }
    };

    static PyObject* _new_SplitButtonAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_GET_SIZE(args);

        auto self_type = get_python_type_for<winrt::Microsoft::UI::Xaml::Automation::Peers::SplitButtonAutomationPeer>();
        if (!self_type)
        {
            return nullptr;
        }

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::SplitButton>(args, 0);

                if (type != self_type)
                {
                    py::pyobj_handle self{type->tp_alloc(type, 0)};
                    if (!self)
                    {
                        return nullptr;
                    }

                    std::construct_at(&reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj, nullptr);

                    auto obj_impl = winrt::make_self<PyWinrtSplitButtonAutomationPeer>(self.get(), param0);

                    auto obj = py::make_py_obj<PyWinrtSplitButtonAutomationPeer>(obj_impl, type, self.get());
                    if (!obj)
                    {
                        return nullptr;
                    }

                    reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj = std::move(obj);

                    return self.detach();
                }

                winrt::Microsoft::UI::Xaml::Automation::Peers::SplitButtonAutomationPeer instance{param0};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_SplitButtonAutomationPeer(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SplitButtonAutomationPeer_Collapse(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.Peers.SplitButtonAutomationPeer", L"Collapse", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.try_as<winrt::Microsoft::UI::Xaml::Automation::Peers::SplitButtonAutomationPeer>().Collapse();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SplitButtonAutomationPeer_Expand(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.Peers.SplitButtonAutomationPeer", L"Expand", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.try_as<winrt::Microsoft::UI::Xaml::Automation::Peers::SplitButtonAutomationPeer>().Expand();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SplitButtonAutomationPeer_Invoke(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.Peers.SplitButtonAutomationPeer", L"Invoke", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.try_as<winrt::Microsoft::UI::Xaml::Automation::Peers::SplitButtonAutomationPeer>().Invoke();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SplitButtonAutomationPeer_get_ExpandCollapseState(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.Peers.SplitButtonAutomationPeer", L"ExpandCollapseState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Automation::Peers::SplitButtonAutomationPeer>().ExpandCollapseState();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SplitButtonAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Automation::Peers::SplitButtonAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SplitButtonAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Automation::Peers::SplitButtonAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SplitButtonAutomationPeer[] = {
        { "collapse", reinterpret_cast<PyCFunction>(SplitButtonAutomationPeer_Collapse), METH_VARARGS, nullptr },
        { "expand", reinterpret_cast<PyCFunction>(SplitButtonAutomationPeer_Expand), METH_VARARGS, nullptr },
        { "invoke", reinterpret_cast<PyCFunction>(SplitButtonAutomationPeer_Invoke), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_SplitButtonAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SplitButtonAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_SplitButtonAutomationPeer[] = {
        { "expand_collapse_state", reinterpret_cast<getter>(SplitButtonAutomationPeer_get_ExpandCollapseState), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_SplitButtonAutomationPeer[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_SplitButtonAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SplitButtonAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SplitButtonAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SplitButtonAutomationPeer) },
        { }};

    static PyType_Spec type_spec_SplitButtonAutomationPeer = {
        "winui2._winui2_microsoft_ui_xaml_automation_peers.SplitButtonAutomationPeer",
        sizeof(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_SplitButtonAutomationPeer};

    static PyGetSetDef getset_SplitButtonAutomationPeer_Static[] = {
        { }};

    static PyMethodDef methods_SplitButtonAutomationPeer_Static[] = {
        { }};

    static PyType_Slot type_slots_SplitButtonAutomationPeer_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_SplitButtonAutomationPeer_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_SplitButtonAutomationPeer_Static) },
        { }
    };

    static PyType_Spec type_spec_SplitButtonAutomationPeer_Static = {
        "winui2._winui2_microsoft_ui_xaml_automation_peers.SplitButtonAutomationPeer_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_SplitButtonAutomationPeer_Static};

    // ----- TabViewAutomationPeer class --------------------

    struct PyWinrtTabViewAutomationPeer;
    using BasePyWinrtTabViewAutomationPeer = winrt::Microsoft::UI::Xaml::Automation::Peers::TabViewAutomationPeerT<PyWinrtTabViewAutomationPeer, py::IPywinrtObject>;

    struct PyWinrtTabViewAutomationPeer : py::py_obj_ref, BasePyWinrtTabViewAutomationPeer
    {
        PyWinrtTabViewAutomationPeer(PyObject* py_obj, winrt::Microsoft::UI::Xaml::Controls::TabView owner) : py::py_obj_ref(py_obj), BasePyWinrtTabViewAutomationPeer(owner) {}

        int32_t __stdcall GetPyObject(PyObject*& obj) override
        {
            obj = py::py_obj_ref::get_py_obj();
            return 0;
        }

        int32_t __stdcall GetComposableInner(winrt::Windows::Foundation::IInspectable& inner) override
        {
            inner = m_inner;
            return winrt::impl::error_ok;
        }

        static void toggle_reference(PyWinrtTabViewAutomationPeer* instance, bool is_last_reference)
        {
            py::py_obj_ref::toggle_reference(instance, is_last_reference);
        }

        int32_t query_interface_tearoff(winrt::guid const& id, void** result) const noexcept override
        {
            return py::py_obj_ref::query_interface_tearoff(id, result);
        }

        std::vector<winrt::guid> get_iids_tearoff() const noexcept override
        {
            return py::py_obj_ref::get_iids_tearoff();
        }
    };

    static PyObject* _new_TabViewAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_GET_SIZE(args);

        auto self_type = get_python_type_for<winrt::Microsoft::UI::Xaml::Automation::Peers::TabViewAutomationPeer>();
        if (!self_type)
        {
            return nullptr;
        }

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::TabView>(args, 0);

                if (type != self_type)
                {
                    py::pyobj_handle self{type->tp_alloc(type, 0)};
                    if (!self)
                    {
                        return nullptr;
                    }

                    std::construct_at(&reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj, nullptr);

                    auto obj_impl = winrt::make_self<PyWinrtTabViewAutomationPeer>(self.get(), param0);

                    auto obj = py::make_py_obj<PyWinrtTabViewAutomationPeer>(obj_impl, type, self.get());
                    if (!obj)
                    {
                        return nullptr;
                    }

                    reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj = std::move(obj);

                    return self.detach();
                }

                winrt::Microsoft::UI::Xaml::Automation::Peers::TabViewAutomationPeer instance{param0};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_TabViewAutomationPeer(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_TabViewAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Automation::Peers::TabViewAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_TabViewAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Automation::Peers::TabViewAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_TabViewAutomationPeer[] = {
        { "_assign_array_", _assign_array_TabViewAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_TabViewAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_TabViewAutomationPeer[] = {
        { }};

    static PyType_Slot _type_slots_TabViewAutomationPeer[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_TabViewAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_TabViewAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_TabViewAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_TabViewAutomationPeer) },
        { }};

    static PyType_Spec type_spec_TabViewAutomationPeer = {
        "winui2._winui2_microsoft_ui_xaml_automation_peers.TabViewAutomationPeer",
        sizeof(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_TabViewAutomationPeer};

    static PyGetSetDef getset_TabViewAutomationPeer_Static[] = {
        { }};

    static PyMethodDef methods_TabViewAutomationPeer_Static[] = {
        { }};

    static PyType_Slot type_slots_TabViewAutomationPeer_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_TabViewAutomationPeer_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_TabViewAutomationPeer_Static) },
        { }
    };

    static PyType_Spec type_spec_TabViewAutomationPeer_Static = {
        "winui2._winui2_microsoft_ui_xaml_automation_peers.TabViewAutomationPeer_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_TabViewAutomationPeer_Static};

    // ----- TabViewItemAutomationPeer class --------------------

    struct PyWinrtTabViewItemAutomationPeer;
    using BasePyWinrtTabViewItemAutomationPeer = winrt::Microsoft::UI::Xaml::Automation::Peers::TabViewItemAutomationPeerT<PyWinrtTabViewItemAutomationPeer, py::IPywinrtObject>;

    struct PyWinrtTabViewItemAutomationPeer : py::py_obj_ref, BasePyWinrtTabViewItemAutomationPeer
    {
        PyWinrtTabViewItemAutomationPeer(PyObject* py_obj, winrt::Microsoft::UI::Xaml::Controls::TabViewItem owner) : py::py_obj_ref(py_obj), BasePyWinrtTabViewItemAutomationPeer(owner) {}

        int32_t __stdcall GetPyObject(PyObject*& obj) override
        {
            obj = py::py_obj_ref::get_py_obj();
            return 0;
        }

        int32_t __stdcall GetComposableInner(winrt::Windows::Foundation::IInspectable& inner) override
        {
            inner = m_inner;
            return winrt::impl::error_ok;
        }

        static void toggle_reference(PyWinrtTabViewItemAutomationPeer* instance, bool is_last_reference)
        {
            py::py_obj_ref::toggle_reference(instance, is_last_reference);
        }

        int32_t query_interface_tearoff(winrt::guid const& id, void** result) const noexcept override
        {
            return py::py_obj_ref::query_interface_tearoff(id, result);
        }

        std::vector<winrt::guid> get_iids_tearoff() const noexcept override
        {
            return py::py_obj_ref::get_iids_tearoff();
        }
    };

    static PyObject* _new_TabViewItemAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_GET_SIZE(args);

        auto self_type = get_python_type_for<winrt::Microsoft::UI::Xaml::Automation::Peers::TabViewItemAutomationPeer>();
        if (!self_type)
        {
            return nullptr;
        }

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::TabViewItem>(args, 0);

                if (type != self_type)
                {
                    py::pyobj_handle self{type->tp_alloc(type, 0)};
                    if (!self)
                    {
                        return nullptr;
                    }

                    std::construct_at(&reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj, nullptr);

                    auto obj_impl = winrt::make_self<PyWinrtTabViewItemAutomationPeer>(self.get(), param0);

                    auto obj = py::make_py_obj<PyWinrtTabViewItemAutomationPeer>(obj_impl, type, self.get());
                    if (!obj)
                    {
                        return nullptr;
                    }

                    reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj = std::move(obj);

                    return self.detach();
                }

                winrt::Microsoft::UI::Xaml::Automation::Peers::TabViewItemAutomationPeer instance{param0};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_TabViewItemAutomationPeer(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_TabViewItemAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Automation::Peers::TabViewItemAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_TabViewItemAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Automation::Peers::TabViewItemAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_TabViewItemAutomationPeer[] = {
        { "_assign_array_", _assign_array_TabViewItemAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_TabViewItemAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_TabViewItemAutomationPeer[] = {
        { }};

    static PyType_Slot _type_slots_TabViewItemAutomationPeer[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_TabViewItemAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_TabViewItemAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_TabViewItemAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_TabViewItemAutomationPeer) },
        { }};

    static PyType_Spec type_spec_TabViewItemAutomationPeer = {
        "winui2._winui2_microsoft_ui_xaml_automation_peers.TabViewItemAutomationPeer",
        sizeof(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_TabViewItemAutomationPeer};

    static PyGetSetDef getset_TabViewItemAutomationPeer_Static[] = {
        { }};

    static PyMethodDef methods_TabViewItemAutomationPeer_Static[] = {
        { }};

    static PyType_Slot type_slots_TabViewItemAutomationPeer_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_TabViewItemAutomationPeer_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_TabViewItemAutomationPeer_Static) },
        { }
    };

    static PyType_Spec type_spec_TabViewItemAutomationPeer_Static = {
        "winui2._winui2_microsoft_ui_xaml_automation_peers.TabViewItemAutomationPeer_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_TabViewItemAutomationPeer_Static};

    // ----- TeachingTipAutomationPeer class --------------------

    struct PyWinrtTeachingTipAutomationPeer;
    using BasePyWinrtTeachingTipAutomationPeer = winrt::Microsoft::UI::Xaml::Automation::Peers::TeachingTipAutomationPeerT<PyWinrtTeachingTipAutomationPeer, py::IPywinrtObject>;

    struct PyWinrtTeachingTipAutomationPeer : py::py_obj_ref, BasePyWinrtTeachingTipAutomationPeer
    {
        PyWinrtTeachingTipAutomationPeer(PyObject* py_obj, winrt::Microsoft::UI::Xaml::Controls::TeachingTip owner) : py::py_obj_ref(py_obj), BasePyWinrtTeachingTipAutomationPeer(owner) {}

        int32_t __stdcall GetPyObject(PyObject*& obj) override
        {
            obj = py::py_obj_ref::get_py_obj();
            return 0;
        }

        int32_t __stdcall GetComposableInner(winrt::Windows::Foundation::IInspectable& inner) override
        {
            inner = m_inner;
            return winrt::impl::error_ok;
        }

        static void toggle_reference(PyWinrtTeachingTipAutomationPeer* instance, bool is_last_reference)
        {
            py::py_obj_ref::toggle_reference(instance, is_last_reference);
        }

        int32_t query_interface_tearoff(winrt::guid const& id, void** result) const noexcept override
        {
            return py::py_obj_ref::query_interface_tearoff(id, result);
        }

        std::vector<winrt::guid> get_iids_tearoff() const noexcept override
        {
            return py::py_obj_ref::get_iids_tearoff();
        }
    };

    static PyObject* _new_TeachingTipAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_GET_SIZE(args);

        auto self_type = get_python_type_for<winrt::Microsoft::UI::Xaml::Automation::Peers::TeachingTipAutomationPeer>();
        if (!self_type)
        {
            return nullptr;
        }

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::TeachingTip>(args, 0);

                if (type != self_type)
                {
                    py::pyobj_handle self{type->tp_alloc(type, 0)};
                    if (!self)
                    {
                        return nullptr;
                    }

                    std::construct_at(&reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj, nullptr);

                    auto obj_impl = winrt::make_self<PyWinrtTeachingTipAutomationPeer>(self.get(), param0);

                    auto obj = py::make_py_obj<PyWinrtTeachingTipAutomationPeer>(obj_impl, type, self.get());
                    if (!obj)
                    {
                        return nullptr;
                    }

                    reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj = std::move(obj);

                    return self.detach();
                }

                winrt::Microsoft::UI::Xaml::Automation::Peers::TeachingTipAutomationPeer instance{param0};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_TeachingTipAutomationPeer(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_TeachingTipAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Automation::Peers::TeachingTipAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_TeachingTipAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Automation::Peers::TeachingTipAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_TeachingTipAutomationPeer[] = {
        { "_assign_array_", _assign_array_TeachingTipAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_TeachingTipAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_TeachingTipAutomationPeer[] = {
        { }};

    static PyType_Slot _type_slots_TeachingTipAutomationPeer[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_TeachingTipAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_TeachingTipAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_TeachingTipAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_TeachingTipAutomationPeer) },
        { }};

    static PyType_Spec type_spec_TeachingTipAutomationPeer = {
        "winui2._winui2_microsoft_ui_xaml_automation_peers.TeachingTipAutomationPeer",
        sizeof(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_TeachingTipAutomationPeer};

    static PyGetSetDef getset_TeachingTipAutomationPeer_Static[] = {
        { }};

    static PyMethodDef methods_TeachingTipAutomationPeer_Static[] = {
        { }};

    static PyType_Slot type_slots_TeachingTipAutomationPeer_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_TeachingTipAutomationPeer_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_TeachingTipAutomationPeer_Static) },
        { }
    };

    static PyType_Spec type_spec_TeachingTipAutomationPeer_Static = {
        "winui2._winui2_microsoft_ui_xaml_automation_peers.TeachingTipAutomationPeer_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_TeachingTipAutomationPeer_Static};

    // ----- ToggleSplitButtonAutomationPeer class --------------------

    struct PyWinrtToggleSplitButtonAutomationPeer;
    using BasePyWinrtToggleSplitButtonAutomationPeer = winrt::Microsoft::UI::Xaml::Automation::Peers::ToggleSplitButtonAutomationPeerT<PyWinrtToggleSplitButtonAutomationPeer, py::IPywinrtObject>;

    struct PyWinrtToggleSplitButtonAutomationPeer : py::py_obj_ref, BasePyWinrtToggleSplitButtonAutomationPeer
    {
        PyWinrtToggleSplitButtonAutomationPeer(PyObject* py_obj, winrt::Microsoft::UI::Xaml::Controls::ToggleSplitButton owner) : py::py_obj_ref(py_obj), BasePyWinrtToggleSplitButtonAutomationPeer(owner) {}

        int32_t __stdcall GetPyObject(PyObject*& obj) override
        {
            obj = py::py_obj_ref::get_py_obj();
            return 0;
        }

        int32_t __stdcall GetComposableInner(winrt::Windows::Foundation::IInspectable& inner) override
        {
            inner = m_inner;
            return winrt::impl::error_ok;
        }

        static void toggle_reference(PyWinrtToggleSplitButtonAutomationPeer* instance, bool is_last_reference)
        {
            py::py_obj_ref::toggle_reference(instance, is_last_reference);
        }

        int32_t query_interface_tearoff(winrt::guid const& id, void** result) const noexcept override
        {
            return py::py_obj_ref::query_interface_tearoff(id, result);
        }

        std::vector<winrt::guid> get_iids_tearoff() const noexcept override
        {
            return py::py_obj_ref::get_iids_tearoff();
        }
    };

    static PyObject* _new_ToggleSplitButtonAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_GET_SIZE(args);

        auto self_type = get_python_type_for<winrt::Microsoft::UI::Xaml::Automation::Peers::ToggleSplitButtonAutomationPeer>();
        if (!self_type)
        {
            return nullptr;
        }

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::ToggleSplitButton>(args, 0);

                if (type != self_type)
                {
                    py::pyobj_handle self{type->tp_alloc(type, 0)};
                    if (!self)
                    {
                        return nullptr;
                    }

                    std::construct_at(&reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj, nullptr);

                    auto obj_impl = winrt::make_self<PyWinrtToggleSplitButtonAutomationPeer>(self.get(), param0);

                    auto obj = py::make_py_obj<PyWinrtToggleSplitButtonAutomationPeer>(obj_impl, type, self.get());
                    if (!obj)
                    {
                        return nullptr;
                    }

                    reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj = std::move(obj);

                    return self.detach();
                }

                winrt::Microsoft::UI::Xaml::Automation::Peers::ToggleSplitButtonAutomationPeer instance{param0};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ToggleSplitButtonAutomationPeer(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ToggleSplitButtonAutomationPeer_Collapse(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.Peers.ToggleSplitButtonAutomationPeer", L"Collapse", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.try_as<winrt::Microsoft::UI::Xaml::Automation::Peers::ToggleSplitButtonAutomationPeer>().Collapse();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ToggleSplitButtonAutomationPeer_Expand(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.Peers.ToggleSplitButtonAutomationPeer", L"Expand", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.try_as<winrt::Microsoft::UI::Xaml::Automation::Peers::ToggleSplitButtonAutomationPeer>().Expand();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ToggleSplitButtonAutomationPeer_Toggle(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.Peers.ToggleSplitButtonAutomationPeer", L"Toggle", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.try_as<winrt::Microsoft::UI::Xaml::Automation::Peers::ToggleSplitButtonAutomationPeer>().Toggle();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ToggleSplitButtonAutomationPeer_get_ExpandCollapseState(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.Peers.ToggleSplitButtonAutomationPeer", L"ExpandCollapseState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Automation::Peers::ToggleSplitButtonAutomationPeer>().ExpandCollapseState();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ToggleSplitButtonAutomationPeer_get_ToggleState(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.Peers.ToggleSplitButtonAutomationPeer", L"ToggleState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Automation::Peers::ToggleSplitButtonAutomationPeer>().ToggleState();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ToggleSplitButtonAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Automation::Peers::ToggleSplitButtonAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ToggleSplitButtonAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Automation::Peers::ToggleSplitButtonAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ToggleSplitButtonAutomationPeer[] = {
        { "collapse", reinterpret_cast<PyCFunction>(ToggleSplitButtonAutomationPeer_Collapse), METH_VARARGS, nullptr },
        { "expand", reinterpret_cast<PyCFunction>(ToggleSplitButtonAutomationPeer_Expand), METH_VARARGS, nullptr },
        { "toggle", reinterpret_cast<PyCFunction>(ToggleSplitButtonAutomationPeer_Toggle), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_ToggleSplitButtonAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ToggleSplitButtonAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_ToggleSplitButtonAutomationPeer[] = {
        { "expand_collapse_state", reinterpret_cast<getter>(ToggleSplitButtonAutomationPeer_get_ExpandCollapseState), nullptr, nullptr, nullptr },
        { "toggle_state", reinterpret_cast<getter>(ToggleSplitButtonAutomationPeer_get_ToggleState), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_ToggleSplitButtonAutomationPeer[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ToggleSplitButtonAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ToggleSplitButtonAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ToggleSplitButtonAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ToggleSplitButtonAutomationPeer) },
        { }};

    static PyType_Spec type_spec_ToggleSplitButtonAutomationPeer = {
        "winui2._winui2_microsoft_ui_xaml_automation_peers.ToggleSplitButtonAutomationPeer",
        sizeof(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_ToggleSplitButtonAutomationPeer};

    static PyGetSetDef getset_ToggleSplitButtonAutomationPeer_Static[] = {
        { }};

    static PyMethodDef methods_ToggleSplitButtonAutomationPeer_Static[] = {
        { }};

    static PyType_Slot type_slots_ToggleSplitButtonAutomationPeer_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_ToggleSplitButtonAutomationPeer_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_ToggleSplitButtonAutomationPeer_Static) },
        { }
    };

    static PyType_Spec type_spec_ToggleSplitButtonAutomationPeer_Static = {
        "winui2._winui2_microsoft_ui_xaml_automation_peers.ToggleSplitButtonAutomationPeer_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_ToggleSplitButtonAutomationPeer_Static};

    // ----- TreeViewItemAutomationPeer class --------------------

    struct PyWinrtTreeViewItemAutomationPeer;
    using BasePyWinrtTreeViewItemAutomationPeer = winrt::Microsoft::UI::Xaml::Automation::Peers::TreeViewItemAutomationPeerT<PyWinrtTreeViewItemAutomationPeer, py::IPywinrtObject>;

    struct PyWinrtTreeViewItemAutomationPeer : py::py_obj_ref, BasePyWinrtTreeViewItemAutomationPeer
    {
        PyWinrtTreeViewItemAutomationPeer(PyObject* py_obj, winrt::Microsoft::UI::Xaml::Controls::TreeViewItem owner) : py::py_obj_ref(py_obj), BasePyWinrtTreeViewItemAutomationPeer(owner) {}

        int32_t __stdcall GetPyObject(PyObject*& obj) override
        {
            obj = py::py_obj_ref::get_py_obj();
            return 0;
        }

        int32_t __stdcall GetComposableInner(winrt::Windows::Foundation::IInspectable& inner) override
        {
            inner = m_inner;
            return winrt::impl::error_ok;
        }

        static void toggle_reference(PyWinrtTreeViewItemAutomationPeer* instance, bool is_last_reference)
        {
            py::py_obj_ref::toggle_reference(instance, is_last_reference);
        }

        int32_t query_interface_tearoff(winrt::guid const& id, void** result) const noexcept override
        {
            return py::py_obj_ref::query_interface_tearoff(id, result);
        }

        std::vector<winrt::guid> get_iids_tearoff() const noexcept override
        {
            return py::py_obj_ref::get_iids_tearoff();
        }
    };

    static PyObject* _new_TreeViewItemAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_GET_SIZE(args);

        auto self_type = get_python_type_for<winrt::Microsoft::UI::Xaml::Automation::Peers::TreeViewItemAutomationPeer>();
        if (!self_type)
        {
            return nullptr;
        }

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::TreeViewItem>(args, 0);

                if (type != self_type)
                {
                    py::pyobj_handle self{type->tp_alloc(type, 0)};
                    if (!self)
                    {
                        return nullptr;
                    }

                    std::construct_at(&reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj, nullptr);

                    auto obj_impl = winrt::make_self<PyWinrtTreeViewItemAutomationPeer>(self.get(), param0);

                    auto obj = py::make_py_obj<PyWinrtTreeViewItemAutomationPeer>(obj_impl, type, self.get());
                    if (!obj)
                    {
                        return nullptr;
                    }

                    reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj = std::move(obj);

                    return self.detach();
                }

                winrt::Microsoft::UI::Xaml::Automation::Peers::TreeViewItemAutomationPeer instance{param0};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_TreeViewItemAutomationPeer(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* TreeViewItemAutomationPeer_Collapse(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.Peers.TreeViewItemAutomationPeer", L"Collapse", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.try_as<winrt::Microsoft::UI::Xaml::Automation::Peers::TreeViewItemAutomationPeer>().Collapse();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TreeViewItemAutomationPeer_Expand(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.Peers.TreeViewItemAutomationPeer", L"Expand", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.try_as<winrt::Microsoft::UI::Xaml::Automation::Peers::TreeViewItemAutomationPeer>().Expand();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TreeViewItemAutomationPeer_get_ExpandCollapseState(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.Peers.TreeViewItemAutomationPeer", L"ExpandCollapseState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Automation::Peers::TreeViewItemAutomationPeer>().ExpandCollapseState();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_TreeViewItemAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Automation::Peers::TreeViewItemAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_TreeViewItemAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Automation::Peers::TreeViewItemAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_TreeViewItemAutomationPeer[] = {
        { "collapse", reinterpret_cast<PyCFunction>(TreeViewItemAutomationPeer_Collapse), METH_VARARGS, nullptr },
        { "expand", reinterpret_cast<PyCFunction>(TreeViewItemAutomationPeer_Expand), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_TreeViewItemAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_TreeViewItemAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_TreeViewItemAutomationPeer[] = {
        { "expand_collapse_state", reinterpret_cast<getter>(TreeViewItemAutomationPeer_get_ExpandCollapseState), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_TreeViewItemAutomationPeer[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_TreeViewItemAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_TreeViewItemAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_TreeViewItemAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_TreeViewItemAutomationPeer) },
        { }};

    static PyType_Spec type_spec_TreeViewItemAutomationPeer = {
        "winui2._winui2_microsoft_ui_xaml_automation_peers.TreeViewItemAutomationPeer",
        sizeof(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_TreeViewItemAutomationPeer};

    static PyGetSetDef getset_TreeViewItemAutomationPeer_Static[] = {
        { }};

    static PyMethodDef methods_TreeViewItemAutomationPeer_Static[] = {
        { }};

    static PyType_Slot type_slots_TreeViewItemAutomationPeer_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_TreeViewItemAutomationPeer_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_TreeViewItemAutomationPeer_Static) },
        { }
    };

    static PyType_Spec type_spec_TreeViewItemAutomationPeer_Static = {
        "winui2._winui2_microsoft_ui_xaml_automation_peers.TreeViewItemAutomationPeer_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_TreeViewItemAutomationPeer_Static};

    // ----- TreeViewItemDataAutomationPeer class --------------------

    struct PyWinrtTreeViewItemDataAutomationPeer;
    using BasePyWinrtTreeViewItemDataAutomationPeer = winrt::Microsoft::UI::Xaml::Automation::Peers::TreeViewItemDataAutomationPeerT<PyWinrtTreeViewItemDataAutomationPeer, py::IPywinrtObject>;

    struct PyWinrtTreeViewItemDataAutomationPeer : py::py_obj_ref, BasePyWinrtTreeViewItemDataAutomationPeer
    {
        PyWinrtTreeViewItemDataAutomationPeer(PyObject* py_obj, winrt::Windows::Foundation::IInspectable item, winrt::Microsoft::UI::Xaml::Automation::Peers::TreeViewListAutomationPeer parent) : py::py_obj_ref(py_obj), BasePyWinrtTreeViewItemDataAutomationPeer(item, parent) {}

        int32_t __stdcall GetPyObject(PyObject*& obj) override
        {
            obj = py::py_obj_ref::get_py_obj();
            return 0;
        }

        int32_t __stdcall GetComposableInner(winrt::Windows::Foundation::IInspectable& inner) override
        {
            inner = m_inner;
            return winrt::impl::error_ok;
        }

        static void toggle_reference(PyWinrtTreeViewItemDataAutomationPeer* instance, bool is_last_reference)
        {
            py::py_obj_ref::toggle_reference(instance, is_last_reference);
        }

        int32_t query_interface_tearoff(winrt::guid const& id, void** result) const noexcept override
        {
            return py::py_obj_ref::query_interface_tearoff(id, result);
        }

        std::vector<winrt::guid> get_iids_tearoff() const noexcept override
        {
            return py::py_obj_ref::get_iids_tearoff();
        }
    };

    static PyObject* _new_TreeViewItemDataAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_GET_SIZE(args);

        auto self_type = get_python_type_for<winrt::Microsoft::UI::Xaml::Automation::Peers::TreeViewItemDataAutomationPeer>();
        if (!self_type)
        {
            return nullptr;
        }

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 0);
                auto param1 = py::convert_to<winrt::Microsoft::UI::Xaml::Automation::Peers::TreeViewListAutomationPeer>(args, 1);

                if (type != self_type)
                {
                    py::pyobj_handle self{type->tp_alloc(type, 0)};
                    if (!self)
                    {
                        return nullptr;
                    }

                    std::construct_at(&reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj, nullptr);

                    auto obj_impl = winrt::make_self<PyWinrtTreeViewItemDataAutomationPeer>(self.get(), param0, param1);

                    auto obj = py::make_py_obj<PyWinrtTreeViewItemDataAutomationPeer>(obj_impl, type, self.get());
                    if (!obj)
                    {
                        return nullptr;
                    }

                    reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj = std::move(obj);

                    return self.detach();
                }

                winrt::Microsoft::UI::Xaml::Automation::Peers::TreeViewItemDataAutomationPeer instance{param0, param1};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_TreeViewItemDataAutomationPeer(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* TreeViewItemDataAutomationPeer_Collapse(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.Peers.TreeViewItemDataAutomationPeer", L"Collapse", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.try_as<winrt::Microsoft::UI::Xaml::Automation::Peers::TreeViewItemDataAutomationPeer>().Collapse();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TreeViewItemDataAutomationPeer_Expand(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.Peers.TreeViewItemDataAutomationPeer", L"Expand", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.try_as<winrt::Microsoft::UI::Xaml::Automation::Peers::TreeViewItemDataAutomationPeer>().Expand();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TreeViewItemDataAutomationPeer_get_ExpandCollapseState(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.Peers.TreeViewItemDataAutomationPeer", L"ExpandCollapseState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Automation::Peers::TreeViewItemDataAutomationPeer>().ExpandCollapseState();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_TreeViewItemDataAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Automation::Peers::TreeViewItemDataAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_TreeViewItemDataAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Automation::Peers::TreeViewItemDataAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_TreeViewItemDataAutomationPeer[] = {
        { "collapse", reinterpret_cast<PyCFunction>(TreeViewItemDataAutomationPeer_Collapse), METH_VARARGS, nullptr },
        { "expand", reinterpret_cast<PyCFunction>(TreeViewItemDataAutomationPeer_Expand), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_TreeViewItemDataAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_TreeViewItemDataAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_TreeViewItemDataAutomationPeer[] = {
        { "expand_collapse_state", reinterpret_cast<getter>(TreeViewItemDataAutomationPeer_get_ExpandCollapseState), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_TreeViewItemDataAutomationPeer[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_TreeViewItemDataAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_TreeViewItemDataAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_TreeViewItemDataAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_TreeViewItemDataAutomationPeer) },
        { }};

    static PyType_Spec type_spec_TreeViewItemDataAutomationPeer = {
        "winui2._winui2_microsoft_ui_xaml_automation_peers.TreeViewItemDataAutomationPeer",
        sizeof(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_TreeViewItemDataAutomationPeer};

    static PyGetSetDef getset_TreeViewItemDataAutomationPeer_Static[] = {
        { }};

    static PyMethodDef methods_TreeViewItemDataAutomationPeer_Static[] = {
        { }};

    static PyType_Slot type_slots_TreeViewItemDataAutomationPeer_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_TreeViewItemDataAutomationPeer_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_TreeViewItemDataAutomationPeer_Static) },
        { }
    };

    static PyType_Spec type_spec_TreeViewItemDataAutomationPeer_Static = {
        "winui2._winui2_microsoft_ui_xaml_automation_peers.TreeViewItemDataAutomationPeer_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_TreeViewItemDataAutomationPeer_Static};

    // ----- TreeViewListAutomationPeer class --------------------

    struct PyWinrtTreeViewListAutomationPeer;
    using BasePyWinrtTreeViewListAutomationPeer = winrt::Microsoft::UI::Xaml::Automation::Peers::TreeViewListAutomationPeerT<PyWinrtTreeViewListAutomationPeer, py::IPywinrtObject>;

    struct PyWinrtTreeViewListAutomationPeer : py::py_obj_ref, BasePyWinrtTreeViewListAutomationPeer
    {
        PyWinrtTreeViewListAutomationPeer(PyObject* py_obj, winrt::Microsoft::UI::Xaml::Controls::TreeViewList owner) : py::py_obj_ref(py_obj), BasePyWinrtTreeViewListAutomationPeer(owner) {}

        int32_t __stdcall GetPyObject(PyObject*& obj) override
        {
            obj = py::py_obj_ref::get_py_obj();
            return 0;
        }

        int32_t __stdcall GetComposableInner(winrt::Windows::Foundation::IInspectable& inner) override
        {
            inner = m_inner;
            return winrt::impl::error_ok;
        }

        static void toggle_reference(PyWinrtTreeViewListAutomationPeer* instance, bool is_last_reference)
        {
            py::py_obj_ref::toggle_reference(instance, is_last_reference);
        }

        int32_t query_interface_tearoff(winrt::guid const& id, void** result) const noexcept override
        {
            return py::py_obj_ref::query_interface_tearoff(id, result);
        }

        std::vector<winrt::guid> get_iids_tearoff() const noexcept override
        {
            return py::py_obj_ref::get_iids_tearoff();
        }
    };

    static PyObject* _new_TreeViewListAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_GET_SIZE(args);

        auto self_type = get_python_type_for<winrt::Microsoft::UI::Xaml::Automation::Peers::TreeViewListAutomationPeer>();
        if (!self_type)
        {
            return nullptr;
        }

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::TreeViewList>(args, 0);

                if (type != self_type)
                {
                    py::pyobj_handle self{type->tp_alloc(type, 0)};
                    if (!self)
                    {
                        return nullptr;
                    }

                    std::construct_at(&reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj, nullptr);

                    auto obj_impl = winrt::make_self<PyWinrtTreeViewListAutomationPeer>(self.get(), param0);

                    auto obj = py::make_py_obj<PyWinrtTreeViewListAutomationPeer>(obj_impl, type, self.get());
                    if (!obj)
                    {
                        return nullptr;
                    }

                    reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj = std::move(obj);

                    return self.detach();
                }

                winrt::Microsoft::UI::Xaml::Automation::Peers::TreeViewListAutomationPeer instance{param0};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_TreeViewListAutomationPeer(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_TreeViewListAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Automation::Peers::TreeViewListAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_TreeViewListAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Automation::Peers::TreeViewListAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_TreeViewListAutomationPeer[] = {
        { "_assign_array_", _assign_array_TreeViewListAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_TreeViewListAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_TreeViewListAutomationPeer[] = {
        { }};

    static PyType_Slot _type_slots_TreeViewListAutomationPeer[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_TreeViewListAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_TreeViewListAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_TreeViewListAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_TreeViewListAutomationPeer) },
        { }};

    static PyType_Spec type_spec_TreeViewListAutomationPeer = {
        "winui2._winui2_microsoft_ui_xaml_automation_peers.TreeViewListAutomationPeer",
        sizeof(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_TreeViewListAutomationPeer};

    static PyGetSetDef getset_TreeViewListAutomationPeer_Static[] = {
        { }};

    static PyMethodDef methods_TreeViewListAutomationPeer_Static[] = {
        { }};

    static PyType_Slot type_slots_TreeViewListAutomationPeer_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_TreeViewListAutomationPeer_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_TreeViewListAutomationPeer_Static) },
        { }
    };

    static PyType_Spec type_spec_TreeViewListAutomationPeer_Static = {
        "winui2._winui2_microsoft_ui_xaml_automation_peers.TreeViewListAutomationPeer_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_TreeViewListAutomationPeer_Static};

    // ----- Microsoft.UI.Xaml.Automation.Peers Initialization --------------------

    PyDoc_STRVAR(module_doc, "Microsoft.UI.Xaml.Automation.Peers");

    static PyModuleDef module_def = {
        PyModuleDef_HEAD_INIT,
        "_winui2_microsoft_ui_xaml_automation_peers",
        module_doc,
        0,
        nullptr,
        nullptr,
        nullptr,
        nullptr,
        nullptr};
} // py::cpp::Microsoft::UI::Xaml::Automation::Peers

PyMODINIT_FUNC PyInit__winui2_microsoft_ui_xaml_automation_peers(void) noexcept
{
    using namespace py::cpp::Microsoft::UI::Xaml::Automation::Peers;

    if (py::import_winrt_runtime() == -1)
    {
        return nullptr;
    }

    py::pyobj_handle module{PyModule_Create(&module_def)};

    if (!module)
    {
        return nullptr;
    }

    auto inspectable_meta_type = py::get_inspectable_meta_type();
    if (!inspectable_meta_type)
    {
        return nullptr;
    }

    auto object_type = py::get_object_type();
    if (!object_type)
    {
        return nullptr;
    }

    py::pyobj_handle object_bases{PyTuple_Pack(1, object_type)};

    if (!object_bases)
    {
        return nullptr;
    }

    py::pyobj_handle windows_ui_xaml_automation_peers_module{PyImport_ImportModule("winrt._winrt_windows_ui_xaml_automation_peers")};
    if (!windows_ui_xaml_automation_peers_module)
    {
        return nullptr;
    }

    py::pyobj_handle windows_ui_xaml_automation_peers_FrameworkElementAutomationPeer_type{PyObject_GetAttrString(windows_ui_xaml_automation_peers_module.get(), "FrameworkElementAutomationPeer")};
    if (!windows_ui_xaml_automation_peers_FrameworkElementAutomationPeer_type)
    {
        return nullptr;
    }

    py::pyobj_handle windows_ui_xaml_automation_peers_SliderAutomationPeer_type{PyObject_GetAttrString(windows_ui_xaml_automation_peers_module.get(), "SliderAutomationPeer")};
    if (!windows_ui_xaml_automation_peers_SliderAutomationPeer_type)
    {
        return nullptr;
    }

    py::pyobj_handle windows_ui_xaml_automation_peers_ButtonAutomationPeer_type{PyObject_GetAttrString(windows_ui_xaml_automation_peers_module.get(), "ButtonAutomationPeer")};
    if (!windows_ui_xaml_automation_peers_ButtonAutomationPeer_type)
    {
        return nullptr;
    }

    py::pyobj_handle windows_ui_xaml_automation_peers_RangeBaseAutomationPeer_type{PyObject_GetAttrString(windows_ui_xaml_automation_peers_module.get(), "RangeBaseAutomationPeer")};
    if (!windows_ui_xaml_automation_peers_RangeBaseAutomationPeer_type)
    {
        return nullptr;
    }

    py::pyobj_handle windows_ui_xaml_automation_peers_ListViewItemAutomationPeer_type{PyObject_GetAttrString(windows_ui_xaml_automation_peers_module.get(), "ListViewItemAutomationPeer")};
    if (!windows_ui_xaml_automation_peers_ListViewItemAutomationPeer_type)
    {
        return nullptr;
    }

    py::pyobj_handle windows_ui_xaml_automation_peers_ItemAutomationPeer_type{PyObject_GetAttrString(windows_ui_xaml_automation_peers_module.get(), "ItemAutomationPeer")};
    if (!windows_ui_xaml_automation_peers_ItemAutomationPeer_type)
    {
        return nullptr;
    }

    py::pyobj_handle windows_ui_xaml_automation_peers_ListViewAutomationPeer_type{PyObject_GetAttrString(windows_ui_xaml_automation_peers_module.get(), "ListViewAutomationPeer")};
    if (!windows_ui_xaml_automation_peers_ListViewAutomationPeer_type)
    {
        return nullptr;
    }

    py::pyobj_handle AnimatedVisualPlayerAutomationPeer_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(windows_ui_xaml_automation_peers_FrameworkElementAutomationPeer_type.get())))};
    if (!AnimatedVisualPlayerAutomationPeer_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_AnimatedVisualPlayerAutomationPeer_Static{PyType_FromSpecWithBases(&type_spec_AnimatedVisualPlayerAutomationPeer_Static, AnimatedVisualPlayerAutomationPeer_Static_bases.get())};
    if (!type_AnimatedVisualPlayerAutomationPeer_Static)
    {
        return nullptr;
    }

    py::pyobj_handle AnimatedVisualPlayerAutomationPeer_bases{PyTuple_Pack(1, windows_ui_xaml_automation_peers_FrameworkElementAutomationPeer_type.get())};
    if (!AnimatedVisualPlayerAutomationPeer_bases)
    {
        return nullptr;
    }

    py::pytype_handle AnimatedVisualPlayerAutomationPeer_type{py::register_python_type(module.get(), &type_spec_AnimatedVisualPlayerAutomationPeer, AnimatedVisualPlayerAutomationPeer_bases.get(), reinterpret_cast<PyTypeObject*>(type_AnimatedVisualPlayerAutomationPeer_Static.get()))};
    if (!AnimatedVisualPlayerAutomationPeer_type)
    {
        return nullptr;
    }

    py::pyobj_handle BreadcrumbBarItemAutomationPeer_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(windows_ui_xaml_automation_peers_FrameworkElementAutomationPeer_type.get())))};
    if (!BreadcrumbBarItemAutomationPeer_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_BreadcrumbBarItemAutomationPeer_Static{PyType_FromSpecWithBases(&type_spec_BreadcrumbBarItemAutomationPeer_Static, BreadcrumbBarItemAutomationPeer_Static_bases.get())};
    if (!type_BreadcrumbBarItemAutomationPeer_Static)
    {
        return nullptr;
    }

    py::pyobj_handle BreadcrumbBarItemAutomationPeer_bases{PyTuple_Pack(1, windows_ui_xaml_automation_peers_FrameworkElementAutomationPeer_type.get())};
    if (!BreadcrumbBarItemAutomationPeer_bases)
    {
        return nullptr;
    }

    py::pytype_handle BreadcrumbBarItemAutomationPeer_type{py::register_python_type(module.get(), &type_spec_BreadcrumbBarItemAutomationPeer, BreadcrumbBarItemAutomationPeer_bases.get(), reinterpret_cast<PyTypeObject*>(type_BreadcrumbBarItemAutomationPeer_Static.get()))};
    if (!BreadcrumbBarItemAutomationPeer_type)
    {
        return nullptr;
    }

    py::pyobj_handle ColorPickerSliderAutomationPeer_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(windows_ui_xaml_automation_peers_SliderAutomationPeer_type.get())))};
    if (!ColorPickerSliderAutomationPeer_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_ColorPickerSliderAutomationPeer_Static{PyType_FromSpecWithBases(&type_spec_ColorPickerSliderAutomationPeer_Static, ColorPickerSliderAutomationPeer_Static_bases.get())};
    if (!type_ColorPickerSliderAutomationPeer_Static)
    {
        return nullptr;
    }

    py::pyobj_handle ColorPickerSliderAutomationPeer_bases{PyTuple_Pack(1, windows_ui_xaml_automation_peers_SliderAutomationPeer_type.get())};
    if (!ColorPickerSliderAutomationPeer_bases)
    {
        return nullptr;
    }

    py::pytype_handle ColorPickerSliderAutomationPeer_type{py::register_python_type(module.get(), &type_spec_ColorPickerSliderAutomationPeer, ColorPickerSliderAutomationPeer_bases.get(), reinterpret_cast<PyTypeObject*>(type_ColorPickerSliderAutomationPeer_Static.get()))};
    if (!ColorPickerSliderAutomationPeer_type)
    {
        return nullptr;
    }

    py::pyobj_handle ColorSpectrumAutomationPeer_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(windows_ui_xaml_automation_peers_FrameworkElementAutomationPeer_type.get())))};
    if (!ColorSpectrumAutomationPeer_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_ColorSpectrumAutomationPeer_Static{PyType_FromSpecWithBases(&type_spec_ColorSpectrumAutomationPeer_Static, ColorSpectrumAutomationPeer_Static_bases.get())};
    if (!type_ColorSpectrumAutomationPeer_Static)
    {
        return nullptr;
    }

    py::pyobj_handle ColorSpectrumAutomationPeer_bases{PyTuple_Pack(1, windows_ui_xaml_automation_peers_FrameworkElementAutomationPeer_type.get())};
    if (!ColorSpectrumAutomationPeer_bases)
    {
        return nullptr;
    }

    py::pytype_handle ColorSpectrumAutomationPeer_type{py::register_python_type(module.get(), &type_spec_ColorSpectrumAutomationPeer, ColorSpectrumAutomationPeer_bases.get(), reinterpret_cast<PyTypeObject*>(type_ColorSpectrumAutomationPeer_Static.get()))};
    if (!ColorSpectrumAutomationPeer_type)
    {
        return nullptr;
    }

    py::pyobj_handle DropDownButtonAutomationPeer_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(windows_ui_xaml_automation_peers_ButtonAutomationPeer_type.get())))};
    if (!DropDownButtonAutomationPeer_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_DropDownButtonAutomationPeer_Static{PyType_FromSpecWithBases(&type_spec_DropDownButtonAutomationPeer_Static, DropDownButtonAutomationPeer_Static_bases.get())};
    if (!type_DropDownButtonAutomationPeer_Static)
    {
        return nullptr;
    }

    py::pyobj_handle DropDownButtonAutomationPeer_bases{PyTuple_Pack(1, windows_ui_xaml_automation_peers_ButtonAutomationPeer_type.get())};
    if (!DropDownButtonAutomationPeer_bases)
    {
        return nullptr;
    }

    py::pytype_handle DropDownButtonAutomationPeer_type{py::register_python_type(module.get(), &type_spec_DropDownButtonAutomationPeer, DropDownButtonAutomationPeer_bases.get(), reinterpret_cast<PyTypeObject*>(type_DropDownButtonAutomationPeer_Static.get()))};
    if (!DropDownButtonAutomationPeer_type)
    {
        return nullptr;
    }

    py::pyobj_handle ExpanderAutomationPeer_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(windows_ui_xaml_automation_peers_FrameworkElementAutomationPeer_type.get())))};
    if (!ExpanderAutomationPeer_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_ExpanderAutomationPeer_Static{PyType_FromSpecWithBases(&type_spec_ExpanderAutomationPeer_Static, ExpanderAutomationPeer_Static_bases.get())};
    if (!type_ExpanderAutomationPeer_Static)
    {
        return nullptr;
    }

    py::pyobj_handle ExpanderAutomationPeer_bases{PyTuple_Pack(1, windows_ui_xaml_automation_peers_FrameworkElementAutomationPeer_type.get())};
    if (!ExpanderAutomationPeer_bases)
    {
        return nullptr;
    }

    py::pytype_handle ExpanderAutomationPeer_type{py::register_python_type(module.get(), &type_spec_ExpanderAutomationPeer, ExpanderAutomationPeer_bases.get(), reinterpret_cast<PyTypeObject*>(type_ExpanderAutomationPeer_Static.get()))};
    if (!ExpanderAutomationPeer_type)
    {
        return nullptr;
    }

    py::pyobj_handle InfoBarAutomationPeer_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(windows_ui_xaml_automation_peers_FrameworkElementAutomationPeer_type.get())))};
    if (!InfoBarAutomationPeer_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_InfoBarAutomationPeer_Static{PyType_FromSpecWithBases(&type_spec_InfoBarAutomationPeer_Static, InfoBarAutomationPeer_Static_bases.get())};
    if (!type_InfoBarAutomationPeer_Static)
    {
        return nullptr;
    }

    py::pyobj_handle InfoBarAutomationPeer_bases{PyTuple_Pack(1, windows_ui_xaml_automation_peers_FrameworkElementAutomationPeer_type.get())};
    if (!InfoBarAutomationPeer_bases)
    {
        return nullptr;
    }

    py::pytype_handle InfoBarAutomationPeer_type{py::register_python_type(module.get(), &type_spec_InfoBarAutomationPeer, InfoBarAutomationPeer_bases.get(), reinterpret_cast<PyTypeObject*>(type_InfoBarAutomationPeer_Static.get()))};
    if (!InfoBarAutomationPeer_type)
    {
        return nullptr;
    }

    py::pyobj_handle MenuBarAutomationPeer_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(windows_ui_xaml_automation_peers_FrameworkElementAutomationPeer_type.get())))};
    if (!MenuBarAutomationPeer_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_MenuBarAutomationPeer_Static{PyType_FromSpecWithBases(&type_spec_MenuBarAutomationPeer_Static, MenuBarAutomationPeer_Static_bases.get())};
    if (!type_MenuBarAutomationPeer_Static)
    {
        return nullptr;
    }

    py::pyobj_handle MenuBarAutomationPeer_bases{PyTuple_Pack(1, windows_ui_xaml_automation_peers_FrameworkElementAutomationPeer_type.get())};
    if (!MenuBarAutomationPeer_bases)
    {
        return nullptr;
    }

    py::pytype_handle MenuBarAutomationPeer_type{py::register_python_type(module.get(), &type_spec_MenuBarAutomationPeer, MenuBarAutomationPeer_bases.get(), reinterpret_cast<PyTypeObject*>(type_MenuBarAutomationPeer_Static.get()))};
    if (!MenuBarAutomationPeer_type)
    {
        return nullptr;
    }

    py::pyobj_handle MenuBarItemAutomationPeer_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(windows_ui_xaml_automation_peers_FrameworkElementAutomationPeer_type.get())))};
    if (!MenuBarItemAutomationPeer_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_MenuBarItemAutomationPeer_Static{PyType_FromSpecWithBases(&type_spec_MenuBarItemAutomationPeer_Static, MenuBarItemAutomationPeer_Static_bases.get())};
    if (!type_MenuBarItemAutomationPeer_Static)
    {
        return nullptr;
    }

    py::pyobj_handle MenuBarItemAutomationPeer_bases{PyTuple_Pack(1, windows_ui_xaml_automation_peers_FrameworkElementAutomationPeer_type.get())};
    if (!MenuBarItemAutomationPeer_bases)
    {
        return nullptr;
    }

    py::pytype_handle MenuBarItemAutomationPeer_type{py::register_python_type(module.get(), &type_spec_MenuBarItemAutomationPeer, MenuBarItemAutomationPeer_bases.get(), reinterpret_cast<PyTypeObject*>(type_MenuBarItemAutomationPeer_Static.get()))};
    if (!MenuBarItemAutomationPeer_type)
    {
        return nullptr;
    }

    py::pyobj_handle NavigationViewAutomationPeer_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(windows_ui_xaml_automation_peers_FrameworkElementAutomationPeer_type.get())))};
    if (!NavigationViewAutomationPeer_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_NavigationViewAutomationPeer_Static{PyType_FromSpecWithBases(&type_spec_NavigationViewAutomationPeer_Static, NavigationViewAutomationPeer_Static_bases.get())};
    if (!type_NavigationViewAutomationPeer_Static)
    {
        return nullptr;
    }

    py::pyobj_handle NavigationViewAutomationPeer_bases{PyTuple_Pack(1, windows_ui_xaml_automation_peers_FrameworkElementAutomationPeer_type.get())};
    if (!NavigationViewAutomationPeer_bases)
    {
        return nullptr;
    }

    py::pytype_handle NavigationViewAutomationPeer_type{py::register_python_type(module.get(), &type_spec_NavigationViewAutomationPeer, NavigationViewAutomationPeer_bases.get(), reinterpret_cast<PyTypeObject*>(type_NavigationViewAutomationPeer_Static.get()))};
    if (!NavigationViewAutomationPeer_type)
    {
        return nullptr;
    }

    py::pyobj_handle NavigationViewItemAutomationPeer_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(windows_ui_xaml_automation_peers_FrameworkElementAutomationPeer_type.get())))};
    if (!NavigationViewItemAutomationPeer_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_NavigationViewItemAutomationPeer_Static{PyType_FromSpecWithBases(&type_spec_NavigationViewItemAutomationPeer_Static, NavigationViewItemAutomationPeer_Static_bases.get())};
    if (!type_NavigationViewItemAutomationPeer_Static)
    {
        return nullptr;
    }

    py::pyobj_handle NavigationViewItemAutomationPeer_bases{PyTuple_Pack(1, windows_ui_xaml_automation_peers_FrameworkElementAutomationPeer_type.get())};
    if (!NavigationViewItemAutomationPeer_bases)
    {
        return nullptr;
    }

    py::pytype_handle NavigationViewItemAutomationPeer_type{py::register_python_type(module.get(), &type_spec_NavigationViewItemAutomationPeer, NavigationViewItemAutomationPeer_bases.get(), reinterpret_cast<PyTypeObject*>(type_NavigationViewItemAutomationPeer_Static.get()))};
    if (!NavigationViewItemAutomationPeer_type)
    {
        return nullptr;
    }

    py::pyobj_handle NumberBoxAutomationPeer_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(windows_ui_xaml_automation_peers_FrameworkElementAutomationPeer_type.get())))};
    if (!NumberBoxAutomationPeer_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_NumberBoxAutomationPeer_Static{PyType_FromSpecWithBases(&type_spec_NumberBoxAutomationPeer_Static, NumberBoxAutomationPeer_Static_bases.get())};
    if (!type_NumberBoxAutomationPeer_Static)
    {
        return nullptr;
    }

    py::pyobj_handle NumberBoxAutomationPeer_bases{PyTuple_Pack(1, windows_ui_xaml_automation_peers_FrameworkElementAutomationPeer_type.get())};
    if (!NumberBoxAutomationPeer_bases)
    {
        return nullptr;
    }

    py::pytype_handle NumberBoxAutomationPeer_type{py::register_python_type(module.get(), &type_spec_NumberBoxAutomationPeer, NumberBoxAutomationPeer_bases.get(), reinterpret_cast<PyTypeObject*>(type_NumberBoxAutomationPeer_Static.get()))};
    if (!NumberBoxAutomationPeer_type)
    {
        return nullptr;
    }

    py::pyobj_handle PersonPictureAutomationPeer_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(windows_ui_xaml_automation_peers_FrameworkElementAutomationPeer_type.get())))};
    if (!PersonPictureAutomationPeer_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_PersonPictureAutomationPeer_Static{PyType_FromSpecWithBases(&type_spec_PersonPictureAutomationPeer_Static, PersonPictureAutomationPeer_Static_bases.get())};
    if (!type_PersonPictureAutomationPeer_Static)
    {
        return nullptr;
    }

    py::pyobj_handle PersonPictureAutomationPeer_bases{PyTuple_Pack(1, windows_ui_xaml_automation_peers_FrameworkElementAutomationPeer_type.get())};
    if (!PersonPictureAutomationPeer_bases)
    {
        return nullptr;
    }

    py::pytype_handle PersonPictureAutomationPeer_type{py::register_python_type(module.get(), &type_spec_PersonPictureAutomationPeer, PersonPictureAutomationPeer_bases.get(), reinterpret_cast<PyTypeObject*>(type_PersonPictureAutomationPeer_Static.get()))};
    if (!PersonPictureAutomationPeer_type)
    {
        return nullptr;
    }

    py::pyobj_handle PipsPagerAutomationPeer_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(windows_ui_xaml_automation_peers_FrameworkElementAutomationPeer_type.get())))};
    if (!PipsPagerAutomationPeer_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_PipsPagerAutomationPeer_Static{PyType_FromSpecWithBases(&type_spec_PipsPagerAutomationPeer_Static, PipsPagerAutomationPeer_Static_bases.get())};
    if (!type_PipsPagerAutomationPeer_Static)
    {
        return nullptr;
    }

    py::pyobj_handle PipsPagerAutomationPeer_bases{PyTuple_Pack(1, windows_ui_xaml_automation_peers_FrameworkElementAutomationPeer_type.get())};
    if (!PipsPagerAutomationPeer_bases)
    {
        return nullptr;
    }

    py::pytype_handle PipsPagerAutomationPeer_type{py::register_python_type(module.get(), &type_spec_PipsPagerAutomationPeer, PipsPagerAutomationPeer_bases.get(), reinterpret_cast<PyTypeObject*>(type_PipsPagerAutomationPeer_Static.get()))};
    if (!PipsPagerAutomationPeer_type)
    {
        return nullptr;
    }

    py::pyobj_handle ProgressBarAutomationPeer_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(windows_ui_xaml_automation_peers_RangeBaseAutomationPeer_type.get())))};
    if (!ProgressBarAutomationPeer_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_ProgressBarAutomationPeer_Static{PyType_FromSpecWithBases(&type_spec_ProgressBarAutomationPeer_Static, ProgressBarAutomationPeer_Static_bases.get())};
    if (!type_ProgressBarAutomationPeer_Static)
    {
        return nullptr;
    }

    py::pyobj_handle ProgressBarAutomationPeer_bases{PyTuple_Pack(1, windows_ui_xaml_automation_peers_RangeBaseAutomationPeer_type.get())};
    if (!ProgressBarAutomationPeer_bases)
    {
        return nullptr;
    }

    py::pytype_handle ProgressBarAutomationPeer_type{py::register_python_type(module.get(), &type_spec_ProgressBarAutomationPeer, ProgressBarAutomationPeer_bases.get(), reinterpret_cast<PyTypeObject*>(type_ProgressBarAutomationPeer_Static.get()))};
    if (!ProgressBarAutomationPeer_type)
    {
        return nullptr;
    }

    py::pyobj_handle ProgressRingAutomationPeer_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(windows_ui_xaml_automation_peers_FrameworkElementAutomationPeer_type.get())))};
    if (!ProgressRingAutomationPeer_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_ProgressRingAutomationPeer_Static{PyType_FromSpecWithBases(&type_spec_ProgressRingAutomationPeer_Static, ProgressRingAutomationPeer_Static_bases.get())};
    if (!type_ProgressRingAutomationPeer_Static)
    {
        return nullptr;
    }

    py::pyobj_handle ProgressRingAutomationPeer_bases{PyTuple_Pack(1, windows_ui_xaml_automation_peers_FrameworkElementAutomationPeer_type.get())};
    if (!ProgressRingAutomationPeer_bases)
    {
        return nullptr;
    }

    py::pytype_handle ProgressRingAutomationPeer_type{py::register_python_type(module.get(), &type_spec_ProgressRingAutomationPeer, ProgressRingAutomationPeer_bases.get(), reinterpret_cast<PyTypeObject*>(type_ProgressRingAutomationPeer_Static.get()))};
    if (!ProgressRingAutomationPeer_type)
    {
        return nullptr;
    }

    py::pyobj_handle RadioButtonsAutomationPeer_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(windows_ui_xaml_automation_peers_FrameworkElementAutomationPeer_type.get())))};
    if (!RadioButtonsAutomationPeer_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_RadioButtonsAutomationPeer_Static{PyType_FromSpecWithBases(&type_spec_RadioButtonsAutomationPeer_Static, RadioButtonsAutomationPeer_Static_bases.get())};
    if (!type_RadioButtonsAutomationPeer_Static)
    {
        return nullptr;
    }

    py::pyobj_handle RadioButtonsAutomationPeer_bases{PyTuple_Pack(1, windows_ui_xaml_automation_peers_FrameworkElementAutomationPeer_type.get())};
    if (!RadioButtonsAutomationPeer_bases)
    {
        return nullptr;
    }

    py::pytype_handle RadioButtonsAutomationPeer_type{py::register_python_type(module.get(), &type_spec_RadioButtonsAutomationPeer, RadioButtonsAutomationPeer_bases.get(), reinterpret_cast<PyTypeObject*>(type_RadioButtonsAutomationPeer_Static.get()))};
    if (!RadioButtonsAutomationPeer_type)
    {
        return nullptr;
    }

    py::pyobj_handle RatingControlAutomationPeer_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(windows_ui_xaml_automation_peers_FrameworkElementAutomationPeer_type.get())))};
    if (!RatingControlAutomationPeer_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_RatingControlAutomationPeer_Static{PyType_FromSpecWithBases(&type_spec_RatingControlAutomationPeer_Static, RatingControlAutomationPeer_Static_bases.get())};
    if (!type_RatingControlAutomationPeer_Static)
    {
        return nullptr;
    }

    py::pyobj_handle RatingControlAutomationPeer_bases{PyTuple_Pack(1, windows_ui_xaml_automation_peers_FrameworkElementAutomationPeer_type.get())};
    if (!RatingControlAutomationPeer_bases)
    {
        return nullptr;
    }

    py::pytype_handle RatingControlAutomationPeer_type{py::register_python_type(module.get(), &type_spec_RatingControlAutomationPeer, RatingControlAutomationPeer_bases.get(), reinterpret_cast<PyTypeObject*>(type_RatingControlAutomationPeer_Static.get()))};
    if (!RatingControlAutomationPeer_type)
    {
        return nullptr;
    }

    py::pyobj_handle RepeaterAutomationPeer_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(windows_ui_xaml_automation_peers_FrameworkElementAutomationPeer_type.get())))};
    if (!RepeaterAutomationPeer_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_RepeaterAutomationPeer_Static{PyType_FromSpecWithBases(&type_spec_RepeaterAutomationPeer_Static, RepeaterAutomationPeer_Static_bases.get())};
    if (!type_RepeaterAutomationPeer_Static)
    {
        return nullptr;
    }

    py::pyobj_handle RepeaterAutomationPeer_bases{PyTuple_Pack(1, windows_ui_xaml_automation_peers_FrameworkElementAutomationPeer_type.get())};
    if (!RepeaterAutomationPeer_bases)
    {
        return nullptr;
    }

    py::pytype_handle RepeaterAutomationPeer_type{py::register_python_type(module.get(), &type_spec_RepeaterAutomationPeer, RepeaterAutomationPeer_bases.get(), reinterpret_cast<PyTypeObject*>(type_RepeaterAutomationPeer_Static.get()))};
    if (!RepeaterAutomationPeer_type)
    {
        return nullptr;
    }

    py::pyobj_handle SplitButtonAutomationPeer_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(windows_ui_xaml_automation_peers_FrameworkElementAutomationPeer_type.get())))};
    if (!SplitButtonAutomationPeer_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_SplitButtonAutomationPeer_Static{PyType_FromSpecWithBases(&type_spec_SplitButtonAutomationPeer_Static, SplitButtonAutomationPeer_Static_bases.get())};
    if (!type_SplitButtonAutomationPeer_Static)
    {
        return nullptr;
    }

    py::pyobj_handle SplitButtonAutomationPeer_bases{PyTuple_Pack(1, windows_ui_xaml_automation_peers_FrameworkElementAutomationPeer_type.get())};
    if (!SplitButtonAutomationPeer_bases)
    {
        return nullptr;
    }

    py::pytype_handle SplitButtonAutomationPeer_type{py::register_python_type(module.get(), &type_spec_SplitButtonAutomationPeer, SplitButtonAutomationPeer_bases.get(), reinterpret_cast<PyTypeObject*>(type_SplitButtonAutomationPeer_Static.get()))};
    if (!SplitButtonAutomationPeer_type)
    {
        return nullptr;
    }

    py::pyobj_handle TabViewAutomationPeer_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(windows_ui_xaml_automation_peers_FrameworkElementAutomationPeer_type.get())))};
    if (!TabViewAutomationPeer_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_TabViewAutomationPeer_Static{PyType_FromSpecWithBases(&type_spec_TabViewAutomationPeer_Static, TabViewAutomationPeer_Static_bases.get())};
    if (!type_TabViewAutomationPeer_Static)
    {
        return nullptr;
    }

    py::pyobj_handle TabViewAutomationPeer_bases{PyTuple_Pack(1, windows_ui_xaml_automation_peers_FrameworkElementAutomationPeer_type.get())};
    if (!TabViewAutomationPeer_bases)
    {
        return nullptr;
    }

    py::pytype_handle TabViewAutomationPeer_type{py::register_python_type(module.get(), &type_spec_TabViewAutomationPeer, TabViewAutomationPeer_bases.get(), reinterpret_cast<PyTypeObject*>(type_TabViewAutomationPeer_Static.get()))};
    if (!TabViewAutomationPeer_type)
    {
        return nullptr;
    }

    py::pyobj_handle TabViewItemAutomationPeer_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(windows_ui_xaml_automation_peers_ListViewItemAutomationPeer_type.get())))};
    if (!TabViewItemAutomationPeer_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_TabViewItemAutomationPeer_Static{PyType_FromSpecWithBases(&type_spec_TabViewItemAutomationPeer_Static, TabViewItemAutomationPeer_Static_bases.get())};
    if (!type_TabViewItemAutomationPeer_Static)
    {
        return nullptr;
    }

    py::pyobj_handle TabViewItemAutomationPeer_bases{PyTuple_Pack(1, windows_ui_xaml_automation_peers_ListViewItemAutomationPeer_type.get())};
    if (!TabViewItemAutomationPeer_bases)
    {
        return nullptr;
    }

    py::pytype_handle TabViewItemAutomationPeer_type{py::register_python_type(module.get(), &type_spec_TabViewItemAutomationPeer, TabViewItemAutomationPeer_bases.get(), reinterpret_cast<PyTypeObject*>(type_TabViewItemAutomationPeer_Static.get()))};
    if (!TabViewItemAutomationPeer_type)
    {
        return nullptr;
    }

    py::pyobj_handle TeachingTipAutomationPeer_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(windows_ui_xaml_automation_peers_FrameworkElementAutomationPeer_type.get())))};
    if (!TeachingTipAutomationPeer_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_TeachingTipAutomationPeer_Static{PyType_FromSpecWithBases(&type_spec_TeachingTipAutomationPeer_Static, TeachingTipAutomationPeer_Static_bases.get())};
    if (!type_TeachingTipAutomationPeer_Static)
    {
        return nullptr;
    }

    py::pyobj_handle TeachingTipAutomationPeer_bases{PyTuple_Pack(1, windows_ui_xaml_automation_peers_FrameworkElementAutomationPeer_type.get())};
    if (!TeachingTipAutomationPeer_bases)
    {
        return nullptr;
    }

    py::pytype_handle TeachingTipAutomationPeer_type{py::register_python_type(module.get(), &type_spec_TeachingTipAutomationPeer, TeachingTipAutomationPeer_bases.get(), reinterpret_cast<PyTypeObject*>(type_TeachingTipAutomationPeer_Static.get()))};
    if (!TeachingTipAutomationPeer_type)
    {
        return nullptr;
    }

    py::pyobj_handle ToggleSplitButtonAutomationPeer_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(windows_ui_xaml_automation_peers_FrameworkElementAutomationPeer_type.get())))};
    if (!ToggleSplitButtonAutomationPeer_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_ToggleSplitButtonAutomationPeer_Static{PyType_FromSpecWithBases(&type_spec_ToggleSplitButtonAutomationPeer_Static, ToggleSplitButtonAutomationPeer_Static_bases.get())};
    if (!type_ToggleSplitButtonAutomationPeer_Static)
    {
        return nullptr;
    }

    py::pyobj_handle ToggleSplitButtonAutomationPeer_bases{PyTuple_Pack(1, windows_ui_xaml_automation_peers_FrameworkElementAutomationPeer_type.get())};
    if (!ToggleSplitButtonAutomationPeer_bases)
    {
        return nullptr;
    }

    py::pytype_handle ToggleSplitButtonAutomationPeer_type{py::register_python_type(module.get(), &type_spec_ToggleSplitButtonAutomationPeer, ToggleSplitButtonAutomationPeer_bases.get(), reinterpret_cast<PyTypeObject*>(type_ToggleSplitButtonAutomationPeer_Static.get()))};
    if (!ToggleSplitButtonAutomationPeer_type)
    {
        return nullptr;
    }

    py::pyobj_handle TreeViewItemAutomationPeer_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(windows_ui_xaml_automation_peers_ListViewItemAutomationPeer_type.get())))};
    if (!TreeViewItemAutomationPeer_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_TreeViewItemAutomationPeer_Static{PyType_FromSpecWithBases(&type_spec_TreeViewItemAutomationPeer_Static, TreeViewItemAutomationPeer_Static_bases.get())};
    if (!type_TreeViewItemAutomationPeer_Static)
    {
        return nullptr;
    }

    py::pyobj_handle TreeViewItemAutomationPeer_bases{PyTuple_Pack(1, windows_ui_xaml_automation_peers_ListViewItemAutomationPeer_type.get())};
    if (!TreeViewItemAutomationPeer_bases)
    {
        return nullptr;
    }

    py::pytype_handle TreeViewItemAutomationPeer_type{py::register_python_type(module.get(), &type_spec_TreeViewItemAutomationPeer, TreeViewItemAutomationPeer_bases.get(), reinterpret_cast<PyTypeObject*>(type_TreeViewItemAutomationPeer_Static.get()))};
    if (!TreeViewItemAutomationPeer_type)
    {
        return nullptr;
    }

    py::pyobj_handle TreeViewItemDataAutomationPeer_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(windows_ui_xaml_automation_peers_ItemAutomationPeer_type.get())))};
    if (!TreeViewItemDataAutomationPeer_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_TreeViewItemDataAutomationPeer_Static{PyType_FromSpecWithBases(&type_spec_TreeViewItemDataAutomationPeer_Static, TreeViewItemDataAutomationPeer_Static_bases.get())};
    if (!type_TreeViewItemDataAutomationPeer_Static)
    {
        return nullptr;
    }

    py::pyobj_handle TreeViewItemDataAutomationPeer_bases{PyTuple_Pack(1, windows_ui_xaml_automation_peers_ItemAutomationPeer_type.get())};
    if (!TreeViewItemDataAutomationPeer_bases)
    {
        return nullptr;
    }

    py::pytype_handle TreeViewItemDataAutomationPeer_type{py::register_python_type(module.get(), &type_spec_TreeViewItemDataAutomationPeer, TreeViewItemDataAutomationPeer_bases.get(), reinterpret_cast<PyTypeObject*>(type_TreeViewItemDataAutomationPeer_Static.get()))};
    if (!TreeViewItemDataAutomationPeer_type)
    {
        return nullptr;
    }

    py::pyobj_handle TreeViewListAutomationPeer_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(windows_ui_xaml_automation_peers_ListViewAutomationPeer_type.get())))};
    if (!TreeViewListAutomationPeer_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_TreeViewListAutomationPeer_Static{PyType_FromSpecWithBases(&type_spec_TreeViewListAutomationPeer_Static, TreeViewListAutomationPeer_Static_bases.get())};
    if (!type_TreeViewListAutomationPeer_Static)
    {
        return nullptr;
    }

    py::pyobj_handle TreeViewListAutomationPeer_bases{PyTuple_Pack(1, windows_ui_xaml_automation_peers_ListViewAutomationPeer_type.get())};
    if (!TreeViewListAutomationPeer_bases)
    {
        return nullptr;
    }

    py::pytype_handle TreeViewListAutomationPeer_type{py::register_python_type(module.get(), &type_spec_TreeViewListAutomationPeer, TreeViewListAutomationPeer_bases.get(), reinterpret_cast<PyTypeObject*>(type_TreeViewListAutomationPeer_Static.get()))};
    if (!TreeViewListAutomationPeer_type)
    {
        return nullptr;
    }


    return module.detach();
}
