// WARNING: Please don't edit this file. It was generated by Python/WinRT v3.1.0

#include "py.Microsoft.UI.Xaml.Controls.Primitives.h"

namespace py::cpp::Microsoft::UI::Xaml::Controls::Primitives
{
    // ----- AutoSuggestBoxHelper class --------------------

    static PyObject* _new_AutoSuggestBoxHelper(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Xaml::Controls::Primitives::AutoSuggestBoxHelper>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Xaml::Controls::Primitives::AutoSuggestBoxHelper>::type_name);
        return nullptr;
    }

    static void _dealloc_AutoSuggestBoxHelper(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::AutoSuggestBoxHelper* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AutoSuggestBoxHelper_GetKeepInteriorCornersSquare(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.Primitives.AutoSuggestBoxHelper", L"GetKeepInteriorCornersSquare", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::AutoSuggestBox>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Microsoft::UI::Xaml::Controls::Primitives::AutoSuggestBoxHelper::GetKeepInteriorCornersSquare(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutoSuggestBoxHelper_SetKeepInteriorCornersSquare(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.Primitives.AutoSuggestBoxHelper", L"SetKeepInteriorCornersSquare", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::AutoSuggestBox>(args, 0);
                auto param1 = py::convert_to<bool>(args, 1);

                {
                    auto _gil = release_gil();
                    winrt::Microsoft::UI::Xaml::Controls::Primitives::AutoSuggestBoxHelper::SetKeepInteriorCornersSquare(param0, param1);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutoSuggestBoxHelper_get_KeepInteriorCornersSquareProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.AutoSuggestBoxHelper", L"KeepInteriorCornersSquareProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::Primitives::AutoSuggestBoxHelper::KeepInteriorCornersSquareProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AutoSuggestBoxHelper(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::Primitives::AutoSuggestBoxHelper>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AutoSuggestBoxHelper(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::Primitives::AutoSuggestBoxHelper>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AutoSuggestBoxHelper[] = {
        { "_assign_array_", _assign_array_AutoSuggestBoxHelper, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AutoSuggestBoxHelper), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_AutoSuggestBoxHelper[] = {
        { }};

    static PyType_Slot _type_slots_AutoSuggestBoxHelper[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_AutoSuggestBoxHelper) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AutoSuggestBoxHelper) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AutoSuggestBoxHelper) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AutoSuggestBoxHelper) },
        { }};

    static PyType_Spec type_spec_AutoSuggestBoxHelper = {
        "winui2._winui2_microsoft_ui_xaml_controls_primitives.AutoSuggestBoxHelper",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::AutoSuggestBoxHelper),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AutoSuggestBoxHelper};

    static PyGetSetDef getset_AutoSuggestBoxHelper_Static[] = {
        { "keep_interior_corners_square_property", reinterpret_cast<getter>(AutoSuggestBoxHelper_get_KeepInteriorCornersSquareProperty), nullptr, nullptr, nullptr },
        { }};

    static PyMethodDef methods_AutoSuggestBoxHelper_Static[] = {
        { "get_keep_interior_corners_square", reinterpret_cast<PyCFunction>(AutoSuggestBoxHelper_GetKeepInteriorCornersSquare), METH_VARARGS, nullptr },
        { "set_keep_interior_corners_square", reinterpret_cast<PyCFunction>(AutoSuggestBoxHelper_SetKeepInteriorCornersSquare), METH_VARARGS, nullptr },
        { }};

    static PyType_Slot type_slots_AutoSuggestBoxHelper_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_AutoSuggestBoxHelper_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_AutoSuggestBoxHelper_Static) },
        { }
    };

    static PyType_Spec type_spec_AutoSuggestBoxHelper_Static = {
        "winui2._winui2_microsoft_ui_xaml_controls_primitives.AutoSuggestBoxHelper_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_AutoSuggestBoxHelper_Static};

    // ----- ColorPickerSlider class --------------------

    struct PyWinrtColorPickerSlider;
    using BasePyWinrtColorPickerSlider = winrt::Microsoft::UI::Xaml::Controls::Primitives::ColorPickerSliderT<PyWinrtColorPickerSlider, py::IPywinrtObject>;

    struct PyWinrtColorPickerSlider : py::py_obj_ref, BasePyWinrtColorPickerSlider
    {
        PyWinrtColorPickerSlider(PyObject* py_obj) : py::py_obj_ref(py_obj), BasePyWinrtColorPickerSlider() {}

        int32_t __stdcall GetPyObject(PyObject*& obj) override
        {
            obj = py::py_obj_ref::get_py_obj();
            return 0;
        }

        int32_t __stdcall GetComposableInner(winrt::Windows::Foundation::IInspectable& inner) override
        {
            inner = m_inner;
            return winrt::impl::error_ok;
        }

        static void toggle_reference(PyWinrtColorPickerSlider* instance, bool is_last_reference)
        {
            py::py_obj_ref::toggle_reference(instance, is_last_reference);
        }

        int32_t query_interface_tearoff(winrt::guid const& id, void** result) const noexcept override
        {
            return py::py_obj_ref::query_interface_tearoff(id, result);
        }

        std::vector<winrt::guid> get_iids_tearoff() const noexcept override
        {
            return py::py_obj_ref::get_iids_tearoff();
        }
    };

    static PyObject* _new_ColorPickerSlider(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_GET_SIZE(args);

        auto self_type = get_python_type_for<winrt::Microsoft::UI::Xaml::Controls::Primitives::ColorPickerSlider>();
        if (!self_type)
        {
            return nullptr;
        }

        if (arg_count == 0)
        {
            try
            {
                if (type != self_type)
                {
                    py::pyobj_handle self{type->tp_alloc(type, 0)};
                    if (!self)
                    {
                        return nullptr;
                    }

                    std::construct_at(&reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj, nullptr);

                    auto obj_impl = winrt::make_self<PyWinrtColorPickerSlider>(self.get());

                    auto obj = py::make_py_obj<PyWinrtColorPickerSlider>(obj_impl, type, self.get());
                    if (!obj)
                    {
                        return nullptr;
                    }

                    reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj = std::move(obj);

                    return self.detach();
                }

                winrt::Microsoft::UI::Xaml::Controls::Primitives::ColorPickerSlider instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ColorPickerSlider(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ColorPickerSlider_get_ColorChannel(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ColorPickerSlider", L"ColorChannel");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ColorPickerSlider>().ColorChannel();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ColorPickerSlider_put_ColorChannel(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ColorPickerSlider", L"ColorChannel");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::ColorPickerHsvChannel>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ColorPickerSlider>().ColorChannel(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ColorPickerSlider_get_ColorChannelProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ColorPickerSlider", L"ColorChannelProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::Primitives::ColorPickerSlider::ColorChannelProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ColorPickerSlider(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::Primitives::ColorPickerSlider>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ColorPickerSlider(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ColorPickerSlider>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ColorPickerSlider[] = {
        { "_assign_array_", _assign_array_ColorPickerSlider, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ColorPickerSlider), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_ColorPickerSlider[] = {
        { "color_channel", reinterpret_cast<getter>(ColorPickerSlider_get_ColorChannel), reinterpret_cast<setter>(ColorPickerSlider_put_ColorChannel), nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_ColorPickerSlider[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ColorPickerSlider) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ColorPickerSlider) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ColorPickerSlider) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ColorPickerSlider) },
        { }};

    static PyType_Spec type_spec_ColorPickerSlider = {
        "winui2._winui2_microsoft_ui_xaml_controls_primitives.ColorPickerSlider",
        sizeof(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_ColorPickerSlider};

    static PyGetSetDef getset_ColorPickerSlider_Static[] = {
        { "color_channel_property", reinterpret_cast<getter>(ColorPickerSlider_get_ColorChannelProperty), nullptr, nullptr, nullptr },
        { }};

    static PyMethodDef methods_ColorPickerSlider_Static[] = {
        { }};

    static PyType_Slot type_slots_ColorPickerSlider_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_ColorPickerSlider_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_ColorPickerSlider_Static) },
        { }
    };

    static PyType_Spec type_spec_ColorPickerSlider_Static = {
        "winui2._winui2_microsoft_ui_xaml_controls_primitives.ColorPickerSlider_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_ColorPickerSlider_Static};

    // ----- ColorSpectrum class --------------------

    struct PyWinrtColorSpectrum;
    using BasePyWinrtColorSpectrum = winrt::Microsoft::UI::Xaml::Controls::Primitives::ColorSpectrumT<PyWinrtColorSpectrum, py::IPywinrtObject>;

    struct PyWinrtColorSpectrum : py::py_obj_ref, BasePyWinrtColorSpectrum
    {
        PyWinrtColorSpectrum(PyObject* py_obj) : py::py_obj_ref(py_obj), BasePyWinrtColorSpectrum() {}

        int32_t __stdcall GetPyObject(PyObject*& obj) override
        {
            obj = py::py_obj_ref::get_py_obj();
            return 0;
        }

        int32_t __stdcall GetComposableInner(winrt::Windows::Foundation::IInspectable& inner) override
        {
            inner = m_inner;
            return winrt::impl::error_ok;
        }

        static void toggle_reference(PyWinrtColorSpectrum* instance, bool is_last_reference)
        {
            py::py_obj_ref::toggle_reference(instance, is_last_reference);
        }

        int32_t query_interface_tearoff(winrt::guid const& id, void** result) const noexcept override
        {
            return py::py_obj_ref::query_interface_tearoff(id, result);
        }

        std::vector<winrt::guid> get_iids_tearoff() const noexcept override
        {
            return py::py_obj_ref::get_iids_tearoff();
        }
    };

    static PyObject* _new_ColorSpectrum(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_GET_SIZE(args);

        auto self_type = get_python_type_for<winrt::Microsoft::UI::Xaml::Controls::Primitives::ColorSpectrum>();
        if (!self_type)
        {
            return nullptr;
        }

        if (arg_count == 0)
        {
            try
            {
                if (type != self_type)
                {
                    py::pyobj_handle self{type->tp_alloc(type, 0)};
                    if (!self)
                    {
                        return nullptr;
                    }

                    std::construct_at(&reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj, nullptr);

                    auto obj_impl = winrt::make_self<PyWinrtColorSpectrum>(self.get());

                    auto obj = py::make_py_obj<PyWinrtColorSpectrum>(obj_impl, type, self.get());
                    if (!obj)
                    {
                        return nullptr;
                    }

                    reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj = std::move(obj);

                    return self.detach();
                }

                winrt::Microsoft::UI::Xaml::Controls::Primitives::ColorSpectrum instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ColorSpectrum(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ColorSpectrum_get_Shape(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ColorSpectrum", L"Shape");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ColorSpectrum>().Shape();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ColorSpectrum_put_Shape(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ColorSpectrum", L"Shape");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::ColorSpectrumShape>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ColorSpectrum>().Shape(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ColorSpectrum_get_MinValue(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ColorSpectrum", L"MinValue");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ColorSpectrum>().MinValue();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ColorSpectrum_put_MinValue(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ColorSpectrum", L"MinValue");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<int32_t>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ColorSpectrum>().MinValue(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ColorSpectrum_get_MinSaturation(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ColorSpectrum", L"MinSaturation");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ColorSpectrum>().MinSaturation();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ColorSpectrum_put_MinSaturation(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ColorSpectrum", L"MinSaturation");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<int32_t>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ColorSpectrum>().MinSaturation(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ColorSpectrum_get_MinHue(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ColorSpectrum", L"MinHue");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ColorSpectrum>().MinHue();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ColorSpectrum_put_MinHue(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ColorSpectrum", L"MinHue");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<int32_t>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ColorSpectrum>().MinHue(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ColorSpectrum_get_MaxValue(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ColorSpectrum", L"MaxValue");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ColorSpectrum>().MaxValue();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ColorSpectrum_put_MaxValue(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ColorSpectrum", L"MaxValue");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<int32_t>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ColorSpectrum>().MaxValue(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ColorSpectrum_get_MaxSaturation(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ColorSpectrum", L"MaxSaturation");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ColorSpectrum>().MaxSaturation();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ColorSpectrum_put_MaxSaturation(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ColorSpectrum", L"MaxSaturation");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<int32_t>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ColorSpectrum>().MaxSaturation(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ColorSpectrum_get_MaxHue(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ColorSpectrum", L"MaxHue");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ColorSpectrum>().MaxHue();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ColorSpectrum_put_MaxHue(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ColorSpectrum", L"MaxHue");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<int32_t>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ColorSpectrum>().MaxHue(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ColorSpectrum_get_HsvColor(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ColorSpectrum", L"HsvColor");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ColorSpectrum>().HsvColor();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ColorSpectrum_put_HsvColor(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ColorSpectrum", L"HsvColor");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::Numerics::float4>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ColorSpectrum>().HsvColor(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ColorSpectrum_get_Components(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ColorSpectrum", L"Components");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ColorSpectrum>().Components();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ColorSpectrum_put_Components(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ColorSpectrum", L"Components");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::ColorSpectrumComponents>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ColorSpectrum>().Components(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ColorSpectrum_get_Color(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ColorSpectrum", L"Color");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ColorSpectrum>().Color();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ColorSpectrum_put_Color(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ColorSpectrum", L"Color");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Color>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ColorSpectrum>().Color(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ColorSpectrum_get_ColorProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ColorSpectrum", L"ColorProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::Primitives::ColorSpectrum::ColorProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ColorSpectrum_get_ComponentsProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ColorSpectrum", L"ComponentsProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::Primitives::ColorSpectrum::ComponentsProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ColorSpectrum_get_HsvColorProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ColorSpectrum", L"HsvColorProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::Primitives::ColorSpectrum::HsvColorProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ColorSpectrum_get_MaxHueProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ColorSpectrum", L"MaxHueProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::Primitives::ColorSpectrum::MaxHueProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ColorSpectrum_get_MaxSaturationProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ColorSpectrum", L"MaxSaturationProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::Primitives::ColorSpectrum::MaxSaturationProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ColorSpectrum_get_MaxValueProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ColorSpectrum", L"MaxValueProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::Primitives::ColorSpectrum::MaxValueProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ColorSpectrum_get_MinHueProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ColorSpectrum", L"MinHueProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::Primitives::ColorSpectrum::MinHueProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ColorSpectrum_get_MinSaturationProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ColorSpectrum", L"MinSaturationProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::Primitives::ColorSpectrum::MinSaturationProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ColorSpectrum_get_MinValueProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ColorSpectrum", L"MinValueProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::Primitives::ColorSpectrum::MinValueProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ColorSpectrum_get_ShapeProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ColorSpectrum", L"ShapeProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::Primitives::ColorSpectrum::ShapeProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ColorSpectrum_add_ColorChanged(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ColorSpectrum", L"ColorChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Xaml::Controls::Primitives::ColorSpectrum, winrt::Microsoft::UI::Xaml::Controls::ColorChangedEventArgs>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ColorSpectrum>().ColorChanged(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ColorSpectrum_remove_ColorChanged(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ColorSpectrum", L"ColorChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ColorSpectrum>().ColorChanged(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ColorSpectrum(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::Primitives::ColorSpectrum>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ColorSpectrum(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ColorSpectrum>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ColorSpectrum[] = {
        { "add_color_changed", reinterpret_cast<PyCFunction>(ColorSpectrum_add_ColorChanged), METH_O, nullptr },
        { "remove_color_changed", reinterpret_cast<PyCFunction>(ColorSpectrum_remove_ColorChanged), METH_O, nullptr },
        { "_assign_array_", _assign_array_ColorSpectrum, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ColorSpectrum), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_ColorSpectrum[] = {
        { "shape", reinterpret_cast<getter>(ColorSpectrum_get_Shape), reinterpret_cast<setter>(ColorSpectrum_put_Shape), nullptr, nullptr },
        { "min_value", reinterpret_cast<getter>(ColorSpectrum_get_MinValue), reinterpret_cast<setter>(ColorSpectrum_put_MinValue), nullptr, nullptr },
        { "min_saturation", reinterpret_cast<getter>(ColorSpectrum_get_MinSaturation), reinterpret_cast<setter>(ColorSpectrum_put_MinSaturation), nullptr, nullptr },
        { "min_hue", reinterpret_cast<getter>(ColorSpectrum_get_MinHue), reinterpret_cast<setter>(ColorSpectrum_put_MinHue), nullptr, nullptr },
        { "max_value", reinterpret_cast<getter>(ColorSpectrum_get_MaxValue), reinterpret_cast<setter>(ColorSpectrum_put_MaxValue), nullptr, nullptr },
        { "max_saturation", reinterpret_cast<getter>(ColorSpectrum_get_MaxSaturation), reinterpret_cast<setter>(ColorSpectrum_put_MaxSaturation), nullptr, nullptr },
        { "max_hue", reinterpret_cast<getter>(ColorSpectrum_get_MaxHue), reinterpret_cast<setter>(ColorSpectrum_put_MaxHue), nullptr, nullptr },
        { "hsv_color", reinterpret_cast<getter>(ColorSpectrum_get_HsvColor), reinterpret_cast<setter>(ColorSpectrum_put_HsvColor), nullptr, nullptr },
        { "components", reinterpret_cast<getter>(ColorSpectrum_get_Components), reinterpret_cast<setter>(ColorSpectrum_put_Components), nullptr, nullptr },
        { "color", reinterpret_cast<getter>(ColorSpectrum_get_Color), reinterpret_cast<setter>(ColorSpectrum_put_Color), nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_ColorSpectrum[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ColorSpectrum) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ColorSpectrum) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ColorSpectrum) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ColorSpectrum) },
        { }};

    static PyType_Spec type_spec_ColorSpectrum = {
        "winui2._winui2_microsoft_ui_xaml_controls_primitives.ColorSpectrum",
        sizeof(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_ColorSpectrum};

    static PyGetSetDef getset_ColorSpectrum_Static[] = {
        { "color_property", reinterpret_cast<getter>(ColorSpectrum_get_ColorProperty), nullptr, nullptr, nullptr },
        { "components_property", reinterpret_cast<getter>(ColorSpectrum_get_ComponentsProperty), nullptr, nullptr, nullptr },
        { "hsv_color_property", reinterpret_cast<getter>(ColorSpectrum_get_HsvColorProperty), nullptr, nullptr, nullptr },
        { "max_hue_property", reinterpret_cast<getter>(ColorSpectrum_get_MaxHueProperty), nullptr, nullptr, nullptr },
        { "max_saturation_property", reinterpret_cast<getter>(ColorSpectrum_get_MaxSaturationProperty), nullptr, nullptr, nullptr },
        { "max_value_property", reinterpret_cast<getter>(ColorSpectrum_get_MaxValueProperty), nullptr, nullptr, nullptr },
        { "min_hue_property", reinterpret_cast<getter>(ColorSpectrum_get_MinHueProperty), nullptr, nullptr, nullptr },
        { "min_saturation_property", reinterpret_cast<getter>(ColorSpectrum_get_MinSaturationProperty), nullptr, nullptr, nullptr },
        { "min_value_property", reinterpret_cast<getter>(ColorSpectrum_get_MinValueProperty), nullptr, nullptr, nullptr },
        { "shape_property", reinterpret_cast<getter>(ColorSpectrum_get_ShapeProperty), nullptr, nullptr, nullptr },
        { }};

    static PyMethodDef methods_ColorSpectrum_Static[] = {
        { }};

    static PyType_Slot type_slots_ColorSpectrum_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_ColorSpectrum_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_ColorSpectrum_Static) },
        { }
    };

    static PyType_Spec type_spec_ColorSpectrum_Static = {
        "winui2._winui2_microsoft_ui_xaml_controls_primitives.ColorSpectrum_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_ColorSpectrum_Static};

    // ----- ColumnMajorUniformToLargestGridLayout class --------------------

    struct PyWinrtColumnMajorUniformToLargestGridLayout;
    using BasePyWinrtColumnMajorUniformToLargestGridLayout = winrt::Microsoft::UI::Xaml::Controls::Primitives::ColumnMajorUniformToLargestGridLayoutT<PyWinrtColumnMajorUniformToLargestGridLayout, py::IPywinrtObject>;

    struct PyWinrtColumnMajorUniformToLargestGridLayout : py::py_obj_ref, BasePyWinrtColumnMajorUniformToLargestGridLayout
    {
        PyWinrtColumnMajorUniformToLargestGridLayout(PyObject* py_obj) : py::py_obj_ref(py_obj), BasePyWinrtColumnMajorUniformToLargestGridLayout() {}

        int32_t __stdcall GetPyObject(PyObject*& obj) override
        {
            obj = py::py_obj_ref::get_py_obj();
            return 0;
        }

        int32_t __stdcall GetComposableInner(winrt::Windows::Foundation::IInspectable& inner) override
        {
            inner = m_inner;
            return winrt::impl::error_ok;
        }

        static void toggle_reference(PyWinrtColumnMajorUniformToLargestGridLayout* instance, bool is_last_reference)
        {
            py::py_obj_ref::toggle_reference(instance, is_last_reference);
        }

        int32_t query_interface_tearoff(winrt::guid const& id, void** result) const noexcept override
        {
            return py::py_obj_ref::query_interface_tearoff(id, result);
        }

        std::vector<winrt::guid> get_iids_tearoff() const noexcept override
        {
            return py::py_obj_ref::get_iids_tearoff();
        }
    };

    static PyObject* _new_ColumnMajorUniformToLargestGridLayout(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_GET_SIZE(args);

        auto self_type = get_python_type_for<winrt::Microsoft::UI::Xaml::Controls::Primitives::ColumnMajorUniformToLargestGridLayout>();
        if (!self_type)
        {
            return nullptr;
        }

        if (arg_count == 0)
        {
            try
            {
                if (type != self_type)
                {
                    py::pyobj_handle self{type->tp_alloc(type, 0)};
                    if (!self)
                    {
                        return nullptr;
                    }

                    std::construct_at(&reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj, nullptr);

                    auto obj_impl = winrt::make_self<PyWinrtColumnMajorUniformToLargestGridLayout>(self.get());

                    auto obj = py::make_py_obj<PyWinrtColumnMajorUniformToLargestGridLayout>(obj_impl, type, self.get());
                    if (!obj)
                    {
                        return nullptr;
                    }

                    reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj = std::move(obj);

                    return self.detach();
                }

                winrt::Microsoft::UI::Xaml::Controls::Primitives::ColumnMajorUniformToLargestGridLayout instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ColumnMajorUniformToLargestGridLayout(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ColumnMajorUniformToLargestGridLayout_get_RowSpacing(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ColumnMajorUniformToLargestGridLayout", L"RowSpacing");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ColumnMajorUniformToLargestGridLayout>().RowSpacing();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ColumnMajorUniformToLargestGridLayout_put_RowSpacing(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ColumnMajorUniformToLargestGridLayout", L"RowSpacing");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<double>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ColumnMajorUniformToLargestGridLayout>().RowSpacing(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ColumnMajorUniformToLargestGridLayout_get_MaxColumns(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ColumnMajorUniformToLargestGridLayout", L"MaxColumns");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ColumnMajorUniformToLargestGridLayout>().MaxColumns();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ColumnMajorUniformToLargestGridLayout_put_MaxColumns(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ColumnMajorUniformToLargestGridLayout", L"MaxColumns");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<int32_t>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ColumnMajorUniformToLargestGridLayout>().MaxColumns(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ColumnMajorUniformToLargestGridLayout_get_ColumnSpacing(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ColumnMajorUniformToLargestGridLayout", L"ColumnSpacing");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ColumnMajorUniformToLargestGridLayout>().ColumnSpacing();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ColumnMajorUniformToLargestGridLayout_put_ColumnSpacing(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ColumnMajorUniformToLargestGridLayout", L"ColumnSpacing");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<double>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ColumnMajorUniformToLargestGridLayout>().ColumnSpacing(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ColumnMajorUniformToLargestGridLayout_get_ColumnSpacingProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ColumnMajorUniformToLargestGridLayout", L"ColumnSpacingProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::Primitives::ColumnMajorUniformToLargestGridLayout::ColumnSpacingProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ColumnMajorUniformToLargestGridLayout_get_MaxColumnsProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ColumnMajorUniformToLargestGridLayout", L"MaxColumnsProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::Primitives::ColumnMajorUniformToLargestGridLayout::MaxColumnsProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ColumnMajorUniformToLargestGridLayout_get_RowSpacingProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ColumnMajorUniformToLargestGridLayout", L"RowSpacingProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::Primitives::ColumnMajorUniformToLargestGridLayout::RowSpacingProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ColumnMajorUniformToLargestGridLayout(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::Primitives::ColumnMajorUniformToLargestGridLayout>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ColumnMajorUniformToLargestGridLayout(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ColumnMajorUniformToLargestGridLayout>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ColumnMajorUniformToLargestGridLayout[] = {
        { "_assign_array_", _assign_array_ColumnMajorUniformToLargestGridLayout, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ColumnMajorUniformToLargestGridLayout), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_ColumnMajorUniformToLargestGridLayout[] = {
        { "row_spacing", reinterpret_cast<getter>(ColumnMajorUniformToLargestGridLayout_get_RowSpacing), reinterpret_cast<setter>(ColumnMajorUniformToLargestGridLayout_put_RowSpacing), nullptr, nullptr },
        { "max_columns", reinterpret_cast<getter>(ColumnMajorUniformToLargestGridLayout_get_MaxColumns), reinterpret_cast<setter>(ColumnMajorUniformToLargestGridLayout_put_MaxColumns), nullptr, nullptr },
        { "column_spacing", reinterpret_cast<getter>(ColumnMajorUniformToLargestGridLayout_get_ColumnSpacing), reinterpret_cast<setter>(ColumnMajorUniformToLargestGridLayout_put_ColumnSpacing), nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_ColumnMajorUniformToLargestGridLayout[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ColumnMajorUniformToLargestGridLayout) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ColumnMajorUniformToLargestGridLayout) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ColumnMajorUniformToLargestGridLayout) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ColumnMajorUniformToLargestGridLayout) },
        { }};

    static PyType_Spec type_spec_ColumnMajorUniformToLargestGridLayout = {
        "winui2._winui2_microsoft_ui_xaml_controls_primitives.ColumnMajorUniformToLargestGridLayout",
        sizeof(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_ColumnMajorUniformToLargestGridLayout};

    static PyGetSetDef getset_ColumnMajorUniformToLargestGridLayout_Static[] = {
        { "column_spacing_property", reinterpret_cast<getter>(ColumnMajorUniformToLargestGridLayout_get_ColumnSpacingProperty), nullptr, nullptr, nullptr },
        { "max_columns_property", reinterpret_cast<getter>(ColumnMajorUniformToLargestGridLayout_get_MaxColumnsProperty), nullptr, nullptr, nullptr },
        { "row_spacing_property", reinterpret_cast<getter>(ColumnMajorUniformToLargestGridLayout_get_RowSpacingProperty), nullptr, nullptr, nullptr },
        { }};

    static PyMethodDef methods_ColumnMajorUniformToLargestGridLayout_Static[] = {
        { }};

    static PyType_Slot type_slots_ColumnMajorUniformToLargestGridLayout_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_ColumnMajorUniformToLargestGridLayout_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_ColumnMajorUniformToLargestGridLayout_Static) },
        { }
    };

    static PyType_Spec type_spec_ColumnMajorUniformToLargestGridLayout_Static = {
        "winui2._winui2_microsoft_ui_xaml_controls_primitives.ColumnMajorUniformToLargestGridLayout_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_ColumnMajorUniformToLargestGridLayout_Static};

    // ----- ComboBoxHelper class --------------------

    static PyObject* _new_ComboBoxHelper(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Xaml::Controls::Primitives::ComboBoxHelper>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Xaml::Controls::Primitives::ComboBoxHelper>::type_name);
        return nullptr;
    }

    static void _dealloc_ComboBoxHelper(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ComboBoxHelper* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ComboBoxHelper_GetKeepInteriorCornersSquare(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ComboBoxHelper", L"GetKeepInteriorCornersSquare", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::ComboBox>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Microsoft::UI::Xaml::Controls::Primitives::ComboBoxHelper::GetKeepInteriorCornersSquare(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ComboBoxHelper_SetKeepInteriorCornersSquare(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ComboBoxHelper", L"SetKeepInteriorCornersSquare", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::ComboBox>(args, 0);
                auto param1 = py::convert_to<bool>(args, 1);

                {
                    auto _gil = release_gil();
                    winrt::Microsoft::UI::Xaml::Controls::Primitives::ComboBoxHelper::SetKeepInteriorCornersSquare(param0, param1);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ComboBoxHelper_get_KeepInteriorCornersSquareProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ComboBoxHelper", L"KeepInteriorCornersSquareProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::Primitives::ComboBoxHelper::KeepInteriorCornersSquareProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ComboBoxHelper(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::Primitives::ComboBoxHelper>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ComboBoxHelper(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ComboBoxHelper>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ComboBoxHelper[] = {
        { "_assign_array_", _assign_array_ComboBoxHelper, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ComboBoxHelper), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_ComboBoxHelper[] = {
        { }};

    static PyType_Slot _type_slots_ComboBoxHelper[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ComboBoxHelper) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ComboBoxHelper) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ComboBoxHelper) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ComboBoxHelper) },
        { }};

    static PyType_Spec type_spec_ComboBoxHelper = {
        "winui2._winui2_microsoft_ui_xaml_controls_primitives.ComboBoxHelper",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ComboBoxHelper),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ComboBoxHelper};

    static PyGetSetDef getset_ComboBoxHelper_Static[] = {
        { "keep_interior_corners_square_property", reinterpret_cast<getter>(ComboBoxHelper_get_KeepInteriorCornersSquareProperty), nullptr, nullptr, nullptr },
        { }};

    static PyMethodDef methods_ComboBoxHelper_Static[] = {
        { "get_keep_interior_corners_square", reinterpret_cast<PyCFunction>(ComboBoxHelper_GetKeepInteriorCornersSquare), METH_VARARGS, nullptr },
        { "set_keep_interior_corners_square", reinterpret_cast<PyCFunction>(ComboBoxHelper_SetKeepInteriorCornersSquare), METH_VARARGS, nullptr },
        { }};

    static PyType_Slot type_slots_ComboBoxHelper_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_ComboBoxHelper_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_ComboBoxHelper_Static) },
        { }
    };

    static PyType_Spec type_spec_ComboBoxHelper_Static = {
        "winui2._winui2_microsoft_ui_xaml_controls_primitives.ComboBoxHelper_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_ComboBoxHelper_Static};

    // ----- CommandBarFlyoutCommandBar class --------------------

    struct PyWinrtCommandBarFlyoutCommandBar;
    using BasePyWinrtCommandBarFlyoutCommandBar = winrt::Microsoft::UI::Xaml::Controls::Primitives::CommandBarFlyoutCommandBarT<PyWinrtCommandBarFlyoutCommandBar, py::IPywinrtObject>;

    struct PyWinrtCommandBarFlyoutCommandBar : py::py_obj_ref, BasePyWinrtCommandBarFlyoutCommandBar
    {
        PyWinrtCommandBarFlyoutCommandBar(PyObject* py_obj) : py::py_obj_ref(py_obj), BasePyWinrtCommandBarFlyoutCommandBar() {}

        int32_t __stdcall GetPyObject(PyObject*& obj) override
        {
            obj = py::py_obj_ref::get_py_obj();
            return 0;
        }

        int32_t __stdcall GetComposableInner(winrt::Windows::Foundation::IInspectable& inner) override
        {
            inner = m_inner;
            return winrt::impl::error_ok;
        }

        static void toggle_reference(PyWinrtCommandBarFlyoutCommandBar* instance, bool is_last_reference)
        {
            py::py_obj_ref::toggle_reference(instance, is_last_reference);
        }

        int32_t query_interface_tearoff(winrt::guid const& id, void** result) const noexcept override
        {
            return py::py_obj_ref::query_interface_tearoff(id, result);
        }

        std::vector<winrt::guid> get_iids_tearoff() const noexcept override
        {
            return py::py_obj_ref::get_iids_tearoff();
        }
    };

    static PyObject* _new_CommandBarFlyoutCommandBar(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_GET_SIZE(args);

        auto self_type = get_python_type_for<winrt::Microsoft::UI::Xaml::Controls::Primitives::CommandBarFlyoutCommandBar>();
        if (!self_type)
        {
            return nullptr;
        }

        if (arg_count == 0)
        {
            try
            {
                if (type != self_type)
                {
                    py::pyobj_handle self{type->tp_alloc(type, 0)};
                    if (!self)
                    {
                        return nullptr;
                    }

                    std::construct_at(&reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj, nullptr);

                    auto obj_impl = winrt::make_self<PyWinrtCommandBarFlyoutCommandBar>(self.get());

                    auto obj = py::make_py_obj<PyWinrtCommandBarFlyoutCommandBar>(obj_impl, type, self.get());
                    if (!obj)
                    {
                        return nullptr;
                    }

                    reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj = std::move(obj);

                    return self.detach();
                }

                winrt::Microsoft::UI::Xaml::Controls::Primitives::CommandBarFlyoutCommandBar instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_CommandBarFlyoutCommandBar(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CommandBarFlyoutCommandBar_get_FlyoutTemplateSettings(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.CommandBarFlyoutCommandBar", L"FlyoutTemplateSettings");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::CommandBarFlyoutCommandBar>().FlyoutTemplateSettings();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_CommandBarFlyoutCommandBar(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::Primitives::CommandBarFlyoutCommandBar>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CommandBarFlyoutCommandBar(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::Primitives::CommandBarFlyoutCommandBar>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CommandBarFlyoutCommandBar[] = {
        { "_assign_array_", _assign_array_CommandBarFlyoutCommandBar, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CommandBarFlyoutCommandBar), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_CommandBarFlyoutCommandBar[] = {
        { "flyout_template_settings", reinterpret_cast<getter>(CommandBarFlyoutCommandBar_get_FlyoutTemplateSettings), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_CommandBarFlyoutCommandBar[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_CommandBarFlyoutCommandBar) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CommandBarFlyoutCommandBar) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CommandBarFlyoutCommandBar) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CommandBarFlyoutCommandBar) },
        { }};

    static PyType_Spec type_spec_CommandBarFlyoutCommandBar = {
        "winui2._winui2_microsoft_ui_xaml_controls_primitives.CommandBarFlyoutCommandBar",
        sizeof(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_CommandBarFlyoutCommandBar};

    static PyGetSetDef getset_CommandBarFlyoutCommandBar_Static[] = {
        { }};

    static PyMethodDef methods_CommandBarFlyoutCommandBar_Static[] = {
        { }};

    static PyType_Slot type_slots_CommandBarFlyoutCommandBar_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_CommandBarFlyoutCommandBar_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_CommandBarFlyoutCommandBar_Static) },
        { }
    };

    static PyType_Spec type_spec_CommandBarFlyoutCommandBar_Static = {
        "winui2._winui2_microsoft_ui_xaml_controls_primitives.CommandBarFlyoutCommandBar_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_CommandBarFlyoutCommandBar_Static};

    // ----- CommandBarFlyoutCommandBarAutomationProperties class --------------------

    static PyObject* _new_CommandBarFlyoutCommandBarAutomationProperties(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Xaml::Controls::Primitives::CommandBarFlyoutCommandBarAutomationProperties>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Xaml::Controls::Primitives::CommandBarFlyoutCommandBarAutomationProperties>::type_name);
        return nullptr;
    }

    static PyObject* CommandBarFlyoutCommandBarAutomationProperties_GetControlType(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.Primitives.CommandBarFlyoutCommandBarAutomationProperties", L"GetControlType", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::UIElement>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Microsoft::UI::Xaml::Controls::Primitives::CommandBarFlyoutCommandBarAutomationProperties::GetControlType(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CommandBarFlyoutCommandBarAutomationProperties_SetControlType(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.Primitives.CommandBarFlyoutCommandBarAutomationProperties", L"SetControlType", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::UIElement>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Xaml::Automation::Peers::AutomationControlType>(args, 1);

                {
                    auto _gil = release_gil();
                    winrt::Microsoft::UI::Xaml::Controls::Primitives::CommandBarFlyoutCommandBarAutomationProperties::SetControlType(param0, param1);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CommandBarFlyoutCommandBarAutomationProperties_get_ControlTypeProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.CommandBarFlyoutCommandBarAutomationProperties", L"ControlTypeProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::Primitives::CommandBarFlyoutCommandBarAutomationProperties::ControlTypeProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CommandBarFlyoutCommandBarAutomationProperties[] = {
        { }};

    static PyGetSetDef _getset_CommandBarFlyoutCommandBarAutomationProperties[] = {
        { }};

    static PyType_Slot _type_slots_CommandBarFlyoutCommandBarAutomationProperties[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_CommandBarFlyoutCommandBarAutomationProperties) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CommandBarFlyoutCommandBarAutomationProperties) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CommandBarFlyoutCommandBarAutomationProperties) },
        { }};

    static PyType_Spec type_spec_CommandBarFlyoutCommandBarAutomationProperties = {
        "winui2._winui2_microsoft_ui_xaml_controls_primitives.CommandBarFlyoutCommandBarAutomationProperties",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CommandBarFlyoutCommandBarAutomationProperties};

    static PyGetSetDef getset_CommandBarFlyoutCommandBarAutomationProperties_Static[] = {
        { "control_type_property", reinterpret_cast<getter>(CommandBarFlyoutCommandBarAutomationProperties_get_ControlTypeProperty), nullptr, nullptr, nullptr },
        { }};

    static PyMethodDef methods_CommandBarFlyoutCommandBarAutomationProperties_Static[] = {
        { "get_control_type", reinterpret_cast<PyCFunction>(CommandBarFlyoutCommandBarAutomationProperties_GetControlType), METH_VARARGS, nullptr },
        { "set_control_type", reinterpret_cast<PyCFunction>(CommandBarFlyoutCommandBarAutomationProperties_SetControlType), METH_VARARGS, nullptr },
        { }};

    static PyType_Slot type_slots_CommandBarFlyoutCommandBarAutomationProperties_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_CommandBarFlyoutCommandBarAutomationProperties_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_CommandBarFlyoutCommandBarAutomationProperties_Static) },
        { }
    };

    static PyType_Spec type_spec_CommandBarFlyoutCommandBarAutomationProperties_Static = {
        "winui2._winui2_microsoft_ui_xaml_controls_primitives.CommandBarFlyoutCommandBarAutomationProperties_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_CommandBarFlyoutCommandBarAutomationProperties_Static};

    // ----- CommandBarFlyoutCommandBarTemplateSettings class --------------------

    static PyObject* _new_CommandBarFlyoutCommandBarTemplateSettings(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Xaml::Controls::Primitives::CommandBarFlyoutCommandBarTemplateSettings>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Xaml::Controls::Primitives::CommandBarFlyoutCommandBarTemplateSettings>::type_name);
        return nullptr;
    }

    static void _dealloc_CommandBarFlyoutCommandBarTemplateSettings(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::CommandBarFlyoutCommandBarTemplateSettings* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CommandBarFlyoutCommandBarTemplateSettings_get_CloseAnimationEndPosition(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::CommandBarFlyoutCommandBarTemplateSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.CommandBarFlyoutCommandBarTemplateSettings", L"CloseAnimationEndPosition");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.CloseAnimationEndPosition();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CommandBarFlyoutCommandBarTemplateSettings_get_ContentClipRect(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::CommandBarFlyoutCommandBarTemplateSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.CommandBarFlyoutCommandBarTemplateSettings", L"ContentClipRect");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ContentClipRect();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CommandBarFlyoutCommandBarTemplateSettings_get_CurrentWidth(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::CommandBarFlyoutCommandBarTemplateSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.CommandBarFlyoutCommandBarTemplateSettings", L"CurrentWidth");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.CurrentWidth();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CommandBarFlyoutCommandBarTemplateSettings_get_ExpandDownAnimationEndPosition(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::CommandBarFlyoutCommandBarTemplateSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.CommandBarFlyoutCommandBarTemplateSettings", L"ExpandDownAnimationEndPosition");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ExpandDownAnimationEndPosition();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CommandBarFlyoutCommandBarTemplateSettings_get_ExpandDownAnimationHoldPosition(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::CommandBarFlyoutCommandBarTemplateSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.CommandBarFlyoutCommandBarTemplateSettings", L"ExpandDownAnimationHoldPosition");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ExpandDownAnimationHoldPosition();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CommandBarFlyoutCommandBarTemplateSettings_get_ExpandDownAnimationStartPosition(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::CommandBarFlyoutCommandBarTemplateSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.CommandBarFlyoutCommandBarTemplateSettings", L"ExpandDownAnimationStartPosition");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ExpandDownAnimationStartPosition();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CommandBarFlyoutCommandBarTemplateSettings_get_ExpandDownOverflowVerticalPosition(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::CommandBarFlyoutCommandBarTemplateSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.CommandBarFlyoutCommandBarTemplateSettings", L"ExpandDownOverflowVerticalPosition");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ExpandDownOverflowVerticalPosition();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CommandBarFlyoutCommandBarTemplateSettings_get_ExpandUpAnimationEndPosition(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::CommandBarFlyoutCommandBarTemplateSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.CommandBarFlyoutCommandBarTemplateSettings", L"ExpandUpAnimationEndPosition");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ExpandUpAnimationEndPosition();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CommandBarFlyoutCommandBarTemplateSettings_get_ExpandUpAnimationHoldPosition(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::CommandBarFlyoutCommandBarTemplateSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.CommandBarFlyoutCommandBarTemplateSettings", L"ExpandUpAnimationHoldPosition");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ExpandUpAnimationHoldPosition();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CommandBarFlyoutCommandBarTemplateSettings_get_ExpandUpAnimationStartPosition(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::CommandBarFlyoutCommandBarTemplateSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.CommandBarFlyoutCommandBarTemplateSettings", L"ExpandUpAnimationStartPosition");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ExpandUpAnimationStartPosition();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CommandBarFlyoutCommandBarTemplateSettings_get_ExpandUpOverflowVerticalPosition(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::CommandBarFlyoutCommandBarTemplateSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.CommandBarFlyoutCommandBarTemplateSettings", L"ExpandUpOverflowVerticalPosition");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ExpandUpOverflowVerticalPosition();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CommandBarFlyoutCommandBarTemplateSettings_get_ExpandedWidth(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::CommandBarFlyoutCommandBarTemplateSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.CommandBarFlyoutCommandBarTemplateSettings", L"ExpandedWidth");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ExpandedWidth();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CommandBarFlyoutCommandBarTemplateSettings_get_OpenAnimationEndPosition(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::CommandBarFlyoutCommandBarTemplateSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.CommandBarFlyoutCommandBarTemplateSettings", L"OpenAnimationEndPosition");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.OpenAnimationEndPosition();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CommandBarFlyoutCommandBarTemplateSettings_get_OpenAnimationStartPosition(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::CommandBarFlyoutCommandBarTemplateSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.CommandBarFlyoutCommandBarTemplateSettings", L"OpenAnimationStartPosition");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.OpenAnimationStartPosition();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CommandBarFlyoutCommandBarTemplateSettings_get_OverflowContentClipRect(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::CommandBarFlyoutCommandBarTemplateSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.CommandBarFlyoutCommandBarTemplateSettings", L"OverflowContentClipRect");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.OverflowContentClipRect();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CommandBarFlyoutCommandBarTemplateSettings_get_WidthExpansionAnimationEndPosition(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::CommandBarFlyoutCommandBarTemplateSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.CommandBarFlyoutCommandBarTemplateSettings", L"WidthExpansionAnimationEndPosition");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.WidthExpansionAnimationEndPosition();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CommandBarFlyoutCommandBarTemplateSettings_get_WidthExpansionAnimationStartPosition(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::CommandBarFlyoutCommandBarTemplateSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.CommandBarFlyoutCommandBarTemplateSettings", L"WidthExpansionAnimationStartPosition");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.WidthExpansionAnimationStartPosition();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CommandBarFlyoutCommandBarTemplateSettings_get_WidthExpansionDelta(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::CommandBarFlyoutCommandBarTemplateSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.CommandBarFlyoutCommandBarTemplateSettings", L"WidthExpansionDelta");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.WidthExpansionDelta();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CommandBarFlyoutCommandBarTemplateSettings_get_WidthExpansionMoreButtonAnimationEndPosition(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::CommandBarFlyoutCommandBarTemplateSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.CommandBarFlyoutCommandBarTemplateSettings", L"WidthExpansionMoreButtonAnimationEndPosition");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.WidthExpansionMoreButtonAnimationEndPosition();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CommandBarFlyoutCommandBarTemplateSettings_get_WidthExpansionMoreButtonAnimationStartPosition(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::CommandBarFlyoutCommandBarTemplateSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.CommandBarFlyoutCommandBarTemplateSettings", L"WidthExpansionMoreButtonAnimationStartPosition");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.WidthExpansionMoreButtonAnimationStartPosition();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_CommandBarFlyoutCommandBarTemplateSettings(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::Primitives::CommandBarFlyoutCommandBarTemplateSettings>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CommandBarFlyoutCommandBarTemplateSettings(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::Primitives::CommandBarFlyoutCommandBarTemplateSettings>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CommandBarFlyoutCommandBarTemplateSettings[] = {
        { "_assign_array_", _assign_array_CommandBarFlyoutCommandBarTemplateSettings, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CommandBarFlyoutCommandBarTemplateSettings), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_CommandBarFlyoutCommandBarTemplateSettings[] = {
        { "close_animation_end_position", reinterpret_cast<getter>(CommandBarFlyoutCommandBarTemplateSettings_get_CloseAnimationEndPosition), nullptr, nullptr, nullptr },
        { "content_clip_rect", reinterpret_cast<getter>(CommandBarFlyoutCommandBarTemplateSettings_get_ContentClipRect), nullptr, nullptr, nullptr },
        { "current_width", reinterpret_cast<getter>(CommandBarFlyoutCommandBarTemplateSettings_get_CurrentWidth), nullptr, nullptr, nullptr },
        { "expand_down_animation_end_position", reinterpret_cast<getter>(CommandBarFlyoutCommandBarTemplateSettings_get_ExpandDownAnimationEndPosition), nullptr, nullptr, nullptr },
        { "expand_down_animation_hold_position", reinterpret_cast<getter>(CommandBarFlyoutCommandBarTemplateSettings_get_ExpandDownAnimationHoldPosition), nullptr, nullptr, nullptr },
        { "expand_down_animation_start_position", reinterpret_cast<getter>(CommandBarFlyoutCommandBarTemplateSettings_get_ExpandDownAnimationStartPosition), nullptr, nullptr, nullptr },
        { "expand_down_overflow_vertical_position", reinterpret_cast<getter>(CommandBarFlyoutCommandBarTemplateSettings_get_ExpandDownOverflowVerticalPosition), nullptr, nullptr, nullptr },
        { "expand_up_animation_end_position", reinterpret_cast<getter>(CommandBarFlyoutCommandBarTemplateSettings_get_ExpandUpAnimationEndPosition), nullptr, nullptr, nullptr },
        { "expand_up_animation_hold_position", reinterpret_cast<getter>(CommandBarFlyoutCommandBarTemplateSettings_get_ExpandUpAnimationHoldPosition), nullptr, nullptr, nullptr },
        { "expand_up_animation_start_position", reinterpret_cast<getter>(CommandBarFlyoutCommandBarTemplateSettings_get_ExpandUpAnimationStartPosition), nullptr, nullptr, nullptr },
        { "expand_up_overflow_vertical_position", reinterpret_cast<getter>(CommandBarFlyoutCommandBarTemplateSettings_get_ExpandUpOverflowVerticalPosition), nullptr, nullptr, nullptr },
        { "expanded_width", reinterpret_cast<getter>(CommandBarFlyoutCommandBarTemplateSettings_get_ExpandedWidth), nullptr, nullptr, nullptr },
        { "open_animation_end_position", reinterpret_cast<getter>(CommandBarFlyoutCommandBarTemplateSettings_get_OpenAnimationEndPosition), nullptr, nullptr, nullptr },
        { "open_animation_start_position", reinterpret_cast<getter>(CommandBarFlyoutCommandBarTemplateSettings_get_OpenAnimationStartPosition), nullptr, nullptr, nullptr },
        { "overflow_content_clip_rect", reinterpret_cast<getter>(CommandBarFlyoutCommandBarTemplateSettings_get_OverflowContentClipRect), nullptr, nullptr, nullptr },
        { "width_expansion_animation_end_position", reinterpret_cast<getter>(CommandBarFlyoutCommandBarTemplateSettings_get_WidthExpansionAnimationEndPosition), nullptr, nullptr, nullptr },
        { "width_expansion_animation_start_position", reinterpret_cast<getter>(CommandBarFlyoutCommandBarTemplateSettings_get_WidthExpansionAnimationStartPosition), nullptr, nullptr, nullptr },
        { "width_expansion_delta", reinterpret_cast<getter>(CommandBarFlyoutCommandBarTemplateSettings_get_WidthExpansionDelta), nullptr, nullptr, nullptr },
        { "width_expansion_more_button_animation_end_position", reinterpret_cast<getter>(CommandBarFlyoutCommandBarTemplateSettings_get_WidthExpansionMoreButtonAnimationEndPosition), nullptr, nullptr, nullptr },
        { "width_expansion_more_button_animation_start_position", reinterpret_cast<getter>(CommandBarFlyoutCommandBarTemplateSettings_get_WidthExpansionMoreButtonAnimationStartPosition), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_CommandBarFlyoutCommandBarTemplateSettings[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_CommandBarFlyoutCommandBarTemplateSettings) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CommandBarFlyoutCommandBarTemplateSettings) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CommandBarFlyoutCommandBarTemplateSettings) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CommandBarFlyoutCommandBarTemplateSettings) },
        { }};

    static PyType_Spec type_spec_CommandBarFlyoutCommandBarTemplateSettings = {
        "winui2._winui2_microsoft_ui_xaml_controls_primitives.CommandBarFlyoutCommandBarTemplateSettings",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::CommandBarFlyoutCommandBarTemplateSettings),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CommandBarFlyoutCommandBarTemplateSettings};

    // ----- CornerRadiusFilterConverter class --------------------

    static PyObject* _new_CornerRadiusFilterConverter(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_GET_SIZE(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Microsoft::UI::Xaml::Controls::Primitives::CornerRadiusFilterConverter instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_CornerRadiusFilterConverter(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::CornerRadiusFilterConverter* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CornerRadiusFilterConverter_Convert(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::CornerRadiusFilterConverter* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 4)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.Primitives.CornerRadiusFilterConverter", L"Convert", 4);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(4);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Xaml::Interop::TypeName>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 2);
                auto param3 = py::convert_to<winrt::hstring>(args, 3);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.Convert(param0, param1, param2, param3);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CornerRadiusFilterConverter_ConvertBack(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::CornerRadiusFilterConverter* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 4)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.Primitives.CornerRadiusFilterConverter", L"ConvertBack", 4);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(4);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Xaml::Interop::TypeName>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 2);
                auto param3 = py::convert_to<winrt::hstring>(args, 3);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.ConvertBack(param0, param1, param2, param3);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CornerRadiusFilterConverter_get_Scale(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::CornerRadiusFilterConverter* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.CornerRadiusFilterConverter", L"Scale");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Scale();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CornerRadiusFilterConverter_put_Scale(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::CornerRadiusFilterConverter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.CornerRadiusFilterConverter", L"Scale");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<double>(arg);

            {
                auto _gil = release_gil();
                self->obj.Scale(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CornerRadiusFilterConverter_get_Filter(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::CornerRadiusFilterConverter* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.CornerRadiusFilterConverter", L"Filter");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Filter();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CornerRadiusFilterConverter_put_Filter(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::CornerRadiusFilterConverter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.CornerRadiusFilterConverter", L"Filter");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::Primitives::CornerRadiusFilterKind>(arg);

            {
                auto _gil = release_gil();
                self->obj.Filter(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CornerRadiusFilterConverter_get_FilterProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.CornerRadiusFilterConverter", L"FilterProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::Primitives::CornerRadiusFilterConverter::FilterProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CornerRadiusFilterConverter_get_ScaleProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.CornerRadiusFilterConverter", L"ScaleProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::Primitives::CornerRadiusFilterConverter::ScaleProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_CornerRadiusFilterConverter(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::Primitives::CornerRadiusFilterConverter>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CornerRadiusFilterConverter(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::Primitives::CornerRadiusFilterConverter>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CornerRadiusFilterConverter[] = {
        { "convert", reinterpret_cast<PyCFunction>(CornerRadiusFilterConverter_Convert), METH_VARARGS, nullptr },
        { "convert_back", reinterpret_cast<PyCFunction>(CornerRadiusFilterConverter_ConvertBack), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_CornerRadiusFilterConverter, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CornerRadiusFilterConverter), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_CornerRadiusFilterConverter[] = {
        { "scale", reinterpret_cast<getter>(CornerRadiusFilterConverter_get_Scale), reinterpret_cast<setter>(CornerRadiusFilterConverter_put_Scale), nullptr, nullptr },
        { "filter", reinterpret_cast<getter>(CornerRadiusFilterConverter_get_Filter), reinterpret_cast<setter>(CornerRadiusFilterConverter_put_Filter), nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_CornerRadiusFilterConverter[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_CornerRadiusFilterConverter) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CornerRadiusFilterConverter) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CornerRadiusFilterConverter) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CornerRadiusFilterConverter) },
        { }};

    static PyType_Spec type_spec_CornerRadiusFilterConverter = {
        "winui2._winui2_microsoft_ui_xaml_controls_primitives.CornerRadiusFilterConverter",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::CornerRadiusFilterConverter),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CornerRadiusFilterConverter};

    static PyGetSetDef getset_CornerRadiusFilterConverter_Static[] = {
        { "filter_property", reinterpret_cast<getter>(CornerRadiusFilterConverter_get_FilterProperty), nullptr, nullptr, nullptr },
        { "scale_property", reinterpret_cast<getter>(CornerRadiusFilterConverter_get_ScaleProperty), nullptr, nullptr, nullptr },
        { }};

    static PyMethodDef methods_CornerRadiusFilterConverter_Static[] = {
        { }};

    static PyType_Slot type_slots_CornerRadiusFilterConverter_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_CornerRadiusFilterConverter_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_CornerRadiusFilterConverter_Static) },
        { }
    };

    static PyType_Spec type_spec_CornerRadiusFilterConverter_Static = {
        "winui2._winui2_microsoft_ui_xaml_controls_primitives.CornerRadiusFilterConverter_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_CornerRadiusFilterConverter_Static};

    // ----- CornerRadiusToThicknessConverter class --------------------

    static PyObject* _new_CornerRadiusToThicknessConverter(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_GET_SIZE(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Microsoft::UI::Xaml::Controls::Primitives::CornerRadiusToThicknessConverter instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_CornerRadiusToThicknessConverter(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::CornerRadiusToThicknessConverter* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CornerRadiusToThicknessConverter_Convert(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::CornerRadiusToThicknessConverter* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 4)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.Primitives.CornerRadiusToThicknessConverter", L"Convert", 4);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(4);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Xaml::Interop::TypeName>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 2);
                auto param3 = py::convert_to<winrt::hstring>(args, 3);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.Convert(param0, param1, param2, param3);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CornerRadiusToThicknessConverter_ConvertBack(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::CornerRadiusToThicknessConverter* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 4)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.Primitives.CornerRadiusToThicknessConverter", L"ConvertBack", 4);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(4);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Xaml::Interop::TypeName>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 2);
                auto param3 = py::convert_to<winrt::hstring>(args, 3);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.ConvertBack(param0, param1, param2, param3);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CornerRadiusToThicknessConverter_get_Multiplier(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::CornerRadiusToThicknessConverter* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.CornerRadiusToThicknessConverter", L"Multiplier");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Multiplier();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CornerRadiusToThicknessConverter_put_Multiplier(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::CornerRadiusToThicknessConverter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.CornerRadiusToThicknessConverter", L"Multiplier");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<double>(arg);

            {
                auto _gil = release_gil();
                self->obj.Multiplier(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CornerRadiusToThicknessConverter_get_ConversionKind(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::CornerRadiusToThicknessConverter* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.CornerRadiusToThicknessConverter", L"ConversionKind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ConversionKind();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CornerRadiusToThicknessConverter_put_ConversionKind(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::CornerRadiusToThicknessConverter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.CornerRadiusToThicknessConverter", L"ConversionKind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::Primitives::CornerRadiusToThicknessConverterKind>(arg);

            {
                auto _gil = release_gil();
                self->obj.ConversionKind(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CornerRadiusToThicknessConverter_get_ConversionKindProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.CornerRadiusToThicknessConverter", L"ConversionKindProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::Primitives::CornerRadiusToThicknessConverter::ConversionKindProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CornerRadiusToThicknessConverter_get_MultiplierProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.CornerRadiusToThicknessConverter", L"MultiplierProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::Primitives::CornerRadiusToThicknessConverter::MultiplierProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_CornerRadiusToThicknessConverter(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::Primitives::CornerRadiusToThicknessConverter>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CornerRadiusToThicknessConverter(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::Primitives::CornerRadiusToThicknessConverter>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CornerRadiusToThicknessConverter[] = {
        { "convert", reinterpret_cast<PyCFunction>(CornerRadiusToThicknessConverter_Convert), METH_VARARGS, nullptr },
        { "convert_back", reinterpret_cast<PyCFunction>(CornerRadiusToThicknessConverter_ConvertBack), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_CornerRadiusToThicknessConverter, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CornerRadiusToThicknessConverter), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_CornerRadiusToThicknessConverter[] = {
        { "multiplier", reinterpret_cast<getter>(CornerRadiusToThicknessConverter_get_Multiplier), reinterpret_cast<setter>(CornerRadiusToThicknessConverter_put_Multiplier), nullptr, nullptr },
        { "conversion_kind", reinterpret_cast<getter>(CornerRadiusToThicknessConverter_get_ConversionKind), reinterpret_cast<setter>(CornerRadiusToThicknessConverter_put_ConversionKind), nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_CornerRadiusToThicknessConverter[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_CornerRadiusToThicknessConverter) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CornerRadiusToThicknessConverter) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CornerRadiusToThicknessConverter) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CornerRadiusToThicknessConverter) },
        { }};

    static PyType_Spec type_spec_CornerRadiusToThicknessConverter = {
        "winui2._winui2_microsoft_ui_xaml_controls_primitives.CornerRadiusToThicknessConverter",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::CornerRadiusToThicknessConverter),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CornerRadiusToThicknessConverter};

    static PyGetSetDef getset_CornerRadiusToThicknessConverter_Static[] = {
        { "conversion_kind_property", reinterpret_cast<getter>(CornerRadiusToThicknessConverter_get_ConversionKindProperty), nullptr, nullptr, nullptr },
        { "multiplier_property", reinterpret_cast<getter>(CornerRadiusToThicknessConverter_get_MultiplierProperty), nullptr, nullptr, nullptr },
        { }};

    static PyMethodDef methods_CornerRadiusToThicknessConverter_Static[] = {
        { }};

    static PyType_Slot type_slots_CornerRadiusToThicknessConverter_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_CornerRadiusToThicknessConverter_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_CornerRadiusToThicknessConverter_Static) },
        { }
    };

    static PyType_Spec type_spec_CornerRadiusToThicknessConverter_Static = {
        "winui2._winui2_microsoft_ui_xaml_controls_primitives.CornerRadiusToThicknessConverter_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_CornerRadiusToThicknessConverter_Static};

    // ----- InfoBarPanel class --------------------

    struct PyWinrtInfoBarPanel;
    using BasePyWinrtInfoBarPanel = winrt::Microsoft::UI::Xaml::Controls::Primitives::InfoBarPanelT<PyWinrtInfoBarPanel, py::IPywinrtObject>;

    struct PyWinrtInfoBarPanel : py::py_obj_ref, BasePyWinrtInfoBarPanel
    {
        PyWinrtInfoBarPanel(PyObject* py_obj) : py::py_obj_ref(py_obj), BasePyWinrtInfoBarPanel() {}

        int32_t __stdcall GetPyObject(PyObject*& obj) override
        {
            obj = py::py_obj_ref::get_py_obj();
            return 0;
        }

        int32_t __stdcall GetComposableInner(winrt::Windows::Foundation::IInspectable& inner) override
        {
            inner = m_inner;
            return winrt::impl::error_ok;
        }

        static void toggle_reference(PyWinrtInfoBarPanel* instance, bool is_last_reference)
        {
            py::py_obj_ref::toggle_reference(instance, is_last_reference);
        }

        int32_t query_interface_tearoff(winrt::guid const& id, void** result) const noexcept override
        {
            return py::py_obj_ref::query_interface_tearoff(id, result);
        }

        std::vector<winrt::guid> get_iids_tearoff() const noexcept override
        {
            return py::py_obj_ref::get_iids_tearoff();
        }
    };

    static PyObject* _new_InfoBarPanel(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_GET_SIZE(args);

        auto self_type = get_python_type_for<winrt::Microsoft::UI::Xaml::Controls::Primitives::InfoBarPanel>();
        if (!self_type)
        {
            return nullptr;
        }

        if (arg_count == 0)
        {
            try
            {
                if (type != self_type)
                {
                    py::pyobj_handle self{type->tp_alloc(type, 0)};
                    if (!self)
                    {
                        return nullptr;
                    }

                    std::construct_at(&reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj, nullptr);

                    auto obj_impl = winrt::make_self<PyWinrtInfoBarPanel>(self.get());

                    auto obj = py::make_py_obj<PyWinrtInfoBarPanel>(obj_impl, type, self.get());
                    if (!obj)
                    {
                        return nullptr;
                    }

                    reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj = std::move(obj);

                    return self.detach();
                }

                winrt::Microsoft::UI::Xaml::Controls::Primitives::InfoBarPanel instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_InfoBarPanel(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* InfoBarPanel_GetHorizontalOrientationMargin(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.Primitives.InfoBarPanel", L"GetHorizontalOrientationMargin", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::DependencyObject>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Microsoft::UI::Xaml::Controls::Primitives::InfoBarPanel::GetHorizontalOrientationMargin(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InfoBarPanel_GetVerticalOrientationMargin(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.Primitives.InfoBarPanel", L"GetVerticalOrientationMargin", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::DependencyObject>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Microsoft::UI::Xaml::Controls::Primitives::InfoBarPanel::GetVerticalOrientationMargin(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InfoBarPanel_SetHorizontalOrientationMargin(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.Primitives.InfoBarPanel", L"SetHorizontalOrientationMargin", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::DependencyObject>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Xaml::Thickness>(args, 1);

                {
                    auto _gil = release_gil();
                    winrt::Microsoft::UI::Xaml::Controls::Primitives::InfoBarPanel::SetHorizontalOrientationMargin(param0, param1);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InfoBarPanel_SetVerticalOrientationMargin(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.Primitives.InfoBarPanel", L"SetVerticalOrientationMargin", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::DependencyObject>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Xaml::Thickness>(args, 1);

                {
                    auto _gil = release_gil();
                    winrt::Microsoft::UI::Xaml::Controls::Primitives::InfoBarPanel::SetVerticalOrientationMargin(param0, param1);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InfoBarPanel_get_VerticalOrientationPadding(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.InfoBarPanel", L"VerticalOrientationPadding");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::InfoBarPanel>().VerticalOrientationPadding();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InfoBarPanel_put_VerticalOrientationPadding(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.InfoBarPanel", L"VerticalOrientationPadding");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Thickness>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::InfoBarPanel>().VerticalOrientationPadding(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InfoBarPanel_get_HorizontalOrientationPadding(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.InfoBarPanel", L"HorizontalOrientationPadding");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::InfoBarPanel>().HorizontalOrientationPadding();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InfoBarPanel_put_HorizontalOrientationPadding(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.InfoBarPanel", L"HorizontalOrientationPadding");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Thickness>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::InfoBarPanel>().HorizontalOrientationPadding(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InfoBarPanel_get_HorizontalOrientationMarginProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.InfoBarPanel", L"HorizontalOrientationMarginProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::Primitives::InfoBarPanel::HorizontalOrientationMarginProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InfoBarPanel_get_HorizontalOrientationPaddingProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.InfoBarPanel", L"HorizontalOrientationPaddingProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::Primitives::InfoBarPanel::HorizontalOrientationPaddingProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InfoBarPanel_get_VerticalOrientationMarginProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.InfoBarPanel", L"VerticalOrientationMarginProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::Primitives::InfoBarPanel::VerticalOrientationMarginProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InfoBarPanel_get_VerticalOrientationPaddingProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.InfoBarPanel", L"VerticalOrientationPaddingProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::Primitives::InfoBarPanel::VerticalOrientationPaddingProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_InfoBarPanel(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::Primitives::InfoBarPanel>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_InfoBarPanel(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::Primitives::InfoBarPanel>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_InfoBarPanel[] = {
        { "_assign_array_", _assign_array_InfoBarPanel, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_InfoBarPanel), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_InfoBarPanel[] = {
        { "vertical_orientation_padding", reinterpret_cast<getter>(InfoBarPanel_get_VerticalOrientationPadding), reinterpret_cast<setter>(InfoBarPanel_put_VerticalOrientationPadding), nullptr, nullptr },
        { "horizontal_orientation_padding", reinterpret_cast<getter>(InfoBarPanel_get_HorizontalOrientationPadding), reinterpret_cast<setter>(InfoBarPanel_put_HorizontalOrientationPadding), nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_InfoBarPanel[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_InfoBarPanel) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_InfoBarPanel) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_InfoBarPanel) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_InfoBarPanel) },
        { }};

    static PyType_Spec type_spec_InfoBarPanel = {
        "winui2._winui2_microsoft_ui_xaml_controls_primitives.InfoBarPanel",
        sizeof(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_InfoBarPanel};

    static PyGetSetDef getset_InfoBarPanel_Static[] = {
        { "horizontal_orientation_margin_property", reinterpret_cast<getter>(InfoBarPanel_get_HorizontalOrientationMarginProperty), nullptr, nullptr, nullptr },
        { "horizontal_orientation_padding_property", reinterpret_cast<getter>(InfoBarPanel_get_HorizontalOrientationPaddingProperty), nullptr, nullptr, nullptr },
        { "vertical_orientation_margin_property", reinterpret_cast<getter>(InfoBarPanel_get_VerticalOrientationMarginProperty), nullptr, nullptr, nullptr },
        { "vertical_orientation_padding_property", reinterpret_cast<getter>(InfoBarPanel_get_VerticalOrientationPaddingProperty), nullptr, nullptr, nullptr },
        { }};

    static PyMethodDef methods_InfoBarPanel_Static[] = {
        { "get_horizontal_orientation_margin", reinterpret_cast<PyCFunction>(InfoBarPanel_GetHorizontalOrientationMargin), METH_VARARGS, nullptr },
        { "get_vertical_orientation_margin", reinterpret_cast<PyCFunction>(InfoBarPanel_GetVerticalOrientationMargin), METH_VARARGS, nullptr },
        { "set_horizontal_orientation_margin", reinterpret_cast<PyCFunction>(InfoBarPanel_SetHorizontalOrientationMargin), METH_VARARGS, nullptr },
        { "set_vertical_orientation_margin", reinterpret_cast<PyCFunction>(InfoBarPanel_SetVerticalOrientationMargin), METH_VARARGS, nullptr },
        { }};

    static PyType_Slot type_slots_InfoBarPanel_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_InfoBarPanel_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_InfoBarPanel_Static) },
        { }
    };

    static PyType_Spec type_spec_InfoBarPanel_Static = {
        "winui2._winui2_microsoft_ui_xaml_controls_primitives.InfoBarPanel_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_InfoBarPanel_Static};

    // ----- MonochromaticOverlayPresenter class --------------------

    struct PyWinrtMonochromaticOverlayPresenter;
    using BasePyWinrtMonochromaticOverlayPresenter = winrt::Microsoft::UI::Xaml::Controls::Primitives::MonochromaticOverlayPresenterT<PyWinrtMonochromaticOverlayPresenter, py::IPywinrtObject>;

    struct PyWinrtMonochromaticOverlayPresenter : py::py_obj_ref, BasePyWinrtMonochromaticOverlayPresenter
    {
        PyWinrtMonochromaticOverlayPresenter(PyObject* py_obj) : py::py_obj_ref(py_obj), BasePyWinrtMonochromaticOverlayPresenter() {}

        int32_t __stdcall GetPyObject(PyObject*& obj) override
        {
            obj = py::py_obj_ref::get_py_obj();
            return 0;
        }

        int32_t __stdcall GetComposableInner(winrt::Windows::Foundation::IInspectable& inner) override
        {
            inner = m_inner;
            return winrt::impl::error_ok;
        }

        static void toggle_reference(PyWinrtMonochromaticOverlayPresenter* instance, bool is_last_reference)
        {
            py::py_obj_ref::toggle_reference(instance, is_last_reference);
        }

        int32_t query_interface_tearoff(winrt::guid const& id, void** result) const noexcept override
        {
            return py::py_obj_ref::query_interface_tearoff(id, result);
        }

        std::vector<winrt::guid> get_iids_tearoff() const noexcept override
        {
            return py::py_obj_ref::get_iids_tearoff();
        }
    };

    static PyObject* _new_MonochromaticOverlayPresenter(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_GET_SIZE(args);

        auto self_type = get_python_type_for<winrt::Microsoft::UI::Xaml::Controls::Primitives::MonochromaticOverlayPresenter>();
        if (!self_type)
        {
            return nullptr;
        }

        if (arg_count == 0)
        {
            try
            {
                if (type != self_type)
                {
                    py::pyobj_handle self{type->tp_alloc(type, 0)};
                    if (!self)
                    {
                        return nullptr;
                    }

                    std::construct_at(&reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj, nullptr);

                    auto obj_impl = winrt::make_self<PyWinrtMonochromaticOverlayPresenter>(self.get());

                    auto obj = py::make_py_obj<PyWinrtMonochromaticOverlayPresenter>(obj_impl, type, self.get());
                    if (!obj)
                    {
                        return nullptr;
                    }

                    reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj = std::move(obj);

                    return self.detach();
                }

                winrt::Microsoft::UI::Xaml::Controls::Primitives::MonochromaticOverlayPresenter instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_MonochromaticOverlayPresenter(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MonochromaticOverlayPresenter_get_SourceElement(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.MonochromaticOverlayPresenter", L"SourceElement");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::MonochromaticOverlayPresenter>().SourceElement();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MonochromaticOverlayPresenter_put_SourceElement(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.MonochromaticOverlayPresenter", L"SourceElement");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::UIElement>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::MonochromaticOverlayPresenter>().SourceElement(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MonochromaticOverlayPresenter_get_ReplacementColor(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.MonochromaticOverlayPresenter", L"ReplacementColor");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::MonochromaticOverlayPresenter>().ReplacementColor();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MonochromaticOverlayPresenter_put_ReplacementColor(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.MonochromaticOverlayPresenter", L"ReplacementColor");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Color>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::MonochromaticOverlayPresenter>().ReplacementColor(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MonochromaticOverlayPresenter_get_ReplacementColorProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.MonochromaticOverlayPresenter", L"ReplacementColorProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::Primitives::MonochromaticOverlayPresenter::ReplacementColorProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MonochromaticOverlayPresenter_get_SourceElementProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.MonochromaticOverlayPresenter", L"SourceElementProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::Primitives::MonochromaticOverlayPresenter::SourceElementProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MonochromaticOverlayPresenter(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::Primitives::MonochromaticOverlayPresenter>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MonochromaticOverlayPresenter(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::Primitives::MonochromaticOverlayPresenter>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MonochromaticOverlayPresenter[] = {
        { "_assign_array_", _assign_array_MonochromaticOverlayPresenter, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MonochromaticOverlayPresenter), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_MonochromaticOverlayPresenter[] = {
        { "source_element", reinterpret_cast<getter>(MonochromaticOverlayPresenter_get_SourceElement), reinterpret_cast<setter>(MonochromaticOverlayPresenter_put_SourceElement), nullptr, nullptr },
        { "replacement_color", reinterpret_cast<getter>(MonochromaticOverlayPresenter_get_ReplacementColor), reinterpret_cast<setter>(MonochromaticOverlayPresenter_put_ReplacementColor), nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_MonochromaticOverlayPresenter[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_MonochromaticOverlayPresenter) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MonochromaticOverlayPresenter) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MonochromaticOverlayPresenter) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MonochromaticOverlayPresenter) },
        { }};

    static PyType_Spec type_spec_MonochromaticOverlayPresenter = {
        "winui2._winui2_microsoft_ui_xaml_controls_primitives.MonochromaticOverlayPresenter",
        sizeof(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_MonochromaticOverlayPresenter};

    static PyGetSetDef getset_MonochromaticOverlayPresenter_Static[] = {
        { "replacement_color_property", reinterpret_cast<getter>(MonochromaticOverlayPresenter_get_ReplacementColorProperty), nullptr, nullptr, nullptr },
        { "source_element_property", reinterpret_cast<getter>(MonochromaticOverlayPresenter_get_SourceElementProperty), nullptr, nullptr, nullptr },
        { }};

    static PyMethodDef methods_MonochromaticOverlayPresenter_Static[] = {
        { }};

    static PyType_Slot type_slots_MonochromaticOverlayPresenter_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_MonochromaticOverlayPresenter_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_MonochromaticOverlayPresenter_Static) },
        { }
    };

    static PyType_Spec type_spec_MonochromaticOverlayPresenter_Static = {
        "winui2._winui2_microsoft_ui_xaml_controls_primitives.MonochromaticOverlayPresenter_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_MonochromaticOverlayPresenter_Static};

    // ----- NavigationViewItemPresenter class --------------------

    struct PyWinrtNavigationViewItemPresenter;
    using BasePyWinrtNavigationViewItemPresenter = winrt::Microsoft::UI::Xaml::Controls::Primitives::NavigationViewItemPresenterT<PyWinrtNavigationViewItemPresenter, py::IPywinrtObject>;

    struct PyWinrtNavigationViewItemPresenter : py::py_obj_ref, BasePyWinrtNavigationViewItemPresenter
    {
        PyWinrtNavigationViewItemPresenter(PyObject* py_obj) : py::py_obj_ref(py_obj), BasePyWinrtNavigationViewItemPresenter() {}

        int32_t __stdcall GetPyObject(PyObject*& obj) override
        {
            obj = py::py_obj_ref::get_py_obj();
            return 0;
        }

        int32_t __stdcall GetComposableInner(winrt::Windows::Foundation::IInspectable& inner) override
        {
            inner = m_inner;
            return winrt::impl::error_ok;
        }

        static void toggle_reference(PyWinrtNavigationViewItemPresenter* instance, bool is_last_reference)
        {
            py::py_obj_ref::toggle_reference(instance, is_last_reference);
        }

        int32_t query_interface_tearoff(winrt::guid const& id, void** result) const noexcept override
        {
            return py::py_obj_ref::query_interface_tearoff(id, result);
        }

        std::vector<winrt::guid> get_iids_tearoff() const noexcept override
        {
            return py::py_obj_ref::get_iids_tearoff();
        }
    };

    static PyObject* _new_NavigationViewItemPresenter(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_GET_SIZE(args);

        auto self_type = get_python_type_for<winrt::Microsoft::UI::Xaml::Controls::Primitives::NavigationViewItemPresenter>();
        if (!self_type)
        {
            return nullptr;
        }

        if (arg_count == 0)
        {
            try
            {
                if (type != self_type)
                {
                    py::pyobj_handle self{type->tp_alloc(type, 0)};
                    if (!self)
                    {
                        return nullptr;
                    }

                    std::construct_at(&reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj, nullptr);

                    auto obj_impl = winrt::make_self<PyWinrtNavigationViewItemPresenter>(self.get());

                    auto obj = py::make_py_obj<PyWinrtNavigationViewItemPresenter>(obj_impl, type, self.get());
                    if (!obj)
                    {
                        return nullptr;
                    }

                    reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj = std::move(obj);

                    return self.detach();
                }

                winrt::Microsoft::UI::Xaml::Controls::Primitives::NavigationViewItemPresenter instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_NavigationViewItemPresenter(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* NavigationViewItemPresenter_get_Icon(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.NavigationViewItemPresenter", L"Icon");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::NavigationViewItemPresenter>().Icon();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int NavigationViewItemPresenter_put_Icon(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.NavigationViewItemPresenter", L"Icon");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::IconElement>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::NavigationViewItemPresenter>().Icon(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* NavigationViewItemPresenter_get_TemplateSettings(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.NavigationViewItemPresenter", L"TemplateSettings");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::NavigationViewItemPresenter>().TemplateSettings();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NavigationViewItemPresenter_get_InfoBadge(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.NavigationViewItemPresenter", L"InfoBadge");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::NavigationViewItemPresenter>().InfoBadge();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int NavigationViewItemPresenter_put_InfoBadge(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.NavigationViewItemPresenter", L"InfoBadge");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::InfoBadge>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::NavigationViewItemPresenter>().InfoBadge(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* NavigationViewItemPresenter_get_IconProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.NavigationViewItemPresenter", L"IconProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::Primitives::NavigationViewItemPresenter::IconProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NavigationViewItemPresenter_get_TemplateSettingsProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.NavigationViewItemPresenter", L"TemplateSettingsProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::Primitives::NavigationViewItemPresenter::TemplateSettingsProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NavigationViewItemPresenter_get_InfoBadgeProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.NavigationViewItemPresenter", L"InfoBadgeProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::Primitives::NavigationViewItemPresenter::InfoBadgeProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_NavigationViewItemPresenter(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::Primitives::NavigationViewItemPresenter>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_NavigationViewItemPresenter(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::Primitives::NavigationViewItemPresenter>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_NavigationViewItemPresenter[] = {
        { "_assign_array_", _assign_array_NavigationViewItemPresenter, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_NavigationViewItemPresenter), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_NavigationViewItemPresenter[] = {
        { "icon", reinterpret_cast<getter>(NavigationViewItemPresenter_get_Icon), reinterpret_cast<setter>(NavigationViewItemPresenter_put_Icon), nullptr, nullptr },
        { "template_settings", reinterpret_cast<getter>(NavigationViewItemPresenter_get_TemplateSettings), nullptr, nullptr, nullptr },
        { "info_badge", reinterpret_cast<getter>(NavigationViewItemPresenter_get_InfoBadge), reinterpret_cast<setter>(NavigationViewItemPresenter_put_InfoBadge), nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_NavigationViewItemPresenter[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_NavigationViewItemPresenter) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_NavigationViewItemPresenter) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_NavigationViewItemPresenter) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_NavigationViewItemPresenter) },
        { }};

    static PyType_Spec type_spec_NavigationViewItemPresenter = {
        "winui2._winui2_microsoft_ui_xaml_controls_primitives.NavigationViewItemPresenter",
        sizeof(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_NavigationViewItemPresenter};

    static PyGetSetDef getset_NavigationViewItemPresenter_Static[] = {
        { "icon_property", reinterpret_cast<getter>(NavigationViewItemPresenter_get_IconProperty), nullptr, nullptr, nullptr },
        { "template_settings_property", reinterpret_cast<getter>(NavigationViewItemPresenter_get_TemplateSettingsProperty), nullptr, nullptr, nullptr },
        { "info_badge_property", reinterpret_cast<getter>(NavigationViewItemPresenter_get_InfoBadgeProperty), nullptr, nullptr, nullptr },
        { }};

    static PyMethodDef methods_NavigationViewItemPresenter_Static[] = {
        { }};

    static PyType_Slot type_slots_NavigationViewItemPresenter_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_NavigationViewItemPresenter_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_NavigationViewItemPresenter_Static) },
        { }
    };

    static PyType_Spec type_spec_NavigationViewItemPresenter_Static = {
        "winui2._winui2_microsoft_ui_xaml_controls_primitives.NavigationViewItemPresenter_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_NavigationViewItemPresenter_Static};

    // ----- NavigationViewItemPresenterTemplateSettings class --------------------

    struct PyWinrtNavigationViewItemPresenterTemplateSettings;
    using BasePyWinrtNavigationViewItemPresenterTemplateSettings = winrt::Microsoft::UI::Xaml::Controls::Primitives::NavigationViewItemPresenterTemplateSettingsT<PyWinrtNavigationViewItemPresenterTemplateSettings, py::IPywinrtObject>;

    struct PyWinrtNavigationViewItemPresenterTemplateSettings : py::py_obj_ref, BasePyWinrtNavigationViewItemPresenterTemplateSettings
    {
        PyWinrtNavigationViewItemPresenterTemplateSettings(PyObject* py_obj) : py::py_obj_ref(py_obj), BasePyWinrtNavigationViewItemPresenterTemplateSettings() {}

        int32_t __stdcall GetPyObject(PyObject*& obj) override
        {
            obj = py::py_obj_ref::get_py_obj();
            return 0;
        }

        int32_t __stdcall GetComposableInner(winrt::Windows::Foundation::IInspectable& inner) override
        {
            inner = m_inner;
            return winrt::impl::error_ok;
        }

        static void toggle_reference(PyWinrtNavigationViewItemPresenterTemplateSettings* instance, bool is_last_reference)
        {
            py::py_obj_ref::toggle_reference(instance, is_last_reference);
        }

        int32_t query_interface_tearoff(winrt::guid const& id, void** result) const noexcept override
        {
            return py::py_obj_ref::query_interface_tearoff(id, result);
        }

        std::vector<winrt::guid> get_iids_tearoff() const noexcept override
        {
            return py::py_obj_ref::get_iids_tearoff();
        }
    };

    static PyObject* _new_NavigationViewItemPresenterTemplateSettings(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_GET_SIZE(args);

        auto self_type = get_python_type_for<winrt::Microsoft::UI::Xaml::Controls::Primitives::NavigationViewItemPresenterTemplateSettings>();
        if (!self_type)
        {
            return nullptr;
        }

        if (arg_count == 0)
        {
            try
            {
                if (type != self_type)
                {
                    py::pyobj_handle self{type->tp_alloc(type, 0)};
                    if (!self)
                    {
                        return nullptr;
                    }

                    std::construct_at(&reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj, nullptr);

                    auto obj_impl = winrt::make_self<PyWinrtNavigationViewItemPresenterTemplateSettings>(self.get());

                    auto obj = py::make_py_obj<PyWinrtNavigationViewItemPresenterTemplateSettings>(obj_impl, type, self.get());
                    if (!obj)
                    {
                        return nullptr;
                    }

                    reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj = std::move(obj);

                    return self.detach();
                }

                winrt::Microsoft::UI::Xaml::Controls::Primitives::NavigationViewItemPresenterTemplateSettings instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_NavigationViewItemPresenterTemplateSettings(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* NavigationViewItemPresenterTemplateSettings_get_IconWidth(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.NavigationViewItemPresenterTemplateSettings", L"IconWidth");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::NavigationViewItemPresenterTemplateSettings>().IconWidth();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NavigationViewItemPresenterTemplateSettings_get_SmallerIconWidth(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.NavigationViewItemPresenterTemplateSettings", L"SmallerIconWidth");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::NavigationViewItemPresenterTemplateSettings>().SmallerIconWidth();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NavigationViewItemPresenterTemplateSettings_get_IconWidthProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.NavigationViewItemPresenterTemplateSettings", L"IconWidthProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::Primitives::NavigationViewItemPresenterTemplateSettings::IconWidthProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NavigationViewItemPresenterTemplateSettings_get_SmallerIconWidthProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.NavigationViewItemPresenterTemplateSettings", L"SmallerIconWidthProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::Primitives::NavigationViewItemPresenterTemplateSettings::SmallerIconWidthProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_NavigationViewItemPresenterTemplateSettings(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::Primitives::NavigationViewItemPresenterTemplateSettings>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_NavigationViewItemPresenterTemplateSettings(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::Primitives::NavigationViewItemPresenterTemplateSettings>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_NavigationViewItemPresenterTemplateSettings[] = {
        { "_assign_array_", _assign_array_NavigationViewItemPresenterTemplateSettings, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_NavigationViewItemPresenterTemplateSettings), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_NavigationViewItemPresenterTemplateSettings[] = {
        { "icon_width", reinterpret_cast<getter>(NavigationViewItemPresenterTemplateSettings_get_IconWidth), nullptr, nullptr, nullptr },
        { "smaller_icon_width", reinterpret_cast<getter>(NavigationViewItemPresenterTemplateSettings_get_SmallerIconWidth), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_NavigationViewItemPresenterTemplateSettings[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_NavigationViewItemPresenterTemplateSettings) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_NavigationViewItemPresenterTemplateSettings) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_NavigationViewItemPresenterTemplateSettings) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_NavigationViewItemPresenterTemplateSettings) },
        { }};

    static PyType_Spec type_spec_NavigationViewItemPresenterTemplateSettings = {
        "winui2._winui2_microsoft_ui_xaml_controls_primitives.NavigationViewItemPresenterTemplateSettings",
        sizeof(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_NavigationViewItemPresenterTemplateSettings};

    static PyGetSetDef getset_NavigationViewItemPresenterTemplateSettings_Static[] = {
        { "icon_width_property", reinterpret_cast<getter>(NavigationViewItemPresenterTemplateSettings_get_IconWidthProperty), nullptr, nullptr, nullptr },
        { "smaller_icon_width_property", reinterpret_cast<getter>(NavigationViewItemPresenterTemplateSettings_get_SmallerIconWidthProperty), nullptr, nullptr, nullptr },
        { }};

    static PyMethodDef methods_NavigationViewItemPresenterTemplateSettings_Static[] = {
        { }};

    static PyType_Slot type_slots_NavigationViewItemPresenterTemplateSettings_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_NavigationViewItemPresenterTemplateSettings_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_NavigationViewItemPresenterTemplateSettings_Static) },
        { }
    };

    static PyType_Spec type_spec_NavigationViewItemPresenterTemplateSettings_Static = {
        "winui2._winui2_microsoft_ui_xaml_controls_primitives.NavigationViewItemPresenterTemplateSettings_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_NavigationViewItemPresenterTemplateSettings_Static};

    // ----- TabViewListView class --------------------

    struct PyWinrtTabViewListView;
    using BasePyWinrtTabViewListView = winrt::Microsoft::UI::Xaml::Controls::Primitives::TabViewListViewT<PyWinrtTabViewListView, py::IPywinrtObject>;

    struct PyWinrtTabViewListView : py::py_obj_ref, BasePyWinrtTabViewListView
    {
        PyWinrtTabViewListView(PyObject* py_obj) : py::py_obj_ref(py_obj), BasePyWinrtTabViewListView() {}

        int32_t __stdcall GetPyObject(PyObject*& obj) override
        {
            obj = py::py_obj_ref::get_py_obj();
            return 0;
        }

        int32_t __stdcall GetComposableInner(winrt::Windows::Foundation::IInspectable& inner) override
        {
            inner = m_inner;
            return winrt::impl::error_ok;
        }

        static void toggle_reference(PyWinrtTabViewListView* instance, bool is_last_reference)
        {
            py::py_obj_ref::toggle_reference(instance, is_last_reference);
        }

        int32_t query_interface_tearoff(winrt::guid const& id, void** result) const noexcept override
        {
            return py::py_obj_ref::query_interface_tearoff(id, result);
        }

        std::vector<winrt::guid> get_iids_tearoff() const noexcept override
        {
            return py::py_obj_ref::get_iids_tearoff();
        }
    };

    static PyObject* _new_TabViewListView(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_GET_SIZE(args);

        auto self_type = get_python_type_for<winrt::Microsoft::UI::Xaml::Controls::Primitives::TabViewListView>();
        if (!self_type)
        {
            return nullptr;
        }

        if (arg_count == 0)
        {
            try
            {
                if (type != self_type)
                {
                    py::pyobj_handle self{type->tp_alloc(type, 0)};
                    if (!self)
                    {
                        return nullptr;
                    }

                    std::construct_at(&reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj, nullptr);

                    auto obj_impl = winrt::make_self<PyWinrtTabViewListView>(self.get());

                    auto obj = py::make_py_obj<PyWinrtTabViewListView>(obj_impl, type, self.get());
                    if (!obj)
                    {
                        return nullptr;
                    }

                    reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj = std::move(obj);

                    return self.detach();
                }

                winrt::Microsoft::UI::Xaml::Controls::Primitives::TabViewListView instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_TabViewListView(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_TabViewListView(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::Primitives::TabViewListView>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_TabViewListView(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::Primitives::TabViewListView>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_TabViewListView[] = {
        { "_assign_array_", _assign_array_TabViewListView, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_TabViewListView), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_TabViewListView[] = {
        { }};

    static PyType_Slot _type_slots_TabViewListView[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_TabViewListView) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_TabViewListView) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_TabViewListView) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_TabViewListView) },
        { }};

    static PyType_Spec type_spec_TabViewListView = {
        "winui2._winui2_microsoft_ui_xaml_controls_primitives.TabViewListView",
        sizeof(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_TabViewListView};

    static PyGetSetDef getset_TabViewListView_Static[] = {
        { }};

    static PyMethodDef methods_TabViewListView_Static[] = {
        { }};

    static PyType_Slot type_slots_TabViewListView_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_TabViewListView_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_TabViewListView_Static) },
        { }
    };

    static PyType_Spec type_spec_TabViewListView_Static = {
        "winui2._winui2_microsoft_ui_xaml_controls_primitives.TabViewListView_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_TabViewListView_Static};

    // ----- Microsoft.UI.Xaml.Controls.Primitives Initialization --------------------

    PyDoc_STRVAR(module_doc, "Microsoft.UI.Xaml.Controls.Primitives");

    static PyModuleDef module_def = {
        PyModuleDef_HEAD_INIT,
        "_winui2_microsoft_ui_xaml_controls_primitives",
        module_doc,
        0,
        nullptr,
        nullptr,
        nullptr,
        nullptr,
        nullptr};
} // py::cpp::Microsoft::UI::Xaml::Controls::Primitives

PyMODINIT_FUNC PyInit__winui2_microsoft_ui_xaml_controls_primitives(void) noexcept
{
    using namespace py::cpp::Microsoft::UI::Xaml::Controls::Primitives;

    if (py::import_winrt_runtime() == -1)
    {
        return nullptr;
    }

    py::pyobj_handle module{PyModule_Create(&module_def)};

    if (!module)
    {
        return nullptr;
    }

    auto inspectable_meta_type = py::get_inspectable_meta_type();
    if (!inspectable_meta_type)
    {
        return nullptr;
    }

    auto object_type = py::get_object_type();
    if (!object_type)
    {
        return nullptr;
    }

    py::pyobj_handle object_bases{PyTuple_Pack(1, object_type)};

    if (!object_bases)
    {
        return nullptr;
    }

    py::pyobj_handle windows_ui_xaml_controls_2_module{PyImport_ImportModule("winrt._winrt_windows_ui_xaml_controls_2")};
    if (!windows_ui_xaml_controls_2_module)
    {
        return nullptr;
    }

    py::pyobj_handle windows_ui_xaml_controls_Slider_type{PyObject_GetAttrString(windows_ui_xaml_controls_2_module.get(), "Slider")};
    if (!windows_ui_xaml_controls_Slider_type)
    {
        return nullptr;
    }

    py::pyobj_handle windows_ui_xaml_controls_ListView_type{PyObject_GetAttrString(windows_ui_xaml_controls_2_module.get(), "ListView")};
    if (!windows_ui_xaml_controls_ListView_type)
    {
        return nullptr;
    }

    py::pyobj_handle windows_ui_xaml_controls_module{PyImport_ImportModule("winrt._winrt_windows_ui_xaml_controls")};
    if (!windows_ui_xaml_controls_module)
    {
        return nullptr;
    }

    py::pyobj_handle windows_ui_xaml_controls_Control_type{PyObject_GetAttrString(windows_ui_xaml_controls_module.get(), "Control")};
    if (!windows_ui_xaml_controls_Control_type)
    {
        return nullptr;
    }

    py::pyobj_handle windows_ui_xaml_controls_CommandBar_type{PyObject_GetAttrString(windows_ui_xaml_controls_module.get(), "CommandBar")};
    if (!windows_ui_xaml_controls_CommandBar_type)
    {
        return nullptr;
    }

    py::pyobj_handle windows_ui_xaml_controls_Panel_type{PyObject_GetAttrString(windows_ui_xaml_controls_module.get(), "Panel")};
    if (!windows_ui_xaml_controls_Panel_type)
    {
        return nullptr;
    }

    py::pyobj_handle windows_ui_xaml_controls_Grid_type{PyObject_GetAttrString(windows_ui_xaml_controls_module.get(), "Grid")};
    if (!windows_ui_xaml_controls_Grid_type)
    {
        return nullptr;
    }

    py::pyobj_handle windows_ui_xaml_controls_ContentControl_type{PyObject_GetAttrString(windows_ui_xaml_controls_module.get(), "ContentControl")};
    if (!windows_ui_xaml_controls_ContentControl_type)
    {
        return nullptr;
    }

    py::pyobj_handle microsoft_ui_xaml_controls_module{PyImport_ImportModule("winui2._winui2_microsoft_ui_xaml_controls")};
    if (!microsoft_ui_xaml_controls_module)
    {
        return nullptr;
    }

    py::pyobj_handle microsoft_ui_xaml_controls_NonVirtualizingLayout_type{PyObject_GetAttrString(microsoft_ui_xaml_controls_module.get(), "NonVirtualizingLayout")};
    if (!microsoft_ui_xaml_controls_NonVirtualizingLayout_type)
    {
        return nullptr;
    }

    py::pyobj_handle windows_ui_xaml_module{PyImport_ImportModule("winrt._winrt_windows_ui_xaml")};
    if (!windows_ui_xaml_module)
    {
        return nullptr;
    }

    py::pyobj_handle windows_ui_xaml_DependencyObject_type{PyObject_GetAttrString(windows_ui_xaml_module.get(), "DependencyObject")};
    if (!windows_ui_xaml_DependencyObject_type)
    {
        return nullptr;
    }

    py::pyobj_handle AutoSuggestBoxHelper_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(inspectable_meta_type))};
    if (!AutoSuggestBoxHelper_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_AutoSuggestBoxHelper_Static{PyType_FromSpecWithBases(&type_spec_AutoSuggestBoxHelper_Static, AutoSuggestBoxHelper_Static_bases.get())};
    if (!type_AutoSuggestBoxHelper_Static)
    {
        return nullptr;
    }

    py::pytype_handle AutoSuggestBoxHelper_type{py::register_python_type(module.get(), &type_spec_AutoSuggestBoxHelper, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_AutoSuggestBoxHelper_Static.get()))};
    if (!AutoSuggestBoxHelper_type)
    {
        return nullptr;
    }

    py::pyobj_handle ColorPickerSlider_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(windows_ui_xaml_controls_Slider_type.get())))};
    if (!ColorPickerSlider_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_ColorPickerSlider_Static{PyType_FromSpecWithBases(&type_spec_ColorPickerSlider_Static, ColorPickerSlider_Static_bases.get())};
    if (!type_ColorPickerSlider_Static)
    {
        return nullptr;
    }

    py::pyobj_handle ColorPickerSlider_bases{PyTuple_Pack(1, windows_ui_xaml_controls_Slider_type.get())};
    if (!ColorPickerSlider_bases)
    {
        return nullptr;
    }

    py::pytype_handle ColorPickerSlider_type{py::register_python_type(module.get(), &type_spec_ColorPickerSlider, ColorPickerSlider_bases.get(), reinterpret_cast<PyTypeObject*>(type_ColorPickerSlider_Static.get()))};
    if (!ColorPickerSlider_type)
    {
        return nullptr;
    }

    py::pyobj_handle ColorSpectrum_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(windows_ui_xaml_controls_Control_type.get())))};
    if (!ColorSpectrum_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_ColorSpectrum_Static{PyType_FromSpecWithBases(&type_spec_ColorSpectrum_Static, ColorSpectrum_Static_bases.get())};
    if (!type_ColorSpectrum_Static)
    {
        return nullptr;
    }

    py::pyobj_handle ColorSpectrum_bases{PyTuple_Pack(1, windows_ui_xaml_controls_Control_type.get())};
    if (!ColorSpectrum_bases)
    {
        return nullptr;
    }

    py::pytype_handle ColorSpectrum_type{py::register_python_type(module.get(), &type_spec_ColorSpectrum, ColorSpectrum_bases.get(), reinterpret_cast<PyTypeObject*>(type_ColorSpectrum_Static.get()))};
    if (!ColorSpectrum_type)
    {
        return nullptr;
    }

    py::pyobj_handle ColumnMajorUniformToLargestGridLayout_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(microsoft_ui_xaml_controls_NonVirtualizingLayout_type.get())))};
    if (!ColumnMajorUniformToLargestGridLayout_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_ColumnMajorUniformToLargestGridLayout_Static{PyType_FromSpecWithBases(&type_spec_ColumnMajorUniformToLargestGridLayout_Static, ColumnMajorUniformToLargestGridLayout_Static_bases.get())};
    if (!type_ColumnMajorUniformToLargestGridLayout_Static)
    {
        return nullptr;
    }

    py::pyobj_handle ColumnMajorUniformToLargestGridLayout_bases{PyTuple_Pack(1, microsoft_ui_xaml_controls_NonVirtualizingLayout_type.get())};
    if (!ColumnMajorUniformToLargestGridLayout_bases)
    {
        return nullptr;
    }

    py::pytype_handle ColumnMajorUniformToLargestGridLayout_type{py::register_python_type(module.get(), &type_spec_ColumnMajorUniformToLargestGridLayout, ColumnMajorUniformToLargestGridLayout_bases.get(), reinterpret_cast<PyTypeObject*>(type_ColumnMajorUniformToLargestGridLayout_Static.get()))};
    if (!ColumnMajorUniformToLargestGridLayout_type)
    {
        return nullptr;
    }

    py::pyobj_handle ComboBoxHelper_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(inspectable_meta_type))};
    if (!ComboBoxHelper_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_ComboBoxHelper_Static{PyType_FromSpecWithBases(&type_spec_ComboBoxHelper_Static, ComboBoxHelper_Static_bases.get())};
    if (!type_ComboBoxHelper_Static)
    {
        return nullptr;
    }

    py::pytype_handle ComboBoxHelper_type{py::register_python_type(module.get(), &type_spec_ComboBoxHelper, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_ComboBoxHelper_Static.get()))};
    if (!ComboBoxHelper_type)
    {
        return nullptr;
    }

    py::pyobj_handle CommandBarFlyoutCommandBar_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(windows_ui_xaml_controls_CommandBar_type.get())))};
    if (!CommandBarFlyoutCommandBar_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_CommandBarFlyoutCommandBar_Static{PyType_FromSpecWithBases(&type_spec_CommandBarFlyoutCommandBar_Static, CommandBarFlyoutCommandBar_Static_bases.get())};
    if (!type_CommandBarFlyoutCommandBar_Static)
    {
        return nullptr;
    }

    py::pyobj_handle CommandBarFlyoutCommandBar_bases{PyTuple_Pack(1, windows_ui_xaml_controls_CommandBar_type.get())};
    if (!CommandBarFlyoutCommandBar_bases)
    {
        return nullptr;
    }

    py::pytype_handle CommandBarFlyoutCommandBar_type{py::register_python_type(module.get(), &type_spec_CommandBarFlyoutCommandBar, CommandBarFlyoutCommandBar_bases.get(), reinterpret_cast<PyTypeObject*>(type_CommandBarFlyoutCommandBar_Static.get()))};
    if (!CommandBarFlyoutCommandBar_type)
    {
        return nullptr;
    }

    py::pyobj_handle CommandBarFlyoutCommandBarAutomationProperties_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(inspectable_meta_type))};
    if (!CommandBarFlyoutCommandBarAutomationProperties_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_CommandBarFlyoutCommandBarAutomationProperties_Static{PyType_FromSpecWithBases(&type_spec_CommandBarFlyoutCommandBarAutomationProperties_Static, CommandBarFlyoutCommandBarAutomationProperties_Static_bases.get())};
    if (!type_CommandBarFlyoutCommandBarAutomationProperties_Static)
    {
        return nullptr;
    }

    py::pytype_handle CommandBarFlyoutCommandBarAutomationProperties_type{py::register_python_type(module.get(), &type_spec_CommandBarFlyoutCommandBarAutomationProperties, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_CommandBarFlyoutCommandBarAutomationProperties_Static.get()))};
    if (!CommandBarFlyoutCommandBarAutomationProperties_type)
    {
        return nullptr;
    }

    py::pyobj_handle CommandBarFlyoutCommandBarTemplateSettings_bases{PyTuple_Pack(1, windows_ui_xaml_DependencyObject_type.get())};
    if (!CommandBarFlyoutCommandBarTemplateSettings_bases)
    {
        return nullptr;
    }

    py::pytype_handle CommandBarFlyoutCommandBarTemplateSettings_type{py::register_python_type(module.get(), &type_spec_CommandBarFlyoutCommandBarTemplateSettings, CommandBarFlyoutCommandBarTemplateSettings_bases.get(), inspectable_meta_type)};
    if (!CommandBarFlyoutCommandBarTemplateSettings_type)
    {
        return nullptr;
    }

    py::pyobj_handle CornerRadiusFilterConverter_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(windows_ui_xaml_DependencyObject_type.get())))};
    if (!CornerRadiusFilterConverter_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_CornerRadiusFilterConverter_Static{PyType_FromSpecWithBases(&type_spec_CornerRadiusFilterConverter_Static, CornerRadiusFilterConverter_Static_bases.get())};
    if (!type_CornerRadiusFilterConverter_Static)
    {
        return nullptr;
    }

    py::pyobj_handle CornerRadiusFilterConverter_bases{PyTuple_Pack(1, windows_ui_xaml_DependencyObject_type.get())};
    if (!CornerRadiusFilterConverter_bases)
    {
        return nullptr;
    }

    py::pytype_handle CornerRadiusFilterConverter_type{py::register_python_type(module.get(), &type_spec_CornerRadiusFilterConverter, CornerRadiusFilterConverter_bases.get(), reinterpret_cast<PyTypeObject*>(type_CornerRadiusFilterConverter_Static.get()))};
    if (!CornerRadiusFilterConverter_type)
    {
        return nullptr;
    }

    py::pyobj_handle CornerRadiusToThicknessConverter_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(windows_ui_xaml_DependencyObject_type.get())))};
    if (!CornerRadiusToThicknessConverter_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_CornerRadiusToThicknessConverter_Static{PyType_FromSpecWithBases(&type_spec_CornerRadiusToThicknessConverter_Static, CornerRadiusToThicknessConverter_Static_bases.get())};
    if (!type_CornerRadiusToThicknessConverter_Static)
    {
        return nullptr;
    }

    py::pyobj_handle CornerRadiusToThicknessConverter_bases{PyTuple_Pack(1, windows_ui_xaml_DependencyObject_type.get())};
    if (!CornerRadiusToThicknessConverter_bases)
    {
        return nullptr;
    }

    py::pytype_handle CornerRadiusToThicknessConverter_type{py::register_python_type(module.get(), &type_spec_CornerRadiusToThicknessConverter, CornerRadiusToThicknessConverter_bases.get(), reinterpret_cast<PyTypeObject*>(type_CornerRadiusToThicknessConverter_Static.get()))};
    if (!CornerRadiusToThicknessConverter_type)
    {
        return nullptr;
    }

    py::pyobj_handle InfoBarPanel_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(windows_ui_xaml_controls_Panel_type.get())))};
    if (!InfoBarPanel_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_InfoBarPanel_Static{PyType_FromSpecWithBases(&type_spec_InfoBarPanel_Static, InfoBarPanel_Static_bases.get())};
    if (!type_InfoBarPanel_Static)
    {
        return nullptr;
    }

    py::pyobj_handle InfoBarPanel_bases{PyTuple_Pack(1, windows_ui_xaml_controls_Panel_type.get())};
    if (!InfoBarPanel_bases)
    {
        return nullptr;
    }

    py::pytype_handle InfoBarPanel_type{py::register_python_type(module.get(), &type_spec_InfoBarPanel, InfoBarPanel_bases.get(), reinterpret_cast<PyTypeObject*>(type_InfoBarPanel_Static.get()))};
    if (!InfoBarPanel_type)
    {
        return nullptr;
    }

    py::pyobj_handle MonochromaticOverlayPresenter_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(windows_ui_xaml_controls_Grid_type.get())))};
    if (!MonochromaticOverlayPresenter_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_MonochromaticOverlayPresenter_Static{PyType_FromSpecWithBases(&type_spec_MonochromaticOverlayPresenter_Static, MonochromaticOverlayPresenter_Static_bases.get())};
    if (!type_MonochromaticOverlayPresenter_Static)
    {
        return nullptr;
    }

    py::pyobj_handle MonochromaticOverlayPresenter_bases{PyTuple_Pack(1, windows_ui_xaml_controls_Grid_type.get())};
    if (!MonochromaticOverlayPresenter_bases)
    {
        return nullptr;
    }

    py::pytype_handle MonochromaticOverlayPresenter_type{py::register_python_type(module.get(), &type_spec_MonochromaticOverlayPresenter, MonochromaticOverlayPresenter_bases.get(), reinterpret_cast<PyTypeObject*>(type_MonochromaticOverlayPresenter_Static.get()))};
    if (!MonochromaticOverlayPresenter_type)
    {
        return nullptr;
    }

    py::pyobj_handle NavigationViewItemPresenter_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(windows_ui_xaml_controls_ContentControl_type.get())))};
    if (!NavigationViewItemPresenter_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_NavigationViewItemPresenter_Static{PyType_FromSpecWithBases(&type_spec_NavigationViewItemPresenter_Static, NavigationViewItemPresenter_Static_bases.get())};
    if (!type_NavigationViewItemPresenter_Static)
    {
        return nullptr;
    }

    py::pyobj_handle NavigationViewItemPresenter_bases{PyTuple_Pack(1, windows_ui_xaml_controls_ContentControl_type.get())};
    if (!NavigationViewItemPresenter_bases)
    {
        return nullptr;
    }

    py::pytype_handle NavigationViewItemPresenter_type{py::register_python_type(module.get(), &type_spec_NavigationViewItemPresenter, NavigationViewItemPresenter_bases.get(), reinterpret_cast<PyTypeObject*>(type_NavigationViewItemPresenter_Static.get()))};
    if (!NavigationViewItemPresenter_type)
    {
        return nullptr;
    }

    py::pyobj_handle NavigationViewItemPresenterTemplateSettings_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(windows_ui_xaml_DependencyObject_type.get())))};
    if (!NavigationViewItemPresenterTemplateSettings_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_NavigationViewItemPresenterTemplateSettings_Static{PyType_FromSpecWithBases(&type_spec_NavigationViewItemPresenterTemplateSettings_Static, NavigationViewItemPresenterTemplateSettings_Static_bases.get())};
    if (!type_NavigationViewItemPresenterTemplateSettings_Static)
    {
        return nullptr;
    }

    py::pyobj_handle NavigationViewItemPresenterTemplateSettings_bases{PyTuple_Pack(1, windows_ui_xaml_DependencyObject_type.get())};
    if (!NavigationViewItemPresenterTemplateSettings_bases)
    {
        return nullptr;
    }

    py::pytype_handle NavigationViewItemPresenterTemplateSettings_type{py::register_python_type(module.get(), &type_spec_NavigationViewItemPresenterTemplateSettings, NavigationViewItemPresenterTemplateSettings_bases.get(), reinterpret_cast<PyTypeObject*>(type_NavigationViewItemPresenterTemplateSettings_Static.get()))};
    if (!NavigationViewItemPresenterTemplateSettings_type)
    {
        return nullptr;
    }

    py::pyobj_handle TabViewListView_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(windows_ui_xaml_controls_ListView_type.get())))};
    if (!TabViewListView_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_TabViewListView_Static{PyType_FromSpecWithBases(&type_spec_TabViewListView_Static, TabViewListView_Static_bases.get())};
    if (!type_TabViewListView_Static)
    {
        return nullptr;
    }

    py::pyobj_handle TabViewListView_bases{PyTuple_Pack(1, windows_ui_xaml_controls_ListView_type.get())};
    if (!TabViewListView_bases)
    {
        return nullptr;
    }

    py::pytype_handle TabViewListView_type{py::register_python_type(module.get(), &type_spec_TabViewListView, TabViewListView_bases.get(), reinterpret_cast<PyTypeObject*>(type_TabViewListView_Static.get()))};
    if (!TabViewListView_type)
    {
        return nullptr;
    }


    return module.detach();
}
