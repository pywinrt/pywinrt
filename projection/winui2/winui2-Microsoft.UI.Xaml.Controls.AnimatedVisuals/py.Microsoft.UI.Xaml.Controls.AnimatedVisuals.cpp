// WARNING: Please don't edit this file. It was generated by Python/WinRT v3.0.0

#include "py.Microsoft.UI.Xaml.Controls.AnimatedVisuals.h"

namespace py::cpp::Microsoft::UI::Xaml::Controls::AnimatedVisuals
{
    // ----- AnimatedAcceptVisualSource class --------------------

    static PyObject* _new_AnimatedAcceptVisualSource(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_GET_SIZE(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Microsoft::UI::Xaml::Controls::AnimatedVisuals::AnimatedAcceptVisualSource instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_AnimatedAcceptVisualSource(py::wrapper::Microsoft::UI::Xaml::Controls::AnimatedVisuals::AnimatedAcceptVisualSource* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AnimatedAcceptVisualSource_SetColorProperty(py::wrapper::Microsoft::UI::Xaml::Controls::AnimatedVisuals::AnimatedAcceptVisualSource* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.AnimatedVisuals.AnimatedAcceptVisualSource", L"SetColorProperty", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Color>(args, 1);

                {
                    auto _gil = release_gil();
                    self->obj.SetColorProperty(param0, param1);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AnimatedAcceptVisualSource_TryCreateAnimatedVisual(py::wrapper::Microsoft::UI::Xaml::Controls::AnimatedVisuals::AnimatedAcceptVisualSource* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.AnimatedVisuals.AnimatedAcceptVisualSource", L"TryCreateAnimatedVisual", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Composition::Compositor>(args, 0);
                winrt::Windows::Foundation::IInspectable param1{};

                auto return_value = [&]()
                {
                    auto _gil = release_gil();
                    return self->obj.TryCreateAnimatedVisual(param0, param1);
                }();

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out1{ py::convert(param1) };
                if (!out1)
                {
                    return nullptr;
                }

                return PyTuple_Pack(2, out_return_value.get(), out1.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AnimatedAcceptVisualSource_get_Markers(py::wrapper::Microsoft::UI::Xaml::Controls::AnimatedVisuals::AnimatedAcceptVisualSource* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.AnimatedVisuals.AnimatedAcceptVisualSource", L"Markers");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Markers();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AnimatedAcceptVisualSource(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::AnimatedVisuals::AnimatedAcceptVisualSource>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AnimatedAcceptVisualSource(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::AnimatedVisuals::AnimatedAcceptVisualSource>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AnimatedAcceptVisualSource[] = {
        { "set_color_property", reinterpret_cast<PyCFunction>(AnimatedAcceptVisualSource_SetColorProperty), METH_VARARGS, nullptr },
        { "try_create_animated_visual", reinterpret_cast<PyCFunction>(AnimatedAcceptVisualSource_TryCreateAnimatedVisual), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_AnimatedAcceptVisualSource, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AnimatedAcceptVisualSource), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_AnimatedAcceptVisualSource[] = {
        { "markers", reinterpret_cast<getter>(AnimatedAcceptVisualSource_get_Markers), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_AnimatedAcceptVisualSource[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_AnimatedAcceptVisualSource) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AnimatedAcceptVisualSource) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AnimatedAcceptVisualSource) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AnimatedAcceptVisualSource) },
        { }};

    static PyType_Spec type_spec_AnimatedAcceptVisualSource = {
        "winui2._winui2_microsoft_ui_xaml_controls_animatedvisuals.AnimatedAcceptVisualSource",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Controls::AnimatedVisuals::AnimatedAcceptVisualSource),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AnimatedAcceptVisualSource};

    // ----- AnimatedBackVisualSource class --------------------

    static PyObject* _new_AnimatedBackVisualSource(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_GET_SIZE(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Microsoft::UI::Xaml::Controls::AnimatedVisuals::AnimatedBackVisualSource instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_AnimatedBackVisualSource(py::wrapper::Microsoft::UI::Xaml::Controls::AnimatedVisuals::AnimatedBackVisualSource* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AnimatedBackVisualSource_SetColorProperty(py::wrapper::Microsoft::UI::Xaml::Controls::AnimatedVisuals::AnimatedBackVisualSource* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.AnimatedVisuals.AnimatedBackVisualSource", L"SetColorProperty", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Color>(args, 1);

                {
                    auto _gil = release_gil();
                    self->obj.SetColorProperty(param0, param1);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AnimatedBackVisualSource_TryCreateAnimatedVisual(py::wrapper::Microsoft::UI::Xaml::Controls::AnimatedVisuals::AnimatedBackVisualSource* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.AnimatedVisuals.AnimatedBackVisualSource", L"TryCreateAnimatedVisual", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Composition::Compositor>(args, 0);
                winrt::Windows::Foundation::IInspectable param1{};

                auto return_value = [&]()
                {
                    auto _gil = release_gil();
                    return self->obj.TryCreateAnimatedVisual(param0, param1);
                }();

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out1{ py::convert(param1) };
                if (!out1)
                {
                    return nullptr;
                }

                return PyTuple_Pack(2, out_return_value.get(), out1.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AnimatedBackVisualSource_get_Markers(py::wrapper::Microsoft::UI::Xaml::Controls::AnimatedVisuals::AnimatedBackVisualSource* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.AnimatedVisuals.AnimatedBackVisualSource", L"Markers");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Markers();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AnimatedBackVisualSource(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::AnimatedVisuals::AnimatedBackVisualSource>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AnimatedBackVisualSource(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::AnimatedVisuals::AnimatedBackVisualSource>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AnimatedBackVisualSource[] = {
        { "set_color_property", reinterpret_cast<PyCFunction>(AnimatedBackVisualSource_SetColorProperty), METH_VARARGS, nullptr },
        { "try_create_animated_visual", reinterpret_cast<PyCFunction>(AnimatedBackVisualSource_TryCreateAnimatedVisual), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_AnimatedBackVisualSource, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AnimatedBackVisualSource), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_AnimatedBackVisualSource[] = {
        { "markers", reinterpret_cast<getter>(AnimatedBackVisualSource_get_Markers), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_AnimatedBackVisualSource[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_AnimatedBackVisualSource) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AnimatedBackVisualSource) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AnimatedBackVisualSource) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AnimatedBackVisualSource) },
        { }};

    static PyType_Spec type_spec_AnimatedBackVisualSource = {
        "winui2._winui2_microsoft_ui_xaml_controls_animatedvisuals.AnimatedBackVisualSource",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Controls::AnimatedVisuals::AnimatedBackVisualSource),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AnimatedBackVisualSource};

    // ----- AnimatedChevronDownSmallVisualSource class --------------------

    static PyObject* _new_AnimatedChevronDownSmallVisualSource(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_GET_SIZE(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Microsoft::UI::Xaml::Controls::AnimatedVisuals::AnimatedChevronDownSmallVisualSource instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_AnimatedChevronDownSmallVisualSource(py::wrapper::Microsoft::UI::Xaml::Controls::AnimatedVisuals::AnimatedChevronDownSmallVisualSource* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AnimatedChevronDownSmallVisualSource_SetColorProperty(py::wrapper::Microsoft::UI::Xaml::Controls::AnimatedVisuals::AnimatedChevronDownSmallVisualSource* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.AnimatedVisuals.AnimatedChevronDownSmallVisualSource", L"SetColorProperty", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Color>(args, 1);

                {
                    auto _gil = release_gil();
                    self->obj.SetColorProperty(param0, param1);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AnimatedChevronDownSmallVisualSource_TryCreateAnimatedVisual(py::wrapper::Microsoft::UI::Xaml::Controls::AnimatedVisuals::AnimatedChevronDownSmallVisualSource* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.AnimatedVisuals.AnimatedChevronDownSmallVisualSource", L"TryCreateAnimatedVisual", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Composition::Compositor>(args, 0);
                winrt::Windows::Foundation::IInspectable param1{};

                auto return_value = [&]()
                {
                    auto _gil = release_gil();
                    return self->obj.TryCreateAnimatedVisual(param0, param1);
                }();

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out1{ py::convert(param1) };
                if (!out1)
                {
                    return nullptr;
                }

                return PyTuple_Pack(2, out_return_value.get(), out1.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AnimatedChevronDownSmallVisualSource_get_Markers(py::wrapper::Microsoft::UI::Xaml::Controls::AnimatedVisuals::AnimatedChevronDownSmallVisualSource* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.AnimatedVisuals.AnimatedChevronDownSmallVisualSource", L"Markers");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Markers();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AnimatedChevronDownSmallVisualSource(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::AnimatedVisuals::AnimatedChevronDownSmallVisualSource>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AnimatedChevronDownSmallVisualSource(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::AnimatedVisuals::AnimatedChevronDownSmallVisualSource>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AnimatedChevronDownSmallVisualSource[] = {
        { "set_color_property", reinterpret_cast<PyCFunction>(AnimatedChevronDownSmallVisualSource_SetColorProperty), METH_VARARGS, nullptr },
        { "try_create_animated_visual", reinterpret_cast<PyCFunction>(AnimatedChevronDownSmallVisualSource_TryCreateAnimatedVisual), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_AnimatedChevronDownSmallVisualSource, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AnimatedChevronDownSmallVisualSource), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_AnimatedChevronDownSmallVisualSource[] = {
        { "markers", reinterpret_cast<getter>(AnimatedChevronDownSmallVisualSource_get_Markers), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_AnimatedChevronDownSmallVisualSource[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_AnimatedChevronDownSmallVisualSource) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AnimatedChevronDownSmallVisualSource) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AnimatedChevronDownSmallVisualSource) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AnimatedChevronDownSmallVisualSource) },
        { }};

    static PyType_Spec type_spec_AnimatedChevronDownSmallVisualSource = {
        "winui2._winui2_microsoft_ui_xaml_controls_animatedvisuals.AnimatedChevronDownSmallVisualSource",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Controls::AnimatedVisuals::AnimatedChevronDownSmallVisualSource),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AnimatedChevronDownSmallVisualSource};

    // ----- AnimatedChevronRightDownSmallVisualSource class --------------------

    static PyObject* _new_AnimatedChevronRightDownSmallVisualSource(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_GET_SIZE(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Microsoft::UI::Xaml::Controls::AnimatedVisuals::AnimatedChevronRightDownSmallVisualSource instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_AnimatedChevronRightDownSmallVisualSource(py::wrapper::Microsoft::UI::Xaml::Controls::AnimatedVisuals::AnimatedChevronRightDownSmallVisualSource* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AnimatedChevronRightDownSmallVisualSource_SetColorProperty(py::wrapper::Microsoft::UI::Xaml::Controls::AnimatedVisuals::AnimatedChevronRightDownSmallVisualSource* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.AnimatedVisuals.AnimatedChevronRightDownSmallVisualSource", L"SetColorProperty", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Color>(args, 1);

                {
                    auto _gil = release_gil();
                    self->obj.SetColorProperty(param0, param1);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AnimatedChevronRightDownSmallVisualSource_TryCreateAnimatedVisual(py::wrapper::Microsoft::UI::Xaml::Controls::AnimatedVisuals::AnimatedChevronRightDownSmallVisualSource* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.AnimatedVisuals.AnimatedChevronRightDownSmallVisualSource", L"TryCreateAnimatedVisual", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Composition::Compositor>(args, 0);
                winrt::Windows::Foundation::IInspectable param1{};

                auto return_value = [&]()
                {
                    auto _gil = release_gil();
                    return self->obj.TryCreateAnimatedVisual(param0, param1);
                }();

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out1{ py::convert(param1) };
                if (!out1)
                {
                    return nullptr;
                }

                return PyTuple_Pack(2, out_return_value.get(), out1.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AnimatedChevronRightDownSmallVisualSource_get_Markers(py::wrapper::Microsoft::UI::Xaml::Controls::AnimatedVisuals::AnimatedChevronRightDownSmallVisualSource* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.AnimatedVisuals.AnimatedChevronRightDownSmallVisualSource", L"Markers");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Markers();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AnimatedChevronRightDownSmallVisualSource(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::AnimatedVisuals::AnimatedChevronRightDownSmallVisualSource>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AnimatedChevronRightDownSmallVisualSource(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::AnimatedVisuals::AnimatedChevronRightDownSmallVisualSource>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AnimatedChevronRightDownSmallVisualSource[] = {
        { "set_color_property", reinterpret_cast<PyCFunction>(AnimatedChevronRightDownSmallVisualSource_SetColorProperty), METH_VARARGS, nullptr },
        { "try_create_animated_visual", reinterpret_cast<PyCFunction>(AnimatedChevronRightDownSmallVisualSource_TryCreateAnimatedVisual), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_AnimatedChevronRightDownSmallVisualSource, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AnimatedChevronRightDownSmallVisualSource), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_AnimatedChevronRightDownSmallVisualSource[] = {
        { "markers", reinterpret_cast<getter>(AnimatedChevronRightDownSmallVisualSource_get_Markers), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_AnimatedChevronRightDownSmallVisualSource[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_AnimatedChevronRightDownSmallVisualSource) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AnimatedChevronRightDownSmallVisualSource) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AnimatedChevronRightDownSmallVisualSource) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AnimatedChevronRightDownSmallVisualSource) },
        { }};

    static PyType_Spec type_spec_AnimatedChevronRightDownSmallVisualSource = {
        "winui2._winui2_microsoft_ui_xaml_controls_animatedvisuals.AnimatedChevronRightDownSmallVisualSource",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Controls::AnimatedVisuals::AnimatedChevronRightDownSmallVisualSource),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AnimatedChevronRightDownSmallVisualSource};

    // ----- AnimatedChevronUpDownSmallVisualSource class --------------------

    static PyObject* _new_AnimatedChevronUpDownSmallVisualSource(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_GET_SIZE(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Microsoft::UI::Xaml::Controls::AnimatedVisuals::AnimatedChevronUpDownSmallVisualSource instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_AnimatedChevronUpDownSmallVisualSource(py::wrapper::Microsoft::UI::Xaml::Controls::AnimatedVisuals::AnimatedChevronUpDownSmallVisualSource* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AnimatedChevronUpDownSmallVisualSource_SetColorProperty(py::wrapper::Microsoft::UI::Xaml::Controls::AnimatedVisuals::AnimatedChevronUpDownSmallVisualSource* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.AnimatedVisuals.AnimatedChevronUpDownSmallVisualSource", L"SetColorProperty", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Color>(args, 1);

                {
                    auto _gil = release_gil();
                    self->obj.SetColorProperty(param0, param1);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AnimatedChevronUpDownSmallVisualSource_TryCreateAnimatedVisual(py::wrapper::Microsoft::UI::Xaml::Controls::AnimatedVisuals::AnimatedChevronUpDownSmallVisualSource* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.AnimatedVisuals.AnimatedChevronUpDownSmallVisualSource", L"TryCreateAnimatedVisual", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Composition::Compositor>(args, 0);
                winrt::Windows::Foundation::IInspectable param1{};

                auto return_value = [&]()
                {
                    auto _gil = release_gil();
                    return self->obj.TryCreateAnimatedVisual(param0, param1);
                }();

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out1{ py::convert(param1) };
                if (!out1)
                {
                    return nullptr;
                }

                return PyTuple_Pack(2, out_return_value.get(), out1.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AnimatedChevronUpDownSmallVisualSource_get_Markers(py::wrapper::Microsoft::UI::Xaml::Controls::AnimatedVisuals::AnimatedChevronUpDownSmallVisualSource* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.AnimatedVisuals.AnimatedChevronUpDownSmallVisualSource", L"Markers");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Markers();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AnimatedChevronUpDownSmallVisualSource(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::AnimatedVisuals::AnimatedChevronUpDownSmallVisualSource>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AnimatedChevronUpDownSmallVisualSource(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::AnimatedVisuals::AnimatedChevronUpDownSmallVisualSource>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AnimatedChevronUpDownSmallVisualSource[] = {
        { "set_color_property", reinterpret_cast<PyCFunction>(AnimatedChevronUpDownSmallVisualSource_SetColorProperty), METH_VARARGS, nullptr },
        { "try_create_animated_visual", reinterpret_cast<PyCFunction>(AnimatedChevronUpDownSmallVisualSource_TryCreateAnimatedVisual), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_AnimatedChevronUpDownSmallVisualSource, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AnimatedChevronUpDownSmallVisualSource), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_AnimatedChevronUpDownSmallVisualSource[] = {
        { "markers", reinterpret_cast<getter>(AnimatedChevronUpDownSmallVisualSource_get_Markers), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_AnimatedChevronUpDownSmallVisualSource[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_AnimatedChevronUpDownSmallVisualSource) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AnimatedChevronUpDownSmallVisualSource) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AnimatedChevronUpDownSmallVisualSource) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AnimatedChevronUpDownSmallVisualSource) },
        { }};

    static PyType_Spec type_spec_AnimatedChevronUpDownSmallVisualSource = {
        "winui2._winui2_microsoft_ui_xaml_controls_animatedvisuals.AnimatedChevronUpDownSmallVisualSource",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Controls::AnimatedVisuals::AnimatedChevronUpDownSmallVisualSource),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AnimatedChevronUpDownSmallVisualSource};

    // ----- AnimatedFindVisualSource class --------------------

    static PyObject* _new_AnimatedFindVisualSource(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_GET_SIZE(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Microsoft::UI::Xaml::Controls::AnimatedVisuals::AnimatedFindVisualSource instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_AnimatedFindVisualSource(py::wrapper::Microsoft::UI::Xaml::Controls::AnimatedVisuals::AnimatedFindVisualSource* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AnimatedFindVisualSource_SetColorProperty(py::wrapper::Microsoft::UI::Xaml::Controls::AnimatedVisuals::AnimatedFindVisualSource* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.AnimatedVisuals.AnimatedFindVisualSource", L"SetColorProperty", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Color>(args, 1);

                {
                    auto _gil = release_gil();
                    self->obj.SetColorProperty(param0, param1);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AnimatedFindVisualSource_TryCreateAnimatedVisual(py::wrapper::Microsoft::UI::Xaml::Controls::AnimatedVisuals::AnimatedFindVisualSource* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.AnimatedVisuals.AnimatedFindVisualSource", L"TryCreateAnimatedVisual", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Composition::Compositor>(args, 0);
                winrt::Windows::Foundation::IInspectable param1{};

                auto return_value = [&]()
                {
                    auto _gil = release_gil();
                    return self->obj.TryCreateAnimatedVisual(param0, param1);
                }();

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out1{ py::convert(param1) };
                if (!out1)
                {
                    return nullptr;
                }

                return PyTuple_Pack(2, out_return_value.get(), out1.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AnimatedFindVisualSource_get_Markers(py::wrapper::Microsoft::UI::Xaml::Controls::AnimatedVisuals::AnimatedFindVisualSource* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.AnimatedVisuals.AnimatedFindVisualSource", L"Markers");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Markers();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AnimatedFindVisualSource(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::AnimatedVisuals::AnimatedFindVisualSource>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AnimatedFindVisualSource(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::AnimatedVisuals::AnimatedFindVisualSource>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AnimatedFindVisualSource[] = {
        { "set_color_property", reinterpret_cast<PyCFunction>(AnimatedFindVisualSource_SetColorProperty), METH_VARARGS, nullptr },
        { "try_create_animated_visual", reinterpret_cast<PyCFunction>(AnimatedFindVisualSource_TryCreateAnimatedVisual), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_AnimatedFindVisualSource, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AnimatedFindVisualSource), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_AnimatedFindVisualSource[] = {
        { "markers", reinterpret_cast<getter>(AnimatedFindVisualSource_get_Markers), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_AnimatedFindVisualSource[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_AnimatedFindVisualSource) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AnimatedFindVisualSource) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AnimatedFindVisualSource) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AnimatedFindVisualSource) },
        { }};

    static PyType_Spec type_spec_AnimatedFindVisualSource = {
        "winui2._winui2_microsoft_ui_xaml_controls_animatedvisuals.AnimatedFindVisualSource",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Controls::AnimatedVisuals::AnimatedFindVisualSource),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AnimatedFindVisualSource};

    // ----- AnimatedGlobalNavigationButtonVisualSource class --------------------

    static PyObject* _new_AnimatedGlobalNavigationButtonVisualSource(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_GET_SIZE(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Microsoft::UI::Xaml::Controls::AnimatedVisuals::AnimatedGlobalNavigationButtonVisualSource instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_AnimatedGlobalNavigationButtonVisualSource(py::wrapper::Microsoft::UI::Xaml::Controls::AnimatedVisuals::AnimatedGlobalNavigationButtonVisualSource* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AnimatedGlobalNavigationButtonVisualSource_SetColorProperty(py::wrapper::Microsoft::UI::Xaml::Controls::AnimatedVisuals::AnimatedGlobalNavigationButtonVisualSource* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.AnimatedVisuals.AnimatedGlobalNavigationButtonVisualSource", L"SetColorProperty", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Color>(args, 1);

                {
                    auto _gil = release_gil();
                    self->obj.SetColorProperty(param0, param1);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AnimatedGlobalNavigationButtonVisualSource_TryCreateAnimatedVisual(py::wrapper::Microsoft::UI::Xaml::Controls::AnimatedVisuals::AnimatedGlobalNavigationButtonVisualSource* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.AnimatedVisuals.AnimatedGlobalNavigationButtonVisualSource", L"TryCreateAnimatedVisual", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Composition::Compositor>(args, 0);
                winrt::Windows::Foundation::IInspectable param1{};

                auto return_value = [&]()
                {
                    auto _gil = release_gil();
                    return self->obj.TryCreateAnimatedVisual(param0, param1);
                }();

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out1{ py::convert(param1) };
                if (!out1)
                {
                    return nullptr;
                }

                return PyTuple_Pack(2, out_return_value.get(), out1.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AnimatedGlobalNavigationButtonVisualSource_get_Markers(py::wrapper::Microsoft::UI::Xaml::Controls::AnimatedVisuals::AnimatedGlobalNavigationButtonVisualSource* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.AnimatedVisuals.AnimatedGlobalNavigationButtonVisualSource", L"Markers");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Markers();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AnimatedGlobalNavigationButtonVisualSource(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::AnimatedVisuals::AnimatedGlobalNavigationButtonVisualSource>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AnimatedGlobalNavigationButtonVisualSource(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::AnimatedVisuals::AnimatedGlobalNavigationButtonVisualSource>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AnimatedGlobalNavigationButtonVisualSource[] = {
        { "set_color_property", reinterpret_cast<PyCFunction>(AnimatedGlobalNavigationButtonVisualSource_SetColorProperty), METH_VARARGS, nullptr },
        { "try_create_animated_visual", reinterpret_cast<PyCFunction>(AnimatedGlobalNavigationButtonVisualSource_TryCreateAnimatedVisual), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_AnimatedGlobalNavigationButtonVisualSource, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AnimatedGlobalNavigationButtonVisualSource), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_AnimatedGlobalNavigationButtonVisualSource[] = {
        { "markers", reinterpret_cast<getter>(AnimatedGlobalNavigationButtonVisualSource_get_Markers), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_AnimatedGlobalNavigationButtonVisualSource[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_AnimatedGlobalNavigationButtonVisualSource) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AnimatedGlobalNavigationButtonVisualSource) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AnimatedGlobalNavigationButtonVisualSource) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AnimatedGlobalNavigationButtonVisualSource) },
        { }};

    static PyType_Spec type_spec_AnimatedGlobalNavigationButtonVisualSource = {
        "winui2._winui2_microsoft_ui_xaml_controls_animatedvisuals.AnimatedGlobalNavigationButtonVisualSource",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Controls::AnimatedVisuals::AnimatedGlobalNavigationButtonVisualSource),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AnimatedGlobalNavigationButtonVisualSource};

    // ----- AnimatedSettingsVisualSource class --------------------

    static PyObject* _new_AnimatedSettingsVisualSource(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_GET_SIZE(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Microsoft::UI::Xaml::Controls::AnimatedVisuals::AnimatedSettingsVisualSource instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_AnimatedSettingsVisualSource(py::wrapper::Microsoft::UI::Xaml::Controls::AnimatedVisuals::AnimatedSettingsVisualSource* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AnimatedSettingsVisualSource_SetColorProperty(py::wrapper::Microsoft::UI::Xaml::Controls::AnimatedVisuals::AnimatedSettingsVisualSource* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.AnimatedVisuals.AnimatedSettingsVisualSource", L"SetColorProperty", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Color>(args, 1);

                {
                    auto _gil = release_gil();
                    self->obj.SetColorProperty(param0, param1);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AnimatedSettingsVisualSource_TryCreateAnimatedVisual(py::wrapper::Microsoft::UI::Xaml::Controls::AnimatedVisuals::AnimatedSettingsVisualSource* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.AnimatedVisuals.AnimatedSettingsVisualSource", L"TryCreateAnimatedVisual", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Composition::Compositor>(args, 0);
                winrt::Windows::Foundation::IInspectable param1{};

                auto return_value = [&]()
                {
                    auto _gil = release_gil();
                    return self->obj.TryCreateAnimatedVisual(param0, param1);
                }();

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out1{ py::convert(param1) };
                if (!out1)
                {
                    return nullptr;
                }

                return PyTuple_Pack(2, out_return_value.get(), out1.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AnimatedSettingsVisualSource_get_Markers(py::wrapper::Microsoft::UI::Xaml::Controls::AnimatedVisuals::AnimatedSettingsVisualSource* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.AnimatedVisuals.AnimatedSettingsVisualSource", L"Markers");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Markers();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AnimatedSettingsVisualSource(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::AnimatedVisuals::AnimatedSettingsVisualSource>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AnimatedSettingsVisualSource(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::AnimatedVisuals::AnimatedSettingsVisualSource>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AnimatedSettingsVisualSource[] = {
        { "set_color_property", reinterpret_cast<PyCFunction>(AnimatedSettingsVisualSource_SetColorProperty), METH_VARARGS, nullptr },
        { "try_create_animated_visual", reinterpret_cast<PyCFunction>(AnimatedSettingsVisualSource_TryCreateAnimatedVisual), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_AnimatedSettingsVisualSource, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AnimatedSettingsVisualSource), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_AnimatedSettingsVisualSource[] = {
        { "markers", reinterpret_cast<getter>(AnimatedSettingsVisualSource_get_Markers), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_AnimatedSettingsVisualSource[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_AnimatedSettingsVisualSource) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AnimatedSettingsVisualSource) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AnimatedSettingsVisualSource) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AnimatedSettingsVisualSource) },
        { }};

    static PyType_Spec type_spec_AnimatedSettingsVisualSource = {
        "winui2._winui2_microsoft_ui_xaml_controls_animatedvisuals.AnimatedSettingsVisualSource",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Controls::AnimatedVisuals::AnimatedSettingsVisualSource),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AnimatedSettingsVisualSource};

    // ----- Microsoft.UI.Xaml.Controls.AnimatedVisuals Initialization --------------------

    PyDoc_STRVAR(module_doc, "Microsoft.UI.Xaml.Controls.AnimatedVisuals");

    static PyModuleDef module_def = {
        PyModuleDef_HEAD_INIT,
        "_winui2_microsoft_ui_xaml_controls_animatedvisuals",
        module_doc,
        0,
        nullptr,
        nullptr,
        nullptr,
        nullptr,
        nullptr};
} // py::cpp::Microsoft::UI::Xaml::Controls::AnimatedVisuals

PyMODINIT_FUNC PyInit__winui2_microsoft_ui_xaml_controls_animatedvisuals(void) noexcept
{
    using namespace py::cpp::Microsoft::UI::Xaml::Controls::AnimatedVisuals;

    if (py::import_winrt_runtime() == -1)
    {
        return nullptr;
    }

    py::pyobj_handle module{PyModule_Create(&module_def)};

    if (!module)
    {
        return nullptr;
    }

    auto inspectable_meta_type = py::get_inspectable_meta_type();
    if (!inspectable_meta_type)
    {
        return nullptr;
    }

    auto object_type = py::get_object_type();
    if (!object_type)
    {
        return nullptr;
    }

    py::pyobj_handle object_bases{PyTuple_Pack(1, object_type)};

    if (!object_bases)
    {
        return nullptr;
    }

    py::pytype_handle AnimatedAcceptVisualSource_type{py::register_python_type(module.get(), &type_spec_AnimatedAcceptVisualSource, object_bases.get(), inspectable_meta_type)};
    if (!AnimatedAcceptVisualSource_type)
    {
        return nullptr;
    }

    py::pytype_handle AnimatedBackVisualSource_type{py::register_python_type(module.get(), &type_spec_AnimatedBackVisualSource, object_bases.get(), inspectable_meta_type)};
    if (!AnimatedBackVisualSource_type)
    {
        return nullptr;
    }

    py::pytype_handle AnimatedChevronDownSmallVisualSource_type{py::register_python_type(module.get(), &type_spec_AnimatedChevronDownSmallVisualSource, object_bases.get(), inspectable_meta_type)};
    if (!AnimatedChevronDownSmallVisualSource_type)
    {
        return nullptr;
    }

    py::pytype_handle AnimatedChevronRightDownSmallVisualSource_type{py::register_python_type(module.get(), &type_spec_AnimatedChevronRightDownSmallVisualSource, object_bases.get(), inspectable_meta_type)};
    if (!AnimatedChevronRightDownSmallVisualSource_type)
    {
        return nullptr;
    }

    py::pytype_handle AnimatedChevronUpDownSmallVisualSource_type{py::register_python_type(module.get(), &type_spec_AnimatedChevronUpDownSmallVisualSource, object_bases.get(), inspectable_meta_type)};
    if (!AnimatedChevronUpDownSmallVisualSource_type)
    {
        return nullptr;
    }

    py::pytype_handle AnimatedFindVisualSource_type{py::register_python_type(module.get(), &type_spec_AnimatedFindVisualSource, object_bases.get(), inspectable_meta_type)};
    if (!AnimatedFindVisualSource_type)
    {
        return nullptr;
    }

    py::pytype_handle AnimatedGlobalNavigationButtonVisualSource_type{py::register_python_type(module.get(), &type_spec_AnimatedGlobalNavigationButtonVisualSource, object_bases.get(), inspectable_meta_type)};
    if (!AnimatedGlobalNavigationButtonVisualSource_type)
    {
        return nullptr;
    }

    py::pytype_handle AnimatedSettingsVisualSource_type{py::register_python_type(module.get(), &type_spec_AnimatedSettingsVisualSource, object_bases.get(), inspectable_meta_type)};
    if (!AnimatedSettingsVisualSource_type)
    {
        return nullptr;
    }


    return module.detach();
}
