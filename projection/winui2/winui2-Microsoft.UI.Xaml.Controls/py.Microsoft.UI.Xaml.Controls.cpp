// WARNING: Please don't edit this file. It was generated by Python/WinRT v3.0.0

#include "py.Microsoft.UI.Xaml.Controls.h"

namespace py::cpp::Microsoft::UI::Xaml::Controls
{
    // ----- AnimatedIcon class --------------------

    struct PyWinrtAnimatedIcon;
    using BasePyWinrtAnimatedIcon = winrt::Microsoft::UI::Xaml::Controls::AnimatedIconT<PyWinrtAnimatedIcon, py::IPywinrtObject>;

    struct PyWinrtAnimatedIcon : py::py_obj_ref, BasePyWinrtAnimatedIcon
    {
        PyWinrtAnimatedIcon(PyObject* py_obj) : py::py_obj_ref(py_obj), BasePyWinrtAnimatedIcon() {}

        int32_t __stdcall GetPyObject(PyObject*& obj) override
        {
            obj = py::py_obj_ref::get_py_obj();
            return 0;
        }

        int32_t __stdcall GetComposableInner(winrt::Windows::Foundation::IInspectable& inner) override
        {
            inner = m_inner;
            return winrt::impl::error_ok;
        }

        static void toggle_reference(PyWinrtAnimatedIcon* instance, bool is_last_reference)
        {
            py::py_obj_ref::toggle_reference(instance, is_last_reference);
        }

        int32_t query_interface_tearoff(winrt::guid const& id, void** result) const noexcept override
        {
            return py::py_obj_ref::query_interface_tearoff(id, result);
        }

        std::vector<winrt::guid> get_iids_tearoff() const noexcept override
        {
            return py::py_obj_ref::get_iids_tearoff();
        }
    };

    static PyObject* _new_AnimatedIcon(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_GET_SIZE(args);

        auto self_type = get_python_type_for<winrt::Microsoft::UI::Xaml::Controls::AnimatedIcon>();
        if (!self_type)
        {
            return nullptr;
        }

        if (arg_count == 0)
        {
            try
            {
                if (type != self_type)
                {
                    py::pyobj_handle self{type->tp_alloc(type, 0)};
                    if (!self)
                    {
                        return nullptr;
                    }

                    std::construct_at(&reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj, nullptr);

                    auto obj_impl = winrt::make_self<PyWinrtAnimatedIcon>(self.get());

                    auto obj = py::make_py_obj<PyWinrtAnimatedIcon>(obj_impl, type, self.get());
                    if (!obj)
                    {
                        return nullptr;
                    }

                    reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj = std::move(obj);

                    return self.detach();
                }

                winrt::Microsoft::UI::Xaml::Controls::AnimatedIcon instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_AnimatedIcon(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AnimatedIcon_GetState(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.AnimatedIcon", L"GetState", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::DependencyObject>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Microsoft::UI::Xaml::Controls::AnimatedIcon::GetState(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AnimatedIcon_SetState(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.AnimatedIcon", L"SetState", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::DependencyObject>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                {
                    auto _gil = release_gil();
                    winrt::Microsoft::UI::Xaml::Controls::AnimatedIcon::SetState(param0, param1);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AnimatedIcon_get_Source(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.AnimatedIcon", L"Source");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::AnimatedIcon>().Source();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AnimatedIcon_put_Source(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.AnimatedIcon", L"Source");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::IAnimatedVisualSource2>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::AnimatedIcon>().Source(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AnimatedIcon_get_MirroredWhenRightToLeft(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.AnimatedIcon", L"MirroredWhenRightToLeft");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::AnimatedIcon>().MirroredWhenRightToLeft();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AnimatedIcon_put_MirroredWhenRightToLeft(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.AnimatedIcon", L"MirroredWhenRightToLeft");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::AnimatedIcon>().MirroredWhenRightToLeft(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AnimatedIcon_get_FallbackIconSource(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.AnimatedIcon", L"FallbackIconSource");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::AnimatedIcon>().FallbackIconSource();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AnimatedIcon_put_FallbackIconSource(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.AnimatedIcon", L"FallbackIconSource");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::IconSource>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::AnimatedIcon>().FallbackIconSource(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AnimatedIcon_get_FallbackIconSourceProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.AnimatedIcon", L"FallbackIconSourceProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::AnimatedIcon::FallbackIconSourceProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AnimatedIcon_get_MirroredWhenRightToLeftProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.AnimatedIcon", L"MirroredWhenRightToLeftProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::AnimatedIcon::MirroredWhenRightToLeftProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AnimatedIcon_get_SourceProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.AnimatedIcon", L"SourceProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::AnimatedIcon::SourceProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AnimatedIcon_get_StateProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.AnimatedIcon", L"StateProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::AnimatedIcon::StateProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AnimatedIcon(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::AnimatedIcon>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AnimatedIcon(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::AnimatedIcon>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AnimatedIcon[] = {
        { "_assign_array_", _assign_array_AnimatedIcon, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AnimatedIcon), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_AnimatedIcon[] = {
        { "source", reinterpret_cast<getter>(AnimatedIcon_get_Source), reinterpret_cast<setter>(AnimatedIcon_put_Source), nullptr, nullptr },
        { "mirrored_when_right_to_left", reinterpret_cast<getter>(AnimatedIcon_get_MirroredWhenRightToLeft), reinterpret_cast<setter>(AnimatedIcon_put_MirroredWhenRightToLeft), nullptr, nullptr },
        { "fallback_icon_source", reinterpret_cast<getter>(AnimatedIcon_get_FallbackIconSource), reinterpret_cast<setter>(AnimatedIcon_put_FallbackIconSource), nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_AnimatedIcon[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_AnimatedIcon) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AnimatedIcon) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AnimatedIcon) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AnimatedIcon) },
        { }};

    static PyType_Spec type_spec_AnimatedIcon = {
        "winui2._winui2_microsoft_ui_xaml_controls.AnimatedIcon",
        sizeof(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_AnimatedIcon};

    static PyGetSetDef getset_AnimatedIcon_Static[] = {
        { "fallback_icon_source_property", reinterpret_cast<getter>(AnimatedIcon_get_FallbackIconSourceProperty), nullptr, nullptr, nullptr },
        { "mirrored_when_right_to_left_property", reinterpret_cast<getter>(AnimatedIcon_get_MirroredWhenRightToLeftProperty), nullptr, nullptr, nullptr },
        { "source_property", reinterpret_cast<getter>(AnimatedIcon_get_SourceProperty), nullptr, nullptr, nullptr },
        { "state_property", reinterpret_cast<getter>(AnimatedIcon_get_StateProperty), nullptr, nullptr, nullptr },
        { }};

    static PyMethodDef methods_AnimatedIcon_Static[] = {
        { "get_state", reinterpret_cast<PyCFunction>(AnimatedIcon_GetState), METH_VARARGS, nullptr },
        { "set_state", reinterpret_cast<PyCFunction>(AnimatedIcon_SetState), METH_VARARGS, nullptr },
        { }};

    static PyType_Slot type_slots_AnimatedIcon_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_AnimatedIcon_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_AnimatedIcon_Static) },
        { }
    };

    static PyType_Spec type_spec_AnimatedIcon_Static = {
        "winui2._winui2_microsoft_ui_xaml_controls.AnimatedIcon_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_AnimatedIcon_Static};

    // ----- AnimatedIconSource class --------------------

    struct PyWinrtAnimatedIconSource;
    using BasePyWinrtAnimatedIconSource = winrt::Microsoft::UI::Xaml::Controls::AnimatedIconSourceT<PyWinrtAnimatedIconSource, py::IPywinrtObject>;

    struct PyWinrtAnimatedIconSource : py::py_obj_ref, BasePyWinrtAnimatedIconSource
    {
        PyWinrtAnimatedIconSource(PyObject* py_obj) : py::py_obj_ref(py_obj), BasePyWinrtAnimatedIconSource() {}

        int32_t __stdcall GetPyObject(PyObject*& obj) override
        {
            obj = py::py_obj_ref::get_py_obj();
            return 0;
        }

        int32_t __stdcall GetComposableInner(winrt::Windows::Foundation::IInspectable& inner) override
        {
            inner = m_inner;
            return winrt::impl::error_ok;
        }

        static void toggle_reference(PyWinrtAnimatedIconSource* instance, bool is_last_reference)
        {
            py::py_obj_ref::toggle_reference(instance, is_last_reference);
        }

        int32_t query_interface_tearoff(winrt::guid const& id, void** result) const noexcept override
        {
            return py::py_obj_ref::query_interface_tearoff(id, result);
        }

        std::vector<winrt::guid> get_iids_tearoff() const noexcept override
        {
            return py::py_obj_ref::get_iids_tearoff();
        }
    };

    static PyObject* _new_AnimatedIconSource(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_GET_SIZE(args);

        auto self_type = get_python_type_for<winrt::Microsoft::UI::Xaml::Controls::AnimatedIconSource>();
        if (!self_type)
        {
            return nullptr;
        }

        if (arg_count == 0)
        {
            try
            {
                if (type != self_type)
                {
                    py::pyobj_handle self{type->tp_alloc(type, 0)};
                    if (!self)
                    {
                        return nullptr;
                    }

                    std::construct_at(&reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj, nullptr);

                    auto obj_impl = winrt::make_self<PyWinrtAnimatedIconSource>(self.get());

                    auto obj = py::make_py_obj<PyWinrtAnimatedIconSource>(obj_impl, type, self.get());
                    if (!obj)
                    {
                        return nullptr;
                    }

                    reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj = std::move(obj);

                    return self.detach();
                }

                winrt::Microsoft::UI::Xaml::Controls::AnimatedIconSource instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_AnimatedIconSource(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AnimatedIconSource_get_Source(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.AnimatedIconSource", L"Source");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::AnimatedIconSource>().Source();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AnimatedIconSource_put_Source(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.AnimatedIconSource", L"Source");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::IAnimatedVisualSource2>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::AnimatedIconSource>().Source(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AnimatedIconSource_get_MirroredWhenRightToLeft(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.AnimatedIconSource", L"MirroredWhenRightToLeft");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::AnimatedIconSource>().MirroredWhenRightToLeft();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AnimatedIconSource_put_MirroredWhenRightToLeft(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.AnimatedIconSource", L"MirroredWhenRightToLeft");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::AnimatedIconSource>().MirroredWhenRightToLeft(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AnimatedIconSource_get_FallbackIconSource(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.AnimatedIconSource", L"FallbackIconSource");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::AnimatedIconSource>().FallbackIconSource();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AnimatedIconSource_put_FallbackIconSource(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.AnimatedIconSource", L"FallbackIconSource");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::IconSource>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::AnimatedIconSource>().FallbackIconSource(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AnimatedIconSource_get_FallbackIconSourceProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.AnimatedIconSource", L"FallbackIconSourceProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::AnimatedIconSource::FallbackIconSourceProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AnimatedIconSource_get_MirroredWhenRightToLeftProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.AnimatedIconSource", L"MirroredWhenRightToLeftProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::AnimatedIconSource::MirroredWhenRightToLeftProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AnimatedIconSource_get_SourceProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.AnimatedIconSource", L"SourceProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::AnimatedIconSource::SourceProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AnimatedIconSource(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::AnimatedIconSource>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AnimatedIconSource(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::AnimatedIconSource>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AnimatedIconSource[] = {
        { "_assign_array_", _assign_array_AnimatedIconSource, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AnimatedIconSource), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_AnimatedIconSource[] = {
        { "source", reinterpret_cast<getter>(AnimatedIconSource_get_Source), reinterpret_cast<setter>(AnimatedIconSource_put_Source), nullptr, nullptr },
        { "mirrored_when_right_to_left", reinterpret_cast<getter>(AnimatedIconSource_get_MirroredWhenRightToLeft), reinterpret_cast<setter>(AnimatedIconSource_put_MirroredWhenRightToLeft), nullptr, nullptr },
        { "fallback_icon_source", reinterpret_cast<getter>(AnimatedIconSource_get_FallbackIconSource), reinterpret_cast<setter>(AnimatedIconSource_put_FallbackIconSource), nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_AnimatedIconSource[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_AnimatedIconSource) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AnimatedIconSource) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AnimatedIconSource) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AnimatedIconSource) },
        { }};

    static PyType_Spec type_spec_AnimatedIconSource = {
        "winui2._winui2_microsoft_ui_xaml_controls.AnimatedIconSource",
        sizeof(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_AnimatedIconSource};

    static PyGetSetDef getset_AnimatedIconSource_Static[] = {
        { "fallback_icon_source_property", reinterpret_cast<getter>(AnimatedIconSource_get_FallbackIconSourceProperty), nullptr, nullptr, nullptr },
        { "mirrored_when_right_to_left_property", reinterpret_cast<getter>(AnimatedIconSource_get_MirroredWhenRightToLeftProperty), nullptr, nullptr, nullptr },
        { "source_property", reinterpret_cast<getter>(AnimatedIconSource_get_SourceProperty), nullptr, nullptr, nullptr },
        { }};

    static PyMethodDef methods_AnimatedIconSource_Static[] = {
        { }};

    static PyType_Slot type_slots_AnimatedIconSource_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_AnimatedIconSource_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_AnimatedIconSource_Static) },
        { }
    };

    static PyType_Spec type_spec_AnimatedIconSource_Static = {
        "winui2._winui2_microsoft_ui_xaml_controls.AnimatedIconSource_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_AnimatedIconSource_Static};

    // ----- AnimatedVisualPlayer class --------------------

    struct PyWinrtAnimatedVisualPlayer;
    using BasePyWinrtAnimatedVisualPlayer = winrt::Microsoft::UI::Xaml::Controls::AnimatedVisualPlayerT<PyWinrtAnimatedVisualPlayer, py::IPywinrtObject>;

    struct PyWinrtAnimatedVisualPlayer : py::py_obj_ref, BasePyWinrtAnimatedVisualPlayer
    {
        PyWinrtAnimatedVisualPlayer(PyObject* py_obj) : py::py_obj_ref(py_obj), BasePyWinrtAnimatedVisualPlayer() {}

        int32_t __stdcall GetPyObject(PyObject*& obj) override
        {
            obj = py::py_obj_ref::get_py_obj();
            return 0;
        }

        int32_t __stdcall GetComposableInner(winrt::Windows::Foundation::IInspectable& inner) override
        {
            inner = m_inner;
            return winrt::impl::error_ok;
        }

        static void toggle_reference(PyWinrtAnimatedVisualPlayer* instance, bool is_last_reference)
        {
            py::py_obj_ref::toggle_reference(instance, is_last_reference);
        }

        int32_t query_interface_tearoff(winrt::guid const& id, void** result) const noexcept override
        {
            return py::py_obj_ref::query_interface_tearoff(id, result);
        }

        std::vector<winrt::guid> get_iids_tearoff() const noexcept override
        {
            return py::py_obj_ref::get_iids_tearoff();
        }
    };

    static PyObject* _new_AnimatedVisualPlayer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_GET_SIZE(args);

        auto self_type = get_python_type_for<winrt::Microsoft::UI::Xaml::Controls::AnimatedVisualPlayer>();
        if (!self_type)
        {
            return nullptr;
        }

        if (arg_count == 0)
        {
            try
            {
                if (type != self_type)
                {
                    py::pyobj_handle self{type->tp_alloc(type, 0)};
                    if (!self)
                    {
                        return nullptr;
                    }

                    std::construct_at(&reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj, nullptr);

                    auto obj_impl = winrt::make_self<PyWinrtAnimatedVisualPlayer>(self.get());

                    auto obj = py::make_py_obj<PyWinrtAnimatedVisualPlayer>(obj_impl, type, self.get());
                    if (!obj)
                    {
                        return nullptr;
                    }

                    reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj = std::move(obj);

                    return self.detach();
                }

                winrt::Microsoft::UI::Xaml::Controls::AnimatedVisualPlayer instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_AnimatedVisualPlayer(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AnimatedVisualPlayer_Pause(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.AnimatedVisualPlayer", L"Pause", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::AnimatedVisualPlayer>().Pause();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AnimatedVisualPlayer_PlayAsync(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 3)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.AnimatedVisualPlayer", L"PlayAsync", 3);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<double>(args, 0);
                auto param1 = py::convert_to<double>(args, 1);
                auto param2 = py::convert_to<bool>(args, 2);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::AnimatedVisualPlayer>().PlayAsync(param0, param1, param2);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AnimatedVisualPlayer_Resume(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.AnimatedVisualPlayer", L"Resume", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::AnimatedVisualPlayer>().Resume();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AnimatedVisualPlayer_SetProgress(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.AnimatedVisualPlayer", L"SetProgress", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<double>(args, 0);

                {
                    auto _gil = release_gil();
                    self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::AnimatedVisualPlayer>().SetProgress(param0);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AnimatedVisualPlayer_Stop(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.AnimatedVisualPlayer", L"Stop", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::AnimatedVisualPlayer>().Stop();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AnimatedVisualPlayer_get_Stretch(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.AnimatedVisualPlayer", L"Stretch");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::AnimatedVisualPlayer>().Stretch();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AnimatedVisualPlayer_put_Stretch(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.AnimatedVisualPlayer", L"Stretch");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Media::Stretch>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::AnimatedVisualPlayer>().Stretch(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AnimatedVisualPlayer_get_Source(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.AnimatedVisualPlayer", L"Source");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::AnimatedVisualPlayer>().Source();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AnimatedVisualPlayer_put_Source(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.AnimatedVisualPlayer", L"Source");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::IAnimatedVisualSource>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::AnimatedVisualPlayer>().Source(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AnimatedVisualPlayer_get_PlaybackRate(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.AnimatedVisualPlayer", L"PlaybackRate");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::AnimatedVisualPlayer>().PlaybackRate();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AnimatedVisualPlayer_put_PlaybackRate(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.AnimatedVisualPlayer", L"PlaybackRate");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<double>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::AnimatedVisualPlayer>().PlaybackRate(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AnimatedVisualPlayer_get_FallbackContent(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.AnimatedVisualPlayer", L"FallbackContent");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::AnimatedVisualPlayer>().FallbackContent();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AnimatedVisualPlayer_put_FallbackContent(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.AnimatedVisualPlayer", L"FallbackContent");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::DataTemplate>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::AnimatedVisualPlayer>().FallbackContent(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AnimatedVisualPlayer_get_AutoPlay(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.AnimatedVisualPlayer", L"AutoPlay");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::AnimatedVisualPlayer>().AutoPlay();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AnimatedVisualPlayer_put_AutoPlay(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.AnimatedVisualPlayer", L"AutoPlay");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::AnimatedVisualPlayer>().AutoPlay(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AnimatedVisualPlayer_get_Diagnostics(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.AnimatedVisualPlayer", L"Diagnostics");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::AnimatedVisualPlayer>().Diagnostics();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AnimatedVisualPlayer_get_Duration(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.AnimatedVisualPlayer", L"Duration");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::AnimatedVisualPlayer>().Duration();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AnimatedVisualPlayer_get_IsAnimatedVisualLoaded(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.AnimatedVisualPlayer", L"IsAnimatedVisualLoaded");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::AnimatedVisualPlayer>().IsAnimatedVisualLoaded();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AnimatedVisualPlayer_get_IsPlaying(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.AnimatedVisualPlayer", L"IsPlaying");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::AnimatedVisualPlayer>().IsPlaying();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AnimatedVisualPlayer_get_ProgressObject(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.AnimatedVisualPlayer", L"ProgressObject");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::AnimatedVisualPlayer>().ProgressObject();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AnimatedVisualPlayer_get_AnimationOptimization(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.AnimatedVisualPlayer", L"AnimationOptimization");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::AnimatedVisualPlayer>().AnimationOptimization();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AnimatedVisualPlayer_put_AnimationOptimization(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.AnimatedVisualPlayer", L"AnimationOptimization");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::PlayerAnimationOptimization>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::AnimatedVisualPlayer>().AnimationOptimization(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AnimatedVisualPlayer_get_AutoPlayProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.AnimatedVisualPlayer", L"AutoPlayProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::AnimatedVisualPlayer::AutoPlayProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AnimatedVisualPlayer_get_DiagnosticsProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.AnimatedVisualPlayer", L"DiagnosticsProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::AnimatedVisualPlayer::DiagnosticsProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AnimatedVisualPlayer_get_DurationProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.AnimatedVisualPlayer", L"DurationProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::AnimatedVisualPlayer::DurationProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AnimatedVisualPlayer_get_FallbackContentProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.AnimatedVisualPlayer", L"FallbackContentProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::AnimatedVisualPlayer::FallbackContentProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AnimatedVisualPlayer_get_IsAnimatedVisualLoadedProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.AnimatedVisualPlayer", L"IsAnimatedVisualLoadedProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::AnimatedVisualPlayer::IsAnimatedVisualLoadedProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AnimatedVisualPlayer_get_IsPlayingProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.AnimatedVisualPlayer", L"IsPlayingProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::AnimatedVisualPlayer::IsPlayingProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AnimatedVisualPlayer_get_PlaybackRateProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.AnimatedVisualPlayer", L"PlaybackRateProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::AnimatedVisualPlayer::PlaybackRateProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AnimatedVisualPlayer_get_SourceProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.AnimatedVisualPlayer", L"SourceProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::AnimatedVisualPlayer::SourceProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AnimatedVisualPlayer_get_StretchProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.AnimatedVisualPlayer", L"StretchProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::AnimatedVisualPlayer::StretchProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AnimatedVisualPlayer_get_AnimationOptimizationProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.AnimatedVisualPlayer", L"AnimationOptimizationProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::AnimatedVisualPlayer::AnimationOptimizationProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AnimatedVisualPlayer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::AnimatedVisualPlayer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AnimatedVisualPlayer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::AnimatedVisualPlayer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AnimatedVisualPlayer[] = {
        { "pause", reinterpret_cast<PyCFunction>(AnimatedVisualPlayer_Pause), METH_VARARGS, nullptr },
        { "play_async", reinterpret_cast<PyCFunction>(AnimatedVisualPlayer_PlayAsync), METH_VARARGS, nullptr },
        { "resume", reinterpret_cast<PyCFunction>(AnimatedVisualPlayer_Resume), METH_VARARGS, nullptr },
        { "set_progress", reinterpret_cast<PyCFunction>(AnimatedVisualPlayer_SetProgress), METH_VARARGS, nullptr },
        { "stop", reinterpret_cast<PyCFunction>(AnimatedVisualPlayer_Stop), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_AnimatedVisualPlayer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AnimatedVisualPlayer), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_AnimatedVisualPlayer[] = {
        { "stretch", reinterpret_cast<getter>(AnimatedVisualPlayer_get_Stretch), reinterpret_cast<setter>(AnimatedVisualPlayer_put_Stretch), nullptr, nullptr },
        { "source", reinterpret_cast<getter>(AnimatedVisualPlayer_get_Source), reinterpret_cast<setter>(AnimatedVisualPlayer_put_Source), nullptr, nullptr },
        { "playback_rate", reinterpret_cast<getter>(AnimatedVisualPlayer_get_PlaybackRate), reinterpret_cast<setter>(AnimatedVisualPlayer_put_PlaybackRate), nullptr, nullptr },
        { "fallback_content", reinterpret_cast<getter>(AnimatedVisualPlayer_get_FallbackContent), reinterpret_cast<setter>(AnimatedVisualPlayer_put_FallbackContent), nullptr, nullptr },
        { "auto_play", reinterpret_cast<getter>(AnimatedVisualPlayer_get_AutoPlay), reinterpret_cast<setter>(AnimatedVisualPlayer_put_AutoPlay), nullptr, nullptr },
        { "diagnostics", reinterpret_cast<getter>(AnimatedVisualPlayer_get_Diagnostics), nullptr, nullptr, nullptr },
        { "duration", reinterpret_cast<getter>(AnimatedVisualPlayer_get_Duration), nullptr, nullptr, nullptr },
        { "is_animated_visual_loaded", reinterpret_cast<getter>(AnimatedVisualPlayer_get_IsAnimatedVisualLoaded), nullptr, nullptr, nullptr },
        { "is_playing", reinterpret_cast<getter>(AnimatedVisualPlayer_get_IsPlaying), nullptr, nullptr, nullptr },
        { "progress_object", reinterpret_cast<getter>(AnimatedVisualPlayer_get_ProgressObject), nullptr, nullptr, nullptr },
        { "animation_optimization", reinterpret_cast<getter>(AnimatedVisualPlayer_get_AnimationOptimization), reinterpret_cast<setter>(AnimatedVisualPlayer_put_AnimationOptimization), nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_AnimatedVisualPlayer[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_AnimatedVisualPlayer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AnimatedVisualPlayer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AnimatedVisualPlayer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AnimatedVisualPlayer) },
        { }};

    static PyType_Spec type_spec_AnimatedVisualPlayer = {
        "winui2._winui2_microsoft_ui_xaml_controls.AnimatedVisualPlayer",
        sizeof(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_AnimatedVisualPlayer};

    static PyGetSetDef getset_AnimatedVisualPlayer_Static[] = {
        { "auto_play_property", reinterpret_cast<getter>(AnimatedVisualPlayer_get_AutoPlayProperty), nullptr, nullptr, nullptr },
        { "diagnostics_property", reinterpret_cast<getter>(AnimatedVisualPlayer_get_DiagnosticsProperty), nullptr, nullptr, nullptr },
        { "duration_property", reinterpret_cast<getter>(AnimatedVisualPlayer_get_DurationProperty), nullptr, nullptr, nullptr },
        { "fallback_content_property", reinterpret_cast<getter>(AnimatedVisualPlayer_get_FallbackContentProperty), nullptr, nullptr, nullptr },
        { "is_animated_visual_loaded_property", reinterpret_cast<getter>(AnimatedVisualPlayer_get_IsAnimatedVisualLoadedProperty), nullptr, nullptr, nullptr },
        { "is_playing_property", reinterpret_cast<getter>(AnimatedVisualPlayer_get_IsPlayingProperty), nullptr, nullptr, nullptr },
        { "playback_rate_property", reinterpret_cast<getter>(AnimatedVisualPlayer_get_PlaybackRateProperty), nullptr, nullptr, nullptr },
        { "source_property", reinterpret_cast<getter>(AnimatedVisualPlayer_get_SourceProperty), nullptr, nullptr, nullptr },
        { "stretch_property", reinterpret_cast<getter>(AnimatedVisualPlayer_get_StretchProperty), nullptr, nullptr, nullptr },
        { "animation_optimization_property", reinterpret_cast<getter>(AnimatedVisualPlayer_get_AnimationOptimizationProperty), nullptr, nullptr, nullptr },
        { }};

    static PyMethodDef methods_AnimatedVisualPlayer_Static[] = {
        { }};

    static PyType_Slot type_slots_AnimatedVisualPlayer_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_AnimatedVisualPlayer_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_AnimatedVisualPlayer_Static) },
        { }
    };

    static PyType_Spec type_spec_AnimatedVisualPlayer_Static = {
        "winui2._winui2_microsoft_ui_xaml_controls.AnimatedVisualPlayer_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_AnimatedVisualPlayer_Static};

    // ----- BackdropMaterial class --------------------

    static PyObject* _new_BackdropMaterial(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Xaml::Controls::BackdropMaterial>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Xaml::Controls::BackdropMaterial>::type_name);
        return nullptr;
    }

    static void _dealloc_BackdropMaterial(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* BackdropMaterial_GetApplyToRootOrPageBackground(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.BackdropMaterial", L"GetApplyToRootOrPageBackground", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::Control>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Microsoft::UI::Xaml::Controls::BackdropMaterial::GetApplyToRootOrPageBackground(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BackdropMaterial_SetApplyToRootOrPageBackground(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.BackdropMaterial", L"SetApplyToRootOrPageBackground", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::Control>(args, 0);
                auto param1 = py::convert_to<bool>(args, 1);

                {
                    auto _gil = release_gil();
                    winrt::Microsoft::UI::Xaml::Controls::BackdropMaterial::SetApplyToRootOrPageBackground(param0, param1);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BackdropMaterial_get_ApplyToRootOrPageBackgroundProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.BackdropMaterial", L"ApplyToRootOrPageBackgroundProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::BackdropMaterial::ApplyToRootOrPageBackgroundProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_BackdropMaterial(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::BackdropMaterial>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_BackdropMaterial(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::BackdropMaterial>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_BackdropMaterial[] = {
        { "_assign_array_", _assign_array_BackdropMaterial, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_BackdropMaterial), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_BackdropMaterial[] = {
        { }};

    static PyType_Slot _type_slots_BackdropMaterial[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_BackdropMaterial) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_BackdropMaterial) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_BackdropMaterial) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_BackdropMaterial) },
        { }};

    static PyType_Spec type_spec_BackdropMaterial = {
        "winui2._winui2_microsoft_ui_xaml_controls.BackdropMaterial",
        sizeof(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_BackdropMaterial};

    static PyGetSetDef getset_BackdropMaterial_Static[] = {
        { "apply_to_root_or_page_background_property", reinterpret_cast<getter>(BackdropMaterial_get_ApplyToRootOrPageBackgroundProperty), nullptr, nullptr, nullptr },
        { }};

    static PyMethodDef methods_BackdropMaterial_Static[] = {
        { "get_apply_to_root_or_page_background", reinterpret_cast<PyCFunction>(BackdropMaterial_GetApplyToRootOrPageBackground), METH_VARARGS, nullptr },
        { "set_apply_to_root_or_page_background", reinterpret_cast<PyCFunction>(BackdropMaterial_SetApplyToRootOrPageBackground), METH_VARARGS, nullptr },
        { }};

    static PyType_Slot type_slots_BackdropMaterial_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_BackdropMaterial_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_BackdropMaterial_Static) },
        { }
    };

    static PyType_Spec type_spec_BackdropMaterial_Static = {
        "winui2._winui2_microsoft_ui_xaml_controls.BackdropMaterial_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_BackdropMaterial_Static};

    // ----- BitmapIconSource class --------------------

    struct PyWinrtBitmapIconSource;
    using BasePyWinrtBitmapIconSource = winrt::Microsoft::UI::Xaml::Controls::BitmapIconSourceT<PyWinrtBitmapIconSource, py::IPywinrtObject>;

    struct PyWinrtBitmapIconSource : py::py_obj_ref, BasePyWinrtBitmapIconSource
    {
        PyWinrtBitmapIconSource(PyObject* py_obj) : py::py_obj_ref(py_obj), BasePyWinrtBitmapIconSource() {}

        int32_t __stdcall GetPyObject(PyObject*& obj) override
        {
            obj = py::py_obj_ref::get_py_obj();
            return 0;
        }

        int32_t __stdcall GetComposableInner(winrt::Windows::Foundation::IInspectable& inner) override
        {
            inner = m_inner;
            return winrt::impl::error_ok;
        }

        static void toggle_reference(PyWinrtBitmapIconSource* instance, bool is_last_reference)
        {
            py::py_obj_ref::toggle_reference(instance, is_last_reference);
        }

        int32_t query_interface_tearoff(winrt::guid const& id, void** result) const noexcept override
        {
            return py::py_obj_ref::query_interface_tearoff(id, result);
        }

        std::vector<winrt::guid> get_iids_tearoff() const noexcept override
        {
            return py::py_obj_ref::get_iids_tearoff();
        }
    };

    static PyObject* _new_BitmapIconSource(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_GET_SIZE(args);

        auto self_type = get_python_type_for<winrt::Microsoft::UI::Xaml::Controls::BitmapIconSource>();
        if (!self_type)
        {
            return nullptr;
        }

        if (arg_count == 0)
        {
            try
            {
                if (type != self_type)
                {
                    py::pyobj_handle self{type->tp_alloc(type, 0)};
                    if (!self)
                    {
                        return nullptr;
                    }

                    std::construct_at(&reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj, nullptr);

                    auto obj_impl = winrt::make_self<PyWinrtBitmapIconSource>(self.get());

                    auto obj = py::make_py_obj<PyWinrtBitmapIconSource>(obj_impl, type, self.get());
                    if (!obj)
                    {
                        return nullptr;
                    }

                    reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj = std::move(obj);

                    return self.detach();
                }

                winrt::Microsoft::UI::Xaml::Controls::BitmapIconSource instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_BitmapIconSource(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* BitmapIconSource_get_UriSource(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.BitmapIconSource", L"UriSource");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::BitmapIconSource>().UriSource();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BitmapIconSource_put_UriSource(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.BitmapIconSource", L"UriSource");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::BitmapIconSource>().UriSource(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BitmapIconSource_get_ShowAsMonochrome(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.BitmapIconSource", L"ShowAsMonochrome");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::BitmapIconSource>().ShowAsMonochrome();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BitmapIconSource_put_ShowAsMonochrome(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.BitmapIconSource", L"ShowAsMonochrome");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::BitmapIconSource>().ShowAsMonochrome(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BitmapIconSource_get_ShowAsMonochromeProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.BitmapIconSource", L"ShowAsMonochromeProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::BitmapIconSource::ShowAsMonochromeProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BitmapIconSource_get_UriSourceProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.BitmapIconSource", L"UriSourceProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::BitmapIconSource::UriSourceProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_BitmapIconSource(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::BitmapIconSource>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_BitmapIconSource(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::BitmapIconSource>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_BitmapIconSource[] = {
        { "_assign_array_", _assign_array_BitmapIconSource, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_BitmapIconSource), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_BitmapIconSource[] = {
        { "uri_source", reinterpret_cast<getter>(BitmapIconSource_get_UriSource), reinterpret_cast<setter>(BitmapIconSource_put_UriSource), nullptr, nullptr },
        { "show_as_monochrome", reinterpret_cast<getter>(BitmapIconSource_get_ShowAsMonochrome), reinterpret_cast<setter>(BitmapIconSource_put_ShowAsMonochrome), nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_BitmapIconSource[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_BitmapIconSource) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_BitmapIconSource) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_BitmapIconSource) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_BitmapIconSource) },
        { }};

    static PyType_Spec type_spec_BitmapIconSource = {
        "winui2._winui2_microsoft_ui_xaml_controls.BitmapIconSource",
        sizeof(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_BitmapIconSource};

    static PyGetSetDef getset_BitmapIconSource_Static[] = {
        { "show_as_monochrome_property", reinterpret_cast<getter>(BitmapIconSource_get_ShowAsMonochromeProperty), nullptr, nullptr, nullptr },
        { "uri_source_property", reinterpret_cast<getter>(BitmapIconSource_get_UriSourceProperty), nullptr, nullptr, nullptr },
        { }};

    static PyMethodDef methods_BitmapIconSource_Static[] = {
        { }};

    static PyType_Slot type_slots_BitmapIconSource_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_BitmapIconSource_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_BitmapIconSource_Static) },
        { }
    };

    static PyType_Spec type_spec_BitmapIconSource_Static = {
        "winui2._winui2_microsoft_ui_xaml_controls.BitmapIconSource_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_BitmapIconSource_Static};

    // ----- BreadcrumbBar class --------------------

    struct PyWinrtBreadcrumbBar;
    using BasePyWinrtBreadcrumbBar = winrt::Microsoft::UI::Xaml::Controls::BreadcrumbBarT<PyWinrtBreadcrumbBar, py::IPywinrtObject>;

    struct PyWinrtBreadcrumbBar : py::py_obj_ref, BasePyWinrtBreadcrumbBar
    {
        PyWinrtBreadcrumbBar(PyObject* py_obj) : py::py_obj_ref(py_obj), BasePyWinrtBreadcrumbBar() {}

        int32_t __stdcall GetPyObject(PyObject*& obj) override
        {
            obj = py::py_obj_ref::get_py_obj();
            return 0;
        }

        int32_t __stdcall GetComposableInner(winrt::Windows::Foundation::IInspectable& inner) override
        {
            inner = m_inner;
            return winrt::impl::error_ok;
        }

        static void toggle_reference(PyWinrtBreadcrumbBar* instance, bool is_last_reference)
        {
            py::py_obj_ref::toggle_reference(instance, is_last_reference);
        }

        int32_t query_interface_tearoff(winrt::guid const& id, void** result) const noexcept override
        {
            return py::py_obj_ref::query_interface_tearoff(id, result);
        }

        std::vector<winrt::guid> get_iids_tearoff() const noexcept override
        {
            return py::py_obj_ref::get_iids_tearoff();
        }
    };

    static PyObject* _new_BreadcrumbBar(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_GET_SIZE(args);

        auto self_type = get_python_type_for<winrt::Microsoft::UI::Xaml::Controls::BreadcrumbBar>();
        if (!self_type)
        {
            return nullptr;
        }

        if (arg_count == 0)
        {
            try
            {
                if (type != self_type)
                {
                    py::pyobj_handle self{type->tp_alloc(type, 0)};
                    if (!self)
                    {
                        return nullptr;
                    }

                    std::construct_at(&reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj, nullptr);

                    auto obj_impl = winrt::make_self<PyWinrtBreadcrumbBar>(self.get());

                    auto obj = py::make_py_obj<PyWinrtBreadcrumbBar>(obj_impl, type, self.get());
                    if (!obj)
                    {
                        return nullptr;
                    }

                    reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj = std::move(obj);

                    return self.detach();
                }

                winrt::Microsoft::UI::Xaml::Controls::BreadcrumbBar instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_BreadcrumbBar(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* BreadcrumbBar_get_ItemsSource(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.BreadcrumbBar", L"ItemsSource");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::BreadcrumbBar>().ItemsSource();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BreadcrumbBar_put_ItemsSource(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.BreadcrumbBar", L"ItemsSource");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::BreadcrumbBar>().ItemsSource(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BreadcrumbBar_get_ItemTemplate(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.BreadcrumbBar", L"ItemTemplate");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::BreadcrumbBar>().ItemTemplate();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BreadcrumbBar_put_ItemTemplate(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.BreadcrumbBar", L"ItemTemplate");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::BreadcrumbBar>().ItemTemplate(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BreadcrumbBar_get_ItemTemplateProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.BreadcrumbBar", L"ItemTemplateProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::BreadcrumbBar::ItemTemplateProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BreadcrumbBar_get_ItemsSourceProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.BreadcrumbBar", L"ItemsSourceProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::BreadcrumbBar::ItemsSourceProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BreadcrumbBar_add_ItemClicked(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.BreadcrumbBar", L"ItemClicked");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Xaml::Controls::BreadcrumbBar, winrt::Microsoft::UI::Xaml::Controls::BreadcrumbBarItemClickedEventArgs>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::BreadcrumbBar>().ItemClicked(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BreadcrumbBar_remove_ItemClicked(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.BreadcrumbBar", L"ItemClicked");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::BreadcrumbBar>().ItemClicked(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_BreadcrumbBar(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::BreadcrumbBar>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_BreadcrumbBar(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::BreadcrumbBar>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_BreadcrumbBar[] = {
        { "add_item_clicked", reinterpret_cast<PyCFunction>(BreadcrumbBar_add_ItemClicked), METH_O, nullptr },
        { "remove_item_clicked", reinterpret_cast<PyCFunction>(BreadcrumbBar_remove_ItemClicked), METH_O, nullptr },
        { "_assign_array_", _assign_array_BreadcrumbBar, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_BreadcrumbBar), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_BreadcrumbBar[] = {
        { "items_source", reinterpret_cast<getter>(BreadcrumbBar_get_ItemsSource), reinterpret_cast<setter>(BreadcrumbBar_put_ItemsSource), nullptr, nullptr },
        { "item_template", reinterpret_cast<getter>(BreadcrumbBar_get_ItemTemplate), reinterpret_cast<setter>(BreadcrumbBar_put_ItemTemplate), nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_BreadcrumbBar[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_BreadcrumbBar) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_BreadcrumbBar) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_BreadcrumbBar) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_BreadcrumbBar) },
        { }};

    static PyType_Spec type_spec_BreadcrumbBar = {
        "winui2._winui2_microsoft_ui_xaml_controls.BreadcrumbBar",
        sizeof(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_BreadcrumbBar};

    static PyGetSetDef getset_BreadcrumbBar_Static[] = {
        { "item_template_property", reinterpret_cast<getter>(BreadcrumbBar_get_ItemTemplateProperty), nullptr, nullptr, nullptr },
        { "items_source_property", reinterpret_cast<getter>(BreadcrumbBar_get_ItemsSourceProperty), nullptr, nullptr, nullptr },
        { }};

    static PyMethodDef methods_BreadcrumbBar_Static[] = {
        { }};

    static PyType_Slot type_slots_BreadcrumbBar_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_BreadcrumbBar_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_BreadcrumbBar_Static) },
        { }
    };

    static PyType_Spec type_spec_BreadcrumbBar_Static = {
        "winui2._winui2_microsoft_ui_xaml_controls.BreadcrumbBar_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_BreadcrumbBar_Static};

    // ----- BreadcrumbBarItem class --------------------

    struct PyWinrtBreadcrumbBarItem;
    using BasePyWinrtBreadcrumbBarItem = winrt::Microsoft::UI::Xaml::Controls::BreadcrumbBarItemT<PyWinrtBreadcrumbBarItem, py::IPywinrtObject>;

    struct PyWinrtBreadcrumbBarItem : py::py_obj_ref, BasePyWinrtBreadcrumbBarItem
    {
        PyWinrtBreadcrumbBarItem(PyObject* py_obj) : py::py_obj_ref(py_obj), BasePyWinrtBreadcrumbBarItem() {}

        int32_t __stdcall GetPyObject(PyObject*& obj) override
        {
            obj = py::py_obj_ref::get_py_obj();
            return 0;
        }

        int32_t __stdcall GetComposableInner(winrt::Windows::Foundation::IInspectable& inner) override
        {
            inner = m_inner;
            return winrt::impl::error_ok;
        }

        static void toggle_reference(PyWinrtBreadcrumbBarItem* instance, bool is_last_reference)
        {
            py::py_obj_ref::toggle_reference(instance, is_last_reference);
        }

        int32_t query_interface_tearoff(winrt::guid const& id, void** result) const noexcept override
        {
            return py::py_obj_ref::query_interface_tearoff(id, result);
        }

        std::vector<winrt::guid> get_iids_tearoff() const noexcept override
        {
            return py::py_obj_ref::get_iids_tearoff();
        }
    };

    static PyObject* _new_BreadcrumbBarItem(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_GET_SIZE(args);

        auto self_type = get_python_type_for<winrt::Microsoft::UI::Xaml::Controls::BreadcrumbBarItem>();
        if (!self_type)
        {
            return nullptr;
        }

        if (arg_count == 0)
        {
            try
            {
                if (type != self_type)
                {
                    py::pyobj_handle self{type->tp_alloc(type, 0)};
                    if (!self)
                    {
                        return nullptr;
                    }

                    std::construct_at(&reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj, nullptr);

                    auto obj_impl = winrt::make_self<PyWinrtBreadcrumbBarItem>(self.get());

                    auto obj = py::make_py_obj<PyWinrtBreadcrumbBarItem>(obj_impl, type, self.get());
                    if (!obj)
                    {
                        return nullptr;
                    }

                    reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj = std::move(obj);

                    return self.detach();
                }

                winrt::Microsoft::UI::Xaml::Controls::BreadcrumbBarItem instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_BreadcrumbBarItem(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_BreadcrumbBarItem(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::BreadcrumbBarItem>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_BreadcrumbBarItem(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::BreadcrumbBarItem>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_BreadcrumbBarItem[] = {
        { "_assign_array_", _assign_array_BreadcrumbBarItem, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_BreadcrumbBarItem), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_BreadcrumbBarItem[] = {
        { }};

    static PyType_Slot _type_slots_BreadcrumbBarItem[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_BreadcrumbBarItem) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_BreadcrumbBarItem) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_BreadcrumbBarItem) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_BreadcrumbBarItem) },
        { }};

    static PyType_Spec type_spec_BreadcrumbBarItem = {
        "winui2._winui2_microsoft_ui_xaml_controls.BreadcrumbBarItem",
        sizeof(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_BreadcrumbBarItem};

    static PyGetSetDef getset_BreadcrumbBarItem_Static[] = {
        { }};

    static PyMethodDef methods_BreadcrumbBarItem_Static[] = {
        { }};

    static PyType_Slot type_slots_BreadcrumbBarItem_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_BreadcrumbBarItem_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_BreadcrumbBarItem_Static) },
        { }
    };

    static PyType_Spec type_spec_BreadcrumbBarItem_Static = {
        "winui2._winui2_microsoft_ui_xaml_controls.BreadcrumbBarItem_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_BreadcrumbBarItem_Static};

    // ----- BreadcrumbBarItemClickedEventArgs class --------------------

    static PyObject* _new_BreadcrumbBarItemClickedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Xaml::Controls::BreadcrumbBarItemClickedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Xaml::Controls::BreadcrumbBarItemClickedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_BreadcrumbBarItemClickedEventArgs(py::wrapper::Microsoft::UI::Xaml::Controls::BreadcrumbBarItemClickedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* BreadcrumbBarItemClickedEventArgs_get_Index(py::wrapper::Microsoft::UI::Xaml::Controls::BreadcrumbBarItemClickedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.BreadcrumbBarItemClickedEventArgs", L"Index");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Index();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BreadcrumbBarItemClickedEventArgs_get_Item(py::wrapper::Microsoft::UI::Xaml::Controls::BreadcrumbBarItemClickedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.BreadcrumbBarItemClickedEventArgs", L"Item");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Item();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_BreadcrumbBarItemClickedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::BreadcrumbBarItemClickedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_BreadcrumbBarItemClickedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::BreadcrumbBarItemClickedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_BreadcrumbBarItemClickedEventArgs[] = {
        { "_assign_array_", _assign_array_BreadcrumbBarItemClickedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_BreadcrumbBarItemClickedEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_BreadcrumbBarItemClickedEventArgs[] = {
        { "index", reinterpret_cast<getter>(BreadcrumbBarItemClickedEventArgs_get_Index), nullptr, nullptr, nullptr },
        { "item", reinterpret_cast<getter>(BreadcrumbBarItemClickedEventArgs_get_Item), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_BreadcrumbBarItemClickedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_BreadcrumbBarItemClickedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_BreadcrumbBarItemClickedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_BreadcrumbBarItemClickedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_BreadcrumbBarItemClickedEventArgs) },
        { }};

    static PyType_Spec type_spec_BreadcrumbBarItemClickedEventArgs = {
        "winui2._winui2_microsoft_ui_xaml_controls.BreadcrumbBarItemClickedEventArgs",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Controls::BreadcrumbBarItemClickedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_BreadcrumbBarItemClickedEventArgs};

    // ----- ColorChangedEventArgs class --------------------

    static PyObject* _new_ColorChangedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Xaml::Controls::ColorChangedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Xaml::Controls::ColorChangedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_ColorChangedEventArgs(py::wrapper::Microsoft::UI::Xaml::Controls::ColorChangedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ColorChangedEventArgs_get_NewColor(py::wrapper::Microsoft::UI::Xaml::Controls::ColorChangedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ColorChangedEventArgs", L"NewColor");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.NewColor();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ColorChangedEventArgs_get_OldColor(py::wrapper::Microsoft::UI::Xaml::Controls::ColorChangedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ColorChangedEventArgs", L"OldColor");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.OldColor();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ColorChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::ColorChangedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ColorChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::ColorChangedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ColorChangedEventArgs[] = {
        { "_assign_array_", _assign_array_ColorChangedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ColorChangedEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_ColorChangedEventArgs[] = {
        { "new_color", reinterpret_cast<getter>(ColorChangedEventArgs_get_NewColor), nullptr, nullptr, nullptr },
        { "old_color", reinterpret_cast<getter>(ColorChangedEventArgs_get_OldColor), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_ColorChangedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ColorChangedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ColorChangedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ColorChangedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ColorChangedEventArgs) },
        { }};

    static PyType_Spec type_spec_ColorChangedEventArgs = {
        "winui2._winui2_microsoft_ui_xaml_controls.ColorChangedEventArgs",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Controls::ColorChangedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ColorChangedEventArgs};

    // ----- ColorPicker class --------------------

    struct PyWinrtColorPicker;
    using BasePyWinrtColorPicker = winrt::Microsoft::UI::Xaml::Controls::ColorPickerT<PyWinrtColorPicker, py::IPywinrtObject>;

    struct PyWinrtColorPicker : py::py_obj_ref, BasePyWinrtColorPicker
    {
        PyWinrtColorPicker(PyObject* py_obj) : py::py_obj_ref(py_obj), BasePyWinrtColorPicker() {}

        int32_t __stdcall GetPyObject(PyObject*& obj) override
        {
            obj = py::py_obj_ref::get_py_obj();
            return 0;
        }

        int32_t __stdcall GetComposableInner(winrt::Windows::Foundation::IInspectable& inner) override
        {
            inner = m_inner;
            return winrt::impl::error_ok;
        }

        static void toggle_reference(PyWinrtColorPicker* instance, bool is_last_reference)
        {
            py::py_obj_ref::toggle_reference(instance, is_last_reference);
        }

        int32_t query_interface_tearoff(winrt::guid const& id, void** result) const noexcept override
        {
            return py::py_obj_ref::query_interface_tearoff(id, result);
        }

        std::vector<winrt::guid> get_iids_tearoff() const noexcept override
        {
            return py::py_obj_ref::get_iids_tearoff();
        }
    };

    static PyObject* _new_ColorPicker(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_GET_SIZE(args);

        auto self_type = get_python_type_for<winrt::Microsoft::UI::Xaml::Controls::ColorPicker>();
        if (!self_type)
        {
            return nullptr;
        }

        if (arg_count == 0)
        {
            try
            {
                if (type != self_type)
                {
                    py::pyobj_handle self{type->tp_alloc(type, 0)};
                    if (!self)
                    {
                        return nullptr;
                    }

                    std::construct_at(&reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj, nullptr);

                    auto obj_impl = winrt::make_self<PyWinrtColorPicker>(self.get());

                    auto obj = py::make_py_obj<PyWinrtColorPicker>(obj_impl, type, self.get());
                    if (!obj)
                    {
                        return nullptr;
                    }

                    reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj = std::move(obj);

                    return self.detach();
                }

                winrt::Microsoft::UI::Xaml::Controls::ColorPicker instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ColorPicker(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ColorPicker_get_PreviousColor(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ColorPicker", L"PreviousColor");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::ColorPicker>().PreviousColor();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ColorPicker_put_PreviousColor(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ColorPicker", L"PreviousColor");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::UI::Color>>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::ColorPicker>().PreviousColor(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ColorPicker_get_MinValue(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ColorPicker", L"MinValue");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::ColorPicker>().MinValue();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ColorPicker_put_MinValue(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ColorPicker", L"MinValue");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<int32_t>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::ColorPicker>().MinValue(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ColorPicker_get_MinSaturation(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ColorPicker", L"MinSaturation");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::ColorPicker>().MinSaturation();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ColorPicker_put_MinSaturation(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ColorPicker", L"MinSaturation");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<int32_t>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::ColorPicker>().MinSaturation(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ColorPicker_get_MinHue(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ColorPicker", L"MinHue");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::ColorPicker>().MinHue();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ColorPicker_put_MinHue(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ColorPicker", L"MinHue");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<int32_t>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::ColorPicker>().MinHue(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ColorPicker_get_MaxValue(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ColorPicker", L"MaxValue");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::ColorPicker>().MaxValue();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ColorPicker_put_MaxValue(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ColorPicker", L"MaxValue");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<int32_t>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::ColorPicker>().MaxValue(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ColorPicker_get_MaxSaturation(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ColorPicker", L"MaxSaturation");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::ColorPicker>().MaxSaturation();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ColorPicker_put_MaxSaturation(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ColorPicker", L"MaxSaturation");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<int32_t>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::ColorPicker>().MaxSaturation(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ColorPicker_get_MaxHue(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ColorPicker", L"MaxHue");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::ColorPicker>().MaxHue();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ColorPicker_put_MaxHue(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ColorPicker", L"MaxHue");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<int32_t>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::ColorPicker>().MaxHue(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ColorPicker_get_IsMoreButtonVisible(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ColorPicker", L"IsMoreButtonVisible");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::ColorPicker>().IsMoreButtonVisible();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ColorPicker_put_IsMoreButtonVisible(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ColorPicker", L"IsMoreButtonVisible");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::ColorPicker>().IsMoreButtonVisible(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ColorPicker_get_IsHexInputVisible(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ColorPicker", L"IsHexInputVisible");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::ColorPicker>().IsHexInputVisible();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ColorPicker_put_IsHexInputVisible(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ColorPicker", L"IsHexInputVisible");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::ColorPicker>().IsHexInputVisible(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ColorPicker_get_IsColorSpectrumVisible(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ColorPicker", L"IsColorSpectrumVisible");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::ColorPicker>().IsColorSpectrumVisible();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ColorPicker_put_IsColorSpectrumVisible(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ColorPicker", L"IsColorSpectrumVisible");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::ColorPicker>().IsColorSpectrumVisible(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ColorPicker_get_IsColorSliderVisible(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ColorPicker", L"IsColorSliderVisible");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::ColorPicker>().IsColorSliderVisible();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ColorPicker_put_IsColorSliderVisible(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ColorPicker", L"IsColorSliderVisible");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::ColorPicker>().IsColorSliderVisible(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ColorPicker_get_IsColorPreviewVisible(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ColorPicker", L"IsColorPreviewVisible");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::ColorPicker>().IsColorPreviewVisible();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ColorPicker_put_IsColorPreviewVisible(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ColorPicker", L"IsColorPreviewVisible");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::ColorPicker>().IsColorPreviewVisible(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ColorPicker_get_IsColorChannelTextInputVisible(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ColorPicker", L"IsColorChannelTextInputVisible");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::ColorPicker>().IsColorChannelTextInputVisible();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ColorPicker_put_IsColorChannelTextInputVisible(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ColorPicker", L"IsColorChannelTextInputVisible");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::ColorPicker>().IsColorChannelTextInputVisible(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ColorPicker_get_IsAlphaTextInputVisible(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ColorPicker", L"IsAlphaTextInputVisible");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::ColorPicker>().IsAlphaTextInputVisible();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ColorPicker_put_IsAlphaTextInputVisible(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ColorPicker", L"IsAlphaTextInputVisible");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::ColorPicker>().IsAlphaTextInputVisible(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ColorPicker_get_IsAlphaSliderVisible(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ColorPicker", L"IsAlphaSliderVisible");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::ColorPicker>().IsAlphaSliderVisible();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ColorPicker_put_IsAlphaSliderVisible(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ColorPicker", L"IsAlphaSliderVisible");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::ColorPicker>().IsAlphaSliderVisible(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ColorPicker_get_IsAlphaEnabled(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ColorPicker", L"IsAlphaEnabled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::ColorPicker>().IsAlphaEnabled();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ColorPicker_put_IsAlphaEnabled(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ColorPicker", L"IsAlphaEnabled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::ColorPicker>().IsAlphaEnabled(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ColorPicker_get_ColorSpectrumShape(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ColorPicker", L"ColorSpectrumShape");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::ColorPicker>().ColorSpectrumShape();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ColorPicker_put_ColorSpectrumShape(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ColorPicker", L"ColorSpectrumShape");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::ColorSpectrumShape>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::ColorPicker>().ColorSpectrumShape(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ColorPicker_get_ColorSpectrumComponents(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ColorPicker", L"ColorSpectrumComponents");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::ColorPicker>().ColorSpectrumComponents();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ColorPicker_put_ColorSpectrumComponents(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ColorPicker", L"ColorSpectrumComponents");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::ColorSpectrumComponents>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::ColorPicker>().ColorSpectrumComponents(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ColorPicker_get_Color(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ColorPicker", L"Color");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::ColorPicker>().Color();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ColorPicker_put_Color(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ColorPicker", L"Color");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Color>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::ColorPicker>().Color(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ColorPicker_get_Orientation(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ColorPicker", L"Orientation");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::ColorPicker>().Orientation();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ColorPicker_put_Orientation(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ColorPicker", L"Orientation");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::Orientation>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::ColorPicker>().Orientation(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ColorPicker_get_ColorProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ColorPicker", L"ColorProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::ColorPicker::ColorProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ColorPicker_get_ColorSpectrumComponentsProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ColorPicker", L"ColorSpectrumComponentsProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::ColorPicker::ColorSpectrumComponentsProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ColorPicker_get_ColorSpectrumShapeProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ColorPicker", L"ColorSpectrumShapeProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::ColorPicker::ColorSpectrumShapeProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ColorPicker_get_IsAlphaEnabledProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ColorPicker", L"IsAlphaEnabledProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::ColorPicker::IsAlphaEnabledProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ColorPicker_get_IsAlphaSliderVisibleProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ColorPicker", L"IsAlphaSliderVisibleProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::ColorPicker::IsAlphaSliderVisibleProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ColorPicker_get_IsAlphaTextInputVisibleProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ColorPicker", L"IsAlphaTextInputVisibleProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::ColorPicker::IsAlphaTextInputVisibleProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ColorPicker_get_IsColorChannelTextInputVisibleProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ColorPicker", L"IsColorChannelTextInputVisibleProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::ColorPicker::IsColorChannelTextInputVisibleProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ColorPicker_get_IsColorPreviewVisibleProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ColorPicker", L"IsColorPreviewVisibleProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::ColorPicker::IsColorPreviewVisibleProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ColorPicker_get_IsColorSliderVisibleProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ColorPicker", L"IsColorSliderVisibleProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::ColorPicker::IsColorSliderVisibleProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ColorPicker_get_IsColorSpectrumVisibleProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ColorPicker", L"IsColorSpectrumVisibleProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::ColorPicker::IsColorSpectrumVisibleProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ColorPicker_get_IsHexInputVisibleProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ColorPicker", L"IsHexInputVisibleProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::ColorPicker::IsHexInputVisibleProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ColorPicker_get_IsMoreButtonVisibleProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ColorPicker", L"IsMoreButtonVisibleProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::ColorPicker::IsMoreButtonVisibleProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ColorPicker_get_MaxHueProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ColorPicker", L"MaxHueProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::ColorPicker::MaxHueProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ColorPicker_get_MaxSaturationProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ColorPicker", L"MaxSaturationProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::ColorPicker::MaxSaturationProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ColorPicker_get_MaxValueProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ColorPicker", L"MaxValueProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::ColorPicker::MaxValueProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ColorPicker_get_MinHueProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ColorPicker", L"MinHueProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::ColorPicker::MinHueProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ColorPicker_get_MinSaturationProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ColorPicker", L"MinSaturationProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::ColorPicker::MinSaturationProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ColorPicker_get_MinValueProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ColorPicker", L"MinValueProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::ColorPicker::MinValueProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ColorPicker_get_PreviousColorProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ColorPicker", L"PreviousColorProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::ColorPicker::PreviousColorProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ColorPicker_get_OrientationProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ColorPicker", L"OrientationProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::ColorPicker::OrientationProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ColorPicker_add_ColorChanged(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.ColorPicker", L"ColorChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Xaml::Controls::ColorPicker, winrt::Microsoft::UI::Xaml::Controls::ColorChangedEventArgs>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::ColorPicker>().ColorChanged(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ColorPicker_remove_ColorChanged(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.ColorPicker", L"ColorChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::ColorPicker>().ColorChanged(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ColorPicker(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::ColorPicker>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ColorPicker(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::ColorPicker>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ColorPicker[] = {
        { "add_color_changed", reinterpret_cast<PyCFunction>(ColorPicker_add_ColorChanged), METH_O, nullptr },
        { "remove_color_changed", reinterpret_cast<PyCFunction>(ColorPicker_remove_ColorChanged), METH_O, nullptr },
        { "_assign_array_", _assign_array_ColorPicker, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ColorPicker), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_ColorPicker[] = {
        { "previous_color", reinterpret_cast<getter>(ColorPicker_get_PreviousColor), reinterpret_cast<setter>(ColorPicker_put_PreviousColor), nullptr, nullptr },
        { "min_value", reinterpret_cast<getter>(ColorPicker_get_MinValue), reinterpret_cast<setter>(ColorPicker_put_MinValue), nullptr, nullptr },
        { "min_saturation", reinterpret_cast<getter>(ColorPicker_get_MinSaturation), reinterpret_cast<setter>(ColorPicker_put_MinSaturation), nullptr, nullptr },
        { "min_hue", reinterpret_cast<getter>(ColorPicker_get_MinHue), reinterpret_cast<setter>(ColorPicker_put_MinHue), nullptr, nullptr },
        { "max_value", reinterpret_cast<getter>(ColorPicker_get_MaxValue), reinterpret_cast<setter>(ColorPicker_put_MaxValue), nullptr, nullptr },
        { "max_saturation", reinterpret_cast<getter>(ColorPicker_get_MaxSaturation), reinterpret_cast<setter>(ColorPicker_put_MaxSaturation), nullptr, nullptr },
        { "max_hue", reinterpret_cast<getter>(ColorPicker_get_MaxHue), reinterpret_cast<setter>(ColorPicker_put_MaxHue), nullptr, nullptr },
        { "is_more_button_visible", reinterpret_cast<getter>(ColorPicker_get_IsMoreButtonVisible), reinterpret_cast<setter>(ColorPicker_put_IsMoreButtonVisible), nullptr, nullptr },
        { "is_hex_input_visible", reinterpret_cast<getter>(ColorPicker_get_IsHexInputVisible), reinterpret_cast<setter>(ColorPicker_put_IsHexInputVisible), nullptr, nullptr },
        { "is_color_spectrum_visible", reinterpret_cast<getter>(ColorPicker_get_IsColorSpectrumVisible), reinterpret_cast<setter>(ColorPicker_put_IsColorSpectrumVisible), nullptr, nullptr },
        { "is_color_slider_visible", reinterpret_cast<getter>(ColorPicker_get_IsColorSliderVisible), reinterpret_cast<setter>(ColorPicker_put_IsColorSliderVisible), nullptr, nullptr },
        { "is_color_preview_visible", reinterpret_cast<getter>(ColorPicker_get_IsColorPreviewVisible), reinterpret_cast<setter>(ColorPicker_put_IsColorPreviewVisible), nullptr, nullptr },
        { "is_color_channel_text_input_visible", reinterpret_cast<getter>(ColorPicker_get_IsColorChannelTextInputVisible), reinterpret_cast<setter>(ColorPicker_put_IsColorChannelTextInputVisible), nullptr, nullptr },
        { "is_alpha_text_input_visible", reinterpret_cast<getter>(ColorPicker_get_IsAlphaTextInputVisible), reinterpret_cast<setter>(ColorPicker_put_IsAlphaTextInputVisible), nullptr, nullptr },
        { "is_alpha_slider_visible", reinterpret_cast<getter>(ColorPicker_get_IsAlphaSliderVisible), reinterpret_cast<setter>(ColorPicker_put_IsAlphaSliderVisible), nullptr, nullptr },
        { "is_alpha_enabled", reinterpret_cast<getter>(ColorPicker_get_IsAlphaEnabled), reinterpret_cast<setter>(ColorPicker_put_IsAlphaEnabled), nullptr, nullptr },
        { "color_spectrum_shape", reinterpret_cast<getter>(ColorPicker_get_ColorSpectrumShape), reinterpret_cast<setter>(ColorPicker_put_ColorSpectrumShape), nullptr, nullptr },
        { "color_spectrum_components", reinterpret_cast<getter>(ColorPicker_get_ColorSpectrumComponents), reinterpret_cast<setter>(ColorPicker_put_ColorSpectrumComponents), nullptr, nullptr },
        { "color", reinterpret_cast<getter>(ColorPicker_get_Color), reinterpret_cast<setter>(ColorPicker_put_Color), nullptr, nullptr },
        { "orientation", reinterpret_cast<getter>(ColorPicker_get_Orientation), reinterpret_cast<setter>(ColorPicker_put_Orientation), nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_ColorPicker[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ColorPicker) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ColorPicker) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ColorPicker) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ColorPicker) },
        { }};

    static PyType_Spec type_spec_ColorPicker = {
        "winui2._winui2_microsoft_ui_xaml_controls.ColorPicker",
        sizeof(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_ColorPicker};

    static PyGetSetDef getset_ColorPicker_Static[] = {
        { "color_property", reinterpret_cast<getter>(ColorPicker_get_ColorProperty), nullptr, nullptr, nullptr },
        { "color_spectrum_components_property", reinterpret_cast<getter>(ColorPicker_get_ColorSpectrumComponentsProperty), nullptr, nullptr, nullptr },
        { "color_spectrum_shape_property", reinterpret_cast<getter>(ColorPicker_get_ColorSpectrumShapeProperty), nullptr, nullptr, nullptr },
        { "is_alpha_enabled_property", reinterpret_cast<getter>(ColorPicker_get_IsAlphaEnabledProperty), nullptr, nullptr, nullptr },
        { "is_alpha_slider_visible_property", reinterpret_cast<getter>(ColorPicker_get_IsAlphaSliderVisibleProperty), nullptr, nullptr, nullptr },
        { "is_alpha_text_input_visible_property", reinterpret_cast<getter>(ColorPicker_get_IsAlphaTextInputVisibleProperty), nullptr, nullptr, nullptr },
        { "is_color_channel_text_input_visible_property", reinterpret_cast<getter>(ColorPicker_get_IsColorChannelTextInputVisibleProperty), nullptr, nullptr, nullptr },
        { "is_color_preview_visible_property", reinterpret_cast<getter>(ColorPicker_get_IsColorPreviewVisibleProperty), nullptr, nullptr, nullptr },
        { "is_color_slider_visible_property", reinterpret_cast<getter>(ColorPicker_get_IsColorSliderVisibleProperty), nullptr, nullptr, nullptr },
        { "is_color_spectrum_visible_property", reinterpret_cast<getter>(ColorPicker_get_IsColorSpectrumVisibleProperty), nullptr, nullptr, nullptr },
        { "is_hex_input_visible_property", reinterpret_cast<getter>(ColorPicker_get_IsHexInputVisibleProperty), nullptr, nullptr, nullptr },
        { "is_more_button_visible_property", reinterpret_cast<getter>(ColorPicker_get_IsMoreButtonVisibleProperty), nullptr, nullptr, nullptr },
        { "max_hue_property", reinterpret_cast<getter>(ColorPicker_get_MaxHueProperty), nullptr, nullptr, nullptr },
        { "max_saturation_property", reinterpret_cast<getter>(ColorPicker_get_MaxSaturationProperty), nullptr, nullptr, nullptr },
        { "max_value_property", reinterpret_cast<getter>(ColorPicker_get_MaxValueProperty), nullptr, nullptr, nullptr },
        { "min_hue_property", reinterpret_cast<getter>(ColorPicker_get_MinHueProperty), nullptr, nullptr, nullptr },
        { "min_saturation_property", reinterpret_cast<getter>(ColorPicker_get_MinSaturationProperty), nullptr, nullptr, nullptr },
        { "min_value_property", reinterpret_cast<getter>(ColorPicker_get_MinValueProperty), nullptr, nullptr, nullptr },
        { "previous_color_property", reinterpret_cast<getter>(ColorPicker_get_PreviousColorProperty), nullptr, nullptr, nullptr },
        { "orientation_property", reinterpret_cast<getter>(ColorPicker_get_OrientationProperty), nullptr, nullptr, nullptr },
        { }};

    static PyMethodDef methods_ColorPicker_Static[] = {
        { }};

    static PyType_Slot type_slots_ColorPicker_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_ColorPicker_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_ColorPicker_Static) },
        { }
    };

    static PyType_Spec type_spec_ColorPicker_Static = {
        "winui2._winui2_microsoft_ui_xaml_controls.ColorPicker_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_ColorPicker_Static};

    // ----- CommandBarFlyout class --------------------

    struct PyWinrtCommandBarFlyout;
    using BasePyWinrtCommandBarFlyout = winrt::Microsoft::UI::Xaml::Controls::CommandBarFlyoutT<PyWinrtCommandBarFlyout, py::IPywinrtObject>;

    struct PyWinrtCommandBarFlyout : py::py_obj_ref, BasePyWinrtCommandBarFlyout
    {
        PyWinrtCommandBarFlyout(PyObject* py_obj) : py::py_obj_ref(py_obj), BasePyWinrtCommandBarFlyout() {}

        int32_t __stdcall GetPyObject(PyObject*& obj) override
        {
            obj = py::py_obj_ref::get_py_obj();
            return 0;
        }

        int32_t __stdcall GetComposableInner(winrt::Windows::Foundation::IInspectable& inner) override
        {
            inner = m_inner;
            return winrt::impl::error_ok;
        }

        static void toggle_reference(PyWinrtCommandBarFlyout* instance, bool is_last_reference)
        {
            py::py_obj_ref::toggle_reference(instance, is_last_reference);
        }

        int32_t query_interface_tearoff(winrt::guid const& id, void** result) const noexcept override
        {
            return py::py_obj_ref::query_interface_tearoff(id, result);
        }

        std::vector<winrt::guid> get_iids_tearoff() const noexcept override
        {
            return py::py_obj_ref::get_iids_tearoff();
        }
    };

    static PyObject* _new_CommandBarFlyout(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_GET_SIZE(args);

        auto self_type = get_python_type_for<winrt::Microsoft::UI::Xaml::Controls::CommandBarFlyout>();
        if (!self_type)
        {
            return nullptr;
        }

        if (arg_count == 0)
        {
            try
            {
                if (type != self_type)
                {
                    py::pyobj_handle self{type->tp_alloc(type, 0)};
                    if (!self)
                    {
                        return nullptr;
                    }

                    std::construct_at(&reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj, nullptr);

                    auto obj_impl = winrt::make_self<PyWinrtCommandBarFlyout>(self.get());

                    auto obj = py::make_py_obj<PyWinrtCommandBarFlyout>(obj_impl, type, self.get());
                    if (!obj)
                    {
                        return nullptr;
                    }

                    reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj = std::move(obj);

                    return self.detach();
                }

                winrt::Microsoft::UI::Xaml::Controls::CommandBarFlyout instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_CommandBarFlyout(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CommandBarFlyout_get_PrimaryCommands(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.CommandBarFlyout", L"PrimaryCommands");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::CommandBarFlyout>().PrimaryCommands();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CommandBarFlyout_get_SecondaryCommands(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.CommandBarFlyout", L"SecondaryCommands");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::CommandBarFlyout>().SecondaryCommands();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CommandBarFlyout_get_AlwaysExpanded(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.CommandBarFlyout", L"AlwaysExpanded");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::CommandBarFlyout>().AlwaysExpanded();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CommandBarFlyout_put_AlwaysExpanded(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.CommandBarFlyout", L"AlwaysExpanded");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::CommandBarFlyout>().AlwaysExpanded(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_CommandBarFlyout(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::CommandBarFlyout>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CommandBarFlyout(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::CommandBarFlyout>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CommandBarFlyout[] = {
        { "_assign_array_", _assign_array_CommandBarFlyout, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CommandBarFlyout), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_CommandBarFlyout[] = {
        { "primary_commands", reinterpret_cast<getter>(CommandBarFlyout_get_PrimaryCommands), nullptr, nullptr, nullptr },
        { "secondary_commands", reinterpret_cast<getter>(CommandBarFlyout_get_SecondaryCommands), nullptr, nullptr, nullptr },
        { "always_expanded", reinterpret_cast<getter>(CommandBarFlyout_get_AlwaysExpanded), reinterpret_cast<setter>(CommandBarFlyout_put_AlwaysExpanded), nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_CommandBarFlyout[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_CommandBarFlyout) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CommandBarFlyout) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CommandBarFlyout) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CommandBarFlyout) },
        { }};

    static PyType_Spec type_spec_CommandBarFlyout = {
        "winui2._winui2_microsoft_ui_xaml_controls.CommandBarFlyout",
        sizeof(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_CommandBarFlyout};

    static PyGetSetDef getset_CommandBarFlyout_Static[] = {
        { }};

    static PyMethodDef methods_CommandBarFlyout_Static[] = {
        { }};

    static PyType_Slot type_slots_CommandBarFlyout_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_CommandBarFlyout_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_CommandBarFlyout_Static) },
        { }
    };

    static PyType_Spec type_spec_CommandBarFlyout_Static = {
        "winui2._winui2_microsoft_ui_xaml_controls.CommandBarFlyout_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_CommandBarFlyout_Static};

    // ----- CoreWebView2InitializedEventArgs class --------------------

    static PyObject* _new_CoreWebView2InitializedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Xaml::Controls::CoreWebView2InitializedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Xaml::Controls::CoreWebView2InitializedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_CoreWebView2InitializedEventArgs(py::wrapper::Microsoft::UI::Xaml::Controls::CoreWebView2InitializedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CoreWebView2InitializedEventArgs_get_Exception(py::wrapper::Microsoft::UI::Xaml::Controls::CoreWebView2InitializedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.CoreWebView2InitializedEventArgs", L"Exception");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Exception();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_CoreWebView2InitializedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::CoreWebView2InitializedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CoreWebView2InitializedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::CoreWebView2InitializedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CoreWebView2InitializedEventArgs[] = {
        { "_assign_array_", _assign_array_CoreWebView2InitializedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CoreWebView2InitializedEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_CoreWebView2InitializedEventArgs[] = {
        { "exception", reinterpret_cast<getter>(CoreWebView2InitializedEventArgs_get_Exception), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_CoreWebView2InitializedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_CoreWebView2InitializedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CoreWebView2InitializedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CoreWebView2InitializedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CoreWebView2InitializedEventArgs) },
        { }};

    static PyType_Spec type_spec_CoreWebView2InitializedEventArgs = {
        "winui2._winui2_microsoft_ui_xaml_controls.CoreWebView2InitializedEventArgs",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Controls::CoreWebView2InitializedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CoreWebView2InitializedEventArgs};

    // ----- DropDownButton class --------------------

    struct PyWinrtDropDownButton;
    using BasePyWinrtDropDownButton = winrt::Microsoft::UI::Xaml::Controls::DropDownButtonT<PyWinrtDropDownButton, py::IPywinrtObject>;

    struct PyWinrtDropDownButton : py::py_obj_ref, BasePyWinrtDropDownButton
    {
        PyWinrtDropDownButton(PyObject* py_obj) : py::py_obj_ref(py_obj), BasePyWinrtDropDownButton() {}

        int32_t __stdcall GetPyObject(PyObject*& obj) override
        {
            obj = py::py_obj_ref::get_py_obj();
            return 0;
        }

        int32_t __stdcall GetComposableInner(winrt::Windows::Foundation::IInspectable& inner) override
        {
            inner = m_inner;
            return winrt::impl::error_ok;
        }

        static void toggle_reference(PyWinrtDropDownButton* instance, bool is_last_reference)
        {
            py::py_obj_ref::toggle_reference(instance, is_last_reference);
        }

        int32_t query_interface_tearoff(winrt::guid const& id, void** result) const noexcept override
        {
            return py::py_obj_ref::query_interface_tearoff(id, result);
        }

        std::vector<winrt::guid> get_iids_tearoff() const noexcept override
        {
            return py::py_obj_ref::get_iids_tearoff();
        }
    };

    static PyObject* _new_DropDownButton(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_GET_SIZE(args);

        auto self_type = get_python_type_for<winrt::Microsoft::UI::Xaml::Controls::DropDownButton>();
        if (!self_type)
        {
            return nullptr;
        }

        if (arg_count == 0)
        {
            try
            {
                if (type != self_type)
                {
                    py::pyobj_handle self{type->tp_alloc(type, 0)};
                    if (!self)
                    {
                        return nullptr;
                    }

                    std::construct_at(&reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj, nullptr);

                    auto obj_impl = winrt::make_self<PyWinrtDropDownButton>(self.get());

                    auto obj = py::make_py_obj<PyWinrtDropDownButton>(obj_impl, type, self.get());
                    if (!obj)
                    {
                        return nullptr;
                    }

                    reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj = std::move(obj);

                    return self.detach();
                }

                winrt::Microsoft::UI::Xaml::Controls::DropDownButton instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_DropDownButton(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_DropDownButton(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::DropDownButton>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_DropDownButton(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::DropDownButton>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DropDownButton[] = {
        { "_assign_array_", _assign_array_DropDownButton, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_DropDownButton), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_DropDownButton[] = {
        { }};

    static PyType_Slot _type_slots_DropDownButton[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_DropDownButton) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_DropDownButton) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_DropDownButton) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_DropDownButton) },
        { }};

    static PyType_Spec type_spec_DropDownButton = {
        "winui2._winui2_microsoft_ui_xaml_controls.DropDownButton",
        sizeof(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_DropDownButton};

    static PyGetSetDef getset_DropDownButton_Static[] = {
        { }};

    static PyMethodDef methods_DropDownButton_Static[] = {
        { }};

    static PyType_Slot type_slots_DropDownButton_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_DropDownButton_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_DropDownButton_Static) },
        { }
    };

    static PyType_Spec type_spec_DropDownButton_Static = {
        "winui2._winui2_microsoft_ui_xaml_controls.DropDownButton_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_DropDownButton_Static};

    // ----- ElementFactory class --------------------

    struct PyWinrtElementFactory;
    using BasePyWinrtElementFactory = winrt::Microsoft::UI::Xaml::Controls::ElementFactoryT<PyWinrtElementFactory, py::IPywinrtObject>;

    struct PyWinrtElementFactory : py::py_obj_ref, BasePyWinrtElementFactory
    {
        PyWinrtElementFactory(PyObject* py_obj) : py::py_obj_ref(py_obj), BasePyWinrtElementFactory() {}

        int32_t __stdcall GetPyObject(PyObject*& obj) override
        {
            obj = py::py_obj_ref::get_py_obj();
            return 0;
        }

        int32_t __stdcall GetComposableInner(winrt::Windows::Foundation::IInspectable& inner) override
        {
            inner = m_inner;
            return winrt::impl::error_ok;
        }

        static void toggle_reference(PyWinrtElementFactory* instance, bool is_last_reference)
        {
            py::py_obj_ref::toggle_reference(instance, is_last_reference);
        }

        int32_t query_interface_tearoff(winrt::guid const& id, void** result) const noexcept override
        {
            return py::py_obj_ref::query_interface_tearoff(id, result);
        }

        std::vector<winrt::guid> get_iids_tearoff() const noexcept override
        {
            return py::py_obj_ref::get_iids_tearoff();
        }

        winrt::Windows::UI::Xaml::UIElement GetElementCore(winrt::Microsoft::UI::Xaml::Controls::ElementFactoryGetArgs const& param0)
        {
            auto gil = py::ensure_gil();

            try
            {
                py::pyobj_handle self{get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "_get_element_core")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallOneArg(method.get(), py_param0.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::UI::Xaml::UIElement>(return_value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        void RecycleElementCore(winrt::Microsoft::UI::Xaml::Controls::ElementFactoryRecycleArgs const& param0)
        {
            auto gil = py::ensure_gil();

            try
            {
                py::pyobj_handle self{get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "_recycle_element_core")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallOneArg(method.get(), py_param0.get())};
                if (!return_value)
                {
                    throw python_exception();
                }
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }
    };

    static PyObject* _new_ElementFactory(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_GET_SIZE(args);

        auto self_type = get_python_type_for<winrt::Microsoft::UI::Xaml::Controls::ElementFactory>();
        if (!self_type)
        {
            return nullptr;
        }

        if (arg_count == 0)
        {
            try
            {
                if (type != self_type)
                {
                    py::pyobj_handle self{type->tp_alloc(type, 0)};
                    if (!self)
                    {
                        return nullptr;
                    }

                    std::construct_at(&reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj, nullptr);

                    auto obj_impl = winrt::make_self<PyWinrtElementFactory>(self.get());

                    auto obj = py::make_py_obj<PyWinrtElementFactory>(obj_impl, type, self.get());
                    if (!obj)
                    {
                        return nullptr;
                    }

                    reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj = std::move(obj);

                    return self.detach();
                }

                winrt::Microsoft::UI::Xaml::Controls::ElementFactory instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ElementFactory(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ElementFactory_GetElementCore(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.ElementFactory", L"GetElementCore", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::ElementFactoryGetArgs>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return py::get_inner_or_self(self->obj).try_as<winrt::Microsoft::UI::Xaml::Controls::IElementFactoryOverrides>().GetElementCore(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ElementFactory_RecycleElementCore(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.ElementFactory", L"RecycleElementCore", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::ElementFactoryRecycleArgs>(args, 0);

                {
                    auto _gil = release_gil();
                    py::get_inner_or_self(self->obj).try_as<winrt::Microsoft::UI::Xaml::Controls::IElementFactoryOverrides>().RecycleElementCore(param0);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_ElementFactory(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::ElementFactory>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ElementFactory(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::ElementFactory>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ElementFactory[] = {
        { "_get_element_core", reinterpret_cast<PyCFunction>(ElementFactory_GetElementCore), METH_VARARGS, nullptr },
        { "_recycle_element_core", reinterpret_cast<PyCFunction>(ElementFactory_RecycleElementCore), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_ElementFactory, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ElementFactory), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_ElementFactory[] = {
        { }};

    static PyType_Slot _type_slots_ElementFactory[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ElementFactory) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ElementFactory) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ElementFactory) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ElementFactory) },
        { }};

    static PyType_Spec type_spec_ElementFactory = {
        "winui2._winui2_microsoft_ui_xaml_controls.ElementFactory",
        sizeof(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_ElementFactory};

    static PyGetSetDef getset_ElementFactory_Static[] = {
        { }};

    static PyMethodDef methods_ElementFactory_Static[] = {
        { }};

    static PyType_Slot type_slots_ElementFactory_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_ElementFactory_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_ElementFactory_Static) },
        { }
    };

    static PyType_Spec type_spec_ElementFactory_Static = {
        "winui2._winui2_microsoft_ui_xaml_controls.ElementFactory_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_ElementFactory_Static};

    // ----- ElementFactoryGetArgs class --------------------

    static PyObject* _new_ElementFactoryGetArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_GET_SIZE(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Microsoft::UI::Xaml::Controls::ElementFactoryGetArgs instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ElementFactoryGetArgs(py::wrapper::Microsoft::UI::Xaml::Controls::ElementFactoryGetArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ElementFactoryGetArgs_get_Parent(py::wrapper::Microsoft::UI::Xaml::Controls::ElementFactoryGetArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ElementFactoryGetArgs", L"Parent");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Parent();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ElementFactoryGetArgs_put_Parent(py::wrapper::Microsoft::UI::Xaml::Controls::ElementFactoryGetArgs* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ElementFactoryGetArgs", L"Parent");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::UIElement>(arg);

            {
                auto _gil = release_gil();
                self->obj.Parent(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ElementFactoryGetArgs_get_Data(py::wrapper::Microsoft::UI::Xaml::Controls::ElementFactoryGetArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ElementFactoryGetArgs", L"Data");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Data();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ElementFactoryGetArgs_put_Data(py::wrapper::Microsoft::UI::Xaml::Controls::ElementFactoryGetArgs* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ElementFactoryGetArgs", L"Data");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);

            {
                auto _gil = release_gil();
                self->obj.Data(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_ElementFactoryGetArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::ElementFactoryGetArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ElementFactoryGetArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::ElementFactoryGetArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ElementFactoryGetArgs[] = {
        { "_assign_array_", _assign_array_ElementFactoryGetArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ElementFactoryGetArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_ElementFactoryGetArgs[] = {
        { "parent", reinterpret_cast<getter>(ElementFactoryGetArgs_get_Parent), reinterpret_cast<setter>(ElementFactoryGetArgs_put_Parent), nullptr, nullptr },
        { "data", reinterpret_cast<getter>(ElementFactoryGetArgs_get_Data), reinterpret_cast<setter>(ElementFactoryGetArgs_put_Data), nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_ElementFactoryGetArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ElementFactoryGetArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ElementFactoryGetArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ElementFactoryGetArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ElementFactoryGetArgs) },
        { }};

    static PyType_Spec type_spec_ElementFactoryGetArgs = {
        "winui2._winui2_microsoft_ui_xaml_controls.ElementFactoryGetArgs",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Controls::ElementFactoryGetArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ElementFactoryGetArgs};

    // ----- ElementFactoryRecycleArgs class --------------------

    static PyObject* _new_ElementFactoryRecycleArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_GET_SIZE(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Microsoft::UI::Xaml::Controls::ElementFactoryRecycleArgs instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ElementFactoryRecycleArgs(py::wrapper::Microsoft::UI::Xaml::Controls::ElementFactoryRecycleArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ElementFactoryRecycleArgs_get_Parent(py::wrapper::Microsoft::UI::Xaml::Controls::ElementFactoryRecycleArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ElementFactoryRecycleArgs", L"Parent");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Parent();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ElementFactoryRecycleArgs_put_Parent(py::wrapper::Microsoft::UI::Xaml::Controls::ElementFactoryRecycleArgs* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ElementFactoryRecycleArgs", L"Parent");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::UIElement>(arg);

            {
                auto _gil = release_gil();
                self->obj.Parent(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ElementFactoryRecycleArgs_get_Element(py::wrapper::Microsoft::UI::Xaml::Controls::ElementFactoryRecycleArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ElementFactoryRecycleArgs", L"Element");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Element();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ElementFactoryRecycleArgs_put_Element(py::wrapper::Microsoft::UI::Xaml::Controls::ElementFactoryRecycleArgs* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ElementFactoryRecycleArgs", L"Element");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::UIElement>(arg);

            {
                auto _gil = release_gil();
                self->obj.Element(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_ElementFactoryRecycleArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::ElementFactoryRecycleArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ElementFactoryRecycleArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::ElementFactoryRecycleArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ElementFactoryRecycleArgs[] = {
        { "_assign_array_", _assign_array_ElementFactoryRecycleArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ElementFactoryRecycleArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_ElementFactoryRecycleArgs[] = {
        { "parent", reinterpret_cast<getter>(ElementFactoryRecycleArgs_get_Parent), reinterpret_cast<setter>(ElementFactoryRecycleArgs_put_Parent), nullptr, nullptr },
        { "element", reinterpret_cast<getter>(ElementFactoryRecycleArgs_get_Element), reinterpret_cast<setter>(ElementFactoryRecycleArgs_put_Element), nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_ElementFactoryRecycleArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ElementFactoryRecycleArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ElementFactoryRecycleArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ElementFactoryRecycleArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ElementFactoryRecycleArgs) },
        { }};

    static PyType_Spec type_spec_ElementFactoryRecycleArgs = {
        "winui2._winui2_microsoft_ui_xaml_controls.ElementFactoryRecycleArgs",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Controls::ElementFactoryRecycleArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ElementFactoryRecycleArgs};

    // ----- Expander class --------------------

    struct PyWinrtExpander;
    using BasePyWinrtExpander = winrt::Microsoft::UI::Xaml::Controls::ExpanderT<PyWinrtExpander, py::IPywinrtObject>;

    struct PyWinrtExpander : py::py_obj_ref, BasePyWinrtExpander
    {
        PyWinrtExpander(PyObject* py_obj) : py::py_obj_ref(py_obj), BasePyWinrtExpander() {}

        int32_t __stdcall GetPyObject(PyObject*& obj) override
        {
            obj = py::py_obj_ref::get_py_obj();
            return 0;
        }

        int32_t __stdcall GetComposableInner(winrt::Windows::Foundation::IInspectable& inner) override
        {
            inner = m_inner;
            return winrt::impl::error_ok;
        }

        static void toggle_reference(PyWinrtExpander* instance, bool is_last_reference)
        {
            py::py_obj_ref::toggle_reference(instance, is_last_reference);
        }

        int32_t query_interface_tearoff(winrt::guid const& id, void** result) const noexcept override
        {
            return py::py_obj_ref::query_interface_tearoff(id, result);
        }

        std::vector<winrt::guid> get_iids_tearoff() const noexcept override
        {
            return py::py_obj_ref::get_iids_tearoff();
        }
    };

    static PyObject* _new_Expander(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_GET_SIZE(args);

        auto self_type = get_python_type_for<winrt::Microsoft::UI::Xaml::Controls::Expander>();
        if (!self_type)
        {
            return nullptr;
        }

        if (arg_count == 0)
        {
            try
            {
                if (type != self_type)
                {
                    py::pyobj_handle self{type->tp_alloc(type, 0)};
                    if (!self)
                    {
                        return nullptr;
                    }

                    std::construct_at(&reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj, nullptr);

                    auto obj_impl = winrt::make_self<PyWinrtExpander>(self.get());

                    auto obj = py::make_py_obj<PyWinrtExpander>(obj_impl, type, self.get());
                    if (!obj)
                    {
                        return nullptr;
                    }

                    reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj = std::move(obj);

                    return self.detach();
                }

                winrt::Microsoft::UI::Xaml::Controls::Expander instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_Expander(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* Expander_get_IsExpanded(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Expander", L"IsExpanded");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Expander>().IsExpanded();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Expander_put_IsExpanded(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Expander", L"IsExpanded");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Expander>().IsExpanded(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Expander_get_HeaderTemplateSelector(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Expander", L"HeaderTemplateSelector");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Expander>().HeaderTemplateSelector();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Expander_put_HeaderTemplateSelector(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Expander", L"HeaderTemplateSelector");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::DataTemplateSelector>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Expander>().HeaderTemplateSelector(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Expander_get_HeaderTemplate(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Expander", L"HeaderTemplate");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Expander>().HeaderTemplate();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Expander_put_HeaderTemplate(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Expander", L"HeaderTemplate");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::DataTemplate>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Expander>().HeaderTemplate(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Expander_get_Header(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Expander", L"Header");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Expander>().Header();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Expander_put_Header(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Expander", L"Header");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Expander>().Header(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Expander_get_ExpandDirection(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Expander", L"ExpandDirection");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Expander>().ExpandDirection();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Expander_put_ExpandDirection(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Expander", L"ExpandDirection");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::ExpandDirection>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Expander>().ExpandDirection(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Expander_get_TemplateSettings(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Expander", L"TemplateSettings");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Expander>().TemplateSettings();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Expander_get_ExpandDirectionProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Expander", L"ExpandDirectionProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::Expander::ExpandDirectionProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Expander_get_HeaderProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Expander", L"HeaderProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::Expander::HeaderProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Expander_get_HeaderTemplateProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Expander", L"HeaderTemplateProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::Expander::HeaderTemplateProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Expander_get_HeaderTemplateSelectorProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Expander", L"HeaderTemplateSelectorProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::Expander::HeaderTemplateSelectorProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Expander_get_IsExpandedProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Expander", L"IsExpandedProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::Expander::IsExpandedProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Expander_add_Collapsed(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.Expander", L"Collapsed");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Xaml::Controls::Expander, winrt::Microsoft::UI::Xaml::Controls::ExpanderCollapsedEventArgs>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Expander>().Collapsed(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Expander_remove_Collapsed(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.Expander", L"Collapsed");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Expander>().Collapsed(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Expander_add_Expanding(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.Expander", L"Expanding");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Xaml::Controls::Expander, winrt::Microsoft::UI::Xaml::Controls::ExpanderExpandingEventArgs>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Expander>().Expanding(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Expander_remove_Expanding(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.Expander", L"Expanding");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Expander>().Expanding(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_Expander(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::Expander>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_Expander(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::Expander>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_Expander[] = {
        { "add_collapsed", reinterpret_cast<PyCFunction>(Expander_add_Collapsed), METH_O, nullptr },
        { "remove_collapsed", reinterpret_cast<PyCFunction>(Expander_remove_Collapsed), METH_O, nullptr },
        { "add_expanding", reinterpret_cast<PyCFunction>(Expander_add_Expanding), METH_O, nullptr },
        { "remove_expanding", reinterpret_cast<PyCFunction>(Expander_remove_Expanding), METH_O, nullptr },
        { "_assign_array_", _assign_array_Expander, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_Expander), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_Expander[] = {
        { "is_expanded", reinterpret_cast<getter>(Expander_get_IsExpanded), reinterpret_cast<setter>(Expander_put_IsExpanded), nullptr, nullptr },
        { "header_template_selector", reinterpret_cast<getter>(Expander_get_HeaderTemplateSelector), reinterpret_cast<setter>(Expander_put_HeaderTemplateSelector), nullptr, nullptr },
        { "header_template", reinterpret_cast<getter>(Expander_get_HeaderTemplate), reinterpret_cast<setter>(Expander_put_HeaderTemplate), nullptr, nullptr },
        { "header", reinterpret_cast<getter>(Expander_get_Header), reinterpret_cast<setter>(Expander_put_Header), nullptr, nullptr },
        { "expand_direction", reinterpret_cast<getter>(Expander_get_ExpandDirection), reinterpret_cast<setter>(Expander_put_ExpandDirection), nullptr, nullptr },
        { "template_settings", reinterpret_cast<getter>(Expander_get_TemplateSettings), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_Expander[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_Expander) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_Expander) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_Expander) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_Expander) },
        { }};

    static PyType_Spec type_spec_Expander = {
        "winui2._winui2_microsoft_ui_xaml_controls.Expander",
        sizeof(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_Expander};

    static PyGetSetDef getset_Expander_Static[] = {
        { "expand_direction_property", reinterpret_cast<getter>(Expander_get_ExpandDirectionProperty), nullptr, nullptr, nullptr },
        { "header_property", reinterpret_cast<getter>(Expander_get_HeaderProperty), nullptr, nullptr, nullptr },
        { "header_template_property", reinterpret_cast<getter>(Expander_get_HeaderTemplateProperty), nullptr, nullptr, nullptr },
        { "header_template_selector_property", reinterpret_cast<getter>(Expander_get_HeaderTemplateSelectorProperty), nullptr, nullptr, nullptr },
        { "is_expanded_property", reinterpret_cast<getter>(Expander_get_IsExpandedProperty), nullptr, nullptr, nullptr },
        { }};

    static PyMethodDef methods_Expander_Static[] = {
        { }};

    static PyType_Slot type_slots_Expander_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_Expander_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_Expander_Static) },
        { }
    };

    static PyType_Spec type_spec_Expander_Static = {
        "winui2._winui2_microsoft_ui_xaml_controls.Expander_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_Expander_Static};

    // ----- ExpanderCollapsedEventArgs class --------------------

    static PyObject* _new_ExpanderCollapsedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Xaml::Controls::ExpanderCollapsedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Xaml::Controls::ExpanderCollapsedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_ExpanderCollapsedEventArgs(py::wrapper::Microsoft::UI::Xaml::Controls::ExpanderCollapsedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_ExpanderCollapsedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::ExpanderCollapsedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ExpanderCollapsedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::ExpanderCollapsedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ExpanderCollapsedEventArgs[] = {
        { "_assign_array_", _assign_array_ExpanderCollapsedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ExpanderCollapsedEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_ExpanderCollapsedEventArgs[] = {
        { }};

    static PyType_Slot _type_slots_ExpanderCollapsedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ExpanderCollapsedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ExpanderCollapsedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ExpanderCollapsedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ExpanderCollapsedEventArgs) },
        { }};

    static PyType_Spec type_spec_ExpanderCollapsedEventArgs = {
        "winui2._winui2_microsoft_ui_xaml_controls.ExpanderCollapsedEventArgs",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Controls::ExpanderCollapsedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ExpanderCollapsedEventArgs};

    // ----- ExpanderExpandingEventArgs class --------------------

    static PyObject* _new_ExpanderExpandingEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Xaml::Controls::ExpanderExpandingEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Xaml::Controls::ExpanderExpandingEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_ExpanderExpandingEventArgs(py::wrapper::Microsoft::UI::Xaml::Controls::ExpanderExpandingEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_ExpanderExpandingEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::ExpanderExpandingEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ExpanderExpandingEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::ExpanderExpandingEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ExpanderExpandingEventArgs[] = {
        { "_assign_array_", _assign_array_ExpanderExpandingEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ExpanderExpandingEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_ExpanderExpandingEventArgs[] = {
        { }};

    static PyType_Slot _type_slots_ExpanderExpandingEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ExpanderExpandingEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ExpanderExpandingEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ExpanderExpandingEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ExpanderExpandingEventArgs) },
        { }};

    static PyType_Spec type_spec_ExpanderExpandingEventArgs = {
        "winui2._winui2_microsoft_ui_xaml_controls.ExpanderExpandingEventArgs",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Controls::ExpanderExpandingEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ExpanderExpandingEventArgs};

    // ----- ExpanderTemplateSettings class --------------------

    static PyObject* _new_ExpanderTemplateSettings(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Xaml::Controls::ExpanderTemplateSettings>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Xaml::Controls::ExpanderTemplateSettings>::type_name);
        return nullptr;
    }

    static void _dealloc_ExpanderTemplateSettings(py::wrapper::Microsoft::UI::Xaml::Controls::ExpanderTemplateSettings* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ExpanderTemplateSettings_get_ContentHeight(py::wrapper::Microsoft::UI::Xaml::Controls::ExpanderTemplateSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ExpanderTemplateSettings", L"ContentHeight");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ContentHeight();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ExpanderTemplateSettings_get_NegativeContentHeight(py::wrapper::Microsoft::UI::Xaml::Controls::ExpanderTemplateSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ExpanderTemplateSettings", L"NegativeContentHeight");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.NegativeContentHeight();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ExpanderTemplateSettings(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::ExpanderTemplateSettings>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ExpanderTemplateSettings(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::ExpanderTemplateSettings>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ExpanderTemplateSettings[] = {
        { "_assign_array_", _assign_array_ExpanderTemplateSettings, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ExpanderTemplateSettings), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_ExpanderTemplateSettings[] = {
        { "content_height", reinterpret_cast<getter>(ExpanderTemplateSettings_get_ContentHeight), nullptr, nullptr, nullptr },
        { "negative_content_height", reinterpret_cast<getter>(ExpanderTemplateSettings_get_NegativeContentHeight), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_ExpanderTemplateSettings[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ExpanderTemplateSettings) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ExpanderTemplateSettings) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ExpanderTemplateSettings) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ExpanderTemplateSettings) },
        { }};

    static PyType_Spec type_spec_ExpanderTemplateSettings = {
        "winui2._winui2_microsoft_ui_xaml_controls.ExpanderTemplateSettings",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Controls::ExpanderTemplateSettings),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ExpanderTemplateSettings};

    // ----- FontIconSource class --------------------

    struct PyWinrtFontIconSource;
    using BasePyWinrtFontIconSource = winrt::Microsoft::UI::Xaml::Controls::FontIconSourceT<PyWinrtFontIconSource, py::IPywinrtObject>;

    struct PyWinrtFontIconSource : py::py_obj_ref, BasePyWinrtFontIconSource
    {
        PyWinrtFontIconSource(PyObject* py_obj) : py::py_obj_ref(py_obj), BasePyWinrtFontIconSource() {}

        int32_t __stdcall GetPyObject(PyObject*& obj) override
        {
            obj = py::py_obj_ref::get_py_obj();
            return 0;
        }

        int32_t __stdcall GetComposableInner(winrt::Windows::Foundation::IInspectable& inner) override
        {
            inner = m_inner;
            return winrt::impl::error_ok;
        }

        static void toggle_reference(PyWinrtFontIconSource* instance, bool is_last_reference)
        {
            py::py_obj_ref::toggle_reference(instance, is_last_reference);
        }

        int32_t query_interface_tearoff(winrt::guid const& id, void** result) const noexcept override
        {
            return py::py_obj_ref::query_interface_tearoff(id, result);
        }

        std::vector<winrt::guid> get_iids_tearoff() const noexcept override
        {
            return py::py_obj_ref::get_iids_tearoff();
        }
    };

    static PyObject* _new_FontIconSource(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_GET_SIZE(args);

        auto self_type = get_python_type_for<winrt::Microsoft::UI::Xaml::Controls::FontIconSource>();
        if (!self_type)
        {
            return nullptr;
        }

        if (arg_count == 0)
        {
            try
            {
                if (type != self_type)
                {
                    py::pyobj_handle self{type->tp_alloc(type, 0)};
                    if (!self)
                    {
                        return nullptr;
                    }

                    std::construct_at(&reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj, nullptr);

                    auto obj_impl = winrt::make_self<PyWinrtFontIconSource>(self.get());

                    auto obj = py::make_py_obj<PyWinrtFontIconSource>(obj_impl, type, self.get());
                    if (!obj)
                    {
                        return nullptr;
                    }

                    reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj = std::move(obj);

                    return self.detach();
                }

                winrt::Microsoft::UI::Xaml::Controls::FontIconSource instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_FontIconSource(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* FontIconSource_get_MirroredWhenRightToLeft(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.FontIconSource", L"MirroredWhenRightToLeft");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::FontIconSource>().MirroredWhenRightToLeft();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int FontIconSource_put_MirroredWhenRightToLeft(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.FontIconSource", L"MirroredWhenRightToLeft");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::FontIconSource>().MirroredWhenRightToLeft(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* FontIconSource_get_IsTextScaleFactorEnabled(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.FontIconSource", L"IsTextScaleFactorEnabled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::FontIconSource>().IsTextScaleFactorEnabled();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int FontIconSource_put_IsTextScaleFactorEnabled(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.FontIconSource", L"IsTextScaleFactorEnabled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::FontIconSource>().IsTextScaleFactorEnabled(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* FontIconSource_get_Glyph(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.FontIconSource", L"Glyph");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::FontIconSource>().Glyph();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int FontIconSource_put_Glyph(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.FontIconSource", L"Glyph");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::FontIconSource>().Glyph(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* FontIconSource_get_FontWeight(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.FontIconSource", L"FontWeight");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::FontIconSource>().FontWeight();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int FontIconSource_put_FontWeight(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.FontIconSource", L"FontWeight");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Text::FontWeight>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::FontIconSource>().FontWeight(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* FontIconSource_get_FontStyle(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.FontIconSource", L"FontStyle");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::FontIconSource>().FontStyle();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int FontIconSource_put_FontStyle(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.FontIconSource", L"FontStyle");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Text::FontStyle>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::FontIconSource>().FontStyle(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* FontIconSource_get_FontSize(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.FontIconSource", L"FontSize");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::FontIconSource>().FontSize();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int FontIconSource_put_FontSize(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.FontIconSource", L"FontSize");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<double>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::FontIconSource>().FontSize(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* FontIconSource_get_FontFamily(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.FontIconSource", L"FontFamily");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::FontIconSource>().FontFamily();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int FontIconSource_put_FontFamily(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.FontIconSource", L"FontFamily");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Media::FontFamily>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::FontIconSource>().FontFamily(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* FontIconSource_get_FontFamilyProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.FontIconSource", L"FontFamilyProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::FontIconSource::FontFamilyProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FontIconSource_get_FontSizeProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.FontIconSource", L"FontSizeProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::FontIconSource::FontSizeProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FontIconSource_get_FontStyleProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.FontIconSource", L"FontStyleProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::FontIconSource::FontStyleProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FontIconSource_get_FontWeightProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.FontIconSource", L"FontWeightProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::FontIconSource::FontWeightProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FontIconSource_get_GlyphProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.FontIconSource", L"GlyphProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::FontIconSource::GlyphProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FontIconSource_get_IsTextScaleFactorEnabledProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.FontIconSource", L"IsTextScaleFactorEnabledProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::FontIconSource::IsTextScaleFactorEnabledProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FontIconSource_get_MirroredWhenRightToLeftProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.FontIconSource", L"MirroredWhenRightToLeftProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::FontIconSource::MirroredWhenRightToLeftProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_FontIconSource(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::FontIconSource>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_FontIconSource(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::FontIconSource>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_FontIconSource[] = {
        { "_assign_array_", _assign_array_FontIconSource, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_FontIconSource), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_FontIconSource[] = {
        { "mirrored_when_right_to_left", reinterpret_cast<getter>(FontIconSource_get_MirroredWhenRightToLeft), reinterpret_cast<setter>(FontIconSource_put_MirroredWhenRightToLeft), nullptr, nullptr },
        { "is_text_scale_factor_enabled", reinterpret_cast<getter>(FontIconSource_get_IsTextScaleFactorEnabled), reinterpret_cast<setter>(FontIconSource_put_IsTextScaleFactorEnabled), nullptr, nullptr },
        { "glyph", reinterpret_cast<getter>(FontIconSource_get_Glyph), reinterpret_cast<setter>(FontIconSource_put_Glyph), nullptr, nullptr },
        { "font_weight", reinterpret_cast<getter>(FontIconSource_get_FontWeight), reinterpret_cast<setter>(FontIconSource_put_FontWeight), nullptr, nullptr },
        { "font_style", reinterpret_cast<getter>(FontIconSource_get_FontStyle), reinterpret_cast<setter>(FontIconSource_put_FontStyle), nullptr, nullptr },
        { "font_size", reinterpret_cast<getter>(FontIconSource_get_FontSize), reinterpret_cast<setter>(FontIconSource_put_FontSize), nullptr, nullptr },
        { "font_family", reinterpret_cast<getter>(FontIconSource_get_FontFamily), reinterpret_cast<setter>(FontIconSource_put_FontFamily), nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_FontIconSource[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_FontIconSource) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_FontIconSource) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_FontIconSource) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_FontIconSource) },
        { }};

    static PyType_Spec type_spec_FontIconSource = {
        "winui2._winui2_microsoft_ui_xaml_controls.FontIconSource",
        sizeof(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_FontIconSource};

    static PyGetSetDef getset_FontIconSource_Static[] = {
        { "font_family_property", reinterpret_cast<getter>(FontIconSource_get_FontFamilyProperty), nullptr, nullptr, nullptr },
        { "font_size_property", reinterpret_cast<getter>(FontIconSource_get_FontSizeProperty), nullptr, nullptr, nullptr },
        { "font_style_property", reinterpret_cast<getter>(FontIconSource_get_FontStyleProperty), nullptr, nullptr, nullptr },
        { "font_weight_property", reinterpret_cast<getter>(FontIconSource_get_FontWeightProperty), nullptr, nullptr, nullptr },
        { "glyph_property", reinterpret_cast<getter>(FontIconSource_get_GlyphProperty), nullptr, nullptr, nullptr },
        { "is_text_scale_factor_enabled_property", reinterpret_cast<getter>(FontIconSource_get_IsTextScaleFactorEnabledProperty), nullptr, nullptr, nullptr },
        { "mirrored_when_right_to_left_property", reinterpret_cast<getter>(FontIconSource_get_MirroredWhenRightToLeftProperty), nullptr, nullptr, nullptr },
        { }};

    static PyMethodDef methods_FontIconSource_Static[] = {
        { }};

    static PyType_Slot type_slots_FontIconSource_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_FontIconSource_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_FontIconSource_Static) },
        { }
    };

    static PyType_Spec type_spec_FontIconSource_Static = {
        "winui2._winui2_microsoft_ui_xaml_controls.FontIconSource_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_FontIconSource_Static};

    // ----- IconSource class --------------------

    static PyObject* _new_IconSource(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Xaml::Controls::IconSource>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Xaml::Controls::IconSource>::type_name);
        return nullptr;
    }

    static void _dealloc_IconSource(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IconSource_CreateIconElement(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.IconSource", L"CreateIconElement", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::IconSource>().CreateIconElement();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IconSource_get_Foreground(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.IconSource", L"Foreground");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::IconSource>().Foreground();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IconSource_put_Foreground(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.IconSource", L"Foreground");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Media::Brush>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::IconSource>().Foreground(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* IconSource_get_ForegroundProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.IconSource", L"ForegroundProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::IconSource::ForegroundProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_IconSource(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::IconSource>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IconSource(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::IconSource>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IconSource[] = {
        { "create_icon_element", reinterpret_cast<PyCFunction>(IconSource_CreateIconElement), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_IconSource, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IconSource), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_IconSource[] = {
        { "foreground", reinterpret_cast<getter>(IconSource_get_Foreground), reinterpret_cast<setter>(IconSource_put_Foreground), nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_IconSource[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_IconSource) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IconSource) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IconSource) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IconSource) },
        { }};

    static PyType_Spec type_spec_IconSource = {
        "winui2._winui2_microsoft_ui_xaml_controls.IconSource",
        sizeof(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_IconSource};

    static PyGetSetDef getset_IconSource_Static[] = {
        { "foreground_property", reinterpret_cast<getter>(IconSource_get_ForegroundProperty), nullptr, nullptr, nullptr },
        { }};

    static PyMethodDef methods_IconSource_Static[] = {
        { }};

    static PyType_Slot type_slots_IconSource_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_IconSource_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_IconSource_Static) },
        { }
    };

    static PyType_Spec type_spec_IconSource_Static = {
        "winui2._winui2_microsoft_ui_xaml_controls.IconSource_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_IconSource_Static};

    // ----- ImageIcon class --------------------

    struct PyWinrtImageIcon;
    using BasePyWinrtImageIcon = winrt::Microsoft::UI::Xaml::Controls::ImageIconT<PyWinrtImageIcon, py::IPywinrtObject>;

    struct PyWinrtImageIcon : py::py_obj_ref, BasePyWinrtImageIcon
    {
        PyWinrtImageIcon(PyObject* py_obj) : py::py_obj_ref(py_obj), BasePyWinrtImageIcon() {}

        int32_t __stdcall GetPyObject(PyObject*& obj) override
        {
            obj = py::py_obj_ref::get_py_obj();
            return 0;
        }

        int32_t __stdcall GetComposableInner(winrt::Windows::Foundation::IInspectable& inner) override
        {
            inner = m_inner;
            return winrt::impl::error_ok;
        }

        static void toggle_reference(PyWinrtImageIcon* instance, bool is_last_reference)
        {
            py::py_obj_ref::toggle_reference(instance, is_last_reference);
        }

        int32_t query_interface_tearoff(winrt::guid const& id, void** result) const noexcept override
        {
            return py::py_obj_ref::query_interface_tearoff(id, result);
        }

        std::vector<winrt::guid> get_iids_tearoff() const noexcept override
        {
            return py::py_obj_ref::get_iids_tearoff();
        }
    };

    static PyObject* _new_ImageIcon(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_GET_SIZE(args);

        auto self_type = get_python_type_for<winrt::Microsoft::UI::Xaml::Controls::ImageIcon>();
        if (!self_type)
        {
            return nullptr;
        }

        if (arg_count == 0)
        {
            try
            {
                if (type != self_type)
                {
                    py::pyobj_handle self{type->tp_alloc(type, 0)};
                    if (!self)
                    {
                        return nullptr;
                    }

                    std::construct_at(&reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj, nullptr);

                    auto obj_impl = winrt::make_self<PyWinrtImageIcon>(self.get());

                    auto obj = py::make_py_obj<PyWinrtImageIcon>(obj_impl, type, self.get());
                    if (!obj)
                    {
                        return nullptr;
                    }

                    reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj = std::move(obj);

                    return self.detach();
                }

                winrt::Microsoft::UI::Xaml::Controls::ImageIcon instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ImageIcon(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ImageIcon_get_Source(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ImageIcon", L"Source");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::ImageIcon>().Source();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ImageIcon_put_Source(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ImageIcon", L"Source");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Media::ImageSource>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::ImageIcon>().Source(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ImageIcon_get_SourceProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ImageIcon", L"SourceProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::ImageIcon::SourceProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ImageIcon(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::ImageIcon>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ImageIcon(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::ImageIcon>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ImageIcon[] = {
        { "_assign_array_", _assign_array_ImageIcon, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ImageIcon), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_ImageIcon[] = {
        { "source", reinterpret_cast<getter>(ImageIcon_get_Source), reinterpret_cast<setter>(ImageIcon_put_Source), nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_ImageIcon[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ImageIcon) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ImageIcon) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ImageIcon) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ImageIcon) },
        { }};

    static PyType_Spec type_spec_ImageIcon = {
        "winui2._winui2_microsoft_ui_xaml_controls.ImageIcon",
        sizeof(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_ImageIcon};

    static PyGetSetDef getset_ImageIcon_Static[] = {
        { "source_property", reinterpret_cast<getter>(ImageIcon_get_SourceProperty), nullptr, nullptr, nullptr },
        { }};

    static PyMethodDef methods_ImageIcon_Static[] = {
        { }};

    static PyType_Slot type_slots_ImageIcon_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_ImageIcon_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_ImageIcon_Static) },
        { }
    };

    static PyType_Spec type_spec_ImageIcon_Static = {
        "winui2._winui2_microsoft_ui_xaml_controls.ImageIcon_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_ImageIcon_Static};

    // ----- ImageIconSource class --------------------

    struct PyWinrtImageIconSource;
    using BasePyWinrtImageIconSource = winrt::Microsoft::UI::Xaml::Controls::ImageIconSourceT<PyWinrtImageIconSource, py::IPywinrtObject>;

    struct PyWinrtImageIconSource : py::py_obj_ref, BasePyWinrtImageIconSource
    {
        PyWinrtImageIconSource(PyObject* py_obj) : py::py_obj_ref(py_obj), BasePyWinrtImageIconSource() {}

        int32_t __stdcall GetPyObject(PyObject*& obj) override
        {
            obj = py::py_obj_ref::get_py_obj();
            return 0;
        }

        int32_t __stdcall GetComposableInner(winrt::Windows::Foundation::IInspectable& inner) override
        {
            inner = m_inner;
            return winrt::impl::error_ok;
        }

        static void toggle_reference(PyWinrtImageIconSource* instance, bool is_last_reference)
        {
            py::py_obj_ref::toggle_reference(instance, is_last_reference);
        }

        int32_t query_interface_tearoff(winrt::guid const& id, void** result) const noexcept override
        {
            return py::py_obj_ref::query_interface_tearoff(id, result);
        }

        std::vector<winrt::guid> get_iids_tearoff() const noexcept override
        {
            return py::py_obj_ref::get_iids_tearoff();
        }
    };

    static PyObject* _new_ImageIconSource(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_GET_SIZE(args);

        auto self_type = get_python_type_for<winrt::Microsoft::UI::Xaml::Controls::ImageIconSource>();
        if (!self_type)
        {
            return nullptr;
        }

        if (arg_count == 0)
        {
            try
            {
                if (type != self_type)
                {
                    py::pyobj_handle self{type->tp_alloc(type, 0)};
                    if (!self)
                    {
                        return nullptr;
                    }

                    std::construct_at(&reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj, nullptr);

                    auto obj_impl = winrt::make_self<PyWinrtImageIconSource>(self.get());

                    auto obj = py::make_py_obj<PyWinrtImageIconSource>(obj_impl, type, self.get());
                    if (!obj)
                    {
                        return nullptr;
                    }

                    reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj = std::move(obj);

                    return self.detach();
                }

                winrt::Microsoft::UI::Xaml::Controls::ImageIconSource instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ImageIconSource(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ImageIconSource_get_ImageSource(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ImageIconSource", L"ImageSource");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::ImageIconSource>().ImageSource();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ImageIconSource_put_ImageSource(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ImageIconSource", L"ImageSource");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Media::ImageSource>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::ImageIconSource>().ImageSource(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ImageIconSource_get_ImageSourceProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ImageIconSource", L"ImageSourceProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::ImageIconSource::ImageSourceProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ImageIconSource(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::ImageIconSource>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ImageIconSource(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::ImageIconSource>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ImageIconSource[] = {
        { "_assign_array_", _assign_array_ImageIconSource, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ImageIconSource), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_ImageIconSource[] = {
        { "image_source", reinterpret_cast<getter>(ImageIconSource_get_ImageSource), reinterpret_cast<setter>(ImageIconSource_put_ImageSource), nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_ImageIconSource[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ImageIconSource) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ImageIconSource) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ImageIconSource) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ImageIconSource) },
        { }};

    static PyType_Spec type_spec_ImageIconSource = {
        "winui2._winui2_microsoft_ui_xaml_controls.ImageIconSource",
        sizeof(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_ImageIconSource};

    static PyGetSetDef getset_ImageIconSource_Static[] = {
        { "image_source_property", reinterpret_cast<getter>(ImageIconSource_get_ImageSourceProperty), nullptr, nullptr, nullptr },
        { }};

    static PyMethodDef methods_ImageIconSource_Static[] = {
        { }};

    static PyType_Slot type_slots_ImageIconSource_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_ImageIconSource_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_ImageIconSource_Static) },
        { }
    };

    static PyType_Spec type_spec_ImageIconSource_Static = {
        "winui2._winui2_microsoft_ui_xaml_controls.ImageIconSource_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_ImageIconSource_Static};

    // ----- InfoBadge class --------------------

    struct PyWinrtInfoBadge;
    using BasePyWinrtInfoBadge = winrt::Microsoft::UI::Xaml::Controls::InfoBadgeT<PyWinrtInfoBadge, py::IPywinrtObject>;

    struct PyWinrtInfoBadge : py::py_obj_ref, BasePyWinrtInfoBadge
    {
        PyWinrtInfoBadge(PyObject* py_obj) : py::py_obj_ref(py_obj), BasePyWinrtInfoBadge() {}

        int32_t __stdcall GetPyObject(PyObject*& obj) override
        {
            obj = py::py_obj_ref::get_py_obj();
            return 0;
        }

        int32_t __stdcall GetComposableInner(winrt::Windows::Foundation::IInspectable& inner) override
        {
            inner = m_inner;
            return winrt::impl::error_ok;
        }

        static void toggle_reference(PyWinrtInfoBadge* instance, bool is_last_reference)
        {
            py::py_obj_ref::toggle_reference(instance, is_last_reference);
        }

        int32_t query_interface_tearoff(winrt::guid const& id, void** result) const noexcept override
        {
            return py::py_obj_ref::query_interface_tearoff(id, result);
        }

        std::vector<winrt::guid> get_iids_tearoff() const noexcept override
        {
            return py::py_obj_ref::get_iids_tearoff();
        }
    };

    static PyObject* _new_InfoBadge(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_GET_SIZE(args);

        auto self_type = get_python_type_for<winrt::Microsoft::UI::Xaml::Controls::InfoBadge>();
        if (!self_type)
        {
            return nullptr;
        }

        if (arg_count == 0)
        {
            try
            {
                if (type != self_type)
                {
                    py::pyobj_handle self{type->tp_alloc(type, 0)};
                    if (!self)
                    {
                        return nullptr;
                    }

                    std::construct_at(&reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj, nullptr);

                    auto obj_impl = winrt::make_self<PyWinrtInfoBadge>(self.get());

                    auto obj = py::make_py_obj<PyWinrtInfoBadge>(obj_impl, type, self.get());
                    if (!obj)
                    {
                        return nullptr;
                    }

                    reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj = std::move(obj);

                    return self.detach();
                }

                winrt::Microsoft::UI::Xaml::Controls::InfoBadge instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_InfoBadge(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* InfoBadge_get_Value(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.InfoBadge", L"Value");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::InfoBadge>().Value();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InfoBadge_put_Value(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.InfoBadge", L"Value");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<int32_t>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::InfoBadge>().Value(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InfoBadge_get_IconSource(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.InfoBadge", L"IconSource");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::InfoBadge>().IconSource();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InfoBadge_put_IconSource(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.InfoBadge", L"IconSource");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::IconSource>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::InfoBadge>().IconSource(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InfoBadge_get_TemplateSettings(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.InfoBadge", L"TemplateSettings");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::InfoBadge>().TemplateSettings();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InfoBadge_get_IconSourceProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.InfoBadge", L"IconSourceProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::InfoBadge::IconSourceProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InfoBadge_get_TemplateSettingsProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.InfoBadge", L"TemplateSettingsProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::InfoBadge::TemplateSettingsProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InfoBadge_get_ValueProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.InfoBadge", L"ValueProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::InfoBadge::ValueProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_InfoBadge(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::InfoBadge>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_InfoBadge(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::InfoBadge>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_InfoBadge[] = {
        { "_assign_array_", _assign_array_InfoBadge, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_InfoBadge), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_InfoBadge[] = {
        { "value", reinterpret_cast<getter>(InfoBadge_get_Value), reinterpret_cast<setter>(InfoBadge_put_Value), nullptr, nullptr },
        { "icon_source", reinterpret_cast<getter>(InfoBadge_get_IconSource), reinterpret_cast<setter>(InfoBadge_put_IconSource), nullptr, nullptr },
        { "template_settings", reinterpret_cast<getter>(InfoBadge_get_TemplateSettings), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_InfoBadge[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_InfoBadge) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_InfoBadge) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_InfoBadge) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_InfoBadge) },
        { }};

    static PyType_Spec type_spec_InfoBadge = {
        "winui2._winui2_microsoft_ui_xaml_controls.InfoBadge",
        sizeof(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_InfoBadge};

    static PyGetSetDef getset_InfoBadge_Static[] = {
        { "icon_source_property", reinterpret_cast<getter>(InfoBadge_get_IconSourceProperty), nullptr, nullptr, nullptr },
        { "template_settings_property", reinterpret_cast<getter>(InfoBadge_get_TemplateSettingsProperty), nullptr, nullptr, nullptr },
        { "value_property", reinterpret_cast<getter>(InfoBadge_get_ValueProperty), nullptr, nullptr, nullptr },
        { }};

    static PyMethodDef methods_InfoBadge_Static[] = {
        { }};

    static PyType_Slot type_slots_InfoBadge_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_InfoBadge_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_InfoBadge_Static) },
        { }
    };

    static PyType_Spec type_spec_InfoBadge_Static = {
        "winui2._winui2_microsoft_ui_xaml_controls.InfoBadge_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_InfoBadge_Static};

    // ----- InfoBadgeTemplateSettings class --------------------

    struct PyWinrtInfoBadgeTemplateSettings;
    using BasePyWinrtInfoBadgeTemplateSettings = winrt::Microsoft::UI::Xaml::Controls::InfoBadgeTemplateSettingsT<PyWinrtInfoBadgeTemplateSettings, py::IPywinrtObject>;

    struct PyWinrtInfoBadgeTemplateSettings : py::py_obj_ref, BasePyWinrtInfoBadgeTemplateSettings
    {
        PyWinrtInfoBadgeTemplateSettings(PyObject* py_obj) : py::py_obj_ref(py_obj), BasePyWinrtInfoBadgeTemplateSettings() {}

        int32_t __stdcall GetPyObject(PyObject*& obj) override
        {
            obj = py::py_obj_ref::get_py_obj();
            return 0;
        }

        int32_t __stdcall GetComposableInner(winrt::Windows::Foundation::IInspectable& inner) override
        {
            inner = m_inner;
            return winrt::impl::error_ok;
        }

        static void toggle_reference(PyWinrtInfoBadgeTemplateSettings* instance, bool is_last_reference)
        {
            py::py_obj_ref::toggle_reference(instance, is_last_reference);
        }

        int32_t query_interface_tearoff(winrt::guid const& id, void** result) const noexcept override
        {
            return py::py_obj_ref::query_interface_tearoff(id, result);
        }

        std::vector<winrt::guid> get_iids_tearoff() const noexcept override
        {
            return py::py_obj_ref::get_iids_tearoff();
        }
    };

    static PyObject* _new_InfoBadgeTemplateSettings(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_GET_SIZE(args);

        auto self_type = get_python_type_for<winrt::Microsoft::UI::Xaml::Controls::InfoBadgeTemplateSettings>();
        if (!self_type)
        {
            return nullptr;
        }

        if (arg_count == 0)
        {
            try
            {
                if (type != self_type)
                {
                    py::pyobj_handle self{type->tp_alloc(type, 0)};
                    if (!self)
                    {
                        return nullptr;
                    }

                    std::construct_at(&reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj, nullptr);

                    auto obj_impl = winrt::make_self<PyWinrtInfoBadgeTemplateSettings>(self.get());

                    auto obj = py::make_py_obj<PyWinrtInfoBadgeTemplateSettings>(obj_impl, type, self.get());
                    if (!obj)
                    {
                        return nullptr;
                    }

                    reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj = std::move(obj);

                    return self.detach();
                }

                winrt::Microsoft::UI::Xaml::Controls::InfoBadgeTemplateSettings instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_InfoBadgeTemplateSettings(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* InfoBadgeTemplateSettings_get_InfoBadgeCornerRadius(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.InfoBadgeTemplateSettings", L"InfoBadgeCornerRadius");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::InfoBadgeTemplateSettings>().InfoBadgeCornerRadius();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InfoBadgeTemplateSettings_put_InfoBadgeCornerRadius(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.InfoBadgeTemplateSettings", L"InfoBadgeCornerRadius");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::CornerRadius>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::InfoBadgeTemplateSettings>().InfoBadgeCornerRadius(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InfoBadgeTemplateSettings_get_IconElement(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.InfoBadgeTemplateSettings", L"IconElement");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::InfoBadgeTemplateSettings>().IconElement();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InfoBadgeTemplateSettings_put_IconElement(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.InfoBadgeTemplateSettings", L"IconElement");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::IconElement>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::InfoBadgeTemplateSettings>().IconElement(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InfoBadgeTemplateSettings_get_IconElementProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.InfoBadgeTemplateSettings", L"IconElementProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::InfoBadgeTemplateSettings::IconElementProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InfoBadgeTemplateSettings_get_InfoBadgeCornerRadiusProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.InfoBadgeTemplateSettings", L"InfoBadgeCornerRadiusProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::InfoBadgeTemplateSettings::InfoBadgeCornerRadiusProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_InfoBadgeTemplateSettings(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::InfoBadgeTemplateSettings>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_InfoBadgeTemplateSettings(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::InfoBadgeTemplateSettings>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_InfoBadgeTemplateSettings[] = {
        { "_assign_array_", _assign_array_InfoBadgeTemplateSettings, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_InfoBadgeTemplateSettings), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_InfoBadgeTemplateSettings[] = {
        { "info_badge_corner_radius", reinterpret_cast<getter>(InfoBadgeTemplateSettings_get_InfoBadgeCornerRadius), reinterpret_cast<setter>(InfoBadgeTemplateSettings_put_InfoBadgeCornerRadius), nullptr, nullptr },
        { "icon_element", reinterpret_cast<getter>(InfoBadgeTemplateSettings_get_IconElement), reinterpret_cast<setter>(InfoBadgeTemplateSettings_put_IconElement), nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_InfoBadgeTemplateSettings[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_InfoBadgeTemplateSettings) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_InfoBadgeTemplateSettings) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_InfoBadgeTemplateSettings) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_InfoBadgeTemplateSettings) },
        { }};

    static PyType_Spec type_spec_InfoBadgeTemplateSettings = {
        "winui2._winui2_microsoft_ui_xaml_controls.InfoBadgeTemplateSettings",
        sizeof(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_InfoBadgeTemplateSettings};

    static PyGetSetDef getset_InfoBadgeTemplateSettings_Static[] = {
        { "icon_element_property", reinterpret_cast<getter>(InfoBadgeTemplateSettings_get_IconElementProperty), nullptr, nullptr, nullptr },
        { "info_badge_corner_radius_property", reinterpret_cast<getter>(InfoBadgeTemplateSettings_get_InfoBadgeCornerRadiusProperty), nullptr, nullptr, nullptr },
        { }};

    static PyMethodDef methods_InfoBadgeTemplateSettings_Static[] = {
        { }};

    static PyType_Slot type_slots_InfoBadgeTemplateSettings_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_InfoBadgeTemplateSettings_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_InfoBadgeTemplateSettings_Static) },
        { }
    };

    static PyType_Spec type_spec_InfoBadgeTemplateSettings_Static = {
        "winui2._winui2_microsoft_ui_xaml_controls.InfoBadgeTemplateSettings_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_InfoBadgeTemplateSettings_Static};

    // ----- InfoBar class --------------------

    struct PyWinrtInfoBar;
    using BasePyWinrtInfoBar = winrt::Microsoft::UI::Xaml::Controls::InfoBarT<PyWinrtInfoBar, py::IPywinrtObject>;

    struct PyWinrtInfoBar : py::py_obj_ref, BasePyWinrtInfoBar
    {
        PyWinrtInfoBar(PyObject* py_obj) : py::py_obj_ref(py_obj), BasePyWinrtInfoBar() {}

        int32_t __stdcall GetPyObject(PyObject*& obj) override
        {
            obj = py::py_obj_ref::get_py_obj();
            return 0;
        }

        int32_t __stdcall GetComposableInner(winrt::Windows::Foundation::IInspectable& inner) override
        {
            inner = m_inner;
            return winrt::impl::error_ok;
        }

        static void toggle_reference(PyWinrtInfoBar* instance, bool is_last_reference)
        {
            py::py_obj_ref::toggle_reference(instance, is_last_reference);
        }

        int32_t query_interface_tearoff(winrt::guid const& id, void** result) const noexcept override
        {
            return py::py_obj_ref::query_interface_tearoff(id, result);
        }

        std::vector<winrt::guid> get_iids_tearoff() const noexcept override
        {
            return py::py_obj_ref::get_iids_tearoff();
        }
    };

    static PyObject* _new_InfoBar(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_GET_SIZE(args);

        auto self_type = get_python_type_for<winrt::Microsoft::UI::Xaml::Controls::InfoBar>();
        if (!self_type)
        {
            return nullptr;
        }

        if (arg_count == 0)
        {
            try
            {
                if (type != self_type)
                {
                    py::pyobj_handle self{type->tp_alloc(type, 0)};
                    if (!self)
                    {
                        return nullptr;
                    }

                    std::construct_at(&reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj, nullptr);

                    auto obj_impl = winrt::make_self<PyWinrtInfoBar>(self.get());

                    auto obj = py::make_py_obj<PyWinrtInfoBar>(obj_impl, type, self.get());
                    if (!obj)
                    {
                        return nullptr;
                    }

                    reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj = std::move(obj);

                    return self.detach();
                }

                winrt::Microsoft::UI::Xaml::Controls::InfoBar instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_InfoBar(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* InfoBar_get_Title(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.InfoBar", L"Title");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::InfoBar>().Title();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InfoBar_put_Title(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.InfoBar", L"Title");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::InfoBar>().Title(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InfoBar_get_Severity(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.InfoBar", L"Severity");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::InfoBar>().Severity();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InfoBar_put_Severity(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.InfoBar", L"Severity");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::InfoBarSeverity>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::InfoBar>().Severity(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InfoBar_get_Message(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.InfoBar", L"Message");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::InfoBar>().Message();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InfoBar_put_Message(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.InfoBar", L"Message");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::InfoBar>().Message(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InfoBar_get_IsOpen(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.InfoBar", L"IsOpen");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::InfoBar>().IsOpen();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InfoBar_put_IsOpen(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.InfoBar", L"IsOpen");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::InfoBar>().IsOpen(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InfoBar_get_IsIconVisible(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.InfoBar", L"IsIconVisible");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::InfoBar>().IsIconVisible();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InfoBar_put_IsIconVisible(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.InfoBar", L"IsIconVisible");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::InfoBar>().IsIconVisible(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InfoBar_get_IsClosable(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.InfoBar", L"IsClosable");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::InfoBar>().IsClosable();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InfoBar_put_IsClosable(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.InfoBar", L"IsClosable");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::InfoBar>().IsClosable(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InfoBar_get_IconSource(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.InfoBar", L"IconSource");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::InfoBar>().IconSource();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InfoBar_put_IconSource(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.InfoBar", L"IconSource");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::IconSource>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::InfoBar>().IconSource(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InfoBar_get_ContentTemplate(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.InfoBar", L"ContentTemplate");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::InfoBar>().ContentTemplate();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InfoBar_put_ContentTemplate(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.InfoBar", L"ContentTemplate");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::DataTemplate>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::InfoBar>().ContentTemplate(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InfoBar_get_Content(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.InfoBar", L"Content");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::InfoBar>().Content();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InfoBar_put_Content(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.InfoBar", L"Content");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::InfoBar>().Content(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InfoBar_get_CloseButtonStyle(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.InfoBar", L"CloseButtonStyle");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::InfoBar>().CloseButtonStyle();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InfoBar_put_CloseButtonStyle(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.InfoBar", L"CloseButtonStyle");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Style>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::InfoBar>().CloseButtonStyle(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InfoBar_get_CloseButtonCommandParameter(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.InfoBar", L"CloseButtonCommandParameter");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::InfoBar>().CloseButtonCommandParameter();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InfoBar_put_CloseButtonCommandParameter(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.InfoBar", L"CloseButtonCommandParameter");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::InfoBar>().CloseButtonCommandParameter(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InfoBar_get_CloseButtonCommand(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.InfoBar", L"CloseButtonCommand");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::InfoBar>().CloseButtonCommand();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InfoBar_put_CloseButtonCommand(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.InfoBar", L"CloseButtonCommand");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Input::ICommand>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::InfoBar>().CloseButtonCommand(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InfoBar_get_ActionButton(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.InfoBar", L"ActionButton");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::InfoBar>().ActionButton();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InfoBar_put_ActionButton(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.InfoBar", L"ActionButton");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::Primitives::ButtonBase>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::InfoBar>().ActionButton(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InfoBar_get_TemplateSettings(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.InfoBar", L"TemplateSettings");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::InfoBar>().TemplateSettings();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InfoBar_get_ActionButtonProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.InfoBar", L"ActionButtonProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::InfoBar::ActionButtonProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InfoBar_get_CloseButtonCommandParameterProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.InfoBar", L"CloseButtonCommandParameterProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::InfoBar::CloseButtonCommandParameterProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InfoBar_get_CloseButtonCommandProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.InfoBar", L"CloseButtonCommandProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::InfoBar::CloseButtonCommandProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InfoBar_get_CloseButtonStyleProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.InfoBar", L"CloseButtonStyleProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::InfoBar::CloseButtonStyleProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InfoBar_get_ContentProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.InfoBar", L"ContentProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::InfoBar::ContentProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InfoBar_get_ContentTemplateProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.InfoBar", L"ContentTemplateProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::InfoBar::ContentTemplateProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InfoBar_get_IconSourceProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.InfoBar", L"IconSourceProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::InfoBar::IconSourceProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InfoBar_get_IsClosableProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.InfoBar", L"IsClosableProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::InfoBar::IsClosableProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InfoBar_get_IsIconVisibleProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.InfoBar", L"IsIconVisibleProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::InfoBar::IsIconVisibleProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InfoBar_get_IsOpenProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.InfoBar", L"IsOpenProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::InfoBar::IsOpenProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InfoBar_get_MessageProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.InfoBar", L"MessageProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::InfoBar::MessageProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InfoBar_get_SeverityProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.InfoBar", L"SeverityProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::InfoBar::SeverityProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InfoBar_get_TemplateSettingsProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.InfoBar", L"TemplateSettingsProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::InfoBar::TemplateSettingsProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InfoBar_get_TitleProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.InfoBar", L"TitleProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::InfoBar::TitleProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InfoBar_add_CloseButtonClick(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.InfoBar", L"CloseButtonClick");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Xaml::Controls::InfoBar, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::InfoBar>().CloseButtonClick(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InfoBar_remove_CloseButtonClick(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.InfoBar", L"CloseButtonClick");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::InfoBar>().CloseButtonClick(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InfoBar_add_Closed(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.InfoBar", L"Closed");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Xaml::Controls::InfoBar, winrt::Microsoft::UI::Xaml::Controls::InfoBarClosedEventArgs>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::InfoBar>().Closed(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InfoBar_remove_Closed(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.InfoBar", L"Closed");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::InfoBar>().Closed(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InfoBar_add_Closing(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.InfoBar", L"Closing");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Xaml::Controls::InfoBar, winrt::Microsoft::UI::Xaml::Controls::InfoBarClosingEventArgs>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::InfoBar>().Closing(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InfoBar_remove_Closing(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.InfoBar", L"Closing");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::InfoBar>().Closing(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_InfoBar(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::InfoBar>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_InfoBar(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::InfoBar>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_InfoBar[] = {
        { "add_close_button_click", reinterpret_cast<PyCFunction>(InfoBar_add_CloseButtonClick), METH_O, nullptr },
        { "remove_close_button_click", reinterpret_cast<PyCFunction>(InfoBar_remove_CloseButtonClick), METH_O, nullptr },
        { "add_closed", reinterpret_cast<PyCFunction>(InfoBar_add_Closed), METH_O, nullptr },
        { "remove_closed", reinterpret_cast<PyCFunction>(InfoBar_remove_Closed), METH_O, nullptr },
        { "add_closing", reinterpret_cast<PyCFunction>(InfoBar_add_Closing), METH_O, nullptr },
        { "remove_closing", reinterpret_cast<PyCFunction>(InfoBar_remove_Closing), METH_O, nullptr },
        { "_assign_array_", _assign_array_InfoBar, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_InfoBar), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_InfoBar[] = {
        { "title", reinterpret_cast<getter>(InfoBar_get_Title), reinterpret_cast<setter>(InfoBar_put_Title), nullptr, nullptr },
        { "severity", reinterpret_cast<getter>(InfoBar_get_Severity), reinterpret_cast<setter>(InfoBar_put_Severity), nullptr, nullptr },
        { "message", reinterpret_cast<getter>(InfoBar_get_Message), reinterpret_cast<setter>(InfoBar_put_Message), nullptr, nullptr },
        { "is_open", reinterpret_cast<getter>(InfoBar_get_IsOpen), reinterpret_cast<setter>(InfoBar_put_IsOpen), nullptr, nullptr },
        { "is_icon_visible", reinterpret_cast<getter>(InfoBar_get_IsIconVisible), reinterpret_cast<setter>(InfoBar_put_IsIconVisible), nullptr, nullptr },
        { "is_closable", reinterpret_cast<getter>(InfoBar_get_IsClosable), reinterpret_cast<setter>(InfoBar_put_IsClosable), nullptr, nullptr },
        { "icon_source", reinterpret_cast<getter>(InfoBar_get_IconSource), reinterpret_cast<setter>(InfoBar_put_IconSource), nullptr, nullptr },
        { "content_template", reinterpret_cast<getter>(InfoBar_get_ContentTemplate), reinterpret_cast<setter>(InfoBar_put_ContentTemplate), nullptr, nullptr },
        { "content", reinterpret_cast<getter>(InfoBar_get_Content), reinterpret_cast<setter>(InfoBar_put_Content), nullptr, nullptr },
        { "close_button_style", reinterpret_cast<getter>(InfoBar_get_CloseButtonStyle), reinterpret_cast<setter>(InfoBar_put_CloseButtonStyle), nullptr, nullptr },
        { "close_button_command_parameter", reinterpret_cast<getter>(InfoBar_get_CloseButtonCommandParameter), reinterpret_cast<setter>(InfoBar_put_CloseButtonCommandParameter), nullptr, nullptr },
        { "close_button_command", reinterpret_cast<getter>(InfoBar_get_CloseButtonCommand), reinterpret_cast<setter>(InfoBar_put_CloseButtonCommand), nullptr, nullptr },
        { "action_button", reinterpret_cast<getter>(InfoBar_get_ActionButton), reinterpret_cast<setter>(InfoBar_put_ActionButton), nullptr, nullptr },
        { "template_settings", reinterpret_cast<getter>(InfoBar_get_TemplateSettings), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_InfoBar[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_InfoBar) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_InfoBar) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_InfoBar) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_InfoBar) },
        { }};

    static PyType_Spec type_spec_InfoBar = {
        "winui2._winui2_microsoft_ui_xaml_controls.InfoBar",
        sizeof(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_InfoBar};

    static PyGetSetDef getset_InfoBar_Static[] = {
        { "action_button_property", reinterpret_cast<getter>(InfoBar_get_ActionButtonProperty), nullptr, nullptr, nullptr },
        { "close_button_command_parameter_property", reinterpret_cast<getter>(InfoBar_get_CloseButtonCommandParameterProperty), nullptr, nullptr, nullptr },
        { "close_button_command_property", reinterpret_cast<getter>(InfoBar_get_CloseButtonCommandProperty), nullptr, nullptr, nullptr },
        { "close_button_style_property", reinterpret_cast<getter>(InfoBar_get_CloseButtonStyleProperty), nullptr, nullptr, nullptr },
        { "content_property", reinterpret_cast<getter>(InfoBar_get_ContentProperty), nullptr, nullptr, nullptr },
        { "content_template_property", reinterpret_cast<getter>(InfoBar_get_ContentTemplateProperty), nullptr, nullptr, nullptr },
        { "icon_source_property", reinterpret_cast<getter>(InfoBar_get_IconSourceProperty), nullptr, nullptr, nullptr },
        { "is_closable_property", reinterpret_cast<getter>(InfoBar_get_IsClosableProperty), nullptr, nullptr, nullptr },
        { "is_icon_visible_property", reinterpret_cast<getter>(InfoBar_get_IsIconVisibleProperty), nullptr, nullptr, nullptr },
        { "is_open_property", reinterpret_cast<getter>(InfoBar_get_IsOpenProperty), nullptr, nullptr, nullptr },
        { "message_property", reinterpret_cast<getter>(InfoBar_get_MessageProperty), nullptr, nullptr, nullptr },
        { "severity_property", reinterpret_cast<getter>(InfoBar_get_SeverityProperty), nullptr, nullptr, nullptr },
        { "template_settings_property", reinterpret_cast<getter>(InfoBar_get_TemplateSettingsProperty), nullptr, nullptr, nullptr },
        { "title_property", reinterpret_cast<getter>(InfoBar_get_TitleProperty), nullptr, nullptr, nullptr },
        { }};

    static PyMethodDef methods_InfoBar_Static[] = {
        { }};

    static PyType_Slot type_slots_InfoBar_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_InfoBar_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_InfoBar_Static) },
        { }
    };

    static PyType_Spec type_spec_InfoBar_Static = {
        "winui2._winui2_microsoft_ui_xaml_controls.InfoBar_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_InfoBar_Static};

    // ----- InfoBarClosedEventArgs class --------------------

    static PyObject* _new_InfoBarClosedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Xaml::Controls::InfoBarClosedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Xaml::Controls::InfoBarClosedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_InfoBarClosedEventArgs(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* InfoBarClosedEventArgs_get_Reason(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.InfoBarClosedEventArgs", L"Reason");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::InfoBarClosedEventArgs>().Reason();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_InfoBarClosedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::InfoBarClosedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_InfoBarClosedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::InfoBarClosedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_InfoBarClosedEventArgs[] = {
        { "_assign_array_", _assign_array_InfoBarClosedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_InfoBarClosedEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_InfoBarClosedEventArgs[] = {
        { "reason", reinterpret_cast<getter>(InfoBarClosedEventArgs_get_Reason), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_InfoBarClosedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_InfoBarClosedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_InfoBarClosedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_InfoBarClosedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_InfoBarClosedEventArgs) },
        { }};

    static PyType_Spec type_spec_InfoBarClosedEventArgs = {
        "winui2._winui2_microsoft_ui_xaml_controls.InfoBarClosedEventArgs",
        sizeof(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_InfoBarClosedEventArgs};

    static PyGetSetDef getset_InfoBarClosedEventArgs_Static[] = {
        { }};

    static PyMethodDef methods_InfoBarClosedEventArgs_Static[] = {
        { }};

    static PyType_Slot type_slots_InfoBarClosedEventArgs_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_InfoBarClosedEventArgs_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_InfoBarClosedEventArgs_Static) },
        { }
    };

    static PyType_Spec type_spec_InfoBarClosedEventArgs_Static = {
        "winui2._winui2_microsoft_ui_xaml_controls.InfoBarClosedEventArgs_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_InfoBarClosedEventArgs_Static};

    // ----- InfoBarClosingEventArgs class --------------------

    static PyObject* _new_InfoBarClosingEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Xaml::Controls::InfoBarClosingEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Xaml::Controls::InfoBarClosingEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_InfoBarClosingEventArgs(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* InfoBarClosingEventArgs_get_Cancel(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.InfoBarClosingEventArgs", L"Cancel");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::InfoBarClosingEventArgs>().Cancel();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InfoBarClosingEventArgs_put_Cancel(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.InfoBarClosingEventArgs", L"Cancel");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::InfoBarClosingEventArgs>().Cancel(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InfoBarClosingEventArgs_get_Reason(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.InfoBarClosingEventArgs", L"Reason");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::InfoBarClosingEventArgs>().Reason();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_InfoBarClosingEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::InfoBarClosingEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_InfoBarClosingEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::InfoBarClosingEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_InfoBarClosingEventArgs[] = {
        { "_assign_array_", _assign_array_InfoBarClosingEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_InfoBarClosingEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_InfoBarClosingEventArgs[] = {
        { "cancel", reinterpret_cast<getter>(InfoBarClosingEventArgs_get_Cancel), reinterpret_cast<setter>(InfoBarClosingEventArgs_put_Cancel), nullptr, nullptr },
        { "reason", reinterpret_cast<getter>(InfoBarClosingEventArgs_get_Reason), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_InfoBarClosingEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_InfoBarClosingEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_InfoBarClosingEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_InfoBarClosingEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_InfoBarClosingEventArgs) },
        { }};

    static PyType_Spec type_spec_InfoBarClosingEventArgs = {
        "winui2._winui2_microsoft_ui_xaml_controls.InfoBarClosingEventArgs",
        sizeof(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_InfoBarClosingEventArgs};

    static PyGetSetDef getset_InfoBarClosingEventArgs_Static[] = {
        { }};

    static PyMethodDef methods_InfoBarClosingEventArgs_Static[] = {
        { }};

    static PyType_Slot type_slots_InfoBarClosingEventArgs_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_InfoBarClosingEventArgs_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_InfoBarClosingEventArgs_Static) },
        { }
    };

    static PyType_Spec type_spec_InfoBarClosingEventArgs_Static = {
        "winui2._winui2_microsoft_ui_xaml_controls.InfoBarClosingEventArgs_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_InfoBarClosingEventArgs_Static};

    // ----- InfoBarTemplateSettings class --------------------

    struct PyWinrtInfoBarTemplateSettings;
    using BasePyWinrtInfoBarTemplateSettings = winrt::Microsoft::UI::Xaml::Controls::InfoBarTemplateSettingsT<PyWinrtInfoBarTemplateSettings, py::IPywinrtObject>;

    struct PyWinrtInfoBarTemplateSettings : py::py_obj_ref, BasePyWinrtInfoBarTemplateSettings
    {
        PyWinrtInfoBarTemplateSettings(PyObject* py_obj) : py::py_obj_ref(py_obj), BasePyWinrtInfoBarTemplateSettings() {}

        int32_t __stdcall GetPyObject(PyObject*& obj) override
        {
            obj = py::py_obj_ref::get_py_obj();
            return 0;
        }

        int32_t __stdcall GetComposableInner(winrt::Windows::Foundation::IInspectable& inner) override
        {
            inner = m_inner;
            return winrt::impl::error_ok;
        }

        static void toggle_reference(PyWinrtInfoBarTemplateSettings* instance, bool is_last_reference)
        {
            py::py_obj_ref::toggle_reference(instance, is_last_reference);
        }

        int32_t query_interface_tearoff(winrt::guid const& id, void** result) const noexcept override
        {
            return py::py_obj_ref::query_interface_tearoff(id, result);
        }

        std::vector<winrt::guid> get_iids_tearoff() const noexcept override
        {
            return py::py_obj_ref::get_iids_tearoff();
        }
    };

    static PyObject* _new_InfoBarTemplateSettings(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_GET_SIZE(args);

        auto self_type = get_python_type_for<winrt::Microsoft::UI::Xaml::Controls::InfoBarTemplateSettings>();
        if (!self_type)
        {
            return nullptr;
        }

        if (arg_count == 0)
        {
            try
            {
                if (type != self_type)
                {
                    py::pyobj_handle self{type->tp_alloc(type, 0)};
                    if (!self)
                    {
                        return nullptr;
                    }

                    std::construct_at(&reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj, nullptr);

                    auto obj_impl = winrt::make_self<PyWinrtInfoBarTemplateSettings>(self.get());

                    auto obj = py::make_py_obj<PyWinrtInfoBarTemplateSettings>(obj_impl, type, self.get());
                    if (!obj)
                    {
                        return nullptr;
                    }

                    reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj = std::move(obj);

                    return self.detach();
                }

                winrt::Microsoft::UI::Xaml::Controls::InfoBarTemplateSettings instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_InfoBarTemplateSettings(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* InfoBarTemplateSettings_get_IconElement(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.InfoBarTemplateSettings", L"IconElement");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::InfoBarTemplateSettings>().IconElement();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InfoBarTemplateSettings_put_IconElement(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.InfoBarTemplateSettings", L"IconElement");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::IconElement>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::InfoBarTemplateSettings>().IconElement(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InfoBarTemplateSettings_get_IconElementProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.InfoBarTemplateSettings", L"IconElementProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::InfoBarTemplateSettings::IconElementProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_InfoBarTemplateSettings(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::InfoBarTemplateSettings>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_InfoBarTemplateSettings(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::InfoBarTemplateSettings>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_InfoBarTemplateSettings[] = {
        { "_assign_array_", _assign_array_InfoBarTemplateSettings, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_InfoBarTemplateSettings), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_InfoBarTemplateSettings[] = {
        { "icon_element", reinterpret_cast<getter>(InfoBarTemplateSettings_get_IconElement), reinterpret_cast<setter>(InfoBarTemplateSettings_put_IconElement), nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_InfoBarTemplateSettings[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_InfoBarTemplateSettings) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_InfoBarTemplateSettings) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_InfoBarTemplateSettings) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_InfoBarTemplateSettings) },
        { }};

    static PyType_Spec type_spec_InfoBarTemplateSettings = {
        "winui2._winui2_microsoft_ui_xaml_controls.InfoBarTemplateSettings",
        sizeof(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_InfoBarTemplateSettings};

    static PyGetSetDef getset_InfoBarTemplateSettings_Static[] = {
        { "icon_element_property", reinterpret_cast<getter>(InfoBarTemplateSettings_get_IconElementProperty), nullptr, nullptr, nullptr },
        { }};

    static PyMethodDef methods_InfoBarTemplateSettings_Static[] = {
        { }};

    static PyType_Slot type_slots_InfoBarTemplateSettings_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_InfoBarTemplateSettings_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_InfoBarTemplateSettings_Static) },
        { }
    };

    static PyType_Spec type_spec_InfoBarTemplateSettings_Static = {
        "winui2._winui2_microsoft_ui_xaml_controls.InfoBarTemplateSettings_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_InfoBarTemplateSettings_Static};

    // ----- ItemsRepeater class --------------------

    struct PyWinrtItemsRepeater;
    using BasePyWinrtItemsRepeater = winrt::Microsoft::UI::Xaml::Controls::ItemsRepeaterT<PyWinrtItemsRepeater, py::IPywinrtObject>;

    struct PyWinrtItemsRepeater : py::py_obj_ref, BasePyWinrtItemsRepeater
    {
        PyWinrtItemsRepeater(PyObject* py_obj) : py::py_obj_ref(py_obj), BasePyWinrtItemsRepeater() {}

        int32_t __stdcall GetPyObject(PyObject*& obj) override
        {
            obj = py::py_obj_ref::get_py_obj();
            return 0;
        }

        int32_t __stdcall GetComposableInner(winrt::Windows::Foundation::IInspectable& inner) override
        {
            inner = m_inner;
            return winrt::impl::error_ok;
        }

        static void toggle_reference(PyWinrtItemsRepeater* instance, bool is_last_reference)
        {
            py::py_obj_ref::toggle_reference(instance, is_last_reference);
        }

        int32_t query_interface_tearoff(winrt::guid const& id, void** result) const noexcept override
        {
            return py::py_obj_ref::query_interface_tearoff(id, result);
        }

        std::vector<winrt::guid> get_iids_tearoff() const noexcept override
        {
            return py::py_obj_ref::get_iids_tearoff();
        }
    };

    static PyObject* _new_ItemsRepeater(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_GET_SIZE(args);

        auto self_type = get_python_type_for<winrt::Microsoft::UI::Xaml::Controls::ItemsRepeater>();
        if (!self_type)
        {
            return nullptr;
        }

        if (arg_count == 0)
        {
            try
            {
                if (type != self_type)
                {
                    py::pyobj_handle self{type->tp_alloc(type, 0)};
                    if (!self)
                    {
                        return nullptr;
                    }

                    std::construct_at(&reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj, nullptr);

                    auto obj_impl = winrt::make_self<PyWinrtItemsRepeater>(self.get());

                    auto obj = py::make_py_obj<PyWinrtItemsRepeater>(obj_impl, type, self.get());
                    if (!obj)
                    {
                        return nullptr;
                    }

                    reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj = std::move(obj);

                    return self.detach();
                }

                winrt::Microsoft::UI::Xaml::Controls::ItemsRepeater instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ItemsRepeater(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ItemsRepeater_GetElementIndex(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.ItemsRepeater", L"GetElementIndex", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::UIElement>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::ItemsRepeater>().GetElementIndex(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ItemsRepeater_GetOrCreateElement(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.ItemsRepeater", L"GetOrCreateElement", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<int32_t>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::ItemsRepeater>().GetOrCreateElement(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ItemsRepeater_TryGetElement(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.ItemsRepeater", L"TryGetElement", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<int32_t>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::ItemsRepeater>().TryGetElement(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ItemsRepeater_get_VerticalCacheLength(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ItemsRepeater", L"VerticalCacheLength");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::ItemsRepeater>().VerticalCacheLength();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ItemsRepeater_put_VerticalCacheLength(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ItemsRepeater", L"VerticalCacheLength");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<double>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::ItemsRepeater>().VerticalCacheLength(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ItemsRepeater_get_Layout(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ItemsRepeater", L"Layout");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::ItemsRepeater>().Layout();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ItemsRepeater_put_Layout(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ItemsRepeater", L"Layout");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::Layout>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::ItemsRepeater>().Layout(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ItemsRepeater_get_ItemsSource(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ItemsRepeater", L"ItemsSource");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::ItemsRepeater>().ItemsSource();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ItemsRepeater_put_ItemsSource(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ItemsRepeater", L"ItemsSource");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::ItemsRepeater>().ItemsSource(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ItemsRepeater_get_ItemTemplate(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ItemsRepeater", L"ItemTemplate");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::ItemsRepeater>().ItemTemplate();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ItemsRepeater_put_ItemTemplate(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ItemsRepeater", L"ItemTemplate");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::ItemsRepeater>().ItemTemplate(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ItemsRepeater_get_HorizontalCacheLength(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ItemsRepeater", L"HorizontalCacheLength");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::ItemsRepeater>().HorizontalCacheLength();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ItemsRepeater_put_HorizontalCacheLength(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ItemsRepeater", L"HorizontalCacheLength");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<double>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::ItemsRepeater>().HorizontalCacheLength(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ItemsRepeater_get_Background(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ItemsRepeater", L"Background");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::ItemsRepeater>().Background();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ItemsRepeater_put_Background(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ItemsRepeater", L"Background");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Media::Brush>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::ItemsRepeater>().Background(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ItemsRepeater_get_ItemsSourceView(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ItemsRepeater", L"ItemsSourceView");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::ItemsRepeater>().ItemsSourceView();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ItemsRepeater_get_BackgroundProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ItemsRepeater", L"BackgroundProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::ItemsRepeater::BackgroundProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ItemsRepeater_get_HorizontalCacheLengthProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ItemsRepeater", L"HorizontalCacheLengthProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::ItemsRepeater::HorizontalCacheLengthProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ItemsRepeater_get_ItemTemplateProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ItemsRepeater", L"ItemTemplateProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::ItemsRepeater::ItemTemplateProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ItemsRepeater_get_ItemsSourceProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ItemsRepeater", L"ItemsSourceProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::ItemsRepeater::ItemsSourceProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ItemsRepeater_get_LayoutProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ItemsRepeater", L"LayoutProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::ItemsRepeater::LayoutProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ItemsRepeater_get_VerticalCacheLengthProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ItemsRepeater", L"VerticalCacheLengthProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::ItemsRepeater::VerticalCacheLengthProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ItemsRepeater_add_ElementClearing(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.ItemsRepeater", L"ElementClearing");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Xaml::Controls::ItemsRepeater, winrt::Microsoft::UI::Xaml::Controls::ItemsRepeaterElementClearingEventArgs>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::ItemsRepeater>().ElementClearing(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ItemsRepeater_remove_ElementClearing(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.ItemsRepeater", L"ElementClearing");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::ItemsRepeater>().ElementClearing(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ItemsRepeater_add_ElementIndexChanged(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.ItemsRepeater", L"ElementIndexChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Xaml::Controls::ItemsRepeater, winrt::Microsoft::UI::Xaml::Controls::ItemsRepeaterElementIndexChangedEventArgs>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::ItemsRepeater>().ElementIndexChanged(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ItemsRepeater_remove_ElementIndexChanged(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.ItemsRepeater", L"ElementIndexChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::ItemsRepeater>().ElementIndexChanged(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ItemsRepeater_add_ElementPrepared(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.ItemsRepeater", L"ElementPrepared");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Xaml::Controls::ItemsRepeater, winrt::Microsoft::UI::Xaml::Controls::ItemsRepeaterElementPreparedEventArgs>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::ItemsRepeater>().ElementPrepared(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ItemsRepeater_remove_ElementPrepared(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.ItemsRepeater", L"ElementPrepared");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::ItemsRepeater>().ElementPrepared(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ItemsRepeater(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::ItemsRepeater>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ItemsRepeater(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::ItemsRepeater>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ItemsRepeater[] = {
        { "get_element_index", reinterpret_cast<PyCFunction>(ItemsRepeater_GetElementIndex), METH_VARARGS, nullptr },
        { "get_or_create_element", reinterpret_cast<PyCFunction>(ItemsRepeater_GetOrCreateElement), METH_VARARGS, nullptr },
        { "try_get_element", reinterpret_cast<PyCFunction>(ItemsRepeater_TryGetElement), METH_VARARGS, nullptr },
        { "add_element_clearing", reinterpret_cast<PyCFunction>(ItemsRepeater_add_ElementClearing), METH_O, nullptr },
        { "remove_element_clearing", reinterpret_cast<PyCFunction>(ItemsRepeater_remove_ElementClearing), METH_O, nullptr },
        { "add_element_index_changed", reinterpret_cast<PyCFunction>(ItemsRepeater_add_ElementIndexChanged), METH_O, nullptr },
        { "remove_element_index_changed", reinterpret_cast<PyCFunction>(ItemsRepeater_remove_ElementIndexChanged), METH_O, nullptr },
        { "add_element_prepared", reinterpret_cast<PyCFunction>(ItemsRepeater_add_ElementPrepared), METH_O, nullptr },
        { "remove_element_prepared", reinterpret_cast<PyCFunction>(ItemsRepeater_remove_ElementPrepared), METH_O, nullptr },
        { "_assign_array_", _assign_array_ItemsRepeater, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ItemsRepeater), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_ItemsRepeater[] = {
        { "vertical_cache_length", reinterpret_cast<getter>(ItemsRepeater_get_VerticalCacheLength), reinterpret_cast<setter>(ItemsRepeater_put_VerticalCacheLength), nullptr, nullptr },
        { "layout", reinterpret_cast<getter>(ItemsRepeater_get_Layout), reinterpret_cast<setter>(ItemsRepeater_put_Layout), nullptr, nullptr },
        { "items_source", reinterpret_cast<getter>(ItemsRepeater_get_ItemsSource), reinterpret_cast<setter>(ItemsRepeater_put_ItemsSource), nullptr, nullptr },
        { "item_template", reinterpret_cast<getter>(ItemsRepeater_get_ItemTemplate), reinterpret_cast<setter>(ItemsRepeater_put_ItemTemplate), nullptr, nullptr },
        { "horizontal_cache_length", reinterpret_cast<getter>(ItemsRepeater_get_HorizontalCacheLength), reinterpret_cast<setter>(ItemsRepeater_put_HorizontalCacheLength), nullptr, nullptr },
        { "background", reinterpret_cast<getter>(ItemsRepeater_get_Background), reinterpret_cast<setter>(ItemsRepeater_put_Background), nullptr, nullptr },
        { "items_source_view", reinterpret_cast<getter>(ItemsRepeater_get_ItemsSourceView), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_ItemsRepeater[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ItemsRepeater) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ItemsRepeater) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ItemsRepeater) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ItemsRepeater) },
        { }};

    static PyType_Spec type_spec_ItemsRepeater = {
        "winui2._winui2_microsoft_ui_xaml_controls.ItemsRepeater",
        sizeof(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_ItemsRepeater};

    static PyGetSetDef getset_ItemsRepeater_Static[] = {
        { "background_property", reinterpret_cast<getter>(ItemsRepeater_get_BackgroundProperty), nullptr, nullptr, nullptr },
        { "horizontal_cache_length_property", reinterpret_cast<getter>(ItemsRepeater_get_HorizontalCacheLengthProperty), nullptr, nullptr, nullptr },
        { "item_template_property", reinterpret_cast<getter>(ItemsRepeater_get_ItemTemplateProperty), nullptr, nullptr, nullptr },
        { "items_source_property", reinterpret_cast<getter>(ItemsRepeater_get_ItemsSourceProperty), nullptr, nullptr, nullptr },
        { "layout_property", reinterpret_cast<getter>(ItemsRepeater_get_LayoutProperty), nullptr, nullptr, nullptr },
        { "vertical_cache_length_property", reinterpret_cast<getter>(ItemsRepeater_get_VerticalCacheLengthProperty), nullptr, nullptr, nullptr },
        { }};

    static PyMethodDef methods_ItemsRepeater_Static[] = {
        { }};

    static PyType_Slot type_slots_ItemsRepeater_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_ItemsRepeater_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_ItemsRepeater_Static) },
        { }
    };

    static PyType_Spec type_spec_ItemsRepeater_Static = {
        "winui2._winui2_microsoft_ui_xaml_controls.ItemsRepeater_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_ItemsRepeater_Static};

    // ----- ItemsRepeaterElementClearingEventArgs class --------------------

    static PyObject* _new_ItemsRepeaterElementClearingEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Xaml::Controls::ItemsRepeaterElementClearingEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Xaml::Controls::ItemsRepeaterElementClearingEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_ItemsRepeaterElementClearingEventArgs(py::wrapper::Microsoft::UI::Xaml::Controls::ItemsRepeaterElementClearingEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ItemsRepeaterElementClearingEventArgs_get_Element(py::wrapper::Microsoft::UI::Xaml::Controls::ItemsRepeaterElementClearingEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ItemsRepeaterElementClearingEventArgs", L"Element");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Element();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ItemsRepeaterElementClearingEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::ItemsRepeaterElementClearingEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ItemsRepeaterElementClearingEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::ItemsRepeaterElementClearingEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ItemsRepeaterElementClearingEventArgs[] = {
        { "_assign_array_", _assign_array_ItemsRepeaterElementClearingEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ItemsRepeaterElementClearingEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_ItemsRepeaterElementClearingEventArgs[] = {
        { "element", reinterpret_cast<getter>(ItemsRepeaterElementClearingEventArgs_get_Element), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_ItemsRepeaterElementClearingEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ItemsRepeaterElementClearingEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ItemsRepeaterElementClearingEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ItemsRepeaterElementClearingEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ItemsRepeaterElementClearingEventArgs) },
        { }};

    static PyType_Spec type_spec_ItemsRepeaterElementClearingEventArgs = {
        "winui2._winui2_microsoft_ui_xaml_controls.ItemsRepeaterElementClearingEventArgs",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Controls::ItemsRepeaterElementClearingEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ItemsRepeaterElementClearingEventArgs};

    // ----- ItemsRepeaterElementIndexChangedEventArgs class --------------------

    static PyObject* _new_ItemsRepeaterElementIndexChangedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Xaml::Controls::ItemsRepeaterElementIndexChangedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Xaml::Controls::ItemsRepeaterElementIndexChangedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_ItemsRepeaterElementIndexChangedEventArgs(py::wrapper::Microsoft::UI::Xaml::Controls::ItemsRepeaterElementIndexChangedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ItemsRepeaterElementIndexChangedEventArgs_get_Element(py::wrapper::Microsoft::UI::Xaml::Controls::ItemsRepeaterElementIndexChangedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ItemsRepeaterElementIndexChangedEventArgs", L"Element");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Element();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ItemsRepeaterElementIndexChangedEventArgs_get_NewIndex(py::wrapper::Microsoft::UI::Xaml::Controls::ItemsRepeaterElementIndexChangedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ItemsRepeaterElementIndexChangedEventArgs", L"NewIndex");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.NewIndex();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ItemsRepeaterElementIndexChangedEventArgs_get_OldIndex(py::wrapper::Microsoft::UI::Xaml::Controls::ItemsRepeaterElementIndexChangedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ItemsRepeaterElementIndexChangedEventArgs", L"OldIndex");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.OldIndex();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ItemsRepeaterElementIndexChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::ItemsRepeaterElementIndexChangedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ItemsRepeaterElementIndexChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::ItemsRepeaterElementIndexChangedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ItemsRepeaterElementIndexChangedEventArgs[] = {
        { "_assign_array_", _assign_array_ItemsRepeaterElementIndexChangedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ItemsRepeaterElementIndexChangedEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_ItemsRepeaterElementIndexChangedEventArgs[] = {
        { "element", reinterpret_cast<getter>(ItemsRepeaterElementIndexChangedEventArgs_get_Element), nullptr, nullptr, nullptr },
        { "new_index", reinterpret_cast<getter>(ItemsRepeaterElementIndexChangedEventArgs_get_NewIndex), nullptr, nullptr, nullptr },
        { "old_index", reinterpret_cast<getter>(ItemsRepeaterElementIndexChangedEventArgs_get_OldIndex), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_ItemsRepeaterElementIndexChangedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ItemsRepeaterElementIndexChangedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ItemsRepeaterElementIndexChangedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ItemsRepeaterElementIndexChangedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ItemsRepeaterElementIndexChangedEventArgs) },
        { }};

    static PyType_Spec type_spec_ItemsRepeaterElementIndexChangedEventArgs = {
        "winui2._winui2_microsoft_ui_xaml_controls.ItemsRepeaterElementIndexChangedEventArgs",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Controls::ItemsRepeaterElementIndexChangedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ItemsRepeaterElementIndexChangedEventArgs};

    // ----- ItemsRepeaterElementPreparedEventArgs class --------------------

    static PyObject* _new_ItemsRepeaterElementPreparedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Xaml::Controls::ItemsRepeaterElementPreparedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Xaml::Controls::ItemsRepeaterElementPreparedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_ItemsRepeaterElementPreparedEventArgs(py::wrapper::Microsoft::UI::Xaml::Controls::ItemsRepeaterElementPreparedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ItemsRepeaterElementPreparedEventArgs_get_Element(py::wrapper::Microsoft::UI::Xaml::Controls::ItemsRepeaterElementPreparedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ItemsRepeaterElementPreparedEventArgs", L"Element");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Element();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ItemsRepeaterElementPreparedEventArgs_get_Index(py::wrapper::Microsoft::UI::Xaml::Controls::ItemsRepeaterElementPreparedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ItemsRepeaterElementPreparedEventArgs", L"Index");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Index();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ItemsRepeaterElementPreparedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::ItemsRepeaterElementPreparedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ItemsRepeaterElementPreparedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::ItemsRepeaterElementPreparedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ItemsRepeaterElementPreparedEventArgs[] = {
        { "_assign_array_", _assign_array_ItemsRepeaterElementPreparedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ItemsRepeaterElementPreparedEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_ItemsRepeaterElementPreparedEventArgs[] = {
        { "element", reinterpret_cast<getter>(ItemsRepeaterElementPreparedEventArgs_get_Element), nullptr, nullptr, nullptr },
        { "index", reinterpret_cast<getter>(ItemsRepeaterElementPreparedEventArgs_get_Index), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_ItemsRepeaterElementPreparedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ItemsRepeaterElementPreparedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ItemsRepeaterElementPreparedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ItemsRepeaterElementPreparedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ItemsRepeaterElementPreparedEventArgs) },
        { }};

    static PyType_Spec type_spec_ItemsRepeaterElementPreparedEventArgs = {
        "winui2._winui2_microsoft_ui_xaml_controls.ItemsRepeaterElementPreparedEventArgs",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Controls::ItemsRepeaterElementPreparedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ItemsRepeaterElementPreparedEventArgs};

    // ----- ItemsRepeaterScrollHost class --------------------

    static PyObject* _new_ItemsRepeaterScrollHost(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_GET_SIZE(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Microsoft::UI::Xaml::Controls::ItemsRepeaterScrollHost instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ItemsRepeaterScrollHost(py::wrapper::Microsoft::UI::Xaml::Controls::ItemsRepeaterScrollHost* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ItemsRepeaterScrollHost_get_VerticalAnchorRatio(py::wrapper::Microsoft::UI::Xaml::Controls::ItemsRepeaterScrollHost* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ItemsRepeaterScrollHost", L"VerticalAnchorRatio");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.VerticalAnchorRatio();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ItemsRepeaterScrollHost_put_VerticalAnchorRatio(py::wrapper::Microsoft::UI::Xaml::Controls::ItemsRepeaterScrollHost* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ItemsRepeaterScrollHost", L"VerticalAnchorRatio");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<double>(arg);

            {
                auto _gil = release_gil();
                self->obj.VerticalAnchorRatio(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ItemsRepeaterScrollHost_get_ScrollViewer(py::wrapper::Microsoft::UI::Xaml::Controls::ItemsRepeaterScrollHost* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ItemsRepeaterScrollHost", L"ScrollViewer");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ScrollViewer();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ItemsRepeaterScrollHost_put_ScrollViewer(py::wrapper::Microsoft::UI::Xaml::Controls::ItemsRepeaterScrollHost* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ItemsRepeaterScrollHost", L"ScrollViewer");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::ScrollViewer>(arg);

            {
                auto _gil = release_gil();
                self->obj.ScrollViewer(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ItemsRepeaterScrollHost_get_HorizontalAnchorRatio(py::wrapper::Microsoft::UI::Xaml::Controls::ItemsRepeaterScrollHost* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ItemsRepeaterScrollHost", L"HorizontalAnchorRatio");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.HorizontalAnchorRatio();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ItemsRepeaterScrollHost_put_HorizontalAnchorRatio(py::wrapper::Microsoft::UI::Xaml::Controls::ItemsRepeaterScrollHost* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ItemsRepeaterScrollHost", L"HorizontalAnchorRatio");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<double>(arg);

            {
                auto _gil = release_gil();
                self->obj.HorizontalAnchorRatio(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ItemsRepeaterScrollHost_get_CurrentAnchor(py::wrapper::Microsoft::UI::Xaml::Controls::ItemsRepeaterScrollHost* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ItemsRepeaterScrollHost", L"CurrentAnchor");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.CurrentAnchor();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ItemsRepeaterScrollHost(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::ItemsRepeaterScrollHost>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ItemsRepeaterScrollHost(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::ItemsRepeaterScrollHost>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ItemsRepeaterScrollHost[] = {
        { "_assign_array_", _assign_array_ItemsRepeaterScrollHost, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ItemsRepeaterScrollHost), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_ItemsRepeaterScrollHost[] = {
        { "vertical_anchor_ratio", reinterpret_cast<getter>(ItemsRepeaterScrollHost_get_VerticalAnchorRatio), reinterpret_cast<setter>(ItemsRepeaterScrollHost_put_VerticalAnchorRatio), nullptr, nullptr },
        { "scroll_viewer", reinterpret_cast<getter>(ItemsRepeaterScrollHost_get_ScrollViewer), reinterpret_cast<setter>(ItemsRepeaterScrollHost_put_ScrollViewer), nullptr, nullptr },
        { "horizontal_anchor_ratio", reinterpret_cast<getter>(ItemsRepeaterScrollHost_get_HorizontalAnchorRatio), reinterpret_cast<setter>(ItemsRepeaterScrollHost_put_HorizontalAnchorRatio), nullptr, nullptr },
        { "current_anchor", reinterpret_cast<getter>(ItemsRepeaterScrollHost_get_CurrentAnchor), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_ItemsRepeaterScrollHost[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ItemsRepeaterScrollHost) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ItemsRepeaterScrollHost) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ItemsRepeaterScrollHost) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ItemsRepeaterScrollHost) },
        { }};

    static PyType_Spec type_spec_ItemsRepeaterScrollHost = {
        "winui2._winui2_microsoft_ui_xaml_controls.ItemsRepeaterScrollHost",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Controls::ItemsRepeaterScrollHost),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ItemsRepeaterScrollHost};

    // ----- ItemsSourceView class --------------------

    struct PyWinrtItemsSourceView;
    using BasePyWinrtItemsSourceView = winrt::Microsoft::UI::Xaml::Controls::ItemsSourceViewT<PyWinrtItemsSourceView, py::IPywinrtObject>;

    struct PyWinrtItemsSourceView : py::py_obj_ref, BasePyWinrtItemsSourceView
    {
        PyWinrtItemsSourceView(PyObject* py_obj, winrt::Windows::Foundation::IInspectable source) : py::py_obj_ref(py_obj), BasePyWinrtItemsSourceView(source) {}

        int32_t __stdcall GetPyObject(PyObject*& obj) override
        {
            obj = py::py_obj_ref::get_py_obj();
            return 0;
        }

        int32_t __stdcall GetComposableInner(winrt::Windows::Foundation::IInspectable& inner) override
        {
            inner = m_inner;
            return winrt::impl::error_ok;
        }

        static void toggle_reference(PyWinrtItemsSourceView* instance, bool is_last_reference)
        {
            py::py_obj_ref::toggle_reference(instance, is_last_reference);
        }

        int32_t query_interface_tearoff(winrt::guid const& id, void** result) const noexcept override
        {
            return py::py_obj_ref::query_interface_tearoff(id, result);
        }

        std::vector<winrt::guid> get_iids_tearoff() const noexcept override
        {
            return py::py_obj_ref::get_iids_tearoff();
        }
    };

    static PyObject* _new_ItemsSourceView(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_GET_SIZE(args);

        auto self_type = get_python_type_for<winrt::Microsoft::UI::Xaml::Controls::ItemsSourceView>();
        if (!self_type)
        {
            return nullptr;
        }

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 0);

                if (type != self_type)
                {
                    py::pyobj_handle self{type->tp_alloc(type, 0)};
                    if (!self)
                    {
                        return nullptr;
                    }

                    std::construct_at(&reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj, nullptr);

                    auto obj_impl = winrt::make_self<PyWinrtItemsSourceView>(self.get(), param0);

                    auto obj = py::make_py_obj<PyWinrtItemsSourceView>(obj_impl, type, self.get());
                    if (!obj)
                    {
                        return nullptr;
                    }

                    reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj = std::move(obj);

                    return self.detach();
                }

                winrt::Microsoft::UI::Xaml::Controls::ItemsSourceView instance{param0};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ItemsSourceView(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ItemsSourceView_GetAt(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.ItemsSourceView", L"GetAt", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<int32_t>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::ItemsSourceView>().GetAt(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ItemsSourceView_IndexFromKey(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.ItemsSourceView", L"IndexFromKey", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::ItemsSourceView>().IndexFromKey(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ItemsSourceView_IndexOf(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.ItemsSourceView", L"IndexOf", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::ItemsSourceView>().IndexOf(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ItemsSourceView_KeyFromIndex(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.ItemsSourceView", L"KeyFromIndex", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<int32_t>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::ItemsSourceView>().KeyFromIndex(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ItemsSourceView_get_Count(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ItemsSourceView", L"Count");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::ItemsSourceView>().Count();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ItemsSourceView_get_HasKeyIndexMapping(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ItemsSourceView", L"HasKeyIndexMapping");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::ItemsSourceView>().HasKeyIndexMapping();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ItemsSourceView_add_CollectionChanged(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.ItemsSourceView", L"CollectionChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Interop::NotifyCollectionChangedEventHandler>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::ItemsSourceView>().CollectionChanged(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ItemsSourceView_remove_CollectionChanged(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.ItemsSourceView", L"CollectionChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::ItemsSourceView>().CollectionChanged(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ItemsSourceView(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::ItemsSourceView>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ItemsSourceView(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::ItemsSourceView>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ItemsSourceView[] = {
        { "get_at", reinterpret_cast<PyCFunction>(ItemsSourceView_GetAt), METH_VARARGS, nullptr },
        { "index_from_key", reinterpret_cast<PyCFunction>(ItemsSourceView_IndexFromKey), METH_VARARGS, nullptr },
        { "index_of", reinterpret_cast<PyCFunction>(ItemsSourceView_IndexOf), METH_VARARGS, nullptr },
        { "key_from_index", reinterpret_cast<PyCFunction>(ItemsSourceView_KeyFromIndex), METH_VARARGS, nullptr },
        { "add_collection_changed", reinterpret_cast<PyCFunction>(ItemsSourceView_add_CollectionChanged), METH_O, nullptr },
        { "remove_collection_changed", reinterpret_cast<PyCFunction>(ItemsSourceView_remove_CollectionChanged), METH_O, nullptr },
        { "_assign_array_", _assign_array_ItemsSourceView, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ItemsSourceView), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_ItemsSourceView[] = {
        { "count", reinterpret_cast<getter>(ItemsSourceView_get_Count), nullptr, nullptr, nullptr },
        { "has_key_index_mapping", reinterpret_cast<getter>(ItemsSourceView_get_HasKeyIndexMapping), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_ItemsSourceView[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ItemsSourceView) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ItemsSourceView) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ItemsSourceView) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ItemsSourceView) },
        { }};

    static PyType_Spec type_spec_ItemsSourceView = {
        "winui2._winui2_microsoft_ui_xaml_controls.ItemsSourceView",
        sizeof(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_ItemsSourceView};

    static PyGetSetDef getset_ItemsSourceView_Static[] = {
        { }};

    static PyMethodDef methods_ItemsSourceView_Static[] = {
        { }};

    static PyType_Slot type_slots_ItemsSourceView_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_ItemsSourceView_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_ItemsSourceView_Static) },
        { }
    };

    static PyType_Spec type_spec_ItemsSourceView_Static = {
        "winui2._winui2_microsoft_ui_xaml_controls.ItemsSourceView_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_ItemsSourceView_Static};

    // ----- Layout class --------------------

    static PyObject* _new_Layout(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Xaml::Controls::Layout>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Xaml::Controls::Layout>::type_name);
        return nullptr;
    }

    static void _dealloc_Layout(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* Layout_Arrange(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.Layout", L"Arrange", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::LayoutContext>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Size>(args, 1);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Layout>().Arrange(param0, param1);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Layout_InitializeForContext(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.Layout", L"InitializeForContext", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::LayoutContext>(args, 0);

                {
                    auto _gil = release_gil();
                    self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Layout>().InitializeForContext(param0);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Layout_InvalidateArrange(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.Layout", L"InvalidateArrange", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::ILayoutProtected>().InvalidateArrange();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Layout_InvalidateMeasure(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.Layout", L"InvalidateMeasure", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::ILayoutProtected>().InvalidateMeasure();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Layout_Measure(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.Layout", L"Measure", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::LayoutContext>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Size>(args, 1);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Layout>().Measure(param0, param1);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Layout_UninitializeForContext(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.Layout", L"UninitializeForContext", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::LayoutContext>(args, 0);

                {
                    auto _gil = release_gil();
                    self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Layout>().UninitializeForContext(param0);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Layout_add_ArrangeInvalidated(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.Layout", L"ArrangeInvalidated");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Xaml::Controls::Layout, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Layout>().ArrangeInvalidated(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Layout_remove_ArrangeInvalidated(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.Layout", L"ArrangeInvalidated");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Layout>().ArrangeInvalidated(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Layout_add_MeasureInvalidated(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.Layout", L"MeasureInvalidated");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Xaml::Controls::Layout, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Layout>().MeasureInvalidated(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Layout_remove_MeasureInvalidated(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.Layout", L"MeasureInvalidated");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Layout>().MeasureInvalidated(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_Layout(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::Layout>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_Layout(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::Layout>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_Layout[] = {
        { "arrange", reinterpret_cast<PyCFunction>(Layout_Arrange), METH_VARARGS, nullptr },
        { "initialize_for_context", reinterpret_cast<PyCFunction>(Layout_InitializeForContext), METH_VARARGS, nullptr },
        { "_invalidate_arrange", reinterpret_cast<PyCFunction>(Layout_InvalidateArrange), METH_VARARGS, nullptr },
        { "_invalidate_measure", reinterpret_cast<PyCFunction>(Layout_InvalidateMeasure), METH_VARARGS, nullptr },
        { "measure", reinterpret_cast<PyCFunction>(Layout_Measure), METH_VARARGS, nullptr },
        { "uninitialize_for_context", reinterpret_cast<PyCFunction>(Layout_UninitializeForContext), METH_VARARGS, nullptr },
        { "add_arrange_invalidated", reinterpret_cast<PyCFunction>(Layout_add_ArrangeInvalidated), METH_O, nullptr },
        { "remove_arrange_invalidated", reinterpret_cast<PyCFunction>(Layout_remove_ArrangeInvalidated), METH_O, nullptr },
        { "add_measure_invalidated", reinterpret_cast<PyCFunction>(Layout_add_MeasureInvalidated), METH_O, nullptr },
        { "remove_measure_invalidated", reinterpret_cast<PyCFunction>(Layout_remove_MeasureInvalidated), METH_O, nullptr },
        { "_assign_array_", _assign_array_Layout, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_Layout), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_Layout[] = {
        { }};

    static PyType_Slot _type_slots_Layout[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_Layout) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_Layout) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_Layout) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_Layout) },
        { }};

    static PyType_Spec type_spec_Layout = {
        "winui2._winui2_microsoft_ui_xaml_controls.Layout",
        sizeof(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_Layout};

    static PyGetSetDef getset_Layout_Static[] = {
        { }};

    static PyMethodDef methods_Layout_Static[] = {
        { }};

    static PyType_Slot type_slots_Layout_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_Layout_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_Layout_Static) },
        { }
    };

    static PyType_Spec type_spec_Layout_Static = {
        "winui2._winui2_microsoft_ui_xaml_controls.Layout_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_Layout_Static};

    // ----- LayoutContext class --------------------

    static PyObject* _new_LayoutContext(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Xaml::Controls::LayoutContext>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Xaml::Controls::LayoutContext>::type_name);
        return nullptr;
    }

    static void _dealloc_LayoutContext(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* LayoutContext_get_LayoutState(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.LayoutContext", L"LayoutState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::LayoutContext>().LayoutState();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LayoutContext_put_LayoutState(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.LayoutContext", L"LayoutState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::LayoutContext>().LayoutState(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_LayoutContext(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::LayoutContext>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_LayoutContext(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::LayoutContext>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_LayoutContext[] = {
        { "_assign_array_", _assign_array_LayoutContext, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_LayoutContext), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_LayoutContext[] = {
        { "layout_state", reinterpret_cast<getter>(LayoutContext_get_LayoutState), reinterpret_cast<setter>(LayoutContext_put_LayoutState), nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_LayoutContext[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_LayoutContext) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_LayoutContext) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_LayoutContext) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_LayoutContext) },
        { }};

    static PyType_Spec type_spec_LayoutContext = {
        "winui2._winui2_microsoft_ui_xaml_controls.LayoutContext",
        sizeof(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_LayoutContext};

    static PyGetSetDef getset_LayoutContext_Static[] = {
        { }};

    static PyMethodDef methods_LayoutContext_Static[] = {
        { }};

    static PyType_Slot type_slots_LayoutContext_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_LayoutContext_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_LayoutContext_Static) },
        { }
    };

    static PyType_Spec type_spec_LayoutContext_Static = {
        "winui2._winui2_microsoft_ui_xaml_controls.LayoutContext_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_LayoutContext_Static};

    // ----- MenuBar class --------------------

    struct PyWinrtMenuBar;
    using BasePyWinrtMenuBar = winrt::Microsoft::UI::Xaml::Controls::MenuBarT<PyWinrtMenuBar, py::IPywinrtObject>;

    struct PyWinrtMenuBar : py::py_obj_ref, BasePyWinrtMenuBar
    {
        PyWinrtMenuBar(PyObject* py_obj) : py::py_obj_ref(py_obj), BasePyWinrtMenuBar() {}

        int32_t __stdcall GetPyObject(PyObject*& obj) override
        {
            obj = py::py_obj_ref::get_py_obj();
            return 0;
        }

        int32_t __stdcall GetComposableInner(winrt::Windows::Foundation::IInspectable& inner) override
        {
            inner = m_inner;
            return winrt::impl::error_ok;
        }

        static void toggle_reference(PyWinrtMenuBar* instance, bool is_last_reference)
        {
            py::py_obj_ref::toggle_reference(instance, is_last_reference);
        }

        int32_t query_interface_tearoff(winrt::guid const& id, void** result) const noexcept override
        {
            return py::py_obj_ref::query_interface_tearoff(id, result);
        }

        std::vector<winrt::guid> get_iids_tearoff() const noexcept override
        {
            return py::py_obj_ref::get_iids_tearoff();
        }
    };

    static PyObject* _new_MenuBar(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_GET_SIZE(args);

        auto self_type = get_python_type_for<winrt::Microsoft::UI::Xaml::Controls::MenuBar>();
        if (!self_type)
        {
            return nullptr;
        }

        if (arg_count == 0)
        {
            try
            {
                if (type != self_type)
                {
                    py::pyobj_handle self{type->tp_alloc(type, 0)};
                    if (!self)
                    {
                        return nullptr;
                    }

                    std::construct_at(&reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj, nullptr);

                    auto obj_impl = winrt::make_self<PyWinrtMenuBar>(self.get());

                    auto obj = py::make_py_obj<PyWinrtMenuBar>(obj_impl, type, self.get());
                    if (!obj)
                    {
                        return nullptr;
                    }

                    reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj = std::move(obj);

                    return self.detach();
                }

                winrt::Microsoft::UI::Xaml::Controls::MenuBar instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_MenuBar(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MenuBar_get_Items(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.MenuBar", L"Items");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::MenuBar>().Items();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MenuBar_get_ItemsProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.MenuBar", L"ItemsProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::MenuBar::ItemsProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MenuBar(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::MenuBar>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MenuBar(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::MenuBar>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MenuBar[] = {
        { "_assign_array_", _assign_array_MenuBar, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MenuBar), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_MenuBar[] = {
        { "items", reinterpret_cast<getter>(MenuBar_get_Items), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_MenuBar[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_MenuBar) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MenuBar) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MenuBar) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MenuBar) },
        { }};

    static PyType_Spec type_spec_MenuBar = {
        "winui2._winui2_microsoft_ui_xaml_controls.MenuBar",
        sizeof(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_MenuBar};

    static PyGetSetDef getset_MenuBar_Static[] = {
        { "items_property", reinterpret_cast<getter>(MenuBar_get_ItemsProperty), nullptr, nullptr, nullptr },
        { }};

    static PyMethodDef methods_MenuBar_Static[] = {
        { }};

    static PyType_Slot type_slots_MenuBar_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_MenuBar_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_MenuBar_Static) },
        { }
    };

    static PyType_Spec type_spec_MenuBar_Static = {
        "winui2._winui2_microsoft_ui_xaml_controls.MenuBar_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_MenuBar_Static};

    // ----- MenuBarItem class --------------------

    struct PyWinrtMenuBarItem;
    using BasePyWinrtMenuBarItem = winrt::Microsoft::UI::Xaml::Controls::MenuBarItemT<PyWinrtMenuBarItem, py::IPywinrtObject>;

    struct PyWinrtMenuBarItem : py::py_obj_ref, BasePyWinrtMenuBarItem
    {
        PyWinrtMenuBarItem(PyObject* py_obj) : py::py_obj_ref(py_obj), BasePyWinrtMenuBarItem() {}

        int32_t __stdcall GetPyObject(PyObject*& obj) override
        {
            obj = py::py_obj_ref::get_py_obj();
            return 0;
        }

        int32_t __stdcall GetComposableInner(winrt::Windows::Foundation::IInspectable& inner) override
        {
            inner = m_inner;
            return winrt::impl::error_ok;
        }

        static void toggle_reference(PyWinrtMenuBarItem* instance, bool is_last_reference)
        {
            py::py_obj_ref::toggle_reference(instance, is_last_reference);
        }

        int32_t query_interface_tearoff(winrt::guid const& id, void** result) const noexcept override
        {
            return py::py_obj_ref::query_interface_tearoff(id, result);
        }

        std::vector<winrt::guid> get_iids_tearoff() const noexcept override
        {
            return py::py_obj_ref::get_iids_tearoff();
        }
    };

    static PyObject* _new_MenuBarItem(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_GET_SIZE(args);

        auto self_type = get_python_type_for<winrt::Microsoft::UI::Xaml::Controls::MenuBarItem>();
        if (!self_type)
        {
            return nullptr;
        }

        if (arg_count == 0)
        {
            try
            {
                if (type != self_type)
                {
                    py::pyobj_handle self{type->tp_alloc(type, 0)};
                    if (!self)
                    {
                        return nullptr;
                    }

                    std::construct_at(&reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj, nullptr);

                    auto obj_impl = winrt::make_self<PyWinrtMenuBarItem>(self.get());

                    auto obj = py::make_py_obj<PyWinrtMenuBarItem>(obj_impl, type, self.get());
                    if (!obj)
                    {
                        return nullptr;
                    }

                    reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj = std::move(obj);

                    return self.detach();
                }

                winrt::Microsoft::UI::Xaml::Controls::MenuBarItem instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_MenuBarItem(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MenuBarItem_get_Title(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.MenuBarItem", L"Title");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::MenuBarItem>().Title();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MenuBarItem_put_Title(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.MenuBarItem", L"Title");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::MenuBarItem>().Title(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MenuBarItem_get_Items(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.MenuBarItem", L"Items");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::MenuBarItem>().Items();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MenuBarItem_get_ItemsProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.MenuBarItem", L"ItemsProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::MenuBarItem::ItemsProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MenuBarItem_get_TitleProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.MenuBarItem", L"TitleProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::MenuBarItem::TitleProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MenuBarItem(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::MenuBarItem>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MenuBarItem(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::MenuBarItem>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MenuBarItem[] = {
        { "_assign_array_", _assign_array_MenuBarItem, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MenuBarItem), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_MenuBarItem[] = {
        { "title", reinterpret_cast<getter>(MenuBarItem_get_Title), reinterpret_cast<setter>(MenuBarItem_put_Title), nullptr, nullptr },
        { "items", reinterpret_cast<getter>(MenuBarItem_get_Items), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_MenuBarItem[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_MenuBarItem) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MenuBarItem) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MenuBarItem) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MenuBarItem) },
        { }};

    static PyType_Spec type_spec_MenuBarItem = {
        "winui2._winui2_microsoft_ui_xaml_controls.MenuBarItem",
        sizeof(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_MenuBarItem};

    static PyGetSetDef getset_MenuBarItem_Static[] = {
        { "items_property", reinterpret_cast<getter>(MenuBarItem_get_ItemsProperty), nullptr, nullptr, nullptr },
        { "title_property", reinterpret_cast<getter>(MenuBarItem_get_TitleProperty), nullptr, nullptr, nullptr },
        { }};

    static PyMethodDef methods_MenuBarItem_Static[] = {
        { }};

    static PyType_Slot type_slots_MenuBarItem_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_MenuBarItem_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_MenuBarItem_Static) },
        { }
    };

    static PyType_Spec type_spec_MenuBarItem_Static = {
        "winui2._winui2_microsoft_ui_xaml_controls.MenuBarItem_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_MenuBarItem_Static};

    // ----- MenuBarItemFlyout class --------------------

    struct PyWinrtMenuBarItemFlyout;
    using BasePyWinrtMenuBarItemFlyout = winrt::Microsoft::UI::Xaml::Controls::MenuBarItemFlyoutT<PyWinrtMenuBarItemFlyout, py::IPywinrtObject>;

    struct PyWinrtMenuBarItemFlyout : py::py_obj_ref, BasePyWinrtMenuBarItemFlyout
    {
        PyWinrtMenuBarItemFlyout(PyObject* py_obj) : py::py_obj_ref(py_obj), BasePyWinrtMenuBarItemFlyout() {}

        int32_t __stdcall GetPyObject(PyObject*& obj) override
        {
            obj = py::py_obj_ref::get_py_obj();
            return 0;
        }

        int32_t __stdcall GetComposableInner(winrt::Windows::Foundation::IInspectable& inner) override
        {
            inner = m_inner;
            return winrt::impl::error_ok;
        }

        static void toggle_reference(PyWinrtMenuBarItemFlyout* instance, bool is_last_reference)
        {
            py::py_obj_ref::toggle_reference(instance, is_last_reference);
        }

        int32_t query_interface_tearoff(winrt::guid const& id, void** result) const noexcept override
        {
            return py::py_obj_ref::query_interface_tearoff(id, result);
        }

        std::vector<winrt::guid> get_iids_tearoff() const noexcept override
        {
            return py::py_obj_ref::get_iids_tearoff();
        }
    };

    static PyObject* _new_MenuBarItemFlyout(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_GET_SIZE(args);

        auto self_type = get_python_type_for<winrt::Microsoft::UI::Xaml::Controls::MenuBarItemFlyout>();
        if (!self_type)
        {
            return nullptr;
        }

        if (arg_count == 0)
        {
            try
            {
                if (type != self_type)
                {
                    py::pyobj_handle self{type->tp_alloc(type, 0)};
                    if (!self)
                    {
                        return nullptr;
                    }

                    std::construct_at(&reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj, nullptr);

                    auto obj_impl = winrt::make_self<PyWinrtMenuBarItemFlyout>(self.get());

                    auto obj = py::make_py_obj<PyWinrtMenuBarItemFlyout>(obj_impl, type, self.get());
                    if (!obj)
                    {
                        return nullptr;
                    }

                    reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj = std::move(obj);

                    return self.detach();
                }

                winrt::Microsoft::UI::Xaml::Controls::MenuBarItemFlyout instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_MenuBarItemFlyout(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_MenuBarItemFlyout(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::MenuBarItemFlyout>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MenuBarItemFlyout(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::MenuBarItemFlyout>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MenuBarItemFlyout[] = {
        { "_assign_array_", _assign_array_MenuBarItemFlyout, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MenuBarItemFlyout), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_MenuBarItemFlyout[] = {
        { }};

    static PyType_Slot _type_slots_MenuBarItemFlyout[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_MenuBarItemFlyout) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MenuBarItemFlyout) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MenuBarItemFlyout) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MenuBarItemFlyout) },
        { }};

    static PyType_Spec type_spec_MenuBarItemFlyout = {
        "winui2._winui2_microsoft_ui_xaml_controls.MenuBarItemFlyout",
        sizeof(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_MenuBarItemFlyout};

    static PyGetSetDef getset_MenuBarItemFlyout_Static[] = {
        { }};

    static PyMethodDef methods_MenuBarItemFlyout_Static[] = {
        { }};

    static PyType_Slot type_slots_MenuBarItemFlyout_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_MenuBarItemFlyout_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_MenuBarItemFlyout_Static) },
        { }
    };

    static PyType_Spec type_spec_MenuBarItemFlyout_Static = {
        "winui2._winui2_microsoft_ui_xaml_controls.MenuBarItemFlyout_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_MenuBarItemFlyout_Static};

    // ----- NavigationView class --------------------

    struct PyWinrtNavigationView;
    using BasePyWinrtNavigationView = winrt::Microsoft::UI::Xaml::Controls::NavigationViewT<PyWinrtNavigationView, py::IPywinrtObject>;

    struct PyWinrtNavigationView : py::py_obj_ref, BasePyWinrtNavigationView
    {
        PyWinrtNavigationView(PyObject* py_obj) : py::py_obj_ref(py_obj), BasePyWinrtNavigationView() {}

        int32_t __stdcall GetPyObject(PyObject*& obj) override
        {
            obj = py::py_obj_ref::get_py_obj();
            return 0;
        }

        int32_t __stdcall GetComposableInner(winrt::Windows::Foundation::IInspectable& inner) override
        {
            inner = m_inner;
            return winrt::impl::error_ok;
        }

        static void toggle_reference(PyWinrtNavigationView* instance, bool is_last_reference)
        {
            py::py_obj_ref::toggle_reference(instance, is_last_reference);
        }

        int32_t query_interface_tearoff(winrt::guid const& id, void** result) const noexcept override
        {
            return py::py_obj_ref::query_interface_tearoff(id, result);
        }

        std::vector<winrt::guid> get_iids_tearoff() const noexcept override
        {
            return py::py_obj_ref::get_iids_tearoff();
        }
    };

    static PyObject* _new_NavigationView(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_GET_SIZE(args);

        auto self_type = get_python_type_for<winrt::Microsoft::UI::Xaml::Controls::NavigationView>();
        if (!self_type)
        {
            return nullptr;
        }

        if (arg_count == 0)
        {
            try
            {
                if (type != self_type)
                {
                    py::pyobj_handle self{type->tp_alloc(type, 0)};
                    if (!self)
                    {
                        return nullptr;
                    }

                    std::construct_at(&reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj, nullptr);

                    auto obj_impl = winrt::make_self<PyWinrtNavigationView>(self.get());

                    auto obj = py::make_py_obj<PyWinrtNavigationView>(obj_impl, type, self.get());
                    if (!obj)
                    {
                        return nullptr;
                    }

                    reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj = std::move(obj);

                    return self.detach();
                }

                winrt::Microsoft::UI::Xaml::Controls::NavigationView instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_NavigationView(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* NavigationView_Collapse(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.NavigationView", L"Collapse", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::NavigationViewItem>(args, 0);

                {
                    auto _gil = release_gil();
                    self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::NavigationView>().Collapse(param0);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* NavigationView_ContainerFromMenuItem(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.NavigationView", L"ContainerFromMenuItem", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::NavigationView>().ContainerFromMenuItem(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* NavigationView_Expand(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.NavigationView", L"Expand", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::NavigationViewItem>(args, 0);

                {
                    auto _gil = release_gil();
                    self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::NavigationView>().Expand(param0);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* NavigationView_MenuItemFromContainer(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.NavigationView", L"MenuItemFromContainer", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::DependencyObject>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::NavigationView>().MenuItemFromContainer(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* NavigationView_get_SelectedItem(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.NavigationView", L"SelectedItem");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::NavigationView>().SelectedItem();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int NavigationView_put_SelectedItem(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.NavigationView", L"SelectedItem");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::NavigationView>().SelectedItem(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* NavigationView_get_PaneToggleButtonStyle(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.NavigationView", L"PaneToggleButtonStyle");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::NavigationView>().PaneToggleButtonStyle();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int NavigationView_put_PaneToggleButtonStyle(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.NavigationView", L"PaneToggleButtonStyle");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Style>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::NavigationView>().PaneToggleButtonStyle(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* NavigationView_get_PaneFooter(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.NavigationView", L"PaneFooter");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::NavigationView>().PaneFooter();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int NavigationView_put_PaneFooter(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.NavigationView", L"PaneFooter");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::UIElement>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::NavigationView>().PaneFooter(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* NavigationView_get_OpenPaneLength(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.NavigationView", L"OpenPaneLength");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::NavigationView>().OpenPaneLength();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int NavigationView_put_OpenPaneLength(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.NavigationView", L"OpenPaneLength");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<double>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::NavigationView>().OpenPaneLength(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* NavigationView_get_MenuItemsSource(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.NavigationView", L"MenuItemsSource");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::NavigationView>().MenuItemsSource();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int NavigationView_put_MenuItemsSource(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.NavigationView", L"MenuItemsSource");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::NavigationView>().MenuItemsSource(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* NavigationView_get_MenuItemContainerStyleSelector(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.NavigationView", L"MenuItemContainerStyleSelector");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::NavigationView>().MenuItemContainerStyleSelector();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int NavigationView_put_MenuItemContainerStyleSelector(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.NavigationView", L"MenuItemContainerStyleSelector");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::StyleSelector>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::NavigationView>().MenuItemContainerStyleSelector(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* NavigationView_get_MenuItemContainerStyle(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.NavigationView", L"MenuItemContainerStyle");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::NavigationView>().MenuItemContainerStyle();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int NavigationView_put_MenuItemContainerStyle(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.NavigationView", L"MenuItemContainerStyle");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Style>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::NavigationView>().MenuItemContainerStyle(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* NavigationView_get_IsTitleBarAutoPaddingEnabled(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.NavigationView", L"IsTitleBarAutoPaddingEnabled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::NavigationView>().IsTitleBarAutoPaddingEnabled();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int NavigationView_put_IsTitleBarAutoPaddingEnabled(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.NavigationView", L"IsTitleBarAutoPaddingEnabled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::NavigationView>().IsTitleBarAutoPaddingEnabled(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* NavigationView_get_IsSettingsVisible(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.NavigationView", L"IsSettingsVisible");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::NavigationView>().IsSettingsVisible();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int NavigationView_put_IsSettingsVisible(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.NavigationView", L"IsSettingsVisible");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::NavigationView>().IsSettingsVisible(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* NavigationView_get_IsPaneToggleButtonVisible(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.NavigationView", L"IsPaneToggleButtonVisible");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::NavigationView>().IsPaneToggleButtonVisible();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int NavigationView_put_IsPaneToggleButtonVisible(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.NavigationView", L"IsPaneToggleButtonVisible");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::NavigationView>().IsPaneToggleButtonVisible(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* NavigationView_get_IsPaneOpen(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.NavigationView", L"IsPaneOpen");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::NavigationView>().IsPaneOpen();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int NavigationView_put_IsPaneOpen(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.NavigationView", L"IsPaneOpen");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::NavigationView>().IsPaneOpen(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* NavigationView_get_HeaderTemplate(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.NavigationView", L"HeaderTemplate");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::NavigationView>().HeaderTemplate();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int NavigationView_put_HeaderTemplate(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.NavigationView", L"HeaderTemplate");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::DataTemplate>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::NavigationView>().HeaderTemplate(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* NavigationView_get_Header(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.NavigationView", L"Header");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::NavigationView>().Header();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int NavigationView_put_Header(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.NavigationView", L"Header");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::NavigationView>().Header(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* NavigationView_get_FooterMenuItemsSource(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.NavigationView", L"FooterMenuItemsSource");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::NavigationView>().FooterMenuItemsSource();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int NavigationView_put_FooterMenuItemsSource(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.NavigationView", L"FooterMenuItemsSource");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::NavigationView>().FooterMenuItemsSource(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* NavigationView_get_MenuItemTemplateSelector(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.NavigationView", L"MenuItemTemplateSelector");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::NavigationView>().MenuItemTemplateSelector();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int NavigationView_put_MenuItemTemplateSelector(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.NavigationView", L"MenuItemTemplateSelector");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::DataTemplateSelector>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::NavigationView>().MenuItemTemplateSelector(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* NavigationView_get_ExpandedModeThresholdWidth(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.NavigationView", L"ExpandedModeThresholdWidth");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::NavigationView>().ExpandedModeThresholdWidth();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int NavigationView_put_ExpandedModeThresholdWidth(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.NavigationView", L"ExpandedModeThresholdWidth");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<double>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::NavigationView>().ExpandedModeThresholdWidth(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* NavigationView_get_MenuItemTemplate(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.NavigationView", L"MenuItemTemplate");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::NavigationView>().MenuItemTemplate();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int NavigationView_put_MenuItemTemplate(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.NavigationView", L"MenuItemTemplate");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::DataTemplate>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::NavigationView>().MenuItemTemplate(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* NavigationView_get_CompactPaneLength(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.NavigationView", L"CompactPaneLength");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::NavigationView>().CompactPaneLength();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int NavigationView_put_CompactPaneLength(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.NavigationView", L"CompactPaneLength");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<double>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::NavigationView>().CompactPaneLength(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* NavigationView_get_CompactModeThresholdWidth(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.NavigationView", L"CompactModeThresholdWidth");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::NavigationView>().CompactModeThresholdWidth();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int NavigationView_put_CompactModeThresholdWidth(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.NavigationView", L"CompactModeThresholdWidth");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<double>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::NavigationView>().CompactModeThresholdWidth(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* NavigationView_get_AutoSuggestBox(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.NavigationView", L"AutoSuggestBox");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::NavigationView>().AutoSuggestBox();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int NavigationView_put_AutoSuggestBox(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.NavigationView", L"AutoSuggestBox");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::AutoSuggestBox>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::NavigationView>().AutoSuggestBox(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* NavigationView_get_AlwaysShowHeader(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.NavigationView", L"AlwaysShowHeader");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::NavigationView>().AlwaysShowHeader();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int NavigationView_put_AlwaysShowHeader(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.NavigationView", L"AlwaysShowHeader");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::NavigationView>().AlwaysShowHeader(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* NavigationView_get_MenuItems(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.NavigationView", L"MenuItems");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::NavigationView>().MenuItems();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NavigationView_get_DisplayMode(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.NavigationView", L"DisplayMode");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::NavigationView>().DisplayMode();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NavigationView_get_FooterMenuItems(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.NavigationView", L"FooterMenuItems");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::NavigationView>().FooterMenuItems();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NavigationView_get_SettingsItem(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.NavigationView", L"SettingsItem");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::NavigationView>().SettingsItem();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NavigationView_get_ShoulderNavigationEnabled(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.NavigationView", L"ShoulderNavigationEnabled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::NavigationView>().ShoulderNavigationEnabled();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int NavigationView_put_ShoulderNavigationEnabled(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.NavigationView", L"ShoulderNavigationEnabled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::NavigationViewShoulderNavigationEnabled>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::NavigationView>().ShoulderNavigationEnabled(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* NavigationView_get_SelectionFollowsFocus(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.NavigationView", L"SelectionFollowsFocus");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::NavigationView>().SelectionFollowsFocus();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int NavigationView_put_SelectionFollowsFocus(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.NavigationView", L"SelectionFollowsFocus");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::NavigationViewSelectionFollowsFocus>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::NavigationView>().SelectionFollowsFocus(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* NavigationView_get_PaneTitle(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.NavigationView", L"PaneTitle");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::NavigationView>().PaneTitle();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int NavigationView_put_PaneTitle(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.NavigationView", L"PaneTitle");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::NavigationView>().PaneTitle(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* NavigationView_get_PaneHeader(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.NavigationView", L"PaneHeader");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::NavigationView>().PaneHeader();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int NavigationView_put_PaneHeader(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.NavigationView", L"PaneHeader");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::UIElement>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::NavigationView>().PaneHeader(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* NavigationView_get_PaneDisplayMode(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.NavigationView", L"PaneDisplayMode");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::NavigationView>().PaneDisplayMode();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int NavigationView_put_PaneDisplayMode(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.NavigationView", L"PaneDisplayMode");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::NavigationViewPaneDisplayMode>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::NavigationView>().PaneDisplayMode(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* NavigationView_get_PaneCustomContent(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.NavigationView", L"PaneCustomContent");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::NavigationView>().PaneCustomContent();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int NavigationView_put_PaneCustomContent(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.NavigationView", L"PaneCustomContent");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::UIElement>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::NavigationView>().PaneCustomContent(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* NavigationView_get_OverflowLabelMode(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.NavigationView", L"OverflowLabelMode");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::NavigationView>().OverflowLabelMode();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int NavigationView_put_OverflowLabelMode(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.NavigationView", L"OverflowLabelMode");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::NavigationViewOverflowLabelMode>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::NavigationView>().OverflowLabelMode(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* NavigationView_get_IsPaneVisible(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.NavigationView", L"IsPaneVisible");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::NavigationView>().IsPaneVisible();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int NavigationView_put_IsPaneVisible(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.NavigationView", L"IsPaneVisible");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::NavigationView>().IsPaneVisible(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* NavigationView_get_IsBackEnabled(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.NavigationView", L"IsBackEnabled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::NavigationView>().IsBackEnabled();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int NavigationView_put_IsBackEnabled(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.NavigationView", L"IsBackEnabled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::NavigationView>().IsBackEnabled(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* NavigationView_get_IsBackButtonVisible(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.NavigationView", L"IsBackButtonVisible");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::NavigationView>().IsBackButtonVisible();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int NavigationView_put_IsBackButtonVisible(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.NavigationView", L"IsBackButtonVisible");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::NavigationViewBackButtonVisible>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::NavigationView>().IsBackButtonVisible(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* NavigationView_get_ContentOverlay(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.NavigationView", L"ContentOverlay");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::NavigationView>().ContentOverlay();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int NavigationView_put_ContentOverlay(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.NavigationView", L"ContentOverlay");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::UIElement>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::NavigationView>().ContentOverlay(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* NavigationView_get_TemplateSettings(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.NavigationView", L"TemplateSettings");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::NavigationView>().TemplateSettings();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NavigationView_get_FooterMenuItemsProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.NavigationView", L"FooterMenuItemsProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::NavigationView::FooterMenuItemsProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NavigationView_get_IsTitleBarAutoPaddingEnabledProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.NavigationView", L"IsTitleBarAutoPaddingEnabledProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::NavigationView::IsTitleBarAutoPaddingEnabledProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NavigationView_get_MenuItemContainerStyleProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.NavigationView", L"MenuItemContainerStyleProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::NavigationView::MenuItemContainerStyleProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NavigationView_get_MenuItemContainerStyleSelectorProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.NavigationView", L"MenuItemContainerStyleSelectorProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::NavigationView::MenuItemContainerStyleSelectorProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NavigationView_get_MenuItemTemplateProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.NavigationView", L"MenuItemTemplateProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::NavigationView::MenuItemTemplateProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NavigationView_get_MenuItemTemplateSelectorProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.NavigationView", L"MenuItemTemplateSelectorProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::NavigationView::MenuItemTemplateSelectorProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NavigationView_get_MenuItemsProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.NavigationView", L"MenuItemsProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::NavigationView::MenuItemsProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NavigationView_get_MenuItemsSourceProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.NavigationView", L"MenuItemsSourceProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::NavigationView::MenuItemsSourceProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NavigationView_get_OpenPaneLengthProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.NavigationView", L"OpenPaneLengthProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::NavigationView::OpenPaneLengthProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NavigationView_get_PaneFooterProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.NavigationView", L"PaneFooterProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::NavigationView::PaneFooterProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NavigationView_get_PaneToggleButtonStyleProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.NavigationView", L"PaneToggleButtonStyleProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::NavigationView::PaneToggleButtonStyleProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NavigationView_get_SelectedItemProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.NavigationView", L"SelectedItemProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::NavigationView::SelectedItemProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NavigationView_get_AlwaysShowHeaderProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.NavigationView", L"AlwaysShowHeaderProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::NavigationView::AlwaysShowHeaderProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NavigationView_get_AutoSuggestBoxProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.NavigationView", L"AutoSuggestBoxProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::NavigationView::AutoSuggestBoxProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NavigationView_get_CompactModeThresholdWidthProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.NavigationView", L"CompactModeThresholdWidthProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::NavigationView::CompactModeThresholdWidthProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NavigationView_get_CompactPaneLengthProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.NavigationView", L"CompactPaneLengthProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::NavigationView::CompactPaneLengthProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NavigationView_get_DisplayModeProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.NavigationView", L"DisplayModeProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::NavigationView::DisplayModeProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NavigationView_get_ExpandedModeThresholdWidthProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.NavigationView", L"ExpandedModeThresholdWidthProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::NavigationView::ExpandedModeThresholdWidthProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NavigationView_get_SettingsItemProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.NavigationView", L"SettingsItemProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::NavigationView::SettingsItemProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NavigationView_get_FooterMenuItemsSourceProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.NavigationView", L"FooterMenuItemsSourceProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::NavigationView::FooterMenuItemsSourceProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NavigationView_get_HeaderProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.NavigationView", L"HeaderProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::NavigationView::HeaderProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NavigationView_get_HeaderTemplateProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.NavigationView", L"HeaderTemplateProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::NavigationView::HeaderTemplateProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NavigationView_get_IsPaneOpenProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.NavigationView", L"IsPaneOpenProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::NavigationView::IsPaneOpenProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NavigationView_get_IsPaneToggleButtonVisibleProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.NavigationView", L"IsPaneToggleButtonVisibleProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::NavigationView::IsPaneToggleButtonVisibleProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NavigationView_get_IsSettingsVisibleProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.NavigationView", L"IsSettingsVisibleProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::NavigationView::IsSettingsVisibleProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NavigationView_get_IsBackButtonVisibleProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.NavigationView", L"IsBackButtonVisibleProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::NavigationView::IsBackButtonVisibleProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NavigationView_get_IsBackEnabledProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.NavigationView", L"IsBackEnabledProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::NavigationView::IsBackEnabledProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NavigationView_get_IsPaneVisibleProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.NavigationView", L"IsPaneVisibleProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::NavigationView::IsPaneVisibleProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NavigationView_get_OverflowLabelModeProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.NavigationView", L"OverflowLabelModeProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::NavigationView::OverflowLabelModeProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NavigationView_get_PaneCustomContentProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.NavigationView", L"PaneCustomContentProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::NavigationView::PaneCustomContentProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NavigationView_get_PaneDisplayModeProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.NavigationView", L"PaneDisplayModeProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::NavigationView::PaneDisplayModeProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NavigationView_get_PaneHeaderProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.NavigationView", L"PaneHeaderProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::NavigationView::PaneHeaderProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NavigationView_get_PaneTitleProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.NavigationView", L"PaneTitleProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::NavigationView::PaneTitleProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NavigationView_get_SelectionFollowsFocusProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.NavigationView", L"SelectionFollowsFocusProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::NavigationView::SelectionFollowsFocusProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NavigationView_get_ShoulderNavigationEnabledProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.NavigationView", L"ShoulderNavigationEnabledProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::NavigationView::ShoulderNavigationEnabledProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NavigationView_get_TemplateSettingsProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.NavigationView", L"TemplateSettingsProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::NavigationView::TemplateSettingsProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NavigationView_get_ContentOverlayProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.NavigationView", L"ContentOverlayProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::NavigationView::ContentOverlayProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NavigationView_add_DisplayModeChanged(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.NavigationView", L"DisplayModeChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Xaml::Controls::NavigationView, winrt::Microsoft::UI::Xaml::Controls::NavigationViewDisplayModeChangedEventArgs>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::NavigationView>().DisplayModeChanged(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NavigationView_remove_DisplayModeChanged(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.NavigationView", L"DisplayModeChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::NavigationView>().DisplayModeChanged(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NavigationView_add_ItemInvoked(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.NavigationView", L"ItemInvoked");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Xaml::Controls::NavigationView, winrt::Microsoft::UI::Xaml::Controls::NavigationViewItemInvokedEventArgs>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::NavigationView>().ItemInvoked(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NavigationView_remove_ItemInvoked(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.NavigationView", L"ItemInvoked");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::NavigationView>().ItemInvoked(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NavigationView_add_SelectionChanged(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.NavigationView", L"SelectionChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Xaml::Controls::NavigationView, winrt::Microsoft::UI::Xaml::Controls::NavigationViewSelectionChangedEventArgs>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::NavigationView>().SelectionChanged(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NavigationView_remove_SelectionChanged(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.NavigationView", L"SelectionChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::NavigationView>().SelectionChanged(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NavigationView_add_BackRequested(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.NavigationView", L"BackRequested");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Xaml::Controls::NavigationView, winrt::Microsoft::UI::Xaml::Controls::NavigationViewBackRequestedEventArgs>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::NavigationView>().BackRequested(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NavigationView_remove_BackRequested(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.NavigationView", L"BackRequested");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::NavigationView>().BackRequested(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NavigationView_add_Collapsed(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.NavigationView", L"Collapsed");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Xaml::Controls::NavigationView, winrt::Microsoft::UI::Xaml::Controls::NavigationViewItemCollapsedEventArgs>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::NavigationView>().Collapsed(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NavigationView_remove_Collapsed(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.NavigationView", L"Collapsed");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::NavigationView>().Collapsed(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NavigationView_add_Expanding(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.NavigationView", L"Expanding");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Xaml::Controls::NavigationView, winrt::Microsoft::UI::Xaml::Controls::NavigationViewItemExpandingEventArgs>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::NavigationView>().Expanding(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NavigationView_remove_Expanding(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.NavigationView", L"Expanding");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::NavigationView>().Expanding(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NavigationView_add_PaneClosed(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.NavigationView", L"PaneClosed");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Xaml::Controls::NavigationView, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::NavigationView>().PaneClosed(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NavigationView_remove_PaneClosed(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.NavigationView", L"PaneClosed");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::NavigationView>().PaneClosed(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NavigationView_add_PaneClosing(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.NavigationView", L"PaneClosing");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Xaml::Controls::NavigationView, winrt::Microsoft::UI::Xaml::Controls::NavigationViewPaneClosingEventArgs>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::NavigationView>().PaneClosing(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NavigationView_remove_PaneClosing(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.NavigationView", L"PaneClosing");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::NavigationView>().PaneClosing(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NavigationView_add_PaneOpened(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.NavigationView", L"PaneOpened");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Xaml::Controls::NavigationView, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::NavigationView>().PaneOpened(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NavigationView_remove_PaneOpened(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.NavigationView", L"PaneOpened");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::NavigationView>().PaneOpened(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NavigationView_add_PaneOpening(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.NavigationView", L"PaneOpening");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Xaml::Controls::NavigationView, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::NavigationView>().PaneOpening(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NavigationView_remove_PaneOpening(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.NavigationView", L"PaneOpening");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::NavigationView>().PaneOpening(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_NavigationView(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::NavigationView>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_NavigationView(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::NavigationView>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_NavigationView[] = {
        { "collapse", reinterpret_cast<PyCFunction>(NavigationView_Collapse), METH_VARARGS, nullptr },
        { "container_from_menu_item", reinterpret_cast<PyCFunction>(NavigationView_ContainerFromMenuItem), METH_VARARGS, nullptr },
        { "expand", reinterpret_cast<PyCFunction>(NavigationView_Expand), METH_VARARGS, nullptr },
        { "menu_item_from_container", reinterpret_cast<PyCFunction>(NavigationView_MenuItemFromContainer), METH_VARARGS, nullptr },
        { "add_display_mode_changed", reinterpret_cast<PyCFunction>(NavigationView_add_DisplayModeChanged), METH_O, nullptr },
        { "remove_display_mode_changed", reinterpret_cast<PyCFunction>(NavigationView_remove_DisplayModeChanged), METH_O, nullptr },
        { "add_item_invoked", reinterpret_cast<PyCFunction>(NavigationView_add_ItemInvoked), METH_O, nullptr },
        { "remove_item_invoked", reinterpret_cast<PyCFunction>(NavigationView_remove_ItemInvoked), METH_O, nullptr },
        { "add_selection_changed", reinterpret_cast<PyCFunction>(NavigationView_add_SelectionChanged), METH_O, nullptr },
        { "remove_selection_changed", reinterpret_cast<PyCFunction>(NavigationView_remove_SelectionChanged), METH_O, nullptr },
        { "add_back_requested", reinterpret_cast<PyCFunction>(NavigationView_add_BackRequested), METH_O, nullptr },
        { "remove_back_requested", reinterpret_cast<PyCFunction>(NavigationView_remove_BackRequested), METH_O, nullptr },
        { "add_collapsed", reinterpret_cast<PyCFunction>(NavigationView_add_Collapsed), METH_O, nullptr },
        { "remove_collapsed", reinterpret_cast<PyCFunction>(NavigationView_remove_Collapsed), METH_O, nullptr },
        { "add_expanding", reinterpret_cast<PyCFunction>(NavigationView_add_Expanding), METH_O, nullptr },
        { "remove_expanding", reinterpret_cast<PyCFunction>(NavigationView_remove_Expanding), METH_O, nullptr },
        { "add_pane_closed", reinterpret_cast<PyCFunction>(NavigationView_add_PaneClosed), METH_O, nullptr },
        { "remove_pane_closed", reinterpret_cast<PyCFunction>(NavigationView_remove_PaneClosed), METH_O, nullptr },
        { "add_pane_closing", reinterpret_cast<PyCFunction>(NavigationView_add_PaneClosing), METH_O, nullptr },
        { "remove_pane_closing", reinterpret_cast<PyCFunction>(NavigationView_remove_PaneClosing), METH_O, nullptr },
        { "add_pane_opened", reinterpret_cast<PyCFunction>(NavigationView_add_PaneOpened), METH_O, nullptr },
        { "remove_pane_opened", reinterpret_cast<PyCFunction>(NavigationView_remove_PaneOpened), METH_O, nullptr },
        { "add_pane_opening", reinterpret_cast<PyCFunction>(NavigationView_add_PaneOpening), METH_O, nullptr },
        { "remove_pane_opening", reinterpret_cast<PyCFunction>(NavigationView_remove_PaneOpening), METH_O, nullptr },
        { "_assign_array_", _assign_array_NavigationView, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_NavigationView), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_NavigationView[] = {
        { "selected_item", reinterpret_cast<getter>(NavigationView_get_SelectedItem), reinterpret_cast<setter>(NavigationView_put_SelectedItem), nullptr, nullptr },
        { "pane_toggle_button_style", reinterpret_cast<getter>(NavigationView_get_PaneToggleButtonStyle), reinterpret_cast<setter>(NavigationView_put_PaneToggleButtonStyle), nullptr, nullptr },
        { "pane_footer", reinterpret_cast<getter>(NavigationView_get_PaneFooter), reinterpret_cast<setter>(NavigationView_put_PaneFooter), nullptr, nullptr },
        { "open_pane_length", reinterpret_cast<getter>(NavigationView_get_OpenPaneLength), reinterpret_cast<setter>(NavigationView_put_OpenPaneLength), nullptr, nullptr },
        { "menu_items_source", reinterpret_cast<getter>(NavigationView_get_MenuItemsSource), reinterpret_cast<setter>(NavigationView_put_MenuItemsSource), nullptr, nullptr },
        { "menu_item_container_style_selector", reinterpret_cast<getter>(NavigationView_get_MenuItemContainerStyleSelector), reinterpret_cast<setter>(NavigationView_put_MenuItemContainerStyleSelector), nullptr, nullptr },
        { "menu_item_container_style", reinterpret_cast<getter>(NavigationView_get_MenuItemContainerStyle), reinterpret_cast<setter>(NavigationView_put_MenuItemContainerStyle), nullptr, nullptr },
        { "is_title_bar_auto_padding_enabled", reinterpret_cast<getter>(NavigationView_get_IsTitleBarAutoPaddingEnabled), reinterpret_cast<setter>(NavigationView_put_IsTitleBarAutoPaddingEnabled), nullptr, nullptr },
        { "is_settings_visible", reinterpret_cast<getter>(NavigationView_get_IsSettingsVisible), reinterpret_cast<setter>(NavigationView_put_IsSettingsVisible), nullptr, nullptr },
        { "is_pane_toggle_button_visible", reinterpret_cast<getter>(NavigationView_get_IsPaneToggleButtonVisible), reinterpret_cast<setter>(NavigationView_put_IsPaneToggleButtonVisible), nullptr, nullptr },
        { "is_pane_open", reinterpret_cast<getter>(NavigationView_get_IsPaneOpen), reinterpret_cast<setter>(NavigationView_put_IsPaneOpen), nullptr, nullptr },
        { "header_template", reinterpret_cast<getter>(NavigationView_get_HeaderTemplate), reinterpret_cast<setter>(NavigationView_put_HeaderTemplate), nullptr, nullptr },
        { "header", reinterpret_cast<getter>(NavigationView_get_Header), reinterpret_cast<setter>(NavigationView_put_Header), nullptr, nullptr },
        { "footer_menu_items_source", reinterpret_cast<getter>(NavigationView_get_FooterMenuItemsSource), reinterpret_cast<setter>(NavigationView_put_FooterMenuItemsSource), nullptr, nullptr },
        { "menu_item_template_selector", reinterpret_cast<getter>(NavigationView_get_MenuItemTemplateSelector), reinterpret_cast<setter>(NavigationView_put_MenuItemTemplateSelector), nullptr, nullptr },
        { "expanded_mode_threshold_width", reinterpret_cast<getter>(NavigationView_get_ExpandedModeThresholdWidth), reinterpret_cast<setter>(NavigationView_put_ExpandedModeThresholdWidth), nullptr, nullptr },
        { "menu_item_template", reinterpret_cast<getter>(NavigationView_get_MenuItemTemplate), reinterpret_cast<setter>(NavigationView_put_MenuItemTemplate), nullptr, nullptr },
        { "compact_pane_length", reinterpret_cast<getter>(NavigationView_get_CompactPaneLength), reinterpret_cast<setter>(NavigationView_put_CompactPaneLength), nullptr, nullptr },
        { "compact_mode_threshold_width", reinterpret_cast<getter>(NavigationView_get_CompactModeThresholdWidth), reinterpret_cast<setter>(NavigationView_put_CompactModeThresholdWidth), nullptr, nullptr },
        { "auto_suggest_box", reinterpret_cast<getter>(NavigationView_get_AutoSuggestBox), reinterpret_cast<setter>(NavigationView_put_AutoSuggestBox), nullptr, nullptr },
        { "always_show_header", reinterpret_cast<getter>(NavigationView_get_AlwaysShowHeader), reinterpret_cast<setter>(NavigationView_put_AlwaysShowHeader), nullptr, nullptr },
        { "menu_items", reinterpret_cast<getter>(NavigationView_get_MenuItems), nullptr, nullptr, nullptr },
        { "display_mode", reinterpret_cast<getter>(NavigationView_get_DisplayMode), nullptr, nullptr, nullptr },
        { "footer_menu_items", reinterpret_cast<getter>(NavigationView_get_FooterMenuItems), nullptr, nullptr, nullptr },
        { "settings_item", reinterpret_cast<getter>(NavigationView_get_SettingsItem), nullptr, nullptr, nullptr },
        { "shoulder_navigation_enabled", reinterpret_cast<getter>(NavigationView_get_ShoulderNavigationEnabled), reinterpret_cast<setter>(NavigationView_put_ShoulderNavigationEnabled), nullptr, nullptr },
        { "selection_follows_focus", reinterpret_cast<getter>(NavigationView_get_SelectionFollowsFocus), reinterpret_cast<setter>(NavigationView_put_SelectionFollowsFocus), nullptr, nullptr },
        { "pane_title", reinterpret_cast<getter>(NavigationView_get_PaneTitle), reinterpret_cast<setter>(NavigationView_put_PaneTitle), nullptr, nullptr },
        { "pane_header", reinterpret_cast<getter>(NavigationView_get_PaneHeader), reinterpret_cast<setter>(NavigationView_put_PaneHeader), nullptr, nullptr },
        { "pane_display_mode", reinterpret_cast<getter>(NavigationView_get_PaneDisplayMode), reinterpret_cast<setter>(NavigationView_put_PaneDisplayMode), nullptr, nullptr },
        { "pane_custom_content", reinterpret_cast<getter>(NavigationView_get_PaneCustomContent), reinterpret_cast<setter>(NavigationView_put_PaneCustomContent), nullptr, nullptr },
        { "overflow_label_mode", reinterpret_cast<getter>(NavigationView_get_OverflowLabelMode), reinterpret_cast<setter>(NavigationView_put_OverflowLabelMode), nullptr, nullptr },
        { "is_pane_visible", reinterpret_cast<getter>(NavigationView_get_IsPaneVisible), reinterpret_cast<setter>(NavigationView_put_IsPaneVisible), nullptr, nullptr },
        { "is_back_enabled", reinterpret_cast<getter>(NavigationView_get_IsBackEnabled), reinterpret_cast<setter>(NavigationView_put_IsBackEnabled), nullptr, nullptr },
        { "is_back_button_visible", reinterpret_cast<getter>(NavigationView_get_IsBackButtonVisible), reinterpret_cast<setter>(NavigationView_put_IsBackButtonVisible), nullptr, nullptr },
        { "content_overlay", reinterpret_cast<getter>(NavigationView_get_ContentOverlay), reinterpret_cast<setter>(NavigationView_put_ContentOverlay), nullptr, nullptr },
        { "template_settings", reinterpret_cast<getter>(NavigationView_get_TemplateSettings), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_NavigationView[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_NavigationView) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_NavigationView) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_NavigationView) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_NavigationView) },
        { }};

    static PyType_Spec type_spec_NavigationView = {
        "winui2._winui2_microsoft_ui_xaml_controls.NavigationView",
        sizeof(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_NavigationView};

    static PyGetSetDef getset_NavigationView_Static[] = {
        { "footer_menu_items_property", reinterpret_cast<getter>(NavigationView_get_FooterMenuItemsProperty), nullptr, nullptr, nullptr },
        { "is_title_bar_auto_padding_enabled_property", reinterpret_cast<getter>(NavigationView_get_IsTitleBarAutoPaddingEnabledProperty), nullptr, nullptr, nullptr },
        { "menu_item_container_style_property", reinterpret_cast<getter>(NavigationView_get_MenuItemContainerStyleProperty), nullptr, nullptr, nullptr },
        { "menu_item_container_style_selector_property", reinterpret_cast<getter>(NavigationView_get_MenuItemContainerStyleSelectorProperty), nullptr, nullptr, nullptr },
        { "menu_item_template_property", reinterpret_cast<getter>(NavigationView_get_MenuItemTemplateProperty), nullptr, nullptr, nullptr },
        { "menu_item_template_selector_property", reinterpret_cast<getter>(NavigationView_get_MenuItemTemplateSelectorProperty), nullptr, nullptr, nullptr },
        { "menu_items_property", reinterpret_cast<getter>(NavigationView_get_MenuItemsProperty), nullptr, nullptr, nullptr },
        { "menu_items_source_property", reinterpret_cast<getter>(NavigationView_get_MenuItemsSourceProperty), nullptr, nullptr, nullptr },
        { "open_pane_length_property", reinterpret_cast<getter>(NavigationView_get_OpenPaneLengthProperty), nullptr, nullptr, nullptr },
        { "pane_footer_property", reinterpret_cast<getter>(NavigationView_get_PaneFooterProperty), nullptr, nullptr, nullptr },
        { "pane_toggle_button_style_property", reinterpret_cast<getter>(NavigationView_get_PaneToggleButtonStyleProperty), nullptr, nullptr, nullptr },
        { "selected_item_property", reinterpret_cast<getter>(NavigationView_get_SelectedItemProperty), nullptr, nullptr, nullptr },
        { "always_show_header_property", reinterpret_cast<getter>(NavigationView_get_AlwaysShowHeaderProperty), nullptr, nullptr, nullptr },
        { "auto_suggest_box_property", reinterpret_cast<getter>(NavigationView_get_AutoSuggestBoxProperty), nullptr, nullptr, nullptr },
        { "compact_mode_threshold_width_property", reinterpret_cast<getter>(NavigationView_get_CompactModeThresholdWidthProperty), nullptr, nullptr, nullptr },
        { "compact_pane_length_property", reinterpret_cast<getter>(NavigationView_get_CompactPaneLengthProperty), nullptr, nullptr, nullptr },
        { "display_mode_property", reinterpret_cast<getter>(NavigationView_get_DisplayModeProperty), nullptr, nullptr, nullptr },
        { "expanded_mode_threshold_width_property", reinterpret_cast<getter>(NavigationView_get_ExpandedModeThresholdWidthProperty), nullptr, nullptr, nullptr },
        { "settings_item_property", reinterpret_cast<getter>(NavigationView_get_SettingsItemProperty), nullptr, nullptr, nullptr },
        { "footer_menu_items_source_property", reinterpret_cast<getter>(NavigationView_get_FooterMenuItemsSourceProperty), nullptr, nullptr, nullptr },
        { "header_property", reinterpret_cast<getter>(NavigationView_get_HeaderProperty), nullptr, nullptr, nullptr },
        { "header_template_property", reinterpret_cast<getter>(NavigationView_get_HeaderTemplateProperty), nullptr, nullptr, nullptr },
        { "is_pane_open_property", reinterpret_cast<getter>(NavigationView_get_IsPaneOpenProperty), nullptr, nullptr, nullptr },
        { "is_pane_toggle_button_visible_property", reinterpret_cast<getter>(NavigationView_get_IsPaneToggleButtonVisibleProperty), nullptr, nullptr, nullptr },
        { "is_settings_visible_property", reinterpret_cast<getter>(NavigationView_get_IsSettingsVisibleProperty), nullptr, nullptr, nullptr },
        { "is_back_button_visible_property", reinterpret_cast<getter>(NavigationView_get_IsBackButtonVisibleProperty), nullptr, nullptr, nullptr },
        { "is_back_enabled_property", reinterpret_cast<getter>(NavigationView_get_IsBackEnabledProperty), nullptr, nullptr, nullptr },
        { "is_pane_visible_property", reinterpret_cast<getter>(NavigationView_get_IsPaneVisibleProperty), nullptr, nullptr, nullptr },
        { "overflow_label_mode_property", reinterpret_cast<getter>(NavigationView_get_OverflowLabelModeProperty), nullptr, nullptr, nullptr },
        { "pane_custom_content_property", reinterpret_cast<getter>(NavigationView_get_PaneCustomContentProperty), nullptr, nullptr, nullptr },
        { "pane_display_mode_property", reinterpret_cast<getter>(NavigationView_get_PaneDisplayModeProperty), nullptr, nullptr, nullptr },
        { "pane_header_property", reinterpret_cast<getter>(NavigationView_get_PaneHeaderProperty), nullptr, nullptr, nullptr },
        { "pane_title_property", reinterpret_cast<getter>(NavigationView_get_PaneTitleProperty), nullptr, nullptr, nullptr },
        { "selection_follows_focus_property", reinterpret_cast<getter>(NavigationView_get_SelectionFollowsFocusProperty), nullptr, nullptr, nullptr },
        { "shoulder_navigation_enabled_property", reinterpret_cast<getter>(NavigationView_get_ShoulderNavigationEnabledProperty), nullptr, nullptr, nullptr },
        { "template_settings_property", reinterpret_cast<getter>(NavigationView_get_TemplateSettingsProperty), nullptr, nullptr, nullptr },
        { "content_overlay_property", reinterpret_cast<getter>(NavigationView_get_ContentOverlayProperty), nullptr, nullptr, nullptr },
        { }};

    static PyMethodDef methods_NavigationView_Static[] = {
        { }};

    static PyType_Slot type_slots_NavigationView_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_NavigationView_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_NavigationView_Static) },
        { }
    };

    static PyType_Spec type_spec_NavigationView_Static = {
        "winui2._winui2_microsoft_ui_xaml_controls.NavigationView_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_NavigationView_Static};

    // ----- NavigationViewBackRequestedEventArgs class --------------------

    static PyObject* _new_NavigationViewBackRequestedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Xaml::Controls::NavigationViewBackRequestedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Xaml::Controls::NavigationViewBackRequestedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_NavigationViewBackRequestedEventArgs(py::wrapper::Microsoft::UI::Xaml::Controls::NavigationViewBackRequestedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_NavigationViewBackRequestedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::NavigationViewBackRequestedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_NavigationViewBackRequestedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::NavigationViewBackRequestedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_NavigationViewBackRequestedEventArgs[] = {
        { "_assign_array_", _assign_array_NavigationViewBackRequestedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_NavigationViewBackRequestedEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_NavigationViewBackRequestedEventArgs[] = {
        { }};

    static PyType_Slot _type_slots_NavigationViewBackRequestedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_NavigationViewBackRequestedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_NavigationViewBackRequestedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_NavigationViewBackRequestedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_NavigationViewBackRequestedEventArgs) },
        { }};

    static PyType_Spec type_spec_NavigationViewBackRequestedEventArgs = {
        "winui2._winui2_microsoft_ui_xaml_controls.NavigationViewBackRequestedEventArgs",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Controls::NavigationViewBackRequestedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_NavigationViewBackRequestedEventArgs};

    // ----- NavigationViewDisplayModeChangedEventArgs class --------------------

    static PyObject* _new_NavigationViewDisplayModeChangedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Xaml::Controls::NavigationViewDisplayModeChangedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Xaml::Controls::NavigationViewDisplayModeChangedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_NavigationViewDisplayModeChangedEventArgs(py::wrapper::Microsoft::UI::Xaml::Controls::NavigationViewDisplayModeChangedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* NavigationViewDisplayModeChangedEventArgs_get_DisplayMode(py::wrapper::Microsoft::UI::Xaml::Controls::NavigationViewDisplayModeChangedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.NavigationViewDisplayModeChangedEventArgs", L"DisplayMode");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.DisplayMode();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_NavigationViewDisplayModeChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::NavigationViewDisplayModeChangedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_NavigationViewDisplayModeChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::NavigationViewDisplayModeChangedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_NavigationViewDisplayModeChangedEventArgs[] = {
        { "_assign_array_", _assign_array_NavigationViewDisplayModeChangedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_NavigationViewDisplayModeChangedEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_NavigationViewDisplayModeChangedEventArgs[] = {
        { "display_mode", reinterpret_cast<getter>(NavigationViewDisplayModeChangedEventArgs_get_DisplayMode), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_NavigationViewDisplayModeChangedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_NavigationViewDisplayModeChangedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_NavigationViewDisplayModeChangedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_NavigationViewDisplayModeChangedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_NavigationViewDisplayModeChangedEventArgs) },
        { }};

    static PyType_Spec type_spec_NavigationViewDisplayModeChangedEventArgs = {
        "winui2._winui2_microsoft_ui_xaml_controls.NavigationViewDisplayModeChangedEventArgs",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Controls::NavigationViewDisplayModeChangedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_NavigationViewDisplayModeChangedEventArgs};

    // ----- NavigationViewItem class --------------------

    struct PyWinrtNavigationViewItem;
    using BasePyWinrtNavigationViewItem = winrt::Microsoft::UI::Xaml::Controls::NavigationViewItemT<PyWinrtNavigationViewItem, py::IPywinrtObject>;

    struct PyWinrtNavigationViewItem : py::py_obj_ref, BasePyWinrtNavigationViewItem
    {
        PyWinrtNavigationViewItem(PyObject* py_obj) : py::py_obj_ref(py_obj), BasePyWinrtNavigationViewItem() {}

        int32_t __stdcall GetPyObject(PyObject*& obj) override
        {
            obj = py::py_obj_ref::get_py_obj();
            return 0;
        }

        int32_t __stdcall GetComposableInner(winrt::Windows::Foundation::IInspectable& inner) override
        {
            inner = m_inner;
            return winrt::impl::error_ok;
        }

        static void toggle_reference(PyWinrtNavigationViewItem* instance, bool is_last_reference)
        {
            py::py_obj_ref::toggle_reference(instance, is_last_reference);
        }

        int32_t query_interface_tearoff(winrt::guid const& id, void** result) const noexcept override
        {
            return py::py_obj_ref::query_interface_tearoff(id, result);
        }

        std::vector<winrt::guid> get_iids_tearoff() const noexcept override
        {
            return py::py_obj_ref::get_iids_tearoff();
        }
    };

    static PyObject* _new_NavigationViewItem(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_GET_SIZE(args);

        auto self_type = get_python_type_for<winrt::Microsoft::UI::Xaml::Controls::NavigationViewItem>();
        if (!self_type)
        {
            return nullptr;
        }

        if (arg_count == 0)
        {
            try
            {
                if (type != self_type)
                {
                    py::pyobj_handle self{type->tp_alloc(type, 0)};
                    if (!self)
                    {
                        return nullptr;
                    }

                    std::construct_at(&reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj, nullptr);

                    auto obj_impl = winrt::make_self<PyWinrtNavigationViewItem>(self.get());

                    auto obj = py::make_py_obj<PyWinrtNavigationViewItem>(obj_impl, type, self.get());
                    if (!obj)
                    {
                        return nullptr;
                    }

                    reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj = std::move(obj);

                    return self.detach();
                }

                winrt::Microsoft::UI::Xaml::Controls::NavigationViewItem instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_NavigationViewItem(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* NavigationViewItem_get_Icon(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.NavigationViewItem", L"Icon");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::NavigationViewItem>().Icon();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int NavigationViewItem_put_Icon(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.NavigationViewItem", L"Icon");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::IconElement>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::NavigationViewItem>().Icon(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* NavigationViewItem_get_CompactPaneLength(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.NavigationViewItem", L"CompactPaneLength");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::NavigationViewItem>().CompactPaneLength();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NavigationViewItem_get_SelectsOnInvoked(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.NavigationViewItem", L"SelectsOnInvoked");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::NavigationViewItem>().SelectsOnInvoked();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int NavigationViewItem_put_SelectsOnInvoked(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.NavigationViewItem", L"SelectsOnInvoked");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::NavigationViewItem>().SelectsOnInvoked(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* NavigationViewItem_get_MenuItemsSource(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.NavigationViewItem", L"MenuItemsSource");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::NavigationViewItem>().MenuItemsSource();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int NavigationViewItem_put_MenuItemsSource(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.NavigationViewItem", L"MenuItemsSource");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::NavigationViewItem>().MenuItemsSource(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* NavigationViewItem_get_IsExpanded(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.NavigationViewItem", L"IsExpanded");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::NavigationViewItem>().IsExpanded();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int NavigationViewItem_put_IsExpanded(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.NavigationViewItem", L"IsExpanded");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::NavigationViewItem>().IsExpanded(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* NavigationViewItem_get_IsChildSelected(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.NavigationViewItem", L"IsChildSelected");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::NavigationViewItem>().IsChildSelected();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int NavigationViewItem_put_IsChildSelected(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.NavigationViewItem", L"IsChildSelected");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::NavigationViewItem>().IsChildSelected(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* NavigationViewItem_get_HasUnrealizedChildren(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.NavigationViewItem", L"HasUnrealizedChildren");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::NavigationViewItem>().HasUnrealizedChildren();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int NavigationViewItem_put_HasUnrealizedChildren(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.NavigationViewItem", L"HasUnrealizedChildren");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::NavigationViewItem>().HasUnrealizedChildren(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* NavigationViewItem_get_MenuItems(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.NavigationViewItem", L"MenuItems");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::NavigationViewItem>().MenuItems();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NavigationViewItem_get_InfoBadge(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.NavigationViewItem", L"InfoBadge");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::NavigationViewItem>().InfoBadge();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int NavigationViewItem_put_InfoBadge(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.NavigationViewItem", L"InfoBadge");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::InfoBadge>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::NavigationViewItem>().InfoBadge(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* NavigationViewItem_get_CompactPaneLengthProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.NavigationViewItem", L"CompactPaneLengthProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::NavigationViewItem::CompactPaneLengthProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NavigationViewItem_get_IconProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.NavigationViewItem", L"IconProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::NavigationViewItem::IconProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NavigationViewItem_get_HasUnrealizedChildrenProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.NavigationViewItem", L"HasUnrealizedChildrenProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::NavigationViewItem::HasUnrealizedChildrenProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NavigationViewItem_get_IsChildSelectedProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.NavigationViewItem", L"IsChildSelectedProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::NavigationViewItem::IsChildSelectedProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NavigationViewItem_get_IsExpandedProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.NavigationViewItem", L"IsExpandedProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::NavigationViewItem::IsExpandedProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NavigationViewItem_get_MenuItemsProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.NavigationViewItem", L"MenuItemsProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::NavigationViewItem::MenuItemsProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NavigationViewItem_get_MenuItemsSourceProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.NavigationViewItem", L"MenuItemsSourceProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::NavigationViewItem::MenuItemsSourceProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NavigationViewItem_get_SelectsOnInvokedProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.NavigationViewItem", L"SelectsOnInvokedProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::NavigationViewItem::SelectsOnInvokedProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NavigationViewItem_get_InfoBadgeProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.NavigationViewItem", L"InfoBadgeProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::NavigationViewItem::InfoBadgeProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_NavigationViewItem(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::NavigationViewItem>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_NavigationViewItem(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::NavigationViewItem>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_NavigationViewItem[] = {
        { "_assign_array_", _assign_array_NavigationViewItem, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_NavigationViewItem), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_NavigationViewItem[] = {
        { "icon", reinterpret_cast<getter>(NavigationViewItem_get_Icon), reinterpret_cast<setter>(NavigationViewItem_put_Icon), nullptr, nullptr },
        { "compact_pane_length", reinterpret_cast<getter>(NavigationViewItem_get_CompactPaneLength), nullptr, nullptr, nullptr },
        { "selects_on_invoked", reinterpret_cast<getter>(NavigationViewItem_get_SelectsOnInvoked), reinterpret_cast<setter>(NavigationViewItem_put_SelectsOnInvoked), nullptr, nullptr },
        { "menu_items_source", reinterpret_cast<getter>(NavigationViewItem_get_MenuItemsSource), reinterpret_cast<setter>(NavigationViewItem_put_MenuItemsSource), nullptr, nullptr },
        { "is_expanded", reinterpret_cast<getter>(NavigationViewItem_get_IsExpanded), reinterpret_cast<setter>(NavigationViewItem_put_IsExpanded), nullptr, nullptr },
        { "is_child_selected", reinterpret_cast<getter>(NavigationViewItem_get_IsChildSelected), reinterpret_cast<setter>(NavigationViewItem_put_IsChildSelected), nullptr, nullptr },
        { "has_unrealized_children", reinterpret_cast<getter>(NavigationViewItem_get_HasUnrealizedChildren), reinterpret_cast<setter>(NavigationViewItem_put_HasUnrealizedChildren), nullptr, nullptr },
        { "menu_items", reinterpret_cast<getter>(NavigationViewItem_get_MenuItems), nullptr, nullptr, nullptr },
        { "info_badge", reinterpret_cast<getter>(NavigationViewItem_get_InfoBadge), reinterpret_cast<setter>(NavigationViewItem_put_InfoBadge), nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_NavigationViewItem[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_NavigationViewItem) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_NavigationViewItem) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_NavigationViewItem) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_NavigationViewItem) },
        { }};

    static PyType_Spec type_spec_NavigationViewItem = {
        "winui2._winui2_microsoft_ui_xaml_controls.NavigationViewItem",
        sizeof(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_NavigationViewItem};

    static PyGetSetDef getset_NavigationViewItem_Static[] = {
        { "compact_pane_length_property", reinterpret_cast<getter>(NavigationViewItem_get_CompactPaneLengthProperty), nullptr, nullptr, nullptr },
        { "icon_property", reinterpret_cast<getter>(NavigationViewItem_get_IconProperty), nullptr, nullptr, nullptr },
        { "has_unrealized_children_property", reinterpret_cast<getter>(NavigationViewItem_get_HasUnrealizedChildrenProperty), nullptr, nullptr, nullptr },
        { "is_child_selected_property", reinterpret_cast<getter>(NavigationViewItem_get_IsChildSelectedProperty), nullptr, nullptr, nullptr },
        { "is_expanded_property", reinterpret_cast<getter>(NavigationViewItem_get_IsExpandedProperty), nullptr, nullptr, nullptr },
        { "menu_items_property", reinterpret_cast<getter>(NavigationViewItem_get_MenuItemsProperty), nullptr, nullptr, nullptr },
        { "menu_items_source_property", reinterpret_cast<getter>(NavigationViewItem_get_MenuItemsSourceProperty), nullptr, nullptr, nullptr },
        { "selects_on_invoked_property", reinterpret_cast<getter>(NavigationViewItem_get_SelectsOnInvokedProperty), nullptr, nullptr, nullptr },
        { "info_badge_property", reinterpret_cast<getter>(NavigationViewItem_get_InfoBadgeProperty), nullptr, nullptr, nullptr },
        { }};

    static PyMethodDef methods_NavigationViewItem_Static[] = {
        { }};

    static PyType_Slot type_slots_NavigationViewItem_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_NavigationViewItem_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_NavigationViewItem_Static) },
        { }
    };

    static PyType_Spec type_spec_NavigationViewItem_Static = {
        "winui2._winui2_microsoft_ui_xaml_controls.NavigationViewItem_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_NavigationViewItem_Static};

    // ----- NavigationViewItemBase class --------------------

    static PyObject* _new_NavigationViewItemBase(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Xaml::Controls::NavigationViewItemBase>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Xaml::Controls::NavigationViewItemBase>::type_name);
        return nullptr;
    }

    static void _dealloc_NavigationViewItemBase(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* NavigationViewItemBase_get_IsSelected(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.NavigationViewItemBase", L"IsSelected");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::NavigationViewItemBase>().IsSelected();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int NavigationViewItemBase_put_IsSelected(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.NavigationViewItemBase", L"IsSelected");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::NavigationViewItemBase>().IsSelected(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* NavigationViewItemBase_get_IsSelectedProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.NavigationViewItemBase", L"IsSelectedProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::NavigationViewItemBase::IsSelectedProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_NavigationViewItemBase(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::NavigationViewItemBase>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_NavigationViewItemBase(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::NavigationViewItemBase>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_NavigationViewItemBase[] = {
        { "_assign_array_", _assign_array_NavigationViewItemBase, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_NavigationViewItemBase), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_NavigationViewItemBase[] = {
        { "is_selected", reinterpret_cast<getter>(NavigationViewItemBase_get_IsSelected), reinterpret_cast<setter>(NavigationViewItemBase_put_IsSelected), nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_NavigationViewItemBase[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_NavigationViewItemBase) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_NavigationViewItemBase) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_NavigationViewItemBase) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_NavigationViewItemBase) },
        { }};

    static PyType_Spec type_spec_NavigationViewItemBase = {
        "winui2._winui2_microsoft_ui_xaml_controls.NavigationViewItemBase",
        sizeof(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_NavigationViewItemBase};

    static PyGetSetDef getset_NavigationViewItemBase_Static[] = {
        { "is_selected_property", reinterpret_cast<getter>(NavigationViewItemBase_get_IsSelectedProperty), nullptr, nullptr, nullptr },
        { }};

    static PyMethodDef methods_NavigationViewItemBase_Static[] = {
        { }};

    static PyType_Slot type_slots_NavigationViewItemBase_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_NavigationViewItemBase_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_NavigationViewItemBase_Static) },
        { }
    };

    static PyType_Spec type_spec_NavigationViewItemBase_Static = {
        "winui2._winui2_microsoft_ui_xaml_controls.NavigationViewItemBase_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_NavigationViewItemBase_Static};

    // ----- NavigationViewItemCollapsedEventArgs class --------------------

    static PyObject* _new_NavigationViewItemCollapsedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Xaml::Controls::NavigationViewItemCollapsedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Xaml::Controls::NavigationViewItemCollapsedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_NavigationViewItemCollapsedEventArgs(py::wrapper::Microsoft::UI::Xaml::Controls::NavigationViewItemCollapsedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* NavigationViewItemCollapsedEventArgs_get_CollapsedItem(py::wrapper::Microsoft::UI::Xaml::Controls::NavigationViewItemCollapsedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.NavigationViewItemCollapsedEventArgs", L"CollapsedItem");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.CollapsedItem();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NavigationViewItemCollapsedEventArgs_get_CollapsedItemContainer(py::wrapper::Microsoft::UI::Xaml::Controls::NavigationViewItemCollapsedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.NavigationViewItemCollapsedEventArgs", L"CollapsedItemContainer");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.CollapsedItemContainer();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_NavigationViewItemCollapsedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::NavigationViewItemCollapsedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_NavigationViewItemCollapsedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::NavigationViewItemCollapsedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_NavigationViewItemCollapsedEventArgs[] = {
        { "_assign_array_", _assign_array_NavigationViewItemCollapsedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_NavigationViewItemCollapsedEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_NavigationViewItemCollapsedEventArgs[] = {
        { "collapsed_item", reinterpret_cast<getter>(NavigationViewItemCollapsedEventArgs_get_CollapsedItem), nullptr, nullptr, nullptr },
        { "collapsed_item_container", reinterpret_cast<getter>(NavigationViewItemCollapsedEventArgs_get_CollapsedItemContainer), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_NavigationViewItemCollapsedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_NavigationViewItemCollapsedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_NavigationViewItemCollapsedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_NavigationViewItemCollapsedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_NavigationViewItemCollapsedEventArgs) },
        { }};

    static PyType_Spec type_spec_NavigationViewItemCollapsedEventArgs = {
        "winui2._winui2_microsoft_ui_xaml_controls.NavigationViewItemCollapsedEventArgs",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Controls::NavigationViewItemCollapsedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_NavigationViewItemCollapsedEventArgs};

    // ----- NavigationViewItemExpandingEventArgs class --------------------

    static PyObject* _new_NavigationViewItemExpandingEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Xaml::Controls::NavigationViewItemExpandingEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Xaml::Controls::NavigationViewItemExpandingEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_NavigationViewItemExpandingEventArgs(py::wrapper::Microsoft::UI::Xaml::Controls::NavigationViewItemExpandingEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* NavigationViewItemExpandingEventArgs_get_ExpandingItem(py::wrapper::Microsoft::UI::Xaml::Controls::NavigationViewItemExpandingEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.NavigationViewItemExpandingEventArgs", L"ExpandingItem");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ExpandingItem();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NavigationViewItemExpandingEventArgs_get_ExpandingItemContainer(py::wrapper::Microsoft::UI::Xaml::Controls::NavigationViewItemExpandingEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.NavigationViewItemExpandingEventArgs", L"ExpandingItemContainer");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ExpandingItemContainer();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_NavigationViewItemExpandingEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::NavigationViewItemExpandingEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_NavigationViewItemExpandingEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::NavigationViewItemExpandingEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_NavigationViewItemExpandingEventArgs[] = {
        { "_assign_array_", _assign_array_NavigationViewItemExpandingEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_NavigationViewItemExpandingEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_NavigationViewItemExpandingEventArgs[] = {
        { "expanding_item", reinterpret_cast<getter>(NavigationViewItemExpandingEventArgs_get_ExpandingItem), nullptr, nullptr, nullptr },
        { "expanding_item_container", reinterpret_cast<getter>(NavigationViewItemExpandingEventArgs_get_ExpandingItemContainer), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_NavigationViewItemExpandingEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_NavigationViewItemExpandingEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_NavigationViewItemExpandingEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_NavigationViewItemExpandingEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_NavigationViewItemExpandingEventArgs) },
        { }};

    static PyType_Spec type_spec_NavigationViewItemExpandingEventArgs = {
        "winui2._winui2_microsoft_ui_xaml_controls.NavigationViewItemExpandingEventArgs",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Controls::NavigationViewItemExpandingEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_NavigationViewItemExpandingEventArgs};

    // ----- NavigationViewItemHeader class --------------------

    struct PyWinrtNavigationViewItemHeader;
    using BasePyWinrtNavigationViewItemHeader = winrt::Microsoft::UI::Xaml::Controls::NavigationViewItemHeaderT<PyWinrtNavigationViewItemHeader, py::IPywinrtObject>;

    struct PyWinrtNavigationViewItemHeader : py::py_obj_ref, BasePyWinrtNavigationViewItemHeader
    {
        PyWinrtNavigationViewItemHeader(PyObject* py_obj) : py::py_obj_ref(py_obj), BasePyWinrtNavigationViewItemHeader() {}

        int32_t __stdcall GetPyObject(PyObject*& obj) override
        {
            obj = py::py_obj_ref::get_py_obj();
            return 0;
        }

        int32_t __stdcall GetComposableInner(winrt::Windows::Foundation::IInspectable& inner) override
        {
            inner = m_inner;
            return winrt::impl::error_ok;
        }

        static void toggle_reference(PyWinrtNavigationViewItemHeader* instance, bool is_last_reference)
        {
            py::py_obj_ref::toggle_reference(instance, is_last_reference);
        }

        int32_t query_interface_tearoff(winrt::guid const& id, void** result) const noexcept override
        {
            return py::py_obj_ref::query_interface_tearoff(id, result);
        }

        std::vector<winrt::guid> get_iids_tearoff() const noexcept override
        {
            return py::py_obj_ref::get_iids_tearoff();
        }
    };

    static PyObject* _new_NavigationViewItemHeader(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_GET_SIZE(args);

        auto self_type = get_python_type_for<winrt::Microsoft::UI::Xaml::Controls::NavigationViewItemHeader>();
        if (!self_type)
        {
            return nullptr;
        }

        if (arg_count == 0)
        {
            try
            {
                if (type != self_type)
                {
                    py::pyobj_handle self{type->tp_alloc(type, 0)};
                    if (!self)
                    {
                        return nullptr;
                    }

                    std::construct_at(&reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj, nullptr);

                    auto obj_impl = winrt::make_self<PyWinrtNavigationViewItemHeader>(self.get());

                    auto obj = py::make_py_obj<PyWinrtNavigationViewItemHeader>(obj_impl, type, self.get());
                    if (!obj)
                    {
                        return nullptr;
                    }

                    reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj = std::move(obj);

                    return self.detach();
                }

                winrt::Microsoft::UI::Xaml::Controls::NavigationViewItemHeader instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_NavigationViewItemHeader(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_NavigationViewItemHeader(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::NavigationViewItemHeader>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_NavigationViewItemHeader(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::NavigationViewItemHeader>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_NavigationViewItemHeader[] = {
        { "_assign_array_", _assign_array_NavigationViewItemHeader, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_NavigationViewItemHeader), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_NavigationViewItemHeader[] = {
        { }};

    static PyType_Slot _type_slots_NavigationViewItemHeader[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_NavigationViewItemHeader) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_NavigationViewItemHeader) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_NavigationViewItemHeader) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_NavigationViewItemHeader) },
        { }};

    static PyType_Spec type_spec_NavigationViewItemHeader = {
        "winui2._winui2_microsoft_ui_xaml_controls.NavigationViewItemHeader",
        sizeof(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_NavigationViewItemHeader};

    static PyGetSetDef getset_NavigationViewItemHeader_Static[] = {
        { }};

    static PyMethodDef methods_NavigationViewItemHeader_Static[] = {
        { }};

    static PyType_Slot type_slots_NavigationViewItemHeader_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_NavigationViewItemHeader_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_NavigationViewItemHeader_Static) },
        { }
    };

    static PyType_Spec type_spec_NavigationViewItemHeader_Static = {
        "winui2._winui2_microsoft_ui_xaml_controls.NavigationViewItemHeader_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_NavigationViewItemHeader_Static};

    // ----- NavigationViewItemInvokedEventArgs class --------------------

    static PyObject* _new_NavigationViewItemInvokedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_GET_SIZE(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Microsoft::UI::Xaml::Controls::NavigationViewItemInvokedEventArgs instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_NavigationViewItemInvokedEventArgs(py::wrapper::Microsoft::UI::Xaml::Controls::NavigationViewItemInvokedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* NavigationViewItemInvokedEventArgs_get_InvokedItem(py::wrapper::Microsoft::UI::Xaml::Controls::NavigationViewItemInvokedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.NavigationViewItemInvokedEventArgs", L"InvokedItem");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.InvokedItem();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NavigationViewItemInvokedEventArgs_get_IsSettingsInvoked(py::wrapper::Microsoft::UI::Xaml::Controls::NavigationViewItemInvokedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.NavigationViewItemInvokedEventArgs", L"IsSettingsInvoked");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.IsSettingsInvoked();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NavigationViewItemInvokedEventArgs_get_InvokedItemContainer(py::wrapper::Microsoft::UI::Xaml::Controls::NavigationViewItemInvokedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.NavigationViewItemInvokedEventArgs", L"InvokedItemContainer");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.InvokedItemContainer();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NavigationViewItemInvokedEventArgs_get_RecommendedNavigationTransitionInfo(py::wrapper::Microsoft::UI::Xaml::Controls::NavigationViewItemInvokedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.NavigationViewItemInvokedEventArgs", L"RecommendedNavigationTransitionInfo");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.RecommendedNavigationTransitionInfo();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_NavigationViewItemInvokedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::NavigationViewItemInvokedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_NavigationViewItemInvokedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::NavigationViewItemInvokedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_NavigationViewItemInvokedEventArgs[] = {
        { "_assign_array_", _assign_array_NavigationViewItemInvokedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_NavigationViewItemInvokedEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_NavigationViewItemInvokedEventArgs[] = {
        { "invoked_item", reinterpret_cast<getter>(NavigationViewItemInvokedEventArgs_get_InvokedItem), nullptr, nullptr, nullptr },
        { "is_settings_invoked", reinterpret_cast<getter>(NavigationViewItemInvokedEventArgs_get_IsSettingsInvoked), nullptr, nullptr, nullptr },
        { "invoked_item_container", reinterpret_cast<getter>(NavigationViewItemInvokedEventArgs_get_InvokedItemContainer), nullptr, nullptr, nullptr },
        { "recommended_navigation_transition_info", reinterpret_cast<getter>(NavigationViewItemInvokedEventArgs_get_RecommendedNavigationTransitionInfo), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_NavigationViewItemInvokedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_NavigationViewItemInvokedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_NavigationViewItemInvokedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_NavigationViewItemInvokedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_NavigationViewItemInvokedEventArgs) },
        { }};

    static PyType_Spec type_spec_NavigationViewItemInvokedEventArgs = {
        "winui2._winui2_microsoft_ui_xaml_controls.NavigationViewItemInvokedEventArgs",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Controls::NavigationViewItemInvokedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_NavigationViewItemInvokedEventArgs};

    // ----- NavigationViewItemSeparator class --------------------

    struct PyWinrtNavigationViewItemSeparator;
    using BasePyWinrtNavigationViewItemSeparator = winrt::Microsoft::UI::Xaml::Controls::NavigationViewItemSeparatorT<PyWinrtNavigationViewItemSeparator, py::IPywinrtObject>;

    struct PyWinrtNavigationViewItemSeparator : py::py_obj_ref, BasePyWinrtNavigationViewItemSeparator
    {
        PyWinrtNavigationViewItemSeparator(PyObject* py_obj) : py::py_obj_ref(py_obj), BasePyWinrtNavigationViewItemSeparator() {}

        int32_t __stdcall GetPyObject(PyObject*& obj) override
        {
            obj = py::py_obj_ref::get_py_obj();
            return 0;
        }

        int32_t __stdcall GetComposableInner(winrt::Windows::Foundation::IInspectable& inner) override
        {
            inner = m_inner;
            return winrt::impl::error_ok;
        }

        static void toggle_reference(PyWinrtNavigationViewItemSeparator* instance, bool is_last_reference)
        {
            py::py_obj_ref::toggle_reference(instance, is_last_reference);
        }

        int32_t query_interface_tearoff(winrt::guid const& id, void** result) const noexcept override
        {
            return py::py_obj_ref::query_interface_tearoff(id, result);
        }

        std::vector<winrt::guid> get_iids_tearoff() const noexcept override
        {
            return py::py_obj_ref::get_iids_tearoff();
        }
    };

    static PyObject* _new_NavigationViewItemSeparator(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_GET_SIZE(args);

        auto self_type = get_python_type_for<winrt::Microsoft::UI::Xaml::Controls::NavigationViewItemSeparator>();
        if (!self_type)
        {
            return nullptr;
        }

        if (arg_count == 0)
        {
            try
            {
                if (type != self_type)
                {
                    py::pyobj_handle self{type->tp_alloc(type, 0)};
                    if (!self)
                    {
                        return nullptr;
                    }

                    std::construct_at(&reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj, nullptr);

                    auto obj_impl = winrt::make_self<PyWinrtNavigationViewItemSeparator>(self.get());

                    auto obj = py::make_py_obj<PyWinrtNavigationViewItemSeparator>(obj_impl, type, self.get());
                    if (!obj)
                    {
                        return nullptr;
                    }

                    reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj = std::move(obj);

                    return self.detach();
                }

                winrt::Microsoft::UI::Xaml::Controls::NavigationViewItemSeparator instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_NavigationViewItemSeparator(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_NavigationViewItemSeparator(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::NavigationViewItemSeparator>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_NavigationViewItemSeparator(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::NavigationViewItemSeparator>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_NavigationViewItemSeparator[] = {
        { "_assign_array_", _assign_array_NavigationViewItemSeparator, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_NavigationViewItemSeparator), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_NavigationViewItemSeparator[] = {
        { }};

    static PyType_Slot _type_slots_NavigationViewItemSeparator[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_NavigationViewItemSeparator) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_NavigationViewItemSeparator) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_NavigationViewItemSeparator) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_NavigationViewItemSeparator) },
        { }};

    static PyType_Spec type_spec_NavigationViewItemSeparator = {
        "winui2._winui2_microsoft_ui_xaml_controls.NavigationViewItemSeparator",
        sizeof(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_NavigationViewItemSeparator};

    static PyGetSetDef getset_NavigationViewItemSeparator_Static[] = {
        { }};

    static PyMethodDef methods_NavigationViewItemSeparator_Static[] = {
        { }};

    static PyType_Slot type_slots_NavigationViewItemSeparator_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_NavigationViewItemSeparator_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_NavigationViewItemSeparator_Static) },
        { }
    };

    static PyType_Spec type_spec_NavigationViewItemSeparator_Static = {
        "winui2._winui2_microsoft_ui_xaml_controls.NavigationViewItemSeparator_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_NavigationViewItemSeparator_Static};

    // ----- NavigationViewPaneClosingEventArgs class --------------------

    static PyObject* _new_NavigationViewPaneClosingEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Xaml::Controls::NavigationViewPaneClosingEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Xaml::Controls::NavigationViewPaneClosingEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_NavigationViewPaneClosingEventArgs(py::wrapper::Microsoft::UI::Xaml::Controls::NavigationViewPaneClosingEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* NavigationViewPaneClosingEventArgs_get_Cancel(py::wrapper::Microsoft::UI::Xaml::Controls::NavigationViewPaneClosingEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.NavigationViewPaneClosingEventArgs", L"Cancel");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Cancel();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int NavigationViewPaneClosingEventArgs_put_Cancel(py::wrapper::Microsoft::UI::Xaml::Controls::NavigationViewPaneClosingEventArgs* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.NavigationViewPaneClosingEventArgs", L"Cancel");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.Cancel(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_NavigationViewPaneClosingEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::NavigationViewPaneClosingEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_NavigationViewPaneClosingEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::NavigationViewPaneClosingEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_NavigationViewPaneClosingEventArgs[] = {
        { "_assign_array_", _assign_array_NavigationViewPaneClosingEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_NavigationViewPaneClosingEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_NavigationViewPaneClosingEventArgs[] = {
        { "cancel", reinterpret_cast<getter>(NavigationViewPaneClosingEventArgs_get_Cancel), reinterpret_cast<setter>(NavigationViewPaneClosingEventArgs_put_Cancel), nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_NavigationViewPaneClosingEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_NavigationViewPaneClosingEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_NavigationViewPaneClosingEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_NavigationViewPaneClosingEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_NavigationViewPaneClosingEventArgs) },
        { }};

    static PyType_Spec type_spec_NavigationViewPaneClosingEventArgs = {
        "winui2._winui2_microsoft_ui_xaml_controls.NavigationViewPaneClosingEventArgs",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Controls::NavigationViewPaneClosingEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_NavigationViewPaneClosingEventArgs};

    // ----- NavigationViewSelectionChangedEventArgs class --------------------

    static PyObject* _new_NavigationViewSelectionChangedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Xaml::Controls::NavigationViewSelectionChangedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Xaml::Controls::NavigationViewSelectionChangedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_NavigationViewSelectionChangedEventArgs(py::wrapper::Microsoft::UI::Xaml::Controls::NavigationViewSelectionChangedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* NavigationViewSelectionChangedEventArgs_get_IsSettingsSelected(py::wrapper::Microsoft::UI::Xaml::Controls::NavigationViewSelectionChangedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.NavigationViewSelectionChangedEventArgs", L"IsSettingsSelected");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.IsSettingsSelected();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NavigationViewSelectionChangedEventArgs_get_SelectedItem(py::wrapper::Microsoft::UI::Xaml::Controls::NavigationViewSelectionChangedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.NavigationViewSelectionChangedEventArgs", L"SelectedItem");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SelectedItem();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NavigationViewSelectionChangedEventArgs_get_RecommendedNavigationTransitionInfo(py::wrapper::Microsoft::UI::Xaml::Controls::NavigationViewSelectionChangedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.NavigationViewSelectionChangedEventArgs", L"RecommendedNavigationTransitionInfo");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.RecommendedNavigationTransitionInfo();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NavigationViewSelectionChangedEventArgs_get_SelectedItemContainer(py::wrapper::Microsoft::UI::Xaml::Controls::NavigationViewSelectionChangedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.NavigationViewSelectionChangedEventArgs", L"SelectedItemContainer");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SelectedItemContainer();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_NavigationViewSelectionChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::NavigationViewSelectionChangedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_NavigationViewSelectionChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::NavigationViewSelectionChangedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_NavigationViewSelectionChangedEventArgs[] = {
        { "_assign_array_", _assign_array_NavigationViewSelectionChangedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_NavigationViewSelectionChangedEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_NavigationViewSelectionChangedEventArgs[] = {
        { "is_settings_selected", reinterpret_cast<getter>(NavigationViewSelectionChangedEventArgs_get_IsSettingsSelected), nullptr, nullptr, nullptr },
        { "selected_item", reinterpret_cast<getter>(NavigationViewSelectionChangedEventArgs_get_SelectedItem), nullptr, nullptr, nullptr },
        { "recommended_navigation_transition_info", reinterpret_cast<getter>(NavigationViewSelectionChangedEventArgs_get_RecommendedNavigationTransitionInfo), nullptr, nullptr, nullptr },
        { "selected_item_container", reinterpret_cast<getter>(NavigationViewSelectionChangedEventArgs_get_SelectedItemContainer), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_NavigationViewSelectionChangedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_NavigationViewSelectionChangedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_NavigationViewSelectionChangedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_NavigationViewSelectionChangedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_NavigationViewSelectionChangedEventArgs) },
        { }};

    static PyType_Spec type_spec_NavigationViewSelectionChangedEventArgs = {
        "winui2._winui2_microsoft_ui_xaml_controls.NavigationViewSelectionChangedEventArgs",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Controls::NavigationViewSelectionChangedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_NavigationViewSelectionChangedEventArgs};

    // ----- NavigationViewTemplateSettings class --------------------

    struct PyWinrtNavigationViewTemplateSettings;
    using BasePyWinrtNavigationViewTemplateSettings = winrt::Microsoft::UI::Xaml::Controls::NavigationViewTemplateSettingsT<PyWinrtNavigationViewTemplateSettings, py::IPywinrtObject>;

    struct PyWinrtNavigationViewTemplateSettings : py::py_obj_ref, BasePyWinrtNavigationViewTemplateSettings
    {
        PyWinrtNavigationViewTemplateSettings(PyObject* py_obj) : py::py_obj_ref(py_obj), BasePyWinrtNavigationViewTemplateSettings() {}

        int32_t __stdcall GetPyObject(PyObject*& obj) override
        {
            obj = py::py_obj_ref::get_py_obj();
            return 0;
        }

        int32_t __stdcall GetComposableInner(winrt::Windows::Foundation::IInspectable& inner) override
        {
            inner = m_inner;
            return winrt::impl::error_ok;
        }

        static void toggle_reference(PyWinrtNavigationViewTemplateSettings* instance, bool is_last_reference)
        {
            py::py_obj_ref::toggle_reference(instance, is_last_reference);
        }

        int32_t query_interface_tearoff(winrt::guid const& id, void** result) const noexcept override
        {
            return py::py_obj_ref::query_interface_tearoff(id, result);
        }

        std::vector<winrt::guid> get_iids_tearoff() const noexcept override
        {
            return py::py_obj_ref::get_iids_tearoff();
        }
    };

    static PyObject* _new_NavigationViewTemplateSettings(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_GET_SIZE(args);

        auto self_type = get_python_type_for<winrt::Microsoft::UI::Xaml::Controls::NavigationViewTemplateSettings>();
        if (!self_type)
        {
            return nullptr;
        }

        if (arg_count == 0)
        {
            try
            {
                if (type != self_type)
                {
                    py::pyobj_handle self{type->tp_alloc(type, 0)};
                    if (!self)
                    {
                        return nullptr;
                    }

                    std::construct_at(&reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj, nullptr);

                    auto obj_impl = winrt::make_self<PyWinrtNavigationViewTemplateSettings>(self.get());

                    auto obj = py::make_py_obj<PyWinrtNavigationViewTemplateSettings>(obj_impl, type, self.get());
                    if (!obj)
                    {
                        return nullptr;
                    }

                    reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj = std::move(obj);

                    return self.detach();
                }

                winrt::Microsoft::UI::Xaml::Controls::NavigationViewTemplateSettings instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_NavigationViewTemplateSettings(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* NavigationViewTemplateSettings_get_BackButtonVisibility(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.NavigationViewTemplateSettings", L"BackButtonVisibility");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::NavigationViewTemplateSettings>().BackButtonVisibility();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NavigationViewTemplateSettings_get_LeftPaneVisibility(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.NavigationViewTemplateSettings", L"LeftPaneVisibility");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::NavigationViewTemplateSettings>().LeftPaneVisibility();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NavigationViewTemplateSettings_get_OverflowButtonVisibility(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.NavigationViewTemplateSettings", L"OverflowButtonVisibility");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::NavigationViewTemplateSettings>().OverflowButtonVisibility();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NavigationViewTemplateSettings_get_PaneToggleButtonVisibility(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.NavigationViewTemplateSettings", L"PaneToggleButtonVisibility");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::NavigationViewTemplateSettings>().PaneToggleButtonVisibility();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NavigationViewTemplateSettings_get_PaneToggleButtonWidth(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.NavigationViewTemplateSettings", L"PaneToggleButtonWidth");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::NavigationViewTemplateSettings>().PaneToggleButtonWidth();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NavigationViewTemplateSettings_get_SingleSelectionFollowsFocus(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.NavigationViewTemplateSettings", L"SingleSelectionFollowsFocus");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::NavigationViewTemplateSettings>().SingleSelectionFollowsFocus();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NavigationViewTemplateSettings_get_SmallerPaneToggleButtonWidth(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.NavigationViewTemplateSettings", L"SmallerPaneToggleButtonWidth");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::NavigationViewTemplateSettings>().SmallerPaneToggleButtonWidth();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NavigationViewTemplateSettings_get_TopPadding(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.NavigationViewTemplateSettings", L"TopPadding");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::NavigationViewTemplateSettings>().TopPadding();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NavigationViewTemplateSettings_get_TopPaneVisibility(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.NavigationViewTemplateSettings", L"TopPaneVisibility");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::NavigationViewTemplateSettings>().TopPaneVisibility();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NavigationViewTemplateSettings_get_OpenPaneLength(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.NavigationViewTemplateSettings", L"OpenPaneLength");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::NavigationViewTemplateSettings>().OpenPaneLength();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NavigationViewTemplateSettings_get_BackButtonVisibilityProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.NavigationViewTemplateSettings", L"BackButtonVisibilityProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::NavigationViewTemplateSettings::BackButtonVisibilityProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NavigationViewTemplateSettings_get_LeftPaneVisibilityProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.NavigationViewTemplateSettings", L"LeftPaneVisibilityProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::NavigationViewTemplateSettings::LeftPaneVisibilityProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NavigationViewTemplateSettings_get_OverflowButtonVisibilityProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.NavigationViewTemplateSettings", L"OverflowButtonVisibilityProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::NavigationViewTemplateSettings::OverflowButtonVisibilityProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NavigationViewTemplateSettings_get_PaneToggleButtonVisibilityProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.NavigationViewTemplateSettings", L"PaneToggleButtonVisibilityProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::NavigationViewTemplateSettings::PaneToggleButtonVisibilityProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NavigationViewTemplateSettings_get_PaneToggleButtonWidthProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.NavigationViewTemplateSettings", L"PaneToggleButtonWidthProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::NavigationViewTemplateSettings::PaneToggleButtonWidthProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NavigationViewTemplateSettings_get_SingleSelectionFollowsFocusProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.NavigationViewTemplateSettings", L"SingleSelectionFollowsFocusProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::NavigationViewTemplateSettings::SingleSelectionFollowsFocusProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NavigationViewTemplateSettings_get_SmallerPaneToggleButtonWidthProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.NavigationViewTemplateSettings", L"SmallerPaneToggleButtonWidthProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::NavigationViewTemplateSettings::SmallerPaneToggleButtonWidthProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NavigationViewTemplateSettings_get_TopPaddingProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.NavigationViewTemplateSettings", L"TopPaddingProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::NavigationViewTemplateSettings::TopPaddingProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NavigationViewTemplateSettings_get_TopPaneVisibilityProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.NavigationViewTemplateSettings", L"TopPaneVisibilityProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::NavigationViewTemplateSettings::TopPaneVisibilityProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NavigationViewTemplateSettings_get_OpenPaneLengthProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.NavigationViewTemplateSettings", L"OpenPaneLengthProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::NavigationViewTemplateSettings::OpenPaneLengthProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_NavigationViewTemplateSettings(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::NavigationViewTemplateSettings>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_NavigationViewTemplateSettings(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::NavigationViewTemplateSettings>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_NavigationViewTemplateSettings[] = {
        { "_assign_array_", _assign_array_NavigationViewTemplateSettings, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_NavigationViewTemplateSettings), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_NavigationViewTemplateSettings[] = {
        { "back_button_visibility", reinterpret_cast<getter>(NavigationViewTemplateSettings_get_BackButtonVisibility), nullptr, nullptr, nullptr },
        { "left_pane_visibility", reinterpret_cast<getter>(NavigationViewTemplateSettings_get_LeftPaneVisibility), nullptr, nullptr, nullptr },
        { "overflow_button_visibility", reinterpret_cast<getter>(NavigationViewTemplateSettings_get_OverflowButtonVisibility), nullptr, nullptr, nullptr },
        { "pane_toggle_button_visibility", reinterpret_cast<getter>(NavigationViewTemplateSettings_get_PaneToggleButtonVisibility), nullptr, nullptr, nullptr },
        { "pane_toggle_button_width", reinterpret_cast<getter>(NavigationViewTemplateSettings_get_PaneToggleButtonWidth), nullptr, nullptr, nullptr },
        { "single_selection_follows_focus", reinterpret_cast<getter>(NavigationViewTemplateSettings_get_SingleSelectionFollowsFocus), nullptr, nullptr, nullptr },
        { "smaller_pane_toggle_button_width", reinterpret_cast<getter>(NavigationViewTemplateSettings_get_SmallerPaneToggleButtonWidth), nullptr, nullptr, nullptr },
        { "top_padding", reinterpret_cast<getter>(NavigationViewTemplateSettings_get_TopPadding), nullptr, nullptr, nullptr },
        { "top_pane_visibility", reinterpret_cast<getter>(NavigationViewTemplateSettings_get_TopPaneVisibility), nullptr, nullptr, nullptr },
        { "open_pane_length", reinterpret_cast<getter>(NavigationViewTemplateSettings_get_OpenPaneLength), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_NavigationViewTemplateSettings[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_NavigationViewTemplateSettings) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_NavigationViewTemplateSettings) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_NavigationViewTemplateSettings) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_NavigationViewTemplateSettings) },
        { }};

    static PyType_Spec type_spec_NavigationViewTemplateSettings = {
        "winui2._winui2_microsoft_ui_xaml_controls.NavigationViewTemplateSettings",
        sizeof(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_NavigationViewTemplateSettings};

    static PyGetSetDef getset_NavigationViewTemplateSettings_Static[] = {
        { "back_button_visibility_property", reinterpret_cast<getter>(NavigationViewTemplateSettings_get_BackButtonVisibilityProperty), nullptr, nullptr, nullptr },
        { "left_pane_visibility_property", reinterpret_cast<getter>(NavigationViewTemplateSettings_get_LeftPaneVisibilityProperty), nullptr, nullptr, nullptr },
        { "overflow_button_visibility_property", reinterpret_cast<getter>(NavigationViewTemplateSettings_get_OverflowButtonVisibilityProperty), nullptr, nullptr, nullptr },
        { "pane_toggle_button_visibility_property", reinterpret_cast<getter>(NavigationViewTemplateSettings_get_PaneToggleButtonVisibilityProperty), nullptr, nullptr, nullptr },
        { "pane_toggle_button_width_property", reinterpret_cast<getter>(NavigationViewTemplateSettings_get_PaneToggleButtonWidthProperty), nullptr, nullptr, nullptr },
        { "single_selection_follows_focus_property", reinterpret_cast<getter>(NavigationViewTemplateSettings_get_SingleSelectionFollowsFocusProperty), nullptr, nullptr, nullptr },
        { "smaller_pane_toggle_button_width_property", reinterpret_cast<getter>(NavigationViewTemplateSettings_get_SmallerPaneToggleButtonWidthProperty), nullptr, nullptr, nullptr },
        { "top_padding_property", reinterpret_cast<getter>(NavigationViewTemplateSettings_get_TopPaddingProperty), nullptr, nullptr, nullptr },
        { "top_pane_visibility_property", reinterpret_cast<getter>(NavigationViewTemplateSettings_get_TopPaneVisibilityProperty), nullptr, nullptr, nullptr },
        { "open_pane_length_property", reinterpret_cast<getter>(NavigationViewTemplateSettings_get_OpenPaneLengthProperty), nullptr, nullptr, nullptr },
        { }};

    static PyMethodDef methods_NavigationViewTemplateSettings_Static[] = {
        { }};

    static PyType_Slot type_slots_NavigationViewTemplateSettings_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_NavigationViewTemplateSettings_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_NavigationViewTemplateSettings_Static) },
        { }
    };

    static PyType_Spec type_spec_NavigationViewTemplateSettings_Static = {
        "winui2._winui2_microsoft_ui_xaml_controls.NavigationViewTemplateSettings_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_NavigationViewTemplateSettings_Static};

    // ----- NonVirtualizingLayout class --------------------

    struct PyWinrtNonVirtualizingLayout;
    using BasePyWinrtNonVirtualizingLayout = winrt::Microsoft::UI::Xaml::Controls::NonVirtualizingLayoutT<PyWinrtNonVirtualizingLayout, py::IPywinrtObject>;

    struct PyWinrtNonVirtualizingLayout : py::py_obj_ref, BasePyWinrtNonVirtualizingLayout
    {
        PyWinrtNonVirtualizingLayout(PyObject* py_obj) : py::py_obj_ref(py_obj), BasePyWinrtNonVirtualizingLayout() {}

        int32_t __stdcall GetPyObject(PyObject*& obj) override
        {
            obj = py::py_obj_ref::get_py_obj();
            return 0;
        }

        int32_t __stdcall GetComposableInner(winrt::Windows::Foundation::IInspectable& inner) override
        {
            inner = m_inner;
            return winrt::impl::error_ok;
        }

        static void toggle_reference(PyWinrtNonVirtualizingLayout* instance, bool is_last_reference)
        {
            py::py_obj_ref::toggle_reference(instance, is_last_reference);
        }

        int32_t query_interface_tearoff(winrt::guid const& id, void** result) const noexcept override
        {
            return py::py_obj_ref::query_interface_tearoff(id, result);
        }

        std::vector<winrt::guid> get_iids_tearoff() const noexcept override
        {
            return py::py_obj_ref::get_iids_tearoff();
        }

        winrt::Windows::Foundation::Size ArrangeOverride(winrt::Microsoft::UI::Xaml::Controls::NonVirtualizingLayoutContext const& param0, winrt::Windows::Foundation::Size param1)
        {
            auto gil = py::ensure_gil();

            try
            {
                py::pyobj_handle self{get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "_arrange_override")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param1{py::convert(param1)};
                if (!py_param1)
                {
                    throw python_exception();
                }

                py::pyobj_handle args{PyTuple_Pack(2, py_param0.get(), py_param1.get())};
                if (!args)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallObject(method.get(), args.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::Foundation::Size>(return_value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        void InitializeForContextCore(winrt::Microsoft::UI::Xaml::Controls::NonVirtualizingLayoutContext const& param0)
        {
            auto gil = py::ensure_gil();

            try
            {
                py::pyobj_handle self{get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "_initialize_for_context_core")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallOneArg(method.get(), py_param0.get())};
                if (!return_value)
                {
                    throw python_exception();
                }
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        winrt::Windows::Foundation::Size MeasureOverride(winrt::Microsoft::UI::Xaml::Controls::NonVirtualizingLayoutContext const& param0, winrt::Windows::Foundation::Size param1)
        {
            auto gil = py::ensure_gil();

            try
            {
                py::pyobj_handle self{get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "_measure_override")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param1{py::convert(param1)};
                if (!py_param1)
                {
                    throw python_exception();
                }

                py::pyobj_handle args{PyTuple_Pack(2, py_param0.get(), py_param1.get())};
                if (!args)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallObject(method.get(), args.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::Foundation::Size>(return_value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        void UninitializeForContextCore(winrt::Microsoft::UI::Xaml::Controls::NonVirtualizingLayoutContext const& param0)
        {
            auto gil = py::ensure_gil();

            try
            {
                py::pyobj_handle self{get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "_uninitialize_for_context_core")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallOneArg(method.get(), py_param0.get())};
                if (!return_value)
                {
                    throw python_exception();
                }
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }
    };

    static PyObject* _new_NonVirtualizingLayout(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_GET_SIZE(args);

        auto self_type = get_python_type_for<winrt::Microsoft::UI::Xaml::Controls::NonVirtualizingLayout>();
        if (!self_type)
        {
            return nullptr;
        }

        if (arg_count == 0)
        {
            try
            {
                if (type != self_type)
                {
                    py::pyobj_handle self{type->tp_alloc(type, 0)};
                    if (!self)
                    {
                        return nullptr;
                    }

                    std::construct_at(&reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj, nullptr);

                    auto obj_impl = winrt::make_self<PyWinrtNonVirtualizingLayout>(self.get());

                    auto obj = py::make_py_obj<PyWinrtNonVirtualizingLayout>(obj_impl, type, self.get());
                    if (!obj)
                    {
                        return nullptr;
                    }

                    reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj = std::move(obj);

                    return self.detach();
                }

                winrt::Microsoft::UI::Xaml::Controls::NonVirtualizingLayout instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_NonVirtualizingLayout(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* NonVirtualizingLayout_ArrangeOverride(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.NonVirtualizingLayout", L"ArrangeOverride", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::NonVirtualizingLayoutContext>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Size>(args, 1);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return py::get_inner_or_self(self->obj).try_as<winrt::Microsoft::UI::Xaml::Controls::INonVirtualizingLayoutOverrides>().ArrangeOverride(param0, param1);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* NonVirtualizingLayout_InitializeForContextCore(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.NonVirtualizingLayout", L"InitializeForContextCore", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::NonVirtualizingLayoutContext>(args, 0);

                {
                    auto _gil = release_gil();
                    py::get_inner_or_self(self->obj).try_as<winrt::Microsoft::UI::Xaml::Controls::INonVirtualizingLayoutOverrides>().InitializeForContextCore(param0);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* NonVirtualizingLayout_MeasureOverride(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.NonVirtualizingLayout", L"MeasureOverride", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::NonVirtualizingLayoutContext>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Size>(args, 1);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return py::get_inner_or_self(self->obj).try_as<winrt::Microsoft::UI::Xaml::Controls::INonVirtualizingLayoutOverrides>().MeasureOverride(param0, param1);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* NonVirtualizingLayout_UninitializeForContextCore(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.NonVirtualizingLayout", L"UninitializeForContextCore", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::NonVirtualizingLayoutContext>(args, 0);

                {
                    auto _gil = release_gil();
                    py::get_inner_or_self(self->obj).try_as<winrt::Microsoft::UI::Xaml::Controls::INonVirtualizingLayoutOverrides>().UninitializeForContextCore(param0);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_NonVirtualizingLayout(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::NonVirtualizingLayout>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_NonVirtualizingLayout(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::NonVirtualizingLayout>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_NonVirtualizingLayout[] = {
        { "_arrange_override", reinterpret_cast<PyCFunction>(NonVirtualizingLayout_ArrangeOverride), METH_VARARGS, nullptr },
        { "_initialize_for_context_core", reinterpret_cast<PyCFunction>(NonVirtualizingLayout_InitializeForContextCore), METH_VARARGS, nullptr },
        { "_measure_override", reinterpret_cast<PyCFunction>(NonVirtualizingLayout_MeasureOverride), METH_VARARGS, nullptr },
        { "_uninitialize_for_context_core", reinterpret_cast<PyCFunction>(NonVirtualizingLayout_UninitializeForContextCore), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_NonVirtualizingLayout, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_NonVirtualizingLayout), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_NonVirtualizingLayout[] = {
        { }};

    static PyType_Slot _type_slots_NonVirtualizingLayout[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_NonVirtualizingLayout) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_NonVirtualizingLayout) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_NonVirtualizingLayout) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_NonVirtualizingLayout) },
        { }};

    static PyType_Spec type_spec_NonVirtualizingLayout = {
        "winui2._winui2_microsoft_ui_xaml_controls.NonVirtualizingLayout",
        sizeof(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_NonVirtualizingLayout};

    static PyGetSetDef getset_NonVirtualizingLayout_Static[] = {
        { }};

    static PyMethodDef methods_NonVirtualizingLayout_Static[] = {
        { }};

    static PyType_Slot type_slots_NonVirtualizingLayout_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_NonVirtualizingLayout_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_NonVirtualizingLayout_Static) },
        { }
    };

    static PyType_Spec type_spec_NonVirtualizingLayout_Static = {
        "winui2._winui2_microsoft_ui_xaml_controls.NonVirtualizingLayout_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_NonVirtualizingLayout_Static};

    // ----- NonVirtualizingLayoutContext class --------------------

    struct PyWinrtNonVirtualizingLayoutContext;
    using BasePyWinrtNonVirtualizingLayoutContext = winrt::Microsoft::UI::Xaml::Controls::NonVirtualizingLayoutContextT<PyWinrtNonVirtualizingLayoutContext, py::IPywinrtObject>;

    struct PyWinrtNonVirtualizingLayoutContext : py::py_obj_ref, BasePyWinrtNonVirtualizingLayoutContext
    {
        PyWinrtNonVirtualizingLayoutContext(PyObject* py_obj) : py::py_obj_ref(py_obj), BasePyWinrtNonVirtualizingLayoutContext() {}

        int32_t __stdcall GetPyObject(PyObject*& obj) override
        {
            obj = py::py_obj_ref::get_py_obj();
            return 0;
        }

        int32_t __stdcall GetComposableInner(winrt::Windows::Foundation::IInspectable& inner) override
        {
            inner = m_inner;
            return winrt::impl::error_ok;
        }

        static void toggle_reference(PyWinrtNonVirtualizingLayoutContext* instance, bool is_last_reference)
        {
            py::py_obj_ref::toggle_reference(instance, is_last_reference);
        }

        int32_t query_interface_tearoff(winrt::guid const& id, void** result) const noexcept override
        {
            return py::py_obj_ref::query_interface_tearoff(id, result);
        }

        std::vector<winrt::guid> get_iids_tearoff() const noexcept override
        {
            return py::py_obj_ref::get_iids_tearoff();
        }
    };

    static PyObject* _new_NonVirtualizingLayoutContext(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_GET_SIZE(args);

        auto self_type = get_python_type_for<winrt::Microsoft::UI::Xaml::Controls::NonVirtualizingLayoutContext>();
        if (!self_type)
        {
            return nullptr;
        }

        if (arg_count == 0)
        {
            try
            {
                if (type != self_type)
                {
                    py::pyobj_handle self{type->tp_alloc(type, 0)};
                    if (!self)
                    {
                        return nullptr;
                    }

                    std::construct_at(&reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj, nullptr);

                    auto obj_impl = winrt::make_self<PyWinrtNonVirtualizingLayoutContext>(self.get());

                    auto obj = py::make_py_obj<PyWinrtNonVirtualizingLayoutContext>(obj_impl, type, self.get());
                    if (!obj)
                    {
                        return nullptr;
                    }

                    reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj = std::move(obj);

                    return self.detach();
                }

                winrt::Microsoft::UI::Xaml::Controls::NonVirtualizingLayoutContext instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_NonVirtualizingLayoutContext(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* NonVirtualizingLayoutContext_get_Children(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.NonVirtualizingLayoutContext", L"Children");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::NonVirtualizingLayoutContext>().Children();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_NonVirtualizingLayoutContext(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::NonVirtualizingLayoutContext>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_NonVirtualizingLayoutContext(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::NonVirtualizingLayoutContext>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_NonVirtualizingLayoutContext[] = {
        { "_assign_array_", _assign_array_NonVirtualizingLayoutContext, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_NonVirtualizingLayoutContext), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_NonVirtualizingLayoutContext[] = {
        { "children", reinterpret_cast<getter>(NonVirtualizingLayoutContext_get_Children), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_NonVirtualizingLayoutContext[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_NonVirtualizingLayoutContext) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_NonVirtualizingLayoutContext) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_NonVirtualizingLayoutContext) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_NonVirtualizingLayoutContext) },
        { }};

    static PyType_Spec type_spec_NonVirtualizingLayoutContext = {
        "winui2._winui2_microsoft_ui_xaml_controls.NonVirtualizingLayoutContext",
        sizeof(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_NonVirtualizingLayoutContext};

    static PyGetSetDef getset_NonVirtualizingLayoutContext_Static[] = {
        { }};

    static PyMethodDef methods_NonVirtualizingLayoutContext_Static[] = {
        { }};

    static PyType_Slot type_slots_NonVirtualizingLayoutContext_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_NonVirtualizingLayoutContext_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_NonVirtualizingLayoutContext_Static) },
        { }
    };

    static PyType_Spec type_spec_NonVirtualizingLayoutContext_Static = {
        "winui2._winui2_microsoft_ui_xaml_controls.NonVirtualizingLayoutContext_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_NonVirtualizingLayoutContext_Static};

    // ----- NumberBox class --------------------

    struct PyWinrtNumberBox;
    using BasePyWinrtNumberBox = winrt::Microsoft::UI::Xaml::Controls::NumberBoxT<PyWinrtNumberBox, py::IPywinrtObject>;

    struct PyWinrtNumberBox : py::py_obj_ref, BasePyWinrtNumberBox
    {
        PyWinrtNumberBox(PyObject* py_obj) : py::py_obj_ref(py_obj), BasePyWinrtNumberBox() {}

        int32_t __stdcall GetPyObject(PyObject*& obj) override
        {
            obj = py::py_obj_ref::get_py_obj();
            return 0;
        }

        int32_t __stdcall GetComposableInner(winrt::Windows::Foundation::IInspectable& inner) override
        {
            inner = m_inner;
            return winrt::impl::error_ok;
        }

        static void toggle_reference(PyWinrtNumberBox* instance, bool is_last_reference)
        {
            py::py_obj_ref::toggle_reference(instance, is_last_reference);
        }

        int32_t query_interface_tearoff(winrt::guid const& id, void** result) const noexcept override
        {
            return py::py_obj_ref::query_interface_tearoff(id, result);
        }

        std::vector<winrt::guid> get_iids_tearoff() const noexcept override
        {
            return py::py_obj_ref::get_iids_tearoff();
        }
    };

    static PyObject* _new_NumberBox(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_GET_SIZE(args);

        auto self_type = get_python_type_for<winrt::Microsoft::UI::Xaml::Controls::NumberBox>();
        if (!self_type)
        {
            return nullptr;
        }

        if (arg_count == 0)
        {
            try
            {
                if (type != self_type)
                {
                    py::pyobj_handle self{type->tp_alloc(type, 0)};
                    if (!self)
                    {
                        return nullptr;
                    }

                    std::construct_at(&reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj, nullptr);

                    auto obj_impl = winrt::make_self<PyWinrtNumberBox>(self.get());

                    auto obj = py::make_py_obj<PyWinrtNumberBox>(obj_impl, type, self.get());
                    if (!obj)
                    {
                        return nullptr;
                    }

                    reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj = std::move(obj);

                    return self.detach();
                }

                winrt::Microsoft::UI::Xaml::Controls::NumberBox instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_NumberBox(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* NumberBox_get_Value(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.NumberBox", L"Value");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::NumberBox>().Value();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int NumberBox_put_Value(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.NumberBox", L"Value");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<double>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::NumberBox>().Value(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* NumberBox_get_ValidationMode(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.NumberBox", L"ValidationMode");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::NumberBox>().ValidationMode();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int NumberBox_put_ValidationMode(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.NumberBox", L"ValidationMode");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::NumberBoxValidationMode>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::NumberBox>().ValidationMode(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* NumberBox_get_TextReadingOrder(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.NumberBox", L"TextReadingOrder");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::NumberBox>().TextReadingOrder();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int NumberBox_put_TextReadingOrder(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.NumberBox", L"TextReadingOrder");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::TextReadingOrder>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::NumberBox>().TextReadingOrder(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* NumberBox_get_Text(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.NumberBox", L"Text");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::NumberBox>().Text();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int NumberBox_put_Text(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.NumberBox", L"Text");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::NumberBox>().Text(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* NumberBox_get_SpinButtonPlacementMode(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.NumberBox", L"SpinButtonPlacementMode");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::NumberBox>().SpinButtonPlacementMode();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int NumberBox_put_SpinButtonPlacementMode(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.NumberBox", L"SpinButtonPlacementMode");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::NumberBoxSpinButtonPlacementMode>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::NumberBox>().SpinButtonPlacementMode(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* NumberBox_get_SmallChange(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.NumberBox", L"SmallChange");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::NumberBox>().SmallChange();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int NumberBox_put_SmallChange(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.NumberBox", L"SmallChange");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<double>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::NumberBox>().SmallChange(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* NumberBox_get_SelectionHighlightColor(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.NumberBox", L"SelectionHighlightColor");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::NumberBox>().SelectionHighlightColor();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int NumberBox_put_SelectionHighlightColor(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.NumberBox", L"SelectionHighlightColor");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Media::SolidColorBrush>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::NumberBox>().SelectionHighlightColor(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* NumberBox_get_SelectionFlyout(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.NumberBox", L"SelectionFlyout");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::NumberBox>().SelectionFlyout();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int NumberBox_put_SelectionFlyout(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.NumberBox", L"SelectionFlyout");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::Primitives::FlyoutBase>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::NumberBox>().SelectionFlyout(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* NumberBox_get_PreventKeyboardDisplayOnProgrammaticFocus(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.NumberBox", L"PreventKeyboardDisplayOnProgrammaticFocus");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::NumberBox>().PreventKeyboardDisplayOnProgrammaticFocus();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int NumberBox_put_PreventKeyboardDisplayOnProgrammaticFocus(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.NumberBox", L"PreventKeyboardDisplayOnProgrammaticFocus");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::NumberBox>().PreventKeyboardDisplayOnProgrammaticFocus(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* NumberBox_get_PlaceholderText(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.NumberBox", L"PlaceholderText");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::NumberBox>().PlaceholderText();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int NumberBox_put_PlaceholderText(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.NumberBox", L"PlaceholderText");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::NumberBox>().PlaceholderText(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* NumberBox_get_NumberFormatter(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.NumberBox", L"NumberFormatter");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::NumberBox>().NumberFormatter();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int NumberBox_put_NumberFormatter(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.NumberBox", L"NumberFormatter");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Globalization::NumberFormatting::INumberFormatter2>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::NumberBox>().NumberFormatter(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* NumberBox_get_Minimum(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.NumberBox", L"Minimum");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::NumberBox>().Minimum();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int NumberBox_put_Minimum(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.NumberBox", L"Minimum");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<double>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::NumberBox>().Minimum(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* NumberBox_get_Maximum(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.NumberBox", L"Maximum");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::NumberBox>().Maximum();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int NumberBox_put_Maximum(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.NumberBox", L"Maximum");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<double>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::NumberBox>().Maximum(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* NumberBox_get_LargeChange(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.NumberBox", L"LargeChange");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::NumberBox>().LargeChange();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int NumberBox_put_LargeChange(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.NumberBox", L"LargeChange");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<double>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::NumberBox>().LargeChange(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* NumberBox_get_IsWrapEnabled(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.NumberBox", L"IsWrapEnabled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::NumberBox>().IsWrapEnabled();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int NumberBox_put_IsWrapEnabled(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.NumberBox", L"IsWrapEnabled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::NumberBox>().IsWrapEnabled(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* NumberBox_get_HeaderTemplate(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.NumberBox", L"HeaderTemplate");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::NumberBox>().HeaderTemplate();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int NumberBox_put_HeaderTemplate(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.NumberBox", L"HeaderTemplate");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::DataTemplate>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::NumberBox>().HeaderTemplate(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* NumberBox_get_Header(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.NumberBox", L"Header");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::NumberBox>().Header();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int NumberBox_put_Header(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.NumberBox", L"Header");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::NumberBox>().Header(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* NumberBox_get_Description(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.NumberBox", L"Description");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::NumberBox>().Description();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int NumberBox_put_Description(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.NumberBox", L"Description");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::NumberBox>().Description(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* NumberBox_get_AcceptsExpression(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.NumberBox", L"AcceptsExpression");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::NumberBox>().AcceptsExpression();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int NumberBox_put_AcceptsExpression(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.NumberBox", L"AcceptsExpression");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::NumberBox>().AcceptsExpression(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* NumberBox_get_AcceptsExpressionProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.NumberBox", L"AcceptsExpressionProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::NumberBox::AcceptsExpressionProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NumberBox_get_DescriptionProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.NumberBox", L"DescriptionProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::NumberBox::DescriptionProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NumberBox_get_HeaderProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.NumberBox", L"HeaderProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::NumberBox::HeaderProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NumberBox_get_HeaderTemplateProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.NumberBox", L"HeaderTemplateProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::NumberBox::HeaderTemplateProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NumberBox_get_IsWrapEnabledProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.NumberBox", L"IsWrapEnabledProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::NumberBox::IsWrapEnabledProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NumberBox_get_LargeChangeProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.NumberBox", L"LargeChangeProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::NumberBox::LargeChangeProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NumberBox_get_MaximumProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.NumberBox", L"MaximumProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::NumberBox::MaximumProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NumberBox_get_MinimumProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.NumberBox", L"MinimumProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::NumberBox::MinimumProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NumberBox_get_NumberFormatterProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.NumberBox", L"NumberFormatterProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::NumberBox::NumberFormatterProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NumberBox_get_PlaceholderTextProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.NumberBox", L"PlaceholderTextProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::NumberBox::PlaceholderTextProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NumberBox_get_PreventKeyboardDisplayOnProgrammaticFocusProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.NumberBox", L"PreventKeyboardDisplayOnProgrammaticFocusProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::NumberBox::PreventKeyboardDisplayOnProgrammaticFocusProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NumberBox_get_SelectionFlyoutProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.NumberBox", L"SelectionFlyoutProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::NumberBox::SelectionFlyoutProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NumberBox_get_SelectionHighlightColorProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.NumberBox", L"SelectionHighlightColorProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::NumberBox::SelectionHighlightColorProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NumberBox_get_SmallChangeProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.NumberBox", L"SmallChangeProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::NumberBox::SmallChangeProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NumberBox_get_SpinButtonPlacementModeProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.NumberBox", L"SpinButtonPlacementModeProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::NumberBox::SpinButtonPlacementModeProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NumberBox_get_TextProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.NumberBox", L"TextProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::NumberBox::TextProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NumberBox_get_TextReadingOrderProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.NumberBox", L"TextReadingOrderProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::NumberBox::TextReadingOrderProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NumberBox_get_ValidationModeProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.NumberBox", L"ValidationModeProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::NumberBox::ValidationModeProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NumberBox_get_ValueProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.NumberBox", L"ValueProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::NumberBox::ValueProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NumberBox_add_ValueChanged(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.NumberBox", L"ValueChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Xaml::Controls::NumberBox, winrt::Microsoft::UI::Xaml::Controls::NumberBoxValueChangedEventArgs>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::NumberBox>().ValueChanged(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NumberBox_remove_ValueChanged(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.NumberBox", L"ValueChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::NumberBox>().ValueChanged(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_NumberBox(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::NumberBox>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_NumberBox(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::NumberBox>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_NumberBox[] = {
        { "add_value_changed", reinterpret_cast<PyCFunction>(NumberBox_add_ValueChanged), METH_O, nullptr },
        { "remove_value_changed", reinterpret_cast<PyCFunction>(NumberBox_remove_ValueChanged), METH_O, nullptr },
        { "_assign_array_", _assign_array_NumberBox, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_NumberBox), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_NumberBox[] = {
        { "value", reinterpret_cast<getter>(NumberBox_get_Value), reinterpret_cast<setter>(NumberBox_put_Value), nullptr, nullptr },
        { "validation_mode", reinterpret_cast<getter>(NumberBox_get_ValidationMode), reinterpret_cast<setter>(NumberBox_put_ValidationMode), nullptr, nullptr },
        { "text_reading_order", reinterpret_cast<getter>(NumberBox_get_TextReadingOrder), reinterpret_cast<setter>(NumberBox_put_TextReadingOrder), nullptr, nullptr },
        { "text", reinterpret_cast<getter>(NumberBox_get_Text), reinterpret_cast<setter>(NumberBox_put_Text), nullptr, nullptr },
        { "spin_button_placement_mode", reinterpret_cast<getter>(NumberBox_get_SpinButtonPlacementMode), reinterpret_cast<setter>(NumberBox_put_SpinButtonPlacementMode), nullptr, nullptr },
        { "small_change", reinterpret_cast<getter>(NumberBox_get_SmallChange), reinterpret_cast<setter>(NumberBox_put_SmallChange), nullptr, nullptr },
        { "selection_highlight_color", reinterpret_cast<getter>(NumberBox_get_SelectionHighlightColor), reinterpret_cast<setter>(NumberBox_put_SelectionHighlightColor), nullptr, nullptr },
        { "selection_flyout", reinterpret_cast<getter>(NumberBox_get_SelectionFlyout), reinterpret_cast<setter>(NumberBox_put_SelectionFlyout), nullptr, nullptr },
        { "prevent_keyboard_display_on_programmatic_focus", reinterpret_cast<getter>(NumberBox_get_PreventKeyboardDisplayOnProgrammaticFocus), reinterpret_cast<setter>(NumberBox_put_PreventKeyboardDisplayOnProgrammaticFocus), nullptr, nullptr },
        { "placeholder_text", reinterpret_cast<getter>(NumberBox_get_PlaceholderText), reinterpret_cast<setter>(NumberBox_put_PlaceholderText), nullptr, nullptr },
        { "number_formatter", reinterpret_cast<getter>(NumberBox_get_NumberFormatter), reinterpret_cast<setter>(NumberBox_put_NumberFormatter), nullptr, nullptr },
        { "minimum", reinterpret_cast<getter>(NumberBox_get_Minimum), reinterpret_cast<setter>(NumberBox_put_Minimum), nullptr, nullptr },
        { "maximum", reinterpret_cast<getter>(NumberBox_get_Maximum), reinterpret_cast<setter>(NumberBox_put_Maximum), nullptr, nullptr },
        { "large_change", reinterpret_cast<getter>(NumberBox_get_LargeChange), reinterpret_cast<setter>(NumberBox_put_LargeChange), nullptr, nullptr },
        { "is_wrap_enabled", reinterpret_cast<getter>(NumberBox_get_IsWrapEnabled), reinterpret_cast<setter>(NumberBox_put_IsWrapEnabled), nullptr, nullptr },
        { "header_template", reinterpret_cast<getter>(NumberBox_get_HeaderTemplate), reinterpret_cast<setter>(NumberBox_put_HeaderTemplate), nullptr, nullptr },
        { "header", reinterpret_cast<getter>(NumberBox_get_Header), reinterpret_cast<setter>(NumberBox_put_Header), nullptr, nullptr },
        { "description", reinterpret_cast<getter>(NumberBox_get_Description), reinterpret_cast<setter>(NumberBox_put_Description), nullptr, nullptr },
        { "accepts_expression", reinterpret_cast<getter>(NumberBox_get_AcceptsExpression), reinterpret_cast<setter>(NumberBox_put_AcceptsExpression), nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_NumberBox[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_NumberBox) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_NumberBox) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_NumberBox) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_NumberBox) },
        { }};

    static PyType_Spec type_spec_NumberBox = {
        "winui2._winui2_microsoft_ui_xaml_controls.NumberBox",
        sizeof(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_NumberBox};

    static PyGetSetDef getset_NumberBox_Static[] = {
        { "accepts_expression_property", reinterpret_cast<getter>(NumberBox_get_AcceptsExpressionProperty), nullptr, nullptr, nullptr },
        { "description_property", reinterpret_cast<getter>(NumberBox_get_DescriptionProperty), nullptr, nullptr, nullptr },
        { "header_property", reinterpret_cast<getter>(NumberBox_get_HeaderProperty), nullptr, nullptr, nullptr },
        { "header_template_property", reinterpret_cast<getter>(NumberBox_get_HeaderTemplateProperty), nullptr, nullptr, nullptr },
        { "is_wrap_enabled_property", reinterpret_cast<getter>(NumberBox_get_IsWrapEnabledProperty), nullptr, nullptr, nullptr },
        { "large_change_property", reinterpret_cast<getter>(NumberBox_get_LargeChangeProperty), nullptr, nullptr, nullptr },
        { "maximum_property", reinterpret_cast<getter>(NumberBox_get_MaximumProperty), nullptr, nullptr, nullptr },
        { "minimum_property", reinterpret_cast<getter>(NumberBox_get_MinimumProperty), nullptr, nullptr, nullptr },
        { "number_formatter_property", reinterpret_cast<getter>(NumberBox_get_NumberFormatterProperty), nullptr, nullptr, nullptr },
        { "placeholder_text_property", reinterpret_cast<getter>(NumberBox_get_PlaceholderTextProperty), nullptr, nullptr, nullptr },
        { "prevent_keyboard_display_on_programmatic_focus_property", reinterpret_cast<getter>(NumberBox_get_PreventKeyboardDisplayOnProgrammaticFocusProperty), nullptr, nullptr, nullptr },
        { "selection_flyout_property", reinterpret_cast<getter>(NumberBox_get_SelectionFlyoutProperty), nullptr, nullptr, nullptr },
        { "selection_highlight_color_property", reinterpret_cast<getter>(NumberBox_get_SelectionHighlightColorProperty), nullptr, nullptr, nullptr },
        { "small_change_property", reinterpret_cast<getter>(NumberBox_get_SmallChangeProperty), nullptr, nullptr, nullptr },
        { "spin_button_placement_mode_property", reinterpret_cast<getter>(NumberBox_get_SpinButtonPlacementModeProperty), nullptr, nullptr, nullptr },
        { "text_property", reinterpret_cast<getter>(NumberBox_get_TextProperty), nullptr, nullptr, nullptr },
        { "text_reading_order_property", reinterpret_cast<getter>(NumberBox_get_TextReadingOrderProperty), nullptr, nullptr, nullptr },
        { "validation_mode_property", reinterpret_cast<getter>(NumberBox_get_ValidationModeProperty), nullptr, nullptr, nullptr },
        { "value_property", reinterpret_cast<getter>(NumberBox_get_ValueProperty), nullptr, nullptr, nullptr },
        { }};

    static PyMethodDef methods_NumberBox_Static[] = {
        { }};

    static PyType_Slot type_slots_NumberBox_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_NumberBox_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_NumberBox_Static) },
        { }
    };

    static PyType_Spec type_spec_NumberBox_Static = {
        "winui2._winui2_microsoft_ui_xaml_controls.NumberBox_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_NumberBox_Static};

    // ----- NumberBoxValueChangedEventArgs class --------------------

    static PyObject* _new_NumberBoxValueChangedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Xaml::Controls::NumberBoxValueChangedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Xaml::Controls::NumberBoxValueChangedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_NumberBoxValueChangedEventArgs(py::wrapper::Microsoft::UI::Xaml::Controls::NumberBoxValueChangedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* NumberBoxValueChangedEventArgs_get_NewValue(py::wrapper::Microsoft::UI::Xaml::Controls::NumberBoxValueChangedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.NumberBoxValueChangedEventArgs", L"NewValue");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.NewValue();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NumberBoxValueChangedEventArgs_get_OldValue(py::wrapper::Microsoft::UI::Xaml::Controls::NumberBoxValueChangedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.NumberBoxValueChangedEventArgs", L"OldValue");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.OldValue();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_NumberBoxValueChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::NumberBoxValueChangedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_NumberBoxValueChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::NumberBoxValueChangedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_NumberBoxValueChangedEventArgs[] = {
        { "_assign_array_", _assign_array_NumberBoxValueChangedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_NumberBoxValueChangedEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_NumberBoxValueChangedEventArgs[] = {
        { "new_value", reinterpret_cast<getter>(NumberBoxValueChangedEventArgs_get_NewValue), nullptr, nullptr, nullptr },
        { "old_value", reinterpret_cast<getter>(NumberBoxValueChangedEventArgs_get_OldValue), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_NumberBoxValueChangedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_NumberBoxValueChangedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_NumberBoxValueChangedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_NumberBoxValueChangedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_NumberBoxValueChangedEventArgs) },
        { }};

    static PyType_Spec type_spec_NumberBoxValueChangedEventArgs = {
        "winui2._winui2_microsoft_ui_xaml_controls.NumberBoxValueChangedEventArgs",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Controls::NumberBoxValueChangedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_NumberBoxValueChangedEventArgs};

    // ----- ParallaxView class --------------------

    struct PyWinrtParallaxView;
    using BasePyWinrtParallaxView = winrt::Microsoft::UI::Xaml::Controls::ParallaxViewT<PyWinrtParallaxView, py::IPywinrtObject>;

    struct PyWinrtParallaxView : py::py_obj_ref, BasePyWinrtParallaxView
    {
        PyWinrtParallaxView(PyObject* py_obj) : py::py_obj_ref(py_obj), BasePyWinrtParallaxView() {}

        int32_t __stdcall GetPyObject(PyObject*& obj) override
        {
            obj = py::py_obj_ref::get_py_obj();
            return 0;
        }

        int32_t __stdcall GetComposableInner(winrt::Windows::Foundation::IInspectable& inner) override
        {
            inner = m_inner;
            return winrt::impl::error_ok;
        }

        static void toggle_reference(PyWinrtParallaxView* instance, bool is_last_reference)
        {
            py::py_obj_ref::toggle_reference(instance, is_last_reference);
        }

        int32_t query_interface_tearoff(winrt::guid const& id, void** result) const noexcept override
        {
            return py::py_obj_ref::query_interface_tearoff(id, result);
        }

        std::vector<winrt::guid> get_iids_tearoff() const noexcept override
        {
            return py::py_obj_ref::get_iids_tearoff();
        }
    };

    static PyObject* _new_ParallaxView(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_GET_SIZE(args);

        auto self_type = get_python_type_for<winrt::Microsoft::UI::Xaml::Controls::ParallaxView>();
        if (!self_type)
        {
            return nullptr;
        }

        if (arg_count == 0)
        {
            try
            {
                if (type != self_type)
                {
                    py::pyobj_handle self{type->tp_alloc(type, 0)};
                    if (!self)
                    {
                        return nullptr;
                    }

                    std::construct_at(&reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj, nullptr);

                    auto obj_impl = winrt::make_self<PyWinrtParallaxView>(self.get());

                    auto obj = py::make_py_obj<PyWinrtParallaxView>(obj_impl, type, self.get());
                    if (!obj)
                    {
                        return nullptr;
                    }

                    reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj = std::move(obj);

                    return self.detach();
                }

                winrt::Microsoft::UI::Xaml::Controls::ParallaxView instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ParallaxView(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ParallaxView_RefreshAutomaticHorizontalOffsets(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.ParallaxView", L"RefreshAutomaticHorizontalOffsets", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::ParallaxView>().RefreshAutomaticHorizontalOffsets();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ParallaxView_RefreshAutomaticVerticalOffsets(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.ParallaxView", L"RefreshAutomaticVerticalOffsets", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::ParallaxView>().RefreshAutomaticVerticalOffsets();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ParallaxView_get_VerticalSourceStartOffset(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ParallaxView", L"VerticalSourceStartOffset");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::ParallaxView>().VerticalSourceStartOffset();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ParallaxView_put_VerticalSourceStartOffset(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ParallaxView", L"VerticalSourceStartOffset");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<double>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::ParallaxView>().VerticalSourceStartOffset(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ParallaxView_get_VerticalSourceOffsetKind(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ParallaxView", L"VerticalSourceOffsetKind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::ParallaxView>().VerticalSourceOffsetKind();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ParallaxView_put_VerticalSourceOffsetKind(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ParallaxView", L"VerticalSourceOffsetKind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::ParallaxSourceOffsetKind>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::ParallaxView>().VerticalSourceOffsetKind(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ParallaxView_get_VerticalSourceEndOffset(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ParallaxView", L"VerticalSourceEndOffset");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::ParallaxView>().VerticalSourceEndOffset();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ParallaxView_put_VerticalSourceEndOffset(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ParallaxView", L"VerticalSourceEndOffset");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<double>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::ParallaxView>().VerticalSourceEndOffset(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ParallaxView_get_VerticalShift(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ParallaxView", L"VerticalShift");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::ParallaxView>().VerticalShift();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ParallaxView_put_VerticalShift(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ParallaxView", L"VerticalShift");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<double>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::ParallaxView>().VerticalShift(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ParallaxView_get_Source(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ParallaxView", L"Source");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::ParallaxView>().Source();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ParallaxView_put_Source(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ParallaxView", L"Source");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::UIElement>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::ParallaxView>().Source(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ParallaxView_get_MaxVerticalShiftRatio(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ParallaxView", L"MaxVerticalShiftRatio");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::ParallaxView>().MaxVerticalShiftRatio();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ParallaxView_put_MaxVerticalShiftRatio(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ParallaxView", L"MaxVerticalShiftRatio");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<double>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::ParallaxView>().MaxVerticalShiftRatio(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ParallaxView_get_MaxHorizontalShiftRatio(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ParallaxView", L"MaxHorizontalShiftRatio");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::ParallaxView>().MaxHorizontalShiftRatio();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ParallaxView_put_MaxHorizontalShiftRatio(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ParallaxView", L"MaxHorizontalShiftRatio");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<double>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::ParallaxView>().MaxHorizontalShiftRatio(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ParallaxView_get_IsVerticalShiftClamped(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ParallaxView", L"IsVerticalShiftClamped");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::ParallaxView>().IsVerticalShiftClamped();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ParallaxView_put_IsVerticalShiftClamped(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ParallaxView", L"IsVerticalShiftClamped");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::ParallaxView>().IsVerticalShiftClamped(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ParallaxView_get_IsHorizontalShiftClamped(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ParallaxView", L"IsHorizontalShiftClamped");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::ParallaxView>().IsHorizontalShiftClamped();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ParallaxView_put_IsHorizontalShiftClamped(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ParallaxView", L"IsHorizontalShiftClamped");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::ParallaxView>().IsHorizontalShiftClamped(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ParallaxView_get_HorizontalSourceStartOffset(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ParallaxView", L"HorizontalSourceStartOffset");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::ParallaxView>().HorizontalSourceStartOffset();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ParallaxView_put_HorizontalSourceStartOffset(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ParallaxView", L"HorizontalSourceStartOffset");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<double>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::ParallaxView>().HorizontalSourceStartOffset(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ParallaxView_get_HorizontalSourceOffsetKind(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ParallaxView", L"HorizontalSourceOffsetKind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::ParallaxView>().HorizontalSourceOffsetKind();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ParallaxView_put_HorizontalSourceOffsetKind(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ParallaxView", L"HorizontalSourceOffsetKind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::ParallaxSourceOffsetKind>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::ParallaxView>().HorizontalSourceOffsetKind(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ParallaxView_get_HorizontalSourceEndOffset(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ParallaxView", L"HorizontalSourceEndOffset");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::ParallaxView>().HorizontalSourceEndOffset();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ParallaxView_put_HorizontalSourceEndOffset(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ParallaxView", L"HorizontalSourceEndOffset");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<double>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::ParallaxView>().HorizontalSourceEndOffset(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ParallaxView_get_HorizontalShift(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ParallaxView", L"HorizontalShift");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::ParallaxView>().HorizontalShift();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ParallaxView_put_HorizontalShift(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ParallaxView", L"HorizontalShift");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<double>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::ParallaxView>().HorizontalShift(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ParallaxView_get_Child(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ParallaxView", L"Child");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::ParallaxView>().Child();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ParallaxView_put_Child(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ParallaxView", L"Child");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::UIElement>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::ParallaxView>().Child(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ParallaxView_get_ChildProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ParallaxView", L"ChildProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::ParallaxView::ChildProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ParallaxView_get_HorizontalShiftProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ParallaxView", L"HorizontalShiftProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::ParallaxView::HorizontalShiftProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ParallaxView_get_HorizontalSourceEndOffsetProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ParallaxView", L"HorizontalSourceEndOffsetProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::ParallaxView::HorizontalSourceEndOffsetProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ParallaxView_get_HorizontalSourceOffsetKindProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ParallaxView", L"HorizontalSourceOffsetKindProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::ParallaxView::HorizontalSourceOffsetKindProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ParallaxView_get_HorizontalSourceStartOffsetProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ParallaxView", L"HorizontalSourceStartOffsetProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::ParallaxView::HorizontalSourceStartOffsetProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ParallaxView_get_IsHorizontalShiftClampedProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ParallaxView", L"IsHorizontalShiftClampedProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::ParallaxView::IsHorizontalShiftClampedProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ParallaxView_get_IsVerticalShiftClampedProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ParallaxView", L"IsVerticalShiftClampedProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::ParallaxView::IsVerticalShiftClampedProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ParallaxView_get_MaxHorizontalShiftRatioProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ParallaxView", L"MaxHorizontalShiftRatioProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::ParallaxView::MaxHorizontalShiftRatioProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ParallaxView_get_MaxVerticalShiftRatioProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ParallaxView", L"MaxVerticalShiftRatioProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::ParallaxView::MaxVerticalShiftRatioProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ParallaxView_get_SourceProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ParallaxView", L"SourceProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::ParallaxView::SourceProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ParallaxView_get_VerticalShiftProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ParallaxView", L"VerticalShiftProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::ParallaxView::VerticalShiftProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ParallaxView_get_VerticalSourceEndOffsetProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ParallaxView", L"VerticalSourceEndOffsetProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::ParallaxView::VerticalSourceEndOffsetProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ParallaxView_get_VerticalSourceOffsetKindProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ParallaxView", L"VerticalSourceOffsetKindProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::ParallaxView::VerticalSourceOffsetKindProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ParallaxView_get_VerticalSourceStartOffsetProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ParallaxView", L"VerticalSourceStartOffsetProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::ParallaxView::VerticalSourceStartOffsetProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ParallaxView(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::ParallaxView>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ParallaxView(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::ParallaxView>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ParallaxView[] = {
        { "refresh_automatic_horizontal_offsets", reinterpret_cast<PyCFunction>(ParallaxView_RefreshAutomaticHorizontalOffsets), METH_VARARGS, nullptr },
        { "refresh_automatic_vertical_offsets", reinterpret_cast<PyCFunction>(ParallaxView_RefreshAutomaticVerticalOffsets), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_ParallaxView, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ParallaxView), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_ParallaxView[] = {
        { "vertical_source_start_offset", reinterpret_cast<getter>(ParallaxView_get_VerticalSourceStartOffset), reinterpret_cast<setter>(ParallaxView_put_VerticalSourceStartOffset), nullptr, nullptr },
        { "vertical_source_offset_kind", reinterpret_cast<getter>(ParallaxView_get_VerticalSourceOffsetKind), reinterpret_cast<setter>(ParallaxView_put_VerticalSourceOffsetKind), nullptr, nullptr },
        { "vertical_source_end_offset", reinterpret_cast<getter>(ParallaxView_get_VerticalSourceEndOffset), reinterpret_cast<setter>(ParallaxView_put_VerticalSourceEndOffset), nullptr, nullptr },
        { "vertical_shift", reinterpret_cast<getter>(ParallaxView_get_VerticalShift), reinterpret_cast<setter>(ParallaxView_put_VerticalShift), nullptr, nullptr },
        { "source", reinterpret_cast<getter>(ParallaxView_get_Source), reinterpret_cast<setter>(ParallaxView_put_Source), nullptr, nullptr },
        { "max_vertical_shift_ratio", reinterpret_cast<getter>(ParallaxView_get_MaxVerticalShiftRatio), reinterpret_cast<setter>(ParallaxView_put_MaxVerticalShiftRatio), nullptr, nullptr },
        { "max_horizontal_shift_ratio", reinterpret_cast<getter>(ParallaxView_get_MaxHorizontalShiftRatio), reinterpret_cast<setter>(ParallaxView_put_MaxHorizontalShiftRatio), nullptr, nullptr },
        { "is_vertical_shift_clamped", reinterpret_cast<getter>(ParallaxView_get_IsVerticalShiftClamped), reinterpret_cast<setter>(ParallaxView_put_IsVerticalShiftClamped), nullptr, nullptr },
        { "is_horizontal_shift_clamped", reinterpret_cast<getter>(ParallaxView_get_IsHorizontalShiftClamped), reinterpret_cast<setter>(ParallaxView_put_IsHorizontalShiftClamped), nullptr, nullptr },
        { "horizontal_source_start_offset", reinterpret_cast<getter>(ParallaxView_get_HorizontalSourceStartOffset), reinterpret_cast<setter>(ParallaxView_put_HorizontalSourceStartOffset), nullptr, nullptr },
        { "horizontal_source_offset_kind", reinterpret_cast<getter>(ParallaxView_get_HorizontalSourceOffsetKind), reinterpret_cast<setter>(ParallaxView_put_HorizontalSourceOffsetKind), nullptr, nullptr },
        { "horizontal_source_end_offset", reinterpret_cast<getter>(ParallaxView_get_HorizontalSourceEndOffset), reinterpret_cast<setter>(ParallaxView_put_HorizontalSourceEndOffset), nullptr, nullptr },
        { "horizontal_shift", reinterpret_cast<getter>(ParallaxView_get_HorizontalShift), reinterpret_cast<setter>(ParallaxView_put_HorizontalShift), nullptr, nullptr },
        { "child", reinterpret_cast<getter>(ParallaxView_get_Child), reinterpret_cast<setter>(ParallaxView_put_Child), nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_ParallaxView[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ParallaxView) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ParallaxView) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ParallaxView) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ParallaxView) },
        { }};

    static PyType_Spec type_spec_ParallaxView = {
        "winui2._winui2_microsoft_ui_xaml_controls.ParallaxView",
        sizeof(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_ParallaxView};

    static PyGetSetDef getset_ParallaxView_Static[] = {
        { "child_property", reinterpret_cast<getter>(ParallaxView_get_ChildProperty), nullptr, nullptr, nullptr },
        { "horizontal_shift_property", reinterpret_cast<getter>(ParallaxView_get_HorizontalShiftProperty), nullptr, nullptr, nullptr },
        { "horizontal_source_end_offset_property", reinterpret_cast<getter>(ParallaxView_get_HorizontalSourceEndOffsetProperty), nullptr, nullptr, nullptr },
        { "horizontal_source_offset_kind_property", reinterpret_cast<getter>(ParallaxView_get_HorizontalSourceOffsetKindProperty), nullptr, nullptr, nullptr },
        { "horizontal_source_start_offset_property", reinterpret_cast<getter>(ParallaxView_get_HorizontalSourceStartOffsetProperty), nullptr, nullptr, nullptr },
        { "is_horizontal_shift_clamped_property", reinterpret_cast<getter>(ParallaxView_get_IsHorizontalShiftClampedProperty), nullptr, nullptr, nullptr },
        { "is_vertical_shift_clamped_property", reinterpret_cast<getter>(ParallaxView_get_IsVerticalShiftClampedProperty), nullptr, nullptr, nullptr },
        { "max_horizontal_shift_ratio_property", reinterpret_cast<getter>(ParallaxView_get_MaxHorizontalShiftRatioProperty), nullptr, nullptr, nullptr },
        { "max_vertical_shift_ratio_property", reinterpret_cast<getter>(ParallaxView_get_MaxVerticalShiftRatioProperty), nullptr, nullptr, nullptr },
        { "source_property", reinterpret_cast<getter>(ParallaxView_get_SourceProperty), nullptr, nullptr, nullptr },
        { "vertical_shift_property", reinterpret_cast<getter>(ParallaxView_get_VerticalShiftProperty), nullptr, nullptr, nullptr },
        { "vertical_source_end_offset_property", reinterpret_cast<getter>(ParallaxView_get_VerticalSourceEndOffsetProperty), nullptr, nullptr, nullptr },
        { "vertical_source_offset_kind_property", reinterpret_cast<getter>(ParallaxView_get_VerticalSourceOffsetKindProperty), nullptr, nullptr, nullptr },
        { "vertical_source_start_offset_property", reinterpret_cast<getter>(ParallaxView_get_VerticalSourceStartOffsetProperty), nullptr, nullptr, nullptr },
        { }};

    static PyMethodDef methods_ParallaxView_Static[] = {
        { }};

    static PyType_Slot type_slots_ParallaxView_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_ParallaxView_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_ParallaxView_Static) },
        { }
    };

    static PyType_Spec type_spec_ParallaxView_Static = {
        "winui2._winui2_microsoft_ui_xaml_controls.ParallaxView_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_ParallaxView_Static};

    // ----- PathIconSource class --------------------

    struct PyWinrtPathIconSource;
    using BasePyWinrtPathIconSource = winrt::Microsoft::UI::Xaml::Controls::PathIconSourceT<PyWinrtPathIconSource, py::IPywinrtObject>;

    struct PyWinrtPathIconSource : py::py_obj_ref, BasePyWinrtPathIconSource
    {
        PyWinrtPathIconSource(PyObject* py_obj) : py::py_obj_ref(py_obj), BasePyWinrtPathIconSource() {}

        int32_t __stdcall GetPyObject(PyObject*& obj) override
        {
            obj = py::py_obj_ref::get_py_obj();
            return 0;
        }

        int32_t __stdcall GetComposableInner(winrt::Windows::Foundation::IInspectable& inner) override
        {
            inner = m_inner;
            return winrt::impl::error_ok;
        }

        static void toggle_reference(PyWinrtPathIconSource* instance, bool is_last_reference)
        {
            py::py_obj_ref::toggle_reference(instance, is_last_reference);
        }

        int32_t query_interface_tearoff(winrt::guid const& id, void** result) const noexcept override
        {
            return py::py_obj_ref::query_interface_tearoff(id, result);
        }

        std::vector<winrt::guid> get_iids_tearoff() const noexcept override
        {
            return py::py_obj_ref::get_iids_tearoff();
        }
    };

    static PyObject* _new_PathIconSource(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_GET_SIZE(args);

        auto self_type = get_python_type_for<winrt::Microsoft::UI::Xaml::Controls::PathIconSource>();
        if (!self_type)
        {
            return nullptr;
        }

        if (arg_count == 0)
        {
            try
            {
                if (type != self_type)
                {
                    py::pyobj_handle self{type->tp_alloc(type, 0)};
                    if (!self)
                    {
                        return nullptr;
                    }

                    std::construct_at(&reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj, nullptr);

                    auto obj_impl = winrt::make_self<PyWinrtPathIconSource>(self.get());

                    auto obj = py::make_py_obj<PyWinrtPathIconSource>(obj_impl, type, self.get());
                    if (!obj)
                    {
                        return nullptr;
                    }

                    reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj = std::move(obj);

                    return self.detach();
                }

                winrt::Microsoft::UI::Xaml::Controls::PathIconSource instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_PathIconSource(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PathIconSource_get_Data(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.PathIconSource", L"Data");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::PathIconSource>().Data();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PathIconSource_put_Data(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.PathIconSource", L"Data");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Media::Geometry>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::PathIconSource>().Data(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PathIconSource_get_DataProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.PathIconSource", L"DataProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::PathIconSource::DataProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PathIconSource(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::PathIconSource>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PathIconSource(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::PathIconSource>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PathIconSource[] = {
        { "_assign_array_", _assign_array_PathIconSource, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PathIconSource), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_PathIconSource[] = {
        { "data", reinterpret_cast<getter>(PathIconSource_get_Data), reinterpret_cast<setter>(PathIconSource_put_Data), nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_PathIconSource[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_PathIconSource) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PathIconSource) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PathIconSource) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PathIconSource) },
        { }};

    static PyType_Spec type_spec_PathIconSource = {
        "winui2._winui2_microsoft_ui_xaml_controls.PathIconSource",
        sizeof(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_PathIconSource};

    static PyGetSetDef getset_PathIconSource_Static[] = {
        { "data_property", reinterpret_cast<getter>(PathIconSource_get_DataProperty), nullptr, nullptr, nullptr },
        { }};

    static PyMethodDef methods_PathIconSource_Static[] = {
        { }};

    static PyType_Slot type_slots_PathIconSource_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_PathIconSource_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_PathIconSource_Static) },
        { }
    };

    static PyType_Spec type_spec_PathIconSource_Static = {
        "winui2._winui2_microsoft_ui_xaml_controls.PathIconSource_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_PathIconSource_Static};

    // ----- PersonPicture class --------------------

    struct PyWinrtPersonPicture;
    using BasePyWinrtPersonPicture = winrt::Microsoft::UI::Xaml::Controls::PersonPictureT<PyWinrtPersonPicture, py::IPywinrtObject>;

    struct PyWinrtPersonPicture : py::py_obj_ref, BasePyWinrtPersonPicture
    {
        PyWinrtPersonPicture(PyObject* py_obj) : py::py_obj_ref(py_obj), BasePyWinrtPersonPicture() {}

        int32_t __stdcall GetPyObject(PyObject*& obj) override
        {
            obj = py::py_obj_ref::get_py_obj();
            return 0;
        }

        int32_t __stdcall GetComposableInner(winrt::Windows::Foundation::IInspectable& inner) override
        {
            inner = m_inner;
            return winrt::impl::error_ok;
        }

        static void toggle_reference(PyWinrtPersonPicture* instance, bool is_last_reference)
        {
            py::py_obj_ref::toggle_reference(instance, is_last_reference);
        }

        int32_t query_interface_tearoff(winrt::guid const& id, void** result) const noexcept override
        {
            return py::py_obj_ref::query_interface_tearoff(id, result);
        }

        std::vector<winrt::guid> get_iids_tearoff() const noexcept override
        {
            return py::py_obj_ref::get_iids_tearoff();
        }
    };

    static PyObject* _new_PersonPicture(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_GET_SIZE(args);

        auto self_type = get_python_type_for<winrt::Microsoft::UI::Xaml::Controls::PersonPicture>();
        if (!self_type)
        {
            return nullptr;
        }

        if (arg_count == 0)
        {
            try
            {
                if (type != self_type)
                {
                    py::pyobj_handle self{type->tp_alloc(type, 0)};
                    if (!self)
                    {
                        return nullptr;
                    }

                    std::construct_at(&reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj, nullptr);

                    auto obj_impl = winrt::make_self<PyWinrtPersonPicture>(self.get());

                    auto obj = py::make_py_obj<PyWinrtPersonPicture>(obj_impl, type, self.get());
                    if (!obj)
                    {
                        return nullptr;
                    }

                    reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj = std::move(obj);

                    return self.detach();
                }

                winrt::Microsoft::UI::Xaml::Controls::PersonPicture instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_PersonPicture(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PersonPicture_get_ProfilePicture(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.PersonPicture", L"ProfilePicture");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::PersonPicture>().ProfilePicture();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PersonPicture_put_ProfilePicture(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.PersonPicture", L"ProfilePicture");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Media::ImageSource>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::PersonPicture>().ProfilePicture(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PersonPicture_get_PreferSmallImage(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.PersonPicture", L"PreferSmallImage");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::PersonPicture>().PreferSmallImage();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PersonPicture_put_PreferSmallImage(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.PersonPicture", L"PreferSmallImage");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::PersonPicture>().PreferSmallImage(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PersonPicture_get_IsGroup(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.PersonPicture", L"IsGroup");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::PersonPicture>().IsGroup();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PersonPicture_put_IsGroup(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.PersonPicture", L"IsGroup");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::PersonPicture>().IsGroup(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PersonPicture_get_Initials(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.PersonPicture", L"Initials");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::PersonPicture>().Initials();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PersonPicture_put_Initials(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.PersonPicture", L"Initials");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::PersonPicture>().Initials(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PersonPicture_get_DisplayName(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.PersonPicture", L"DisplayName");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::PersonPicture>().DisplayName();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PersonPicture_put_DisplayName(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.PersonPicture", L"DisplayName");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::PersonPicture>().DisplayName(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PersonPicture_get_Contact(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.PersonPicture", L"Contact");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::PersonPicture>().Contact();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PersonPicture_put_Contact(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.PersonPicture", L"Contact");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Contacts::Contact>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::PersonPicture>().Contact(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PersonPicture_get_BadgeText(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.PersonPicture", L"BadgeText");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::PersonPicture>().BadgeText();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PersonPicture_put_BadgeText(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.PersonPicture", L"BadgeText");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::PersonPicture>().BadgeText(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PersonPicture_get_BadgeNumber(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.PersonPicture", L"BadgeNumber");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::PersonPicture>().BadgeNumber();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PersonPicture_put_BadgeNumber(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.PersonPicture", L"BadgeNumber");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<int32_t>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::PersonPicture>().BadgeNumber(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PersonPicture_get_BadgeImageSource(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.PersonPicture", L"BadgeImageSource");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::PersonPicture>().BadgeImageSource();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PersonPicture_put_BadgeImageSource(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.PersonPicture", L"BadgeImageSource");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Media::ImageSource>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::PersonPicture>().BadgeImageSource(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PersonPicture_get_BadgeGlyph(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.PersonPicture", L"BadgeGlyph");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::PersonPicture>().BadgeGlyph();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PersonPicture_put_BadgeGlyph(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.PersonPicture", L"BadgeGlyph");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::PersonPicture>().BadgeGlyph(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PersonPicture_get_TemplateSettings(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.PersonPicture", L"TemplateSettings");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::PersonPicture>().TemplateSettings();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PersonPicture_get_BadgeGlyphProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.PersonPicture", L"BadgeGlyphProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::PersonPicture::BadgeGlyphProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PersonPicture_get_BadgeImageSourceProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.PersonPicture", L"BadgeImageSourceProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::PersonPicture::BadgeImageSourceProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PersonPicture_get_BadgeNumberProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.PersonPicture", L"BadgeNumberProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::PersonPicture::BadgeNumberProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PersonPicture_get_BadgeTextProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.PersonPicture", L"BadgeTextProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::PersonPicture::BadgeTextProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PersonPicture_get_ContactProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.PersonPicture", L"ContactProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::PersonPicture::ContactProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PersonPicture_get_DisplayNameProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.PersonPicture", L"DisplayNameProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::PersonPicture::DisplayNameProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PersonPicture_get_InitialsProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.PersonPicture", L"InitialsProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::PersonPicture::InitialsProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PersonPicture_get_IsGroupProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.PersonPicture", L"IsGroupProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::PersonPicture::IsGroupProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PersonPicture_get_PreferSmallImageProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.PersonPicture", L"PreferSmallImageProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::PersonPicture::PreferSmallImageProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PersonPicture_get_ProfilePictureProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.PersonPicture", L"ProfilePictureProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::PersonPicture::ProfilePictureProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PersonPicture(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::PersonPicture>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PersonPicture(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::PersonPicture>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PersonPicture[] = {
        { "_assign_array_", _assign_array_PersonPicture, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PersonPicture), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_PersonPicture[] = {
        { "profile_picture", reinterpret_cast<getter>(PersonPicture_get_ProfilePicture), reinterpret_cast<setter>(PersonPicture_put_ProfilePicture), nullptr, nullptr },
        { "prefer_small_image", reinterpret_cast<getter>(PersonPicture_get_PreferSmallImage), reinterpret_cast<setter>(PersonPicture_put_PreferSmallImage), nullptr, nullptr },
        { "is_group", reinterpret_cast<getter>(PersonPicture_get_IsGroup), reinterpret_cast<setter>(PersonPicture_put_IsGroup), nullptr, nullptr },
        { "initials", reinterpret_cast<getter>(PersonPicture_get_Initials), reinterpret_cast<setter>(PersonPicture_put_Initials), nullptr, nullptr },
        { "display_name", reinterpret_cast<getter>(PersonPicture_get_DisplayName), reinterpret_cast<setter>(PersonPicture_put_DisplayName), nullptr, nullptr },
        { "contact", reinterpret_cast<getter>(PersonPicture_get_Contact), reinterpret_cast<setter>(PersonPicture_put_Contact), nullptr, nullptr },
        { "badge_text", reinterpret_cast<getter>(PersonPicture_get_BadgeText), reinterpret_cast<setter>(PersonPicture_put_BadgeText), nullptr, nullptr },
        { "badge_number", reinterpret_cast<getter>(PersonPicture_get_BadgeNumber), reinterpret_cast<setter>(PersonPicture_put_BadgeNumber), nullptr, nullptr },
        { "badge_image_source", reinterpret_cast<getter>(PersonPicture_get_BadgeImageSource), reinterpret_cast<setter>(PersonPicture_put_BadgeImageSource), nullptr, nullptr },
        { "badge_glyph", reinterpret_cast<getter>(PersonPicture_get_BadgeGlyph), reinterpret_cast<setter>(PersonPicture_put_BadgeGlyph), nullptr, nullptr },
        { "template_settings", reinterpret_cast<getter>(PersonPicture_get_TemplateSettings), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_PersonPicture[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_PersonPicture) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PersonPicture) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PersonPicture) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PersonPicture) },
        { }};

    static PyType_Spec type_spec_PersonPicture = {
        "winui2._winui2_microsoft_ui_xaml_controls.PersonPicture",
        sizeof(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_PersonPicture};

    static PyGetSetDef getset_PersonPicture_Static[] = {
        { "badge_glyph_property", reinterpret_cast<getter>(PersonPicture_get_BadgeGlyphProperty), nullptr, nullptr, nullptr },
        { "badge_image_source_property", reinterpret_cast<getter>(PersonPicture_get_BadgeImageSourceProperty), nullptr, nullptr, nullptr },
        { "badge_number_property", reinterpret_cast<getter>(PersonPicture_get_BadgeNumberProperty), nullptr, nullptr, nullptr },
        { "badge_text_property", reinterpret_cast<getter>(PersonPicture_get_BadgeTextProperty), nullptr, nullptr, nullptr },
        { "contact_property", reinterpret_cast<getter>(PersonPicture_get_ContactProperty), nullptr, nullptr, nullptr },
        { "display_name_property", reinterpret_cast<getter>(PersonPicture_get_DisplayNameProperty), nullptr, nullptr, nullptr },
        { "initials_property", reinterpret_cast<getter>(PersonPicture_get_InitialsProperty), nullptr, nullptr, nullptr },
        { "is_group_property", reinterpret_cast<getter>(PersonPicture_get_IsGroupProperty), nullptr, nullptr, nullptr },
        { "prefer_small_image_property", reinterpret_cast<getter>(PersonPicture_get_PreferSmallImageProperty), nullptr, nullptr, nullptr },
        { "profile_picture_property", reinterpret_cast<getter>(PersonPicture_get_ProfilePictureProperty), nullptr, nullptr, nullptr },
        { }};

    static PyMethodDef methods_PersonPicture_Static[] = {
        { }};

    static PyType_Slot type_slots_PersonPicture_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_PersonPicture_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_PersonPicture_Static) },
        { }
    };

    static PyType_Spec type_spec_PersonPicture_Static = {
        "winui2._winui2_microsoft_ui_xaml_controls.PersonPicture_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_PersonPicture_Static};

    // ----- PersonPictureTemplateSettings class --------------------

    static PyObject* _new_PersonPictureTemplateSettings(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Xaml::Controls::PersonPictureTemplateSettings>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Xaml::Controls::PersonPictureTemplateSettings>::type_name);
        return nullptr;
    }

    static void _dealloc_PersonPictureTemplateSettings(py::wrapper::Microsoft::UI::Xaml::Controls::PersonPictureTemplateSettings* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PersonPictureTemplateSettings_get_ActualImageBrush(py::wrapper::Microsoft::UI::Xaml::Controls::PersonPictureTemplateSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.PersonPictureTemplateSettings", L"ActualImageBrush");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ActualImageBrush();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PersonPictureTemplateSettings_get_ActualInitials(py::wrapper::Microsoft::UI::Xaml::Controls::PersonPictureTemplateSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.PersonPictureTemplateSettings", L"ActualInitials");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ActualInitials();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PersonPictureTemplateSettings(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::PersonPictureTemplateSettings>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PersonPictureTemplateSettings(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::PersonPictureTemplateSettings>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PersonPictureTemplateSettings[] = {
        { "_assign_array_", _assign_array_PersonPictureTemplateSettings, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PersonPictureTemplateSettings), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_PersonPictureTemplateSettings[] = {
        { "actual_image_brush", reinterpret_cast<getter>(PersonPictureTemplateSettings_get_ActualImageBrush), nullptr, nullptr, nullptr },
        { "actual_initials", reinterpret_cast<getter>(PersonPictureTemplateSettings_get_ActualInitials), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_PersonPictureTemplateSettings[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_PersonPictureTemplateSettings) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PersonPictureTemplateSettings) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PersonPictureTemplateSettings) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PersonPictureTemplateSettings) },
        { }};

    static PyType_Spec type_spec_PersonPictureTemplateSettings = {
        "winui2._winui2_microsoft_ui_xaml_controls.PersonPictureTemplateSettings",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Controls::PersonPictureTemplateSettings),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PersonPictureTemplateSettings};

    // ----- PipsPager class --------------------

    struct PyWinrtPipsPager;
    using BasePyWinrtPipsPager = winrt::Microsoft::UI::Xaml::Controls::PipsPagerT<PyWinrtPipsPager, py::IPywinrtObject>;

    struct PyWinrtPipsPager : py::py_obj_ref, BasePyWinrtPipsPager
    {
        PyWinrtPipsPager(PyObject* py_obj) : py::py_obj_ref(py_obj), BasePyWinrtPipsPager() {}

        int32_t __stdcall GetPyObject(PyObject*& obj) override
        {
            obj = py::py_obj_ref::get_py_obj();
            return 0;
        }

        int32_t __stdcall GetComposableInner(winrt::Windows::Foundation::IInspectable& inner) override
        {
            inner = m_inner;
            return winrt::impl::error_ok;
        }

        static void toggle_reference(PyWinrtPipsPager* instance, bool is_last_reference)
        {
            py::py_obj_ref::toggle_reference(instance, is_last_reference);
        }

        int32_t query_interface_tearoff(winrt::guid const& id, void** result) const noexcept override
        {
            return py::py_obj_ref::query_interface_tearoff(id, result);
        }

        std::vector<winrt::guid> get_iids_tearoff() const noexcept override
        {
            return py::py_obj_ref::get_iids_tearoff();
        }
    };

    static PyObject* _new_PipsPager(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_GET_SIZE(args);

        auto self_type = get_python_type_for<winrt::Microsoft::UI::Xaml::Controls::PipsPager>();
        if (!self_type)
        {
            return nullptr;
        }

        if (arg_count == 0)
        {
            try
            {
                if (type != self_type)
                {
                    py::pyobj_handle self{type->tp_alloc(type, 0)};
                    if (!self)
                    {
                        return nullptr;
                    }

                    std::construct_at(&reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj, nullptr);

                    auto obj_impl = winrt::make_self<PyWinrtPipsPager>(self.get());

                    auto obj = py::make_py_obj<PyWinrtPipsPager>(obj_impl, type, self.get());
                    if (!obj)
                    {
                        return nullptr;
                    }

                    reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj = std::move(obj);

                    return self.detach();
                }

                winrt::Microsoft::UI::Xaml::Controls::PipsPager instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_PipsPager(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PipsPager_get_SelectedPipStyle(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.PipsPager", L"SelectedPipStyle");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::PipsPager>().SelectedPipStyle();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PipsPager_put_SelectedPipStyle(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.PipsPager", L"SelectedPipStyle");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Style>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::PipsPager>().SelectedPipStyle(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PipsPager_get_SelectedPageIndex(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.PipsPager", L"SelectedPageIndex");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::PipsPager>().SelectedPageIndex();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PipsPager_put_SelectedPageIndex(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.PipsPager", L"SelectedPageIndex");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<int32_t>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::PipsPager>().SelectedPageIndex(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PipsPager_get_PreviousButtonVisibility(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.PipsPager", L"PreviousButtonVisibility");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::PipsPager>().PreviousButtonVisibility();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PipsPager_put_PreviousButtonVisibility(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.PipsPager", L"PreviousButtonVisibility");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::PipsPagerButtonVisibility>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::PipsPager>().PreviousButtonVisibility(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PipsPager_get_PreviousButtonStyle(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.PipsPager", L"PreviousButtonStyle");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::PipsPager>().PreviousButtonStyle();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PipsPager_put_PreviousButtonStyle(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.PipsPager", L"PreviousButtonStyle");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Style>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::PipsPager>().PreviousButtonStyle(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PipsPager_get_Orientation(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.PipsPager", L"Orientation");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::PipsPager>().Orientation();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PipsPager_put_Orientation(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.PipsPager", L"Orientation");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::Orientation>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::PipsPager>().Orientation(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PipsPager_get_NumberOfPages(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.PipsPager", L"NumberOfPages");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::PipsPager>().NumberOfPages();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PipsPager_put_NumberOfPages(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.PipsPager", L"NumberOfPages");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<int32_t>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::PipsPager>().NumberOfPages(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PipsPager_get_NormalPipStyle(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.PipsPager", L"NormalPipStyle");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::PipsPager>().NormalPipStyle();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PipsPager_put_NormalPipStyle(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.PipsPager", L"NormalPipStyle");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Style>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::PipsPager>().NormalPipStyle(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PipsPager_get_NextButtonVisibility(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.PipsPager", L"NextButtonVisibility");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::PipsPager>().NextButtonVisibility();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PipsPager_put_NextButtonVisibility(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.PipsPager", L"NextButtonVisibility");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::PipsPagerButtonVisibility>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::PipsPager>().NextButtonVisibility(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PipsPager_get_NextButtonStyle(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.PipsPager", L"NextButtonStyle");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::PipsPager>().NextButtonStyle();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PipsPager_put_NextButtonStyle(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.PipsPager", L"NextButtonStyle");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Style>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::PipsPager>().NextButtonStyle(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PipsPager_get_MaxVisiblePips(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.PipsPager", L"MaxVisiblePips");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::PipsPager>().MaxVisiblePips();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PipsPager_put_MaxVisiblePips(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.PipsPager", L"MaxVisiblePips");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<int32_t>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::PipsPager>().MaxVisiblePips(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PipsPager_get_TemplateSettings(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.PipsPager", L"TemplateSettings");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::PipsPager>().TemplateSettings();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PipsPager_get_MaxVisiblePipsProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.PipsPager", L"MaxVisiblePipsProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::PipsPager::MaxVisiblePipsProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PipsPager_get_NextButtonStyleProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.PipsPager", L"NextButtonStyleProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::PipsPager::NextButtonStyleProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PipsPager_get_NextButtonVisibilityProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.PipsPager", L"NextButtonVisibilityProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::PipsPager::NextButtonVisibilityProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PipsPager_get_NormalPipStyleProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.PipsPager", L"NormalPipStyleProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::PipsPager::NormalPipStyleProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PipsPager_get_NumberOfPagesProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.PipsPager", L"NumberOfPagesProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::PipsPager::NumberOfPagesProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PipsPager_get_OrientationProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.PipsPager", L"OrientationProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::PipsPager::OrientationProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PipsPager_get_PreviousButtonStyleProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.PipsPager", L"PreviousButtonStyleProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::PipsPager::PreviousButtonStyleProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PipsPager_get_PreviousButtonVisibilityProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.PipsPager", L"PreviousButtonVisibilityProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::PipsPager::PreviousButtonVisibilityProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PipsPager_get_SelectedPageIndexProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.PipsPager", L"SelectedPageIndexProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::PipsPager::SelectedPageIndexProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PipsPager_get_SelectedPipStyleProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.PipsPager", L"SelectedPipStyleProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::PipsPager::SelectedPipStyleProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PipsPager_add_SelectedIndexChanged(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.PipsPager", L"SelectedIndexChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Xaml::Controls::PipsPager, winrt::Microsoft::UI::Xaml::Controls::PipsPagerSelectedIndexChangedEventArgs>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::PipsPager>().SelectedIndexChanged(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PipsPager_remove_SelectedIndexChanged(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.PipsPager", L"SelectedIndexChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::PipsPager>().SelectedIndexChanged(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PipsPager(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::PipsPager>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PipsPager(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::PipsPager>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PipsPager[] = {
        { "add_selected_index_changed", reinterpret_cast<PyCFunction>(PipsPager_add_SelectedIndexChanged), METH_O, nullptr },
        { "remove_selected_index_changed", reinterpret_cast<PyCFunction>(PipsPager_remove_SelectedIndexChanged), METH_O, nullptr },
        { "_assign_array_", _assign_array_PipsPager, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PipsPager), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_PipsPager[] = {
        { "selected_pip_style", reinterpret_cast<getter>(PipsPager_get_SelectedPipStyle), reinterpret_cast<setter>(PipsPager_put_SelectedPipStyle), nullptr, nullptr },
        { "selected_page_index", reinterpret_cast<getter>(PipsPager_get_SelectedPageIndex), reinterpret_cast<setter>(PipsPager_put_SelectedPageIndex), nullptr, nullptr },
        { "previous_button_visibility", reinterpret_cast<getter>(PipsPager_get_PreviousButtonVisibility), reinterpret_cast<setter>(PipsPager_put_PreviousButtonVisibility), nullptr, nullptr },
        { "previous_button_style", reinterpret_cast<getter>(PipsPager_get_PreviousButtonStyle), reinterpret_cast<setter>(PipsPager_put_PreviousButtonStyle), nullptr, nullptr },
        { "orientation", reinterpret_cast<getter>(PipsPager_get_Orientation), reinterpret_cast<setter>(PipsPager_put_Orientation), nullptr, nullptr },
        { "number_of_pages", reinterpret_cast<getter>(PipsPager_get_NumberOfPages), reinterpret_cast<setter>(PipsPager_put_NumberOfPages), nullptr, nullptr },
        { "normal_pip_style", reinterpret_cast<getter>(PipsPager_get_NormalPipStyle), reinterpret_cast<setter>(PipsPager_put_NormalPipStyle), nullptr, nullptr },
        { "next_button_visibility", reinterpret_cast<getter>(PipsPager_get_NextButtonVisibility), reinterpret_cast<setter>(PipsPager_put_NextButtonVisibility), nullptr, nullptr },
        { "next_button_style", reinterpret_cast<getter>(PipsPager_get_NextButtonStyle), reinterpret_cast<setter>(PipsPager_put_NextButtonStyle), nullptr, nullptr },
        { "max_visible_pips", reinterpret_cast<getter>(PipsPager_get_MaxVisiblePips), reinterpret_cast<setter>(PipsPager_put_MaxVisiblePips), nullptr, nullptr },
        { "template_settings", reinterpret_cast<getter>(PipsPager_get_TemplateSettings), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_PipsPager[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_PipsPager) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PipsPager) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PipsPager) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PipsPager) },
        { }};

    static PyType_Spec type_spec_PipsPager = {
        "winui2._winui2_microsoft_ui_xaml_controls.PipsPager",
        sizeof(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_PipsPager};

    static PyGetSetDef getset_PipsPager_Static[] = {
        { "max_visible_pips_property", reinterpret_cast<getter>(PipsPager_get_MaxVisiblePipsProperty), nullptr, nullptr, nullptr },
        { "next_button_style_property", reinterpret_cast<getter>(PipsPager_get_NextButtonStyleProperty), nullptr, nullptr, nullptr },
        { "next_button_visibility_property", reinterpret_cast<getter>(PipsPager_get_NextButtonVisibilityProperty), nullptr, nullptr, nullptr },
        { "normal_pip_style_property", reinterpret_cast<getter>(PipsPager_get_NormalPipStyleProperty), nullptr, nullptr, nullptr },
        { "number_of_pages_property", reinterpret_cast<getter>(PipsPager_get_NumberOfPagesProperty), nullptr, nullptr, nullptr },
        { "orientation_property", reinterpret_cast<getter>(PipsPager_get_OrientationProperty), nullptr, nullptr, nullptr },
        { "previous_button_style_property", reinterpret_cast<getter>(PipsPager_get_PreviousButtonStyleProperty), nullptr, nullptr, nullptr },
        { "previous_button_visibility_property", reinterpret_cast<getter>(PipsPager_get_PreviousButtonVisibilityProperty), nullptr, nullptr, nullptr },
        { "selected_page_index_property", reinterpret_cast<getter>(PipsPager_get_SelectedPageIndexProperty), nullptr, nullptr, nullptr },
        { "selected_pip_style_property", reinterpret_cast<getter>(PipsPager_get_SelectedPipStyleProperty), nullptr, nullptr, nullptr },
        { }};

    static PyMethodDef methods_PipsPager_Static[] = {
        { }};

    static PyType_Slot type_slots_PipsPager_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_PipsPager_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_PipsPager_Static) },
        { }
    };

    static PyType_Spec type_spec_PipsPager_Static = {
        "winui2._winui2_microsoft_ui_xaml_controls.PipsPager_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_PipsPager_Static};

    // ----- PipsPagerSelectedIndexChangedEventArgs class --------------------

    static PyObject* _new_PipsPagerSelectedIndexChangedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Xaml::Controls::PipsPagerSelectedIndexChangedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Xaml::Controls::PipsPagerSelectedIndexChangedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_PipsPagerSelectedIndexChangedEventArgs(py::wrapper::Microsoft::UI::Xaml::Controls::PipsPagerSelectedIndexChangedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_PipsPagerSelectedIndexChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::PipsPagerSelectedIndexChangedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PipsPagerSelectedIndexChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::PipsPagerSelectedIndexChangedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PipsPagerSelectedIndexChangedEventArgs[] = {
        { "_assign_array_", _assign_array_PipsPagerSelectedIndexChangedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PipsPagerSelectedIndexChangedEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_PipsPagerSelectedIndexChangedEventArgs[] = {
        { }};

    static PyType_Slot _type_slots_PipsPagerSelectedIndexChangedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_PipsPagerSelectedIndexChangedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PipsPagerSelectedIndexChangedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PipsPagerSelectedIndexChangedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PipsPagerSelectedIndexChangedEventArgs) },
        { }};

    static PyType_Spec type_spec_PipsPagerSelectedIndexChangedEventArgs = {
        "winui2._winui2_microsoft_ui_xaml_controls.PipsPagerSelectedIndexChangedEventArgs",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Controls::PipsPagerSelectedIndexChangedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PipsPagerSelectedIndexChangedEventArgs};

    // ----- PipsPagerTemplateSettings class --------------------

    static PyObject* _new_PipsPagerTemplateSettings(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Xaml::Controls::PipsPagerTemplateSettings>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Xaml::Controls::PipsPagerTemplateSettings>::type_name);
        return nullptr;
    }

    static void _dealloc_PipsPagerTemplateSettings(py::wrapper::Microsoft::UI::Xaml::Controls::PipsPagerTemplateSettings* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PipsPagerTemplateSettings_get_PipsPagerItems(py::wrapper::Microsoft::UI::Xaml::Controls::PipsPagerTemplateSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.PipsPagerTemplateSettings", L"PipsPagerItems");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PipsPagerItems();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PipsPagerTemplateSettings(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::PipsPagerTemplateSettings>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PipsPagerTemplateSettings(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::PipsPagerTemplateSettings>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PipsPagerTemplateSettings[] = {
        { "_assign_array_", _assign_array_PipsPagerTemplateSettings, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PipsPagerTemplateSettings), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_PipsPagerTemplateSettings[] = {
        { "pips_pager_items", reinterpret_cast<getter>(PipsPagerTemplateSettings_get_PipsPagerItems), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_PipsPagerTemplateSettings[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_PipsPagerTemplateSettings) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PipsPagerTemplateSettings) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PipsPagerTemplateSettings) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PipsPagerTemplateSettings) },
        { }};

    static PyType_Spec type_spec_PipsPagerTemplateSettings = {
        "winui2._winui2_microsoft_ui_xaml_controls.PipsPagerTemplateSettings",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Controls::PipsPagerTemplateSettings),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PipsPagerTemplateSettings};

    // ----- ProgressBar class --------------------

    struct PyWinrtProgressBar;
    using BasePyWinrtProgressBar = winrt::Microsoft::UI::Xaml::Controls::ProgressBarT<PyWinrtProgressBar, py::IPywinrtObject>;

    struct PyWinrtProgressBar : py::py_obj_ref, BasePyWinrtProgressBar
    {
        PyWinrtProgressBar(PyObject* py_obj) : py::py_obj_ref(py_obj), BasePyWinrtProgressBar() {}

        int32_t __stdcall GetPyObject(PyObject*& obj) override
        {
            obj = py::py_obj_ref::get_py_obj();
            return 0;
        }

        int32_t __stdcall GetComposableInner(winrt::Windows::Foundation::IInspectable& inner) override
        {
            inner = m_inner;
            return winrt::impl::error_ok;
        }

        static void toggle_reference(PyWinrtProgressBar* instance, bool is_last_reference)
        {
            py::py_obj_ref::toggle_reference(instance, is_last_reference);
        }

        int32_t query_interface_tearoff(winrt::guid const& id, void** result) const noexcept override
        {
            return py::py_obj_ref::query_interface_tearoff(id, result);
        }

        std::vector<winrt::guid> get_iids_tearoff() const noexcept override
        {
            return py::py_obj_ref::get_iids_tearoff();
        }
    };

    static PyObject* _new_ProgressBar(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_GET_SIZE(args);

        auto self_type = get_python_type_for<winrt::Microsoft::UI::Xaml::Controls::ProgressBar>();
        if (!self_type)
        {
            return nullptr;
        }

        if (arg_count == 0)
        {
            try
            {
                if (type != self_type)
                {
                    py::pyobj_handle self{type->tp_alloc(type, 0)};
                    if (!self)
                    {
                        return nullptr;
                    }

                    std::construct_at(&reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj, nullptr);

                    auto obj_impl = winrt::make_self<PyWinrtProgressBar>(self.get());

                    auto obj = py::make_py_obj<PyWinrtProgressBar>(obj_impl, type, self.get());
                    if (!obj)
                    {
                        return nullptr;
                    }

                    reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj = std::move(obj);

                    return self.detach();
                }

                winrt::Microsoft::UI::Xaml::Controls::ProgressBar instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ProgressBar(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ProgressBar_get_ShowPaused(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ProgressBar", L"ShowPaused");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::ProgressBar>().ShowPaused();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ProgressBar_put_ShowPaused(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ProgressBar", L"ShowPaused");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::ProgressBar>().ShowPaused(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ProgressBar_get_ShowError(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ProgressBar", L"ShowError");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::ProgressBar>().ShowError();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ProgressBar_put_ShowError(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ProgressBar", L"ShowError");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::ProgressBar>().ShowError(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ProgressBar_get_IsIndeterminate(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ProgressBar", L"IsIndeterminate");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::ProgressBar>().IsIndeterminate();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ProgressBar_put_IsIndeterminate(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ProgressBar", L"IsIndeterminate");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::ProgressBar>().IsIndeterminate(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ProgressBar_get_TemplateSettings(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ProgressBar", L"TemplateSettings");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::ProgressBar>().TemplateSettings();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ProgressBar_get_IsIndeterminateProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ProgressBar", L"IsIndeterminateProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::ProgressBar::IsIndeterminateProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ProgressBar_get_ShowErrorProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ProgressBar", L"ShowErrorProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::ProgressBar::ShowErrorProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ProgressBar_get_ShowPausedProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ProgressBar", L"ShowPausedProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::ProgressBar::ShowPausedProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ProgressBar(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::ProgressBar>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ProgressBar(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::ProgressBar>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ProgressBar[] = {
        { "_assign_array_", _assign_array_ProgressBar, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ProgressBar), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_ProgressBar[] = {
        { "show_paused", reinterpret_cast<getter>(ProgressBar_get_ShowPaused), reinterpret_cast<setter>(ProgressBar_put_ShowPaused), nullptr, nullptr },
        { "show_error", reinterpret_cast<getter>(ProgressBar_get_ShowError), reinterpret_cast<setter>(ProgressBar_put_ShowError), nullptr, nullptr },
        { "is_indeterminate", reinterpret_cast<getter>(ProgressBar_get_IsIndeterminate), reinterpret_cast<setter>(ProgressBar_put_IsIndeterminate), nullptr, nullptr },
        { "template_settings", reinterpret_cast<getter>(ProgressBar_get_TemplateSettings), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_ProgressBar[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ProgressBar) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ProgressBar) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ProgressBar) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ProgressBar) },
        { }};

    static PyType_Spec type_spec_ProgressBar = {
        "winui2._winui2_microsoft_ui_xaml_controls.ProgressBar",
        sizeof(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_ProgressBar};

    static PyGetSetDef getset_ProgressBar_Static[] = {
        { "is_indeterminate_property", reinterpret_cast<getter>(ProgressBar_get_IsIndeterminateProperty), nullptr, nullptr, nullptr },
        { "show_error_property", reinterpret_cast<getter>(ProgressBar_get_ShowErrorProperty), nullptr, nullptr, nullptr },
        { "show_paused_property", reinterpret_cast<getter>(ProgressBar_get_ShowPausedProperty), nullptr, nullptr, nullptr },
        { }};

    static PyMethodDef methods_ProgressBar_Static[] = {
        { }};

    static PyType_Slot type_slots_ProgressBar_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_ProgressBar_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_ProgressBar_Static) },
        { }
    };

    static PyType_Spec type_spec_ProgressBar_Static = {
        "winui2._winui2_microsoft_ui_xaml_controls.ProgressBar_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_ProgressBar_Static};

    // ----- ProgressBarTemplateSettings class --------------------

    static PyObject* _new_ProgressBarTemplateSettings(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Xaml::Controls::ProgressBarTemplateSettings>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Xaml::Controls::ProgressBarTemplateSettings>::type_name);
        return nullptr;
    }

    static void _dealloc_ProgressBarTemplateSettings(py::wrapper::Microsoft::UI::Xaml::Controls::ProgressBarTemplateSettings* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ProgressBarTemplateSettings_get_ClipRect(py::wrapper::Microsoft::UI::Xaml::Controls::ProgressBarTemplateSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ProgressBarTemplateSettings", L"ClipRect");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ClipRect();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ProgressBarTemplateSettings_get_Container2AnimationEndPosition(py::wrapper::Microsoft::UI::Xaml::Controls::ProgressBarTemplateSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ProgressBarTemplateSettings", L"Container2AnimationEndPosition");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Container2AnimationEndPosition();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ProgressBarTemplateSettings_get_Container2AnimationStartPosition(py::wrapper::Microsoft::UI::Xaml::Controls::ProgressBarTemplateSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ProgressBarTemplateSettings", L"Container2AnimationStartPosition");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Container2AnimationStartPosition();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ProgressBarTemplateSettings_get_ContainerAnimationEndPosition(py::wrapper::Microsoft::UI::Xaml::Controls::ProgressBarTemplateSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ProgressBarTemplateSettings", L"ContainerAnimationEndPosition");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ContainerAnimationEndPosition();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ProgressBarTemplateSettings_get_ContainerAnimationMidPosition(py::wrapper::Microsoft::UI::Xaml::Controls::ProgressBarTemplateSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ProgressBarTemplateSettings", L"ContainerAnimationMidPosition");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ContainerAnimationMidPosition();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ProgressBarTemplateSettings_get_ContainerAnimationStartPosition(py::wrapper::Microsoft::UI::Xaml::Controls::ProgressBarTemplateSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ProgressBarTemplateSettings", L"ContainerAnimationStartPosition");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ContainerAnimationStartPosition();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ProgressBarTemplateSettings_get_EllipseAnimationEndPosition(py::wrapper::Microsoft::UI::Xaml::Controls::ProgressBarTemplateSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ProgressBarTemplateSettings", L"EllipseAnimationEndPosition");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.EllipseAnimationEndPosition();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ProgressBarTemplateSettings_get_EllipseAnimationWellPosition(py::wrapper::Microsoft::UI::Xaml::Controls::ProgressBarTemplateSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ProgressBarTemplateSettings", L"EllipseAnimationWellPosition");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.EllipseAnimationWellPosition();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ProgressBarTemplateSettings_get_EllipseDiameter(py::wrapper::Microsoft::UI::Xaml::Controls::ProgressBarTemplateSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ProgressBarTemplateSettings", L"EllipseDiameter");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.EllipseDiameter();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ProgressBarTemplateSettings_get_EllipseOffset(py::wrapper::Microsoft::UI::Xaml::Controls::ProgressBarTemplateSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ProgressBarTemplateSettings", L"EllipseOffset");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.EllipseOffset();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ProgressBarTemplateSettings_get_IndicatorLengthDelta(py::wrapper::Microsoft::UI::Xaml::Controls::ProgressBarTemplateSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ProgressBarTemplateSettings", L"IndicatorLengthDelta");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.IndicatorLengthDelta();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ProgressBarTemplateSettings(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::ProgressBarTemplateSettings>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ProgressBarTemplateSettings(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::ProgressBarTemplateSettings>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ProgressBarTemplateSettings[] = {
        { "_assign_array_", _assign_array_ProgressBarTemplateSettings, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ProgressBarTemplateSettings), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_ProgressBarTemplateSettings[] = {
        { "clip_rect", reinterpret_cast<getter>(ProgressBarTemplateSettings_get_ClipRect), nullptr, nullptr, nullptr },
        { "container2_animation_end_position", reinterpret_cast<getter>(ProgressBarTemplateSettings_get_Container2AnimationEndPosition), nullptr, nullptr, nullptr },
        { "container2_animation_start_position", reinterpret_cast<getter>(ProgressBarTemplateSettings_get_Container2AnimationStartPosition), nullptr, nullptr, nullptr },
        { "container_animation_end_position", reinterpret_cast<getter>(ProgressBarTemplateSettings_get_ContainerAnimationEndPosition), nullptr, nullptr, nullptr },
        { "container_animation_mid_position", reinterpret_cast<getter>(ProgressBarTemplateSettings_get_ContainerAnimationMidPosition), nullptr, nullptr, nullptr },
        { "container_animation_start_position", reinterpret_cast<getter>(ProgressBarTemplateSettings_get_ContainerAnimationStartPosition), nullptr, nullptr, nullptr },
        { "ellipse_animation_end_position", reinterpret_cast<getter>(ProgressBarTemplateSettings_get_EllipseAnimationEndPosition), nullptr, nullptr, nullptr },
        { "ellipse_animation_well_position", reinterpret_cast<getter>(ProgressBarTemplateSettings_get_EllipseAnimationWellPosition), nullptr, nullptr, nullptr },
        { "ellipse_diameter", reinterpret_cast<getter>(ProgressBarTemplateSettings_get_EllipseDiameter), nullptr, nullptr, nullptr },
        { "ellipse_offset", reinterpret_cast<getter>(ProgressBarTemplateSettings_get_EllipseOffset), nullptr, nullptr, nullptr },
        { "indicator_length_delta", reinterpret_cast<getter>(ProgressBarTemplateSettings_get_IndicatorLengthDelta), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_ProgressBarTemplateSettings[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ProgressBarTemplateSettings) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ProgressBarTemplateSettings) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ProgressBarTemplateSettings) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ProgressBarTemplateSettings) },
        { }};

    static PyType_Spec type_spec_ProgressBarTemplateSettings = {
        "winui2._winui2_microsoft_ui_xaml_controls.ProgressBarTemplateSettings",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Controls::ProgressBarTemplateSettings),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ProgressBarTemplateSettings};

    // ----- ProgressRing class --------------------

    struct PyWinrtProgressRing;
    using BasePyWinrtProgressRing = winrt::Microsoft::UI::Xaml::Controls::ProgressRingT<PyWinrtProgressRing, py::IPywinrtObject>;

    struct PyWinrtProgressRing : py::py_obj_ref, BasePyWinrtProgressRing
    {
        PyWinrtProgressRing(PyObject* py_obj) : py::py_obj_ref(py_obj), BasePyWinrtProgressRing() {}

        int32_t __stdcall GetPyObject(PyObject*& obj) override
        {
            obj = py::py_obj_ref::get_py_obj();
            return 0;
        }

        int32_t __stdcall GetComposableInner(winrt::Windows::Foundation::IInspectable& inner) override
        {
            inner = m_inner;
            return winrt::impl::error_ok;
        }

        static void toggle_reference(PyWinrtProgressRing* instance, bool is_last_reference)
        {
            py::py_obj_ref::toggle_reference(instance, is_last_reference);
        }

        int32_t query_interface_tearoff(winrt::guid const& id, void** result) const noexcept override
        {
            return py::py_obj_ref::query_interface_tearoff(id, result);
        }

        std::vector<winrt::guid> get_iids_tearoff() const noexcept override
        {
            return py::py_obj_ref::get_iids_tearoff();
        }
    };

    static PyObject* _new_ProgressRing(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_GET_SIZE(args);

        auto self_type = get_python_type_for<winrt::Microsoft::UI::Xaml::Controls::ProgressRing>();
        if (!self_type)
        {
            return nullptr;
        }

        if (arg_count == 0)
        {
            try
            {
                if (type != self_type)
                {
                    py::pyobj_handle self{type->tp_alloc(type, 0)};
                    if (!self)
                    {
                        return nullptr;
                    }

                    std::construct_at(&reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj, nullptr);

                    auto obj_impl = winrt::make_self<PyWinrtProgressRing>(self.get());

                    auto obj = py::make_py_obj<PyWinrtProgressRing>(obj_impl, type, self.get());
                    if (!obj)
                    {
                        return nullptr;
                    }

                    reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj = std::move(obj);

                    return self.detach();
                }

                winrt::Microsoft::UI::Xaml::Controls::ProgressRing instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ProgressRing(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ProgressRing_get_Value(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ProgressRing", L"Value");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::ProgressRing>().Value();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ProgressRing_put_Value(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ProgressRing", L"Value");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<double>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::ProgressRing>().Value(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ProgressRing_get_Minimum(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ProgressRing", L"Minimum");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::ProgressRing>().Minimum();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ProgressRing_put_Minimum(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ProgressRing", L"Minimum");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<double>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::ProgressRing>().Minimum(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ProgressRing_get_Maximum(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ProgressRing", L"Maximum");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::ProgressRing>().Maximum();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ProgressRing_put_Maximum(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ProgressRing", L"Maximum");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<double>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::ProgressRing>().Maximum(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ProgressRing_get_IsIndeterminate(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ProgressRing", L"IsIndeterminate");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::ProgressRing>().IsIndeterminate();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ProgressRing_put_IsIndeterminate(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ProgressRing", L"IsIndeterminate");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::ProgressRing>().IsIndeterminate(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ProgressRing_get_IsActive(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ProgressRing", L"IsActive");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::ProgressRing>().IsActive();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ProgressRing_put_IsActive(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ProgressRing", L"IsActive");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::ProgressRing>().IsActive(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ProgressRing_get_TemplateSettings(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ProgressRing", L"TemplateSettings");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::ProgressRing>().TemplateSettings();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ProgressRing_get_IsActiveProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ProgressRing", L"IsActiveProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::ProgressRing::IsActiveProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ProgressRing_get_IsIndeterminateProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ProgressRing", L"IsIndeterminateProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::ProgressRing::IsIndeterminateProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ProgressRing_get_MaximumProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ProgressRing", L"MaximumProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::ProgressRing::MaximumProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ProgressRing_get_MinimumProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ProgressRing", L"MinimumProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::ProgressRing::MinimumProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ProgressRing_get_ValueProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ProgressRing", L"ValueProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::ProgressRing::ValueProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ProgressRing(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::ProgressRing>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ProgressRing(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::ProgressRing>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ProgressRing[] = {
        { "_assign_array_", _assign_array_ProgressRing, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ProgressRing), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_ProgressRing[] = {
        { "value", reinterpret_cast<getter>(ProgressRing_get_Value), reinterpret_cast<setter>(ProgressRing_put_Value), nullptr, nullptr },
        { "minimum", reinterpret_cast<getter>(ProgressRing_get_Minimum), reinterpret_cast<setter>(ProgressRing_put_Minimum), nullptr, nullptr },
        { "maximum", reinterpret_cast<getter>(ProgressRing_get_Maximum), reinterpret_cast<setter>(ProgressRing_put_Maximum), nullptr, nullptr },
        { "is_indeterminate", reinterpret_cast<getter>(ProgressRing_get_IsIndeterminate), reinterpret_cast<setter>(ProgressRing_put_IsIndeterminate), nullptr, nullptr },
        { "is_active", reinterpret_cast<getter>(ProgressRing_get_IsActive), reinterpret_cast<setter>(ProgressRing_put_IsActive), nullptr, nullptr },
        { "template_settings", reinterpret_cast<getter>(ProgressRing_get_TemplateSettings), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_ProgressRing[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ProgressRing) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ProgressRing) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ProgressRing) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ProgressRing) },
        { }};

    static PyType_Spec type_spec_ProgressRing = {
        "winui2._winui2_microsoft_ui_xaml_controls.ProgressRing",
        sizeof(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_ProgressRing};

    static PyGetSetDef getset_ProgressRing_Static[] = {
        { "is_active_property", reinterpret_cast<getter>(ProgressRing_get_IsActiveProperty), nullptr, nullptr, nullptr },
        { "is_indeterminate_property", reinterpret_cast<getter>(ProgressRing_get_IsIndeterminateProperty), nullptr, nullptr, nullptr },
        { "maximum_property", reinterpret_cast<getter>(ProgressRing_get_MaximumProperty), nullptr, nullptr, nullptr },
        { "minimum_property", reinterpret_cast<getter>(ProgressRing_get_MinimumProperty), nullptr, nullptr, nullptr },
        { "value_property", reinterpret_cast<getter>(ProgressRing_get_ValueProperty), nullptr, nullptr, nullptr },
        { }};

    static PyMethodDef methods_ProgressRing_Static[] = {
        { }};

    static PyType_Slot type_slots_ProgressRing_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_ProgressRing_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_ProgressRing_Static) },
        { }
    };

    static PyType_Spec type_spec_ProgressRing_Static = {
        "winui2._winui2_microsoft_ui_xaml_controls.ProgressRing_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_ProgressRing_Static};

    // ----- ProgressRingTemplateSettings class --------------------

    static PyObject* _new_ProgressRingTemplateSettings(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Xaml::Controls::ProgressRingTemplateSettings>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Xaml::Controls::ProgressRingTemplateSettings>::type_name);
        return nullptr;
    }

    static void _dealloc_ProgressRingTemplateSettings(py::wrapper::Microsoft::UI::Xaml::Controls::ProgressRingTemplateSettings* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ProgressRingTemplateSettings_get_EllipseDiameter(py::wrapper::Microsoft::UI::Xaml::Controls::ProgressRingTemplateSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ProgressRingTemplateSettings", L"EllipseDiameter");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.EllipseDiameter();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ProgressRingTemplateSettings_get_EllipseOffset(py::wrapper::Microsoft::UI::Xaml::Controls::ProgressRingTemplateSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ProgressRingTemplateSettings", L"EllipseOffset");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.EllipseOffset();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ProgressRingTemplateSettings_get_MaxSideLength(py::wrapper::Microsoft::UI::Xaml::Controls::ProgressRingTemplateSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ProgressRingTemplateSettings", L"MaxSideLength");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.MaxSideLength();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ProgressRingTemplateSettings(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::ProgressRingTemplateSettings>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ProgressRingTemplateSettings(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::ProgressRingTemplateSettings>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ProgressRingTemplateSettings[] = {
        { "_assign_array_", _assign_array_ProgressRingTemplateSettings, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ProgressRingTemplateSettings), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_ProgressRingTemplateSettings[] = {
        { "ellipse_diameter", reinterpret_cast<getter>(ProgressRingTemplateSettings_get_EllipseDiameter), nullptr, nullptr, nullptr },
        { "ellipse_offset", reinterpret_cast<getter>(ProgressRingTemplateSettings_get_EllipseOffset), nullptr, nullptr, nullptr },
        { "max_side_length", reinterpret_cast<getter>(ProgressRingTemplateSettings_get_MaxSideLength), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_ProgressRingTemplateSettings[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ProgressRingTemplateSettings) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ProgressRingTemplateSettings) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ProgressRingTemplateSettings) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ProgressRingTemplateSettings) },
        { }};

    static PyType_Spec type_spec_ProgressRingTemplateSettings = {
        "winui2._winui2_microsoft_ui_xaml_controls.ProgressRingTemplateSettings",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Controls::ProgressRingTemplateSettings),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ProgressRingTemplateSettings};

    // ----- RadioButtons class --------------------

    struct PyWinrtRadioButtons;
    using BasePyWinrtRadioButtons = winrt::Microsoft::UI::Xaml::Controls::RadioButtonsT<PyWinrtRadioButtons, py::IPywinrtObject>;

    struct PyWinrtRadioButtons : py::py_obj_ref, BasePyWinrtRadioButtons
    {
        PyWinrtRadioButtons(PyObject* py_obj) : py::py_obj_ref(py_obj), BasePyWinrtRadioButtons() {}

        int32_t __stdcall GetPyObject(PyObject*& obj) override
        {
            obj = py::py_obj_ref::get_py_obj();
            return 0;
        }

        int32_t __stdcall GetComposableInner(winrt::Windows::Foundation::IInspectable& inner) override
        {
            inner = m_inner;
            return winrt::impl::error_ok;
        }

        static void toggle_reference(PyWinrtRadioButtons* instance, bool is_last_reference)
        {
            py::py_obj_ref::toggle_reference(instance, is_last_reference);
        }

        int32_t query_interface_tearoff(winrt::guid const& id, void** result) const noexcept override
        {
            return py::py_obj_ref::query_interface_tearoff(id, result);
        }

        std::vector<winrt::guid> get_iids_tearoff() const noexcept override
        {
            return py::py_obj_ref::get_iids_tearoff();
        }
    };

    static PyObject* _new_RadioButtons(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_GET_SIZE(args);

        auto self_type = get_python_type_for<winrt::Microsoft::UI::Xaml::Controls::RadioButtons>();
        if (!self_type)
        {
            return nullptr;
        }

        if (arg_count == 0)
        {
            try
            {
                if (type != self_type)
                {
                    py::pyobj_handle self{type->tp_alloc(type, 0)};
                    if (!self)
                    {
                        return nullptr;
                    }

                    std::construct_at(&reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj, nullptr);

                    auto obj_impl = winrt::make_self<PyWinrtRadioButtons>(self.get());

                    auto obj = py::make_py_obj<PyWinrtRadioButtons>(obj_impl, type, self.get());
                    if (!obj)
                    {
                        return nullptr;
                    }

                    reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj = std::move(obj);

                    return self.detach();
                }

                winrt::Microsoft::UI::Xaml::Controls::RadioButtons instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_RadioButtons(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* RadioButtons_ContainerFromIndex(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.RadioButtons", L"ContainerFromIndex", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<int32_t>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::RadioButtons>().ContainerFromIndex(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RadioButtons_get_SelectedItem(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.RadioButtons", L"SelectedItem");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::RadioButtons>().SelectedItem();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int RadioButtons_put_SelectedItem(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.RadioButtons", L"SelectedItem");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::RadioButtons>().SelectedItem(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* RadioButtons_get_SelectedIndex(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.RadioButtons", L"SelectedIndex");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::RadioButtons>().SelectedIndex();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int RadioButtons_put_SelectedIndex(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.RadioButtons", L"SelectedIndex");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<int32_t>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::RadioButtons>().SelectedIndex(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* RadioButtons_get_MaxColumns(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.RadioButtons", L"MaxColumns");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::RadioButtons>().MaxColumns();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int RadioButtons_put_MaxColumns(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.RadioButtons", L"MaxColumns");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<int32_t>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::RadioButtons>().MaxColumns(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* RadioButtons_get_ItemsSource(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.RadioButtons", L"ItemsSource");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::RadioButtons>().ItemsSource();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int RadioButtons_put_ItemsSource(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.RadioButtons", L"ItemsSource");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::RadioButtons>().ItemsSource(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* RadioButtons_get_ItemTemplate(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.RadioButtons", L"ItemTemplate");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::RadioButtons>().ItemTemplate();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int RadioButtons_put_ItemTemplate(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.RadioButtons", L"ItemTemplate");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::RadioButtons>().ItemTemplate(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* RadioButtons_get_HeaderTemplate(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.RadioButtons", L"HeaderTemplate");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::RadioButtons>().HeaderTemplate();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int RadioButtons_put_HeaderTemplate(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.RadioButtons", L"HeaderTemplate");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::DataTemplate>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::RadioButtons>().HeaderTemplate(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* RadioButtons_get_Header(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.RadioButtons", L"Header");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::RadioButtons>().Header();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int RadioButtons_put_Header(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.RadioButtons", L"Header");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::RadioButtons>().Header(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* RadioButtons_get_Items(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.RadioButtons", L"Items");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::RadioButtons>().Items();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RadioButtons_get_HeaderProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.RadioButtons", L"HeaderProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::RadioButtons::HeaderProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RadioButtons_get_HeaderTemplateProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.RadioButtons", L"HeaderTemplateProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::RadioButtons::HeaderTemplateProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RadioButtons_get_ItemTemplateProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.RadioButtons", L"ItemTemplateProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::RadioButtons::ItemTemplateProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RadioButtons_get_ItemsProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.RadioButtons", L"ItemsProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::RadioButtons::ItemsProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RadioButtons_get_ItemsSourceProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.RadioButtons", L"ItemsSourceProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::RadioButtons::ItemsSourceProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RadioButtons_get_MaxColumnsProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.RadioButtons", L"MaxColumnsProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::RadioButtons::MaxColumnsProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RadioButtons_get_SelectedIndexProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.RadioButtons", L"SelectedIndexProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::RadioButtons::SelectedIndexProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RadioButtons_get_SelectedItemProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.RadioButtons", L"SelectedItemProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::RadioButtons::SelectedItemProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RadioButtons_add_SelectionChanged(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.RadioButtons", L"SelectionChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::SelectionChangedEventHandler>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::RadioButtons>().SelectionChanged(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RadioButtons_remove_SelectionChanged(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.RadioButtons", L"SelectionChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::RadioButtons>().SelectionChanged(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_RadioButtons(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::RadioButtons>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_RadioButtons(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::RadioButtons>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_RadioButtons[] = {
        { "container_from_index", reinterpret_cast<PyCFunction>(RadioButtons_ContainerFromIndex), METH_VARARGS, nullptr },
        { "add_selection_changed", reinterpret_cast<PyCFunction>(RadioButtons_add_SelectionChanged), METH_O, nullptr },
        { "remove_selection_changed", reinterpret_cast<PyCFunction>(RadioButtons_remove_SelectionChanged), METH_O, nullptr },
        { "_assign_array_", _assign_array_RadioButtons, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_RadioButtons), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_RadioButtons[] = {
        { "selected_item", reinterpret_cast<getter>(RadioButtons_get_SelectedItem), reinterpret_cast<setter>(RadioButtons_put_SelectedItem), nullptr, nullptr },
        { "selected_index", reinterpret_cast<getter>(RadioButtons_get_SelectedIndex), reinterpret_cast<setter>(RadioButtons_put_SelectedIndex), nullptr, nullptr },
        { "max_columns", reinterpret_cast<getter>(RadioButtons_get_MaxColumns), reinterpret_cast<setter>(RadioButtons_put_MaxColumns), nullptr, nullptr },
        { "items_source", reinterpret_cast<getter>(RadioButtons_get_ItemsSource), reinterpret_cast<setter>(RadioButtons_put_ItemsSource), nullptr, nullptr },
        { "item_template", reinterpret_cast<getter>(RadioButtons_get_ItemTemplate), reinterpret_cast<setter>(RadioButtons_put_ItemTemplate), nullptr, nullptr },
        { "header_template", reinterpret_cast<getter>(RadioButtons_get_HeaderTemplate), reinterpret_cast<setter>(RadioButtons_put_HeaderTemplate), nullptr, nullptr },
        { "header", reinterpret_cast<getter>(RadioButtons_get_Header), reinterpret_cast<setter>(RadioButtons_put_Header), nullptr, nullptr },
        { "items", reinterpret_cast<getter>(RadioButtons_get_Items), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_RadioButtons[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_RadioButtons) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_RadioButtons) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_RadioButtons) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_RadioButtons) },
        { }};

    static PyType_Spec type_spec_RadioButtons = {
        "winui2._winui2_microsoft_ui_xaml_controls.RadioButtons",
        sizeof(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_RadioButtons};

    static PyGetSetDef getset_RadioButtons_Static[] = {
        { "header_property", reinterpret_cast<getter>(RadioButtons_get_HeaderProperty), nullptr, nullptr, nullptr },
        { "header_template_property", reinterpret_cast<getter>(RadioButtons_get_HeaderTemplateProperty), nullptr, nullptr, nullptr },
        { "item_template_property", reinterpret_cast<getter>(RadioButtons_get_ItemTemplateProperty), nullptr, nullptr, nullptr },
        { "items_property", reinterpret_cast<getter>(RadioButtons_get_ItemsProperty), nullptr, nullptr, nullptr },
        { "items_source_property", reinterpret_cast<getter>(RadioButtons_get_ItemsSourceProperty), nullptr, nullptr, nullptr },
        { "max_columns_property", reinterpret_cast<getter>(RadioButtons_get_MaxColumnsProperty), nullptr, nullptr, nullptr },
        { "selected_index_property", reinterpret_cast<getter>(RadioButtons_get_SelectedIndexProperty), nullptr, nullptr, nullptr },
        { "selected_item_property", reinterpret_cast<getter>(RadioButtons_get_SelectedItemProperty), nullptr, nullptr, nullptr },
        { }};

    static PyMethodDef methods_RadioButtons_Static[] = {
        { }};

    static PyType_Slot type_slots_RadioButtons_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_RadioButtons_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_RadioButtons_Static) },
        { }
    };

    static PyType_Spec type_spec_RadioButtons_Static = {
        "winui2._winui2_microsoft_ui_xaml_controls.RadioButtons_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_RadioButtons_Static};

    // ----- RadioMenuFlyoutItem class --------------------

    struct PyWinrtRadioMenuFlyoutItem;
    using BasePyWinrtRadioMenuFlyoutItem = winrt::Microsoft::UI::Xaml::Controls::RadioMenuFlyoutItemT<PyWinrtRadioMenuFlyoutItem, py::IPywinrtObject>;

    struct PyWinrtRadioMenuFlyoutItem : py::py_obj_ref, BasePyWinrtRadioMenuFlyoutItem
    {
        PyWinrtRadioMenuFlyoutItem(PyObject* py_obj) : py::py_obj_ref(py_obj), BasePyWinrtRadioMenuFlyoutItem() {}

        int32_t __stdcall GetPyObject(PyObject*& obj) override
        {
            obj = py::py_obj_ref::get_py_obj();
            return 0;
        }

        int32_t __stdcall GetComposableInner(winrt::Windows::Foundation::IInspectable& inner) override
        {
            inner = m_inner;
            return winrt::impl::error_ok;
        }

        static void toggle_reference(PyWinrtRadioMenuFlyoutItem* instance, bool is_last_reference)
        {
            py::py_obj_ref::toggle_reference(instance, is_last_reference);
        }

        int32_t query_interface_tearoff(winrt::guid const& id, void** result) const noexcept override
        {
            return py::py_obj_ref::query_interface_tearoff(id, result);
        }

        std::vector<winrt::guid> get_iids_tearoff() const noexcept override
        {
            return py::py_obj_ref::get_iids_tearoff();
        }
    };

    static PyObject* _new_RadioMenuFlyoutItem(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_GET_SIZE(args);

        auto self_type = get_python_type_for<winrt::Microsoft::UI::Xaml::Controls::RadioMenuFlyoutItem>();
        if (!self_type)
        {
            return nullptr;
        }

        if (arg_count == 0)
        {
            try
            {
                if (type != self_type)
                {
                    py::pyobj_handle self{type->tp_alloc(type, 0)};
                    if (!self)
                    {
                        return nullptr;
                    }

                    std::construct_at(&reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj, nullptr);

                    auto obj_impl = winrt::make_self<PyWinrtRadioMenuFlyoutItem>(self.get());

                    auto obj = py::make_py_obj<PyWinrtRadioMenuFlyoutItem>(obj_impl, type, self.get());
                    if (!obj)
                    {
                        return nullptr;
                    }

                    reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj = std::move(obj);

                    return self.detach();
                }

                winrt::Microsoft::UI::Xaml::Controls::RadioMenuFlyoutItem instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_RadioMenuFlyoutItem(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* RadioMenuFlyoutItem_GetAreCheckStatesEnabled(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.RadioMenuFlyoutItem", L"GetAreCheckStatesEnabled", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::MenuFlyoutSubItem>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Microsoft::UI::Xaml::Controls::RadioMenuFlyoutItem::GetAreCheckStatesEnabled(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RadioMenuFlyoutItem_SetAreCheckStatesEnabled(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.RadioMenuFlyoutItem", L"SetAreCheckStatesEnabled", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::MenuFlyoutSubItem>(args, 0);
                auto param1 = py::convert_to<bool>(args, 1);

                {
                    auto _gil = release_gil();
                    winrt::Microsoft::UI::Xaml::Controls::RadioMenuFlyoutItem::SetAreCheckStatesEnabled(param0, param1);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RadioMenuFlyoutItem_get_IsChecked(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.RadioMenuFlyoutItem", L"IsChecked");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::RadioMenuFlyoutItem>().IsChecked();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int RadioMenuFlyoutItem_put_IsChecked(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.RadioMenuFlyoutItem", L"IsChecked");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::RadioMenuFlyoutItem>().IsChecked(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* RadioMenuFlyoutItem_get_GroupName(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.RadioMenuFlyoutItem", L"GroupName");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::RadioMenuFlyoutItem>().GroupName();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int RadioMenuFlyoutItem_put_GroupName(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.RadioMenuFlyoutItem", L"GroupName");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::RadioMenuFlyoutItem>().GroupName(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* RadioMenuFlyoutItem_get_GroupNameProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.RadioMenuFlyoutItem", L"GroupNameProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::RadioMenuFlyoutItem::GroupNameProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RadioMenuFlyoutItem_get_IsCheckedProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.RadioMenuFlyoutItem", L"IsCheckedProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::RadioMenuFlyoutItem::IsCheckedProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RadioMenuFlyoutItem_get_AreCheckStatesEnabledProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.RadioMenuFlyoutItem", L"AreCheckStatesEnabledProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::RadioMenuFlyoutItem::AreCheckStatesEnabledProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_RadioMenuFlyoutItem(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::RadioMenuFlyoutItem>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_RadioMenuFlyoutItem(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::RadioMenuFlyoutItem>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_RadioMenuFlyoutItem[] = {
        { "_assign_array_", _assign_array_RadioMenuFlyoutItem, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_RadioMenuFlyoutItem), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_RadioMenuFlyoutItem[] = {
        { "is_checked", reinterpret_cast<getter>(RadioMenuFlyoutItem_get_IsChecked), reinterpret_cast<setter>(RadioMenuFlyoutItem_put_IsChecked), nullptr, nullptr },
        { "group_name", reinterpret_cast<getter>(RadioMenuFlyoutItem_get_GroupName), reinterpret_cast<setter>(RadioMenuFlyoutItem_put_GroupName), nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_RadioMenuFlyoutItem[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_RadioMenuFlyoutItem) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_RadioMenuFlyoutItem) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_RadioMenuFlyoutItem) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_RadioMenuFlyoutItem) },
        { }};

    static PyType_Spec type_spec_RadioMenuFlyoutItem = {
        "winui2._winui2_microsoft_ui_xaml_controls.RadioMenuFlyoutItem",
        sizeof(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_RadioMenuFlyoutItem};

    static PyGetSetDef getset_RadioMenuFlyoutItem_Static[] = {
        { "group_name_property", reinterpret_cast<getter>(RadioMenuFlyoutItem_get_GroupNameProperty), nullptr, nullptr, nullptr },
        { "is_checked_property", reinterpret_cast<getter>(RadioMenuFlyoutItem_get_IsCheckedProperty), nullptr, nullptr, nullptr },
        { "are_check_states_enabled_property", reinterpret_cast<getter>(RadioMenuFlyoutItem_get_AreCheckStatesEnabledProperty), nullptr, nullptr, nullptr },
        { }};

    static PyMethodDef methods_RadioMenuFlyoutItem_Static[] = {
        { "get_are_check_states_enabled", reinterpret_cast<PyCFunction>(RadioMenuFlyoutItem_GetAreCheckStatesEnabled), METH_VARARGS, nullptr },
        { "set_are_check_states_enabled", reinterpret_cast<PyCFunction>(RadioMenuFlyoutItem_SetAreCheckStatesEnabled), METH_VARARGS, nullptr },
        { }};

    static PyType_Slot type_slots_RadioMenuFlyoutItem_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_RadioMenuFlyoutItem_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_RadioMenuFlyoutItem_Static) },
        { }
    };

    static PyType_Spec type_spec_RadioMenuFlyoutItem_Static = {
        "winui2._winui2_microsoft_ui_xaml_controls.RadioMenuFlyoutItem_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_RadioMenuFlyoutItem_Static};

    // ----- RatingControl class --------------------

    struct PyWinrtRatingControl;
    using BasePyWinrtRatingControl = winrt::Microsoft::UI::Xaml::Controls::RatingControlT<PyWinrtRatingControl, py::IPywinrtObject>;

    struct PyWinrtRatingControl : py::py_obj_ref, BasePyWinrtRatingControl
    {
        PyWinrtRatingControl(PyObject* py_obj) : py::py_obj_ref(py_obj), BasePyWinrtRatingControl() {}

        int32_t __stdcall GetPyObject(PyObject*& obj) override
        {
            obj = py::py_obj_ref::get_py_obj();
            return 0;
        }

        int32_t __stdcall GetComposableInner(winrt::Windows::Foundation::IInspectable& inner) override
        {
            inner = m_inner;
            return winrt::impl::error_ok;
        }

        static void toggle_reference(PyWinrtRatingControl* instance, bool is_last_reference)
        {
            py::py_obj_ref::toggle_reference(instance, is_last_reference);
        }

        int32_t query_interface_tearoff(winrt::guid const& id, void** result) const noexcept override
        {
            return py::py_obj_ref::query_interface_tearoff(id, result);
        }

        std::vector<winrt::guid> get_iids_tearoff() const noexcept override
        {
            return py::py_obj_ref::get_iids_tearoff();
        }
    };

    static PyObject* _new_RatingControl(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_GET_SIZE(args);

        auto self_type = get_python_type_for<winrt::Microsoft::UI::Xaml::Controls::RatingControl>();
        if (!self_type)
        {
            return nullptr;
        }

        if (arg_count == 0)
        {
            try
            {
                if (type != self_type)
                {
                    py::pyobj_handle self{type->tp_alloc(type, 0)};
                    if (!self)
                    {
                        return nullptr;
                    }

                    std::construct_at(&reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj, nullptr);

                    auto obj_impl = winrt::make_self<PyWinrtRatingControl>(self.get());

                    auto obj = py::make_py_obj<PyWinrtRatingControl>(obj_impl, type, self.get());
                    if (!obj)
                    {
                        return nullptr;
                    }

                    reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj = std::move(obj);

                    return self.detach();
                }

                winrt::Microsoft::UI::Xaml::Controls::RatingControl instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_RatingControl(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* RatingControl_get_Value(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.RatingControl", L"Value");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::RatingControl>().Value();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int RatingControl_put_Value(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.RatingControl", L"Value");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<double>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::RatingControl>().Value(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* RatingControl_get_PlaceholderValue(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.RatingControl", L"PlaceholderValue");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::RatingControl>().PlaceholderValue();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int RatingControl_put_PlaceholderValue(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.RatingControl", L"PlaceholderValue");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<double>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::RatingControl>().PlaceholderValue(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* RatingControl_get_MaxRating(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.RatingControl", L"MaxRating");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::RatingControl>().MaxRating();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int RatingControl_put_MaxRating(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.RatingControl", L"MaxRating");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<int32_t>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::RatingControl>().MaxRating(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* RatingControl_get_ItemInfo(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.RatingControl", L"ItemInfo");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::RatingControl>().ItemInfo();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int RatingControl_put_ItemInfo(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.RatingControl", L"ItemInfo");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::RatingItemInfo>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::RatingControl>().ItemInfo(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* RatingControl_get_IsReadOnly(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.RatingControl", L"IsReadOnly");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::RatingControl>().IsReadOnly();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int RatingControl_put_IsReadOnly(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.RatingControl", L"IsReadOnly");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::RatingControl>().IsReadOnly(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* RatingControl_get_IsClearEnabled(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.RatingControl", L"IsClearEnabled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::RatingControl>().IsClearEnabled();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int RatingControl_put_IsClearEnabled(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.RatingControl", L"IsClearEnabled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::RatingControl>().IsClearEnabled(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* RatingControl_get_InitialSetValue(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.RatingControl", L"InitialSetValue");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::RatingControl>().InitialSetValue();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int RatingControl_put_InitialSetValue(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.RatingControl", L"InitialSetValue");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<int32_t>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::RatingControl>().InitialSetValue(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* RatingControl_get_Caption(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.RatingControl", L"Caption");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::RatingControl>().Caption();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int RatingControl_put_Caption(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.RatingControl", L"Caption");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::RatingControl>().Caption(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* RatingControl_get_CaptionProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.RatingControl", L"CaptionProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::RatingControl::CaptionProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RatingControl_get_InitialSetValueProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.RatingControl", L"InitialSetValueProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::RatingControl::InitialSetValueProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RatingControl_get_IsClearEnabledProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.RatingControl", L"IsClearEnabledProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::RatingControl::IsClearEnabledProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RatingControl_get_IsReadOnlyProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.RatingControl", L"IsReadOnlyProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::RatingControl::IsReadOnlyProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RatingControl_get_ItemInfoProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.RatingControl", L"ItemInfoProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::RatingControl::ItemInfoProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RatingControl_get_MaxRatingProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.RatingControl", L"MaxRatingProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::RatingControl::MaxRatingProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RatingControl_get_PlaceholderValueProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.RatingControl", L"PlaceholderValueProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::RatingControl::PlaceholderValueProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RatingControl_get_ValueProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.RatingControl", L"ValueProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::RatingControl::ValueProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RatingControl_add_ValueChanged(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.RatingControl", L"ValueChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Xaml::Controls::RatingControl, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::RatingControl>().ValueChanged(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RatingControl_remove_ValueChanged(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.RatingControl", L"ValueChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::RatingControl>().ValueChanged(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_RatingControl(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::RatingControl>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_RatingControl(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::RatingControl>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_RatingControl[] = {
        { "add_value_changed", reinterpret_cast<PyCFunction>(RatingControl_add_ValueChanged), METH_O, nullptr },
        { "remove_value_changed", reinterpret_cast<PyCFunction>(RatingControl_remove_ValueChanged), METH_O, nullptr },
        { "_assign_array_", _assign_array_RatingControl, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_RatingControl), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_RatingControl[] = {
        { "value", reinterpret_cast<getter>(RatingControl_get_Value), reinterpret_cast<setter>(RatingControl_put_Value), nullptr, nullptr },
        { "placeholder_value", reinterpret_cast<getter>(RatingControl_get_PlaceholderValue), reinterpret_cast<setter>(RatingControl_put_PlaceholderValue), nullptr, nullptr },
        { "max_rating", reinterpret_cast<getter>(RatingControl_get_MaxRating), reinterpret_cast<setter>(RatingControl_put_MaxRating), nullptr, nullptr },
        { "item_info", reinterpret_cast<getter>(RatingControl_get_ItemInfo), reinterpret_cast<setter>(RatingControl_put_ItemInfo), nullptr, nullptr },
        { "is_read_only", reinterpret_cast<getter>(RatingControl_get_IsReadOnly), reinterpret_cast<setter>(RatingControl_put_IsReadOnly), nullptr, nullptr },
        { "is_clear_enabled", reinterpret_cast<getter>(RatingControl_get_IsClearEnabled), reinterpret_cast<setter>(RatingControl_put_IsClearEnabled), nullptr, nullptr },
        { "initial_set_value", reinterpret_cast<getter>(RatingControl_get_InitialSetValue), reinterpret_cast<setter>(RatingControl_put_InitialSetValue), nullptr, nullptr },
        { "caption", reinterpret_cast<getter>(RatingControl_get_Caption), reinterpret_cast<setter>(RatingControl_put_Caption), nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_RatingControl[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_RatingControl) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_RatingControl) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_RatingControl) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_RatingControl) },
        { }};

    static PyType_Spec type_spec_RatingControl = {
        "winui2._winui2_microsoft_ui_xaml_controls.RatingControl",
        sizeof(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_RatingControl};

    static PyGetSetDef getset_RatingControl_Static[] = {
        { "caption_property", reinterpret_cast<getter>(RatingControl_get_CaptionProperty), nullptr, nullptr, nullptr },
        { "initial_set_value_property", reinterpret_cast<getter>(RatingControl_get_InitialSetValueProperty), nullptr, nullptr, nullptr },
        { "is_clear_enabled_property", reinterpret_cast<getter>(RatingControl_get_IsClearEnabledProperty), nullptr, nullptr, nullptr },
        { "is_read_only_property", reinterpret_cast<getter>(RatingControl_get_IsReadOnlyProperty), nullptr, nullptr, nullptr },
        { "item_info_property", reinterpret_cast<getter>(RatingControl_get_ItemInfoProperty), nullptr, nullptr, nullptr },
        { "max_rating_property", reinterpret_cast<getter>(RatingControl_get_MaxRatingProperty), nullptr, nullptr, nullptr },
        { "placeholder_value_property", reinterpret_cast<getter>(RatingControl_get_PlaceholderValueProperty), nullptr, nullptr, nullptr },
        { "value_property", reinterpret_cast<getter>(RatingControl_get_ValueProperty), nullptr, nullptr, nullptr },
        { }};

    static PyMethodDef methods_RatingControl_Static[] = {
        { }};

    static PyType_Slot type_slots_RatingControl_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_RatingControl_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_RatingControl_Static) },
        { }
    };

    static PyType_Spec type_spec_RatingControl_Static = {
        "winui2._winui2_microsoft_ui_xaml_controls.RatingControl_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_RatingControl_Static};

    // ----- RatingItemFontInfo class --------------------

    struct PyWinrtRatingItemFontInfo;
    using BasePyWinrtRatingItemFontInfo = winrt::Microsoft::UI::Xaml::Controls::RatingItemFontInfoT<PyWinrtRatingItemFontInfo, py::IPywinrtObject>;

    struct PyWinrtRatingItemFontInfo : py::py_obj_ref, BasePyWinrtRatingItemFontInfo
    {
        PyWinrtRatingItemFontInfo(PyObject* py_obj) : py::py_obj_ref(py_obj), BasePyWinrtRatingItemFontInfo() {}

        int32_t __stdcall GetPyObject(PyObject*& obj) override
        {
            obj = py::py_obj_ref::get_py_obj();
            return 0;
        }

        int32_t __stdcall GetComposableInner(winrt::Windows::Foundation::IInspectable& inner) override
        {
            inner = m_inner;
            return winrt::impl::error_ok;
        }

        static void toggle_reference(PyWinrtRatingItemFontInfo* instance, bool is_last_reference)
        {
            py::py_obj_ref::toggle_reference(instance, is_last_reference);
        }

        int32_t query_interface_tearoff(winrt::guid const& id, void** result) const noexcept override
        {
            return py::py_obj_ref::query_interface_tearoff(id, result);
        }

        std::vector<winrt::guid> get_iids_tearoff() const noexcept override
        {
            return py::py_obj_ref::get_iids_tearoff();
        }
    };

    static PyObject* _new_RatingItemFontInfo(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_GET_SIZE(args);

        auto self_type = get_python_type_for<winrt::Microsoft::UI::Xaml::Controls::RatingItemFontInfo>();
        if (!self_type)
        {
            return nullptr;
        }

        if (arg_count == 0)
        {
            try
            {
                if (type != self_type)
                {
                    py::pyobj_handle self{type->tp_alloc(type, 0)};
                    if (!self)
                    {
                        return nullptr;
                    }

                    std::construct_at(&reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj, nullptr);

                    auto obj_impl = winrt::make_self<PyWinrtRatingItemFontInfo>(self.get());

                    auto obj = py::make_py_obj<PyWinrtRatingItemFontInfo>(obj_impl, type, self.get());
                    if (!obj)
                    {
                        return nullptr;
                    }

                    reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj = std::move(obj);

                    return self.detach();
                }

                winrt::Microsoft::UI::Xaml::Controls::RatingItemFontInfo instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_RatingItemFontInfo(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* RatingItemFontInfo_get_UnsetGlyph(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.RatingItemFontInfo", L"UnsetGlyph");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::RatingItemFontInfo>().UnsetGlyph();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int RatingItemFontInfo_put_UnsetGlyph(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.RatingItemFontInfo", L"UnsetGlyph");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::RatingItemFontInfo>().UnsetGlyph(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* RatingItemFontInfo_get_PointerOverPlaceholderGlyph(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.RatingItemFontInfo", L"PointerOverPlaceholderGlyph");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::RatingItemFontInfo>().PointerOverPlaceholderGlyph();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int RatingItemFontInfo_put_PointerOverPlaceholderGlyph(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.RatingItemFontInfo", L"PointerOverPlaceholderGlyph");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::RatingItemFontInfo>().PointerOverPlaceholderGlyph(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* RatingItemFontInfo_get_PointerOverGlyph(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.RatingItemFontInfo", L"PointerOverGlyph");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::RatingItemFontInfo>().PointerOverGlyph();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int RatingItemFontInfo_put_PointerOverGlyph(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.RatingItemFontInfo", L"PointerOverGlyph");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::RatingItemFontInfo>().PointerOverGlyph(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* RatingItemFontInfo_get_PlaceholderGlyph(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.RatingItemFontInfo", L"PlaceholderGlyph");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::RatingItemFontInfo>().PlaceholderGlyph();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int RatingItemFontInfo_put_PlaceholderGlyph(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.RatingItemFontInfo", L"PlaceholderGlyph");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::RatingItemFontInfo>().PlaceholderGlyph(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* RatingItemFontInfo_get_Glyph(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.RatingItemFontInfo", L"Glyph");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::RatingItemFontInfo>().Glyph();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int RatingItemFontInfo_put_Glyph(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.RatingItemFontInfo", L"Glyph");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::RatingItemFontInfo>().Glyph(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* RatingItemFontInfo_get_DisabledGlyph(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.RatingItemFontInfo", L"DisabledGlyph");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::RatingItemFontInfo>().DisabledGlyph();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int RatingItemFontInfo_put_DisabledGlyph(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.RatingItemFontInfo", L"DisabledGlyph");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::RatingItemFontInfo>().DisabledGlyph(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* RatingItemFontInfo_get_DisabledGlyphProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.RatingItemFontInfo", L"DisabledGlyphProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::RatingItemFontInfo::DisabledGlyphProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RatingItemFontInfo_get_GlyphProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.RatingItemFontInfo", L"GlyphProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::RatingItemFontInfo::GlyphProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RatingItemFontInfo_get_PlaceholderGlyphProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.RatingItemFontInfo", L"PlaceholderGlyphProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::RatingItemFontInfo::PlaceholderGlyphProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RatingItemFontInfo_get_PointerOverGlyphProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.RatingItemFontInfo", L"PointerOverGlyphProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::RatingItemFontInfo::PointerOverGlyphProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RatingItemFontInfo_get_PointerOverPlaceholderGlyphProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.RatingItemFontInfo", L"PointerOverPlaceholderGlyphProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::RatingItemFontInfo::PointerOverPlaceholderGlyphProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RatingItemFontInfo_get_UnsetGlyphProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.RatingItemFontInfo", L"UnsetGlyphProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::RatingItemFontInfo::UnsetGlyphProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_RatingItemFontInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::RatingItemFontInfo>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_RatingItemFontInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::RatingItemFontInfo>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_RatingItemFontInfo[] = {
        { "_assign_array_", _assign_array_RatingItemFontInfo, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_RatingItemFontInfo), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_RatingItemFontInfo[] = {
        { "unset_glyph", reinterpret_cast<getter>(RatingItemFontInfo_get_UnsetGlyph), reinterpret_cast<setter>(RatingItemFontInfo_put_UnsetGlyph), nullptr, nullptr },
        { "pointer_over_placeholder_glyph", reinterpret_cast<getter>(RatingItemFontInfo_get_PointerOverPlaceholderGlyph), reinterpret_cast<setter>(RatingItemFontInfo_put_PointerOverPlaceholderGlyph), nullptr, nullptr },
        { "pointer_over_glyph", reinterpret_cast<getter>(RatingItemFontInfo_get_PointerOverGlyph), reinterpret_cast<setter>(RatingItemFontInfo_put_PointerOverGlyph), nullptr, nullptr },
        { "placeholder_glyph", reinterpret_cast<getter>(RatingItemFontInfo_get_PlaceholderGlyph), reinterpret_cast<setter>(RatingItemFontInfo_put_PlaceholderGlyph), nullptr, nullptr },
        { "glyph", reinterpret_cast<getter>(RatingItemFontInfo_get_Glyph), reinterpret_cast<setter>(RatingItemFontInfo_put_Glyph), nullptr, nullptr },
        { "disabled_glyph", reinterpret_cast<getter>(RatingItemFontInfo_get_DisabledGlyph), reinterpret_cast<setter>(RatingItemFontInfo_put_DisabledGlyph), nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_RatingItemFontInfo[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_RatingItemFontInfo) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_RatingItemFontInfo) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_RatingItemFontInfo) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_RatingItemFontInfo) },
        { }};

    static PyType_Spec type_spec_RatingItemFontInfo = {
        "winui2._winui2_microsoft_ui_xaml_controls.RatingItemFontInfo",
        sizeof(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_RatingItemFontInfo};

    static PyGetSetDef getset_RatingItemFontInfo_Static[] = {
        { "disabled_glyph_property", reinterpret_cast<getter>(RatingItemFontInfo_get_DisabledGlyphProperty), nullptr, nullptr, nullptr },
        { "glyph_property", reinterpret_cast<getter>(RatingItemFontInfo_get_GlyphProperty), nullptr, nullptr, nullptr },
        { "placeholder_glyph_property", reinterpret_cast<getter>(RatingItemFontInfo_get_PlaceholderGlyphProperty), nullptr, nullptr, nullptr },
        { "pointer_over_glyph_property", reinterpret_cast<getter>(RatingItemFontInfo_get_PointerOverGlyphProperty), nullptr, nullptr, nullptr },
        { "pointer_over_placeholder_glyph_property", reinterpret_cast<getter>(RatingItemFontInfo_get_PointerOverPlaceholderGlyphProperty), nullptr, nullptr, nullptr },
        { "unset_glyph_property", reinterpret_cast<getter>(RatingItemFontInfo_get_UnsetGlyphProperty), nullptr, nullptr, nullptr },
        { }};

    static PyMethodDef methods_RatingItemFontInfo_Static[] = {
        { }};

    static PyType_Slot type_slots_RatingItemFontInfo_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_RatingItemFontInfo_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_RatingItemFontInfo_Static) },
        { }
    };

    static PyType_Spec type_spec_RatingItemFontInfo_Static = {
        "winui2._winui2_microsoft_ui_xaml_controls.RatingItemFontInfo_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_RatingItemFontInfo_Static};

    // ----- RatingItemImageInfo class --------------------

    struct PyWinrtRatingItemImageInfo;
    using BasePyWinrtRatingItemImageInfo = winrt::Microsoft::UI::Xaml::Controls::RatingItemImageInfoT<PyWinrtRatingItemImageInfo, py::IPywinrtObject>;

    struct PyWinrtRatingItemImageInfo : py::py_obj_ref, BasePyWinrtRatingItemImageInfo
    {
        PyWinrtRatingItemImageInfo(PyObject* py_obj) : py::py_obj_ref(py_obj), BasePyWinrtRatingItemImageInfo() {}

        int32_t __stdcall GetPyObject(PyObject*& obj) override
        {
            obj = py::py_obj_ref::get_py_obj();
            return 0;
        }

        int32_t __stdcall GetComposableInner(winrt::Windows::Foundation::IInspectable& inner) override
        {
            inner = m_inner;
            return winrt::impl::error_ok;
        }

        static void toggle_reference(PyWinrtRatingItemImageInfo* instance, bool is_last_reference)
        {
            py::py_obj_ref::toggle_reference(instance, is_last_reference);
        }

        int32_t query_interface_tearoff(winrt::guid const& id, void** result) const noexcept override
        {
            return py::py_obj_ref::query_interface_tearoff(id, result);
        }

        std::vector<winrt::guid> get_iids_tearoff() const noexcept override
        {
            return py::py_obj_ref::get_iids_tearoff();
        }
    };

    static PyObject* _new_RatingItemImageInfo(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_GET_SIZE(args);

        auto self_type = get_python_type_for<winrt::Microsoft::UI::Xaml::Controls::RatingItemImageInfo>();
        if (!self_type)
        {
            return nullptr;
        }

        if (arg_count == 0)
        {
            try
            {
                if (type != self_type)
                {
                    py::pyobj_handle self{type->tp_alloc(type, 0)};
                    if (!self)
                    {
                        return nullptr;
                    }

                    std::construct_at(&reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj, nullptr);

                    auto obj_impl = winrt::make_self<PyWinrtRatingItemImageInfo>(self.get());

                    auto obj = py::make_py_obj<PyWinrtRatingItemImageInfo>(obj_impl, type, self.get());
                    if (!obj)
                    {
                        return nullptr;
                    }

                    reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj = std::move(obj);

                    return self.detach();
                }

                winrt::Microsoft::UI::Xaml::Controls::RatingItemImageInfo instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_RatingItemImageInfo(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* RatingItemImageInfo_get_UnsetImage(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.RatingItemImageInfo", L"UnsetImage");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::RatingItemImageInfo>().UnsetImage();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int RatingItemImageInfo_put_UnsetImage(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.RatingItemImageInfo", L"UnsetImage");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Media::ImageSource>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::RatingItemImageInfo>().UnsetImage(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* RatingItemImageInfo_get_PointerOverPlaceholderImage(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.RatingItemImageInfo", L"PointerOverPlaceholderImage");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::RatingItemImageInfo>().PointerOverPlaceholderImage();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int RatingItemImageInfo_put_PointerOverPlaceholderImage(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.RatingItemImageInfo", L"PointerOverPlaceholderImage");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Media::ImageSource>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::RatingItemImageInfo>().PointerOverPlaceholderImage(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* RatingItemImageInfo_get_PointerOverImage(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.RatingItemImageInfo", L"PointerOverImage");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::RatingItemImageInfo>().PointerOverImage();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int RatingItemImageInfo_put_PointerOverImage(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.RatingItemImageInfo", L"PointerOverImage");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Media::ImageSource>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::RatingItemImageInfo>().PointerOverImage(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* RatingItemImageInfo_get_PlaceholderImage(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.RatingItemImageInfo", L"PlaceholderImage");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::RatingItemImageInfo>().PlaceholderImage();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int RatingItemImageInfo_put_PlaceholderImage(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.RatingItemImageInfo", L"PlaceholderImage");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Media::ImageSource>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::RatingItemImageInfo>().PlaceholderImage(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* RatingItemImageInfo_get_Image(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.RatingItemImageInfo", L"Image");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::RatingItemImageInfo>().Image();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int RatingItemImageInfo_put_Image(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.RatingItemImageInfo", L"Image");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Media::ImageSource>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::RatingItemImageInfo>().Image(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* RatingItemImageInfo_get_DisabledImage(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.RatingItemImageInfo", L"DisabledImage");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::RatingItemImageInfo>().DisabledImage();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int RatingItemImageInfo_put_DisabledImage(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.RatingItemImageInfo", L"DisabledImage");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Media::ImageSource>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::RatingItemImageInfo>().DisabledImage(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* RatingItemImageInfo_get_DisabledImageProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.RatingItemImageInfo", L"DisabledImageProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::RatingItemImageInfo::DisabledImageProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RatingItemImageInfo_get_ImageProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.RatingItemImageInfo", L"ImageProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::RatingItemImageInfo::ImageProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RatingItemImageInfo_get_PlaceholderImageProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.RatingItemImageInfo", L"PlaceholderImageProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::RatingItemImageInfo::PlaceholderImageProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RatingItemImageInfo_get_PointerOverImageProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.RatingItemImageInfo", L"PointerOverImageProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::RatingItemImageInfo::PointerOverImageProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RatingItemImageInfo_get_PointerOverPlaceholderImageProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.RatingItemImageInfo", L"PointerOverPlaceholderImageProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::RatingItemImageInfo::PointerOverPlaceholderImageProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RatingItemImageInfo_get_UnsetImageProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.RatingItemImageInfo", L"UnsetImageProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::RatingItemImageInfo::UnsetImageProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_RatingItemImageInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::RatingItemImageInfo>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_RatingItemImageInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::RatingItemImageInfo>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_RatingItemImageInfo[] = {
        { "_assign_array_", _assign_array_RatingItemImageInfo, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_RatingItemImageInfo), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_RatingItemImageInfo[] = {
        { "unset_image", reinterpret_cast<getter>(RatingItemImageInfo_get_UnsetImage), reinterpret_cast<setter>(RatingItemImageInfo_put_UnsetImage), nullptr, nullptr },
        { "pointer_over_placeholder_image", reinterpret_cast<getter>(RatingItemImageInfo_get_PointerOverPlaceholderImage), reinterpret_cast<setter>(RatingItemImageInfo_put_PointerOverPlaceholderImage), nullptr, nullptr },
        { "pointer_over_image", reinterpret_cast<getter>(RatingItemImageInfo_get_PointerOverImage), reinterpret_cast<setter>(RatingItemImageInfo_put_PointerOverImage), nullptr, nullptr },
        { "placeholder_image", reinterpret_cast<getter>(RatingItemImageInfo_get_PlaceholderImage), reinterpret_cast<setter>(RatingItemImageInfo_put_PlaceholderImage), nullptr, nullptr },
        { "image", reinterpret_cast<getter>(RatingItemImageInfo_get_Image), reinterpret_cast<setter>(RatingItemImageInfo_put_Image), nullptr, nullptr },
        { "disabled_image", reinterpret_cast<getter>(RatingItemImageInfo_get_DisabledImage), reinterpret_cast<setter>(RatingItemImageInfo_put_DisabledImage), nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_RatingItemImageInfo[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_RatingItemImageInfo) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_RatingItemImageInfo) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_RatingItemImageInfo) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_RatingItemImageInfo) },
        { }};

    static PyType_Spec type_spec_RatingItemImageInfo = {
        "winui2._winui2_microsoft_ui_xaml_controls.RatingItemImageInfo",
        sizeof(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_RatingItemImageInfo};

    static PyGetSetDef getset_RatingItemImageInfo_Static[] = {
        { "disabled_image_property", reinterpret_cast<getter>(RatingItemImageInfo_get_DisabledImageProperty), nullptr, nullptr, nullptr },
        { "image_property", reinterpret_cast<getter>(RatingItemImageInfo_get_ImageProperty), nullptr, nullptr, nullptr },
        { "placeholder_image_property", reinterpret_cast<getter>(RatingItemImageInfo_get_PlaceholderImageProperty), nullptr, nullptr, nullptr },
        { "pointer_over_image_property", reinterpret_cast<getter>(RatingItemImageInfo_get_PointerOverImageProperty), nullptr, nullptr, nullptr },
        { "pointer_over_placeholder_image_property", reinterpret_cast<getter>(RatingItemImageInfo_get_PointerOverPlaceholderImageProperty), nullptr, nullptr, nullptr },
        { "unset_image_property", reinterpret_cast<getter>(RatingItemImageInfo_get_UnsetImageProperty), nullptr, nullptr, nullptr },
        { }};

    static PyMethodDef methods_RatingItemImageInfo_Static[] = {
        { }};

    static PyType_Slot type_slots_RatingItemImageInfo_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_RatingItemImageInfo_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_RatingItemImageInfo_Static) },
        { }
    };

    static PyType_Spec type_spec_RatingItemImageInfo_Static = {
        "winui2._winui2_microsoft_ui_xaml_controls.RatingItemImageInfo_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_RatingItemImageInfo_Static};

    // ----- RatingItemInfo class --------------------

    struct PyWinrtRatingItemInfo;
    using BasePyWinrtRatingItemInfo = winrt::Microsoft::UI::Xaml::Controls::RatingItemInfoT<PyWinrtRatingItemInfo, py::IPywinrtObject>;

    struct PyWinrtRatingItemInfo : py::py_obj_ref, BasePyWinrtRatingItemInfo
    {
        PyWinrtRatingItemInfo(PyObject* py_obj) : py::py_obj_ref(py_obj), BasePyWinrtRatingItemInfo() {}

        int32_t __stdcall GetPyObject(PyObject*& obj) override
        {
            obj = py::py_obj_ref::get_py_obj();
            return 0;
        }

        int32_t __stdcall GetComposableInner(winrt::Windows::Foundation::IInspectable& inner) override
        {
            inner = m_inner;
            return winrt::impl::error_ok;
        }

        static void toggle_reference(PyWinrtRatingItemInfo* instance, bool is_last_reference)
        {
            py::py_obj_ref::toggle_reference(instance, is_last_reference);
        }

        int32_t query_interface_tearoff(winrt::guid const& id, void** result) const noexcept override
        {
            return py::py_obj_ref::query_interface_tearoff(id, result);
        }

        std::vector<winrt::guid> get_iids_tearoff() const noexcept override
        {
            return py::py_obj_ref::get_iids_tearoff();
        }
    };

    static PyObject* _new_RatingItemInfo(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_GET_SIZE(args);

        auto self_type = get_python_type_for<winrt::Microsoft::UI::Xaml::Controls::RatingItemInfo>();
        if (!self_type)
        {
            return nullptr;
        }

        if (arg_count == 0)
        {
            try
            {
                if (type != self_type)
                {
                    py::pyobj_handle self{type->tp_alloc(type, 0)};
                    if (!self)
                    {
                        return nullptr;
                    }

                    std::construct_at(&reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj, nullptr);

                    auto obj_impl = winrt::make_self<PyWinrtRatingItemInfo>(self.get());

                    auto obj = py::make_py_obj<PyWinrtRatingItemInfo>(obj_impl, type, self.get());
                    if (!obj)
                    {
                        return nullptr;
                    }

                    reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj = std::move(obj);

                    return self.detach();
                }

                winrt::Microsoft::UI::Xaml::Controls::RatingItemInfo instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_RatingItemInfo(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_RatingItemInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::RatingItemInfo>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_RatingItemInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::RatingItemInfo>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_RatingItemInfo[] = {
        { "_assign_array_", _assign_array_RatingItemInfo, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_RatingItemInfo), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_RatingItemInfo[] = {
        { }};

    static PyType_Slot _type_slots_RatingItemInfo[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_RatingItemInfo) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_RatingItemInfo) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_RatingItemInfo) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_RatingItemInfo) },
        { }};

    static PyType_Spec type_spec_RatingItemInfo = {
        "winui2._winui2_microsoft_ui_xaml_controls.RatingItemInfo",
        sizeof(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_RatingItemInfo};

    static PyGetSetDef getset_RatingItemInfo_Static[] = {
        { }};

    static PyMethodDef methods_RatingItemInfo_Static[] = {
        { }};

    static PyType_Slot type_slots_RatingItemInfo_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_RatingItemInfo_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_RatingItemInfo_Static) },
        { }
    };

    static PyType_Spec type_spec_RatingItemInfo_Static = {
        "winui2._winui2_microsoft_ui_xaml_controls.RatingItemInfo_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_RatingItemInfo_Static};

    // ----- RefreshContainer class --------------------

    struct PyWinrtRefreshContainer;
    using BasePyWinrtRefreshContainer = winrt::Microsoft::UI::Xaml::Controls::RefreshContainerT<PyWinrtRefreshContainer, py::IPywinrtObject>;

    struct PyWinrtRefreshContainer : py::py_obj_ref, BasePyWinrtRefreshContainer
    {
        PyWinrtRefreshContainer(PyObject* py_obj) : py::py_obj_ref(py_obj), BasePyWinrtRefreshContainer() {}

        int32_t __stdcall GetPyObject(PyObject*& obj) override
        {
            obj = py::py_obj_ref::get_py_obj();
            return 0;
        }

        int32_t __stdcall GetComposableInner(winrt::Windows::Foundation::IInspectable& inner) override
        {
            inner = m_inner;
            return winrt::impl::error_ok;
        }

        static void toggle_reference(PyWinrtRefreshContainer* instance, bool is_last_reference)
        {
            py::py_obj_ref::toggle_reference(instance, is_last_reference);
        }

        int32_t query_interface_tearoff(winrt::guid const& id, void** result) const noexcept override
        {
            return py::py_obj_ref::query_interface_tearoff(id, result);
        }

        std::vector<winrt::guid> get_iids_tearoff() const noexcept override
        {
            return py::py_obj_ref::get_iids_tearoff();
        }
    };

    static PyObject* _new_RefreshContainer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_GET_SIZE(args);

        auto self_type = get_python_type_for<winrt::Microsoft::UI::Xaml::Controls::RefreshContainer>();
        if (!self_type)
        {
            return nullptr;
        }

        if (arg_count == 0)
        {
            try
            {
                if (type != self_type)
                {
                    py::pyobj_handle self{type->tp_alloc(type, 0)};
                    if (!self)
                    {
                        return nullptr;
                    }

                    std::construct_at(&reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj, nullptr);

                    auto obj_impl = winrt::make_self<PyWinrtRefreshContainer>(self.get());

                    auto obj = py::make_py_obj<PyWinrtRefreshContainer>(obj_impl, type, self.get());
                    if (!obj)
                    {
                        return nullptr;
                    }

                    reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj = std::move(obj);

                    return self.detach();
                }

                winrt::Microsoft::UI::Xaml::Controls::RefreshContainer instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_RefreshContainer(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* RefreshContainer_RequestRefresh(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.RefreshContainer", L"RequestRefresh", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::RefreshContainer>().RequestRefresh();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RefreshContainer_get_Visualizer(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.RefreshContainer", L"Visualizer");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::RefreshContainer>().Visualizer();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int RefreshContainer_put_Visualizer(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.RefreshContainer", L"Visualizer");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::RefreshVisualizer>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::RefreshContainer>().Visualizer(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* RefreshContainer_get_PullDirection(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.RefreshContainer", L"PullDirection");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::RefreshContainer>().PullDirection();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int RefreshContainer_put_PullDirection(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.RefreshContainer", L"PullDirection");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::RefreshPullDirection>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::RefreshContainer>().PullDirection(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* RefreshContainer_get_PullDirectionProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.RefreshContainer", L"PullDirectionProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::RefreshContainer::PullDirectionProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RefreshContainer_get_VisualizerProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.RefreshContainer", L"VisualizerProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::RefreshContainer::VisualizerProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RefreshContainer_add_RefreshRequested(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.RefreshContainer", L"RefreshRequested");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Xaml::Controls::RefreshContainer, winrt::Microsoft::UI::Xaml::Controls::RefreshRequestedEventArgs>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::RefreshContainer>().RefreshRequested(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RefreshContainer_remove_RefreshRequested(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.RefreshContainer", L"RefreshRequested");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::RefreshContainer>().RefreshRequested(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_RefreshContainer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::RefreshContainer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_RefreshContainer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::RefreshContainer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_RefreshContainer[] = {
        { "request_refresh", reinterpret_cast<PyCFunction>(RefreshContainer_RequestRefresh), METH_VARARGS, nullptr },
        { "add_refresh_requested", reinterpret_cast<PyCFunction>(RefreshContainer_add_RefreshRequested), METH_O, nullptr },
        { "remove_refresh_requested", reinterpret_cast<PyCFunction>(RefreshContainer_remove_RefreshRequested), METH_O, nullptr },
        { "_assign_array_", _assign_array_RefreshContainer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_RefreshContainer), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_RefreshContainer[] = {
        { "visualizer", reinterpret_cast<getter>(RefreshContainer_get_Visualizer), reinterpret_cast<setter>(RefreshContainer_put_Visualizer), nullptr, nullptr },
        { "pull_direction", reinterpret_cast<getter>(RefreshContainer_get_PullDirection), reinterpret_cast<setter>(RefreshContainer_put_PullDirection), nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_RefreshContainer[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_RefreshContainer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_RefreshContainer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_RefreshContainer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_RefreshContainer) },
        { }};

    static PyType_Spec type_spec_RefreshContainer = {
        "winui2._winui2_microsoft_ui_xaml_controls.RefreshContainer",
        sizeof(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_RefreshContainer};

    static PyGetSetDef getset_RefreshContainer_Static[] = {
        { "pull_direction_property", reinterpret_cast<getter>(RefreshContainer_get_PullDirectionProperty), nullptr, nullptr, nullptr },
        { "visualizer_property", reinterpret_cast<getter>(RefreshContainer_get_VisualizerProperty), nullptr, nullptr, nullptr },
        { }};

    static PyMethodDef methods_RefreshContainer_Static[] = {
        { }};

    static PyType_Slot type_slots_RefreshContainer_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_RefreshContainer_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_RefreshContainer_Static) },
        { }
    };

    static PyType_Spec type_spec_RefreshContainer_Static = {
        "winui2._winui2_microsoft_ui_xaml_controls.RefreshContainer_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_RefreshContainer_Static};

    // ----- RefreshInteractionRatioChangedEventArgs class --------------------

    static PyObject* _new_RefreshInteractionRatioChangedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Xaml::Controls::RefreshInteractionRatioChangedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Xaml::Controls::RefreshInteractionRatioChangedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_RefreshInteractionRatioChangedEventArgs(py::wrapper::Microsoft::UI::Xaml::Controls::RefreshInteractionRatioChangedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* RefreshInteractionRatioChangedEventArgs_get_InteractionRatio(py::wrapper::Microsoft::UI::Xaml::Controls::RefreshInteractionRatioChangedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.RefreshInteractionRatioChangedEventArgs", L"InteractionRatio");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.InteractionRatio();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_RefreshInteractionRatioChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::RefreshInteractionRatioChangedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_RefreshInteractionRatioChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::RefreshInteractionRatioChangedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_RefreshInteractionRatioChangedEventArgs[] = {
        { "_assign_array_", _assign_array_RefreshInteractionRatioChangedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_RefreshInteractionRatioChangedEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_RefreshInteractionRatioChangedEventArgs[] = {
        { "interaction_ratio", reinterpret_cast<getter>(RefreshInteractionRatioChangedEventArgs_get_InteractionRatio), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_RefreshInteractionRatioChangedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_RefreshInteractionRatioChangedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_RefreshInteractionRatioChangedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_RefreshInteractionRatioChangedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_RefreshInteractionRatioChangedEventArgs) },
        { }};

    static PyType_Spec type_spec_RefreshInteractionRatioChangedEventArgs = {
        "winui2._winui2_microsoft_ui_xaml_controls.RefreshInteractionRatioChangedEventArgs",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Controls::RefreshInteractionRatioChangedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_RefreshInteractionRatioChangedEventArgs};

    // ----- RefreshRequestedEventArgs class --------------------

    static PyObject* _new_RefreshRequestedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Xaml::Controls::RefreshRequestedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Xaml::Controls::RefreshRequestedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_RefreshRequestedEventArgs(py::wrapper::Microsoft::UI::Xaml::Controls::RefreshRequestedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* RefreshRequestedEventArgs_GetDeferral(py::wrapper::Microsoft::UI::Xaml::Controls::RefreshRequestedEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.RefreshRequestedEventArgs", L"GetDeferral", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetDeferral();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_RefreshRequestedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::RefreshRequestedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_RefreshRequestedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::RefreshRequestedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_RefreshRequestedEventArgs[] = {
        { "get_deferral", reinterpret_cast<PyCFunction>(RefreshRequestedEventArgs_GetDeferral), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_RefreshRequestedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_RefreshRequestedEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_RefreshRequestedEventArgs[] = {
        { }};

    static PyType_Slot _type_slots_RefreshRequestedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_RefreshRequestedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_RefreshRequestedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_RefreshRequestedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_RefreshRequestedEventArgs) },
        { }};

    static PyType_Spec type_spec_RefreshRequestedEventArgs = {
        "winui2._winui2_microsoft_ui_xaml_controls.RefreshRequestedEventArgs",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Controls::RefreshRequestedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_RefreshRequestedEventArgs};

    // ----- RefreshStateChangedEventArgs class --------------------

    static PyObject* _new_RefreshStateChangedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Xaml::Controls::RefreshStateChangedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Xaml::Controls::RefreshStateChangedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_RefreshStateChangedEventArgs(py::wrapper::Microsoft::UI::Xaml::Controls::RefreshStateChangedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* RefreshStateChangedEventArgs_get_NewState(py::wrapper::Microsoft::UI::Xaml::Controls::RefreshStateChangedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.RefreshStateChangedEventArgs", L"NewState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.NewState();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RefreshStateChangedEventArgs_get_OldState(py::wrapper::Microsoft::UI::Xaml::Controls::RefreshStateChangedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.RefreshStateChangedEventArgs", L"OldState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.OldState();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_RefreshStateChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::RefreshStateChangedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_RefreshStateChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::RefreshStateChangedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_RefreshStateChangedEventArgs[] = {
        { "_assign_array_", _assign_array_RefreshStateChangedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_RefreshStateChangedEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_RefreshStateChangedEventArgs[] = {
        { "new_state", reinterpret_cast<getter>(RefreshStateChangedEventArgs_get_NewState), nullptr, nullptr, nullptr },
        { "old_state", reinterpret_cast<getter>(RefreshStateChangedEventArgs_get_OldState), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_RefreshStateChangedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_RefreshStateChangedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_RefreshStateChangedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_RefreshStateChangedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_RefreshStateChangedEventArgs) },
        { }};

    static PyType_Spec type_spec_RefreshStateChangedEventArgs = {
        "winui2._winui2_microsoft_ui_xaml_controls.RefreshStateChangedEventArgs",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Controls::RefreshStateChangedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_RefreshStateChangedEventArgs};

    // ----- RefreshVisualizer class --------------------

    struct PyWinrtRefreshVisualizer;
    using BasePyWinrtRefreshVisualizer = winrt::Microsoft::UI::Xaml::Controls::RefreshVisualizerT<PyWinrtRefreshVisualizer, py::IPywinrtObject>;

    struct PyWinrtRefreshVisualizer : py::py_obj_ref, BasePyWinrtRefreshVisualizer
    {
        PyWinrtRefreshVisualizer(PyObject* py_obj) : py::py_obj_ref(py_obj), BasePyWinrtRefreshVisualizer() {}

        int32_t __stdcall GetPyObject(PyObject*& obj) override
        {
            obj = py::py_obj_ref::get_py_obj();
            return 0;
        }

        int32_t __stdcall GetComposableInner(winrt::Windows::Foundation::IInspectable& inner) override
        {
            inner = m_inner;
            return winrt::impl::error_ok;
        }

        static void toggle_reference(PyWinrtRefreshVisualizer* instance, bool is_last_reference)
        {
            py::py_obj_ref::toggle_reference(instance, is_last_reference);
        }

        int32_t query_interface_tearoff(winrt::guid const& id, void** result) const noexcept override
        {
            return py::py_obj_ref::query_interface_tearoff(id, result);
        }

        std::vector<winrt::guid> get_iids_tearoff() const noexcept override
        {
            return py::py_obj_ref::get_iids_tearoff();
        }
    };

    static PyObject* _new_RefreshVisualizer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_GET_SIZE(args);

        auto self_type = get_python_type_for<winrt::Microsoft::UI::Xaml::Controls::RefreshVisualizer>();
        if (!self_type)
        {
            return nullptr;
        }

        if (arg_count == 0)
        {
            try
            {
                if (type != self_type)
                {
                    py::pyobj_handle self{type->tp_alloc(type, 0)};
                    if (!self)
                    {
                        return nullptr;
                    }

                    std::construct_at(&reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj, nullptr);

                    auto obj_impl = winrt::make_self<PyWinrtRefreshVisualizer>(self.get());

                    auto obj = py::make_py_obj<PyWinrtRefreshVisualizer>(obj_impl, type, self.get());
                    if (!obj)
                    {
                        return nullptr;
                    }

                    reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj = std::move(obj);

                    return self.detach();
                }

                winrt::Microsoft::UI::Xaml::Controls::RefreshVisualizer instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_RefreshVisualizer(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* RefreshVisualizer_RequestRefresh(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.RefreshVisualizer", L"RequestRefresh", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::RefreshVisualizer>().RequestRefresh();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RefreshVisualizer_get_Orientation(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.RefreshVisualizer", L"Orientation");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::RefreshVisualizer>().Orientation();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int RefreshVisualizer_put_Orientation(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.RefreshVisualizer", L"Orientation");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::RefreshVisualizerOrientation>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::RefreshVisualizer>().Orientation(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* RefreshVisualizer_get_Content(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.RefreshVisualizer", L"Content");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::RefreshVisualizer>().Content();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int RefreshVisualizer_put_Content(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.RefreshVisualizer", L"Content");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::UIElement>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::RefreshVisualizer>().Content(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* RefreshVisualizer_get_State(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.RefreshVisualizer", L"State");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::RefreshVisualizer>().State();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RefreshVisualizer_get_ContentProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.RefreshVisualizer", L"ContentProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::RefreshVisualizer::ContentProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RefreshVisualizer_get_InfoProviderProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.RefreshVisualizer", L"InfoProviderProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::RefreshVisualizer::InfoProviderProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RefreshVisualizer_get_OrientationProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.RefreshVisualizer", L"OrientationProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::RefreshVisualizer::OrientationProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RefreshVisualizer_get_StateProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.RefreshVisualizer", L"StateProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::RefreshVisualizer::StateProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RefreshVisualizer_add_RefreshRequested(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.RefreshVisualizer", L"RefreshRequested");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Xaml::Controls::RefreshVisualizer, winrt::Microsoft::UI::Xaml::Controls::RefreshRequestedEventArgs>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::RefreshVisualizer>().RefreshRequested(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RefreshVisualizer_remove_RefreshRequested(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.RefreshVisualizer", L"RefreshRequested");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::RefreshVisualizer>().RefreshRequested(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RefreshVisualizer_add_RefreshStateChanged(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.RefreshVisualizer", L"RefreshStateChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Xaml::Controls::RefreshVisualizer, winrt::Microsoft::UI::Xaml::Controls::RefreshStateChangedEventArgs>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::RefreshVisualizer>().RefreshStateChanged(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RefreshVisualizer_remove_RefreshStateChanged(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.RefreshVisualizer", L"RefreshStateChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::RefreshVisualizer>().RefreshStateChanged(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_RefreshVisualizer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::RefreshVisualizer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_RefreshVisualizer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::RefreshVisualizer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_RefreshVisualizer[] = {
        { "request_refresh", reinterpret_cast<PyCFunction>(RefreshVisualizer_RequestRefresh), METH_VARARGS, nullptr },
        { "add_refresh_requested", reinterpret_cast<PyCFunction>(RefreshVisualizer_add_RefreshRequested), METH_O, nullptr },
        { "remove_refresh_requested", reinterpret_cast<PyCFunction>(RefreshVisualizer_remove_RefreshRequested), METH_O, nullptr },
        { "add_refresh_state_changed", reinterpret_cast<PyCFunction>(RefreshVisualizer_add_RefreshStateChanged), METH_O, nullptr },
        { "remove_refresh_state_changed", reinterpret_cast<PyCFunction>(RefreshVisualizer_remove_RefreshStateChanged), METH_O, nullptr },
        { "_assign_array_", _assign_array_RefreshVisualizer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_RefreshVisualizer), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_RefreshVisualizer[] = {
        { "orientation", reinterpret_cast<getter>(RefreshVisualizer_get_Orientation), reinterpret_cast<setter>(RefreshVisualizer_put_Orientation), nullptr, nullptr },
        { "content", reinterpret_cast<getter>(RefreshVisualizer_get_Content), reinterpret_cast<setter>(RefreshVisualizer_put_Content), nullptr, nullptr },
        { "state", reinterpret_cast<getter>(RefreshVisualizer_get_State), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_RefreshVisualizer[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_RefreshVisualizer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_RefreshVisualizer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_RefreshVisualizer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_RefreshVisualizer) },
        { }};

    static PyType_Spec type_spec_RefreshVisualizer = {
        "winui2._winui2_microsoft_ui_xaml_controls.RefreshVisualizer",
        sizeof(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_RefreshVisualizer};

    static PyGetSetDef getset_RefreshVisualizer_Static[] = {
        { "content_property", reinterpret_cast<getter>(RefreshVisualizer_get_ContentProperty), nullptr, nullptr, nullptr },
        { "info_provider_property", reinterpret_cast<getter>(RefreshVisualizer_get_InfoProviderProperty), nullptr, nullptr, nullptr },
        { "orientation_property", reinterpret_cast<getter>(RefreshVisualizer_get_OrientationProperty), nullptr, nullptr, nullptr },
        { "state_property", reinterpret_cast<getter>(RefreshVisualizer_get_StateProperty), nullptr, nullptr, nullptr },
        { }};

    static PyMethodDef methods_RefreshVisualizer_Static[] = {
        { }};

    static PyType_Slot type_slots_RefreshVisualizer_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_RefreshVisualizer_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_RefreshVisualizer_Static) },
        { }
    };

    static PyType_Spec type_spec_RefreshVisualizer_Static = {
        "winui2._winui2_microsoft_ui_xaml_controls.RefreshVisualizer_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_RefreshVisualizer_Static};

    // ----- RevealListViewItemPresenter class --------------------

    struct PyWinrtRevealListViewItemPresenter;
    using BasePyWinrtRevealListViewItemPresenter = winrt::Microsoft::UI::Xaml::Controls::RevealListViewItemPresenterT<PyWinrtRevealListViewItemPresenter, py::IPywinrtObject>;

    struct PyWinrtRevealListViewItemPresenter : py::py_obj_ref, BasePyWinrtRevealListViewItemPresenter
    {
        PyWinrtRevealListViewItemPresenter(PyObject* py_obj) : py::py_obj_ref(py_obj), BasePyWinrtRevealListViewItemPresenter() {}

        int32_t __stdcall GetPyObject(PyObject*& obj) override
        {
            obj = py::py_obj_ref::get_py_obj();
            return 0;
        }

        int32_t __stdcall GetComposableInner(winrt::Windows::Foundation::IInspectable& inner) override
        {
            inner = m_inner;
            return winrt::impl::error_ok;
        }

        static void toggle_reference(PyWinrtRevealListViewItemPresenter* instance, bool is_last_reference)
        {
            py::py_obj_ref::toggle_reference(instance, is_last_reference);
        }

        int32_t query_interface_tearoff(winrt::guid const& id, void** result) const noexcept override
        {
            return py::py_obj_ref::query_interface_tearoff(id, result);
        }

        std::vector<winrt::guid> get_iids_tearoff() const noexcept override
        {
            return py::py_obj_ref::get_iids_tearoff();
        }
    };

    static PyObject* _new_RevealListViewItemPresenter(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_GET_SIZE(args);

        auto self_type = get_python_type_for<winrt::Microsoft::UI::Xaml::Controls::RevealListViewItemPresenter>();
        if (!self_type)
        {
            return nullptr;
        }

        if (arg_count == 0)
        {
            try
            {
                if (type != self_type)
                {
                    py::pyobj_handle self{type->tp_alloc(type, 0)};
                    if (!self)
                    {
                        return nullptr;
                    }

                    std::construct_at(&reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj, nullptr);

                    auto obj_impl = winrt::make_self<PyWinrtRevealListViewItemPresenter>(self.get());

                    auto obj = py::make_py_obj<PyWinrtRevealListViewItemPresenter>(obj_impl, type, self.get());
                    if (!obj)
                    {
                        return nullptr;
                    }

                    reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj = std::move(obj);

                    return self.detach();
                }

                winrt::Microsoft::UI::Xaml::Controls::RevealListViewItemPresenter instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_RevealListViewItemPresenter(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_RevealListViewItemPresenter(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::RevealListViewItemPresenter>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_RevealListViewItemPresenter(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::RevealListViewItemPresenter>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_RevealListViewItemPresenter[] = {
        { "_assign_array_", _assign_array_RevealListViewItemPresenter, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_RevealListViewItemPresenter), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_RevealListViewItemPresenter[] = {
        { }};

    static PyType_Slot _type_slots_RevealListViewItemPresenter[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_RevealListViewItemPresenter) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_RevealListViewItemPresenter) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_RevealListViewItemPresenter) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_RevealListViewItemPresenter) },
        { }};

    static PyType_Spec type_spec_RevealListViewItemPresenter = {
        "winui2._winui2_microsoft_ui_xaml_controls.RevealListViewItemPresenter",
        sizeof(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_RevealListViewItemPresenter};

    static PyGetSetDef getset_RevealListViewItemPresenter_Static[] = {
        { }};

    static PyMethodDef methods_RevealListViewItemPresenter_Static[] = {
        { }};

    static PyType_Slot type_slots_RevealListViewItemPresenter_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_RevealListViewItemPresenter_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_RevealListViewItemPresenter_Static) },
        { }
    };

    static PyType_Spec type_spec_RevealListViewItemPresenter_Static = {
        "winui2._winui2_microsoft_ui_xaml_controls.RevealListViewItemPresenter_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_RevealListViewItemPresenter_Static};

    // ----- SplitButton class --------------------

    struct PyWinrtSplitButton;
    using BasePyWinrtSplitButton = winrt::Microsoft::UI::Xaml::Controls::SplitButtonT<PyWinrtSplitButton, py::IPywinrtObject>;

    struct PyWinrtSplitButton : py::py_obj_ref, BasePyWinrtSplitButton
    {
        PyWinrtSplitButton(PyObject* py_obj) : py::py_obj_ref(py_obj), BasePyWinrtSplitButton() {}

        int32_t __stdcall GetPyObject(PyObject*& obj) override
        {
            obj = py::py_obj_ref::get_py_obj();
            return 0;
        }

        int32_t __stdcall GetComposableInner(winrt::Windows::Foundation::IInspectable& inner) override
        {
            inner = m_inner;
            return winrt::impl::error_ok;
        }

        static void toggle_reference(PyWinrtSplitButton* instance, bool is_last_reference)
        {
            py::py_obj_ref::toggle_reference(instance, is_last_reference);
        }

        int32_t query_interface_tearoff(winrt::guid const& id, void** result) const noexcept override
        {
            return py::py_obj_ref::query_interface_tearoff(id, result);
        }

        std::vector<winrt::guid> get_iids_tearoff() const noexcept override
        {
            return py::py_obj_ref::get_iids_tearoff();
        }
    };

    static PyObject* _new_SplitButton(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_GET_SIZE(args);

        auto self_type = get_python_type_for<winrt::Microsoft::UI::Xaml::Controls::SplitButton>();
        if (!self_type)
        {
            return nullptr;
        }

        if (arg_count == 0)
        {
            try
            {
                if (type != self_type)
                {
                    py::pyobj_handle self{type->tp_alloc(type, 0)};
                    if (!self)
                    {
                        return nullptr;
                    }

                    std::construct_at(&reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj, nullptr);

                    auto obj_impl = winrt::make_self<PyWinrtSplitButton>(self.get());

                    auto obj = py::make_py_obj<PyWinrtSplitButton>(obj_impl, type, self.get());
                    if (!obj)
                    {
                        return nullptr;
                    }

                    reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj = std::move(obj);

                    return self.detach();
                }

                winrt::Microsoft::UI::Xaml::Controls::SplitButton instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_SplitButton(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SplitButton_get_Flyout(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.SplitButton", L"Flyout");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::SplitButton>().Flyout();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SplitButton_put_Flyout(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.SplitButton", L"Flyout");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::Primitives::FlyoutBase>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::SplitButton>().Flyout(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SplitButton_get_CommandParameter(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.SplitButton", L"CommandParameter");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::SplitButton>().CommandParameter();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SplitButton_put_CommandParameter(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.SplitButton", L"CommandParameter");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::SplitButton>().CommandParameter(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SplitButton_get_Command(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.SplitButton", L"Command");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::SplitButton>().Command();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SplitButton_put_Command(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.SplitButton", L"Command");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Input::ICommand>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::SplitButton>().Command(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SplitButton_get_CommandParameterProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.SplitButton", L"CommandParameterProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::SplitButton::CommandParameterProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SplitButton_get_CommandProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.SplitButton", L"CommandProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::SplitButton::CommandProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SplitButton_get_FlyoutProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.SplitButton", L"FlyoutProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::SplitButton::FlyoutProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SplitButton_add_Click(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.SplitButton", L"Click");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Xaml::Controls::SplitButton, winrt::Microsoft::UI::Xaml::Controls::SplitButtonClickEventArgs>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::SplitButton>().Click(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SplitButton_remove_Click(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.SplitButton", L"Click");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::SplitButton>().Click(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SplitButton(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::SplitButton>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SplitButton(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::SplitButton>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SplitButton[] = {
        { "add_click", reinterpret_cast<PyCFunction>(SplitButton_add_Click), METH_O, nullptr },
        { "remove_click", reinterpret_cast<PyCFunction>(SplitButton_remove_Click), METH_O, nullptr },
        { "_assign_array_", _assign_array_SplitButton, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SplitButton), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_SplitButton[] = {
        { "flyout", reinterpret_cast<getter>(SplitButton_get_Flyout), reinterpret_cast<setter>(SplitButton_put_Flyout), nullptr, nullptr },
        { "command_parameter", reinterpret_cast<getter>(SplitButton_get_CommandParameter), reinterpret_cast<setter>(SplitButton_put_CommandParameter), nullptr, nullptr },
        { "command", reinterpret_cast<getter>(SplitButton_get_Command), reinterpret_cast<setter>(SplitButton_put_Command), nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_SplitButton[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_SplitButton) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SplitButton) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SplitButton) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SplitButton) },
        { }};

    static PyType_Spec type_spec_SplitButton = {
        "winui2._winui2_microsoft_ui_xaml_controls.SplitButton",
        sizeof(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_SplitButton};

    static PyGetSetDef getset_SplitButton_Static[] = {
        { "command_parameter_property", reinterpret_cast<getter>(SplitButton_get_CommandParameterProperty), nullptr, nullptr, nullptr },
        { "command_property", reinterpret_cast<getter>(SplitButton_get_CommandProperty), nullptr, nullptr, nullptr },
        { "flyout_property", reinterpret_cast<getter>(SplitButton_get_FlyoutProperty), nullptr, nullptr, nullptr },
        { }};

    static PyMethodDef methods_SplitButton_Static[] = {
        { }};

    static PyType_Slot type_slots_SplitButton_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_SplitButton_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_SplitButton_Static) },
        { }
    };

    static PyType_Spec type_spec_SplitButton_Static = {
        "winui2._winui2_microsoft_ui_xaml_controls.SplitButton_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_SplitButton_Static};

    // ----- SplitButtonClickEventArgs class --------------------

    static PyObject* _new_SplitButtonClickEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Xaml::Controls::SplitButtonClickEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Xaml::Controls::SplitButtonClickEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_SplitButtonClickEventArgs(py::wrapper::Microsoft::UI::Xaml::Controls::SplitButtonClickEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_SplitButtonClickEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::SplitButtonClickEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SplitButtonClickEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::SplitButtonClickEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SplitButtonClickEventArgs[] = {
        { "_assign_array_", _assign_array_SplitButtonClickEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SplitButtonClickEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_SplitButtonClickEventArgs[] = {
        { }};

    static PyType_Slot _type_slots_SplitButtonClickEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_SplitButtonClickEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SplitButtonClickEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SplitButtonClickEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SplitButtonClickEventArgs) },
        { }};

    static PyType_Spec type_spec_SplitButtonClickEventArgs = {
        "winui2._winui2_microsoft_ui_xaml_controls.SplitButtonClickEventArgs",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Controls::SplitButtonClickEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SplitButtonClickEventArgs};

    // ----- StackLayout class --------------------

    struct PyWinrtStackLayout;
    using BasePyWinrtStackLayout = winrt::Microsoft::UI::Xaml::Controls::StackLayoutT<PyWinrtStackLayout, py::IPywinrtObject>;

    struct PyWinrtStackLayout : py::py_obj_ref, BasePyWinrtStackLayout
    {
        PyWinrtStackLayout(PyObject* py_obj) : py::py_obj_ref(py_obj), BasePyWinrtStackLayout() {}

        int32_t __stdcall GetPyObject(PyObject*& obj) override
        {
            obj = py::py_obj_ref::get_py_obj();
            return 0;
        }

        int32_t __stdcall GetComposableInner(winrt::Windows::Foundation::IInspectable& inner) override
        {
            inner = m_inner;
            return winrt::impl::error_ok;
        }

        static void toggle_reference(PyWinrtStackLayout* instance, bool is_last_reference)
        {
            py::py_obj_ref::toggle_reference(instance, is_last_reference);
        }

        int32_t query_interface_tearoff(winrt::guid const& id, void** result) const noexcept override
        {
            return py::py_obj_ref::query_interface_tearoff(id, result);
        }

        std::vector<winrt::guid> get_iids_tearoff() const noexcept override
        {
            return py::py_obj_ref::get_iids_tearoff();
        }
    };

    static PyObject* _new_StackLayout(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_GET_SIZE(args);

        auto self_type = get_python_type_for<winrt::Microsoft::UI::Xaml::Controls::StackLayout>();
        if (!self_type)
        {
            return nullptr;
        }

        if (arg_count == 0)
        {
            try
            {
                if (type != self_type)
                {
                    py::pyobj_handle self{type->tp_alloc(type, 0)};
                    if (!self)
                    {
                        return nullptr;
                    }

                    std::construct_at(&reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj, nullptr);

                    auto obj_impl = winrt::make_self<PyWinrtStackLayout>(self.get());

                    auto obj = py::make_py_obj<PyWinrtStackLayout>(obj_impl, type, self.get());
                    if (!obj)
                    {
                        return nullptr;
                    }

                    reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj = std::move(obj);

                    return self.detach();
                }

                winrt::Microsoft::UI::Xaml::Controls::StackLayout instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_StackLayout(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* StackLayout_get_Spacing(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.StackLayout", L"Spacing");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::StackLayout>().Spacing();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StackLayout_put_Spacing(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.StackLayout", L"Spacing");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<double>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::StackLayout>().Spacing(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StackLayout_get_Orientation(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.StackLayout", L"Orientation");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::StackLayout>().Orientation();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StackLayout_put_Orientation(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.StackLayout", L"Orientation");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::Orientation>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::StackLayout>().Orientation(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StackLayout_get_OrientationProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.StackLayout", L"OrientationProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::StackLayout::OrientationProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StackLayout_get_SpacingProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.StackLayout", L"SpacingProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::StackLayout::SpacingProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_StackLayout(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::StackLayout>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_StackLayout(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::StackLayout>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StackLayout[] = {
        { "_assign_array_", _assign_array_StackLayout, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_StackLayout), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_StackLayout[] = {
        { "spacing", reinterpret_cast<getter>(StackLayout_get_Spacing), reinterpret_cast<setter>(StackLayout_put_Spacing), nullptr, nullptr },
        { "orientation", reinterpret_cast<getter>(StackLayout_get_Orientation), reinterpret_cast<setter>(StackLayout_put_Orientation), nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_StackLayout[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_StackLayout) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_StackLayout) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_StackLayout) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_StackLayout) },
        { }};

    static PyType_Spec type_spec_StackLayout = {
        "winui2._winui2_microsoft_ui_xaml_controls.StackLayout",
        sizeof(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_StackLayout};

    static PyGetSetDef getset_StackLayout_Static[] = {
        { "orientation_property", reinterpret_cast<getter>(StackLayout_get_OrientationProperty), nullptr, nullptr, nullptr },
        { "spacing_property", reinterpret_cast<getter>(StackLayout_get_SpacingProperty), nullptr, nullptr, nullptr },
        { }};

    static PyMethodDef methods_StackLayout_Static[] = {
        { }};

    static PyType_Slot type_slots_StackLayout_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_StackLayout_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_StackLayout_Static) },
        { }
    };

    static PyType_Spec type_spec_StackLayout_Static = {
        "winui2._winui2_microsoft_ui_xaml_controls.StackLayout_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_StackLayout_Static};

    // ----- SwipeControl class --------------------

    struct PyWinrtSwipeControl;
    using BasePyWinrtSwipeControl = winrt::Microsoft::UI::Xaml::Controls::SwipeControlT<PyWinrtSwipeControl, py::IPywinrtObject>;

    struct PyWinrtSwipeControl : py::py_obj_ref, BasePyWinrtSwipeControl
    {
        PyWinrtSwipeControl(PyObject* py_obj) : py::py_obj_ref(py_obj), BasePyWinrtSwipeControl() {}

        int32_t __stdcall GetPyObject(PyObject*& obj) override
        {
            obj = py::py_obj_ref::get_py_obj();
            return 0;
        }

        int32_t __stdcall GetComposableInner(winrt::Windows::Foundation::IInspectable& inner) override
        {
            inner = m_inner;
            return winrt::impl::error_ok;
        }

        static void toggle_reference(PyWinrtSwipeControl* instance, bool is_last_reference)
        {
            py::py_obj_ref::toggle_reference(instance, is_last_reference);
        }

        int32_t query_interface_tearoff(winrt::guid const& id, void** result) const noexcept override
        {
            return py::py_obj_ref::query_interface_tearoff(id, result);
        }

        std::vector<winrt::guid> get_iids_tearoff() const noexcept override
        {
            return py::py_obj_ref::get_iids_tearoff();
        }
    };

    static PyObject* _new_SwipeControl(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_GET_SIZE(args);

        auto self_type = get_python_type_for<winrt::Microsoft::UI::Xaml::Controls::SwipeControl>();
        if (!self_type)
        {
            return nullptr;
        }

        if (arg_count == 0)
        {
            try
            {
                if (type != self_type)
                {
                    py::pyobj_handle self{type->tp_alloc(type, 0)};
                    if (!self)
                    {
                        return nullptr;
                    }

                    std::construct_at(&reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj, nullptr);

                    auto obj_impl = winrt::make_self<PyWinrtSwipeControl>(self.get());

                    auto obj = py::make_py_obj<PyWinrtSwipeControl>(obj_impl, type, self.get());
                    if (!obj)
                    {
                        return nullptr;
                    }

                    reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj = std::move(obj);

                    return self.detach();
                }

                winrt::Microsoft::UI::Xaml::Controls::SwipeControl instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_SwipeControl(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SwipeControl_Close(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.SwipeControl", L"Close", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::SwipeControl>().Close();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SwipeControl_get_TopItems(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.SwipeControl", L"TopItems");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::SwipeControl>().TopItems();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SwipeControl_put_TopItems(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.SwipeControl", L"TopItems");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::SwipeItems>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::SwipeControl>().TopItems(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SwipeControl_get_RightItems(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.SwipeControl", L"RightItems");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::SwipeControl>().RightItems();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SwipeControl_put_RightItems(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.SwipeControl", L"RightItems");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::SwipeItems>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::SwipeControl>().RightItems(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SwipeControl_get_LeftItems(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.SwipeControl", L"LeftItems");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::SwipeControl>().LeftItems();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SwipeControl_put_LeftItems(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.SwipeControl", L"LeftItems");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::SwipeItems>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::SwipeControl>().LeftItems(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SwipeControl_get_BottomItems(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.SwipeControl", L"BottomItems");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::SwipeControl>().BottomItems();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SwipeControl_put_BottomItems(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.SwipeControl", L"BottomItems");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::SwipeItems>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::SwipeControl>().BottomItems(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SwipeControl_get_BottomItemsProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.SwipeControl", L"BottomItemsProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::SwipeControl::BottomItemsProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SwipeControl_get_LeftItemsProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.SwipeControl", L"LeftItemsProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::SwipeControl::LeftItemsProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SwipeControl_get_RightItemsProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.SwipeControl", L"RightItemsProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::SwipeControl::RightItemsProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SwipeControl_get_TopItemsProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.SwipeControl", L"TopItemsProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::SwipeControl::TopItemsProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SwipeControl(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::SwipeControl>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SwipeControl(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::SwipeControl>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SwipeControl[] = {
        { "close", reinterpret_cast<PyCFunction>(SwipeControl_Close), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_SwipeControl, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SwipeControl), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_SwipeControl[] = {
        { "top_items", reinterpret_cast<getter>(SwipeControl_get_TopItems), reinterpret_cast<setter>(SwipeControl_put_TopItems), nullptr, nullptr },
        { "right_items", reinterpret_cast<getter>(SwipeControl_get_RightItems), reinterpret_cast<setter>(SwipeControl_put_RightItems), nullptr, nullptr },
        { "left_items", reinterpret_cast<getter>(SwipeControl_get_LeftItems), reinterpret_cast<setter>(SwipeControl_put_LeftItems), nullptr, nullptr },
        { "bottom_items", reinterpret_cast<getter>(SwipeControl_get_BottomItems), reinterpret_cast<setter>(SwipeControl_put_BottomItems), nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_SwipeControl[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_SwipeControl) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SwipeControl) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SwipeControl) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SwipeControl) },
        { }};

    static PyType_Spec type_spec_SwipeControl = {
        "winui2._winui2_microsoft_ui_xaml_controls.SwipeControl",
        sizeof(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_SwipeControl};

    static PyGetSetDef getset_SwipeControl_Static[] = {
        { "bottom_items_property", reinterpret_cast<getter>(SwipeControl_get_BottomItemsProperty), nullptr, nullptr, nullptr },
        { "left_items_property", reinterpret_cast<getter>(SwipeControl_get_LeftItemsProperty), nullptr, nullptr, nullptr },
        { "right_items_property", reinterpret_cast<getter>(SwipeControl_get_RightItemsProperty), nullptr, nullptr, nullptr },
        { "top_items_property", reinterpret_cast<getter>(SwipeControl_get_TopItemsProperty), nullptr, nullptr, nullptr },
        { }};

    static PyMethodDef methods_SwipeControl_Static[] = {
        { }};

    static PyType_Slot type_slots_SwipeControl_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_SwipeControl_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_SwipeControl_Static) },
        { }
    };

    static PyType_Spec type_spec_SwipeControl_Static = {
        "winui2._winui2_microsoft_ui_xaml_controls.SwipeControl_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_SwipeControl_Static};

    // ----- SwipeItem class --------------------

    struct PyWinrtSwipeItem;
    using BasePyWinrtSwipeItem = winrt::Microsoft::UI::Xaml::Controls::SwipeItemT<PyWinrtSwipeItem, py::IPywinrtObject>;

    struct PyWinrtSwipeItem : py::py_obj_ref, BasePyWinrtSwipeItem
    {
        PyWinrtSwipeItem(PyObject* py_obj) : py::py_obj_ref(py_obj), BasePyWinrtSwipeItem() {}

        int32_t __stdcall GetPyObject(PyObject*& obj) override
        {
            obj = py::py_obj_ref::get_py_obj();
            return 0;
        }

        int32_t __stdcall GetComposableInner(winrt::Windows::Foundation::IInspectable& inner) override
        {
            inner = m_inner;
            return winrt::impl::error_ok;
        }

        static void toggle_reference(PyWinrtSwipeItem* instance, bool is_last_reference)
        {
            py::py_obj_ref::toggle_reference(instance, is_last_reference);
        }

        int32_t query_interface_tearoff(winrt::guid const& id, void** result) const noexcept override
        {
            return py::py_obj_ref::query_interface_tearoff(id, result);
        }

        std::vector<winrt::guid> get_iids_tearoff() const noexcept override
        {
            return py::py_obj_ref::get_iids_tearoff();
        }
    };

    static PyObject* _new_SwipeItem(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_GET_SIZE(args);

        auto self_type = get_python_type_for<winrt::Microsoft::UI::Xaml::Controls::SwipeItem>();
        if (!self_type)
        {
            return nullptr;
        }

        if (arg_count == 0)
        {
            try
            {
                if (type != self_type)
                {
                    py::pyobj_handle self{type->tp_alloc(type, 0)};
                    if (!self)
                    {
                        return nullptr;
                    }

                    std::construct_at(&reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj, nullptr);

                    auto obj_impl = winrt::make_self<PyWinrtSwipeItem>(self.get());

                    auto obj = py::make_py_obj<PyWinrtSwipeItem>(obj_impl, type, self.get());
                    if (!obj)
                    {
                        return nullptr;
                    }

                    reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj = std::move(obj);

                    return self.detach();
                }

                winrt::Microsoft::UI::Xaml::Controls::SwipeItem instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_SwipeItem(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SwipeItem_get_Text(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.SwipeItem", L"Text");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::SwipeItem>().Text();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SwipeItem_put_Text(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.SwipeItem", L"Text");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::SwipeItem>().Text(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SwipeItem_get_IconSource(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.SwipeItem", L"IconSource");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::SwipeItem>().IconSource();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SwipeItem_put_IconSource(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.SwipeItem", L"IconSource");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::IconSource>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::SwipeItem>().IconSource(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SwipeItem_get_Foreground(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.SwipeItem", L"Foreground");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::SwipeItem>().Foreground();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SwipeItem_put_Foreground(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.SwipeItem", L"Foreground");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Media::Brush>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::SwipeItem>().Foreground(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SwipeItem_get_CommandParameter(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.SwipeItem", L"CommandParameter");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::SwipeItem>().CommandParameter();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SwipeItem_put_CommandParameter(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.SwipeItem", L"CommandParameter");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::SwipeItem>().CommandParameter(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SwipeItem_get_Command(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.SwipeItem", L"Command");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::SwipeItem>().Command();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SwipeItem_put_Command(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.SwipeItem", L"Command");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Input::ICommand>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::SwipeItem>().Command(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SwipeItem_get_BehaviorOnInvoked(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.SwipeItem", L"BehaviorOnInvoked");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::SwipeItem>().BehaviorOnInvoked();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SwipeItem_put_BehaviorOnInvoked(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.SwipeItem", L"BehaviorOnInvoked");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::SwipeBehaviorOnInvoked>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::SwipeItem>().BehaviorOnInvoked(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SwipeItem_get_Background(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.SwipeItem", L"Background");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::SwipeItem>().Background();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SwipeItem_put_Background(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.SwipeItem", L"Background");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Media::Brush>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::SwipeItem>().Background(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SwipeItem_get_BackgroundProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.SwipeItem", L"BackgroundProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::SwipeItem::BackgroundProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SwipeItem_get_BehaviorOnInvokedProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.SwipeItem", L"BehaviorOnInvokedProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::SwipeItem::BehaviorOnInvokedProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SwipeItem_get_CommandParameterProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.SwipeItem", L"CommandParameterProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::SwipeItem::CommandParameterProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SwipeItem_get_CommandProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.SwipeItem", L"CommandProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::SwipeItem::CommandProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SwipeItem_get_ForegroundProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.SwipeItem", L"ForegroundProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::SwipeItem::ForegroundProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SwipeItem_get_IconSourceProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.SwipeItem", L"IconSourceProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::SwipeItem::IconSourceProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SwipeItem_get_TextProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.SwipeItem", L"TextProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::SwipeItem::TextProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SwipeItem_add_Invoked(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.SwipeItem", L"Invoked");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Xaml::Controls::SwipeItem, winrt::Microsoft::UI::Xaml::Controls::SwipeItemInvokedEventArgs>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::SwipeItem>().Invoked(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SwipeItem_remove_Invoked(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.SwipeItem", L"Invoked");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::SwipeItem>().Invoked(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SwipeItem(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::SwipeItem>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SwipeItem(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::SwipeItem>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SwipeItem[] = {
        { "add_invoked", reinterpret_cast<PyCFunction>(SwipeItem_add_Invoked), METH_O, nullptr },
        { "remove_invoked", reinterpret_cast<PyCFunction>(SwipeItem_remove_Invoked), METH_O, nullptr },
        { "_assign_array_", _assign_array_SwipeItem, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SwipeItem), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_SwipeItem[] = {
        { "text", reinterpret_cast<getter>(SwipeItem_get_Text), reinterpret_cast<setter>(SwipeItem_put_Text), nullptr, nullptr },
        { "icon_source", reinterpret_cast<getter>(SwipeItem_get_IconSource), reinterpret_cast<setter>(SwipeItem_put_IconSource), nullptr, nullptr },
        { "foreground", reinterpret_cast<getter>(SwipeItem_get_Foreground), reinterpret_cast<setter>(SwipeItem_put_Foreground), nullptr, nullptr },
        { "command_parameter", reinterpret_cast<getter>(SwipeItem_get_CommandParameter), reinterpret_cast<setter>(SwipeItem_put_CommandParameter), nullptr, nullptr },
        { "command", reinterpret_cast<getter>(SwipeItem_get_Command), reinterpret_cast<setter>(SwipeItem_put_Command), nullptr, nullptr },
        { "behavior_on_invoked", reinterpret_cast<getter>(SwipeItem_get_BehaviorOnInvoked), reinterpret_cast<setter>(SwipeItem_put_BehaviorOnInvoked), nullptr, nullptr },
        { "background", reinterpret_cast<getter>(SwipeItem_get_Background), reinterpret_cast<setter>(SwipeItem_put_Background), nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_SwipeItem[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_SwipeItem) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SwipeItem) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SwipeItem) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SwipeItem) },
        { }};

    static PyType_Spec type_spec_SwipeItem = {
        "winui2._winui2_microsoft_ui_xaml_controls.SwipeItem",
        sizeof(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_SwipeItem};

    static PyGetSetDef getset_SwipeItem_Static[] = {
        { "background_property", reinterpret_cast<getter>(SwipeItem_get_BackgroundProperty), nullptr, nullptr, nullptr },
        { "behavior_on_invoked_property", reinterpret_cast<getter>(SwipeItem_get_BehaviorOnInvokedProperty), nullptr, nullptr, nullptr },
        { "command_parameter_property", reinterpret_cast<getter>(SwipeItem_get_CommandParameterProperty), nullptr, nullptr, nullptr },
        { "command_property", reinterpret_cast<getter>(SwipeItem_get_CommandProperty), nullptr, nullptr, nullptr },
        { "foreground_property", reinterpret_cast<getter>(SwipeItem_get_ForegroundProperty), nullptr, nullptr, nullptr },
        { "icon_source_property", reinterpret_cast<getter>(SwipeItem_get_IconSourceProperty), nullptr, nullptr, nullptr },
        { "text_property", reinterpret_cast<getter>(SwipeItem_get_TextProperty), nullptr, nullptr, nullptr },
        { }};

    static PyMethodDef methods_SwipeItem_Static[] = {
        { }};

    static PyType_Slot type_slots_SwipeItem_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_SwipeItem_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_SwipeItem_Static) },
        { }
    };

    static PyType_Spec type_spec_SwipeItem_Static = {
        "winui2._winui2_microsoft_ui_xaml_controls.SwipeItem_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_SwipeItem_Static};

    // ----- SwipeItemInvokedEventArgs class --------------------

    static PyObject* _new_SwipeItemInvokedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Xaml::Controls::SwipeItemInvokedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Xaml::Controls::SwipeItemInvokedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_SwipeItemInvokedEventArgs(py::wrapper::Microsoft::UI::Xaml::Controls::SwipeItemInvokedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SwipeItemInvokedEventArgs_get_SwipeControl(py::wrapper::Microsoft::UI::Xaml::Controls::SwipeItemInvokedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.SwipeItemInvokedEventArgs", L"SwipeControl");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SwipeControl();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SwipeItemInvokedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::SwipeItemInvokedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SwipeItemInvokedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::SwipeItemInvokedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SwipeItemInvokedEventArgs[] = {
        { "_assign_array_", _assign_array_SwipeItemInvokedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SwipeItemInvokedEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_SwipeItemInvokedEventArgs[] = {
        { "swipe_control", reinterpret_cast<getter>(SwipeItemInvokedEventArgs_get_SwipeControl), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_SwipeItemInvokedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_SwipeItemInvokedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SwipeItemInvokedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SwipeItemInvokedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SwipeItemInvokedEventArgs) },
        { }};

    static PyType_Spec type_spec_SwipeItemInvokedEventArgs = {
        "winui2._winui2_microsoft_ui_xaml_controls.SwipeItemInvokedEventArgs",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Controls::SwipeItemInvokedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SwipeItemInvokedEventArgs};

    // ----- SwipeItems class --------------------

    struct PyWinrtSwipeItems;
    using BasePyWinrtSwipeItems = winrt::Microsoft::UI::Xaml::Controls::SwipeItemsT<PyWinrtSwipeItems, py::IPywinrtObject>;

    struct PyWinrtSwipeItems : py::py_obj_ref, BasePyWinrtSwipeItems
    {
        PyWinrtSwipeItems(PyObject* py_obj) : py::py_obj_ref(py_obj), BasePyWinrtSwipeItems() {}

        int32_t __stdcall GetPyObject(PyObject*& obj) override
        {
            obj = py::py_obj_ref::get_py_obj();
            return 0;
        }

        int32_t __stdcall GetComposableInner(winrt::Windows::Foundation::IInspectable& inner) override
        {
            inner = m_inner;
            return winrt::impl::error_ok;
        }

        static void toggle_reference(PyWinrtSwipeItems* instance, bool is_last_reference)
        {
            py::py_obj_ref::toggle_reference(instance, is_last_reference);
        }

        int32_t query_interface_tearoff(winrt::guid const& id, void** result) const noexcept override
        {
            return py::py_obj_ref::query_interface_tearoff(id, result);
        }

        std::vector<winrt::guid> get_iids_tearoff() const noexcept override
        {
            return py::py_obj_ref::get_iids_tearoff();
        }
    };

    static PyObject* _new_SwipeItems(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_GET_SIZE(args);

        auto self_type = get_python_type_for<winrt::Microsoft::UI::Xaml::Controls::SwipeItems>();
        if (!self_type)
        {
            return nullptr;
        }

        if (arg_count == 0)
        {
            try
            {
                if (type != self_type)
                {
                    py::pyobj_handle self{type->tp_alloc(type, 0)};
                    if (!self)
                    {
                        return nullptr;
                    }

                    std::construct_at(&reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj, nullptr);

                    auto obj_impl = winrt::make_self<PyWinrtSwipeItems>(self.get());

                    auto obj = py::make_py_obj<PyWinrtSwipeItems>(obj_impl, type, self.get());
                    if (!obj)
                    {
                        return nullptr;
                    }

                    reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj = std::move(obj);

                    return self.detach();
                }

                winrt::Microsoft::UI::Xaml::Controls::SwipeItems instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_SwipeItems(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SwipeItems_Append(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.SwipeItems", L"Append", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::SwipeItem>(args, 0);

                {
                    auto _gil = release_gil();
                    self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::SwipeItems>().Append(param0);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SwipeItems_Clear(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.SwipeItems", L"Clear", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::SwipeItems>().Clear();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SwipeItems_First(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.SwipeItems", L"First", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::SwipeItems>().First();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SwipeItems_GetAt(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.SwipeItems", L"GetAt", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint32_t>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::SwipeItems>().GetAt(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SwipeItems_GetMany(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.SwipeItems", L"GetMany", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<py::pybuf_view<winrt::Microsoft::UI::Xaml::Controls::SwipeItem, true>>(args, 1);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::SwipeItems>().GetMany(param0, param1);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SwipeItems_GetView(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.SwipeItems", L"GetView", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::SwipeItems>().GetView();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SwipeItems_IndexOf(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.SwipeItems", L"IndexOf", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::SwipeItem>(args, 0);
                uint32_t param1{};

                auto return_value = [&]()
                {
                    auto _gil = release_gil();
                    return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::SwipeItems>().IndexOf(param0, param1);
                }();

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out1{ py::convert(param1) };
                if (!out1)
                {
                    return nullptr;
                }

                return PyTuple_Pack(2, out_return_value.get(), out1.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SwipeItems_InsertAt(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.SwipeItems", L"InsertAt", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::SwipeItem>(args, 1);

                {
                    auto _gil = release_gil();
                    self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::SwipeItems>().InsertAt(param0, param1);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SwipeItems_RemoveAt(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.SwipeItems", L"RemoveAt", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint32_t>(args, 0);

                {
                    auto _gil = release_gil();
                    self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::SwipeItems>().RemoveAt(param0);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SwipeItems_RemoveAtEnd(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.SwipeItems", L"RemoveAtEnd", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::SwipeItems>().RemoveAtEnd();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SwipeItems_ReplaceAll(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.SwipeItems", L"ReplaceAll", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<py::pybuf_view<winrt::Microsoft::UI::Xaml::Controls::SwipeItem, false>>(args, 0);

                {
                    auto _gil = release_gil();
                    self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::SwipeItems>().ReplaceAll(param0);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SwipeItems_SetAt(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.SwipeItems", L"SetAt", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::SwipeItem>(args, 1);

                {
                    auto _gil = release_gil();
                    self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::SwipeItems>().SetAt(param0, param1);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SwipeItems_get_Mode(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.SwipeItems", L"Mode");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::SwipeItems>().Mode();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SwipeItems_put_Mode(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.SwipeItems", L"Mode");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::SwipeMode>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::SwipeItems>().Mode(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SwipeItems_get_Size(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.SwipeItems", L"Size");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::SwipeItems>().Size();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SwipeItems_get_ModeProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.SwipeItems", L"ModeProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::SwipeItems::ModeProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SwipeItems(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::SwipeItems>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SwipeItems(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::SwipeItems>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _iterator_SwipeItems(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self) noexcept
    {
        try
        {
            return py::convert([&]()
            {
                auto _gil = py::release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::SwipeItems>().First();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static Py_ssize_t _seq_length_SwipeItems(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self) noexcept
    {
        try
        {
            auto _gil = py::release_gil();
            return static_cast<Py_ssize_t>(self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::SwipeItems>().Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _seq_item_SwipeItems(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, Py_ssize_t i) noexcept
    {
        try
        {
            return py::convert([&]()
            {
                auto _gil = py::release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::SwipeItems>().GetAt(static_cast<uint32_t>(i));
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _seq_subscript_SwipeItems(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* slice) noexcept
    {
        try
        {
            if (PyIndex_Check(slice))
            {
                pyobj_handle index{PyNumber_Index(slice)};

                if (!index)
                {
                    return nullptr;
                }

                auto i = PyNumber_AsSsize_t(index.get(), PyExc_IndexError);

                if (i == -1 && PyErr_Occurred())
                {
                    return nullptr;
                }

                return _seq_item_SwipeItems(self, i);
            }

            if (!PySlice_Check(slice))
            {
                PyErr_Format(PyExc_TypeError, "indices must be integers, not '%s'", Py_TYPE(slice)->tp_name);
            }

            Py_ssize_t start, stop, step, length;

            auto size = [&]()
            {
                auto _gil = py::release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::SwipeItems>().Size();
            }();
            if (PySlice_GetIndicesEx(slice, size, &start, &stop, &step, &length) < 0)
            {
                return nullptr;
            }

            if (step != 1)
            {
                PyErr_SetString(PyExc_NotImplementedError, "slices with step other than 1 are not implemented");
                return nullptr;
            }

            winrt::com_array<winrt::Microsoft::UI::Xaml::Controls::SwipeItem> items(static_cast<uint32_t>(length), empty_instance<winrt::Microsoft::UI::Xaml::Controls::SwipeItem>::get());

            auto count = [&]()
            {
                auto _gil = py::release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::SwipeItems>().GetMany(static_cast<uint32_t>(start), items);
            }();

            if (count != static_cast<uint32_t>(length))
            {
                PyErr_Format(PyExc_RuntimeError, "returned count %d did not match requested length %zd", count, length);
                return nullptr;
            }

            return convert(items);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int _seq_assign_SwipeItems(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, Py_ssize_t i, PyObject* value) noexcept
    {
        try
        {
            if (!value)
            {
                auto _gil = py::release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::SwipeItems>().RemoveAt(static_cast<uint32_t>(i));
            }
            else
            {
                auto _value = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::SwipeItem>(value);
                {
                    auto _gil = py::release_gil();
                    self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::SwipeItems>().SetAt(static_cast<uint32_t>(i), _value);
                }
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyMethodDef _methods_SwipeItems[] = {
        { "append", reinterpret_cast<PyCFunction>(SwipeItems_Append), METH_VARARGS, nullptr },
        { "clear", reinterpret_cast<PyCFunction>(SwipeItems_Clear), METH_VARARGS, nullptr },
        { "first", reinterpret_cast<PyCFunction>(SwipeItems_First), METH_VARARGS, nullptr },
        { "get_at", reinterpret_cast<PyCFunction>(SwipeItems_GetAt), METH_VARARGS, nullptr },
        { "get_many", reinterpret_cast<PyCFunction>(SwipeItems_GetMany), METH_VARARGS, nullptr },
        { "get_view", reinterpret_cast<PyCFunction>(SwipeItems_GetView), METH_VARARGS, nullptr },
        { "index_of", reinterpret_cast<PyCFunction>(SwipeItems_IndexOf), METH_VARARGS, nullptr },
        { "insert_at", reinterpret_cast<PyCFunction>(SwipeItems_InsertAt), METH_VARARGS, nullptr },
        { "remove_at", reinterpret_cast<PyCFunction>(SwipeItems_RemoveAt), METH_VARARGS, nullptr },
        { "remove_at_end", reinterpret_cast<PyCFunction>(SwipeItems_RemoveAtEnd), METH_VARARGS, nullptr },
        { "replace_all", reinterpret_cast<PyCFunction>(SwipeItems_ReplaceAll), METH_VARARGS, nullptr },
        { "set_at", reinterpret_cast<PyCFunction>(SwipeItems_SetAt), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_SwipeItems, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SwipeItems), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_SwipeItems[] = {
        { "mode", reinterpret_cast<getter>(SwipeItems_get_Mode), reinterpret_cast<setter>(SwipeItems_put_Mode), nullptr, nullptr },
        { "size", reinterpret_cast<getter>(SwipeItems_get_Size), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_SwipeItems[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_SwipeItems) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SwipeItems) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SwipeItems) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SwipeItems) },
        { Py_tp_iter, reinterpret_cast<void*>(_iterator_SwipeItems) },
        { Py_sq_length, reinterpret_cast<void*>(_seq_length_SwipeItems) },
        { Py_sq_item, reinterpret_cast<void*>(_seq_item_SwipeItems) },
        { Py_mp_subscript, reinterpret_cast<void*>(_seq_subscript_SwipeItems) },
        { Py_sq_ass_item, reinterpret_cast<void*>(_seq_assign_SwipeItems) },
        { }};

    static PyType_Spec type_spec_SwipeItems = {
        "winui2._winui2_microsoft_ui_xaml_controls.SwipeItems",
        sizeof(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_SwipeItems};

    static PyGetSetDef getset_SwipeItems_Static[] = {
        { "mode_property", reinterpret_cast<getter>(SwipeItems_get_ModeProperty), nullptr, nullptr, nullptr },
        { }};

    static PyMethodDef methods_SwipeItems_Static[] = {
        { }};

    static PyType_Slot type_slots_SwipeItems_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_SwipeItems_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_SwipeItems_Static) },
        { }
    };

    static PyType_Spec type_spec_SwipeItems_Static = {
        "winui2._winui2_microsoft_ui_xaml_controls.SwipeItems_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_SwipeItems_Static};

    // ----- SymbolIconSource class --------------------

    struct PyWinrtSymbolIconSource;
    using BasePyWinrtSymbolIconSource = winrt::Microsoft::UI::Xaml::Controls::SymbolIconSourceT<PyWinrtSymbolIconSource, py::IPywinrtObject>;

    struct PyWinrtSymbolIconSource : py::py_obj_ref, BasePyWinrtSymbolIconSource
    {
        PyWinrtSymbolIconSource(PyObject* py_obj) : py::py_obj_ref(py_obj), BasePyWinrtSymbolIconSource() {}

        int32_t __stdcall GetPyObject(PyObject*& obj) override
        {
            obj = py::py_obj_ref::get_py_obj();
            return 0;
        }

        int32_t __stdcall GetComposableInner(winrt::Windows::Foundation::IInspectable& inner) override
        {
            inner = m_inner;
            return winrt::impl::error_ok;
        }

        static void toggle_reference(PyWinrtSymbolIconSource* instance, bool is_last_reference)
        {
            py::py_obj_ref::toggle_reference(instance, is_last_reference);
        }

        int32_t query_interface_tearoff(winrt::guid const& id, void** result) const noexcept override
        {
            return py::py_obj_ref::query_interface_tearoff(id, result);
        }

        std::vector<winrt::guid> get_iids_tearoff() const noexcept override
        {
            return py::py_obj_ref::get_iids_tearoff();
        }
    };

    static PyObject* _new_SymbolIconSource(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_GET_SIZE(args);

        auto self_type = get_python_type_for<winrt::Microsoft::UI::Xaml::Controls::SymbolIconSource>();
        if (!self_type)
        {
            return nullptr;
        }

        if (arg_count == 0)
        {
            try
            {
                if (type != self_type)
                {
                    py::pyobj_handle self{type->tp_alloc(type, 0)};
                    if (!self)
                    {
                        return nullptr;
                    }

                    std::construct_at(&reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj, nullptr);

                    auto obj_impl = winrt::make_self<PyWinrtSymbolIconSource>(self.get());

                    auto obj = py::make_py_obj<PyWinrtSymbolIconSource>(obj_impl, type, self.get());
                    if (!obj)
                    {
                        return nullptr;
                    }

                    reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj = std::move(obj);

                    return self.detach();
                }

                winrt::Microsoft::UI::Xaml::Controls::SymbolIconSource instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_SymbolIconSource(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SymbolIconSource_get_Symbol(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.SymbolIconSource", L"Symbol");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::SymbolIconSource>().Symbol();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SymbolIconSource_put_Symbol(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.SymbolIconSource", L"Symbol");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::Symbol>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::SymbolIconSource>().Symbol(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SymbolIconSource_get_SymbolProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.SymbolIconSource", L"SymbolProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::SymbolIconSource::SymbolProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SymbolIconSource(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::SymbolIconSource>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SymbolIconSource(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::SymbolIconSource>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SymbolIconSource[] = {
        { "_assign_array_", _assign_array_SymbolIconSource, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SymbolIconSource), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_SymbolIconSource[] = {
        { "symbol", reinterpret_cast<getter>(SymbolIconSource_get_Symbol), reinterpret_cast<setter>(SymbolIconSource_put_Symbol), nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_SymbolIconSource[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_SymbolIconSource) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SymbolIconSource) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SymbolIconSource) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SymbolIconSource) },
        { }};

    static PyType_Spec type_spec_SymbolIconSource = {
        "winui2._winui2_microsoft_ui_xaml_controls.SymbolIconSource",
        sizeof(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_SymbolIconSource};

    static PyGetSetDef getset_SymbolIconSource_Static[] = {
        { "symbol_property", reinterpret_cast<getter>(SymbolIconSource_get_SymbolProperty), nullptr, nullptr, nullptr },
        { }};

    static PyMethodDef methods_SymbolIconSource_Static[] = {
        { }};

    static PyType_Slot type_slots_SymbolIconSource_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_SymbolIconSource_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_SymbolIconSource_Static) },
        { }
    };

    static PyType_Spec type_spec_SymbolIconSource_Static = {
        "winui2._winui2_microsoft_ui_xaml_controls.SymbolIconSource_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_SymbolIconSource_Static};

    // ----- TabView class --------------------

    struct PyWinrtTabView;
    using BasePyWinrtTabView = winrt::Microsoft::UI::Xaml::Controls::TabViewT<PyWinrtTabView, py::IPywinrtObject>;

    struct PyWinrtTabView : py::py_obj_ref, BasePyWinrtTabView
    {
        PyWinrtTabView(PyObject* py_obj) : py::py_obj_ref(py_obj), BasePyWinrtTabView() {}

        int32_t __stdcall GetPyObject(PyObject*& obj) override
        {
            obj = py::py_obj_ref::get_py_obj();
            return 0;
        }

        int32_t __stdcall GetComposableInner(winrt::Windows::Foundation::IInspectable& inner) override
        {
            inner = m_inner;
            return winrt::impl::error_ok;
        }

        static void toggle_reference(PyWinrtTabView* instance, bool is_last_reference)
        {
            py::py_obj_ref::toggle_reference(instance, is_last_reference);
        }

        int32_t query_interface_tearoff(winrt::guid const& id, void** result) const noexcept override
        {
            return py::py_obj_ref::query_interface_tearoff(id, result);
        }

        std::vector<winrt::guid> get_iids_tearoff() const noexcept override
        {
            return py::py_obj_ref::get_iids_tearoff();
        }
    };

    static PyObject* _new_TabView(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_GET_SIZE(args);

        auto self_type = get_python_type_for<winrt::Microsoft::UI::Xaml::Controls::TabView>();
        if (!self_type)
        {
            return nullptr;
        }

        if (arg_count == 0)
        {
            try
            {
                if (type != self_type)
                {
                    py::pyobj_handle self{type->tp_alloc(type, 0)};
                    if (!self)
                    {
                        return nullptr;
                    }

                    std::construct_at(&reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj, nullptr);

                    auto obj_impl = winrt::make_self<PyWinrtTabView>(self.get());

                    auto obj = py::make_py_obj<PyWinrtTabView>(obj_impl, type, self.get());
                    if (!obj)
                    {
                        return nullptr;
                    }

                    reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj = std::move(obj);

                    return self.detach();
                }

                winrt::Microsoft::UI::Xaml::Controls::TabView instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_TabView(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* TabView_ContainerFromIndex(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.TabView", L"ContainerFromIndex", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<int32_t>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::TabView>().ContainerFromIndex(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TabView_ContainerFromItem(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.TabView", L"ContainerFromItem", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::TabView>().ContainerFromItem(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TabView_get_TabWidthMode(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TabView", L"TabWidthMode");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::TabView>().TabWidthMode();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TabView_put_TabWidthMode(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TabView", L"TabWidthMode");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::TabViewWidthMode>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::TabView>().TabWidthMode(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TabView_get_TabStripHeaderTemplate(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TabView", L"TabStripHeaderTemplate");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::TabView>().TabStripHeaderTemplate();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TabView_put_TabStripHeaderTemplate(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TabView", L"TabStripHeaderTemplate");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::DataTemplate>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::TabView>().TabStripHeaderTemplate(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TabView_get_TabStripHeader(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TabView", L"TabStripHeader");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::TabView>().TabStripHeader();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TabView_put_TabStripHeader(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TabView", L"TabStripHeader");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::TabView>().TabStripHeader(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TabView_get_TabStripFooterTemplate(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TabView", L"TabStripFooterTemplate");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::TabView>().TabStripFooterTemplate();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TabView_put_TabStripFooterTemplate(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TabView", L"TabStripFooterTemplate");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::DataTemplate>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::TabView>().TabStripFooterTemplate(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TabView_get_TabStripFooter(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TabView", L"TabStripFooter");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::TabView>().TabStripFooter();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TabView_put_TabStripFooter(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TabView", L"TabStripFooter");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::TabView>().TabStripFooter(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TabView_get_TabItemsSource(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TabView", L"TabItemsSource");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::TabView>().TabItemsSource();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TabView_put_TabItemsSource(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TabView", L"TabItemsSource");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::TabView>().TabItemsSource(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TabView_get_TabItemTemplateSelector(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TabView", L"TabItemTemplateSelector");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::TabView>().TabItemTemplateSelector();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TabView_put_TabItemTemplateSelector(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TabView", L"TabItemTemplateSelector");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::DataTemplateSelector>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::TabView>().TabItemTemplateSelector(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TabView_get_TabItemTemplate(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TabView", L"TabItemTemplate");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::TabView>().TabItemTemplate();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TabView_put_TabItemTemplate(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TabView", L"TabItemTemplate");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::DataTemplate>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::TabView>().TabItemTemplate(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TabView_get_SelectedItem(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TabView", L"SelectedItem");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::TabView>().SelectedItem();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TabView_put_SelectedItem(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TabView", L"SelectedItem");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::TabView>().SelectedItem(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TabView_get_SelectedIndex(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TabView", L"SelectedIndex");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::TabView>().SelectedIndex();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TabView_put_SelectedIndex(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TabView", L"SelectedIndex");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<int32_t>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::TabView>().SelectedIndex(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TabView_get_IsAddTabButtonVisible(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TabView", L"IsAddTabButtonVisible");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::TabView>().IsAddTabButtonVisible();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TabView_put_IsAddTabButtonVisible(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TabView", L"IsAddTabButtonVisible");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::TabView>().IsAddTabButtonVisible(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TabView_get_CloseButtonOverlayMode(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TabView", L"CloseButtonOverlayMode");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::TabView>().CloseButtonOverlayMode();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TabView_put_CloseButtonOverlayMode(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TabView", L"CloseButtonOverlayMode");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::TabViewCloseButtonOverlayMode>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::TabView>().CloseButtonOverlayMode(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TabView_get_CanReorderTabs(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TabView", L"CanReorderTabs");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::TabView>().CanReorderTabs();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TabView_put_CanReorderTabs(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TabView", L"CanReorderTabs");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::TabView>().CanReorderTabs(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TabView_get_CanDragTabs(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TabView", L"CanDragTabs");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::TabView>().CanDragTabs();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TabView_put_CanDragTabs(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TabView", L"CanDragTabs");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::TabView>().CanDragTabs(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TabView_get_AllowDropTabs(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TabView", L"AllowDropTabs");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::TabView>().AllowDropTabs();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TabView_put_AllowDropTabs(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TabView", L"AllowDropTabs");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::TabView>().AllowDropTabs(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TabView_get_AddTabButtonCommandParameter(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TabView", L"AddTabButtonCommandParameter");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::TabView>().AddTabButtonCommandParameter();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TabView_put_AddTabButtonCommandParameter(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TabView", L"AddTabButtonCommandParameter");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::TabView>().AddTabButtonCommandParameter(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TabView_get_AddTabButtonCommand(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TabView", L"AddTabButtonCommand");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::TabView>().AddTabButtonCommand();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TabView_put_AddTabButtonCommand(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TabView", L"AddTabButtonCommand");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Input::ICommand>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::TabView>().AddTabButtonCommand(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TabView_get_TabItems(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TabView", L"TabItems");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::TabView>().TabItems();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TabView_get_AddTabButtonCommandParameterProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TabView", L"AddTabButtonCommandParameterProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::TabView::AddTabButtonCommandParameterProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TabView_get_AddTabButtonCommandProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TabView", L"AddTabButtonCommandProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::TabView::AddTabButtonCommandProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TabView_get_AllowDropTabsProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TabView", L"AllowDropTabsProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::TabView::AllowDropTabsProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TabView_get_CanDragTabsProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TabView", L"CanDragTabsProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::TabView::CanDragTabsProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TabView_get_CanReorderTabsProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TabView", L"CanReorderTabsProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::TabView::CanReorderTabsProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TabView_get_CloseButtonOverlayModeProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TabView", L"CloseButtonOverlayModeProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::TabView::CloseButtonOverlayModeProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TabView_get_IsAddTabButtonVisibleProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TabView", L"IsAddTabButtonVisibleProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::TabView::IsAddTabButtonVisibleProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TabView_get_SelectedIndexProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TabView", L"SelectedIndexProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::TabView::SelectedIndexProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TabView_get_SelectedItemProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TabView", L"SelectedItemProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::TabView::SelectedItemProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TabView_get_TabItemTemplateProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TabView", L"TabItemTemplateProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::TabView::TabItemTemplateProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TabView_get_TabItemTemplateSelectorProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TabView", L"TabItemTemplateSelectorProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::TabView::TabItemTemplateSelectorProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TabView_get_TabItemsProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TabView", L"TabItemsProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::TabView::TabItemsProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TabView_get_TabItemsSourceProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TabView", L"TabItemsSourceProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::TabView::TabItemsSourceProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TabView_get_TabStripFooterProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TabView", L"TabStripFooterProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::TabView::TabStripFooterProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TabView_get_TabStripFooterTemplateProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TabView", L"TabStripFooterTemplateProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::TabView::TabStripFooterTemplateProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TabView_get_TabStripHeaderProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TabView", L"TabStripHeaderProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::TabView::TabStripHeaderProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TabView_get_TabStripHeaderTemplateProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TabView", L"TabStripHeaderTemplateProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::TabView::TabStripHeaderTemplateProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TabView_get_TabWidthModeProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TabView", L"TabWidthModeProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::TabView::TabWidthModeProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TabView_add_AddTabButtonClick(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.TabView", L"AddTabButtonClick");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Xaml::Controls::TabView, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::TabView>().AddTabButtonClick(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TabView_remove_AddTabButtonClick(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.TabView", L"AddTabButtonClick");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::TabView>().AddTabButtonClick(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TabView_add_SelectionChanged(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.TabView", L"SelectionChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::SelectionChangedEventHandler>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::TabView>().SelectionChanged(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TabView_remove_SelectionChanged(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.TabView", L"SelectionChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::TabView>().SelectionChanged(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TabView_add_TabCloseRequested(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.TabView", L"TabCloseRequested");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Xaml::Controls::TabView, winrt::Microsoft::UI::Xaml::Controls::TabViewTabCloseRequestedEventArgs>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::TabView>().TabCloseRequested(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TabView_remove_TabCloseRequested(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.TabView", L"TabCloseRequested");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::TabView>().TabCloseRequested(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TabView_add_TabDragCompleted(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.TabView", L"TabDragCompleted");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Xaml::Controls::TabView, winrt::Microsoft::UI::Xaml::Controls::TabViewTabDragCompletedEventArgs>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::TabView>().TabDragCompleted(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TabView_remove_TabDragCompleted(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.TabView", L"TabDragCompleted");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::TabView>().TabDragCompleted(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TabView_add_TabDragStarting(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.TabView", L"TabDragStarting");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Xaml::Controls::TabView, winrt::Microsoft::UI::Xaml::Controls::TabViewTabDragStartingEventArgs>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::TabView>().TabDragStarting(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TabView_remove_TabDragStarting(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.TabView", L"TabDragStarting");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::TabView>().TabDragStarting(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TabView_add_TabDroppedOutside(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.TabView", L"TabDroppedOutside");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Xaml::Controls::TabView, winrt::Microsoft::UI::Xaml::Controls::TabViewTabDroppedOutsideEventArgs>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::TabView>().TabDroppedOutside(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TabView_remove_TabDroppedOutside(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.TabView", L"TabDroppedOutside");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::TabView>().TabDroppedOutside(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TabView_add_TabItemsChanged(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.TabView", L"TabItemsChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Xaml::Controls::TabView, winrt::Windows::Foundation::Collections::IVectorChangedEventArgs>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::TabView>().TabItemsChanged(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TabView_remove_TabItemsChanged(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.TabView", L"TabItemsChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::TabView>().TabItemsChanged(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TabView_add_TabStripDragOver(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.TabView", L"TabStripDragOver");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::DragEventHandler>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::TabView>().TabStripDragOver(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TabView_remove_TabStripDragOver(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.TabView", L"TabStripDragOver");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::TabView>().TabStripDragOver(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TabView_add_TabStripDrop(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.TabView", L"TabStripDrop");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::DragEventHandler>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::TabView>().TabStripDrop(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TabView_remove_TabStripDrop(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.TabView", L"TabStripDrop");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::TabView>().TabStripDrop(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_TabView(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::TabView>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_TabView(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::TabView>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_TabView[] = {
        { "container_from_index", reinterpret_cast<PyCFunction>(TabView_ContainerFromIndex), METH_VARARGS, nullptr },
        { "container_from_item", reinterpret_cast<PyCFunction>(TabView_ContainerFromItem), METH_VARARGS, nullptr },
        { "add_add_tab_button_click", reinterpret_cast<PyCFunction>(TabView_add_AddTabButtonClick), METH_O, nullptr },
        { "remove_add_tab_button_click", reinterpret_cast<PyCFunction>(TabView_remove_AddTabButtonClick), METH_O, nullptr },
        { "add_selection_changed", reinterpret_cast<PyCFunction>(TabView_add_SelectionChanged), METH_O, nullptr },
        { "remove_selection_changed", reinterpret_cast<PyCFunction>(TabView_remove_SelectionChanged), METH_O, nullptr },
        { "add_tab_close_requested", reinterpret_cast<PyCFunction>(TabView_add_TabCloseRequested), METH_O, nullptr },
        { "remove_tab_close_requested", reinterpret_cast<PyCFunction>(TabView_remove_TabCloseRequested), METH_O, nullptr },
        { "add_tab_drag_completed", reinterpret_cast<PyCFunction>(TabView_add_TabDragCompleted), METH_O, nullptr },
        { "remove_tab_drag_completed", reinterpret_cast<PyCFunction>(TabView_remove_TabDragCompleted), METH_O, nullptr },
        { "add_tab_drag_starting", reinterpret_cast<PyCFunction>(TabView_add_TabDragStarting), METH_O, nullptr },
        { "remove_tab_drag_starting", reinterpret_cast<PyCFunction>(TabView_remove_TabDragStarting), METH_O, nullptr },
        { "add_tab_dropped_outside", reinterpret_cast<PyCFunction>(TabView_add_TabDroppedOutside), METH_O, nullptr },
        { "remove_tab_dropped_outside", reinterpret_cast<PyCFunction>(TabView_remove_TabDroppedOutside), METH_O, nullptr },
        { "add_tab_items_changed", reinterpret_cast<PyCFunction>(TabView_add_TabItemsChanged), METH_O, nullptr },
        { "remove_tab_items_changed", reinterpret_cast<PyCFunction>(TabView_remove_TabItemsChanged), METH_O, nullptr },
        { "add_tab_strip_drag_over", reinterpret_cast<PyCFunction>(TabView_add_TabStripDragOver), METH_O, nullptr },
        { "remove_tab_strip_drag_over", reinterpret_cast<PyCFunction>(TabView_remove_TabStripDragOver), METH_O, nullptr },
        { "add_tab_strip_drop", reinterpret_cast<PyCFunction>(TabView_add_TabStripDrop), METH_O, nullptr },
        { "remove_tab_strip_drop", reinterpret_cast<PyCFunction>(TabView_remove_TabStripDrop), METH_O, nullptr },
        { "_assign_array_", _assign_array_TabView, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_TabView), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_TabView[] = {
        { "tab_width_mode", reinterpret_cast<getter>(TabView_get_TabWidthMode), reinterpret_cast<setter>(TabView_put_TabWidthMode), nullptr, nullptr },
        { "tab_strip_header_template", reinterpret_cast<getter>(TabView_get_TabStripHeaderTemplate), reinterpret_cast<setter>(TabView_put_TabStripHeaderTemplate), nullptr, nullptr },
        { "tab_strip_header", reinterpret_cast<getter>(TabView_get_TabStripHeader), reinterpret_cast<setter>(TabView_put_TabStripHeader), nullptr, nullptr },
        { "tab_strip_footer_template", reinterpret_cast<getter>(TabView_get_TabStripFooterTemplate), reinterpret_cast<setter>(TabView_put_TabStripFooterTemplate), nullptr, nullptr },
        { "tab_strip_footer", reinterpret_cast<getter>(TabView_get_TabStripFooter), reinterpret_cast<setter>(TabView_put_TabStripFooter), nullptr, nullptr },
        { "tab_items_source", reinterpret_cast<getter>(TabView_get_TabItemsSource), reinterpret_cast<setter>(TabView_put_TabItemsSource), nullptr, nullptr },
        { "tab_item_template_selector", reinterpret_cast<getter>(TabView_get_TabItemTemplateSelector), reinterpret_cast<setter>(TabView_put_TabItemTemplateSelector), nullptr, nullptr },
        { "tab_item_template", reinterpret_cast<getter>(TabView_get_TabItemTemplate), reinterpret_cast<setter>(TabView_put_TabItemTemplate), nullptr, nullptr },
        { "selected_item", reinterpret_cast<getter>(TabView_get_SelectedItem), reinterpret_cast<setter>(TabView_put_SelectedItem), nullptr, nullptr },
        { "selected_index", reinterpret_cast<getter>(TabView_get_SelectedIndex), reinterpret_cast<setter>(TabView_put_SelectedIndex), nullptr, nullptr },
        { "is_add_tab_button_visible", reinterpret_cast<getter>(TabView_get_IsAddTabButtonVisible), reinterpret_cast<setter>(TabView_put_IsAddTabButtonVisible), nullptr, nullptr },
        { "close_button_overlay_mode", reinterpret_cast<getter>(TabView_get_CloseButtonOverlayMode), reinterpret_cast<setter>(TabView_put_CloseButtonOverlayMode), nullptr, nullptr },
        { "can_reorder_tabs", reinterpret_cast<getter>(TabView_get_CanReorderTabs), reinterpret_cast<setter>(TabView_put_CanReorderTabs), nullptr, nullptr },
        { "can_drag_tabs", reinterpret_cast<getter>(TabView_get_CanDragTabs), reinterpret_cast<setter>(TabView_put_CanDragTabs), nullptr, nullptr },
        { "allow_drop_tabs", reinterpret_cast<getter>(TabView_get_AllowDropTabs), reinterpret_cast<setter>(TabView_put_AllowDropTabs), nullptr, nullptr },
        { "add_tab_button_command_parameter", reinterpret_cast<getter>(TabView_get_AddTabButtonCommandParameter), reinterpret_cast<setter>(TabView_put_AddTabButtonCommandParameter), nullptr, nullptr },
        { "add_tab_button_command", reinterpret_cast<getter>(TabView_get_AddTabButtonCommand), reinterpret_cast<setter>(TabView_put_AddTabButtonCommand), nullptr, nullptr },
        { "tab_items", reinterpret_cast<getter>(TabView_get_TabItems), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_TabView[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_TabView) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_TabView) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_TabView) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_TabView) },
        { }};

    static PyType_Spec type_spec_TabView = {
        "winui2._winui2_microsoft_ui_xaml_controls.TabView",
        sizeof(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_TabView};

    static PyGetSetDef getset_TabView_Static[] = {
        { "add_tab_button_command_parameter_property", reinterpret_cast<getter>(TabView_get_AddTabButtonCommandParameterProperty), nullptr, nullptr, nullptr },
        { "add_tab_button_command_property", reinterpret_cast<getter>(TabView_get_AddTabButtonCommandProperty), nullptr, nullptr, nullptr },
        { "allow_drop_tabs_property", reinterpret_cast<getter>(TabView_get_AllowDropTabsProperty), nullptr, nullptr, nullptr },
        { "can_drag_tabs_property", reinterpret_cast<getter>(TabView_get_CanDragTabsProperty), nullptr, nullptr, nullptr },
        { "can_reorder_tabs_property", reinterpret_cast<getter>(TabView_get_CanReorderTabsProperty), nullptr, nullptr, nullptr },
        { "close_button_overlay_mode_property", reinterpret_cast<getter>(TabView_get_CloseButtonOverlayModeProperty), nullptr, nullptr, nullptr },
        { "is_add_tab_button_visible_property", reinterpret_cast<getter>(TabView_get_IsAddTabButtonVisibleProperty), nullptr, nullptr, nullptr },
        { "selected_index_property", reinterpret_cast<getter>(TabView_get_SelectedIndexProperty), nullptr, nullptr, nullptr },
        { "selected_item_property", reinterpret_cast<getter>(TabView_get_SelectedItemProperty), nullptr, nullptr, nullptr },
        { "tab_item_template_property", reinterpret_cast<getter>(TabView_get_TabItemTemplateProperty), nullptr, nullptr, nullptr },
        { "tab_item_template_selector_property", reinterpret_cast<getter>(TabView_get_TabItemTemplateSelectorProperty), nullptr, nullptr, nullptr },
        { "tab_items_property", reinterpret_cast<getter>(TabView_get_TabItemsProperty), nullptr, nullptr, nullptr },
        { "tab_items_source_property", reinterpret_cast<getter>(TabView_get_TabItemsSourceProperty), nullptr, nullptr, nullptr },
        { "tab_strip_footer_property", reinterpret_cast<getter>(TabView_get_TabStripFooterProperty), nullptr, nullptr, nullptr },
        { "tab_strip_footer_template_property", reinterpret_cast<getter>(TabView_get_TabStripFooterTemplateProperty), nullptr, nullptr, nullptr },
        { "tab_strip_header_property", reinterpret_cast<getter>(TabView_get_TabStripHeaderProperty), nullptr, nullptr, nullptr },
        { "tab_strip_header_template_property", reinterpret_cast<getter>(TabView_get_TabStripHeaderTemplateProperty), nullptr, nullptr, nullptr },
        { "tab_width_mode_property", reinterpret_cast<getter>(TabView_get_TabWidthModeProperty), nullptr, nullptr, nullptr },
        { }};

    static PyMethodDef methods_TabView_Static[] = {
        { }};

    static PyType_Slot type_slots_TabView_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_TabView_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_TabView_Static) },
        { }
    };

    static PyType_Spec type_spec_TabView_Static = {
        "winui2._winui2_microsoft_ui_xaml_controls.TabView_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_TabView_Static};

    // ----- TabViewItem class --------------------

    struct PyWinrtTabViewItem;
    using BasePyWinrtTabViewItem = winrt::Microsoft::UI::Xaml::Controls::TabViewItemT<PyWinrtTabViewItem, py::IPywinrtObject>;

    struct PyWinrtTabViewItem : py::py_obj_ref, BasePyWinrtTabViewItem
    {
        PyWinrtTabViewItem(PyObject* py_obj) : py::py_obj_ref(py_obj), BasePyWinrtTabViewItem() {}

        int32_t __stdcall GetPyObject(PyObject*& obj) override
        {
            obj = py::py_obj_ref::get_py_obj();
            return 0;
        }

        int32_t __stdcall GetComposableInner(winrt::Windows::Foundation::IInspectable& inner) override
        {
            inner = m_inner;
            return winrt::impl::error_ok;
        }

        static void toggle_reference(PyWinrtTabViewItem* instance, bool is_last_reference)
        {
            py::py_obj_ref::toggle_reference(instance, is_last_reference);
        }

        int32_t query_interface_tearoff(winrt::guid const& id, void** result) const noexcept override
        {
            return py::py_obj_ref::query_interface_tearoff(id, result);
        }

        std::vector<winrt::guid> get_iids_tearoff() const noexcept override
        {
            return py::py_obj_ref::get_iids_tearoff();
        }
    };

    static PyObject* _new_TabViewItem(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_GET_SIZE(args);

        auto self_type = get_python_type_for<winrt::Microsoft::UI::Xaml::Controls::TabViewItem>();
        if (!self_type)
        {
            return nullptr;
        }

        if (arg_count == 0)
        {
            try
            {
                if (type != self_type)
                {
                    py::pyobj_handle self{type->tp_alloc(type, 0)};
                    if (!self)
                    {
                        return nullptr;
                    }

                    std::construct_at(&reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj, nullptr);

                    auto obj_impl = winrt::make_self<PyWinrtTabViewItem>(self.get());

                    auto obj = py::make_py_obj<PyWinrtTabViewItem>(obj_impl, type, self.get());
                    if (!obj)
                    {
                        return nullptr;
                    }

                    reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj = std::move(obj);

                    return self.detach();
                }

                winrt::Microsoft::UI::Xaml::Controls::TabViewItem instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_TabViewItem(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* TabViewItem_get_IsClosable(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TabViewItem", L"IsClosable");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::TabViewItem>().IsClosable();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TabViewItem_put_IsClosable(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TabViewItem", L"IsClosable");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::TabViewItem>().IsClosable(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TabViewItem_get_IconSource(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TabViewItem", L"IconSource");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::TabViewItem>().IconSource();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TabViewItem_put_IconSource(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TabViewItem", L"IconSource");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::IconSource>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::TabViewItem>().IconSource(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TabViewItem_get_HeaderTemplate(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TabViewItem", L"HeaderTemplate");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::TabViewItem>().HeaderTemplate();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TabViewItem_put_HeaderTemplate(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TabViewItem", L"HeaderTemplate");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::DataTemplate>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::TabViewItem>().HeaderTemplate(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TabViewItem_get_Header(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TabViewItem", L"Header");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::TabViewItem>().Header();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TabViewItem_put_Header(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TabViewItem", L"Header");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::TabViewItem>().Header(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TabViewItem_get_TabViewTemplateSettings(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TabViewItem", L"TabViewTemplateSettings");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::TabViewItem>().TabViewTemplateSettings();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TabViewItem_get_HeaderProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TabViewItem", L"HeaderProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::TabViewItem::HeaderProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TabViewItem_get_HeaderTemplateProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TabViewItem", L"HeaderTemplateProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::TabViewItem::HeaderTemplateProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TabViewItem_get_IconSourceProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TabViewItem", L"IconSourceProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::TabViewItem::IconSourceProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TabViewItem_get_IsClosableProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TabViewItem", L"IsClosableProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::TabViewItem::IsClosableProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TabViewItem_get_TabViewTemplateSettingsProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TabViewItem", L"TabViewTemplateSettingsProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::TabViewItem::TabViewTemplateSettingsProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TabViewItem_add_CloseRequested(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.TabViewItem", L"CloseRequested");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Xaml::Controls::TabViewItem, winrt::Microsoft::UI::Xaml::Controls::TabViewTabCloseRequestedEventArgs>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::TabViewItem>().CloseRequested(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TabViewItem_remove_CloseRequested(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.TabViewItem", L"CloseRequested");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::TabViewItem>().CloseRequested(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_TabViewItem(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::TabViewItem>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_TabViewItem(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::TabViewItem>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_TabViewItem[] = {
        { "add_close_requested", reinterpret_cast<PyCFunction>(TabViewItem_add_CloseRequested), METH_O, nullptr },
        { "remove_close_requested", reinterpret_cast<PyCFunction>(TabViewItem_remove_CloseRequested), METH_O, nullptr },
        { "_assign_array_", _assign_array_TabViewItem, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_TabViewItem), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_TabViewItem[] = {
        { "is_closable", reinterpret_cast<getter>(TabViewItem_get_IsClosable), reinterpret_cast<setter>(TabViewItem_put_IsClosable), nullptr, nullptr },
        { "icon_source", reinterpret_cast<getter>(TabViewItem_get_IconSource), reinterpret_cast<setter>(TabViewItem_put_IconSource), nullptr, nullptr },
        { "header_template", reinterpret_cast<getter>(TabViewItem_get_HeaderTemplate), reinterpret_cast<setter>(TabViewItem_put_HeaderTemplate), nullptr, nullptr },
        { "header", reinterpret_cast<getter>(TabViewItem_get_Header), reinterpret_cast<setter>(TabViewItem_put_Header), nullptr, nullptr },
        { "tab_view_template_settings", reinterpret_cast<getter>(TabViewItem_get_TabViewTemplateSettings), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_TabViewItem[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_TabViewItem) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_TabViewItem) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_TabViewItem) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_TabViewItem) },
        { }};

    static PyType_Spec type_spec_TabViewItem = {
        "winui2._winui2_microsoft_ui_xaml_controls.TabViewItem",
        sizeof(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_TabViewItem};

    static PyGetSetDef getset_TabViewItem_Static[] = {
        { "header_property", reinterpret_cast<getter>(TabViewItem_get_HeaderProperty), nullptr, nullptr, nullptr },
        { "header_template_property", reinterpret_cast<getter>(TabViewItem_get_HeaderTemplateProperty), nullptr, nullptr, nullptr },
        { "icon_source_property", reinterpret_cast<getter>(TabViewItem_get_IconSourceProperty), nullptr, nullptr, nullptr },
        { "is_closable_property", reinterpret_cast<getter>(TabViewItem_get_IsClosableProperty), nullptr, nullptr, nullptr },
        { "tab_view_template_settings_property", reinterpret_cast<getter>(TabViewItem_get_TabViewTemplateSettingsProperty), nullptr, nullptr, nullptr },
        { }};

    static PyMethodDef methods_TabViewItem_Static[] = {
        { }};

    static PyType_Slot type_slots_TabViewItem_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_TabViewItem_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_TabViewItem_Static) },
        { }
    };

    static PyType_Spec type_spec_TabViewItem_Static = {
        "winui2._winui2_microsoft_ui_xaml_controls.TabViewItem_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_TabViewItem_Static};

    // ----- TabViewItemTemplateSettings class --------------------

    struct PyWinrtTabViewItemTemplateSettings;
    using BasePyWinrtTabViewItemTemplateSettings = winrt::Microsoft::UI::Xaml::Controls::TabViewItemTemplateSettingsT<PyWinrtTabViewItemTemplateSettings, py::IPywinrtObject>;

    struct PyWinrtTabViewItemTemplateSettings : py::py_obj_ref, BasePyWinrtTabViewItemTemplateSettings
    {
        PyWinrtTabViewItemTemplateSettings(PyObject* py_obj) : py::py_obj_ref(py_obj), BasePyWinrtTabViewItemTemplateSettings() {}

        int32_t __stdcall GetPyObject(PyObject*& obj) override
        {
            obj = py::py_obj_ref::get_py_obj();
            return 0;
        }

        int32_t __stdcall GetComposableInner(winrt::Windows::Foundation::IInspectable& inner) override
        {
            inner = m_inner;
            return winrt::impl::error_ok;
        }

        static void toggle_reference(PyWinrtTabViewItemTemplateSettings* instance, bool is_last_reference)
        {
            py::py_obj_ref::toggle_reference(instance, is_last_reference);
        }

        int32_t query_interface_tearoff(winrt::guid const& id, void** result) const noexcept override
        {
            return py::py_obj_ref::query_interface_tearoff(id, result);
        }

        std::vector<winrt::guid> get_iids_tearoff() const noexcept override
        {
            return py::py_obj_ref::get_iids_tearoff();
        }
    };

    static PyObject* _new_TabViewItemTemplateSettings(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_GET_SIZE(args);

        auto self_type = get_python_type_for<winrt::Microsoft::UI::Xaml::Controls::TabViewItemTemplateSettings>();
        if (!self_type)
        {
            return nullptr;
        }

        if (arg_count == 0)
        {
            try
            {
                if (type != self_type)
                {
                    py::pyobj_handle self{type->tp_alloc(type, 0)};
                    if (!self)
                    {
                        return nullptr;
                    }

                    std::construct_at(&reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj, nullptr);

                    auto obj_impl = winrt::make_self<PyWinrtTabViewItemTemplateSettings>(self.get());

                    auto obj = py::make_py_obj<PyWinrtTabViewItemTemplateSettings>(obj_impl, type, self.get());
                    if (!obj)
                    {
                        return nullptr;
                    }

                    reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj = std::move(obj);

                    return self.detach();
                }

                winrt::Microsoft::UI::Xaml::Controls::TabViewItemTemplateSettings instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_TabViewItemTemplateSettings(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* TabViewItemTemplateSettings_get_IconElement(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TabViewItemTemplateSettings", L"IconElement");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::TabViewItemTemplateSettings>().IconElement();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TabViewItemTemplateSettings_put_IconElement(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TabViewItemTemplateSettings", L"IconElement");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::IconElement>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::TabViewItemTemplateSettings>().IconElement(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TabViewItemTemplateSettings_get_TabGeometry(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TabViewItemTemplateSettings", L"TabGeometry");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::TabViewItemTemplateSettings>().TabGeometry();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TabViewItemTemplateSettings_put_TabGeometry(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TabViewItemTemplateSettings", L"TabGeometry");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Media::Geometry>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::TabViewItemTemplateSettings>().TabGeometry(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TabViewItemTemplateSettings_get_IconElementProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TabViewItemTemplateSettings", L"IconElementProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::TabViewItemTemplateSettings::IconElementProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TabViewItemTemplateSettings_get_TabGeometryProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TabViewItemTemplateSettings", L"TabGeometryProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::TabViewItemTemplateSettings::TabGeometryProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_TabViewItemTemplateSettings(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::TabViewItemTemplateSettings>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_TabViewItemTemplateSettings(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::TabViewItemTemplateSettings>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_TabViewItemTemplateSettings[] = {
        { "_assign_array_", _assign_array_TabViewItemTemplateSettings, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_TabViewItemTemplateSettings), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_TabViewItemTemplateSettings[] = {
        { "icon_element", reinterpret_cast<getter>(TabViewItemTemplateSettings_get_IconElement), reinterpret_cast<setter>(TabViewItemTemplateSettings_put_IconElement), nullptr, nullptr },
        { "tab_geometry", reinterpret_cast<getter>(TabViewItemTemplateSettings_get_TabGeometry), reinterpret_cast<setter>(TabViewItemTemplateSettings_put_TabGeometry), nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_TabViewItemTemplateSettings[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_TabViewItemTemplateSettings) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_TabViewItemTemplateSettings) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_TabViewItemTemplateSettings) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_TabViewItemTemplateSettings) },
        { }};

    static PyType_Spec type_spec_TabViewItemTemplateSettings = {
        "winui2._winui2_microsoft_ui_xaml_controls.TabViewItemTemplateSettings",
        sizeof(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_TabViewItemTemplateSettings};

    static PyGetSetDef getset_TabViewItemTemplateSettings_Static[] = {
        { "icon_element_property", reinterpret_cast<getter>(TabViewItemTemplateSettings_get_IconElementProperty), nullptr, nullptr, nullptr },
        { "tab_geometry_property", reinterpret_cast<getter>(TabViewItemTemplateSettings_get_TabGeometryProperty), nullptr, nullptr, nullptr },
        { }};

    static PyMethodDef methods_TabViewItemTemplateSettings_Static[] = {
        { }};

    static PyType_Slot type_slots_TabViewItemTemplateSettings_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_TabViewItemTemplateSettings_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_TabViewItemTemplateSettings_Static) },
        { }
    };

    static PyType_Spec type_spec_TabViewItemTemplateSettings_Static = {
        "winui2._winui2_microsoft_ui_xaml_controls.TabViewItemTemplateSettings_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_TabViewItemTemplateSettings_Static};

    // ----- TabViewTabCloseRequestedEventArgs class --------------------

    static PyObject* _new_TabViewTabCloseRequestedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Xaml::Controls::TabViewTabCloseRequestedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Xaml::Controls::TabViewTabCloseRequestedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_TabViewTabCloseRequestedEventArgs(py::wrapper::Microsoft::UI::Xaml::Controls::TabViewTabCloseRequestedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* TabViewTabCloseRequestedEventArgs_get_Item(py::wrapper::Microsoft::UI::Xaml::Controls::TabViewTabCloseRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TabViewTabCloseRequestedEventArgs", L"Item");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Item();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TabViewTabCloseRequestedEventArgs_get_Tab(py::wrapper::Microsoft::UI::Xaml::Controls::TabViewTabCloseRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TabViewTabCloseRequestedEventArgs", L"Tab");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Tab();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_TabViewTabCloseRequestedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::TabViewTabCloseRequestedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_TabViewTabCloseRequestedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::TabViewTabCloseRequestedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_TabViewTabCloseRequestedEventArgs[] = {
        { "_assign_array_", _assign_array_TabViewTabCloseRequestedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_TabViewTabCloseRequestedEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_TabViewTabCloseRequestedEventArgs[] = {
        { "item", reinterpret_cast<getter>(TabViewTabCloseRequestedEventArgs_get_Item), nullptr, nullptr, nullptr },
        { "tab", reinterpret_cast<getter>(TabViewTabCloseRequestedEventArgs_get_Tab), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_TabViewTabCloseRequestedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_TabViewTabCloseRequestedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_TabViewTabCloseRequestedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_TabViewTabCloseRequestedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_TabViewTabCloseRequestedEventArgs) },
        { }};

    static PyType_Spec type_spec_TabViewTabCloseRequestedEventArgs = {
        "winui2._winui2_microsoft_ui_xaml_controls.TabViewTabCloseRequestedEventArgs",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Controls::TabViewTabCloseRequestedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TabViewTabCloseRequestedEventArgs};

    // ----- TabViewTabDragCompletedEventArgs class --------------------

    static PyObject* _new_TabViewTabDragCompletedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Xaml::Controls::TabViewTabDragCompletedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Xaml::Controls::TabViewTabDragCompletedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_TabViewTabDragCompletedEventArgs(py::wrapper::Microsoft::UI::Xaml::Controls::TabViewTabDragCompletedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* TabViewTabDragCompletedEventArgs_get_DropResult(py::wrapper::Microsoft::UI::Xaml::Controls::TabViewTabDragCompletedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TabViewTabDragCompletedEventArgs", L"DropResult");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.DropResult();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TabViewTabDragCompletedEventArgs_get_Item(py::wrapper::Microsoft::UI::Xaml::Controls::TabViewTabDragCompletedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TabViewTabDragCompletedEventArgs", L"Item");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Item();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TabViewTabDragCompletedEventArgs_get_Tab(py::wrapper::Microsoft::UI::Xaml::Controls::TabViewTabDragCompletedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TabViewTabDragCompletedEventArgs", L"Tab");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Tab();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_TabViewTabDragCompletedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::TabViewTabDragCompletedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_TabViewTabDragCompletedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::TabViewTabDragCompletedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_TabViewTabDragCompletedEventArgs[] = {
        { "_assign_array_", _assign_array_TabViewTabDragCompletedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_TabViewTabDragCompletedEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_TabViewTabDragCompletedEventArgs[] = {
        { "drop_result", reinterpret_cast<getter>(TabViewTabDragCompletedEventArgs_get_DropResult), nullptr, nullptr, nullptr },
        { "item", reinterpret_cast<getter>(TabViewTabDragCompletedEventArgs_get_Item), nullptr, nullptr, nullptr },
        { "tab", reinterpret_cast<getter>(TabViewTabDragCompletedEventArgs_get_Tab), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_TabViewTabDragCompletedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_TabViewTabDragCompletedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_TabViewTabDragCompletedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_TabViewTabDragCompletedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_TabViewTabDragCompletedEventArgs) },
        { }};

    static PyType_Spec type_spec_TabViewTabDragCompletedEventArgs = {
        "winui2._winui2_microsoft_ui_xaml_controls.TabViewTabDragCompletedEventArgs",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Controls::TabViewTabDragCompletedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TabViewTabDragCompletedEventArgs};

    // ----- TabViewTabDragStartingEventArgs class --------------------

    static PyObject* _new_TabViewTabDragStartingEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Xaml::Controls::TabViewTabDragStartingEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Xaml::Controls::TabViewTabDragStartingEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_TabViewTabDragStartingEventArgs(py::wrapper::Microsoft::UI::Xaml::Controls::TabViewTabDragStartingEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* TabViewTabDragStartingEventArgs_get_Cancel(py::wrapper::Microsoft::UI::Xaml::Controls::TabViewTabDragStartingEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TabViewTabDragStartingEventArgs", L"Cancel");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Cancel();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TabViewTabDragStartingEventArgs_put_Cancel(py::wrapper::Microsoft::UI::Xaml::Controls::TabViewTabDragStartingEventArgs* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TabViewTabDragStartingEventArgs", L"Cancel");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.Cancel(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TabViewTabDragStartingEventArgs_get_Data(py::wrapper::Microsoft::UI::Xaml::Controls::TabViewTabDragStartingEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TabViewTabDragStartingEventArgs", L"Data");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Data();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TabViewTabDragStartingEventArgs_get_Item(py::wrapper::Microsoft::UI::Xaml::Controls::TabViewTabDragStartingEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TabViewTabDragStartingEventArgs", L"Item");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Item();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TabViewTabDragStartingEventArgs_get_Tab(py::wrapper::Microsoft::UI::Xaml::Controls::TabViewTabDragStartingEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TabViewTabDragStartingEventArgs", L"Tab");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Tab();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_TabViewTabDragStartingEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::TabViewTabDragStartingEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_TabViewTabDragStartingEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::TabViewTabDragStartingEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_TabViewTabDragStartingEventArgs[] = {
        { "_assign_array_", _assign_array_TabViewTabDragStartingEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_TabViewTabDragStartingEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_TabViewTabDragStartingEventArgs[] = {
        { "cancel", reinterpret_cast<getter>(TabViewTabDragStartingEventArgs_get_Cancel), reinterpret_cast<setter>(TabViewTabDragStartingEventArgs_put_Cancel), nullptr, nullptr },
        { "data", reinterpret_cast<getter>(TabViewTabDragStartingEventArgs_get_Data), nullptr, nullptr, nullptr },
        { "item", reinterpret_cast<getter>(TabViewTabDragStartingEventArgs_get_Item), nullptr, nullptr, nullptr },
        { "tab", reinterpret_cast<getter>(TabViewTabDragStartingEventArgs_get_Tab), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_TabViewTabDragStartingEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_TabViewTabDragStartingEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_TabViewTabDragStartingEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_TabViewTabDragStartingEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_TabViewTabDragStartingEventArgs) },
        { }};

    static PyType_Spec type_spec_TabViewTabDragStartingEventArgs = {
        "winui2._winui2_microsoft_ui_xaml_controls.TabViewTabDragStartingEventArgs",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Controls::TabViewTabDragStartingEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TabViewTabDragStartingEventArgs};

    // ----- TabViewTabDroppedOutsideEventArgs class --------------------

    static PyObject* _new_TabViewTabDroppedOutsideEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Xaml::Controls::TabViewTabDroppedOutsideEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Xaml::Controls::TabViewTabDroppedOutsideEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_TabViewTabDroppedOutsideEventArgs(py::wrapper::Microsoft::UI::Xaml::Controls::TabViewTabDroppedOutsideEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* TabViewTabDroppedOutsideEventArgs_get_Item(py::wrapper::Microsoft::UI::Xaml::Controls::TabViewTabDroppedOutsideEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TabViewTabDroppedOutsideEventArgs", L"Item");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Item();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TabViewTabDroppedOutsideEventArgs_get_Tab(py::wrapper::Microsoft::UI::Xaml::Controls::TabViewTabDroppedOutsideEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TabViewTabDroppedOutsideEventArgs", L"Tab");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Tab();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_TabViewTabDroppedOutsideEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::TabViewTabDroppedOutsideEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_TabViewTabDroppedOutsideEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::TabViewTabDroppedOutsideEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_TabViewTabDroppedOutsideEventArgs[] = {
        { "_assign_array_", _assign_array_TabViewTabDroppedOutsideEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_TabViewTabDroppedOutsideEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_TabViewTabDroppedOutsideEventArgs[] = {
        { "item", reinterpret_cast<getter>(TabViewTabDroppedOutsideEventArgs_get_Item), nullptr, nullptr, nullptr },
        { "tab", reinterpret_cast<getter>(TabViewTabDroppedOutsideEventArgs_get_Tab), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_TabViewTabDroppedOutsideEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_TabViewTabDroppedOutsideEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_TabViewTabDroppedOutsideEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_TabViewTabDroppedOutsideEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_TabViewTabDroppedOutsideEventArgs) },
        { }};

    static PyType_Spec type_spec_TabViewTabDroppedOutsideEventArgs = {
        "winui2._winui2_microsoft_ui_xaml_controls.TabViewTabDroppedOutsideEventArgs",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Controls::TabViewTabDroppedOutsideEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TabViewTabDroppedOutsideEventArgs};

    // ----- TeachingTip class --------------------

    struct PyWinrtTeachingTip;
    using BasePyWinrtTeachingTip = winrt::Microsoft::UI::Xaml::Controls::TeachingTipT<PyWinrtTeachingTip, py::IPywinrtObject>;

    struct PyWinrtTeachingTip : py::py_obj_ref, BasePyWinrtTeachingTip
    {
        PyWinrtTeachingTip(PyObject* py_obj) : py::py_obj_ref(py_obj), BasePyWinrtTeachingTip() {}

        int32_t __stdcall GetPyObject(PyObject*& obj) override
        {
            obj = py::py_obj_ref::get_py_obj();
            return 0;
        }

        int32_t __stdcall GetComposableInner(winrt::Windows::Foundation::IInspectable& inner) override
        {
            inner = m_inner;
            return winrt::impl::error_ok;
        }

        static void toggle_reference(PyWinrtTeachingTip* instance, bool is_last_reference)
        {
            py::py_obj_ref::toggle_reference(instance, is_last_reference);
        }

        int32_t query_interface_tearoff(winrt::guid const& id, void** result) const noexcept override
        {
            return py::py_obj_ref::query_interface_tearoff(id, result);
        }

        std::vector<winrt::guid> get_iids_tearoff() const noexcept override
        {
            return py::py_obj_ref::get_iids_tearoff();
        }
    };

    static PyObject* _new_TeachingTip(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_GET_SIZE(args);

        auto self_type = get_python_type_for<winrt::Microsoft::UI::Xaml::Controls::TeachingTip>();
        if (!self_type)
        {
            return nullptr;
        }

        if (arg_count == 0)
        {
            try
            {
                if (type != self_type)
                {
                    py::pyobj_handle self{type->tp_alloc(type, 0)};
                    if (!self)
                    {
                        return nullptr;
                    }

                    std::construct_at(&reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj, nullptr);

                    auto obj_impl = winrt::make_self<PyWinrtTeachingTip>(self.get());

                    auto obj = py::make_py_obj<PyWinrtTeachingTip>(obj_impl, type, self.get());
                    if (!obj)
                    {
                        return nullptr;
                    }

                    reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj = std::move(obj);

                    return self.detach();
                }

                winrt::Microsoft::UI::Xaml::Controls::TeachingTip instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_TeachingTip(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* TeachingTip_get_Title(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TeachingTip", L"Title");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::TeachingTip>().Title();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TeachingTip_put_Title(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TeachingTip", L"Title");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::TeachingTip>().Title(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TeachingTip_get_Target(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TeachingTip", L"Target");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::TeachingTip>().Target();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TeachingTip_put_Target(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TeachingTip", L"Target");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::FrameworkElement>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::TeachingTip>().Target(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TeachingTip_get_TailVisibility(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TeachingTip", L"TailVisibility");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::TeachingTip>().TailVisibility();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TeachingTip_put_TailVisibility(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TeachingTip", L"TailVisibility");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::TeachingTipTailVisibility>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::TeachingTip>().TailVisibility(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TeachingTip_get_Subtitle(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TeachingTip", L"Subtitle");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::TeachingTip>().Subtitle();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TeachingTip_put_Subtitle(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TeachingTip", L"Subtitle");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::TeachingTip>().Subtitle(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TeachingTip_get_ShouldConstrainToRootBounds(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TeachingTip", L"ShouldConstrainToRootBounds");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::TeachingTip>().ShouldConstrainToRootBounds();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TeachingTip_put_ShouldConstrainToRootBounds(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TeachingTip", L"ShouldConstrainToRootBounds");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::TeachingTip>().ShouldConstrainToRootBounds(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TeachingTip_get_PreferredPlacement(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TeachingTip", L"PreferredPlacement");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::TeachingTip>().PreferredPlacement();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TeachingTip_put_PreferredPlacement(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TeachingTip", L"PreferredPlacement");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::TeachingTipPlacementMode>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::TeachingTip>().PreferredPlacement(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TeachingTip_get_PlacementMargin(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TeachingTip", L"PlacementMargin");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::TeachingTip>().PlacementMargin();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TeachingTip_put_PlacementMargin(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TeachingTip", L"PlacementMargin");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Thickness>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::TeachingTip>().PlacementMargin(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TeachingTip_get_IsOpen(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TeachingTip", L"IsOpen");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::TeachingTip>().IsOpen();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TeachingTip_put_IsOpen(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TeachingTip", L"IsOpen");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::TeachingTip>().IsOpen(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TeachingTip_get_IsLightDismissEnabled(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TeachingTip", L"IsLightDismissEnabled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::TeachingTip>().IsLightDismissEnabled();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TeachingTip_put_IsLightDismissEnabled(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TeachingTip", L"IsLightDismissEnabled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::TeachingTip>().IsLightDismissEnabled(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TeachingTip_get_IconSource(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TeachingTip", L"IconSource");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::TeachingTip>().IconSource();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TeachingTip_put_IconSource(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TeachingTip", L"IconSource");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::IconSource>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::TeachingTip>().IconSource(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TeachingTip_get_HeroContentPlacement(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TeachingTip", L"HeroContentPlacement");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::TeachingTip>().HeroContentPlacement();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TeachingTip_put_HeroContentPlacement(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TeachingTip", L"HeroContentPlacement");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::TeachingTipHeroContentPlacementMode>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::TeachingTip>().HeroContentPlacement(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TeachingTip_get_HeroContent(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TeachingTip", L"HeroContent");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::TeachingTip>().HeroContent();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TeachingTip_put_HeroContent(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TeachingTip", L"HeroContent");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::UIElement>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::TeachingTip>().HeroContent(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TeachingTip_get_CloseButtonStyle(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TeachingTip", L"CloseButtonStyle");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::TeachingTip>().CloseButtonStyle();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TeachingTip_put_CloseButtonStyle(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TeachingTip", L"CloseButtonStyle");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Style>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::TeachingTip>().CloseButtonStyle(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TeachingTip_get_CloseButtonContent(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TeachingTip", L"CloseButtonContent");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::TeachingTip>().CloseButtonContent();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TeachingTip_put_CloseButtonContent(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TeachingTip", L"CloseButtonContent");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::TeachingTip>().CloseButtonContent(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TeachingTip_get_CloseButtonCommandParameter(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TeachingTip", L"CloseButtonCommandParameter");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::TeachingTip>().CloseButtonCommandParameter();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TeachingTip_put_CloseButtonCommandParameter(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TeachingTip", L"CloseButtonCommandParameter");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::TeachingTip>().CloseButtonCommandParameter(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TeachingTip_get_CloseButtonCommand(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TeachingTip", L"CloseButtonCommand");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::TeachingTip>().CloseButtonCommand();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TeachingTip_put_CloseButtonCommand(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TeachingTip", L"CloseButtonCommand");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Input::ICommand>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::TeachingTip>().CloseButtonCommand(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TeachingTip_get_ActionButtonStyle(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TeachingTip", L"ActionButtonStyle");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::TeachingTip>().ActionButtonStyle();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TeachingTip_put_ActionButtonStyle(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TeachingTip", L"ActionButtonStyle");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Style>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::TeachingTip>().ActionButtonStyle(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TeachingTip_get_ActionButtonContent(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TeachingTip", L"ActionButtonContent");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::TeachingTip>().ActionButtonContent();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TeachingTip_put_ActionButtonContent(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TeachingTip", L"ActionButtonContent");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::TeachingTip>().ActionButtonContent(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TeachingTip_get_ActionButtonCommandParameter(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TeachingTip", L"ActionButtonCommandParameter");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::TeachingTip>().ActionButtonCommandParameter();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TeachingTip_put_ActionButtonCommandParameter(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TeachingTip", L"ActionButtonCommandParameter");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::TeachingTip>().ActionButtonCommandParameter(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TeachingTip_get_ActionButtonCommand(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TeachingTip", L"ActionButtonCommand");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::TeachingTip>().ActionButtonCommand();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TeachingTip_put_ActionButtonCommand(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TeachingTip", L"ActionButtonCommand");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Input::ICommand>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::TeachingTip>().ActionButtonCommand(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TeachingTip_get_TemplateSettings(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TeachingTip", L"TemplateSettings");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::TeachingTip>().TemplateSettings();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TeachingTip_get_ActionButtonCommandParameterProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TeachingTip", L"ActionButtonCommandParameterProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::TeachingTip::ActionButtonCommandParameterProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TeachingTip_get_ActionButtonCommandProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TeachingTip", L"ActionButtonCommandProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::TeachingTip::ActionButtonCommandProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TeachingTip_get_ActionButtonContentProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TeachingTip", L"ActionButtonContentProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::TeachingTip::ActionButtonContentProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TeachingTip_get_ActionButtonStyleProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TeachingTip", L"ActionButtonStyleProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::TeachingTip::ActionButtonStyleProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TeachingTip_get_CloseButtonCommandParameterProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TeachingTip", L"CloseButtonCommandParameterProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::TeachingTip::CloseButtonCommandParameterProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TeachingTip_get_CloseButtonCommandProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TeachingTip", L"CloseButtonCommandProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::TeachingTip::CloseButtonCommandProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TeachingTip_get_CloseButtonContentProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TeachingTip", L"CloseButtonContentProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::TeachingTip::CloseButtonContentProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TeachingTip_get_CloseButtonStyleProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TeachingTip", L"CloseButtonStyleProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::TeachingTip::CloseButtonStyleProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TeachingTip_get_HeroContentPlacementProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TeachingTip", L"HeroContentPlacementProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::TeachingTip::HeroContentPlacementProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TeachingTip_get_HeroContentProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TeachingTip", L"HeroContentProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::TeachingTip::HeroContentProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TeachingTip_get_IconSourceProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TeachingTip", L"IconSourceProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::TeachingTip::IconSourceProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TeachingTip_get_IsLightDismissEnabledProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TeachingTip", L"IsLightDismissEnabledProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::TeachingTip::IsLightDismissEnabledProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TeachingTip_get_IsOpenProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TeachingTip", L"IsOpenProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::TeachingTip::IsOpenProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TeachingTip_get_PlacementMarginProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TeachingTip", L"PlacementMarginProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::TeachingTip::PlacementMarginProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TeachingTip_get_PreferredPlacementProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TeachingTip", L"PreferredPlacementProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::TeachingTip::PreferredPlacementProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TeachingTip_get_ShouldConstrainToRootBoundsProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TeachingTip", L"ShouldConstrainToRootBoundsProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::TeachingTip::ShouldConstrainToRootBoundsProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TeachingTip_get_SubtitleProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TeachingTip", L"SubtitleProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::TeachingTip::SubtitleProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TeachingTip_get_TailVisibilityProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TeachingTip", L"TailVisibilityProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::TeachingTip::TailVisibilityProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TeachingTip_get_TargetProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TeachingTip", L"TargetProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::TeachingTip::TargetProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TeachingTip_get_TemplateSettingsProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TeachingTip", L"TemplateSettingsProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::TeachingTip::TemplateSettingsProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TeachingTip_get_TitleProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TeachingTip", L"TitleProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::TeachingTip::TitleProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TeachingTip_add_ActionButtonClick(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.TeachingTip", L"ActionButtonClick");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Xaml::Controls::TeachingTip, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::TeachingTip>().ActionButtonClick(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TeachingTip_remove_ActionButtonClick(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.TeachingTip", L"ActionButtonClick");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::TeachingTip>().ActionButtonClick(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TeachingTip_add_CloseButtonClick(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.TeachingTip", L"CloseButtonClick");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Xaml::Controls::TeachingTip, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::TeachingTip>().CloseButtonClick(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TeachingTip_remove_CloseButtonClick(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.TeachingTip", L"CloseButtonClick");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::TeachingTip>().CloseButtonClick(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TeachingTip_add_Closed(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.TeachingTip", L"Closed");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Xaml::Controls::TeachingTip, winrt::Microsoft::UI::Xaml::Controls::TeachingTipClosedEventArgs>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::TeachingTip>().Closed(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TeachingTip_remove_Closed(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.TeachingTip", L"Closed");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::TeachingTip>().Closed(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TeachingTip_add_Closing(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.TeachingTip", L"Closing");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Xaml::Controls::TeachingTip, winrt::Microsoft::UI::Xaml::Controls::TeachingTipClosingEventArgs>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::TeachingTip>().Closing(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TeachingTip_remove_Closing(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.TeachingTip", L"Closing");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::TeachingTip>().Closing(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_TeachingTip(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::TeachingTip>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_TeachingTip(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::TeachingTip>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_TeachingTip[] = {
        { "add_action_button_click", reinterpret_cast<PyCFunction>(TeachingTip_add_ActionButtonClick), METH_O, nullptr },
        { "remove_action_button_click", reinterpret_cast<PyCFunction>(TeachingTip_remove_ActionButtonClick), METH_O, nullptr },
        { "add_close_button_click", reinterpret_cast<PyCFunction>(TeachingTip_add_CloseButtonClick), METH_O, nullptr },
        { "remove_close_button_click", reinterpret_cast<PyCFunction>(TeachingTip_remove_CloseButtonClick), METH_O, nullptr },
        { "add_closed", reinterpret_cast<PyCFunction>(TeachingTip_add_Closed), METH_O, nullptr },
        { "remove_closed", reinterpret_cast<PyCFunction>(TeachingTip_remove_Closed), METH_O, nullptr },
        { "add_closing", reinterpret_cast<PyCFunction>(TeachingTip_add_Closing), METH_O, nullptr },
        { "remove_closing", reinterpret_cast<PyCFunction>(TeachingTip_remove_Closing), METH_O, nullptr },
        { "_assign_array_", _assign_array_TeachingTip, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_TeachingTip), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_TeachingTip[] = {
        { "title", reinterpret_cast<getter>(TeachingTip_get_Title), reinterpret_cast<setter>(TeachingTip_put_Title), nullptr, nullptr },
        { "target", reinterpret_cast<getter>(TeachingTip_get_Target), reinterpret_cast<setter>(TeachingTip_put_Target), nullptr, nullptr },
        { "tail_visibility", reinterpret_cast<getter>(TeachingTip_get_TailVisibility), reinterpret_cast<setter>(TeachingTip_put_TailVisibility), nullptr, nullptr },
        { "subtitle", reinterpret_cast<getter>(TeachingTip_get_Subtitle), reinterpret_cast<setter>(TeachingTip_put_Subtitle), nullptr, nullptr },
        { "should_constrain_to_root_bounds", reinterpret_cast<getter>(TeachingTip_get_ShouldConstrainToRootBounds), reinterpret_cast<setter>(TeachingTip_put_ShouldConstrainToRootBounds), nullptr, nullptr },
        { "preferred_placement", reinterpret_cast<getter>(TeachingTip_get_PreferredPlacement), reinterpret_cast<setter>(TeachingTip_put_PreferredPlacement), nullptr, nullptr },
        { "placement_margin", reinterpret_cast<getter>(TeachingTip_get_PlacementMargin), reinterpret_cast<setter>(TeachingTip_put_PlacementMargin), nullptr, nullptr },
        { "is_open", reinterpret_cast<getter>(TeachingTip_get_IsOpen), reinterpret_cast<setter>(TeachingTip_put_IsOpen), nullptr, nullptr },
        { "is_light_dismiss_enabled", reinterpret_cast<getter>(TeachingTip_get_IsLightDismissEnabled), reinterpret_cast<setter>(TeachingTip_put_IsLightDismissEnabled), nullptr, nullptr },
        { "icon_source", reinterpret_cast<getter>(TeachingTip_get_IconSource), reinterpret_cast<setter>(TeachingTip_put_IconSource), nullptr, nullptr },
        { "hero_content_placement", reinterpret_cast<getter>(TeachingTip_get_HeroContentPlacement), reinterpret_cast<setter>(TeachingTip_put_HeroContentPlacement), nullptr, nullptr },
        { "hero_content", reinterpret_cast<getter>(TeachingTip_get_HeroContent), reinterpret_cast<setter>(TeachingTip_put_HeroContent), nullptr, nullptr },
        { "close_button_style", reinterpret_cast<getter>(TeachingTip_get_CloseButtonStyle), reinterpret_cast<setter>(TeachingTip_put_CloseButtonStyle), nullptr, nullptr },
        { "close_button_content", reinterpret_cast<getter>(TeachingTip_get_CloseButtonContent), reinterpret_cast<setter>(TeachingTip_put_CloseButtonContent), nullptr, nullptr },
        { "close_button_command_parameter", reinterpret_cast<getter>(TeachingTip_get_CloseButtonCommandParameter), reinterpret_cast<setter>(TeachingTip_put_CloseButtonCommandParameter), nullptr, nullptr },
        { "close_button_command", reinterpret_cast<getter>(TeachingTip_get_CloseButtonCommand), reinterpret_cast<setter>(TeachingTip_put_CloseButtonCommand), nullptr, nullptr },
        { "action_button_style", reinterpret_cast<getter>(TeachingTip_get_ActionButtonStyle), reinterpret_cast<setter>(TeachingTip_put_ActionButtonStyle), nullptr, nullptr },
        { "action_button_content", reinterpret_cast<getter>(TeachingTip_get_ActionButtonContent), reinterpret_cast<setter>(TeachingTip_put_ActionButtonContent), nullptr, nullptr },
        { "action_button_command_parameter", reinterpret_cast<getter>(TeachingTip_get_ActionButtonCommandParameter), reinterpret_cast<setter>(TeachingTip_put_ActionButtonCommandParameter), nullptr, nullptr },
        { "action_button_command", reinterpret_cast<getter>(TeachingTip_get_ActionButtonCommand), reinterpret_cast<setter>(TeachingTip_put_ActionButtonCommand), nullptr, nullptr },
        { "template_settings", reinterpret_cast<getter>(TeachingTip_get_TemplateSettings), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_TeachingTip[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_TeachingTip) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_TeachingTip) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_TeachingTip) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_TeachingTip) },
        { }};

    static PyType_Spec type_spec_TeachingTip = {
        "winui2._winui2_microsoft_ui_xaml_controls.TeachingTip",
        sizeof(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_TeachingTip};

    static PyGetSetDef getset_TeachingTip_Static[] = {
        { "action_button_command_parameter_property", reinterpret_cast<getter>(TeachingTip_get_ActionButtonCommandParameterProperty), nullptr, nullptr, nullptr },
        { "action_button_command_property", reinterpret_cast<getter>(TeachingTip_get_ActionButtonCommandProperty), nullptr, nullptr, nullptr },
        { "action_button_content_property", reinterpret_cast<getter>(TeachingTip_get_ActionButtonContentProperty), nullptr, nullptr, nullptr },
        { "action_button_style_property", reinterpret_cast<getter>(TeachingTip_get_ActionButtonStyleProperty), nullptr, nullptr, nullptr },
        { "close_button_command_parameter_property", reinterpret_cast<getter>(TeachingTip_get_CloseButtonCommandParameterProperty), nullptr, nullptr, nullptr },
        { "close_button_command_property", reinterpret_cast<getter>(TeachingTip_get_CloseButtonCommandProperty), nullptr, nullptr, nullptr },
        { "close_button_content_property", reinterpret_cast<getter>(TeachingTip_get_CloseButtonContentProperty), nullptr, nullptr, nullptr },
        { "close_button_style_property", reinterpret_cast<getter>(TeachingTip_get_CloseButtonStyleProperty), nullptr, nullptr, nullptr },
        { "hero_content_placement_property", reinterpret_cast<getter>(TeachingTip_get_HeroContentPlacementProperty), nullptr, nullptr, nullptr },
        { "hero_content_property", reinterpret_cast<getter>(TeachingTip_get_HeroContentProperty), nullptr, nullptr, nullptr },
        { "icon_source_property", reinterpret_cast<getter>(TeachingTip_get_IconSourceProperty), nullptr, nullptr, nullptr },
        { "is_light_dismiss_enabled_property", reinterpret_cast<getter>(TeachingTip_get_IsLightDismissEnabledProperty), nullptr, nullptr, nullptr },
        { "is_open_property", reinterpret_cast<getter>(TeachingTip_get_IsOpenProperty), nullptr, nullptr, nullptr },
        { "placement_margin_property", reinterpret_cast<getter>(TeachingTip_get_PlacementMarginProperty), nullptr, nullptr, nullptr },
        { "preferred_placement_property", reinterpret_cast<getter>(TeachingTip_get_PreferredPlacementProperty), nullptr, nullptr, nullptr },
        { "should_constrain_to_root_bounds_property", reinterpret_cast<getter>(TeachingTip_get_ShouldConstrainToRootBoundsProperty), nullptr, nullptr, nullptr },
        { "subtitle_property", reinterpret_cast<getter>(TeachingTip_get_SubtitleProperty), nullptr, nullptr, nullptr },
        { "tail_visibility_property", reinterpret_cast<getter>(TeachingTip_get_TailVisibilityProperty), nullptr, nullptr, nullptr },
        { "target_property", reinterpret_cast<getter>(TeachingTip_get_TargetProperty), nullptr, nullptr, nullptr },
        { "template_settings_property", reinterpret_cast<getter>(TeachingTip_get_TemplateSettingsProperty), nullptr, nullptr, nullptr },
        { "title_property", reinterpret_cast<getter>(TeachingTip_get_TitleProperty), nullptr, nullptr, nullptr },
        { }};

    static PyMethodDef methods_TeachingTip_Static[] = {
        { }};

    static PyType_Slot type_slots_TeachingTip_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_TeachingTip_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_TeachingTip_Static) },
        { }
    };

    static PyType_Spec type_spec_TeachingTip_Static = {
        "winui2._winui2_microsoft_ui_xaml_controls.TeachingTip_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_TeachingTip_Static};

    // ----- TeachingTipClosedEventArgs class --------------------

    static PyObject* _new_TeachingTipClosedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Xaml::Controls::TeachingTipClosedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Xaml::Controls::TeachingTipClosedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_TeachingTipClosedEventArgs(py::wrapper::Microsoft::UI::Xaml::Controls::TeachingTipClosedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* TeachingTipClosedEventArgs_get_Reason(py::wrapper::Microsoft::UI::Xaml::Controls::TeachingTipClosedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TeachingTipClosedEventArgs", L"Reason");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Reason();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_TeachingTipClosedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::TeachingTipClosedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_TeachingTipClosedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::TeachingTipClosedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_TeachingTipClosedEventArgs[] = {
        { "_assign_array_", _assign_array_TeachingTipClosedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_TeachingTipClosedEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_TeachingTipClosedEventArgs[] = {
        { "reason", reinterpret_cast<getter>(TeachingTipClosedEventArgs_get_Reason), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_TeachingTipClosedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_TeachingTipClosedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_TeachingTipClosedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_TeachingTipClosedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_TeachingTipClosedEventArgs) },
        { }};

    static PyType_Spec type_spec_TeachingTipClosedEventArgs = {
        "winui2._winui2_microsoft_ui_xaml_controls.TeachingTipClosedEventArgs",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Controls::TeachingTipClosedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TeachingTipClosedEventArgs};

    // ----- TeachingTipClosingEventArgs class --------------------

    static PyObject* _new_TeachingTipClosingEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Xaml::Controls::TeachingTipClosingEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Xaml::Controls::TeachingTipClosingEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_TeachingTipClosingEventArgs(py::wrapper::Microsoft::UI::Xaml::Controls::TeachingTipClosingEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* TeachingTipClosingEventArgs_GetDeferral(py::wrapper::Microsoft::UI::Xaml::Controls::TeachingTipClosingEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.TeachingTipClosingEventArgs", L"GetDeferral", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetDeferral();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TeachingTipClosingEventArgs_get_Cancel(py::wrapper::Microsoft::UI::Xaml::Controls::TeachingTipClosingEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TeachingTipClosingEventArgs", L"Cancel");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Cancel();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TeachingTipClosingEventArgs_put_Cancel(py::wrapper::Microsoft::UI::Xaml::Controls::TeachingTipClosingEventArgs* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TeachingTipClosingEventArgs", L"Cancel");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.Cancel(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TeachingTipClosingEventArgs_get_Reason(py::wrapper::Microsoft::UI::Xaml::Controls::TeachingTipClosingEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TeachingTipClosingEventArgs", L"Reason");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Reason();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_TeachingTipClosingEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::TeachingTipClosingEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_TeachingTipClosingEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::TeachingTipClosingEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_TeachingTipClosingEventArgs[] = {
        { "get_deferral", reinterpret_cast<PyCFunction>(TeachingTipClosingEventArgs_GetDeferral), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_TeachingTipClosingEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_TeachingTipClosingEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_TeachingTipClosingEventArgs[] = {
        { "cancel", reinterpret_cast<getter>(TeachingTipClosingEventArgs_get_Cancel), reinterpret_cast<setter>(TeachingTipClosingEventArgs_put_Cancel), nullptr, nullptr },
        { "reason", reinterpret_cast<getter>(TeachingTipClosingEventArgs_get_Reason), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_TeachingTipClosingEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_TeachingTipClosingEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_TeachingTipClosingEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_TeachingTipClosingEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_TeachingTipClosingEventArgs) },
        { }};

    static PyType_Spec type_spec_TeachingTipClosingEventArgs = {
        "winui2._winui2_microsoft_ui_xaml_controls.TeachingTipClosingEventArgs",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Controls::TeachingTipClosingEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TeachingTipClosingEventArgs};

    // ----- TeachingTipTemplateSettings class --------------------

    struct PyWinrtTeachingTipTemplateSettings;
    using BasePyWinrtTeachingTipTemplateSettings = winrt::Microsoft::UI::Xaml::Controls::TeachingTipTemplateSettingsT<PyWinrtTeachingTipTemplateSettings, py::IPywinrtObject>;

    struct PyWinrtTeachingTipTemplateSettings : py::py_obj_ref, BasePyWinrtTeachingTipTemplateSettings
    {
        PyWinrtTeachingTipTemplateSettings(PyObject* py_obj) : py::py_obj_ref(py_obj), BasePyWinrtTeachingTipTemplateSettings() {}

        int32_t __stdcall GetPyObject(PyObject*& obj) override
        {
            obj = py::py_obj_ref::get_py_obj();
            return 0;
        }

        int32_t __stdcall GetComposableInner(winrt::Windows::Foundation::IInspectable& inner) override
        {
            inner = m_inner;
            return winrt::impl::error_ok;
        }

        static void toggle_reference(PyWinrtTeachingTipTemplateSettings* instance, bool is_last_reference)
        {
            py::py_obj_ref::toggle_reference(instance, is_last_reference);
        }

        int32_t query_interface_tearoff(winrt::guid const& id, void** result) const noexcept override
        {
            return py::py_obj_ref::query_interface_tearoff(id, result);
        }

        std::vector<winrt::guid> get_iids_tearoff() const noexcept override
        {
            return py::py_obj_ref::get_iids_tearoff();
        }
    };

    static PyObject* _new_TeachingTipTemplateSettings(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_GET_SIZE(args);

        auto self_type = get_python_type_for<winrt::Microsoft::UI::Xaml::Controls::TeachingTipTemplateSettings>();
        if (!self_type)
        {
            return nullptr;
        }

        if (arg_count == 0)
        {
            try
            {
                if (type != self_type)
                {
                    py::pyobj_handle self{type->tp_alloc(type, 0)};
                    if (!self)
                    {
                        return nullptr;
                    }

                    std::construct_at(&reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj, nullptr);

                    auto obj_impl = winrt::make_self<PyWinrtTeachingTipTemplateSettings>(self.get());

                    auto obj = py::make_py_obj<PyWinrtTeachingTipTemplateSettings>(obj_impl, type, self.get());
                    if (!obj)
                    {
                        return nullptr;
                    }

                    reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj = std::move(obj);

                    return self.detach();
                }

                winrt::Microsoft::UI::Xaml::Controls::TeachingTipTemplateSettings instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_TeachingTipTemplateSettings(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* TeachingTipTemplateSettings_get_TopRightHighlightMargin(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TeachingTipTemplateSettings", L"TopRightHighlightMargin");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::TeachingTipTemplateSettings>().TopRightHighlightMargin();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TeachingTipTemplateSettings_put_TopRightHighlightMargin(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TeachingTipTemplateSettings", L"TopRightHighlightMargin");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Thickness>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::TeachingTipTemplateSettings>().TopRightHighlightMargin(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TeachingTipTemplateSettings_get_TopLeftHighlightMargin(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TeachingTipTemplateSettings", L"TopLeftHighlightMargin");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::TeachingTipTemplateSettings>().TopLeftHighlightMargin();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TeachingTipTemplateSettings_put_TopLeftHighlightMargin(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TeachingTipTemplateSettings", L"TopLeftHighlightMargin");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Thickness>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::TeachingTipTemplateSettings>().TopLeftHighlightMargin(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TeachingTipTemplateSettings_get_IconElement(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TeachingTipTemplateSettings", L"IconElement");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::TeachingTipTemplateSettings>().IconElement();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TeachingTipTemplateSettings_put_IconElement(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TeachingTipTemplateSettings", L"IconElement");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::IconElement>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::TeachingTipTemplateSettings>().IconElement(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TeachingTipTemplateSettings_get_IconElementProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TeachingTipTemplateSettings", L"IconElementProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::TeachingTipTemplateSettings::IconElementProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TeachingTipTemplateSettings_get_TopLeftHighlightMarginProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TeachingTipTemplateSettings", L"TopLeftHighlightMarginProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::TeachingTipTemplateSettings::TopLeftHighlightMarginProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TeachingTipTemplateSettings_get_TopRightHighlightMarginProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TeachingTipTemplateSettings", L"TopRightHighlightMarginProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::TeachingTipTemplateSettings::TopRightHighlightMarginProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_TeachingTipTemplateSettings(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::TeachingTipTemplateSettings>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_TeachingTipTemplateSettings(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::TeachingTipTemplateSettings>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_TeachingTipTemplateSettings[] = {
        { "_assign_array_", _assign_array_TeachingTipTemplateSettings, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_TeachingTipTemplateSettings), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_TeachingTipTemplateSettings[] = {
        { "top_right_highlight_margin", reinterpret_cast<getter>(TeachingTipTemplateSettings_get_TopRightHighlightMargin), reinterpret_cast<setter>(TeachingTipTemplateSettings_put_TopRightHighlightMargin), nullptr, nullptr },
        { "top_left_highlight_margin", reinterpret_cast<getter>(TeachingTipTemplateSettings_get_TopLeftHighlightMargin), reinterpret_cast<setter>(TeachingTipTemplateSettings_put_TopLeftHighlightMargin), nullptr, nullptr },
        { "icon_element", reinterpret_cast<getter>(TeachingTipTemplateSettings_get_IconElement), reinterpret_cast<setter>(TeachingTipTemplateSettings_put_IconElement), nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_TeachingTipTemplateSettings[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_TeachingTipTemplateSettings) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_TeachingTipTemplateSettings) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_TeachingTipTemplateSettings) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_TeachingTipTemplateSettings) },
        { }};

    static PyType_Spec type_spec_TeachingTipTemplateSettings = {
        "winui2._winui2_microsoft_ui_xaml_controls.TeachingTipTemplateSettings",
        sizeof(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_TeachingTipTemplateSettings};

    static PyGetSetDef getset_TeachingTipTemplateSettings_Static[] = {
        { "icon_element_property", reinterpret_cast<getter>(TeachingTipTemplateSettings_get_IconElementProperty), nullptr, nullptr, nullptr },
        { "top_left_highlight_margin_property", reinterpret_cast<getter>(TeachingTipTemplateSettings_get_TopLeftHighlightMarginProperty), nullptr, nullptr, nullptr },
        { "top_right_highlight_margin_property", reinterpret_cast<getter>(TeachingTipTemplateSettings_get_TopRightHighlightMarginProperty), nullptr, nullptr, nullptr },
        { }};

    static PyMethodDef methods_TeachingTipTemplateSettings_Static[] = {
        { }};

    static PyType_Slot type_slots_TeachingTipTemplateSettings_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_TeachingTipTemplateSettings_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_TeachingTipTemplateSettings_Static) },
        { }
    };

    static PyType_Spec type_spec_TeachingTipTemplateSettings_Static = {
        "winui2._winui2_microsoft_ui_xaml_controls.TeachingTipTemplateSettings_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_TeachingTipTemplateSettings_Static};

    // ----- TextCommandBarFlyout class --------------------

    struct PyWinrtTextCommandBarFlyout;
    using BasePyWinrtTextCommandBarFlyout = winrt::Microsoft::UI::Xaml::Controls::TextCommandBarFlyoutT<PyWinrtTextCommandBarFlyout, py::IPywinrtObject>;

    struct PyWinrtTextCommandBarFlyout : py::py_obj_ref, BasePyWinrtTextCommandBarFlyout
    {
        PyWinrtTextCommandBarFlyout(PyObject* py_obj) : py::py_obj_ref(py_obj), BasePyWinrtTextCommandBarFlyout() {}

        int32_t __stdcall GetPyObject(PyObject*& obj) override
        {
            obj = py::py_obj_ref::get_py_obj();
            return 0;
        }

        int32_t __stdcall GetComposableInner(winrt::Windows::Foundation::IInspectable& inner) override
        {
            inner = m_inner;
            return winrt::impl::error_ok;
        }

        static void toggle_reference(PyWinrtTextCommandBarFlyout* instance, bool is_last_reference)
        {
            py::py_obj_ref::toggle_reference(instance, is_last_reference);
        }

        int32_t query_interface_tearoff(winrt::guid const& id, void** result) const noexcept override
        {
            return py::py_obj_ref::query_interface_tearoff(id, result);
        }

        std::vector<winrt::guid> get_iids_tearoff() const noexcept override
        {
            return py::py_obj_ref::get_iids_tearoff();
        }
    };

    static PyObject* _new_TextCommandBarFlyout(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_GET_SIZE(args);

        auto self_type = get_python_type_for<winrt::Microsoft::UI::Xaml::Controls::TextCommandBarFlyout>();
        if (!self_type)
        {
            return nullptr;
        }

        if (arg_count == 0)
        {
            try
            {
                if (type != self_type)
                {
                    py::pyobj_handle self{type->tp_alloc(type, 0)};
                    if (!self)
                    {
                        return nullptr;
                    }

                    std::construct_at(&reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj, nullptr);

                    auto obj_impl = winrt::make_self<PyWinrtTextCommandBarFlyout>(self.get());

                    auto obj = py::make_py_obj<PyWinrtTextCommandBarFlyout>(obj_impl, type, self.get());
                    if (!obj)
                    {
                        return nullptr;
                    }

                    reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj = std::move(obj);

                    return self.detach();
                }

                winrt::Microsoft::UI::Xaml::Controls::TextCommandBarFlyout instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_TextCommandBarFlyout(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_TextCommandBarFlyout(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::TextCommandBarFlyout>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_TextCommandBarFlyout(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::TextCommandBarFlyout>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_TextCommandBarFlyout[] = {
        { "_assign_array_", _assign_array_TextCommandBarFlyout, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_TextCommandBarFlyout), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_TextCommandBarFlyout[] = {
        { }};

    static PyType_Slot _type_slots_TextCommandBarFlyout[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_TextCommandBarFlyout) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_TextCommandBarFlyout) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_TextCommandBarFlyout) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_TextCommandBarFlyout) },
        { }};

    static PyType_Spec type_spec_TextCommandBarFlyout = {
        "winui2._winui2_microsoft_ui_xaml_controls.TextCommandBarFlyout",
        sizeof(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_TextCommandBarFlyout};

    static PyGetSetDef getset_TextCommandBarFlyout_Static[] = {
        { }};

    static PyMethodDef methods_TextCommandBarFlyout_Static[] = {
        { }};

    static PyType_Slot type_slots_TextCommandBarFlyout_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_TextCommandBarFlyout_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_TextCommandBarFlyout_Static) },
        { }
    };

    static PyType_Spec type_spec_TextCommandBarFlyout_Static = {
        "winui2._winui2_microsoft_ui_xaml_controls.TextCommandBarFlyout_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_TextCommandBarFlyout_Static};

    // ----- ToggleSplitButton class --------------------

    struct PyWinrtToggleSplitButton;
    using BasePyWinrtToggleSplitButton = winrt::Microsoft::UI::Xaml::Controls::ToggleSplitButtonT<PyWinrtToggleSplitButton, py::IPywinrtObject>;

    struct PyWinrtToggleSplitButton : py::py_obj_ref, BasePyWinrtToggleSplitButton
    {
        PyWinrtToggleSplitButton(PyObject* py_obj) : py::py_obj_ref(py_obj), BasePyWinrtToggleSplitButton() {}

        int32_t __stdcall GetPyObject(PyObject*& obj) override
        {
            obj = py::py_obj_ref::get_py_obj();
            return 0;
        }

        int32_t __stdcall GetComposableInner(winrt::Windows::Foundation::IInspectable& inner) override
        {
            inner = m_inner;
            return winrt::impl::error_ok;
        }

        static void toggle_reference(PyWinrtToggleSplitButton* instance, bool is_last_reference)
        {
            py::py_obj_ref::toggle_reference(instance, is_last_reference);
        }

        int32_t query_interface_tearoff(winrt::guid const& id, void** result) const noexcept override
        {
            return py::py_obj_ref::query_interface_tearoff(id, result);
        }

        std::vector<winrt::guid> get_iids_tearoff() const noexcept override
        {
            return py::py_obj_ref::get_iids_tearoff();
        }
    };

    static PyObject* _new_ToggleSplitButton(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_GET_SIZE(args);

        auto self_type = get_python_type_for<winrt::Microsoft::UI::Xaml::Controls::ToggleSplitButton>();
        if (!self_type)
        {
            return nullptr;
        }

        if (arg_count == 0)
        {
            try
            {
                if (type != self_type)
                {
                    py::pyobj_handle self{type->tp_alloc(type, 0)};
                    if (!self)
                    {
                        return nullptr;
                    }

                    std::construct_at(&reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj, nullptr);

                    auto obj_impl = winrt::make_self<PyWinrtToggleSplitButton>(self.get());

                    auto obj = py::make_py_obj<PyWinrtToggleSplitButton>(obj_impl, type, self.get());
                    if (!obj)
                    {
                        return nullptr;
                    }

                    reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj = std::move(obj);

                    return self.detach();
                }

                winrt::Microsoft::UI::Xaml::Controls::ToggleSplitButton instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ToggleSplitButton(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ToggleSplitButton_get_IsChecked(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ToggleSplitButton", L"IsChecked");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::ToggleSplitButton>().IsChecked();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ToggleSplitButton_put_IsChecked(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ToggleSplitButton", L"IsChecked");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::ToggleSplitButton>().IsChecked(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ToggleSplitButton_get_IsCheckedProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ToggleSplitButton", L"IsCheckedProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::ToggleSplitButton::IsCheckedProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ToggleSplitButton_add_IsCheckedChanged(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.ToggleSplitButton", L"IsCheckedChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Xaml::Controls::ToggleSplitButton, winrt::Microsoft::UI::Xaml::Controls::ToggleSplitButtonIsCheckedChangedEventArgs>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::ToggleSplitButton>().IsCheckedChanged(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ToggleSplitButton_remove_IsCheckedChanged(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.ToggleSplitButton", L"IsCheckedChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::ToggleSplitButton>().IsCheckedChanged(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ToggleSplitButton(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::ToggleSplitButton>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ToggleSplitButton(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::ToggleSplitButton>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ToggleSplitButton[] = {
        { "add_is_checked_changed", reinterpret_cast<PyCFunction>(ToggleSplitButton_add_IsCheckedChanged), METH_O, nullptr },
        { "remove_is_checked_changed", reinterpret_cast<PyCFunction>(ToggleSplitButton_remove_IsCheckedChanged), METH_O, nullptr },
        { "_assign_array_", _assign_array_ToggleSplitButton, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ToggleSplitButton), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_ToggleSplitButton[] = {
        { "is_checked", reinterpret_cast<getter>(ToggleSplitButton_get_IsChecked), reinterpret_cast<setter>(ToggleSplitButton_put_IsChecked), nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_ToggleSplitButton[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ToggleSplitButton) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ToggleSplitButton) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ToggleSplitButton) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ToggleSplitButton) },
        { }};

    static PyType_Spec type_spec_ToggleSplitButton = {
        "winui2._winui2_microsoft_ui_xaml_controls.ToggleSplitButton",
        sizeof(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_ToggleSplitButton};

    static PyGetSetDef getset_ToggleSplitButton_Static[] = {
        { "is_checked_property", reinterpret_cast<getter>(ToggleSplitButton_get_IsCheckedProperty), nullptr, nullptr, nullptr },
        { }};

    static PyMethodDef methods_ToggleSplitButton_Static[] = {
        { }};

    static PyType_Slot type_slots_ToggleSplitButton_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_ToggleSplitButton_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_ToggleSplitButton_Static) },
        { }
    };

    static PyType_Spec type_spec_ToggleSplitButton_Static = {
        "winui2._winui2_microsoft_ui_xaml_controls.ToggleSplitButton_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_ToggleSplitButton_Static};

    // ----- ToggleSplitButtonIsCheckedChangedEventArgs class --------------------

    static PyObject* _new_ToggleSplitButtonIsCheckedChangedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Xaml::Controls::ToggleSplitButtonIsCheckedChangedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Xaml::Controls::ToggleSplitButtonIsCheckedChangedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_ToggleSplitButtonIsCheckedChangedEventArgs(py::wrapper::Microsoft::UI::Xaml::Controls::ToggleSplitButtonIsCheckedChangedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_ToggleSplitButtonIsCheckedChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::ToggleSplitButtonIsCheckedChangedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ToggleSplitButtonIsCheckedChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::ToggleSplitButtonIsCheckedChangedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ToggleSplitButtonIsCheckedChangedEventArgs[] = {
        { "_assign_array_", _assign_array_ToggleSplitButtonIsCheckedChangedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ToggleSplitButtonIsCheckedChangedEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_ToggleSplitButtonIsCheckedChangedEventArgs[] = {
        { }};

    static PyType_Slot _type_slots_ToggleSplitButtonIsCheckedChangedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ToggleSplitButtonIsCheckedChangedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ToggleSplitButtonIsCheckedChangedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ToggleSplitButtonIsCheckedChangedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ToggleSplitButtonIsCheckedChangedEventArgs) },
        { }};

    static PyType_Spec type_spec_ToggleSplitButtonIsCheckedChangedEventArgs = {
        "winui2._winui2_microsoft_ui_xaml_controls.ToggleSplitButtonIsCheckedChangedEventArgs",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Controls::ToggleSplitButtonIsCheckedChangedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ToggleSplitButtonIsCheckedChangedEventArgs};

    // ----- TreeView class --------------------

    struct PyWinrtTreeView;
    using BasePyWinrtTreeView = winrt::Microsoft::UI::Xaml::Controls::TreeViewT<PyWinrtTreeView, py::IPywinrtObject>;

    struct PyWinrtTreeView : py::py_obj_ref, BasePyWinrtTreeView
    {
        PyWinrtTreeView(PyObject* py_obj) : py::py_obj_ref(py_obj), BasePyWinrtTreeView() {}

        int32_t __stdcall GetPyObject(PyObject*& obj) override
        {
            obj = py::py_obj_ref::get_py_obj();
            return 0;
        }

        int32_t __stdcall GetComposableInner(winrt::Windows::Foundation::IInspectable& inner) override
        {
            inner = m_inner;
            return winrt::impl::error_ok;
        }

        static void toggle_reference(PyWinrtTreeView* instance, bool is_last_reference)
        {
            py::py_obj_ref::toggle_reference(instance, is_last_reference);
        }

        int32_t query_interface_tearoff(winrt::guid const& id, void** result) const noexcept override
        {
            return py::py_obj_ref::query_interface_tearoff(id, result);
        }

        std::vector<winrt::guid> get_iids_tearoff() const noexcept override
        {
            return py::py_obj_ref::get_iids_tearoff();
        }
    };

    static PyObject* _new_TreeView(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_GET_SIZE(args);

        auto self_type = get_python_type_for<winrt::Microsoft::UI::Xaml::Controls::TreeView>();
        if (!self_type)
        {
            return nullptr;
        }

        if (arg_count == 0)
        {
            try
            {
                if (type != self_type)
                {
                    py::pyobj_handle self{type->tp_alloc(type, 0)};
                    if (!self)
                    {
                        return nullptr;
                    }

                    std::construct_at(&reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj, nullptr);

                    auto obj_impl = winrt::make_self<PyWinrtTreeView>(self.get());

                    auto obj = py::make_py_obj<PyWinrtTreeView>(obj_impl, type, self.get());
                    if (!obj)
                    {
                        return nullptr;
                    }

                    reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj = std::move(obj);

                    return self.detach();
                }

                winrt::Microsoft::UI::Xaml::Controls::TreeView instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_TreeView(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* TreeView_Collapse(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.TreeView", L"Collapse", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::TreeViewNode>(args, 0);

                {
                    auto _gil = release_gil();
                    self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::TreeView>().Collapse(param0);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TreeView_ContainerFromItem(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.TreeView", L"ContainerFromItem", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::TreeView>().ContainerFromItem(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TreeView_ContainerFromNode(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.TreeView", L"ContainerFromNode", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::TreeViewNode>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::TreeView>().ContainerFromNode(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TreeView_Expand(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.TreeView", L"Expand", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::TreeViewNode>(args, 0);

                {
                    auto _gil = release_gil();
                    self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::TreeView>().Expand(param0);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TreeView_ItemFromContainer(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.TreeView", L"ItemFromContainer", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::DependencyObject>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::TreeView>().ItemFromContainer(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TreeView_NodeFromContainer(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.TreeView", L"NodeFromContainer", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::DependencyObject>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::TreeView>().NodeFromContainer(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TreeView_SelectAll(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.TreeView", L"SelectAll", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::TreeView>().SelectAll();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TreeView_get_SelectionMode(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TreeView", L"SelectionMode");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::TreeView>().SelectionMode();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TreeView_put_SelectionMode(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TreeView", L"SelectionMode");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::TreeViewSelectionMode>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::TreeView>().SelectionMode(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TreeView_get_RootNodes(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TreeView", L"RootNodes");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::TreeView>().RootNodes();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TreeView_get_SelectedNodes(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TreeView", L"SelectedNodes");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::TreeView>().SelectedNodes();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TreeView_get_SelectedNode(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TreeView", L"SelectedNode");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::TreeView>().SelectedNode();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TreeView_put_SelectedNode(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TreeView", L"SelectedNode");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::TreeViewNode>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::TreeView>().SelectedNode(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TreeView_get_SelectedItem(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TreeView", L"SelectedItem");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::TreeView>().SelectedItem();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TreeView_put_SelectedItem(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TreeView", L"SelectedItem");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::TreeView>().SelectedItem(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TreeView_get_ItemsSource(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TreeView", L"ItemsSource");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::TreeView>().ItemsSource();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TreeView_put_ItemsSource(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TreeView", L"ItemsSource");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::TreeView>().ItemsSource(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TreeView_get_ItemTemplateSelector(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TreeView", L"ItemTemplateSelector");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::TreeView>().ItemTemplateSelector();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TreeView_put_ItemTemplateSelector(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TreeView", L"ItemTemplateSelector");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::DataTemplateSelector>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::TreeView>().ItemTemplateSelector(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TreeView_get_ItemTemplate(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TreeView", L"ItemTemplate");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::TreeView>().ItemTemplate();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TreeView_put_ItemTemplate(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TreeView", L"ItemTemplate");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::DataTemplate>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::TreeView>().ItemTemplate(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TreeView_get_ItemContainerTransitions(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TreeView", L"ItemContainerTransitions");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::TreeView>().ItemContainerTransitions();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TreeView_put_ItemContainerTransitions(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TreeView", L"ItemContainerTransitions");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Media::Animation::TransitionCollection>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::TreeView>().ItemContainerTransitions(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TreeView_get_ItemContainerStyleSelector(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TreeView", L"ItemContainerStyleSelector");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::TreeView>().ItemContainerStyleSelector();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TreeView_put_ItemContainerStyleSelector(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TreeView", L"ItemContainerStyleSelector");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::StyleSelector>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::TreeView>().ItemContainerStyleSelector(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TreeView_get_ItemContainerStyle(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TreeView", L"ItemContainerStyle");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::TreeView>().ItemContainerStyle();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TreeView_put_ItemContainerStyle(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TreeView", L"ItemContainerStyle");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Style>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::TreeView>().ItemContainerStyle(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TreeView_get_CanReorderItems(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TreeView", L"CanReorderItems");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::TreeView>().CanReorderItems();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TreeView_put_CanReorderItems(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TreeView", L"CanReorderItems");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::TreeView>().CanReorderItems(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TreeView_get_CanDragItems(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TreeView", L"CanDragItems");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::TreeView>().CanDragItems();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TreeView_put_CanDragItems(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TreeView", L"CanDragItems");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::TreeView>().CanDragItems(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TreeView_get_SelectedItems(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TreeView", L"SelectedItems");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::TreeView>().SelectedItems();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TreeView_get_SelectedItemProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TreeView", L"SelectedItemProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::TreeView::SelectedItemProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TreeView_get_SelectionModeProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TreeView", L"SelectionModeProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::TreeView::SelectionModeProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TreeView_get_CanDragItemsProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TreeView", L"CanDragItemsProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::TreeView::CanDragItemsProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TreeView_get_CanReorderItemsProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TreeView", L"CanReorderItemsProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::TreeView::CanReorderItemsProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TreeView_get_ItemContainerStyleProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TreeView", L"ItemContainerStyleProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::TreeView::ItemContainerStyleProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TreeView_get_ItemContainerStyleSelectorProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TreeView", L"ItemContainerStyleSelectorProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::TreeView::ItemContainerStyleSelectorProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TreeView_get_ItemContainerTransitionsProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TreeView", L"ItemContainerTransitionsProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::TreeView::ItemContainerTransitionsProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TreeView_get_ItemTemplateProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TreeView", L"ItemTemplateProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::TreeView::ItemTemplateProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TreeView_get_ItemTemplateSelectorProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TreeView", L"ItemTemplateSelectorProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::TreeView::ItemTemplateSelectorProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TreeView_get_ItemsSourceProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TreeView", L"ItemsSourceProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::TreeView::ItemsSourceProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TreeView_add_Collapsed(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.TreeView", L"Collapsed");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Xaml::Controls::TreeView, winrt::Microsoft::UI::Xaml::Controls::TreeViewCollapsedEventArgs>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::TreeView>().Collapsed(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TreeView_remove_Collapsed(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.TreeView", L"Collapsed");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::TreeView>().Collapsed(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TreeView_add_Expanding(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.TreeView", L"Expanding");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Xaml::Controls::TreeView, winrt::Microsoft::UI::Xaml::Controls::TreeViewExpandingEventArgs>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::TreeView>().Expanding(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TreeView_remove_Expanding(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.TreeView", L"Expanding");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::TreeView>().Expanding(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TreeView_add_ItemInvoked(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.TreeView", L"ItemInvoked");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Xaml::Controls::TreeView, winrt::Microsoft::UI::Xaml::Controls::TreeViewItemInvokedEventArgs>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::TreeView>().ItemInvoked(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TreeView_remove_ItemInvoked(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.TreeView", L"ItemInvoked");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::TreeView>().ItemInvoked(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TreeView_add_DragItemsCompleted(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.TreeView", L"DragItemsCompleted");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Xaml::Controls::TreeView, winrt::Microsoft::UI::Xaml::Controls::TreeViewDragItemsCompletedEventArgs>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::TreeView>().DragItemsCompleted(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TreeView_remove_DragItemsCompleted(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.TreeView", L"DragItemsCompleted");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::TreeView>().DragItemsCompleted(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TreeView_add_DragItemsStarting(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.TreeView", L"DragItemsStarting");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Xaml::Controls::TreeView, winrt::Microsoft::UI::Xaml::Controls::TreeViewDragItemsStartingEventArgs>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::TreeView>().DragItemsStarting(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TreeView_remove_DragItemsStarting(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.TreeView", L"DragItemsStarting");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::TreeView>().DragItemsStarting(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_TreeView(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::TreeView>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_TreeView(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::TreeView>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_TreeView[] = {
        { "collapse", reinterpret_cast<PyCFunction>(TreeView_Collapse), METH_VARARGS, nullptr },
        { "container_from_item", reinterpret_cast<PyCFunction>(TreeView_ContainerFromItem), METH_VARARGS, nullptr },
        { "container_from_node", reinterpret_cast<PyCFunction>(TreeView_ContainerFromNode), METH_VARARGS, nullptr },
        { "expand", reinterpret_cast<PyCFunction>(TreeView_Expand), METH_VARARGS, nullptr },
        { "item_from_container", reinterpret_cast<PyCFunction>(TreeView_ItemFromContainer), METH_VARARGS, nullptr },
        { "node_from_container", reinterpret_cast<PyCFunction>(TreeView_NodeFromContainer), METH_VARARGS, nullptr },
        { "select_all", reinterpret_cast<PyCFunction>(TreeView_SelectAll), METH_VARARGS, nullptr },
        { "add_collapsed", reinterpret_cast<PyCFunction>(TreeView_add_Collapsed), METH_O, nullptr },
        { "remove_collapsed", reinterpret_cast<PyCFunction>(TreeView_remove_Collapsed), METH_O, nullptr },
        { "add_expanding", reinterpret_cast<PyCFunction>(TreeView_add_Expanding), METH_O, nullptr },
        { "remove_expanding", reinterpret_cast<PyCFunction>(TreeView_remove_Expanding), METH_O, nullptr },
        { "add_item_invoked", reinterpret_cast<PyCFunction>(TreeView_add_ItemInvoked), METH_O, nullptr },
        { "remove_item_invoked", reinterpret_cast<PyCFunction>(TreeView_remove_ItemInvoked), METH_O, nullptr },
        { "add_drag_items_completed", reinterpret_cast<PyCFunction>(TreeView_add_DragItemsCompleted), METH_O, nullptr },
        { "remove_drag_items_completed", reinterpret_cast<PyCFunction>(TreeView_remove_DragItemsCompleted), METH_O, nullptr },
        { "add_drag_items_starting", reinterpret_cast<PyCFunction>(TreeView_add_DragItemsStarting), METH_O, nullptr },
        { "remove_drag_items_starting", reinterpret_cast<PyCFunction>(TreeView_remove_DragItemsStarting), METH_O, nullptr },
        { "_assign_array_", _assign_array_TreeView, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_TreeView), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_TreeView[] = {
        { "selection_mode", reinterpret_cast<getter>(TreeView_get_SelectionMode), reinterpret_cast<setter>(TreeView_put_SelectionMode), nullptr, nullptr },
        { "root_nodes", reinterpret_cast<getter>(TreeView_get_RootNodes), nullptr, nullptr, nullptr },
        { "selected_nodes", reinterpret_cast<getter>(TreeView_get_SelectedNodes), nullptr, nullptr, nullptr },
        { "selected_node", reinterpret_cast<getter>(TreeView_get_SelectedNode), reinterpret_cast<setter>(TreeView_put_SelectedNode), nullptr, nullptr },
        { "selected_item", reinterpret_cast<getter>(TreeView_get_SelectedItem), reinterpret_cast<setter>(TreeView_put_SelectedItem), nullptr, nullptr },
        { "items_source", reinterpret_cast<getter>(TreeView_get_ItemsSource), reinterpret_cast<setter>(TreeView_put_ItemsSource), nullptr, nullptr },
        { "item_template_selector", reinterpret_cast<getter>(TreeView_get_ItemTemplateSelector), reinterpret_cast<setter>(TreeView_put_ItemTemplateSelector), nullptr, nullptr },
        { "item_template", reinterpret_cast<getter>(TreeView_get_ItemTemplate), reinterpret_cast<setter>(TreeView_put_ItemTemplate), nullptr, nullptr },
        { "item_container_transitions", reinterpret_cast<getter>(TreeView_get_ItemContainerTransitions), reinterpret_cast<setter>(TreeView_put_ItemContainerTransitions), nullptr, nullptr },
        { "item_container_style_selector", reinterpret_cast<getter>(TreeView_get_ItemContainerStyleSelector), reinterpret_cast<setter>(TreeView_put_ItemContainerStyleSelector), nullptr, nullptr },
        { "item_container_style", reinterpret_cast<getter>(TreeView_get_ItemContainerStyle), reinterpret_cast<setter>(TreeView_put_ItemContainerStyle), nullptr, nullptr },
        { "can_reorder_items", reinterpret_cast<getter>(TreeView_get_CanReorderItems), reinterpret_cast<setter>(TreeView_put_CanReorderItems), nullptr, nullptr },
        { "can_drag_items", reinterpret_cast<getter>(TreeView_get_CanDragItems), reinterpret_cast<setter>(TreeView_put_CanDragItems), nullptr, nullptr },
        { "selected_items", reinterpret_cast<getter>(TreeView_get_SelectedItems), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_TreeView[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_TreeView) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_TreeView) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_TreeView) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_TreeView) },
        { }};

    static PyType_Spec type_spec_TreeView = {
        "winui2._winui2_microsoft_ui_xaml_controls.TreeView",
        sizeof(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_TreeView};

    static PyGetSetDef getset_TreeView_Static[] = {
        { "selected_item_property", reinterpret_cast<getter>(TreeView_get_SelectedItemProperty), nullptr, nullptr, nullptr },
        { "selection_mode_property", reinterpret_cast<getter>(TreeView_get_SelectionModeProperty), nullptr, nullptr, nullptr },
        { "can_drag_items_property", reinterpret_cast<getter>(TreeView_get_CanDragItemsProperty), nullptr, nullptr, nullptr },
        { "can_reorder_items_property", reinterpret_cast<getter>(TreeView_get_CanReorderItemsProperty), nullptr, nullptr, nullptr },
        { "item_container_style_property", reinterpret_cast<getter>(TreeView_get_ItemContainerStyleProperty), nullptr, nullptr, nullptr },
        { "item_container_style_selector_property", reinterpret_cast<getter>(TreeView_get_ItemContainerStyleSelectorProperty), nullptr, nullptr, nullptr },
        { "item_container_transitions_property", reinterpret_cast<getter>(TreeView_get_ItemContainerTransitionsProperty), nullptr, nullptr, nullptr },
        { "item_template_property", reinterpret_cast<getter>(TreeView_get_ItemTemplateProperty), nullptr, nullptr, nullptr },
        { "item_template_selector_property", reinterpret_cast<getter>(TreeView_get_ItemTemplateSelectorProperty), nullptr, nullptr, nullptr },
        { "items_source_property", reinterpret_cast<getter>(TreeView_get_ItemsSourceProperty), nullptr, nullptr, nullptr },
        { }};

    static PyMethodDef methods_TreeView_Static[] = {
        { }};

    static PyType_Slot type_slots_TreeView_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_TreeView_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_TreeView_Static) },
        { }
    };

    static PyType_Spec type_spec_TreeView_Static = {
        "winui2._winui2_microsoft_ui_xaml_controls.TreeView_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_TreeView_Static};

    // ----- TreeViewCollapsedEventArgs class --------------------

    static PyObject* _new_TreeViewCollapsedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Xaml::Controls::TreeViewCollapsedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Xaml::Controls::TreeViewCollapsedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_TreeViewCollapsedEventArgs(py::wrapper::Microsoft::UI::Xaml::Controls::TreeViewCollapsedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* TreeViewCollapsedEventArgs_get_Node(py::wrapper::Microsoft::UI::Xaml::Controls::TreeViewCollapsedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TreeViewCollapsedEventArgs", L"Node");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Node();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TreeViewCollapsedEventArgs_get_Item(py::wrapper::Microsoft::UI::Xaml::Controls::TreeViewCollapsedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TreeViewCollapsedEventArgs", L"Item");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Item();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_TreeViewCollapsedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::TreeViewCollapsedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_TreeViewCollapsedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::TreeViewCollapsedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_TreeViewCollapsedEventArgs[] = {
        { "_assign_array_", _assign_array_TreeViewCollapsedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_TreeViewCollapsedEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_TreeViewCollapsedEventArgs[] = {
        { "node", reinterpret_cast<getter>(TreeViewCollapsedEventArgs_get_Node), nullptr, nullptr, nullptr },
        { "item", reinterpret_cast<getter>(TreeViewCollapsedEventArgs_get_Item), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_TreeViewCollapsedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_TreeViewCollapsedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_TreeViewCollapsedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_TreeViewCollapsedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_TreeViewCollapsedEventArgs) },
        { }};

    static PyType_Spec type_spec_TreeViewCollapsedEventArgs = {
        "winui2._winui2_microsoft_ui_xaml_controls.TreeViewCollapsedEventArgs",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Controls::TreeViewCollapsedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TreeViewCollapsedEventArgs};

    // ----- TreeViewDragItemsCompletedEventArgs class --------------------

    static PyObject* _new_TreeViewDragItemsCompletedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Xaml::Controls::TreeViewDragItemsCompletedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Xaml::Controls::TreeViewDragItemsCompletedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_TreeViewDragItemsCompletedEventArgs(py::wrapper::Microsoft::UI::Xaml::Controls::TreeViewDragItemsCompletedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* TreeViewDragItemsCompletedEventArgs_get_DropResult(py::wrapper::Microsoft::UI::Xaml::Controls::TreeViewDragItemsCompletedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TreeViewDragItemsCompletedEventArgs", L"DropResult");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.DropResult();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TreeViewDragItemsCompletedEventArgs_get_Items(py::wrapper::Microsoft::UI::Xaml::Controls::TreeViewDragItemsCompletedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TreeViewDragItemsCompletedEventArgs", L"Items");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Items();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TreeViewDragItemsCompletedEventArgs_get_NewParentItem(py::wrapper::Microsoft::UI::Xaml::Controls::TreeViewDragItemsCompletedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TreeViewDragItemsCompletedEventArgs", L"NewParentItem");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.NewParentItem();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_TreeViewDragItemsCompletedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::TreeViewDragItemsCompletedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_TreeViewDragItemsCompletedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::TreeViewDragItemsCompletedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_TreeViewDragItemsCompletedEventArgs[] = {
        { "_assign_array_", _assign_array_TreeViewDragItemsCompletedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_TreeViewDragItemsCompletedEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_TreeViewDragItemsCompletedEventArgs[] = {
        { "drop_result", reinterpret_cast<getter>(TreeViewDragItemsCompletedEventArgs_get_DropResult), nullptr, nullptr, nullptr },
        { "items", reinterpret_cast<getter>(TreeViewDragItemsCompletedEventArgs_get_Items), nullptr, nullptr, nullptr },
        { "new_parent_item", reinterpret_cast<getter>(TreeViewDragItemsCompletedEventArgs_get_NewParentItem), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_TreeViewDragItemsCompletedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_TreeViewDragItemsCompletedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_TreeViewDragItemsCompletedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_TreeViewDragItemsCompletedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_TreeViewDragItemsCompletedEventArgs) },
        { }};

    static PyType_Spec type_spec_TreeViewDragItemsCompletedEventArgs = {
        "winui2._winui2_microsoft_ui_xaml_controls.TreeViewDragItemsCompletedEventArgs",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Controls::TreeViewDragItemsCompletedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TreeViewDragItemsCompletedEventArgs};

    // ----- TreeViewDragItemsStartingEventArgs class --------------------

    static PyObject* _new_TreeViewDragItemsStartingEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Xaml::Controls::TreeViewDragItemsStartingEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Xaml::Controls::TreeViewDragItemsStartingEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_TreeViewDragItemsStartingEventArgs(py::wrapper::Microsoft::UI::Xaml::Controls::TreeViewDragItemsStartingEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* TreeViewDragItemsStartingEventArgs_get_Cancel(py::wrapper::Microsoft::UI::Xaml::Controls::TreeViewDragItemsStartingEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TreeViewDragItemsStartingEventArgs", L"Cancel");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Cancel();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TreeViewDragItemsStartingEventArgs_put_Cancel(py::wrapper::Microsoft::UI::Xaml::Controls::TreeViewDragItemsStartingEventArgs* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TreeViewDragItemsStartingEventArgs", L"Cancel");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.Cancel(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TreeViewDragItemsStartingEventArgs_get_Data(py::wrapper::Microsoft::UI::Xaml::Controls::TreeViewDragItemsStartingEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TreeViewDragItemsStartingEventArgs", L"Data");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Data();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TreeViewDragItemsStartingEventArgs_get_Items(py::wrapper::Microsoft::UI::Xaml::Controls::TreeViewDragItemsStartingEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TreeViewDragItemsStartingEventArgs", L"Items");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Items();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_TreeViewDragItemsStartingEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::TreeViewDragItemsStartingEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_TreeViewDragItemsStartingEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::TreeViewDragItemsStartingEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_TreeViewDragItemsStartingEventArgs[] = {
        { "_assign_array_", _assign_array_TreeViewDragItemsStartingEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_TreeViewDragItemsStartingEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_TreeViewDragItemsStartingEventArgs[] = {
        { "cancel", reinterpret_cast<getter>(TreeViewDragItemsStartingEventArgs_get_Cancel), reinterpret_cast<setter>(TreeViewDragItemsStartingEventArgs_put_Cancel), nullptr, nullptr },
        { "data", reinterpret_cast<getter>(TreeViewDragItemsStartingEventArgs_get_Data), nullptr, nullptr, nullptr },
        { "items", reinterpret_cast<getter>(TreeViewDragItemsStartingEventArgs_get_Items), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_TreeViewDragItemsStartingEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_TreeViewDragItemsStartingEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_TreeViewDragItemsStartingEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_TreeViewDragItemsStartingEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_TreeViewDragItemsStartingEventArgs) },
        { }};

    static PyType_Spec type_spec_TreeViewDragItemsStartingEventArgs = {
        "winui2._winui2_microsoft_ui_xaml_controls.TreeViewDragItemsStartingEventArgs",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Controls::TreeViewDragItemsStartingEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TreeViewDragItemsStartingEventArgs};

    // ----- TreeViewExpandingEventArgs class --------------------

    static PyObject* _new_TreeViewExpandingEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Xaml::Controls::TreeViewExpandingEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Xaml::Controls::TreeViewExpandingEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_TreeViewExpandingEventArgs(py::wrapper::Microsoft::UI::Xaml::Controls::TreeViewExpandingEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* TreeViewExpandingEventArgs_get_Node(py::wrapper::Microsoft::UI::Xaml::Controls::TreeViewExpandingEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TreeViewExpandingEventArgs", L"Node");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Node();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TreeViewExpandingEventArgs_get_Item(py::wrapper::Microsoft::UI::Xaml::Controls::TreeViewExpandingEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TreeViewExpandingEventArgs", L"Item");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Item();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_TreeViewExpandingEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::TreeViewExpandingEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_TreeViewExpandingEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::TreeViewExpandingEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_TreeViewExpandingEventArgs[] = {
        { "_assign_array_", _assign_array_TreeViewExpandingEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_TreeViewExpandingEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_TreeViewExpandingEventArgs[] = {
        { "node", reinterpret_cast<getter>(TreeViewExpandingEventArgs_get_Node), nullptr, nullptr, nullptr },
        { "item", reinterpret_cast<getter>(TreeViewExpandingEventArgs_get_Item), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_TreeViewExpandingEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_TreeViewExpandingEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_TreeViewExpandingEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_TreeViewExpandingEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_TreeViewExpandingEventArgs) },
        { }};

    static PyType_Spec type_spec_TreeViewExpandingEventArgs = {
        "winui2._winui2_microsoft_ui_xaml_controls.TreeViewExpandingEventArgs",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Controls::TreeViewExpandingEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TreeViewExpandingEventArgs};

    // ----- TreeViewItem class --------------------

    struct PyWinrtTreeViewItem;
    using BasePyWinrtTreeViewItem = winrt::Microsoft::UI::Xaml::Controls::TreeViewItemT<PyWinrtTreeViewItem, py::IPywinrtObject>;

    struct PyWinrtTreeViewItem : py::py_obj_ref, BasePyWinrtTreeViewItem
    {
        PyWinrtTreeViewItem(PyObject* py_obj) : py::py_obj_ref(py_obj), BasePyWinrtTreeViewItem() {}

        int32_t __stdcall GetPyObject(PyObject*& obj) override
        {
            obj = py::py_obj_ref::get_py_obj();
            return 0;
        }

        int32_t __stdcall GetComposableInner(winrt::Windows::Foundation::IInspectable& inner) override
        {
            inner = m_inner;
            return winrt::impl::error_ok;
        }

        static void toggle_reference(PyWinrtTreeViewItem* instance, bool is_last_reference)
        {
            py::py_obj_ref::toggle_reference(instance, is_last_reference);
        }

        int32_t query_interface_tearoff(winrt::guid const& id, void** result) const noexcept override
        {
            return py::py_obj_ref::query_interface_tearoff(id, result);
        }

        std::vector<winrt::guid> get_iids_tearoff() const noexcept override
        {
            return py::py_obj_ref::get_iids_tearoff();
        }
    };

    static PyObject* _new_TreeViewItem(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_GET_SIZE(args);

        auto self_type = get_python_type_for<winrt::Microsoft::UI::Xaml::Controls::TreeViewItem>();
        if (!self_type)
        {
            return nullptr;
        }

        if (arg_count == 0)
        {
            try
            {
                if (type != self_type)
                {
                    py::pyobj_handle self{type->tp_alloc(type, 0)};
                    if (!self)
                    {
                        return nullptr;
                    }

                    std::construct_at(&reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj, nullptr);

                    auto obj_impl = winrt::make_self<PyWinrtTreeViewItem>(self.get());

                    auto obj = py::make_py_obj<PyWinrtTreeViewItem>(obj_impl, type, self.get());
                    if (!obj)
                    {
                        return nullptr;
                    }

                    reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj = std::move(obj);

                    return self.detach();
                }

                winrt::Microsoft::UI::Xaml::Controls::TreeViewItem instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_TreeViewItem(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* TreeViewItem_get_IsExpanded(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TreeViewItem", L"IsExpanded");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::TreeViewItem>().IsExpanded();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TreeViewItem_put_IsExpanded(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TreeViewItem", L"IsExpanded");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::TreeViewItem>().IsExpanded(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TreeViewItem_get_GlyphSize(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TreeViewItem", L"GlyphSize");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::TreeViewItem>().GlyphSize();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TreeViewItem_put_GlyphSize(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TreeViewItem", L"GlyphSize");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<double>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::TreeViewItem>().GlyphSize(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TreeViewItem_get_GlyphOpacity(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TreeViewItem", L"GlyphOpacity");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::TreeViewItem>().GlyphOpacity();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TreeViewItem_put_GlyphOpacity(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TreeViewItem", L"GlyphOpacity");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<double>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::TreeViewItem>().GlyphOpacity(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TreeViewItem_get_GlyphBrush(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TreeViewItem", L"GlyphBrush");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::TreeViewItem>().GlyphBrush();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TreeViewItem_put_GlyphBrush(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TreeViewItem", L"GlyphBrush");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Media::Brush>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::TreeViewItem>().GlyphBrush(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TreeViewItem_get_ExpandedGlyph(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TreeViewItem", L"ExpandedGlyph");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::TreeViewItem>().ExpandedGlyph();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TreeViewItem_put_ExpandedGlyph(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TreeViewItem", L"ExpandedGlyph");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::TreeViewItem>().ExpandedGlyph(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TreeViewItem_get_CollapsedGlyph(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TreeViewItem", L"CollapsedGlyph");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::TreeViewItem>().CollapsedGlyph();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TreeViewItem_put_CollapsedGlyph(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TreeViewItem", L"CollapsedGlyph");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::TreeViewItem>().CollapsedGlyph(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TreeViewItem_get_TreeViewItemTemplateSettings(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TreeViewItem", L"TreeViewItemTemplateSettings");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::TreeViewItem>().TreeViewItemTemplateSettings();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TreeViewItem_get_ItemsSource(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TreeViewItem", L"ItemsSource");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::TreeViewItem>().ItemsSource();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TreeViewItem_put_ItemsSource(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TreeViewItem", L"ItemsSource");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::TreeViewItem>().ItemsSource(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TreeViewItem_get_HasUnrealizedChildren(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TreeViewItem", L"HasUnrealizedChildren");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::TreeViewItem>().HasUnrealizedChildren();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TreeViewItem_put_HasUnrealizedChildren(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TreeViewItem", L"HasUnrealizedChildren");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::TreeViewItem>().HasUnrealizedChildren(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TreeViewItem_get_CollapsedGlyphProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TreeViewItem", L"CollapsedGlyphProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::TreeViewItem::CollapsedGlyphProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TreeViewItem_get_ExpandedGlyphProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TreeViewItem", L"ExpandedGlyphProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::TreeViewItem::ExpandedGlyphProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TreeViewItem_get_GlyphBrushProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TreeViewItem", L"GlyphBrushProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::TreeViewItem::GlyphBrushProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TreeViewItem_get_GlyphOpacityProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TreeViewItem", L"GlyphOpacityProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::TreeViewItem::GlyphOpacityProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TreeViewItem_get_GlyphSizeProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TreeViewItem", L"GlyphSizeProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::TreeViewItem::GlyphSizeProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TreeViewItem_get_IsExpandedProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TreeViewItem", L"IsExpandedProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::TreeViewItem::IsExpandedProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TreeViewItem_get_TreeViewItemTemplateSettingsProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TreeViewItem", L"TreeViewItemTemplateSettingsProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::TreeViewItem::TreeViewItemTemplateSettingsProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TreeViewItem_get_HasUnrealizedChildrenProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TreeViewItem", L"HasUnrealizedChildrenProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::TreeViewItem::HasUnrealizedChildrenProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TreeViewItem_get_ItemsSourceProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TreeViewItem", L"ItemsSourceProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::TreeViewItem::ItemsSourceProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_TreeViewItem(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::TreeViewItem>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_TreeViewItem(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::TreeViewItem>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_TreeViewItem[] = {
        { "_assign_array_", _assign_array_TreeViewItem, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_TreeViewItem), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_TreeViewItem[] = {
        { "is_expanded", reinterpret_cast<getter>(TreeViewItem_get_IsExpanded), reinterpret_cast<setter>(TreeViewItem_put_IsExpanded), nullptr, nullptr },
        { "glyph_size", reinterpret_cast<getter>(TreeViewItem_get_GlyphSize), reinterpret_cast<setter>(TreeViewItem_put_GlyphSize), nullptr, nullptr },
        { "glyph_opacity", reinterpret_cast<getter>(TreeViewItem_get_GlyphOpacity), reinterpret_cast<setter>(TreeViewItem_put_GlyphOpacity), nullptr, nullptr },
        { "glyph_brush", reinterpret_cast<getter>(TreeViewItem_get_GlyphBrush), reinterpret_cast<setter>(TreeViewItem_put_GlyphBrush), nullptr, nullptr },
        { "expanded_glyph", reinterpret_cast<getter>(TreeViewItem_get_ExpandedGlyph), reinterpret_cast<setter>(TreeViewItem_put_ExpandedGlyph), nullptr, nullptr },
        { "collapsed_glyph", reinterpret_cast<getter>(TreeViewItem_get_CollapsedGlyph), reinterpret_cast<setter>(TreeViewItem_put_CollapsedGlyph), nullptr, nullptr },
        { "tree_view_item_template_settings", reinterpret_cast<getter>(TreeViewItem_get_TreeViewItemTemplateSettings), nullptr, nullptr, nullptr },
        { "items_source", reinterpret_cast<getter>(TreeViewItem_get_ItemsSource), reinterpret_cast<setter>(TreeViewItem_put_ItemsSource), nullptr, nullptr },
        { "has_unrealized_children", reinterpret_cast<getter>(TreeViewItem_get_HasUnrealizedChildren), reinterpret_cast<setter>(TreeViewItem_put_HasUnrealizedChildren), nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_TreeViewItem[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_TreeViewItem) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_TreeViewItem) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_TreeViewItem) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_TreeViewItem) },
        { }};

    static PyType_Spec type_spec_TreeViewItem = {
        "winui2._winui2_microsoft_ui_xaml_controls.TreeViewItem",
        sizeof(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_TreeViewItem};

    static PyGetSetDef getset_TreeViewItem_Static[] = {
        { "collapsed_glyph_property", reinterpret_cast<getter>(TreeViewItem_get_CollapsedGlyphProperty), nullptr, nullptr, nullptr },
        { "expanded_glyph_property", reinterpret_cast<getter>(TreeViewItem_get_ExpandedGlyphProperty), nullptr, nullptr, nullptr },
        { "glyph_brush_property", reinterpret_cast<getter>(TreeViewItem_get_GlyphBrushProperty), nullptr, nullptr, nullptr },
        { "glyph_opacity_property", reinterpret_cast<getter>(TreeViewItem_get_GlyphOpacityProperty), nullptr, nullptr, nullptr },
        { "glyph_size_property", reinterpret_cast<getter>(TreeViewItem_get_GlyphSizeProperty), nullptr, nullptr, nullptr },
        { "is_expanded_property", reinterpret_cast<getter>(TreeViewItem_get_IsExpandedProperty), nullptr, nullptr, nullptr },
        { "tree_view_item_template_settings_property", reinterpret_cast<getter>(TreeViewItem_get_TreeViewItemTemplateSettingsProperty), nullptr, nullptr, nullptr },
        { "has_unrealized_children_property", reinterpret_cast<getter>(TreeViewItem_get_HasUnrealizedChildrenProperty), nullptr, nullptr, nullptr },
        { "items_source_property", reinterpret_cast<getter>(TreeViewItem_get_ItemsSourceProperty), nullptr, nullptr, nullptr },
        { }};

    static PyMethodDef methods_TreeViewItem_Static[] = {
        { }};

    static PyType_Slot type_slots_TreeViewItem_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_TreeViewItem_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_TreeViewItem_Static) },
        { }
    };

    static PyType_Spec type_spec_TreeViewItem_Static = {
        "winui2._winui2_microsoft_ui_xaml_controls.TreeViewItem_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_TreeViewItem_Static};

    // ----- TreeViewItemInvokedEventArgs class --------------------

    static PyObject* _new_TreeViewItemInvokedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Xaml::Controls::TreeViewItemInvokedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Xaml::Controls::TreeViewItemInvokedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_TreeViewItemInvokedEventArgs(py::wrapper::Microsoft::UI::Xaml::Controls::TreeViewItemInvokedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* TreeViewItemInvokedEventArgs_get_Handled(py::wrapper::Microsoft::UI::Xaml::Controls::TreeViewItemInvokedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TreeViewItemInvokedEventArgs", L"Handled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Handled();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TreeViewItemInvokedEventArgs_put_Handled(py::wrapper::Microsoft::UI::Xaml::Controls::TreeViewItemInvokedEventArgs* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TreeViewItemInvokedEventArgs", L"Handled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.Handled(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TreeViewItemInvokedEventArgs_get_InvokedItem(py::wrapper::Microsoft::UI::Xaml::Controls::TreeViewItemInvokedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TreeViewItemInvokedEventArgs", L"InvokedItem");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.InvokedItem();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_TreeViewItemInvokedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::TreeViewItemInvokedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_TreeViewItemInvokedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::TreeViewItemInvokedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_TreeViewItemInvokedEventArgs[] = {
        { "_assign_array_", _assign_array_TreeViewItemInvokedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_TreeViewItemInvokedEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_TreeViewItemInvokedEventArgs[] = {
        { "handled", reinterpret_cast<getter>(TreeViewItemInvokedEventArgs_get_Handled), reinterpret_cast<setter>(TreeViewItemInvokedEventArgs_put_Handled), nullptr, nullptr },
        { "invoked_item", reinterpret_cast<getter>(TreeViewItemInvokedEventArgs_get_InvokedItem), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_TreeViewItemInvokedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_TreeViewItemInvokedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_TreeViewItemInvokedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_TreeViewItemInvokedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_TreeViewItemInvokedEventArgs) },
        { }};

    static PyType_Spec type_spec_TreeViewItemInvokedEventArgs = {
        "winui2._winui2_microsoft_ui_xaml_controls.TreeViewItemInvokedEventArgs",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Controls::TreeViewItemInvokedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TreeViewItemInvokedEventArgs};

    // ----- TreeViewItemTemplateSettings class --------------------

    struct PyWinrtTreeViewItemTemplateSettings;
    using BasePyWinrtTreeViewItemTemplateSettings = winrt::Microsoft::UI::Xaml::Controls::TreeViewItemTemplateSettingsT<PyWinrtTreeViewItemTemplateSettings, py::IPywinrtObject>;

    struct PyWinrtTreeViewItemTemplateSettings : py::py_obj_ref, BasePyWinrtTreeViewItemTemplateSettings
    {
        PyWinrtTreeViewItemTemplateSettings(PyObject* py_obj) : py::py_obj_ref(py_obj), BasePyWinrtTreeViewItemTemplateSettings() {}

        int32_t __stdcall GetPyObject(PyObject*& obj) override
        {
            obj = py::py_obj_ref::get_py_obj();
            return 0;
        }

        int32_t __stdcall GetComposableInner(winrt::Windows::Foundation::IInspectable& inner) override
        {
            inner = m_inner;
            return winrt::impl::error_ok;
        }

        static void toggle_reference(PyWinrtTreeViewItemTemplateSettings* instance, bool is_last_reference)
        {
            py::py_obj_ref::toggle_reference(instance, is_last_reference);
        }

        int32_t query_interface_tearoff(winrt::guid const& id, void** result) const noexcept override
        {
            return py::py_obj_ref::query_interface_tearoff(id, result);
        }

        std::vector<winrt::guid> get_iids_tearoff() const noexcept override
        {
            return py::py_obj_ref::get_iids_tearoff();
        }
    };

    static PyObject* _new_TreeViewItemTemplateSettings(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_GET_SIZE(args);

        auto self_type = get_python_type_for<winrt::Microsoft::UI::Xaml::Controls::TreeViewItemTemplateSettings>();
        if (!self_type)
        {
            return nullptr;
        }

        if (arg_count == 0)
        {
            try
            {
                if (type != self_type)
                {
                    py::pyobj_handle self{type->tp_alloc(type, 0)};
                    if (!self)
                    {
                        return nullptr;
                    }

                    std::construct_at(&reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj, nullptr);

                    auto obj_impl = winrt::make_self<PyWinrtTreeViewItemTemplateSettings>(self.get());

                    auto obj = py::make_py_obj<PyWinrtTreeViewItemTemplateSettings>(obj_impl, type, self.get());
                    if (!obj)
                    {
                        return nullptr;
                    }

                    reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj = std::move(obj);

                    return self.detach();
                }

                winrt::Microsoft::UI::Xaml::Controls::TreeViewItemTemplateSettings instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_TreeViewItemTemplateSettings(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* TreeViewItemTemplateSettings_get_CollapsedGlyphVisibility(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TreeViewItemTemplateSettings", L"CollapsedGlyphVisibility");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::TreeViewItemTemplateSettings>().CollapsedGlyphVisibility();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TreeViewItemTemplateSettings_get_DragItemsCount(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TreeViewItemTemplateSettings", L"DragItemsCount");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::TreeViewItemTemplateSettings>().DragItemsCount();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TreeViewItemTemplateSettings_get_ExpandedGlyphVisibility(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TreeViewItemTemplateSettings", L"ExpandedGlyphVisibility");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::TreeViewItemTemplateSettings>().ExpandedGlyphVisibility();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TreeViewItemTemplateSettings_get_Indentation(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TreeViewItemTemplateSettings", L"Indentation");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::TreeViewItemTemplateSettings>().Indentation();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TreeViewItemTemplateSettings_get_CollapsedGlyphVisibilityProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TreeViewItemTemplateSettings", L"CollapsedGlyphVisibilityProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::TreeViewItemTemplateSettings::CollapsedGlyphVisibilityProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TreeViewItemTemplateSettings_get_DragItemsCountProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TreeViewItemTemplateSettings", L"DragItemsCountProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::TreeViewItemTemplateSettings::DragItemsCountProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TreeViewItemTemplateSettings_get_ExpandedGlyphVisibilityProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TreeViewItemTemplateSettings", L"ExpandedGlyphVisibilityProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::TreeViewItemTemplateSettings::ExpandedGlyphVisibilityProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TreeViewItemTemplateSettings_get_IndentationProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TreeViewItemTemplateSettings", L"IndentationProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::TreeViewItemTemplateSettings::IndentationProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_TreeViewItemTemplateSettings(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::TreeViewItemTemplateSettings>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_TreeViewItemTemplateSettings(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::TreeViewItemTemplateSettings>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_TreeViewItemTemplateSettings[] = {
        { "_assign_array_", _assign_array_TreeViewItemTemplateSettings, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_TreeViewItemTemplateSettings), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_TreeViewItemTemplateSettings[] = {
        { "collapsed_glyph_visibility", reinterpret_cast<getter>(TreeViewItemTemplateSettings_get_CollapsedGlyphVisibility), nullptr, nullptr, nullptr },
        { "drag_items_count", reinterpret_cast<getter>(TreeViewItemTemplateSettings_get_DragItemsCount), nullptr, nullptr, nullptr },
        { "expanded_glyph_visibility", reinterpret_cast<getter>(TreeViewItemTemplateSettings_get_ExpandedGlyphVisibility), nullptr, nullptr, nullptr },
        { "indentation", reinterpret_cast<getter>(TreeViewItemTemplateSettings_get_Indentation), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_TreeViewItemTemplateSettings[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_TreeViewItemTemplateSettings) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_TreeViewItemTemplateSettings) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_TreeViewItemTemplateSettings) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_TreeViewItemTemplateSettings) },
        { }};

    static PyType_Spec type_spec_TreeViewItemTemplateSettings = {
        "winui2._winui2_microsoft_ui_xaml_controls.TreeViewItemTemplateSettings",
        sizeof(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_TreeViewItemTemplateSettings};

    static PyGetSetDef getset_TreeViewItemTemplateSettings_Static[] = {
        { "collapsed_glyph_visibility_property", reinterpret_cast<getter>(TreeViewItemTemplateSettings_get_CollapsedGlyphVisibilityProperty), nullptr, nullptr, nullptr },
        { "drag_items_count_property", reinterpret_cast<getter>(TreeViewItemTemplateSettings_get_DragItemsCountProperty), nullptr, nullptr, nullptr },
        { "expanded_glyph_visibility_property", reinterpret_cast<getter>(TreeViewItemTemplateSettings_get_ExpandedGlyphVisibilityProperty), nullptr, nullptr, nullptr },
        { "indentation_property", reinterpret_cast<getter>(TreeViewItemTemplateSettings_get_IndentationProperty), nullptr, nullptr, nullptr },
        { }};

    static PyMethodDef methods_TreeViewItemTemplateSettings_Static[] = {
        { }};

    static PyType_Slot type_slots_TreeViewItemTemplateSettings_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_TreeViewItemTemplateSettings_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_TreeViewItemTemplateSettings_Static) },
        { }
    };

    static PyType_Spec type_spec_TreeViewItemTemplateSettings_Static = {
        "winui2._winui2_microsoft_ui_xaml_controls.TreeViewItemTemplateSettings_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_TreeViewItemTemplateSettings_Static};

    // ----- TreeViewList class --------------------

    struct PyWinrtTreeViewList;
    using BasePyWinrtTreeViewList = winrt::Microsoft::UI::Xaml::Controls::TreeViewListT<PyWinrtTreeViewList, py::IPywinrtObject>;

    struct PyWinrtTreeViewList : py::py_obj_ref, BasePyWinrtTreeViewList
    {
        PyWinrtTreeViewList(PyObject* py_obj) : py::py_obj_ref(py_obj), BasePyWinrtTreeViewList() {}

        int32_t __stdcall GetPyObject(PyObject*& obj) override
        {
            obj = py::py_obj_ref::get_py_obj();
            return 0;
        }

        int32_t __stdcall GetComposableInner(winrt::Windows::Foundation::IInspectable& inner) override
        {
            inner = m_inner;
            return winrt::impl::error_ok;
        }

        static void toggle_reference(PyWinrtTreeViewList* instance, bool is_last_reference)
        {
            py::py_obj_ref::toggle_reference(instance, is_last_reference);
        }

        int32_t query_interface_tearoff(winrt::guid const& id, void** result) const noexcept override
        {
            return py::py_obj_ref::query_interface_tearoff(id, result);
        }

        std::vector<winrt::guid> get_iids_tearoff() const noexcept override
        {
            return py::py_obj_ref::get_iids_tearoff();
        }
    };

    static PyObject* _new_TreeViewList(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_GET_SIZE(args);

        auto self_type = get_python_type_for<winrt::Microsoft::UI::Xaml::Controls::TreeViewList>();
        if (!self_type)
        {
            return nullptr;
        }

        if (arg_count == 0)
        {
            try
            {
                if (type != self_type)
                {
                    py::pyobj_handle self{type->tp_alloc(type, 0)};
                    if (!self)
                    {
                        return nullptr;
                    }

                    std::construct_at(&reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj, nullptr);

                    auto obj_impl = winrt::make_self<PyWinrtTreeViewList>(self.get());

                    auto obj = py::make_py_obj<PyWinrtTreeViewList>(obj_impl, type, self.get());
                    if (!obj)
                    {
                        return nullptr;
                    }

                    reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj = std::move(obj);

                    return self.detach();
                }

                winrt::Microsoft::UI::Xaml::Controls::TreeViewList instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_TreeViewList(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_TreeViewList(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::TreeViewList>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_TreeViewList(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::TreeViewList>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_TreeViewList[] = {
        { "_assign_array_", _assign_array_TreeViewList, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_TreeViewList), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_TreeViewList[] = {
        { }};

    static PyType_Slot _type_slots_TreeViewList[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_TreeViewList) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_TreeViewList) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_TreeViewList) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_TreeViewList) },
        { }};

    static PyType_Spec type_spec_TreeViewList = {
        "winui2._winui2_microsoft_ui_xaml_controls.TreeViewList",
        sizeof(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_TreeViewList};

    static PyGetSetDef getset_TreeViewList_Static[] = {
        { }};

    static PyMethodDef methods_TreeViewList_Static[] = {
        { }};

    static PyType_Slot type_slots_TreeViewList_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_TreeViewList_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_TreeViewList_Static) },
        { }
    };

    static PyType_Spec type_spec_TreeViewList_Static = {
        "winui2._winui2_microsoft_ui_xaml_controls.TreeViewList_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_TreeViewList_Static};

    // ----- TreeViewNode class --------------------

    struct PyWinrtTreeViewNode;
    using BasePyWinrtTreeViewNode = winrt::Microsoft::UI::Xaml::Controls::TreeViewNodeT<PyWinrtTreeViewNode, py::IPywinrtObject>;

    struct PyWinrtTreeViewNode : py::py_obj_ref, BasePyWinrtTreeViewNode
    {
        PyWinrtTreeViewNode(PyObject* py_obj) : py::py_obj_ref(py_obj), BasePyWinrtTreeViewNode() {}

        int32_t __stdcall GetPyObject(PyObject*& obj) override
        {
            obj = py::py_obj_ref::get_py_obj();
            return 0;
        }

        int32_t __stdcall GetComposableInner(winrt::Windows::Foundation::IInspectable& inner) override
        {
            inner = m_inner;
            return winrt::impl::error_ok;
        }

        static void toggle_reference(PyWinrtTreeViewNode* instance, bool is_last_reference)
        {
            py::py_obj_ref::toggle_reference(instance, is_last_reference);
        }

        int32_t query_interface_tearoff(winrt::guid const& id, void** result) const noexcept override
        {
            return py::py_obj_ref::query_interface_tearoff(id, result);
        }

        std::vector<winrt::guid> get_iids_tearoff() const noexcept override
        {
            return py::py_obj_ref::get_iids_tearoff();
        }
    };

    static PyObject* _new_TreeViewNode(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_GET_SIZE(args);

        auto self_type = get_python_type_for<winrt::Microsoft::UI::Xaml::Controls::TreeViewNode>();
        if (!self_type)
        {
            return nullptr;
        }

        if (arg_count == 0)
        {
            try
            {
                if (type != self_type)
                {
                    py::pyobj_handle self{type->tp_alloc(type, 0)};
                    if (!self)
                    {
                        return nullptr;
                    }

                    std::construct_at(&reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj, nullptr);

                    auto obj_impl = winrt::make_self<PyWinrtTreeViewNode>(self.get());

                    auto obj = py::make_py_obj<PyWinrtTreeViewNode>(obj_impl, type, self.get());
                    if (!obj)
                    {
                        return nullptr;
                    }

                    reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj = std::move(obj);

                    return self.detach();
                }

                winrt::Microsoft::UI::Xaml::Controls::TreeViewNode instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_TreeViewNode(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* TreeViewNode_get_IsExpanded(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TreeViewNode", L"IsExpanded");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::TreeViewNode>().IsExpanded();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TreeViewNode_put_IsExpanded(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TreeViewNode", L"IsExpanded");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::TreeViewNode>().IsExpanded(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TreeViewNode_get_HasUnrealizedChildren(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TreeViewNode", L"HasUnrealizedChildren");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::TreeViewNode>().HasUnrealizedChildren();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TreeViewNode_put_HasUnrealizedChildren(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TreeViewNode", L"HasUnrealizedChildren");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::TreeViewNode>().HasUnrealizedChildren(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TreeViewNode_get_Content(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TreeViewNode", L"Content");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::TreeViewNode>().Content();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TreeViewNode_put_Content(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TreeViewNode", L"Content");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::TreeViewNode>().Content(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TreeViewNode_get_Children(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TreeViewNode", L"Children");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::TreeViewNode>().Children();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TreeViewNode_get_Depth(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TreeViewNode", L"Depth");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::TreeViewNode>().Depth();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TreeViewNode_get_HasChildren(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TreeViewNode", L"HasChildren");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::TreeViewNode>().HasChildren();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TreeViewNode_get_Parent(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TreeViewNode", L"Parent");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::TreeViewNode>().Parent();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TreeViewNode_get_ContentProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TreeViewNode", L"ContentProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::TreeViewNode::ContentProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TreeViewNode_get_DepthProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TreeViewNode", L"DepthProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::TreeViewNode::DepthProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TreeViewNode_get_HasChildrenProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TreeViewNode", L"HasChildrenProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::TreeViewNode::HasChildrenProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TreeViewNode_get_IsExpandedProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TreeViewNode", L"IsExpandedProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::TreeViewNode::IsExpandedProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_TreeViewNode(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::TreeViewNode>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_TreeViewNode(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::TreeViewNode>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_TreeViewNode[] = {
        { "_assign_array_", _assign_array_TreeViewNode, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_TreeViewNode), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_TreeViewNode[] = {
        { "is_expanded", reinterpret_cast<getter>(TreeViewNode_get_IsExpanded), reinterpret_cast<setter>(TreeViewNode_put_IsExpanded), nullptr, nullptr },
        { "has_unrealized_children", reinterpret_cast<getter>(TreeViewNode_get_HasUnrealizedChildren), reinterpret_cast<setter>(TreeViewNode_put_HasUnrealizedChildren), nullptr, nullptr },
        { "content", reinterpret_cast<getter>(TreeViewNode_get_Content), reinterpret_cast<setter>(TreeViewNode_put_Content), nullptr, nullptr },
        { "children", reinterpret_cast<getter>(TreeViewNode_get_Children), nullptr, nullptr, nullptr },
        { "depth", reinterpret_cast<getter>(TreeViewNode_get_Depth), nullptr, nullptr, nullptr },
        { "has_children", reinterpret_cast<getter>(TreeViewNode_get_HasChildren), nullptr, nullptr, nullptr },
        { "parent", reinterpret_cast<getter>(TreeViewNode_get_Parent), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_TreeViewNode[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_TreeViewNode) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_TreeViewNode) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_TreeViewNode) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_TreeViewNode) },
        { }};

    static PyType_Spec type_spec_TreeViewNode = {
        "winui2._winui2_microsoft_ui_xaml_controls.TreeViewNode",
        sizeof(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_TreeViewNode};

    static PyGetSetDef getset_TreeViewNode_Static[] = {
        { "content_property", reinterpret_cast<getter>(TreeViewNode_get_ContentProperty), nullptr, nullptr, nullptr },
        { "depth_property", reinterpret_cast<getter>(TreeViewNode_get_DepthProperty), nullptr, nullptr, nullptr },
        { "has_children_property", reinterpret_cast<getter>(TreeViewNode_get_HasChildrenProperty), nullptr, nullptr, nullptr },
        { "is_expanded_property", reinterpret_cast<getter>(TreeViewNode_get_IsExpandedProperty), nullptr, nullptr, nullptr },
        { }};

    static PyMethodDef methods_TreeViewNode_Static[] = {
        { }};

    static PyType_Slot type_slots_TreeViewNode_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_TreeViewNode_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_TreeViewNode_Static) },
        { }
    };

    static PyType_Spec type_spec_TreeViewNode_Static = {
        "winui2._winui2_microsoft_ui_xaml_controls.TreeViewNode_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_TreeViewNode_Static};

    // ----- TwoPaneView class --------------------

    struct PyWinrtTwoPaneView;
    using BasePyWinrtTwoPaneView = winrt::Microsoft::UI::Xaml::Controls::TwoPaneViewT<PyWinrtTwoPaneView, py::IPywinrtObject>;

    struct PyWinrtTwoPaneView : py::py_obj_ref, BasePyWinrtTwoPaneView
    {
        PyWinrtTwoPaneView(PyObject* py_obj) : py::py_obj_ref(py_obj), BasePyWinrtTwoPaneView() {}

        int32_t __stdcall GetPyObject(PyObject*& obj) override
        {
            obj = py::py_obj_ref::get_py_obj();
            return 0;
        }

        int32_t __stdcall GetComposableInner(winrt::Windows::Foundation::IInspectable& inner) override
        {
            inner = m_inner;
            return winrt::impl::error_ok;
        }

        static void toggle_reference(PyWinrtTwoPaneView* instance, bool is_last_reference)
        {
            py::py_obj_ref::toggle_reference(instance, is_last_reference);
        }

        int32_t query_interface_tearoff(winrt::guid const& id, void** result) const noexcept override
        {
            return py::py_obj_ref::query_interface_tearoff(id, result);
        }

        std::vector<winrt::guid> get_iids_tearoff() const noexcept override
        {
            return py::py_obj_ref::get_iids_tearoff();
        }
    };

    static PyObject* _new_TwoPaneView(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_GET_SIZE(args);

        auto self_type = get_python_type_for<winrt::Microsoft::UI::Xaml::Controls::TwoPaneView>();
        if (!self_type)
        {
            return nullptr;
        }

        if (arg_count == 0)
        {
            try
            {
                if (type != self_type)
                {
                    py::pyobj_handle self{type->tp_alloc(type, 0)};
                    if (!self)
                    {
                        return nullptr;
                    }

                    std::construct_at(&reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj, nullptr);

                    auto obj_impl = winrt::make_self<PyWinrtTwoPaneView>(self.get());

                    auto obj = py::make_py_obj<PyWinrtTwoPaneView>(obj_impl, type, self.get());
                    if (!obj)
                    {
                        return nullptr;
                    }

                    reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj = std::move(obj);

                    return self.detach();
                }

                winrt::Microsoft::UI::Xaml::Controls::TwoPaneView instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_TwoPaneView(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* TwoPaneView_get_WideModeConfiguration(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TwoPaneView", L"WideModeConfiguration");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::TwoPaneView>().WideModeConfiguration();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TwoPaneView_put_WideModeConfiguration(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TwoPaneView", L"WideModeConfiguration");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::TwoPaneViewWideModeConfiguration>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::TwoPaneView>().WideModeConfiguration(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TwoPaneView_get_TallModeConfiguration(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TwoPaneView", L"TallModeConfiguration");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::TwoPaneView>().TallModeConfiguration();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TwoPaneView_put_TallModeConfiguration(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TwoPaneView", L"TallModeConfiguration");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::TwoPaneViewTallModeConfiguration>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::TwoPaneView>().TallModeConfiguration(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TwoPaneView_get_PanePriority(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TwoPaneView", L"PanePriority");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::TwoPaneView>().PanePriority();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TwoPaneView_put_PanePriority(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TwoPaneView", L"PanePriority");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::TwoPaneViewPriority>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::TwoPaneView>().PanePriority(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TwoPaneView_get_Pane2Length(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TwoPaneView", L"Pane2Length");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::TwoPaneView>().Pane2Length();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TwoPaneView_put_Pane2Length(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TwoPaneView", L"Pane2Length");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::GridLength>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::TwoPaneView>().Pane2Length(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TwoPaneView_get_Pane2(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TwoPaneView", L"Pane2");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::TwoPaneView>().Pane2();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TwoPaneView_put_Pane2(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TwoPaneView", L"Pane2");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::UIElement>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::TwoPaneView>().Pane2(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TwoPaneView_get_Pane1Length(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TwoPaneView", L"Pane1Length");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::TwoPaneView>().Pane1Length();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TwoPaneView_put_Pane1Length(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TwoPaneView", L"Pane1Length");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::GridLength>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::TwoPaneView>().Pane1Length(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TwoPaneView_get_Pane1(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TwoPaneView", L"Pane1");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::TwoPaneView>().Pane1();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TwoPaneView_put_Pane1(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TwoPaneView", L"Pane1");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::UIElement>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::TwoPaneView>().Pane1(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TwoPaneView_get_MinWideModeWidth(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TwoPaneView", L"MinWideModeWidth");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::TwoPaneView>().MinWideModeWidth();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TwoPaneView_put_MinWideModeWidth(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TwoPaneView", L"MinWideModeWidth");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<double>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::TwoPaneView>().MinWideModeWidth(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TwoPaneView_get_MinTallModeHeight(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TwoPaneView", L"MinTallModeHeight");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::TwoPaneView>().MinTallModeHeight();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TwoPaneView_put_MinTallModeHeight(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TwoPaneView", L"MinTallModeHeight");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<double>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::TwoPaneView>().MinTallModeHeight(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TwoPaneView_get_Mode(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TwoPaneView", L"Mode");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::TwoPaneView>().Mode();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TwoPaneView_get_MinTallModeHeightProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TwoPaneView", L"MinTallModeHeightProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::TwoPaneView::MinTallModeHeightProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TwoPaneView_get_MinWideModeWidthProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TwoPaneView", L"MinWideModeWidthProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::TwoPaneView::MinWideModeWidthProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TwoPaneView_get_ModeProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TwoPaneView", L"ModeProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::TwoPaneView::ModeProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TwoPaneView_get_Pane1LengthProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TwoPaneView", L"Pane1LengthProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::TwoPaneView::Pane1LengthProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TwoPaneView_get_Pane1Property(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TwoPaneView", L"Pane1Property");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::TwoPaneView::Pane1Property();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TwoPaneView_get_Pane2LengthProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TwoPaneView", L"Pane2LengthProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::TwoPaneView::Pane2LengthProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TwoPaneView_get_Pane2Property(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TwoPaneView", L"Pane2Property");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::TwoPaneView::Pane2Property();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TwoPaneView_get_PanePriorityProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TwoPaneView", L"PanePriorityProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::TwoPaneView::PanePriorityProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TwoPaneView_get_TallModeConfigurationProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TwoPaneView", L"TallModeConfigurationProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::TwoPaneView::TallModeConfigurationProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TwoPaneView_get_WideModeConfigurationProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TwoPaneView", L"WideModeConfigurationProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::TwoPaneView::WideModeConfigurationProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TwoPaneView_add_ModeChanged(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.TwoPaneView", L"ModeChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Xaml::Controls::TwoPaneView, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::TwoPaneView>().ModeChanged(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TwoPaneView_remove_ModeChanged(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.TwoPaneView", L"ModeChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::TwoPaneView>().ModeChanged(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_TwoPaneView(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::TwoPaneView>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_TwoPaneView(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::TwoPaneView>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_TwoPaneView[] = {
        { "add_mode_changed", reinterpret_cast<PyCFunction>(TwoPaneView_add_ModeChanged), METH_O, nullptr },
        { "remove_mode_changed", reinterpret_cast<PyCFunction>(TwoPaneView_remove_ModeChanged), METH_O, nullptr },
        { "_assign_array_", _assign_array_TwoPaneView, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_TwoPaneView), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_TwoPaneView[] = {
        { "wide_mode_configuration", reinterpret_cast<getter>(TwoPaneView_get_WideModeConfiguration), reinterpret_cast<setter>(TwoPaneView_put_WideModeConfiguration), nullptr, nullptr },
        { "tall_mode_configuration", reinterpret_cast<getter>(TwoPaneView_get_TallModeConfiguration), reinterpret_cast<setter>(TwoPaneView_put_TallModeConfiguration), nullptr, nullptr },
        { "pane_priority", reinterpret_cast<getter>(TwoPaneView_get_PanePriority), reinterpret_cast<setter>(TwoPaneView_put_PanePriority), nullptr, nullptr },
        { "pane2_length", reinterpret_cast<getter>(TwoPaneView_get_Pane2Length), reinterpret_cast<setter>(TwoPaneView_put_Pane2Length), nullptr, nullptr },
        { "pane2", reinterpret_cast<getter>(TwoPaneView_get_Pane2), reinterpret_cast<setter>(TwoPaneView_put_Pane2), nullptr, nullptr },
        { "pane1_length", reinterpret_cast<getter>(TwoPaneView_get_Pane1Length), reinterpret_cast<setter>(TwoPaneView_put_Pane1Length), nullptr, nullptr },
        { "pane1", reinterpret_cast<getter>(TwoPaneView_get_Pane1), reinterpret_cast<setter>(TwoPaneView_put_Pane1), nullptr, nullptr },
        { "min_wide_mode_width", reinterpret_cast<getter>(TwoPaneView_get_MinWideModeWidth), reinterpret_cast<setter>(TwoPaneView_put_MinWideModeWidth), nullptr, nullptr },
        { "min_tall_mode_height", reinterpret_cast<getter>(TwoPaneView_get_MinTallModeHeight), reinterpret_cast<setter>(TwoPaneView_put_MinTallModeHeight), nullptr, nullptr },
        { "mode", reinterpret_cast<getter>(TwoPaneView_get_Mode), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_TwoPaneView[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_TwoPaneView) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_TwoPaneView) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_TwoPaneView) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_TwoPaneView) },
        { }};

    static PyType_Spec type_spec_TwoPaneView = {
        "winui2._winui2_microsoft_ui_xaml_controls.TwoPaneView",
        sizeof(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_TwoPaneView};

    static PyGetSetDef getset_TwoPaneView_Static[] = {
        { "min_tall_mode_height_property", reinterpret_cast<getter>(TwoPaneView_get_MinTallModeHeightProperty), nullptr, nullptr, nullptr },
        { "min_wide_mode_width_property", reinterpret_cast<getter>(TwoPaneView_get_MinWideModeWidthProperty), nullptr, nullptr, nullptr },
        { "mode_property", reinterpret_cast<getter>(TwoPaneView_get_ModeProperty), nullptr, nullptr, nullptr },
        { "pane1_length_property", reinterpret_cast<getter>(TwoPaneView_get_Pane1LengthProperty), nullptr, nullptr, nullptr },
        { "pane1_property", reinterpret_cast<getter>(TwoPaneView_get_Pane1Property), nullptr, nullptr, nullptr },
        { "pane2_length_property", reinterpret_cast<getter>(TwoPaneView_get_Pane2LengthProperty), nullptr, nullptr, nullptr },
        { "pane2_property", reinterpret_cast<getter>(TwoPaneView_get_Pane2Property), nullptr, nullptr, nullptr },
        { "pane_priority_property", reinterpret_cast<getter>(TwoPaneView_get_PanePriorityProperty), nullptr, nullptr, nullptr },
        { "tall_mode_configuration_property", reinterpret_cast<getter>(TwoPaneView_get_TallModeConfigurationProperty), nullptr, nullptr, nullptr },
        { "wide_mode_configuration_property", reinterpret_cast<getter>(TwoPaneView_get_WideModeConfigurationProperty), nullptr, nullptr, nullptr },
        { }};

    static PyMethodDef methods_TwoPaneView_Static[] = {
        { }};

    static PyType_Slot type_slots_TwoPaneView_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_TwoPaneView_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_TwoPaneView_Static) },
        { }
    };

    static PyType_Spec type_spec_TwoPaneView_Static = {
        "winui2._winui2_microsoft_ui_xaml_controls.TwoPaneView_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_TwoPaneView_Static};

    // ----- UniformGridLayout class --------------------

    struct PyWinrtUniformGridLayout;
    using BasePyWinrtUniformGridLayout = winrt::Microsoft::UI::Xaml::Controls::UniformGridLayoutT<PyWinrtUniformGridLayout, py::IPywinrtObject>;

    struct PyWinrtUniformGridLayout : py::py_obj_ref, BasePyWinrtUniformGridLayout
    {
        PyWinrtUniformGridLayout(PyObject* py_obj) : py::py_obj_ref(py_obj), BasePyWinrtUniformGridLayout() {}

        int32_t __stdcall GetPyObject(PyObject*& obj) override
        {
            obj = py::py_obj_ref::get_py_obj();
            return 0;
        }

        int32_t __stdcall GetComposableInner(winrt::Windows::Foundation::IInspectable& inner) override
        {
            inner = m_inner;
            return winrt::impl::error_ok;
        }

        static void toggle_reference(PyWinrtUniformGridLayout* instance, bool is_last_reference)
        {
            py::py_obj_ref::toggle_reference(instance, is_last_reference);
        }

        int32_t query_interface_tearoff(winrt::guid const& id, void** result) const noexcept override
        {
            return py::py_obj_ref::query_interface_tearoff(id, result);
        }

        std::vector<winrt::guid> get_iids_tearoff() const noexcept override
        {
            return py::py_obj_ref::get_iids_tearoff();
        }
    };

    static PyObject* _new_UniformGridLayout(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_GET_SIZE(args);

        auto self_type = get_python_type_for<winrt::Microsoft::UI::Xaml::Controls::UniformGridLayout>();
        if (!self_type)
        {
            return nullptr;
        }

        if (arg_count == 0)
        {
            try
            {
                if (type != self_type)
                {
                    py::pyobj_handle self{type->tp_alloc(type, 0)};
                    if (!self)
                    {
                        return nullptr;
                    }

                    std::construct_at(&reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj, nullptr);

                    auto obj_impl = winrt::make_self<PyWinrtUniformGridLayout>(self.get());

                    auto obj = py::make_py_obj<PyWinrtUniformGridLayout>(obj_impl, type, self.get());
                    if (!obj)
                    {
                        return nullptr;
                    }

                    reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj = std::move(obj);

                    return self.detach();
                }

                winrt::Microsoft::UI::Xaml::Controls::UniformGridLayout instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_UniformGridLayout(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* UniformGridLayout_get_Orientation(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.UniformGridLayout", L"Orientation");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::UniformGridLayout>().Orientation();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int UniformGridLayout_put_Orientation(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.UniformGridLayout", L"Orientation");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::Orientation>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::UniformGridLayout>().Orientation(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* UniformGridLayout_get_MinRowSpacing(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.UniformGridLayout", L"MinRowSpacing");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::UniformGridLayout>().MinRowSpacing();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int UniformGridLayout_put_MinRowSpacing(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.UniformGridLayout", L"MinRowSpacing");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<double>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::UniformGridLayout>().MinRowSpacing(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* UniformGridLayout_get_MinItemWidth(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.UniformGridLayout", L"MinItemWidth");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::UniformGridLayout>().MinItemWidth();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int UniformGridLayout_put_MinItemWidth(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.UniformGridLayout", L"MinItemWidth");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<double>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::UniformGridLayout>().MinItemWidth(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* UniformGridLayout_get_MinItemHeight(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.UniformGridLayout", L"MinItemHeight");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::UniformGridLayout>().MinItemHeight();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int UniformGridLayout_put_MinItemHeight(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.UniformGridLayout", L"MinItemHeight");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<double>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::UniformGridLayout>().MinItemHeight(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* UniformGridLayout_get_MinColumnSpacing(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.UniformGridLayout", L"MinColumnSpacing");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::UniformGridLayout>().MinColumnSpacing();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int UniformGridLayout_put_MinColumnSpacing(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.UniformGridLayout", L"MinColumnSpacing");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<double>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::UniformGridLayout>().MinColumnSpacing(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* UniformGridLayout_get_MaximumRowsOrColumns(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.UniformGridLayout", L"MaximumRowsOrColumns");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::UniformGridLayout>().MaximumRowsOrColumns();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int UniformGridLayout_put_MaximumRowsOrColumns(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.UniformGridLayout", L"MaximumRowsOrColumns");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<int32_t>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::UniformGridLayout>().MaximumRowsOrColumns(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* UniformGridLayout_get_ItemsStretch(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.UniformGridLayout", L"ItemsStretch");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::UniformGridLayout>().ItemsStretch();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int UniformGridLayout_put_ItemsStretch(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.UniformGridLayout", L"ItemsStretch");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::UniformGridLayoutItemsStretch>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::UniformGridLayout>().ItemsStretch(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* UniformGridLayout_get_ItemsJustification(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.UniformGridLayout", L"ItemsJustification");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::UniformGridLayout>().ItemsJustification();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int UniformGridLayout_put_ItemsJustification(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.UniformGridLayout", L"ItemsJustification");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::UniformGridLayoutItemsJustification>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::UniformGridLayout>().ItemsJustification(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* UniformGridLayout_get_ItemsJustificationProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.UniformGridLayout", L"ItemsJustificationProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::UniformGridLayout::ItemsJustificationProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UniformGridLayout_get_ItemsStretchProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.UniformGridLayout", L"ItemsStretchProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::UniformGridLayout::ItemsStretchProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UniformGridLayout_get_MaximumRowsOrColumnsProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.UniformGridLayout", L"MaximumRowsOrColumnsProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::UniformGridLayout::MaximumRowsOrColumnsProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UniformGridLayout_get_MinColumnSpacingProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.UniformGridLayout", L"MinColumnSpacingProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::UniformGridLayout::MinColumnSpacingProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UniformGridLayout_get_MinItemHeightProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.UniformGridLayout", L"MinItemHeightProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::UniformGridLayout::MinItemHeightProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UniformGridLayout_get_MinItemWidthProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.UniformGridLayout", L"MinItemWidthProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::UniformGridLayout::MinItemWidthProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UniformGridLayout_get_MinRowSpacingProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.UniformGridLayout", L"MinRowSpacingProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::UniformGridLayout::MinRowSpacingProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UniformGridLayout_get_OrientationProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.UniformGridLayout", L"OrientationProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::UniformGridLayout::OrientationProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_UniformGridLayout(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::UniformGridLayout>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_UniformGridLayout(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::UniformGridLayout>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_UniformGridLayout[] = {
        { "_assign_array_", _assign_array_UniformGridLayout, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_UniformGridLayout), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_UniformGridLayout[] = {
        { "orientation", reinterpret_cast<getter>(UniformGridLayout_get_Orientation), reinterpret_cast<setter>(UniformGridLayout_put_Orientation), nullptr, nullptr },
        { "min_row_spacing", reinterpret_cast<getter>(UniformGridLayout_get_MinRowSpacing), reinterpret_cast<setter>(UniformGridLayout_put_MinRowSpacing), nullptr, nullptr },
        { "min_item_width", reinterpret_cast<getter>(UniformGridLayout_get_MinItemWidth), reinterpret_cast<setter>(UniformGridLayout_put_MinItemWidth), nullptr, nullptr },
        { "min_item_height", reinterpret_cast<getter>(UniformGridLayout_get_MinItemHeight), reinterpret_cast<setter>(UniformGridLayout_put_MinItemHeight), nullptr, nullptr },
        { "min_column_spacing", reinterpret_cast<getter>(UniformGridLayout_get_MinColumnSpacing), reinterpret_cast<setter>(UniformGridLayout_put_MinColumnSpacing), nullptr, nullptr },
        { "maximum_rows_or_columns", reinterpret_cast<getter>(UniformGridLayout_get_MaximumRowsOrColumns), reinterpret_cast<setter>(UniformGridLayout_put_MaximumRowsOrColumns), nullptr, nullptr },
        { "items_stretch", reinterpret_cast<getter>(UniformGridLayout_get_ItemsStretch), reinterpret_cast<setter>(UniformGridLayout_put_ItemsStretch), nullptr, nullptr },
        { "items_justification", reinterpret_cast<getter>(UniformGridLayout_get_ItemsJustification), reinterpret_cast<setter>(UniformGridLayout_put_ItemsJustification), nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_UniformGridLayout[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_UniformGridLayout) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_UniformGridLayout) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_UniformGridLayout) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_UniformGridLayout) },
        { }};

    static PyType_Spec type_spec_UniformGridLayout = {
        "winui2._winui2_microsoft_ui_xaml_controls.UniformGridLayout",
        sizeof(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_UniformGridLayout};

    static PyGetSetDef getset_UniformGridLayout_Static[] = {
        { "items_justification_property", reinterpret_cast<getter>(UniformGridLayout_get_ItemsJustificationProperty), nullptr, nullptr, nullptr },
        { "items_stretch_property", reinterpret_cast<getter>(UniformGridLayout_get_ItemsStretchProperty), nullptr, nullptr, nullptr },
        { "maximum_rows_or_columns_property", reinterpret_cast<getter>(UniformGridLayout_get_MaximumRowsOrColumnsProperty), nullptr, nullptr, nullptr },
        { "min_column_spacing_property", reinterpret_cast<getter>(UniformGridLayout_get_MinColumnSpacingProperty), nullptr, nullptr, nullptr },
        { "min_item_height_property", reinterpret_cast<getter>(UniformGridLayout_get_MinItemHeightProperty), nullptr, nullptr, nullptr },
        { "min_item_width_property", reinterpret_cast<getter>(UniformGridLayout_get_MinItemWidthProperty), nullptr, nullptr, nullptr },
        { "min_row_spacing_property", reinterpret_cast<getter>(UniformGridLayout_get_MinRowSpacingProperty), nullptr, nullptr, nullptr },
        { "orientation_property", reinterpret_cast<getter>(UniformGridLayout_get_OrientationProperty), nullptr, nullptr, nullptr },
        { }};

    static PyMethodDef methods_UniformGridLayout_Static[] = {
        { }};

    static PyType_Slot type_slots_UniformGridLayout_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_UniformGridLayout_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_UniformGridLayout_Static) },
        { }
    };

    static PyType_Spec type_spec_UniformGridLayout_Static = {
        "winui2._winui2_microsoft_ui_xaml_controls.UniformGridLayout_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_UniformGridLayout_Static};

    // ----- VirtualizingLayout class --------------------

    struct PyWinrtVirtualizingLayout;
    using BasePyWinrtVirtualizingLayout = winrt::Microsoft::UI::Xaml::Controls::VirtualizingLayoutT<PyWinrtVirtualizingLayout, py::IPywinrtObject>;

    struct PyWinrtVirtualizingLayout : py::py_obj_ref, BasePyWinrtVirtualizingLayout
    {
        PyWinrtVirtualizingLayout(PyObject* py_obj) : py::py_obj_ref(py_obj), BasePyWinrtVirtualizingLayout() {}

        int32_t __stdcall GetPyObject(PyObject*& obj) override
        {
            obj = py::py_obj_ref::get_py_obj();
            return 0;
        }

        int32_t __stdcall GetComposableInner(winrt::Windows::Foundation::IInspectable& inner) override
        {
            inner = m_inner;
            return winrt::impl::error_ok;
        }

        static void toggle_reference(PyWinrtVirtualizingLayout* instance, bool is_last_reference)
        {
            py::py_obj_ref::toggle_reference(instance, is_last_reference);
        }

        int32_t query_interface_tearoff(winrt::guid const& id, void** result) const noexcept override
        {
            return py::py_obj_ref::query_interface_tearoff(id, result);
        }

        std::vector<winrt::guid> get_iids_tearoff() const noexcept override
        {
            return py::py_obj_ref::get_iids_tearoff();
        }

        winrt::Windows::Foundation::Size ArrangeOverride(winrt::Microsoft::UI::Xaml::Controls::VirtualizingLayoutContext const& param0, winrt::Windows::Foundation::Size param1)
        {
            auto gil = py::ensure_gil();

            try
            {
                py::pyobj_handle self{get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "_arrange_override")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param1{py::convert(param1)};
                if (!py_param1)
                {
                    throw python_exception();
                }

                py::pyobj_handle args{PyTuple_Pack(2, py_param0.get(), py_param1.get())};
                if (!args)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallObject(method.get(), args.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::Foundation::Size>(return_value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        void InitializeForContextCore(winrt::Microsoft::UI::Xaml::Controls::VirtualizingLayoutContext const& param0)
        {
            auto gil = py::ensure_gil();

            try
            {
                py::pyobj_handle self{get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "_initialize_for_context_core")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallOneArg(method.get(), py_param0.get())};
                if (!return_value)
                {
                    throw python_exception();
                }
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        winrt::Windows::Foundation::Size MeasureOverride(winrt::Microsoft::UI::Xaml::Controls::VirtualizingLayoutContext const& param0, winrt::Windows::Foundation::Size param1)
        {
            auto gil = py::ensure_gil();

            try
            {
                py::pyobj_handle self{get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "_measure_override")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param1{py::convert(param1)};
                if (!py_param1)
                {
                    throw python_exception();
                }

                py::pyobj_handle args{PyTuple_Pack(2, py_param0.get(), py_param1.get())};
                if (!args)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallObject(method.get(), args.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::Foundation::Size>(return_value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        void OnItemsChangedCore(winrt::Microsoft::UI::Xaml::Controls::VirtualizingLayoutContext const& param0, winrt::Windows::Foundation::IInspectable const& param1, winrt::Windows::UI::Xaml::Interop::NotifyCollectionChangedEventArgs const& param2)
        {
            auto gil = py::ensure_gil();

            try
            {
                py::pyobj_handle self{get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "_on_items_changed_core")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param1{py::convert(param1)};
                if (!py_param1)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param2{py::convert(param2)};
                if (!py_param2)
                {
                    throw python_exception();
                }

                py::pyobj_handle args{PyTuple_Pack(3, py_param0.get(), py_param1.get(), py_param2.get())};
                if (!args)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallObject(method.get(), args.get())};
                if (!return_value)
                {
                    throw python_exception();
                }
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        void UninitializeForContextCore(winrt::Microsoft::UI::Xaml::Controls::VirtualizingLayoutContext const& param0)
        {
            auto gil = py::ensure_gil();

            try
            {
                py::pyobj_handle self{get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "_uninitialize_for_context_core")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallOneArg(method.get(), py_param0.get())};
                if (!return_value)
                {
                    throw python_exception();
                }
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }
    };

    static PyObject* _new_VirtualizingLayout(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_GET_SIZE(args);

        auto self_type = get_python_type_for<winrt::Microsoft::UI::Xaml::Controls::VirtualizingLayout>();
        if (!self_type)
        {
            return nullptr;
        }

        if (arg_count == 0)
        {
            try
            {
                if (type != self_type)
                {
                    py::pyobj_handle self{type->tp_alloc(type, 0)};
                    if (!self)
                    {
                        return nullptr;
                    }

                    std::construct_at(&reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj, nullptr);

                    auto obj_impl = winrt::make_self<PyWinrtVirtualizingLayout>(self.get());

                    auto obj = py::make_py_obj<PyWinrtVirtualizingLayout>(obj_impl, type, self.get());
                    if (!obj)
                    {
                        return nullptr;
                    }

                    reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj = std::move(obj);

                    return self.detach();
                }

                winrt::Microsoft::UI::Xaml::Controls::VirtualizingLayout instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_VirtualizingLayout(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* VirtualizingLayout_ArrangeOverride(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.VirtualizingLayout", L"ArrangeOverride", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::VirtualizingLayoutContext>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Size>(args, 1);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return py::get_inner_or_self(self->obj).try_as<winrt::Microsoft::UI::Xaml::Controls::IVirtualizingLayoutOverrides>().ArrangeOverride(param0, param1);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VirtualizingLayout_InitializeForContextCore(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.VirtualizingLayout", L"InitializeForContextCore", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::VirtualizingLayoutContext>(args, 0);

                {
                    auto _gil = release_gil();
                    py::get_inner_or_self(self->obj).try_as<winrt::Microsoft::UI::Xaml::Controls::IVirtualizingLayoutOverrides>().InitializeForContextCore(param0);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VirtualizingLayout_MeasureOverride(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.VirtualizingLayout", L"MeasureOverride", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::VirtualizingLayoutContext>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Size>(args, 1);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return py::get_inner_or_self(self->obj).try_as<winrt::Microsoft::UI::Xaml::Controls::IVirtualizingLayoutOverrides>().MeasureOverride(param0, param1);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VirtualizingLayout_OnItemsChangedCore(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 3)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.VirtualizingLayout", L"OnItemsChangedCore", 3);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::VirtualizingLayoutContext>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::UI::Xaml::Interop::NotifyCollectionChangedEventArgs>(args, 2);

                {
                    auto _gil = release_gil();
                    py::get_inner_or_self(self->obj).try_as<winrt::Microsoft::UI::Xaml::Controls::IVirtualizingLayoutOverrides>().OnItemsChangedCore(param0, param1, param2);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VirtualizingLayout_UninitializeForContextCore(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.VirtualizingLayout", L"UninitializeForContextCore", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::VirtualizingLayoutContext>(args, 0);

                {
                    auto _gil = release_gil();
                    py::get_inner_or_self(self->obj).try_as<winrt::Microsoft::UI::Xaml::Controls::IVirtualizingLayoutOverrides>().UninitializeForContextCore(param0);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_VirtualizingLayout(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::VirtualizingLayout>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_VirtualizingLayout(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::VirtualizingLayout>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_VirtualizingLayout[] = {
        { "_arrange_override", reinterpret_cast<PyCFunction>(VirtualizingLayout_ArrangeOverride), METH_VARARGS, nullptr },
        { "_initialize_for_context_core", reinterpret_cast<PyCFunction>(VirtualizingLayout_InitializeForContextCore), METH_VARARGS, nullptr },
        { "_measure_override", reinterpret_cast<PyCFunction>(VirtualizingLayout_MeasureOverride), METH_VARARGS, nullptr },
        { "_on_items_changed_core", reinterpret_cast<PyCFunction>(VirtualizingLayout_OnItemsChangedCore), METH_VARARGS, nullptr },
        { "_uninitialize_for_context_core", reinterpret_cast<PyCFunction>(VirtualizingLayout_UninitializeForContextCore), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_VirtualizingLayout, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_VirtualizingLayout), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_VirtualizingLayout[] = {
        { }};

    static PyType_Slot _type_slots_VirtualizingLayout[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_VirtualizingLayout) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_VirtualizingLayout) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_VirtualizingLayout) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_VirtualizingLayout) },
        { }};

    static PyType_Spec type_spec_VirtualizingLayout = {
        "winui2._winui2_microsoft_ui_xaml_controls.VirtualizingLayout",
        sizeof(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_VirtualizingLayout};

    static PyGetSetDef getset_VirtualizingLayout_Static[] = {
        { }};

    static PyMethodDef methods_VirtualizingLayout_Static[] = {
        { }};

    static PyType_Slot type_slots_VirtualizingLayout_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_VirtualizingLayout_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_VirtualizingLayout_Static) },
        { }
    };

    static PyType_Spec type_spec_VirtualizingLayout_Static = {
        "winui2._winui2_microsoft_ui_xaml_controls.VirtualizingLayout_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_VirtualizingLayout_Static};

    // ----- VirtualizingLayoutContext class --------------------

    struct PyWinrtVirtualizingLayoutContext;
    using BasePyWinrtVirtualizingLayoutContext = winrt::Microsoft::UI::Xaml::Controls::VirtualizingLayoutContextT<PyWinrtVirtualizingLayoutContext, py::IPywinrtObject>;

    struct PyWinrtVirtualizingLayoutContext : py::py_obj_ref, BasePyWinrtVirtualizingLayoutContext
    {
        PyWinrtVirtualizingLayoutContext(PyObject* py_obj) : py::py_obj_ref(py_obj), BasePyWinrtVirtualizingLayoutContext() {}

        int32_t __stdcall GetPyObject(PyObject*& obj) override
        {
            obj = py::py_obj_ref::get_py_obj();
            return 0;
        }

        int32_t __stdcall GetComposableInner(winrt::Windows::Foundation::IInspectable& inner) override
        {
            inner = m_inner;
            return winrt::impl::error_ok;
        }

        static void toggle_reference(PyWinrtVirtualizingLayoutContext* instance, bool is_last_reference)
        {
            py::py_obj_ref::toggle_reference(instance, is_last_reference);
        }

        int32_t query_interface_tearoff(winrt::guid const& id, void** result) const noexcept override
        {
            return py::py_obj_ref::query_interface_tearoff(id, result);
        }

        std::vector<winrt::guid> get_iids_tearoff() const noexcept override
        {
            return py::py_obj_ref::get_iids_tearoff();
        }

        winrt::Windows::Foundation::IInspectable GetItemAtCore(int32_t param0)
        {
            auto gil = py::ensure_gil();

            try
            {
                py::pyobj_handle self{get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "_get_item_at_core")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallOneArg(method.get(), py_param0.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::Foundation::IInspectable>(return_value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        winrt::Windows::UI::Xaml::UIElement GetOrCreateElementAtCore(int32_t param0, winrt::Microsoft::UI::Xaml::Controls::ElementRealizationOptions param1)
        {
            auto gil = py::ensure_gil();

            try
            {
                py::pyobj_handle self{get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "_get_or_create_element_at_core")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param1{py::convert(param1)};
                if (!py_param1)
                {
                    throw python_exception();
                }

                py::pyobj_handle args{PyTuple_Pack(2, py_param0.get(), py_param1.get())};
                if (!args)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallObject(method.get(), args.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::UI::Xaml::UIElement>(return_value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        int32_t ItemCountCore()
        {
            auto gil = py::ensure_gil();

            try
            {
                py::pyobj_handle self{get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "_item_count_core")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallNoArgs(method.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                return py::convert_to<int32_t>(return_value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        winrt::Windows::Foundation::Rect RealizationRectCore()
        {
            auto gil = py::ensure_gil();

            try
            {
                py::pyobj_handle self{get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "_realization_rect_core")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallNoArgs(method.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::Foundation::Rect>(return_value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        void RecycleElementCore(winrt::Windows::UI::Xaml::UIElement const& param0)
        {
            auto gil = py::ensure_gil();

            try
            {
                py::pyobj_handle self{get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "_recycle_element_core")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallOneArg(method.get(), py_param0.get())};
                if (!return_value)
                {
                    throw python_exception();
                }
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }
    };

    static PyObject* _new_VirtualizingLayoutContext(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_GET_SIZE(args);

        auto self_type = get_python_type_for<winrt::Microsoft::UI::Xaml::Controls::VirtualizingLayoutContext>();
        if (!self_type)
        {
            return nullptr;
        }

        if (arg_count == 0)
        {
            try
            {
                if (type != self_type)
                {
                    py::pyobj_handle self{type->tp_alloc(type, 0)};
                    if (!self)
                    {
                        return nullptr;
                    }

                    std::construct_at(&reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj, nullptr);

                    auto obj_impl = winrt::make_self<PyWinrtVirtualizingLayoutContext>(self.get());

                    auto obj = py::make_py_obj<PyWinrtVirtualizingLayoutContext>(obj_impl, type, self.get());
                    if (!obj)
                    {
                        return nullptr;
                    }

                    reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj = std::move(obj);

                    return self.detach();
                }

                winrt::Microsoft::UI::Xaml::Controls::VirtualizingLayoutContext instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_VirtualizingLayoutContext(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* VirtualizingLayoutContext_GetItemAt(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.VirtualizingLayoutContext", L"GetItemAt", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<int32_t>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::VirtualizingLayoutContext>().GetItemAt(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VirtualizingLayoutContext_GetItemAtCore(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.VirtualizingLayoutContext", L"GetItemAtCore", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<int32_t>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return py::get_inner_or_self(self->obj).try_as<winrt::Microsoft::UI::Xaml::Controls::IVirtualizingLayoutContextOverrides>().GetItemAtCore(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VirtualizingLayoutContext_GetOrCreateElementAt(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.VirtualizingLayoutContext", L"GetOrCreateElementAt", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<int32_t>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::VirtualizingLayoutContext>().GetOrCreateElementAt(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VirtualizingLayoutContext_GetOrCreateElementAt2(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.VirtualizingLayoutContext", L"GetOrCreateElementAt", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<int32_t>(args, 0);
                auto param1 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::ElementRealizationOptions>(args, 1);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::VirtualizingLayoutContext>().GetOrCreateElementAt(param0, param1);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VirtualizingLayoutContext_GetOrCreateElementAtCore(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.VirtualizingLayoutContext", L"GetOrCreateElementAtCore", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<int32_t>(args, 0);
                auto param1 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::ElementRealizationOptions>(args, 1);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return py::get_inner_or_self(self->obj).try_as<winrt::Microsoft::UI::Xaml::Controls::IVirtualizingLayoutContextOverrides>().GetOrCreateElementAtCore(param0, param1);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VirtualizingLayoutContext_ItemCountCore(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.VirtualizingLayoutContext", L"ItemCountCore", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return py::get_inner_or_self(self->obj).try_as<winrt::Microsoft::UI::Xaml::Controls::IVirtualizingLayoutContextOverrides>().ItemCountCore();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VirtualizingLayoutContext_RealizationRectCore(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.VirtualizingLayoutContext", L"RealizationRectCore", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return py::get_inner_or_self(self->obj).try_as<winrt::Microsoft::UI::Xaml::Controls::IVirtualizingLayoutContextOverrides>().RealizationRectCore();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VirtualizingLayoutContext_RecycleElement(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.VirtualizingLayoutContext", L"RecycleElement", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::UIElement>(args, 0);

                {
                    auto _gil = release_gil();
                    self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::VirtualizingLayoutContext>().RecycleElement(param0);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VirtualizingLayoutContext_RecycleElementCore(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.VirtualizingLayoutContext", L"RecycleElementCore", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::UIElement>(args, 0);

                {
                    auto _gil = release_gil();
                    py::get_inner_or_self(self->obj).try_as<winrt::Microsoft::UI::Xaml::Controls::IVirtualizingLayoutContextOverrides>().RecycleElementCore(param0);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VirtualizingLayoutContext_get_LayoutOrigin(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.VirtualizingLayoutContext", L"LayoutOrigin");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::VirtualizingLayoutContext>().LayoutOrigin();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VirtualizingLayoutContext_put_LayoutOrigin(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.VirtualizingLayoutContext", L"LayoutOrigin");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::Point>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::VirtualizingLayoutContext>().LayoutOrigin(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VirtualizingLayoutContext_get_ItemCount(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.VirtualizingLayoutContext", L"ItemCount");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::VirtualizingLayoutContext>().ItemCount();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VirtualizingLayoutContext_get_RealizationRect(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.VirtualizingLayoutContext", L"RealizationRect");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::VirtualizingLayoutContext>().RealizationRect();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VirtualizingLayoutContext_get_RecommendedAnchorIndex(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.VirtualizingLayoutContext", L"RecommendedAnchorIndex");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::VirtualizingLayoutContext>().RecommendedAnchorIndex();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_VirtualizingLayoutContext(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::VirtualizingLayoutContext>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_VirtualizingLayoutContext(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::VirtualizingLayoutContext>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_VirtualizingLayoutContext[] = {
        { "get_item_at", reinterpret_cast<PyCFunction>(VirtualizingLayoutContext_GetItemAt), METH_VARARGS, nullptr },
        { "_get_item_at_core", reinterpret_cast<PyCFunction>(VirtualizingLayoutContext_GetItemAtCore), METH_VARARGS, nullptr },
        { "get_or_create_element_at", reinterpret_cast<PyCFunction>(VirtualizingLayoutContext_GetOrCreateElementAt), METH_VARARGS, nullptr },
        { "get_or_create_element_at2", reinterpret_cast<PyCFunction>(VirtualizingLayoutContext_GetOrCreateElementAt2), METH_VARARGS, nullptr },
        { "_get_or_create_element_at_core", reinterpret_cast<PyCFunction>(VirtualizingLayoutContext_GetOrCreateElementAtCore), METH_VARARGS, nullptr },
        { "_item_count_core", reinterpret_cast<PyCFunction>(VirtualizingLayoutContext_ItemCountCore), METH_VARARGS, nullptr },
        { "_realization_rect_core", reinterpret_cast<PyCFunction>(VirtualizingLayoutContext_RealizationRectCore), METH_VARARGS, nullptr },
        { "recycle_element", reinterpret_cast<PyCFunction>(VirtualizingLayoutContext_RecycleElement), METH_VARARGS, nullptr },
        { "_recycle_element_core", reinterpret_cast<PyCFunction>(VirtualizingLayoutContext_RecycleElementCore), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_VirtualizingLayoutContext, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_VirtualizingLayoutContext), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_VirtualizingLayoutContext[] = {
        { "layout_origin", reinterpret_cast<getter>(VirtualizingLayoutContext_get_LayoutOrigin), reinterpret_cast<setter>(VirtualizingLayoutContext_put_LayoutOrigin), nullptr, nullptr },
        { "item_count", reinterpret_cast<getter>(VirtualizingLayoutContext_get_ItemCount), nullptr, nullptr, nullptr },
        { "realization_rect", reinterpret_cast<getter>(VirtualizingLayoutContext_get_RealizationRect), nullptr, nullptr, nullptr },
        { "recommended_anchor_index", reinterpret_cast<getter>(VirtualizingLayoutContext_get_RecommendedAnchorIndex), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_VirtualizingLayoutContext[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_VirtualizingLayoutContext) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_VirtualizingLayoutContext) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_VirtualizingLayoutContext) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_VirtualizingLayoutContext) },
        { }};

    static PyType_Spec type_spec_VirtualizingLayoutContext = {
        "winui2._winui2_microsoft_ui_xaml_controls.VirtualizingLayoutContext",
        sizeof(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_VirtualizingLayoutContext};

    static PyGetSetDef getset_VirtualizingLayoutContext_Static[] = {
        { }};

    static PyMethodDef methods_VirtualizingLayoutContext_Static[] = {
        { }};

    static PyType_Slot type_slots_VirtualizingLayoutContext_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_VirtualizingLayoutContext_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_VirtualizingLayoutContext_Static) },
        { }
    };

    static PyType_Spec type_spec_VirtualizingLayoutContext_Static = {
        "winui2._winui2_microsoft_ui_xaml_controls.VirtualizingLayoutContext_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_VirtualizingLayoutContext_Static};

    // ----- WebView2 class --------------------

    struct PyWinrtWebView2;
    using BasePyWinrtWebView2 = winrt::Microsoft::UI::Xaml::Controls::WebView2T<PyWinrtWebView2, py::IPywinrtObject>;

    struct PyWinrtWebView2 : py::py_obj_ref, BasePyWinrtWebView2
    {
        PyWinrtWebView2(PyObject* py_obj) : py::py_obj_ref(py_obj), BasePyWinrtWebView2() {}

        int32_t __stdcall GetPyObject(PyObject*& obj) override
        {
            obj = py::py_obj_ref::get_py_obj();
            return 0;
        }

        int32_t __stdcall GetComposableInner(winrt::Windows::Foundation::IInspectable& inner) override
        {
            inner = m_inner;
            return winrt::impl::error_ok;
        }

        static void toggle_reference(PyWinrtWebView2* instance, bool is_last_reference)
        {
            py::py_obj_ref::toggle_reference(instance, is_last_reference);
        }

        int32_t query_interface_tearoff(winrt::guid const& id, void** result) const noexcept override
        {
            return py::py_obj_ref::query_interface_tearoff(id, result);
        }

        std::vector<winrt::guid> get_iids_tearoff() const noexcept override
        {
            return py::py_obj_ref::get_iids_tearoff();
        }
    };

    static PyObject* _new_WebView2(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_GET_SIZE(args);

        auto self_type = get_python_type_for<winrt::Microsoft::UI::Xaml::Controls::WebView2>();
        if (!self_type)
        {
            return nullptr;
        }

        if (arg_count == 0)
        {
            try
            {
                if (type != self_type)
                {
                    py::pyobj_handle self{type->tp_alloc(type, 0)};
                    if (!self)
                    {
                        return nullptr;
                    }

                    std::construct_at(&reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj, nullptr);

                    auto obj_impl = winrt::make_self<PyWinrtWebView2>(self.get());

                    auto obj = py::make_py_obj<PyWinrtWebView2>(obj_impl, type, self.get());
                    if (!obj)
                    {
                        return nullptr;
                    }

                    reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj = std::move(obj);

                    return self.detach();
                }

                winrt::Microsoft::UI::Xaml::Controls::WebView2 instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_WebView2(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* WebView2_Close(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.WebView2", L"Close", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::WebView2>().Close();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* WebView2_EnsureCoreWebView2Async(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.WebView2", L"EnsureCoreWebView2Async", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::WebView2>().EnsureCoreWebView2Async();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* WebView2_ExecuteScriptAsync(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.WebView2", L"ExecuteScriptAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::WebView2>().ExecuteScriptAsync(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* WebView2_GoBack(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.WebView2", L"GoBack", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::WebView2>().GoBack();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* WebView2_GoForward(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.WebView2", L"GoForward", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::WebView2>().GoForward();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* WebView2_NavigateToString(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.WebView2", L"NavigateToString", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                {
                    auto _gil = release_gil();
                    self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::WebView2>().NavigateToString(param0);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* WebView2_Reload(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.WebView2", L"Reload", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::WebView2>().Reload();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* WebView2_get_Source(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.WebView2", L"Source");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::WebView2>().Source();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int WebView2_put_Source(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.WebView2", L"Source");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::WebView2>().Source(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* WebView2_get_CanGoForward(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.WebView2", L"CanGoForward");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::WebView2>().CanGoForward();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int WebView2_put_CanGoForward(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.WebView2", L"CanGoForward");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::WebView2>().CanGoForward(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* WebView2_get_CanGoBack(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.WebView2", L"CanGoBack");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::WebView2>().CanGoBack();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int WebView2_put_CanGoBack(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.WebView2", L"CanGoBack");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::WebView2>().CanGoBack(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* WebView2_get_CoreWebView2(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.WebView2", L"CoreWebView2");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::WebView2>().CoreWebView2();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebView2_get_CanGoBackProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.WebView2", L"CanGoBackProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::WebView2::CanGoBackProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebView2_get_CanGoForwardProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.WebView2", L"CanGoForwardProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::WebView2::CanGoForwardProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebView2_get_SourceProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.WebView2", L"SourceProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::WebView2::SourceProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebView2_add_CoreProcessFailed(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.WebView2", L"CoreProcessFailed");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Xaml::Controls::WebView2, winrt::Microsoft::Web::WebView2::Core::CoreWebView2ProcessFailedEventArgs>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::WebView2>().CoreProcessFailed(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebView2_remove_CoreProcessFailed(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.WebView2", L"CoreProcessFailed");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::WebView2>().CoreProcessFailed(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebView2_add_CoreWebView2Initialized(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.WebView2", L"CoreWebView2Initialized");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Xaml::Controls::WebView2, winrt::Microsoft::UI::Xaml::Controls::CoreWebView2InitializedEventArgs>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::WebView2>().CoreWebView2Initialized(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebView2_remove_CoreWebView2Initialized(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.WebView2", L"CoreWebView2Initialized");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::WebView2>().CoreWebView2Initialized(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebView2_add_NavigationCompleted(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.WebView2", L"NavigationCompleted");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Xaml::Controls::WebView2, winrt::Microsoft::Web::WebView2::Core::CoreWebView2NavigationCompletedEventArgs>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::WebView2>().NavigationCompleted(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebView2_remove_NavigationCompleted(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.WebView2", L"NavigationCompleted");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::WebView2>().NavigationCompleted(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebView2_add_NavigationStarting(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.WebView2", L"NavigationStarting");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Xaml::Controls::WebView2, winrt::Microsoft::Web::WebView2::Core::CoreWebView2NavigationStartingEventArgs>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::WebView2>().NavigationStarting(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebView2_remove_NavigationStarting(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.WebView2", L"NavigationStarting");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::WebView2>().NavigationStarting(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebView2_add_WebMessageReceived(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.WebView2", L"WebMessageReceived");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Xaml::Controls::WebView2, winrt::Microsoft::Web::WebView2::Core::CoreWebView2WebMessageReceivedEventArgs>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::WebView2>().WebMessageReceived(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebView2_remove_WebMessageReceived(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.WebView2", L"WebMessageReceived");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::WebView2>().WebMessageReceived(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_WebView2(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::WebView2>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_WebView2(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::WebView2>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_WebView2[] = {
        { "close", reinterpret_cast<PyCFunction>(WebView2_Close), METH_VARARGS, nullptr },
        { "ensure_core_webview2_async", reinterpret_cast<PyCFunction>(WebView2_EnsureCoreWebView2Async), METH_VARARGS, nullptr },
        { "execute_script_async", reinterpret_cast<PyCFunction>(WebView2_ExecuteScriptAsync), METH_VARARGS, nullptr },
        { "go_back", reinterpret_cast<PyCFunction>(WebView2_GoBack), METH_VARARGS, nullptr },
        { "go_forward", reinterpret_cast<PyCFunction>(WebView2_GoForward), METH_VARARGS, nullptr },
        { "navigate_to_string", reinterpret_cast<PyCFunction>(WebView2_NavigateToString), METH_VARARGS, nullptr },
        { "reload", reinterpret_cast<PyCFunction>(WebView2_Reload), METH_VARARGS, nullptr },
        { "add_core_process_failed", reinterpret_cast<PyCFunction>(WebView2_add_CoreProcessFailed), METH_O, nullptr },
        { "remove_core_process_failed", reinterpret_cast<PyCFunction>(WebView2_remove_CoreProcessFailed), METH_O, nullptr },
        { "add_core_webview2_initialized", reinterpret_cast<PyCFunction>(WebView2_add_CoreWebView2Initialized), METH_O, nullptr },
        { "remove_core_webview2_initialized", reinterpret_cast<PyCFunction>(WebView2_remove_CoreWebView2Initialized), METH_O, nullptr },
        { "add_navigation_completed", reinterpret_cast<PyCFunction>(WebView2_add_NavigationCompleted), METH_O, nullptr },
        { "remove_navigation_completed", reinterpret_cast<PyCFunction>(WebView2_remove_NavigationCompleted), METH_O, nullptr },
        { "add_navigation_starting", reinterpret_cast<PyCFunction>(WebView2_add_NavigationStarting), METH_O, nullptr },
        { "remove_navigation_starting", reinterpret_cast<PyCFunction>(WebView2_remove_NavigationStarting), METH_O, nullptr },
        { "add_web_message_received", reinterpret_cast<PyCFunction>(WebView2_add_WebMessageReceived), METH_O, nullptr },
        { "remove_web_message_received", reinterpret_cast<PyCFunction>(WebView2_remove_WebMessageReceived), METH_O, nullptr },
        { "_assign_array_", _assign_array_WebView2, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_WebView2), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_WebView2[] = {
        { "source", reinterpret_cast<getter>(WebView2_get_Source), reinterpret_cast<setter>(WebView2_put_Source), nullptr, nullptr },
        { "can_go_forward", reinterpret_cast<getter>(WebView2_get_CanGoForward), reinterpret_cast<setter>(WebView2_put_CanGoForward), nullptr, nullptr },
        { "can_go_back", reinterpret_cast<getter>(WebView2_get_CanGoBack), reinterpret_cast<setter>(WebView2_put_CanGoBack), nullptr, nullptr },
        { "core_webview2", reinterpret_cast<getter>(WebView2_get_CoreWebView2), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_WebView2[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_WebView2) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_WebView2) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_WebView2) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_WebView2) },
        { }};

    static PyType_Spec type_spec_WebView2 = {
        "winui2._winui2_microsoft_ui_xaml_controls.WebView2",
        sizeof(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_WebView2};

    static PyGetSetDef getset_WebView2_Static[] = {
        { "can_go_back_property", reinterpret_cast<getter>(WebView2_get_CanGoBackProperty), nullptr, nullptr, nullptr },
        { "can_go_forward_property", reinterpret_cast<getter>(WebView2_get_CanGoForwardProperty), nullptr, nullptr, nullptr },
        { "source_property", reinterpret_cast<getter>(WebView2_get_SourceProperty), nullptr, nullptr, nullptr },
        { }};

    static PyMethodDef methods_WebView2_Static[] = {
        { }};

    static PyType_Slot type_slots_WebView2_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_WebView2_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_WebView2_Static) },
        { }
    };

    static PyType_Spec type_spec_WebView2_Static = {
        "winui2._winui2_microsoft_ui_xaml_controls.WebView2_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_WebView2_Static};

    // ----- XamlControlsResources class --------------------

    static PyObject* _new_XamlControlsResources(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_GET_SIZE(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Microsoft::UI::Xaml::Controls::XamlControlsResources instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_XamlControlsResources(py::wrapper::Microsoft::UI::Xaml::Controls::XamlControlsResources* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* XamlControlsResources_EnsureRevealLights(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.XamlControlsResources", L"EnsureRevealLights", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::UIElement>(args, 0);

                {
                    auto _gil = release_gil();
                    winrt::Microsoft::UI::Xaml::Controls::XamlControlsResources::EnsureRevealLights(param0);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* XamlControlsResources_get_ControlsResourcesVersion(py::wrapper::Microsoft::UI::Xaml::Controls::XamlControlsResources* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.XamlControlsResources", L"ControlsResourcesVersion");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ControlsResourcesVersion();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int XamlControlsResources_put_ControlsResourcesVersion(py::wrapper::Microsoft::UI::Xaml::Controls::XamlControlsResources* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.XamlControlsResources", L"ControlsResourcesVersion");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::ControlsResourcesVersion>(arg);

            {
                auto _gil = release_gil();
                self->obj.ControlsResourcesVersion(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* XamlControlsResources_get_ControlsResourcesVersionProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.XamlControlsResources", L"ControlsResourcesVersionProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::XamlControlsResources::ControlsResourcesVersionProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_XamlControlsResources(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::XamlControlsResources>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_XamlControlsResources(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::XamlControlsResources>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_XamlControlsResources[] = {
        { "_assign_array_", _assign_array_XamlControlsResources, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_XamlControlsResources), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_XamlControlsResources[] = {
        { "controls_resources_version", reinterpret_cast<getter>(XamlControlsResources_get_ControlsResourcesVersion), reinterpret_cast<setter>(XamlControlsResources_put_ControlsResourcesVersion), nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_XamlControlsResources[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_XamlControlsResources) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_XamlControlsResources) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_XamlControlsResources) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_XamlControlsResources) },
        { }};

    static PyType_Spec type_spec_XamlControlsResources = {
        "winui2._winui2_microsoft_ui_xaml_controls.XamlControlsResources",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Controls::XamlControlsResources),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_XamlControlsResources};

    static PyGetSetDef getset_XamlControlsResources_Static[] = {
        { "controls_resources_version_property", reinterpret_cast<getter>(XamlControlsResources_get_ControlsResourcesVersionProperty), nullptr, nullptr, nullptr },
        { }};

    static PyMethodDef methods_XamlControlsResources_Static[] = {
        { "ensure_reveal_lights", reinterpret_cast<PyCFunction>(XamlControlsResources_EnsureRevealLights), METH_VARARGS, nullptr },
        { }};

    static PyType_Slot type_slots_XamlControlsResources_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_XamlControlsResources_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_XamlControlsResources_Static) },
        { }
    };

    static PyType_Spec type_spec_XamlControlsResources_Static = {
        "winui2._winui2_microsoft_ui_xaml_controls.XamlControlsResources_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_XamlControlsResources_Static};

    // ----- IAnimatedVisual interface --------------------

    #if PY_VERSION_HEX < 0x030A0000
    static PyObject* _new_IAnimatedVisual(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Xaml::Controls::IAnimatedVisual>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Xaml::Controls::IAnimatedVisual>::type_name);
        return nullptr;
    }
    #endif

    static void _dealloc_IAnimatedVisual(py::wrapper::Microsoft::UI::Xaml::Controls::IAnimatedVisual* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IAnimatedVisual_Close(py::wrapper::Microsoft::UI::Xaml::Controls::IAnimatedVisual* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.IClosable", L"Close", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.Close();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IAnimatedVisual_get_Duration(py::wrapper::Microsoft::UI::Xaml::Controls::IAnimatedVisual* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.IAnimatedVisual", L"Duration");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Duration();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IAnimatedVisual_get_RootVisual(py::wrapper::Microsoft::UI::Xaml::Controls::IAnimatedVisual* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.IAnimatedVisual", L"RootVisual");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.RootVisual();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IAnimatedVisual_get_Size(py::wrapper::Microsoft::UI::Xaml::Controls::IAnimatedVisual* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.IAnimatedVisual", L"Size");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Size();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_IAnimatedVisual(py::wrapper::Microsoft::UI::Xaml::Controls::IAnimatedVisual* self, PyObject* /*unused*/) noexcept
    {
        return Py_NewRef(self);
    }

    static PyObject* _exit_IAnimatedVisual(py::wrapper::Microsoft::UI::Xaml::Controls::IAnimatedVisual* self, PyObject* /*unused*/) noexcept
    {
        try
        {
            {
                auto _gil = py::release_gil();
                self->obj.Close();
            }

            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IAnimatedVisual[] = {
        { "close", reinterpret_cast<PyCFunction>(IAnimatedVisual_Close), METH_VARARGS, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_IAnimatedVisual), METH_NOARGS, nullptr },
        { "__exit__", reinterpret_cast<PyCFunction>(_exit_IAnimatedVisual), METH_VARARGS, nullptr },
        { }};

    static PyGetSetDef _getset_IAnimatedVisual[] = {
        { "duration", reinterpret_cast<getter>(IAnimatedVisual_get_Duration), nullptr, nullptr, nullptr },
        { "root_visual", reinterpret_cast<getter>(IAnimatedVisual_get_RootVisual), nullptr, nullptr, nullptr },
        { "size", reinterpret_cast<getter>(IAnimatedVisual_get_Size), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_IAnimatedVisual[] = {
        #if PY_VERSION_HEX < 0x030A0000
        { Py_tp_new, reinterpret_cast<void*>(_new_IAnimatedVisual) },
        #endif
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IAnimatedVisual) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IAnimatedVisual) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IAnimatedVisual) },
        { }};

    static PyType_Spec type_spec_IAnimatedVisual = {
        "winui2._winui2_microsoft_ui_xaml_controls._IAnimatedVisual",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Controls::IAnimatedVisual),
        0,
        Py_TPFLAGS_DEFAULT
        #if PY_VERSION_HEX >= 0x030A0000
        | Py_TPFLAGS_DISALLOW_INSTANTIATION
        #endif
        ,
        _type_slots_IAnimatedVisual};

    struct ImplementsIAnimatedVisual : py::ImplementsInterfaceT<ImplementsIAnimatedVisual, winrt::Microsoft::UI::Xaml::Controls::IAnimatedVisual>
    {
        ImplementsIAnimatedVisual() = delete;
        ImplementsIAnimatedVisual(PyObject* py_obj, winrt::impl::inspectable_abi* runtime_class) : py::ImplementsInterfaceT<ImplementsIAnimatedVisual, winrt::Microsoft::UI::Xaml::Controls::IAnimatedVisual>(py_obj, runtime_class)
        {
        }

        auto Close()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "close")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallNoArgs(method.get())};
                if (!return_value)
                {
                    throw python_exception();
                }
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto Duration()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "duration")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::Foundation::TimeSpan>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto RootVisual()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "root_visual")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::UI::Composition::Visual>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto Size()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "size")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::Foundation::Numerics::float2>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }
    };

    static PyObject* _assign_array_IAnimatedVisual(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::IAnimatedVisual>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IAnimatedVisual(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::IAnimatedVisual>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _guid_ImplementsIAnimatedVisual(PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::guid_of<winrt::Microsoft::UI::Xaml::Controls::IAnimatedVisual>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _make_ImplementsIAnimatedVisual(PyObject* /*unused*/, PyObject* args) noexcept
    {
        try
        {
            PyObject* py_obj;
            winrt::impl::inspectable_abi* runtime_class;

            if (!PyArg_ParseTuple(args, "On", &py_obj, &runtime_class))
            {
                return nullptr;
            }

            auto iface{std::make_unique<ImplementsIAnimatedVisual>(py_obj, runtime_class)};

            return PyLong_FromVoidPtr(iface.release());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef methods_ImplementsIAnimatedVisual[] = {
        { "_assign_array_", _assign_array_IAnimatedVisual, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IAnimatedVisual), METH_O | METH_STATIC, nullptr },
        { "_guid_", reinterpret_cast<PyCFunction>(_guid_ImplementsIAnimatedVisual), METH_NOARGS | METH_STATIC, nullptr },
        { "_make_", reinterpret_cast<PyCFunction>(_make_ImplementsIAnimatedVisual), METH_VARARGS | METH_STATIC, nullptr },
        { }};

    static PyType_Slot type_slots_ImplementsIAnimatedVisual[] = {
        { Py_tp_methods, reinterpret_cast<void*>(methods_ImplementsIAnimatedVisual) },
        { }};

    static PyType_Spec type_spec_ImplementsIAnimatedVisual = {
        "winui2._winui2_microsoft_ui_xaml_controls.IAnimatedVisual",
        0,
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE
        #if PY_VERSION_HEX >= 0x030A0000
        | Py_TPFLAGS_DISALLOW_INSTANTIATION
        #endif
        ,
        type_slots_ImplementsIAnimatedVisual};

    // ----- IAnimatedVisual2 interface --------------------

    #if PY_VERSION_HEX < 0x030A0000
    static PyObject* _new_IAnimatedVisual2(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Xaml::Controls::IAnimatedVisual2>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Xaml::Controls::IAnimatedVisual2>::type_name);
        return nullptr;
    }
    #endif

    static void _dealloc_IAnimatedVisual2(py::wrapper::Microsoft::UI::Xaml::Controls::IAnimatedVisual2* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IAnimatedVisual2_Close(py::wrapper::Microsoft::UI::Xaml::Controls::IAnimatedVisual2* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.IClosable", L"Close", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.Close();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IAnimatedVisual2_CreateAnimations(py::wrapper::Microsoft::UI::Xaml::Controls::IAnimatedVisual2* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.IAnimatedVisual2", L"CreateAnimations", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.CreateAnimations();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IAnimatedVisual2_DestroyAnimations(py::wrapper::Microsoft::UI::Xaml::Controls::IAnimatedVisual2* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.IAnimatedVisual2", L"DestroyAnimations", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.DestroyAnimations();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IAnimatedVisual2_get_Duration(py::wrapper::Microsoft::UI::Xaml::Controls::IAnimatedVisual2* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.IAnimatedVisual", L"Duration");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Duration();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IAnimatedVisual2_get_RootVisual(py::wrapper::Microsoft::UI::Xaml::Controls::IAnimatedVisual2* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.IAnimatedVisual", L"RootVisual");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.RootVisual();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IAnimatedVisual2_get_Size(py::wrapper::Microsoft::UI::Xaml::Controls::IAnimatedVisual2* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.IAnimatedVisual", L"Size");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Size();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_IAnimatedVisual2(py::wrapper::Microsoft::UI::Xaml::Controls::IAnimatedVisual2* self, PyObject* /*unused*/) noexcept
    {
        return Py_NewRef(self);
    }

    static PyObject* _exit_IAnimatedVisual2(py::wrapper::Microsoft::UI::Xaml::Controls::IAnimatedVisual2* self, PyObject* /*unused*/) noexcept
    {
        try
        {
            {
                auto _gil = py::release_gil();
                self->obj.Close();
            }

            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IAnimatedVisual2[] = {
        { "close", reinterpret_cast<PyCFunction>(IAnimatedVisual2_Close), METH_VARARGS, nullptr },
        { "create_animations", reinterpret_cast<PyCFunction>(IAnimatedVisual2_CreateAnimations), METH_VARARGS, nullptr },
        { "destroy_animations", reinterpret_cast<PyCFunction>(IAnimatedVisual2_DestroyAnimations), METH_VARARGS, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_IAnimatedVisual2), METH_NOARGS, nullptr },
        { "__exit__", reinterpret_cast<PyCFunction>(_exit_IAnimatedVisual2), METH_VARARGS, nullptr },
        { }};

    static PyGetSetDef _getset_IAnimatedVisual2[] = {
        { "duration", reinterpret_cast<getter>(IAnimatedVisual2_get_Duration), nullptr, nullptr, nullptr },
        { "root_visual", reinterpret_cast<getter>(IAnimatedVisual2_get_RootVisual), nullptr, nullptr, nullptr },
        { "size", reinterpret_cast<getter>(IAnimatedVisual2_get_Size), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_IAnimatedVisual2[] = {
        #if PY_VERSION_HEX < 0x030A0000
        { Py_tp_new, reinterpret_cast<void*>(_new_IAnimatedVisual2) },
        #endif
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IAnimatedVisual2) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IAnimatedVisual2) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IAnimatedVisual2) },
        { }};

    static PyType_Spec type_spec_IAnimatedVisual2 = {
        "winui2._winui2_microsoft_ui_xaml_controls._IAnimatedVisual2",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Controls::IAnimatedVisual2),
        0,
        Py_TPFLAGS_DEFAULT
        #if PY_VERSION_HEX >= 0x030A0000
        | Py_TPFLAGS_DISALLOW_INSTANTIATION
        #endif
        ,
        _type_slots_IAnimatedVisual2};

    struct ImplementsIAnimatedVisual2 : py::ImplementsInterfaceT<ImplementsIAnimatedVisual2, winrt::Microsoft::UI::Xaml::Controls::IAnimatedVisual2>
    {
        ImplementsIAnimatedVisual2() = delete;
        ImplementsIAnimatedVisual2(PyObject* py_obj, winrt::impl::inspectable_abi* runtime_class) : py::ImplementsInterfaceT<ImplementsIAnimatedVisual2, winrt::Microsoft::UI::Xaml::Controls::IAnimatedVisual2>(py_obj, runtime_class)
        {
        }

        auto Close()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "close")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallNoArgs(method.get())};
                if (!return_value)
                {
                    throw python_exception();
                }
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto CreateAnimations()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "create_animations")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallNoArgs(method.get())};
                if (!return_value)
                {
                    throw python_exception();
                }
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto DestroyAnimations()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "destroy_animations")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallNoArgs(method.get())};
                if (!return_value)
                {
                    throw python_exception();
                }
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto Duration()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "duration")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::Foundation::TimeSpan>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto RootVisual()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "root_visual")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::UI::Composition::Visual>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto Size()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "size")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::Foundation::Numerics::float2>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }
    };

    static PyObject* _assign_array_IAnimatedVisual2(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::IAnimatedVisual2>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IAnimatedVisual2(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::IAnimatedVisual2>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _guid_ImplementsIAnimatedVisual2(PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::guid_of<winrt::Microsoft::UI::Xaml::Controls::IAnimatedVisual2>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _make_ImplementsIAnimatedVisual2(PyObject* /*unused*/, PyObject* args) noexcept
    {
        try
        {
            PyObject* py_obj;
            winrt::impl::inspectable_abi* runtime_class;

            if (!PyArg_ParseTuple(args, "On", &py_obj, &runtime_class))
            {
                return nullptr;
            }

            auto iface{std::make_unique<ImplementsIAnimatedVisual2>(py_obj, runtime_class)};

            return PyLong_FromVoidPtr(iface.release());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef methods_ImplementsIAnimatedVisual2[] = {
        { "_assign_array_", _assign_array_IAnimatedVisual2, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IAnimatedVisual2), METH_O | METH_STATIC, nullptr },
        { "_guid_", reinterpret_cast<PyCFunction>(_guid_ImplementsIAnimatedVisual2), METH_NOARGS | METH_STATIC, nullptr },
        { "_make_", reinterpret_cast<PyCFunction>(_make_ImplementsIAnimatedVisual2), METH_VARARGS | METH_STATIC, nullptr },
        { }};

    static PyType_Slot type_slots_ImplementsIAnimatedVisual2[] = {
        { Py_tp_methods, reinterpret_cast<void*>(methods_ImplementsIAnimatedVisual2) },
        { }};

    static PyType_Spec type_spec_ImplementsIAnimatedVisual2 = {
        "winui2._winui2_microsoft_ui_xaml_controls.IAnimatedVisual2",
        0,
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE
        #if PY_VERSION_HEX >= 0x030A0000
        | Py_TPFLAGS_DISALLOW_INSTANTIATION
        #endif
        ,
        type_slots_ImplementsIAnimatedVisual2};

    // ----- IAnimatedVisualSource interface --------------------

    #if PY_VERSION_HEX < 0x030A0000
    static PyObject* _new_IAnimatedVisualSource(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Xaml::Controls::IAnimatedVisualSource>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Xaml::Controls::IAnimatedVisualSource>::type_name);
        return nullptr;
    }
    #endif

    static void _dealloc_IAnimatedVisualSource(py::wrapper::Microsoft::UI::Xaml::Controls::IAnimatedVisualSource* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IAnimatedVisualSource_TryCreateAnimatedVisual(py::wrapper::Microsoft::UI::Xaml::Controls::IAnimatedVisualSource* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.IAnimatedVisualSource", L"TryCreateAnimatedVisual", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Composition::Compositor>(args, 0);
                winrt::Windows::Foundation::IInspectable param1{};

                auto return_value = [&]()
                {
                    auto _gil = release_gil();
                    return self->obj.TryCreateAnimatedVisual(param0, param1);
                }();

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out1{ py::convert(param1) };
                if (!out1)
                {
                    return nullptr;
                }

                return PyTuple_Pack(2, out_return_value.get(), out1.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyMethodDef _methods_IAnimatedVisualSource[] = {
        { "try_create_animated_visual", reinterpret_cast<PyCFunction>(IAnimatedVisualSource_TryCreateAnimatedVisual), METH_VARARGS, nullptr },
        { }};

    static PyGetSetDef _getset_IAnimatedVisualSource[] = {
        { }};

    static PyType_Slot _type_slots_IAnimatedVisualSource[] = {
        #if PY_VERSION_HEX < 0x030A0000
        { Py_tp_new, reinterpret_cast<void*>(_new_IAnimatedVisualSource) },
        #endif
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IAnimatedVisualSource) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IAnimatedVisualSource) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IAnimatedVisualSource) },
        { }};

    static PyType_Spec type_spec_IAnimatedVisualSource = {
        "winui2._winui2_microsoft_ui_xaml_controls._IAnimatedVisualSource",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Controls::IAnimatedVisualSource),
        0,
        Py_TPFLAGS_DEFAULT
        #if PY_VERSION_HEX >= 0x030A0000
        | Py_TPFLAGS_DISALLOW_INSTANTIATION
        #endif
        ,
        _type_slots_IAnimatedVisualSource};

    struct ImplementsIAnimatedVisualSource : py::ImplementsInterfaceT<ImplementsIAnimatedVisualSource, winrt::Microsoft::UI::Xaml::Controls::IAnimatedVisualSource>
    {
        ImplementsIAnimatedVisualSource() = delete;
        ImplementsIAnimatedVisualSource(PyObject* py_obj, winrt::impl::inspectable_abi* runtime_class) : py::ImplementsInterfaceT<ImplementsIAnimatedVisualSource, winrt::Microsoft::UI::Xaml::Controls::IAnimatedVisualSource>(py_obj, runtime_class)
        {
        }

        auto TryCreateAnimatedVisual(winrt::Windows::UI::Composition::Compositor const& param0, winrt::Windows::Foundation::IInspectable& param1)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "try_create_animated_visual")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallOneArg(method.get(), py_param0.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                param1 = py::convert_to<winrt::Windows::Foundation::IInspectable>(return_value.get(), 1);

                return py::convert_to<winrt::Microsoft::UI::Xaml::Controls::IAnimatedVisual>(return_value.get(), 0);
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }
    };

    static PyObject* _assign_array_IAnimatedVisualSource(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::IAnimatedVisualSource>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IAnimatedVisualSource(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::IAnimatedVisualSource>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _guid_ImplementsIAnimatedVisualSource(PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::guid_of<winrt::Microsoft::UI::Xaml::Controls::IAnimatedVisualSource>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _make_ImplementsIAnimatedVisualSource(PyObject* /*unused*/, PyObject* args) noexcept
    {
        try
        {
            PyObject* py_obj;
            winrt::impl::inspectable_abi* runtime_class;

            if (!PyArg_ParseTuple(args, "On", &py_obj, &runtime_class))
            {
                return nullptr;
            }

            auto iface{std::make_unique<ImplementsIAnimatedVisualSource>(py_obj, runtime_class)};

            return PyLong_FromVoidPtr(iface.release());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef methods_ImplementsIAnimatedVisualSource[] = {
        { "_assign_array_", _assign_array_IAnimatedVisualSource, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IAnimatedVisualSource), METH_O | METH_STATIC, nullptr },
        { "_guid_", reinterpret_cast<PyCFunction>(_guid_ImplementsIAnimatedVisualSource), METH_NOARGS | METH_STATIC, nullptr },
        { "_make_", reinterpret_cast<PyCFunction>(_make_ImplementsIAnimatedVisualSource), METH_VARARGS | METH_STATIC, nullptr },
        { }};

    static PyType_Slot type_slots_ImplementsIAnimatedVisualSource[] = {
        { Py_tp_methods, reinterpret_cast<void*>(methods_ImplementsIAnimatedVisualSource) },
        { }};

    static PyType_Spec type_spec_ImplementsIAnimatedVisualSource = {
        "winui2._winui2_microsoft_ui_xaml_controls.IAnimatedVisualSource",
        0,
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE
        #if PY_VERSION_HEX >= 0x030A0000
        | Py_TPFLAGS_DISALLOW_INSTANTIATION
        #endif
        ,
        type_slots_ImplementsIAnimatedVisualSource};

    // ----- IAnimatedVisualSource2 interface --------------------

    #if PY_VERSION_HEX < 0x030A0000
    static PyObject* _new_IAnimatedVisualSource2(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Xaml::Controls::IAnimatedVisualSource2>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Xaml::Controls::IAnimatedVisualSource2>::type_name);
        return nullptr;
    }
    #endif

    static void _dealloc_IAnimatedVisualSource2(py::wrapper::Microsoft::UI::Xaml::Controls::IAnimatedVisualSource2* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IAnimatedVisualSource2_SetColorProperty(py::wrapper::Microsoft::UI::Xaml::Controls::IAnimatedVisualSource2* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.IAnimatedVisualSource2", L"SetColorProperty", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Color>(args, 1);

                {
                    auto _gil = release_gil();
                    self->obj.SetColorProperty(param0, param1);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IAnimatedVisualSource2_TryCreateAnimatedVisual(py::wrapper::Microsoft::UI::Xaml::Controls::IAnimatedVisualSource2* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.IAnimatedVisualSource", L"TryCreateAnimatedVisual", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Composition::Compositor>(args, 0);
                winrt::Windows::Foundation::IInspectable param1{};

                auto return_value = [&]()
                {
                    auto _gil = release_gil();
                    return self->obj.TryCreateAnimatedVisual(param0, param1);
                }();

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out1{ py::convert(param1) };
                if (!out1)
                {
                    return nullptr;
                }

                return PyTuple_Pack(2, out_return_value.get(), out1.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IAnimatedVisualSource2_get_Markers(py::wrapper::Microsoft::UI::Xaml::Controls::IAnimatedVisualSource2* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.IAnimatedVisualSource2", L"Markers");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Markers();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IAnimatedVisualSource2[] = {
        { "set_color_property", reinterpret_cast<PyCFunction>(IAnimatedVisualSource2_SetColorProperty), METH_VARARGS, nullptr },
        { "try_create_animated_visual", reinterpret_cast<PyCFunction>(IAnimatedVisualSource2_TryCreateAnimatedVisual), METH_VARARGS, nullptr },
        { }};

    static PyGetSetDef _getset_IAnimatedVisualSource2[] = {
        { "markers", reinterpret_cast<getter>(IAnimatedVisualSource2_get_Markers), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_IAnimatedVisualSource2[] = {
        #if PY_VERSION_HEX < 0x030A0000
        { Py_tp_new, reinterpret_cast<void*>(_new_IAnimatedVisualSource2) },
        #endif
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IAnimatedVisualSource2) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IAnimatedVisualSource2) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IAnimatedVisualSource2) },
        { }};

    static PyType_Spec type_spec_IAnimatedVisualSource2 = {
        "winui2._winui2_microsoft_ui_xaml_controls._IAnimatedVisualSource2",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Controls::IAnimatedVisualSource2),
        0,
        Py_TPFLAGS_DEFAULT
        #if PY_VERSION_HEX >= 0x030A0000
        | Py_TPFLAGS_DISALLOW_INSTANTIATION
        #endif
        ,
        _type_slots_IAnimatedVisualSource2};

    struct ImplementsIAnimatedVisualSource2 : py::ImplementsInterfaceT<ImplementsIAnimatedVisualSource2, winrt::Microsoft::UI::Xaml::Controls::IAnimatedVisualSource2>
    {
        ImplementsIAnimatedVisualSource2() = delete;
        ImplementsIAnimatedVisualSource2(PyObject* py_obj, winrt::impl::inspectable_abi* runtime_class) : py::ImplementsInterfaceT<ImplementsIAnimatedVisualSource2, winrt::Microsoft::UI::Xaml::Controls::IAnimatedVisualSource2>(py_obj, runtime_class)
        {
        }

        auto SetColorProperty(winrt::hstring const& param0, winrt::Windows::UI::Color param1)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "set_color_property")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param1{py::convert(param1)};
                if (!py_param1)
                {
                    throw python_exception();
                }

                py::pyobj_handle args{PyTuple_Pack(2, py_param0.get(), py_param1.get())};
                if (!args)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallObject(method.get(), args.get())};
                if (!return_value)
                {
                    throw python_exception();
                }
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto TryCreateAnimatedVisual(winrt::Windows::UI::Composition::Compositor const& param0, winrt::Windows::Foundation::IInspectable& param1)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "try_create_animated_visual")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallOneArg(method.get(), py_param0.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                param1 = py::convert_to<winrt::Windows::Foundation::IInspectable>(return_value.get(), 1);

                return py::convert_to<winrt::Microsoft::UI::Xaml::Controls::IAnimatedVisual>(return_value.get(), 0);
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto Markers()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "markers")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::Foundation::Collections::IMapView<winrt::hstring, double>>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }
    };

    static PyObject* _assign_array_IAnimatedVisualSource2(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::IAnimatedVisualSource2>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IAnimatedVisualSource2(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::IAnimatedVisualSource2>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _guid_ImplementsIAnimatedVisualSource2(PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::guid_of<winrt::Microsoft::UI::Xaml::Controls::IAnimatedVisualSource2>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _make_ImplementsIAnimatedVisualSource2(PyObject* /*unused*/, PyObject* args) noexcept
    {
        try
        {
            PyObject* py_obj;
            winrt::impl::inspectable_abi* runtime_class;

            if (!PyArg_ParseTuple(args, "On", &py_obj, &runtime_class))
            {
                return nullptr;
            }

            auto iface{std::make_unique<ImplementsIAnimatedVisualSource2>(py_obj, runtime_class)};

            return PyLong_FromVoidPtr(iface.release());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef methods_ImplementsIAnimatedVisualSource2[] = {
        { "_assign_array_", _assign_array_IAnimatedVisualSource2, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IAnimatedVisualSource2), METH_O | METH_STATIC, nullptr },
        { "_guid_", reinterpret_cast<PyCFunction>(_guid_ImplementsIAnimatedVisualSource2), METH_NOARGS | METH_STATIC, nullptr },
        { "_make_", reinterpret_cast<PyCFunction>(_make_ImplementsIAnimatedVisualSource2), METH_VARARGS | METH_STATIC, nullptr },
        { }};

    static PyType_Slot type_slots_ImplementsIAnimatedVisualSource2[] = {
        { Py_tp_methods, reinterpret_cast<void*>(methods_ImplementsIAnimatedVisualSource2) },
        { }};

    static PyType_Spec type_spec_ImplementsIAnimatedVisualSource2 = {
        "winui2._winui2_microsoft_ui_xaml_controls.IAnimatedVisualSource2",
        0,
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE
        #if PY_VERSION_HEX >= 0x030A0000
        | Py_TPFLAGS_DISALLOW_INSTANTIATION
        #endif
        ,
        type_slots_ImplementsIAnimatedVisualSource2};

    // ----- IAnimatedVisualSource3 interface --------------------

    #if PY_VERSION_HEX < 0x030A0000
    static PyObject* _new_IAnimatedVisualSource3(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Xaml::Controls::IAnimatedVisualSource3>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Xaml::Controls::IAnimatedVisualSource3>::type_name);
        return nullptr;
    }
    #endif

    static void _dealloc_IAnimatedVisualSource3(py::wrapper::Microsoft::UI::Xaml::Controls::IAnimatedVisualSource3* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IAnimatedVisualSource3_TryCreateAnimatedVisual(py::wrapper::Microsoft::UI::Xaml::Controls::IAnimatedVisualSource3* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.IAnimatedVisualSource3", L"TryCreateAnimatedVisual", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Composition::Compositor>(args, 0);
                winrt::Windows::Foundation::IInspectable param1{};
                auto param2 = py::convert_to<bool>(args, 2);

                auto return_value = [&]()
                {
                    auto _gil = release_gil();
                    return self->obj.TryCreateAnimatedVisual(param0, param1, param2);
                }();

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out1{ py::convert(param1) };
                if (!out1)
                {
                    return nullptr;
                }

                return PyTuple_Pack(2, out_return_value.get(), out1.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyMethodDef _methods_IAnimatedVisualSource3[] = {
        { "try_create_animated_visual", reinterpret_cast<PyCFunction>(IAnimatedVisualSource3_TryCreateAnimatedVisual), METH_VARARGS, nullptr },
        { }};

    static PyGetSetDef _getset_IAnimatedVisualSource3[] = {
        { }};

    static PyType_Slot _type_slots_IAnimatedVisualSource3[] = {
        #if PY_VERSION_HEX < 0x030A0000
        { Py_tp_new, reinterpret_cast<void*>(_new_IAnimatedVisualSource3) },
        #endif
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IAnimatedVisualSource3) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IAnimatedVisualSource3) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IAnimatedVisualSource3) },
        { }};

    static PyType_Spec type_spec_IAnimatedVisualSource3 = {
        "winui2._winui2_microsoft_ui_xaml_controls._IAnimatedVisualSource3",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Controls::IAnimatedVisualSource3),
        0,
        Py_TPFLAGS_DEFAULT
        #if PY_VERSION_HEX >= 0x030A0000
        | Py_TPFLAGS_DISALLOW_INSTANTIATION
        #endif
        ,
        _type_slots_IAnimatedVisualSource3};

    struct ImplementsIAnimatedVisualSource3 : py::ImplementsInterfaceT<ImplementsIAnimatedVisualSource3, winrt::Microsoft::UI::Xaml::Controls::IAnimatedVisualSource3>
    {
        ImplementsIAnimatedVisualSource3() = delete;
        ImplementsIAnimatedVisualSource3(PyObject* py_obj, winrt::impl::inspectable_abi* runtime_class) : py::ImplementsInterfaceT<ImplementsIAnimatedVisualSource3, winrt::Microsoft::UI::Xaml::Controls::IAnimatedVisualSource3>(py_obj, runtime_class)
        {
        }

        auto TryCreateAnimatedVisual(winrt::Windows::UI::Composition::Compositor const& param0, winrt::Windows::Foundation::IInspectable& param1, bool param2)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "try_create_animated_visual")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param2{py::convert(param2)};
                if (!py_param2)
                {
                    throw python_exception();
                }

                py::pyobj_handle args{PyTuple_Pack(2, py_param0.get(), py_param2.get())};
                if (!args)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallObject(method.get(), args.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                param1 = py::convert_to<winrt::Windows::Foundation::IInspectable>(return_value.get(), 1);

                return py::convert_to<winrt::Microsoft::UI::Xaml::Controls::IAnimatedVisual2>(return_value.get(), 0);
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }
    };

    static PyObject* _assign_array_IAnimatedVisualSource3(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::IAnimatedVisualSource3>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IAnimatedVisualSource3(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::IAnimatedVisualSource3>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _guid_ImplementsIAnimatedVisualSource3(PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::guid_of<winrt::Microsoft::UI::Xaml::Controls::IAnimatedVisualSource3>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _make_ImplementsIAnimatedVisualSource3(PyObject* /*unused*/, PyObject* args) noexcept
    {
        try
        {
            PyObject* py_obj;
            winrt::impl::inspectable_abi* runtime_class;

            if (!PyArg_ParseTuple(args, "On", &py_obj, &runtime_class))
            {
                return nullptr;
            }

            auto iface{std::make_unique<ImplementsIAnimatedVisualSource3>(py_obj, runtime_class)};

            return PyLong_FromVoidPtr(iface.release());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef methods_ImplementsIAnimatedVisualSource3[] = {
        { "_assign_array_", _assign_array_IAnimatedVisualSource3, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IAnimatedVisualSource3), METH_O | METH_STATIC, nullptr },
        { "_guid_", reinterpret_cast<PyCFunction>(_guid_ImplementsIAnimatedVisualSource3), METH_NOARGS | METH_STATIC, nullptr },
        { "_make_", reinterpret_cast<PyCFunction>(_make_ImplementsIAnimatedVisualSource3), METH_VARARGS | METH_STATIC, nullptr },
        { }};

    static PyType_Slot type_slots_ImplementsIAnimatedVisualSource3[] = {
        { Py_tp_methods, reinterpret_cast<void*>(methods_ImplementsIAnimatedVisualSource3) },
        { }};

    static PyType_Spec type_spec_ImplementsIAnimatedVisualSource3 = {
        "winui2._winui2_microsoft_ui_xaml_controls.IAnimatedVisualSource3",
        0,
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE
        #if PY_VERSION_HEX >= 0x030A0000
        | Py_TPFLAGS_DISALLOW_INSTANTIATION
        #endif
        ,
        type_slots_ImplementsIAnimatedVisualSource3};

    // ----- IDynamicAnimatedVisualSource interface --------------------

    #if PY_VERSION_HEX < 0x030A0000
    static PyObject* _new_IDynamicAnimatedVisualSource(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Xaml::Controls::IDynamicAnimatedVisualSource>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Xaml::Controls::IDynamicAnimatedVisualSource>::type_name);
        return nullptr;
    }
    #endif

    static void _dealloc_IDynamicAnimatedVisualSource(py::wrapper::Microsoft::UI::Xaml::Controls::IDynamicAnimatedVisualSource* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IDynamicAnimatedVisualSource_TryCreateAnimatedVisual(py::wrapper::Microsoft::UI::Xaml::Controls::IDynamicAnimatedVisualSource* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.IAnimatedVisualSource", L"TryCreateAnimatedVisual", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Composition::Compositor>(args, 0);
                winrt::Windows::Foundation::IInspectable param1{};

                auto return_value = [&]()
                {
                    auto _gil = release_gil();
                    return self->obj.TryCreateAnimatedVisual(param0, param1);
                }();

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out1{ py::convert(param1) };
                if (!out1)
                {
                    return nullptr;
                }

                return PyTuple_Pack(2, out_return_value.get(), out1.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IDynamicAnimatedVisualSource_add_AnimatedVisualInvalidated(py::wrapper::Microsoft::UI::Xaml::Controls::IDynamicAnimatedVisualSource* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.IDynamicAnimatedVisualSource", L"AnimatedVisualInvalidated");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Xaml::Controls::IDynamicAnimatedVisualSource, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.AnimatedVisualInvalidated(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IDynamicAnimatedVisualSource_remove_AnimatedVisualInvalidated(py::wrapper::Microsoft::UI::Xaml::Controls::IDynamicAnimatedVisualSource* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.IDynamicAnimatedVisualSource", L"AnimatedVisualInvalidated");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.AnimatedVisualInvalidated(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IDynamicAnimatedVisualSource[] = {
        { "try_create_animated_visual", reinterpret_cast<PyCFunction>(IDynamicAnimatedVisualSource_TryCreateAnimatedVisual), METH_VARARGS, nullptr },
        { "add_animated_visual_invalidated", reinterpret_cast<PyCFunction>(IDynamicAnimatedVisualSource_add_AnimatedVisualInvalidated), METH_O, nullptr },
        { "remove_animated_visual_invalidated", reinterpret_cast<PyCFunction>(IDynamicAnimatedVisualSource_remove_AnimatedVisualInvalidated), METH_O, nullptr },
        { }};

    static PyGetSetDef _getset_IDynamicAnimatedVisualSource[] = {
        { }};

    static PyType_Slot _type_slots_IDynamicAnimatedVisualSource[] = {
        #if PY_VERSION_HEX < 0x030A0000
        { Py_tp_new, reinterpret_cast<void*>(_new_IDynamicAnimatedVisualSource) },
        #endif
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IDynamicAnimatedVisualSource) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IDynamicAnimatedVisualSource) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IDynamicAnimatedVisualSource) },
        { }};

    static PyType_Spec type_spec_IDynamicAnimatedVisualSource = {
        "winui2._winui2_microsoft_ui_xaml_controls._IDynamicAnimatedVisualSource",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Controls::IDynamicAnimatedVisualSource),
        0,
        Py_TPFLAGS_DEFAULT
        #if PY_VERSION_HEX >= 0x030A0000
        | Py_TPFLAGS_DISALLOW_INSTANTIATION
        #endif
        ,
        _type_slots_IDynamicAnimatedVisualSource};

    struct ImplementsIDynamicAnimatedVisualSource : py::ImplementsInterfaceT<ImplementsIDynamicAnimatedVisualSource, winrt::Microsoft::UI::Xaml::Controls::IDynamicAnimatedVisualSource>
    {
        ImplementsIDynamicAnimatedVisualSource() = delete;
        ImplementsIDynamicAnimatedVisualSource(PyObject* py_obj, winrt::impl::inspectable_abi* runtime_class) : py::ImplementsInterfaceT<ImplementsIDynamicAnimatedVisualSource, winrt::Microsoft::UI::Xaml::Controls::IDynamicAnimatedVisualSource>(py_obj, runtime_class)
        {
        }

        auto TryCreateAnimatedVisual(winrt::Windows::UI::Composition::Compositor const& param0, winrt::Windows::Foundation::IInspectable& param1)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "try_create_animated_visual")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallOneArg(method.get(), py_param0.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                param1 = py::convert_to<winrt::Windows::Foundation::IInspectable>(return_value.get(), 1);

                return py::convert_to<winrt::Microsoft::UI::Xaml::Controls::IAnimatedVisual>(return_value.get(), 0);
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto AnimatedVisualInvalidated(winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Xaml::Controls::IDynamicAnimatedVisualSource, winrt::Windows::Foundation::IInspectable> const& param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "add_animated_visual_invalidated")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallOneArg(method.get(), py_param0.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::event_token>(return_value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto AnimatedVisualInvalidated(winrt::event_token param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "remove_animated_visual_invalidated")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallOneArg(method.get(), py_param0.get())};
                if (!return_value)
                {
                    throw python_exception();
                }
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }
    };

    static PyObject* _assign_array_IDynamicAnimatedVisualSource(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::IDynamicAnimatedVisualSource>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IDynamicAnimatedVisualSource(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::IDynamicAnimatedVisualSource>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _guid_ImplementsIDynamicAnimatedVisualSource(PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::guid_of<winrt::Microsoft::UI::Xaml::Controls::IDynamicAnimatedVisualSource>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _make_ImplementsIDynamicAnimatedVisualSource(PyObject* /*unused*/, PyObject* args) noexcept
    {
        try
        {
            PyObject* py_obj;
            winrt::impl::inspectable_abi* runtime_class;

            if (!PyArg_ParseTuple(args, "On", &py_obj, &runtime_class))
            {
                return nullptr;
            }

            auto iface{std::make_unique<ImplementsIDynamicAnimatedVisualSource>(py_obj, runtime_class)};

            return PyLong_FromVoidPtr(iface.release());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef methods_ImplementsIDynamicAnimatedVisualSource[] = {
        { "_assign_array_", _assign_array_IDynamicAnimatedVisualSource, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IDynamicAnimatedVisualSource), METH_O | METH_STATIC, nullptr },
        { "_guid_", reinterpret_cast<PyCFunction>(_guid_ImplementsIDynamicAnimatedVisualSource), METH_NOARGS | METH_STATIC, nullptr },
        { "_make_", reinterpret_cast<PyCFunction>(_make_ImplementsIDynamicAnimatedVisualSource), METH_VARARGS | METH_STATIC, nullptr },
        { }};

    static PyType_Slot type_slots_ImplementsIDynamicAnimatedVisualSource[] = {
        { Py_tp_methods, reinterpret_cast<void*>(methods_ImplementsIDynamicAnimatedVisualSource) },
        { }};

    static PyType_Spec type_spec_ImplementsIDynamicAnimatedVisualSource = {
        "winui2._winui2_microsoft_ui_xaml_controls.IDynamicAnimatedVisualSource",
        0,
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE
        #if PY_VERSION_HEX >= 0x030A0000
        | Py_TPFLAGS_DISALLOW_INSTANTIATION
        #endif
        ,
        type_slots_ImplementsIDynamicAnimatedVisualSource};

    // ----- IKeyIndexMapping interface --------------------

    #if PY_VERSION_HEX < 0x030A0000
    static PyObject* _new_IKeyIndexMapping(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Xaml::Controls::IKeyIndexMapping>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Xaml::Controls::IKeyIndexMapping>::type_name);
        return nullptr;
    }
    #endif

    static void _dealloc_IKeyIndexMapping(py::wrapper::Microsoft::UI::Xaml::Controls::IKeyIndexMapping* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IKeyIndexMapping_IndexFromKey(py::wrapper::Microsoft::UI::Xaml::Controls::IKeyIndexMapping* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.IKeyIndexMapping", L"IndexFromKey", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.IndexFromKey(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IKeyIndexMapping_KeyFromIndex(py::wrapper::Microsoft::UI::Xaml::Controls::IKeyIndexMapping* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.IKeyIndexMapping", L"KeyFromIndex", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<int32_t>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.KeyFromIndex(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyMethodDef _methods_IKeyIndexMapping[] = {
        { "index_from_key", reinterpret_cast<PyCFunction>(IKeyIndexMapping_IndexFromKey), METH_VARARGS, nullptr },
        { "key_from_index", reinterpret_cast<PyCFunction>(IKeyIndexMapping_KeyFromIndex), METH_VARARGS, nullptr },
        { }};

    static PyGetSetDef _getset_IKeyIndexMapping[] = {
        { }};

    static PyType_Slot _type_slots_IKeyIndexMapping[] = {
        #if PY_VERSION_HEX < 0x030A0000
        { Py_tp_new, reinterpret_cast<void*>(_new_IKeyIndexMapping) },
        #endif
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IKeyIndexMapping) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IKeyIndexMapping) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IKeyIndexMapping) },
        { }};

    static PyType_Spec type_spec_IKeyIndexMapping = {
        "winui2._winui2_microsoft_ui_xaml_controls._IKeyIndexMapping",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Controls::IKeyIndexMapping),
        0,
        Py_TPFLAGS_DEFAULT
        #if PY_VERSION_HEX >= 0x030A0000
        | Py_TPFLAGS_DISALLOW_INSTANTIATION
        #endif
        ,
        _type_slots_IKeyIndexMapping};

    struct ImplementsIKeyIndexMapping : py::ImplementsInterfaceT<ImplementsIKeyIndexMapping, winrt::Microsoft::UI::Xaml::Controls::IKeyIndexMapping>
    {
        ImplementsIKeyIndexMapping() = delete;
        ImplementsIKeyIndexMapping(PyObject* py_obj, winrt::impl::inspectable_abi* runtime_class) : py::ImplementsInterfaceT<ImplementsIKeyIndexMapping, winrt::Microsoft::UI::Xaml::Controls::IKeyIndexMapping>(py_obj, runtime_class)
        {
        }

        auto IndexFromKey(winrt::hstring const& param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "index_from_key")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallOneArg(method.get(), py_param0.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                return py::convert_to<int32_t>(return_value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto KeyFromIndex(int32_t param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "key_from_index")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallOneArg(method.get(), py_param0.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::hstring>(return_value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }
    };

    static PyObject* _assign_array_IKeyIndexMapping(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::IKeyIndexMapping>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IKeyIndexMapping(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::IKeyIndexMapping>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _guid_ImplementsIKeyIndexMapping(PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::guid_of<winrt::Microsoft::UI::Xaml::Controls::IKeyIndexMapping>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _make_ImplementsIKeyIndexMapping(PyObject* /*unused*/, PyObject* args) noexcept
    {
        try
        {
            PyObject* py_obj;
            winrt::impl::inspectable_abi* runtime_class;

            if (!PyArg_ParseTuple(args, "On", &py_obj, &runtime_class))
            {
                return nullptr;
            }

            auto iface{std::make_unique<ImplementsIKeyIndexMapping>(py_obj, runtime_class)};

            return PyLong_FromVoidPtr(iface.release());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef methods_ImplementsIKeyIndexMapping[] = {
        { "_assign_array_", _assign_array_IKeyIndexMapping, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IKeyIndexMapping), METH_O | METH_STATIC, nullptr },
        { "_guid_", reinterpret_cast<PyCFunction>(_guid_ImplementsIKeyIndexMapping), METH_NOARGS | METH_STATIC, nullptr },
        { "_make_", reinterpret_cast<PyCFunction>(_make_ImplementsIKeyIndexMapping), METH_VARARGS | METH_STATIC, nullptr },
        { }};

    static PyType_Slot type_slots_ImplementsIKeyIndexMapping[] = {
        { Py_tp_methods, reinterpret_cast<void*>(methods_ImplementsIKeyIndexMapping) },
        { }};

    static PyType_Spec type_spec_ImplementsIKeyIndexMapping = {
        "winui2._winui2_microsoft_ui_xaml_controls.IKeyIndexMapping",
        0,
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE
        #if PY_VERSION_HEX >= 0x030A0000
        | Py_TPFLAGS_DISALLOW_INSTANTIATION
        #endif
        ,
        type_slots_ImplementsIKeyIndexMapping};

    // ----- Microsoft.UI.Xaml.Controls Initialization --------------------

    PyDoc_STRVAR(module_doc, "Microsoft.UI.Xaml.Controls");

    static PyModuleDef module_def = {
        PyModuleDef_HEAD_INIT,
        "_winui2_microsoft_ui_xaml_controls",
        module_doc,
        0,
        nullptr,
        nullptr,
        nullptr,
        nullptr,
        nullptr};
} // py::cpp::Microsoft::UI::Xaml::Controls

PyMODINIT_FUNC PyInit__winui2_microsoft_ui_xaml_controls(void) noexcept
{
    using namespace py::cpp::Microsoft::UI::Xaml::Controls;

    if (py::import_winrt_runtime() == -1)
    {
        return nullptr;
    }

    py::pyobj_handle module{PyModule_Create(&module_def)};

    if (!module)
    {
        return nullptr;
    }

    auto inspectable_meta_type = py::get_inspectable_meta_type();
    if (!inspectable_meta_type)
    {
        return nullptr;
    }

    auto object_type = py::get_object_type();
    if (!object_type)
    {
        return nullptr;
    }

    py::pyobj_handle object_bases{PyTuple_Pack(1, object_type)};

    if (!object_bases)
    {
        return nullptr;
    }

    py::pyobj_handle windows_ui_xaml_controls_module{PyImport_ImportModule("winrt._winrt_windows_ui_xaml_controls")};
    if (!windows_ui_xaml_controls_module)
    {
        return nullptr;
    }

    py::pyobj_handle windows_ui_xaml_controls_IconElement_type{PyObject_GetAttrString(windows_ui_xaml_controls_module.get(), "IconElement")};
    if (!windows_ui_xaml_controls_IconElement_type)
    {
        return nullptr;
    }

    py::pyobj_handle windows_ui_xaml_controls_Control_type{PyObject_GetAttrString(windows_ui_xaml_controls_module.get(), "Control")};
    if (!windows_ui_xaml_controls_Control_type)
    {
        return nullptr;
    }

    py::pyobj_handle windows_ui_xaml_controls_ContentControl_type{PyObject_GetAttrString(windows_ui_xaml_controls_module.get(), "ContentControl")};
    if (!windows_ui_xaml_controls_ContentControl_type)
    {
        return nullptr;
    }

    py::pyobj_handle windows_ui_xaml_controls_MenuFlyoutItem_type{PyObject_GetAttrString(windows_ui_xaml_controls_module.get(), "MenuFlyoutItem")};
    if (!windows_ui_xaml_controls_MenuFlyoutItem_type)
    {
        return nullptr;
    }

    py::pyobj_handle windows_ui_xaml_module{PyImport_ImportModule("winrt._winrt_windows_ui_xaml")};
    if (!windows_ui_xaml_module)
    {
        return nullptr;
    }

    py::pyobj_handle windows_ui_xaml_FrameworkElement_type{PyObject_GetAttrString(windows_ui_xaml_module.get(), "FrameworkElement")};
    if (!windows_ui_xaml_FrameworkElement_type)
    {
        return nullptr;
    }

    py::pyobj_handle windows_ui_xaml_DependencyObject_type{PyObject_GetAttrString(windows_ui_xaml_module.get(), "DependencyObject")};
    if (!windows_ui_xaml_DependencyObject_type)
    {
        return nullptr;
    }

    py::pyobj_handle windows_ui_xaml_ResourceDictionary_type{PyObject_GetAttrString(windows_ui_xaml_module.get(), "ResourceDictionary")};
    if (!windows_ui_xaml_ResourceDictionary_type)
    {
        return nullptr;
    }

    py::pyobj_handle windows_ui_xaml_controls_primitives_module{PyImport_ImportModule("winrt._winrt_windows_ui_xaml_controls_primitives")};
    if (!windows_ui_xaml_controls_primitives_module)
    {
        return nullptr;
    }

    py::pyobj_handle windows_ui_xaml_controls_primitives_FlyoutBase_type{PyObject_GetAttrString(windows_ui_xaml_controls_primitives_module.get(), "FlyoutBase")};
    if (!windows_ui_xaml_controls_primitives_FlyoutBase_type)
    {
        return nullptr;
    }

    py::pyobj_handle windows_ui_xaml_controls_primitives_RangeBase_type{PyObject_GetAttrString(windows_ui_xaml_controls_primitives_module.get(), "RangeBase")};
    if (!windows_ui_xaml_controls_primitives_RangeBase_type)
    {
        return nullptr;
    }

    py::pyobj_handle windows_ui_xaml_controls_primitives_ListViewItemPresenter_type{PyObject_GetAttrString(windows_ui_xaml_controls_primitives_module.get(), "ListViewItemPresenter")};
    if (!windows_ui_xaml_controls_primitives_ListViewItemPresenter_type)
    {
        return nullptr;
    }

    py::pyobj_handle windows_ui_xaml_controls_2_module{PyImport_ImportModule("winrt._winrt_windows_ui_xaml_controls_2")};
    if (!windows_ui_xaml_controls_2_module)
    {
        return nullptr;
    }

    py::pyobj_handle windows_ui_xaml_controls_Button_type{PyObject_GetAttrString(windows_ui_xaml_controls_2_module.get(), "Button")};
    if (!windows_ui_xaml_controls_Button_type)
    {
        return nullptr;
    }

    py::pyobj_handle windows_ui_xaml_controls_MenuFlyout_type{PyObject_GetAttrString(windows_ui_xaml_controls_2_module.get(), "MenuFlyout")};
    if (!windows_ui_xaml_controls_MenuFlyout_type)
    {
        return nullptr;
    }

    py::pyobj_handle windows_ui_xaml_controls_ListViewItem_type{PyObject_GetAttrString(windows_ui_xaml_controls_2_module.get(), "ListViewItem")};
    if (!windows_ui_xaml_controls_ListViewItem_type)
    {
        return nullptr;
    }

    py::pyobj_handle windows_ui_xaml_controls_ListView_type{PyObject_GetAttrString(windows_ui_xaml_controls_2_module.get(), "ListView")};
    if (!windows_ui_xaml_controls_ListView_type)
    {
        return nullptr;
    }

    py::pyobj_handle AnimatedIcon_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(windows_ui_xaml_controls_IconElement_type.get())))};
    if (!AnimatedIcon_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_AnimatedIcon_Static{PyType_FromSpecWithBases(&type_spec_AnimatedIcon_Static, AnimatedIcon_Static_bases.get())};
    if (!type_AnimatedIcon_Static)
    {
        return nullptr;
    }

    py::pyobj_handle AnimatedIcon_bases{PyTuple_Pack(1, windows_ui_xaml_controls_IconElement_type.get())};
    if (!AnimatedIcon_bases)
    {
        return nullptr;
    }

    py::pytype_handle AnimatedIcon_type{py::register_python_type(module.get(), &type_spec_AnimatedIcon, AnimatedIcon_bases.get(), reinterpret_cast<PyTypeObject*>(type_AnimatedIcon_Static.get()))};
    if (!AnimatedIcon_type)
    {
        return nullptr;
    }

    py::pyobj_handle IconSource_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(windows_ui_xaml_DependencyObject_type.get())))};
    if (!IconSource_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_IconSource_Static{PyType_FromSpecWithBases(&type_spec_IconSource_Static, IconSource_Static_bases.get())};
    if (!type_IconSource_Static)
    {
        return nullptr;
    }

    py::pyobj_handle IconSource_bases{PyTuple_Pack(1, windows_ui_xaml_DependencyObject_type.get())};
    if (!IconSource_bases)
    {
        return nullptr;
    }

    py::pytype_handle IconSource_type{py::register_python_type(module.get(), &type_spec_IconSource, IconSource_bases.get(), reinterpret_cast<PyTypeObject*>(type_IconSource_Static.get()))};
    if (!IconSource_type)
    {
        return nullptr;
    }

    py::pyobj_handle AnimatedIconSource_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(IconSource_type.get())))};
    if (!AnimatedIconSource_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_AnimatedIconSource_Static{PyType_FromSpecWithBases(&type_spec_AnimatedIconSource_Static, AnimatedIconSource_Static_bases.get())};
    if (!type_AnimatedIconSource_Static)
    {
        return nullptr;
    }

    py::pyobj_handle AnimatedIconSource_bases{PyTuple_Pack(1, IconSource_type.get())};
    if (!AnimatedIconSource_bases)
    {
        return nullptr;
    }

    py::pytype_handle AnimatedIconSource_type{py::register_python_type(module.get(), &type_spec_AnimatedIconSource, AnimatedIconSource_bases.get(), reinterpret_cast<PyTypeObject*>(type_AnimatedIconSource_Static.get()))};
    if (!AnimatedIconSource_type)
    {
        return nullptr;
    }

    py::pyobj_handle AnimatedVisualPlayer_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(windows_ui_xaml_FrameworkElement_type.get())))};
    if (!AnimatedVisualPlayer_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_AnimatedVisualPlayer_Static{PyType_FromSpecWithBases(&type_spec_AnimatedVisualPlayer_Static, AnimatedVisualPlayer_Static_bases.get())};
    if (!type_AnimatedVisualPlayer_Static)
    {
        return nullptr;
    }

    py::pyobj_handle AnimatedVisualPlayer_bases{PyTuple_Pack(1, windows_ui_xaml_FrameworkElement_type.get())};
    if (!AnimatedVisualPlayer_bases)
    {
        return nullptr;
    }

    py::pytype_handle AnimatedVisualPlayer_type{py::register_python_type(module.get(), &type_spec_AnimatedVisualPlayer, AnimatedVisualPlayer_bases.get(), reinterpret_cast<PyTypeObject*>(type_AnimatedVisualPlayer_Static.get()))};
    if (!AnimatedVisualPlayer_type)
    {
        return nullptr;
    }

    py::pyobj_handle BackdropMaterial_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(windows_ui_xaml_DependencyObject_type.get())))};
    if (!BackdropMaterial_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_BackdropMaterial_Static{PyType_FromSpecWithBases(&type_spec_BackdropMaterial_Static, BackdropMaterial_Static_bases.get())};
    if (!type_BackdropMaterial_Static)
    {
        return nullptr;
    }

    py::pyobj_handle BackdropMaterial_bases{PyTuple_Pack(1, windows_ui_xaml_DependencyObject_type.get())};
    if (!BackdropMaterial_bases)
    {
        return nullptr;
    }

    py::pytype_handle BackdropMaterial_type{py::register_python_type(module.get(), &type_spec_BackdropMaterial, BackdropMaterial_bases.get(), reinterpret_cast<PyTypeObject*>(type_BackdropMaterial_Static.get()))};
    if (!BackdropMaterial_type)
    {
        return nullptr;
    }

    py::pyobj_handle BitmapIconSource_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(IconSource_type.get())))};
    if (!BitmapIconSource_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_BitmapIconSource_Static{PyType_FromSpecWithBases(&type_spec_BitmapIconSource_Static, BitmapIconSource_Static_bases.get())};
    if (!type_BitmapIconSource_Static)
    {
        return nullptr;
    }

    py::pyobj_handle BitmapIconSource_bases{PyTuple_Pack(1, IconSource_type.get())};
    if (!BitmapIconSource_bases)
    {
        return nullptr;
    }

    py::pytype_handle BitmapIconSource_type{py::register_python_type(module.get(), &type_spec_BitmapIconSource, BitmapIconSource_bases.get(), reinterpret_cast<PyTypeObject*>(type_BitmapIconSource_Static.get()))};
    if (!BitmapIconSource_type)
    {
        return nullptr;
    }

    py::pyobj_handle BreadcrumbBar_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(windows_ui_xaml_controls_Control_type.get())))};
    if (!BreadcrumbBar_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_BreadcrumbBar_Static{PyType_FromSpecWithBases(&type_spec_BreadcrumbBar_Static, BreadcrumbBar_Static_bases.get())};
    if (!type_BreadcrumbBar_Static)
    {
        return nullptr;
    }

    py::pyobj_handle BreadcrumbBar_bases{PyTuple_Pack(1, windows_ui_xaml_controls_Control_type.get())};
    if (!BreadcrumbBar_bases)
    {
        return nullptr;
    }

    py::pytype_handle BreadcrumbBar_type{py::register_python_type(module.get(), &type_spec_BreadcrumbBar, BreadcrumbBar_bases.get(), reinterpret_cast<PyTypeObject*>(type_BreadcrumbBar_Static.get()))};
    if (!BreadcrumbBar_type)
    {
        return nullptr;
    }

    py::pyobj_handle BreadcrumbBarItem_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(windows_ui_xaml_controls_ContentControl_type.get())))};
    if (!BreadcrumbBarItem_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_BreadcrumbBarItem_Static{PyType_FromSpecWithBases(&type_spec_BreadcrumbBarItem_Static, BreadcrumbBarItem_Static_bases.get())};
    if (!type_BreadcrumbBarItem_Static)
    {
        return nullptr;
    }

    py::pyobj_handle BreadcrumbBarItem_bases{PyTuple_Pack(1, windows_ui_xaml_controls_ContentControl_type.get())};
    if (!BreadcrumbBarItem_bases)
    {
        return nullptr;
    }

    py::pytype_handle BreadcrumbBarItem_type{py::register_python_type(module.get(), &type_spec_BreadcrumbBarItem, BreadcrumbBarItem_bases.get(), reinterpret_cast<PyTypeObject*>(type_BreadcrumbBarItem_Static.get()))};
    if (!BreadcrumbBarItem_type)
    {
        return nullptr;
    }

    py::pytype_handle BreadcrumbBarItemClickedEventArgs_type{py::register_python_type(module.get(), &type_spec_BreadcrumbBarItemClickedEventArgs, object_bases.get(), inspectable_meta_type)};
    if (!BreadcrumbBarItemClickedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle ColorChangedEventArgs_type{py::register_python_type(module.get(), &type_spec_ColorChangedEventArgs, object_bases.get(), inspectable_meta_type)};
    if (!ColorChangedEventArgs_type)
    {
        return nullptr;
    }

    py::pyobj_handle ColorPicker_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(windows_ui_xaml_controls_Control_type.get())))};
    if (!ColorPicker_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_ColorPicker_Static{PyType_FromSpecWithBases(&type_spec_ColorPicker_Static, ColorPicker_Static_bases.get())};
    if (!type_ColorPicker_Static)
    {
        return nullptr;
    }

    py::pyobj_handle ColorPicker_bases{PyTuple_Pack(1, windows_ui_xaml_controls_Control_type.get())};
    if (!ColorPicker_bases)
    {
        return nullptr;
    }

    py::pytype_handle ColorPicker_type{py::register_python_type(module.get(), &type_spec_ColorPicker, ColorPicker_bases.get(), reinterpret_cast<PyTypeObject*>(type_ColorPicker_Static.get()))};
    if (!ColorPicker_type)
    {
        return nullptr;
    }

    py::pyobj_handle CommandBarFlyout_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(windows_ui_xaml_controls_primitives_FlyoutBase_type.get())))};
    if (!CommandBarFlyout_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_CommandBarFlyout_Static{PyType_FromSpecWithBases(&type_spec_CommandBarFlyout_Static, CommandBarFlyout_Static_bases.get())};
    if (!type_CommandBarFlyout_Static)
    {
        return nullptr;
    }

    py::pyobj_handle CommandBarFlyout_bases{PyTuple_Pack(1, windows_ui_xaml_controls_primitives_FlyoutBase_type.get())};
    if (!CommandBarFlyout_bases)
    {
        return nullptr;
    }

    py::pytype_handle CommandBarFlyout_type{py::register_python_type(module.get(), &type_spec_CommandBarFlyout, CommandBarFlyout_bases.get(), reinterpret_cast<PyTypeObject*>(type_CommandBarFlyout_Static.get()))};
    if (!CommandBarFlyout_type)
    {
        return nullptr;
    }

    py::pytype_handle CoreWebView2InitializedEventArgs_type{py::register_python_type(module.get(), &type_spec_CoreWebView2InitializedEventArgs, object_bases.get(), inspectable_meta_type)};
    if (!CoreWebView2InitializedEventArgs_type)
    {
        return nullptr;
    }

    py::pyobj_handle DropDownButton_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(windows_ui_xaml_controls_Button_type.get())))};
    if (!DropDownButton_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_DropDownButton_Static{PyType_FromSpecWithBases(&type_spec_DropDownButton_Static, DropDownButton_Static_bases.get())};
    if (!type_DropDownButton_Static)
    {
        return nullptr;
    }

    py::pyobj_handle DropDownButton_bases{PyTuple_Pack(1, windows_ui_xaml_controls_Button_type.get())};
    if (!DropDownButton_bases)
    {
        return nullptr;
    }

    py::pytype_handle DropDownButton_type{py::register_python_type(module.get(), &type_spec_DropDownButton, DropDownButton_bases.get(), reinterpret_cast<PyTypeObject*>(type_DropDownButton_Static.get()))};
    if (!DropDownButton_type)
    {
        return nullptr;
    }

    py::pyobj_handle ElementFactory_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(windows_ui_xaml_DependencyObject_type.get())))};
    if (!ElementFactory_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_ElementFactory_Static{PyType_FromSpecWithBases(&type_spec_ElementFactory_Static, ElementFactory_Static_bases.get())};
    if (!type_ElementFactory_Static)
    {
        return nullptr;
    }

    py::pyobj_handle ElementFactory_bases{PyTuple_Pack(1, windows_ui_xaml_DependencyObject_type.get())};
    if (!ElementFactory_bases)
    {
        return nullptr;
    }

    py::pytype_handle ElementFactory_type{py::register_python_type(module.get(), &type_spec_ElementFactory, ElementFactory_bases.get(), reinterpret_cast<PyTypeObject*>(type_ElementFactory_Static.get()))};
    if (!ElementFactory_type)
    {
        return nullptr;
    }

    py::pytype_handle ElementFactoryGetArgs_type{py::register_python_type(module.get(), &type_spec_ElementFactoryGetArgs, object_bases.get(), inspectable_meta_type)};
    if (!ElementFactoryGetArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle ElementFactoryRecycleArgs_type{py::register_python_type(module.get(), &type_spec_ElementFactoryRecycleArgs, object_bases.get(), inspectable_meta_type)};
    if (!ElementFactoryRecycleArgs_type)
    {
        return nullptr;
    }

    py::pyobj_handle Expander_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(windows_ui_xaml_controls_ContentControl_type.get())))};
    if (!Expander_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_Expander_Static{PyType_FromSpecWithBases(&type_spec_Expander_Static, Expander_Static_bases.get())};
    if (!type_Expander_Static)
    {
        return nullptr;
    }

    py::pyobj_handle Expander_bases{PyTuple_Pack(1, windows_ui_xaml_controls_ContentControl_type.get())};
    if (!Expander_bases)
    {
        return nullptr;
    }

    py::pytype_handle Expander_type{py::register_python_type(module.get(), &type_spec_Expander, Expander_bases.get(), reinterpret_cast<PyTypeObject*>(type_Expander_Static.get()))};
    if (!Expander_type)
    {
        return nullptr;
    }

    py::pytype_handle ExpanderCollapsedEventArgs_type{py::register_python_type(module.get(), &type_spec_ExpanderCollapsedEventArgs, object_bases.get(), inspectable_meta_type)};
    if (!ExpanderCollapsedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle ExpanderExpandingEventArgs_type{py::register_python_type(module.get(), &type_spec_ExpanderExpandingEventArgs, object_bases.get(), inspectable_meta_type)};
    if (!ExpanderExpandingEventArgs_type)
    {
        return nullptr;
    }

    py::pyobj_handle ExpanderTemplateSettings_bases{PyTuple_Pack(1, windows_ui_xaml_DependencyObject_type.get())};
    if (!ExpanderTemplateSettings_bases)
    {
        return nullptr;
    }

    py::pytype_handle ExpanderTemplateSettings_type{py::register_python_type(module.get(), &type_spec_ExpanderTemplateSettings, ExpanderTemplateSettings_bases.get(), inspectable_meta_type)};
    if (!ExpanderTemplateSettings_type)
    {
        return nullptr;
    }

    py::pyobj_handle FontIconSource_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(IconSource_type.get())))};
    if (!FontIconSource_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_FontIconSource_Static{PyType_FromSpecWithBases(&type_spec_FontIconSource_Static, FontIconSource_Static_bases.get())};
    if (!type_FontIconSource_Static)
    {
        return nullptr;
    }

    py::pyobj_handle FontIconSource_bases{PyTuple_Pack(1, IconSource_type.get())};
    if (!FontIconSource_bases)
    {
        return nullptr;
    }

    py::pytype_handle FontIconSource_type{py::register_python_type(module.get(), &type_spec_FontIconSource, FontIconSource_bases.get(), reinterpret_cast<PyTypeObject*>(type_FontIconSource_Static.get()))};
    if (!FontIconSource_type)
    {
        return nullptr;
    }

    py::pyobj_handle ImageIcon_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(windows_ui_xaml_controls_IconElement_type.get())))};
    if (!ImageIcon_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_ImageIcon_Static{PyType_FromSpecWithBases(&type_spec_ImageIcon_Static, ImageIcon_Static_bases.get())};
    if (!type_ImageIcon_Static)
    {
        return nullptr;
    }

    py::pyobj_handle ImageIcon_bases{PyTuple_Pack(1, windows_ui_xaml_controls_IconElement_type.get())};
    if (!ImageIcon_bases)
    {
        return nullptr;
    }

    py::pytype_handle ImageIcon_type{py::register_python_type(module.get(), &type_spec_ImageIcon, ImageIcon_bases.get(), reinterpret_cast<PyTypeObject*>(type_ImageIcon_Static.get()))};
    if (!ImageIcon_type)
    {
        return nullptr;
    }

    py::pyobj_handle ImageIconSource_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(IconSource_type.get())))};
    if (!ImageIconSource_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_ImageIconSource_Static{PyType_FromSpecWithBases(&type_spec_ImageIconSource_Static, ImageIconSource_Static_bases.get())};
    if (!type_ImageIconSource_Static)
    {
        return nullptr;
    }

    py::pyobj_handle ImageIconSource_bases{PyTuple_Pack(1, IconSource_type.get())};
    if (!ImageIconSource_bases)
    {
        return nullptr;
    }

    py::pytype_handle ImageIconSource_type{py::register_python_type(module.get(), &type_spec_ImageIconSource, ImageIconSource_bases.get(), reinterpret_cast<PyTypeObject*>(type_ImageIconSource_Static.get()))};
    if (!ImageIconSource_type)
    {
        return nullptr;
    }

    py::pyobj_handle InfoBadge_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(windows_ui_xaml_controls_Control_type.get())))};
    if (!InfoBadge_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_InfoBadge_Static{PyType_FromSpecWithBases(&type_spec_InfoBadge_Static, InfoBadge_Static_bases.get())};
    if (!type_InfoBadge_Static)
    {
        return nullptr;
    }

    py::pyobj_handle InfoBadge_bases{PyTuple_Pack(1, windows_ui_xaml_controls_Control_type.get())};
    if (!InfoBadge_bases)
    {
        return nullptr;
    }

    py::pytype_handle InfoBadge_type{py::register_python_type(module.get(), &type_spec_InfoBadge, InfoBadge_bases.get(), reinterpret_cast<PyTypeObject*>(type_InfoBadge_Static.get()))};
    if (!InfoBadge_type)
    {
        return nullptr;
    }

    py::pyobj_handle InfoBadgeTemplateSettings_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(windows_ui_xaml_DependencyObject_type.get())))};
    if (!InfoBadgeTemplateSettings_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_InfoBadgeTemplateSettings_Static{PyType_FromSpecWithBases(&type_spec_InfoBadgeTemplateSettings_Static, InfoBadgeTemplateSettings_Static_bases.get())};
    if (!type_InfoBadgeTemplateSettings_Static)
    {
        return nullptr;
    }

    py::pyobj_handle InfoBadgeTemplateSettings_bases{PyTuple_Pack(1, windows_ui_xaml_DependencyObject_type.get())};
    if (!InfoBadgeTemplateSettings_bases)
    {
        return nullptr;
    }

    py::pytype_handle InfoBadgeTemplateSettings_type{py::register_python_type(module.get(), &type_spec_InfoBadgeTemplateSettings, InfoBadgeTemplateSettings_bases.get(), reinterpret_cast<PyTypeObject*>(type_InfoBadgeTemplateSettings_Static.get()))};
    if (!InfoBadgeTemplateSettings_type)
    {
        return nullptr;
    }

    py::pyobj_handle InfoBar_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(windows_ui_xaml_controls_Control_type.get())))};
    if (!InfoBar_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_InfoBar_Static{PyType_FromSpecWithBases(&type_spec_InfoBar_Static, InfoBar_Static_bases.get())};
    if (!type_InfoBar_Static)
    {
        return nullptr;
    }

    py::pyobj_handle InfoBar_bases{PyTuple_Pack(1, windows_ui_xaml_controls_Control_type.get())};
    if (!InfoBar_bases)
    {
        return nullptr;
    }

    py::pytype_handle InfoBar_type{py::register_python_type(module.get(), &type_spec_InfoBar, InfoBar_bases.get(), reinterpret_cast<PyTypeObject*>(type_InfoBar_Static.get()))};
    if (!InfoBar_type)
    {
        return nullptr;
    }

    py::pyobj_handle InfoBarClosedEventArgs_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(inspectable_meta_type))};
    if (!InfoBarClosedEventArgs_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_InfoBarClosedEventArgs_Static{PyType_FromSpecWithBases(&type_spec_InfoBarClosedEventArgs_Static, InfoBarClosedEventArgs_Static_bases.get())};
    if (!type_InfoBarClosedEventArgs_Static)
    {
        return nullptr;
    }

    py::pytype_handle InfoBarClosedEventArgs_type{py::register_python_type(module.get(), &type_spec_InfoBarClosedEventArgs, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_InfoBarClosedEventArgs_Static.get()))};
    if (!InfoBarClosedEventArgs_type)
    {
        return nullptr;
    }

    py::pyobj_handle InfoBarClosingEventArgs_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(inspectable_meta_type))};
    if (!InfoBarClosingEventArgs_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_InfoBarClosingEventArgs_Static{PyType_FromSpecWithBases(&type_spec_InfoBarClosingEventArgs_Static, InfoBarClosingEventArgs_Static_bases.get())};
    if (!type_InfoBarClosingEventArgs_Static)
    {
        return nullptr;
    }

    py::pytype_handle InfoBarClosingEventArgs_type{py::register_python_type(module.get(), &type_spec_InfoBarClosingEventArgs, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_InfoBarClosingEventArgs_Static.get()))};
    if (!InfoBarClosingEventArgs_type)
    {
        return nullptr;
    }

    py::pyobj_handle InfoBarTemplateSettings_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(windows_ui_xaml_DependencyObject_type.get())))};
    if (!InfoBarTemplateSettings_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_InfoBarTemplateSettings_Static{PyType_FromSpecWithBases(&type_spec_InfoBarTemplateSettings_Static, InfoBarTemplateSettings_Static_bases.get())};
    if (!type_InfoBarTemplateSettings_Static)
    {
        return nullptr;
    }

    py::pyobj_handle InfoBarTemplateSettings_bases{PyTuple_Pack(1, windows_ui_xaml_DependencyObject_type.get())};
    if (!InfoBarTemplateSettings_bases)
    {
        return nullptr;
    }

    py::pytype_handle InfoBarTemplateSettings_type{py::register_python_type(module.get(), &type_spec_InfoBarTemplateSettings, InfoBarTemplateSettings_bases.get(), reinterpret_cast<PyTypeObject*>(type_InfoBarTemplateSettings_Static.get()))};
    if (!InfoBarTemplateSettings_type)
    {
        return nullptr;
    }

    py::pyobj_handle ItemsRepeater_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(windows_ui_xaml_FrameworkElement_type.get())))};
    if (!ItemsRepeater_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_ItemsRepeater_Static{PyType_FromSpecWithBases(&type_spec_ItemsRepeater_Static, ItemsRepeater_Static_bases.get())};
    if (!type_ItemsRepeater_Static)
    {
        return nullptr;
    }

    py::pyobj_handle ItemsRepeater_bases{PyTuple_Pack(1, windows_ui_xaml_FrameworkElement_type.get())};
    if (!ItemsRepeater_bases)
    {
        return nullptr;
    }

    py::pytype_handle ItemsRepeater_type{py::register_python_type(module.get(), &type_spec_ItemsRepeater, ItemsRepeater_bases.get(), reinterpret_cast<PyTypeObject*>(type_ItemsRepeater_Static.get()))};
    if (!ItemsRepeater_type)
    {
        return nullptr;
    }

    py::pytype_handle ItemsRepeaterElementClearingEventArgs_type{py::register_python_type(module.get(), &type_spec_ItemsRepeaterElementClearingEventArgs, object_bases.get(), inspectable_meta_type)};
    if (!ItemsRepeaterElementClearingEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle ItemsRepeaterElementIndexChangedEventArgs_type{py::register_python_type(module.get(), &type_spec_ItemsRepeaterElementIndexChangedEventArgs, object_bases.get(), inspectable_meta_type)};
    if (!ItemsRepeaterElementIndexChangedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle ItemsRepeaterElementPreparedEventArgs_type{py::register_python_type(module.get(), &type_spec_ItemsRepeaterElementPreparedEventArgs, object_bases.get(), inspectable_meta_type)};
    if (!ItemsRepeaterElementPreparedEventArgs_type)
    {
        return nullptr;
    }

    py::pyobj_handle ItemsRepeaterScrollHost_bases{PyTuple_Pack(1, windows_ui_xaml_FrameworkElement_type.get())};
    if (!ItemsRepeaterScrollHost_bases)
    {
        return nullptr;
    }

    py::pytype_handle ItemsRepeaterScrollHost_type{py::register_python_type(module.get(), &type_spec_ItemsRepeaterScrollHost, ItemsRepeaterScrollHost_bases.get(), inspectable_meta_type)};
    if (!ItemsRepeaterScrollHost_type)
    {
        return nullptr;
    }

    py::pyobj_handle ItemsSourceView_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(inspectable_meta_type))};
    if (!ItemsSourceView_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_ItemsSourceView_Static{PyType_FromSpecWithBases(&type_spec_ItemsSourceView_Static, ItemsSourceView_Static_bases.get())};
    if (!type_ItemsSourceView_Static)
    {
        return nullptr;
    }

    py::pytype_handle ItemsSourceView_type{py::register_python_type(module.get(), &type_spec_ItemsSourceView, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_ItemsSourceView_Static.get()))};
    if (!ItemsSourceView_type)
    {
        return nullptr;
    }

    py::pyobj_handle Layout_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(windows_ui_xaml_DependencyObject_type.get())))};
    if (!Layout_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_Layout_Static{PyType_FromSpecWithBases(&type_spec_Layout_Static, Layout_Static_bases.get())};
    if (!type_Layout_Static)
    {
        return nullptr;
    }

    py::pyobj_handle Layout_bases{PyTuple_Pack(1, windows_ui_xaml_DependencyObject_type.get())};
    if (!Layout_bases)
    {
        return nullptr;
    }

    py::pytype_handle Layout_type{py::register_python_type(module.get(), &type_spec_Layout, Layout_bases.get(), reinterpret_cast<PyTypeObject*>(type_Layout_Static.get()))};
    if (!Layout_type)
    {
        return nullptr;
    }

    py::pyobj_handle LayoutContext_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(windows_ui_xaml_DependencyObject_type.get())))};
    if (!LayoutContext_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_LayoutContext_Static{PyType_FromSpecWithBases(&type_spec_LayoutContext_Static, LayoutContext_Static_bases.get())};
    if (!type_LayoutContext_Static)
    {
        return nullptr;
    }

    py::pyobj_handle LayoutContext_bases{PyTuple_Pack(1, windows_ui_xaml_DependencyObject_type.get())};
    if (!LayoutContext_bases)
    {
        return nullptr;
    }

    py::pytype_handle LayoutContext_type{py::register_python_type(module.get(), &type_spec_LayoutContext, LayoutContext_bases.get(), reinterpret_cast<PyTypeObject*>(type_LayoutContext_Static.get()))};
    if (!LayoutContext_type)
    {
        return nullptr;
    }

    py::pyobj_handle MenuBar_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(windows_ui_xaml_controls_Control_type.get())))};
    if (!MenuBar_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_MenuBar_Static{PyType_FromSpecWithBases(&type_spec_MenuBar_Static, MenuBar_Static_bases.get())};
    if (!type_MenuBar_Static)
    {
        return nullptr;
    }

    py::pyobj_handle MenuBar_bases{PyTuple_Pack(1, windows_ui_xaml_controls_Control_type.get())};
    if (!MenuBar_bases)
    {
        return nullptr;
    }

    py::pytype_handle MenuBar_type{py::register_python_type(module.get(), &type_spec_MenuBar, MenuBar_bases.get(), reinterpret_cast<PyTypeObject*>(type_MenuBar_Static.get()))};
    if (!MenuBar_type)
    {
        return nullptr;
    }

    py::pyobj_handle MenuBarItem_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(windows_ui_xaml_controls_Control_type.get())))};
    if (!MenuBarItem_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_MenuBarItem_Static{PyType_FromSpecWithBases(&type_spec_MenuBarItem_Static, MenuBarItem_Static_bases.get())};
    if (!type_MenuBarItem_Static)
    {
        return nullptr;
    }

    py::pyobj_handle MenuBarItem_bases{PyTuple_Pack(1, windows_ui_xaml_controls_Control_type.get())};
    if (!MenuBarItem_bases)
    {
        return nullptr;
    }

    py::pytype_handle MenuBarItem_type{py::register_python_type(module.get(), &type_spec_MenuBarItem, MenuBarItem_bases.get(), reinterpret_cast<PyTypeObject*>(type_MenuBarItem_Static.get()))};
    if (!MenuBarItem_type)
    {
        return nullptr;
    }

    py::pyobj_handle MenuBarItemFlyout_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(windows_ui_xaml_controls_MenuFlyout_type.get())))};
    if (!MenuBarItemFlyout_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_MenuBarItemFlyout_Static{PyType_FromSpecWithBases(&type_spec_MenuBarItemFlyout_Static, MenuBarItemFlyout_Static_bases.get())};
    if (!type_MenuBarItemFlyout_Static)
    {
        return nullptr;
    }

    py::pyobj_handle MenuBarItemFlyout_bases{PyTuple_Pack(1, windows_ui_xaml_controls_MenuFlyout_type.get())};
    if (!MenuBarItemFlyout_bases)
    {
        return nullptr;
    }

    py::pytype_handle MenuBarItemFlyout_type{py::register_python_type(module.get(), &type_spec_MenuBarItemFlyout, MenuBarItemFlyout_bases.get(), reinterpret_cast<PyTypeObject*>(type_MenuBarItemFlyout_Static.get()))};
    if (!MenuBarItemFlyout_type)
    {
        return nullptr;
    }

    py::pyobj_handle NavigationView_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(windows_ui_xaml_controls_ContentControl_type.get())))};
    if (!NavigationView_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_NavigationView_Static{PyType_FromSpecWithBases(&type_spec_NavigationView_Static, NavigationView_Static_bases.get())};
    if (!type_NavigationView_Static)
    {
        return nullptr;
    }

    py::pyobj_handle NavigationView_bases{PyTuple_Pack(1, windows_ui_xaml_controls_ContentControl_type.get())};
    if (!NavigationView_bases)
    {
        return nullptr;
    }

    py::pytype_handle NavigationView_type{py::register_python_type(module.get(), &type_spec_NavigationView, NavigationView_bases.get(), reinterpret_cast<PyTypeObject*>(type_NavigationView_Static.get()))};
    if (!NavigationView_type)
    {
        return nullptr;
    }

    py::pytype_handle NavigationViewBackRequestedEventArgs_type{py::register_python_type(module.get(), &type_spec_NavigationViewBackRequestedEventArgs, object_bases.get(), inspectable_meta_type)};
    if (!NavigationViewBackRequestedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle NavigationViewDisplayModeChangedEventArgs_type{py::register_python_type(module.get(), &type_spec_NavigationViewDisplayModeChangedEventArgs, object_bases.get(), inspectable_meta_type)};
    if (!NavigationViewDisplayModeChangedEventArgs_type)
    {
        return nullptr;
    }

    py::pyobj_handle NavigationViewItemBase_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(windows_ui_xaml_controls_ContentControl_type.get())))};
    if (!NavigationViewItemBase_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_NavigationViewItemBase_Static{PyType_FromSpecWithBases(&type_spec_NavigationViewItemBase_Static, NavigationViewItemBase_Static_bases.get())};
    if (!type_NavigationViewItemBase_Static)
    {
        return nullptr;
    }

    py::pyobj_handle NavigationViewItemBase_bases{PyTuple_Pack(1, windows_ui_xaml_controls_ContentControl_type.get())};
    if (!NavigationViewItemBase_bases)
    {
        return nullptr;
    }

    py::pytype_handle NavigationViewItemBase_type{py::register_python_type(module.get(), &type_spec_NavigationViewItemBase, NavigationViewItemBase_bases.get(), reinterpret_cast<PyTypeObject*>(type_NavigationViewItemBase_Static.get()))};
    if (!NavigationViewItemBase_type)
    {
        return nullptr;
    }

    py::pyobj_handle NavigationViewItem_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(NavigationViewItemBase_type.get())))};
    if (!NavigationViewItem_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_NavigationViewItem_Static{PyType_FromSpecWithBases(&type_spec_NavigationViewItem_Static, NavigationViewItem_Static_bases.get())};
    if (!type_NavigationViewItem_Static)
    {
        return nullptr;
    }

    py::pyobj_handle NavigationViewItem_bases{PyTuple_Pack(1, NavigationViewItemBase_type.get())};
    if (!NavigationViewItem_bases)
    {
        return nullptr;
    }

    py::pytype_handle NavigationViewItem_type{py::register_python_type(module.get(), &type_spec_NavigationViewItem, NavigationViewItem_bases.get(), reinterpret_cast<PyTypeObject*>(type_NavigationViewItem_Static.get()))};
    if (!NavigationViewItem_type)
    {
        return nullptr;
    }

    py::pytype_handle NavigationViewItemCollapsedEventArgs_type{py::register_python_type(module.get(), &type_spec_NavigationViewItemCollapsedEventArgs, object_bases.get(), inspectable_meta_type)};
    if (!NavigationViewItemCollapsedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle NavigationViewItemExpandingEventArgs_type{py::register_python_type(module.get(), &type_spec_NavigationViewItemExpandingEventArgs, object_bases.get(), inspectable_meta_type)};
    if (!NavigationViewItemExpandingEventArgs_type)
    {
        return nullptr;
    }

    py::pyobj_handle NavigationViewItemHeader_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(NavigationViewItemBase_type.get())))};
    if (!NavigationViewItemHeader_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_NavigationViewItemHeader_Static{PyType_FromSpecWithBases(&type_spec_NavigationViewItemHeader_Static, NavigationViewItemHeader_Static_bases.get())};
    if (!type_NavigationViewItemHeader_Static)
    {
        return nullptr;
    }

    py::pyobj_handle NavigationViewItemHeader_bases{PyTuple_Pack(1, NavigationViewItemBase_type.get())};
    if (!NavigationViewItemHeader_bases)
    {
        return nullptr;
    }

    py::pytype_handle NavigationViewItemHeader_type{py::register_python_type(module.get(), &type_spec_NavigationViewItemHeader, NavigationViewItemHeader_bases.get(), reinterpret_cast<PyTypeObject*>(type_NavigationViewItemHeader_Static.get()))};
    if (!NavigationViewItemHeader_type)
    {
        return nullptr;
    }

    py::pytype_handle NavigationViewItemInvokedEventArgs_type{py::register_python_type(module.get(), &type_spec_NavigationViewItemInvokedEventArgs, object_bases.get(), inspectable_meta_type)};
    if (!NavigationViewItemInvokedEventArgs_type)
    {
        return nullptr;
    }

    py::pyobj_handle NavigationViewItemSeparator_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(NavigationViewItemBase_type.get())))};
    if (!NavigationViewItemSeparator_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_NavigationViewItemSeparator_Static{PyType_FromSpecWithBases(&type_spec_NavigationViewItemSeparator_Static, NavigationViewItemSeparator_Static_bases.get())};
    if (!type_NavigationViewItemSeparator_Static)
    {
        return nullptr;
    }

    py::pyobj_handle NavigationViewItemSeparator_bases{PyTuple_Pack(1, NavigationViewItemBase_type.get())};
    if (!NavigationViewItemSeparator_bases)
    {
        return nullptr;
    }

    py::pytype_handle NavigationViewItemSeparator_type{py::register_python_type(module.get(), &type_spec_NavigationViewItemSeparator, NavigationViewItemSeparator_bases.get(), reinterpret_cast<PyTypeObject*>(type_NavigationViewItemSeparator_Static.get()))};
    if (!NavigationViewItemSeparator_type)
    {
        return nullptr;
    }

    py::pytype_handle NavigationViewPaneClosingEventArgs_type{py::register_python_type(module.get(), &type_spec_NavigationViewPaneClosingEventArgs, object_bases.get(), inspectable_meta_type)};
    if (!NavigationViewPaneClosingEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle NavigationViewSelectionChangedEventArgs_type{py::register_python_type(module.get(), &type_spec_NavigationViewSelectionChangedEventArgs, object_bases.get(), inspectable_meta_type)};
    if (!NavigationViewSelectionChangedEventArgs_type)
    {
        return nullptr;
    }

    py::pyobj_handle NavigationViewTemplateSettings_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(windows_ui_xaml_DependencyObject_type.get())))};
    if (!NavigationViewTemplateSettings_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_NavigationViewTemplateSettings_Static{PyType_FromSpecWithBases(&type_spec_NavigationViewTemplateSettings_Static, NavigationViewTemplateSettings_Static_bases.get())};
    if (!type_NavigationViewTemplateSettings_Static)
    {
        return nullptr;
    }

    py::pyobj_handle NavigationViewTemplateSettings_bases{PyTuple_Pack(1, windows_ui_xaml_DependencyObject_type.get())};
    if (!NavigationViewTemplateSettings_bases)
    {
        return nullptr;
    }

    py::pytype_handle NavigationViewTemplateSettings_type{py::register_python_type(module.get(), &type_spec_NavigationViewTemplateSettings, NavigationViewTemplateSettings_bases.get(), reinterpret_cast<PyTypeObject*>(type_NavigationViewTemplateSettings_Static.get()))};
    if (!NavigationViewTemplateSettings_type)
    {
        return nullptr;
    }

    py::pyobj_handle NonVirtualizingLayout_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(Layout_type.get())))};
    if (!NonVirtualizingLayout_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_NonVirtualizingLayout_Static{PyType_FromSpecWithBases(&type_spec_NonVirtualizingLayout_Static, NonVirtualizingLayout_Static_bases.get())};
    if (!type_NonVirtualizingLayout_Static)
    {
        return nullptr;
    }

    py::pyobj_handle NonVirtualizingLayout_bases{PyTuple_Pack(1, Layout_type.get())};
    if (!NonVirtualizingLayout_bases)
    {
        return nullptr;
    }

    py::pytype_handle NonVirtualizingLayout_type{py::register_python_type(module.get(), &type_spec_NonVirtualizingLayout, NonVirtualizingLayout_bases.get(), reinterpret_cast<PyTypeObject*>(type_NonVirtualizingLayout_Static.get()))};
    if (!NonVirtualizingLayout_type)
    {
        return nullptr;
    }

    py::pyobj_handle NonVirtualizingLayoutContext_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(LayoutContext_type.get())))};
    if (!NonVirtualizingLayoutContext_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_NonVirtualizingLayoutContext_Static{PyType_FromSpecWithBases(&type_spec_NonVirtualizingLayoutContext_Static, NonVirtualizingLayoutContext_Static_bases.get())};
    if (!type_NonVirtualizingLayoutContext_Static)
    {
        return nullptr;
    }

    py::pyobj_handle NonVirtualizingLayoutContext_bases{PyTuple_Pack(1, LayoutContext_type.get())};
    if (!NonVirtualizingLayoutContext_bases)
    {
        return nullptr;
    }

    py::pytype_handle NonVirtualizingLayoutContext_type{py::register_python_type(module.get(), &type_spec_NonVirtualizingLayoutContext, NonVirtualizingLayoutContext_bases.get(), reinterpret_cast<PyTypeObject*>(type_NonVirtualizingLayoutContext_Static.get()))};
    if (!NonVirtualizingLayoutContext_type)
    {
        return nullptr;
    }

    py::pyobj_handle NumberBox_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(windows_ui_xaml_controls_Control_type.get())))};
    if (!NumberBox_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_NumberBox_Static{PyType_FromSpecWithBases(&type_spec_NumberBox_Static, NumberBox_Static_bases.get())};
    if (!type_NumberBox_Static)
    {
        return nullptr;
    }

    py::pyobj_handle NumberBox_bases{PyTuple_Pack(1, windows_ui_xaml_controls_Control_type.get())};
    if (!NumberBox_bases)
    {
        return nullptr;
    }

    py::pytype_handle NumberBox_type{py::register_python_type(module.get(), &type_spec_NumberBox, NumberBox_bases.get(), reinterpret_cast<PyTypeObject*>(type_NumberBox_Static.get()))};
    if (!NumberBox_type)
    {
        return nullptr;
    }

    py::pytype_handle NumberBoxValueChangedEventArgs_type{py::register_python_type(module.get(), &type_spec_NumberBoxValueChangedEventArgs, object_bases.get(), inspectable_meta_type)};
    if (!NumberBoxValueChangedEventArgs_type)
    {
        return nullptr;
    }

    py::pyobj_handle ParallaxView_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(windows_ui_xaml_FrameworkElement_type.get())))};
    if (!ParallaxView_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_ParallaxView_Static{PyType_FromSpecWithBases(&type_spec_ParallaxView_Static, ParallaxView_Static_bases.get())};
    if (!type_ParallaxView_Static)
    {
        return nullptr;
    }

    py::pyobj_handle ParallaxView_bases{PyTuple_Pack(1, windows_ui_xaml_FrameworkElement_type.get())};
    if (!ParallaxView_bases)
    {
        return nullptr;
    }

    py::pytype_handle ParallaxView_type{py::register_python_type(module.get(), &type_spec_ParallaxView, ParallaxView_bases.get(), reinterpret_cast<PyTypeObject*>(type_ParallaxView_Static.get()))};
    if (!ParallaxView_type)
    {
        return nullptr;
    }

    py::pyobj_handle PathIconSource_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(IconSource_type.get())))};
    if (!PathIconSource_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_PathIconSource_Static{PyType_FromSpecWithBases(&type_spec_PathIconSource_Static, PathIconSource_Static_bases.get())};
    if (!type_PathIconSource_Static)
    {
        return nullptr;
    }

    py::pyobj_handle PathIconSource_bases{PyTuple_Pack(1, IconSource_type.get())};
    if (!PathIconSource_bases)
    {
        return nullptr;
    }

    py::pytype_handle PathIconSource_type{py::register_python_type(module.get(), &type_spec_PathIconSource, PathIconSource_bases.get(), reinterpret_cast<PyTypeObject*>(type_PathIconSource_Static.get()))};
    if (!PathIconSource_type)
    {
        return nullptr;
    }

    py::pyobj_handle PersonPicture_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(windows_ui_xaml_controls_Control_type.get())))};
    if (!PersonPicture_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_PersonPicture_Static{PyType_FromSpecWithBases(&type_spec_PersonPicture_Static, PersonPicture_Static_bases.get())};
    if (!type_PersonPicture_Static)
    {
        return nullptr;
    }

    py::pyobj_handle PersonPicture_bases{PyTuple_Pack(1, windows_ui_xaml_controls_Control_type.get())};
    if (!PersonPicture_bases)
    {
        return nullptr;
    }

    py::pytype_handle PersonPicture_type{py::register_python_type(module.get(), &type_spec_PersonPicture, PersonPicture_bases.get(), reinterpret_cast<PyTypeObject*>(type_PersonPicture_Static.get()))};
    if (!PersonPicture_type)
    {
        return nullptr;
    }

    py::pyobj_handle PersonPictureTemplateSettings_bases{PyTuple_Pack(1, windows_ui_xaml_DependencyObject_type.get())};
    if (!PersonPictureTemplateSettings_bases)
    {
        return nullptr;
    }

    py::pytype_handle PersonPictureTemplateSettings_type{py::register_python_type(module.get(), &type_spec_PersonPictureTemplateSettings, PersonPictureTemplateSettings_bases.get(), inspectable_meta_type)};
    if (!PersonPictureTemplateSettings_type)
    {
        return nullptr;
    }

    py::pyobj_handle PipsPager_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(windows_ui_xaml_controls_Control_type.get())))};
    if (!PipsPager_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_PipsPager_Static{PyType_FromSpecWithBases(&type_spec_PipsPager_Static, PipsPager_Static_bases.get())};
    if (!type_PipsPager_Static)
    {
        return nullptr;
    }

    py::pyobj_handle PipsPager_bases{PyTuple_Pack(1, windows_ui_xaml_controls_Control_type.get())};
    if (!PipsPager_bases)
    {
        return nullptr;
    }

    py::pytype_handle PipsPager_type{py::register_python_type(module.get(), &type_spec_PipsPager, PipsPager_bases.get(), reinterpret_cast<PyTypeObject*>(type_PipsPager_Static.get()))};
    if (!PipsPager_type)
    {
        return nullptr;
    }

    py::pytype_handle PipsPagerSelectedIndexChangedEventArgs_type{py::register_python_type(module.get(), &type_spec_PipsPagerSelectedIndexChangedEventArgs, object_bases.get(), inspectable_meta_type)};
    if (!PipsPagerSelectedIndexChangedEventArgs_type)
    {
        return nullptr;
    }

    py::pyobj_handle PipsPagerTemplateSettings_bases{PyTuple_Pack(1, windows_ui_xaml_DependencyObject_type.get())};
    if (!PipsPagerTemplateSettings_bases)
    {
        return nullptr;
    }

    py::pytype_handle PipsPagerTemplateSettings_type{py::register_python_type(module.get(), &type_spec_PipsPagerTemplateSettings, PipsPagerTemplateSettings_bases.get(), inspectable_meta_type)};
    if (!PipsPagerTemplateSettings_type)
    {
        return nullptr;
    }

    py::pyobj_handle ProgressBar_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(windows_ui_xaml_controls_primitives_RangeBase_type.get())))};
    if (!ProgressBar_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_ProgressBar_Static{PyType_FromSpecWithBases(&type_spec_ProgressBar_Static, ProgressBar_Static_bases.get())};
    if (!type_ProgressBar_Static)
    {
        return nullptr;
    }

    py::pyobj_handle ProgressBar_bases{PyTuple_Pack(1, windows_ui_xaml_controls_primitives_RangeBase_type.get())};
    if (!ProgressBar_bases)
    {
        return nullptr;
    }

    py::pytype_handle ProgressBar_type{py::register_python_type(module.get(), &type_spec_ProgressBar, ProgressBar_bases.get(), reinterpret_cast<PyTypeObject*>(type_ProgressBar_Static.get()))};
    if (!ProgressBar_type)
    {
        return nullptr;
    }

    py::pyobj_handle ProgressBarTemplateSettings_bases{PyTuple_Pack(1, windows_ui_xaml_DependencyObject_type.get())};
    if (!ProgressBarTemplateSettings_bases)
    {
        return nullptr;
    }

    py::pytype_handle ProgressBarTemplateSettings_type{py::register_python_type(module.get(), &type_spec_ProgressBarTemplateSettings, ProgressBarTemplateSettings_bases.get(), inspectable_meta_type)};
    if (!ProgressBarTemplateSettings_type)
    {
        return nullptr;
    }

    py::pyobj_handle ProgressRing_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(windows_ui_xaml_controls_Control_type.get())))};
    if (!ProgressRing_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_ProgressRing_Static{PyType_FromSpecWithBases(&type_spec_ProgressRing_Static, ProgressRing_Static_bases.get())};
    if (!type_ProgressRing_Static)
    {
        return nullptr;
    }

    py::pyobj_handle ProgressRing_bases{PyTuple_Pack(1, windows_ui_xaml_controls_Control_type.get())};
    if (!ProgressRing_bases)
    {
        return nullptr;
    }

    py::pytype_handle ProgressRing_type{py::register_python_type(module.get(), &type_spec_ProgressRing, ProgressRing_bases.get(), reinterpret_cast<PyTypeObject*>(type_ProgressRing_Static.get()))};
    if (!ProgressRing_type)
    {
        return nullptr;
    }

    py::pyobj_handle ProgressRingTemplateSettings_bases{PyTuple_Pack(1, windows_ui_xaml_DependencyObject_type.get())};
    if (!ProgressRingTemplateSettings_bases)
    {
        return nullptr;
    }

    py::pytype_handle ProgressRingTemplateSettings_type{py::register_python_type(module.get(), &type_spec_ProgressRingTemplateSettings, ProgressRingTemplateSettings_bases.get(), inspectable_meta_type)};
    if (!ProgressRingTemplateSettings_type)
    {
        return nullptr;
    }

    py::pyobj_handle RadioButtons_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(windows_ui_xaml_controls_Control_type.get())))};
    if (!RadioButtons_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_RadioButtons_Static{PyType_FromSpecWithBases(&type_spec_RadioButtons_Static, RadioButtons_Static_bases.get())};
    if (!type_RadioButtons_Static)
    {
        return nullptr;
    }

    py::pyobj_handle RadioButtons_bases{PyTuple_Pack(1, windows_ui_xaml_controls_Control_type.get())};
    if (!RadioButtons_bases)
    {
        return nullptr;
    }

    py::pytype_handle RadioButtons_type{py::register_python_type(module.get(), &type_spec_RadioButtons, RadioButtons_bases.get(), reinterpret_cast<PyTypeObject*>(type_RadioButtons_Static.get()))};
    if (!RadioButtons_type)
    {
        return nullptr;
    }

    py::pyobj_handle RadioMenuFlyoutItem_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(windows_ui_xaml_controls_MenuFlyoutItem_type.get())))};
    if (!RadioMenuFlyoutItem_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_RadioMenuFlyoutItem_Static{PyType_FromSpecWithBases(&type_spec_RadioMenuFlyoutItem_Static, RadioMenuFlyoutItem_Static_bases.get())};
    if (!type_RadioMenuFlyoutItem_Static)
    {
        return nullptr;
    }

    py::pyobj_handle RadioMenuFlyoutItem_bases{PyTuple_Pack(1, windows_ui_xaml_controls_MenuFlyoutItem_type.get())};
    if (!RadioMenuFlyoutItem_bases)
    {
        return nullptr;
    }

    py::pytype_handle RadioMenuFlyoutItem_type{py::register_python_type(module.get(), &type_spec_RadioMenuFlyoutItem, RadioMenuFlyoutItem_bases.get(), reinterpret_cast<PyTypeObject*>(type_RadioMenuFlyoutItem_Static.get()))};
    if (!RadioMenuFlyoutItem_type)
    {
        return nullptr;
    }

    py::pyobj_handle RatingControl_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(windows_ui_xaml_controls_Control_type.get())))};
    if (!RatingControl_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_RatingControl_Static{PyType_FromSpecWithBases(&type_spec_RatingControl_Static, RatingControl_Static_bases.get())};
    if (!type_RatingControl_Static)
    {
        return nullptr;
    }

    py::pyobj_handle RatingControl_bases{PyTuple_Pack(1, windows_ui_xaml_controls_Control_type.get())};
    if (!RatingControl_bases)
    {
        return nullptr;
    }

    py::pytype_handle RatingControl_type{py::register_python_type(module.get(), &type_spec_RatingControl, RatingControl_bases.get(), reinterpret_cast<PyTypeObject*>(type_RatingControl_Static.get()))};
    if (!RatingControl_type)
    {
        return nullptr;
    }

    py::pyobj_handle RatingItemInfo_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(windows_ui_xaml_DependencyObject_type.get())))};
    if (!RatingItemInfo_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_RatingItemInfo_Static{PyType_FromSpecWithBases(&type_spec_RatingItemInfo_Static, RatingItemInfo_Static_bases.get())};
    if (!type_RatingItemInfo_Static)
    {
        return nullptr;
    }

    py::pyobj_handle RatingItemInfo_bases{PyTuple_Pack(1, windows_ui_xaml_DependencyObject_type.get())};
    if (!RatingItemInfo_bases)
    {
        return nullptr;
    }

    py::pytype_handle RatingItemInfo_type{py::register_python_type(module.get(), &type_spec_RatingItemInfo, RatingItemInfo_bases.get(), reinterpret_cast<PyTypeObject*>(type_RatingItemInfo_Static.get()))};
    if (!RatingItemInfo_type)
    {
        return nullptr;
    }

    py::pyobj_handle RatingItemFontInfo_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(RatingItemInfo_type.get())))};
    if (!RatingItemFontInfo_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_RatingItemFontInfo_Static{PyType_FromSpecWithBases(&type_spec_RatingItemFontInfo_Static, RatingItemFontInfo_Static_bases.get())};
    if (!type_RatingItemFontInfo_Static)
    {
        return nullptr;
    }

    py::pyobj_handle RatingItemFontInfo_bases{PyTuple_Pack(1, RatingItemInfo_type.get())};
    if (!RatingItemFontInfo_bases)
    {
        return nullptr;
    }

    py::pytype_handle RatingItemFontInfo_type{py::register_python_type(module.get(), &type_spec_RatingItemFontInfo, RatingItemFontInfo_bases.get(), reinterpret_cast<PyTypeObject*>(type_RatingItemFontInfo_Static.get()))};
    if (!RatingItemFontInfo_type)
    {
        return nullptr;
    }

    py::pyobj_handle RatingItemImageInfo_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(RatingItemInfo_type.get())))};
    if (!RatingItemImageInfo_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_RatingItemImageInfo_Static{PyType_FromSpecWithBases(&type_spec_RatingItemImageInfo_Static, RatingItemImageInfo_Static_bases.get())};
    if (!type_RatingItemImageInfo_Static)
    {
        return nullptr;
    }

    py::pyobj_handle RatingItemImageInfo_bases{PyTuple_Pack(1, RatingItemInfo_type.get())};
    if (!RatingItemImageInfo_bases)
    {
        return nullptr;
    }

    py::pytype_handle RatingItemImageInfo_type{py::register_python_type(module.get(), &type_spec_RatingItemImageInfo, RatingItemImageInfo_bases.get(), reinterpret_cast<PyTypeObject*>(type_RatingItemImageInfo_Static.get()))};
    if (!RatingItemImageInfo_type)
    {
        return nullptr;
    }

    py::pyobj_handle RefreshContainer_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(windows_ui_xaml_controls_ContentControl_type.get())))};
    if (!RefreshContainer_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_RefreshContainer_Static{PyType_FromSpecWithBases(&type_spec_RefreshContainer_Static, RefreshContainer_Static_bases.get())};
    if (!type_RefreshContainer_Static)
    {
        return nullptr;
    }

    py::pyobj_handle RefreshContainer_bases{PyTuple_Pack(1, windows_ui_xaml_controls_ContentControl_type.get())};
    if (!RefreshContainer_bases)
    {
        return nullptr;
    }

    py::pytype_handle RefreshContainer_type{py::register_python_type(module.get(), &type_spec_RefreshContainer, RefreshContainer_bases.get(), reinterpret_cast<PyTypeObject*>(type_RefreshContainer_Static.get()))};
    if (!RefreshContainer_type)
    {
        return nullptr;
    }

    py::pytype_handle RefreshInteractionRatioChangedEventArgs_type{py::register_python_type(module.get(), &type_spec_RefreshInteractionRatioChangedEventArgs, object_bases.get(), inspectable_meta_type)};
    if (!RefreshInteractionRatioChangedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle RefreshRequestedEventArgs_type{py::register_python_type(module.get(), &type_spec_RefreshRequestedEventArgs, object_bases.get(), inspectable_meta_type)};
    if (!RefreshRequestedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle RefreshStateChangedEventArgs_type{py::register_python_type(module.get(), &type_spec_RefreshStateChangedEventArgs, object_bases.get(), inspectable_meta_type)};
    if (!RefreshStateChangedEventArgs_type)
    {
        return nullptr;
    }

    py::pyobj_handle RefreshVisualizer_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(windows_ui_xaml_controls_Control_type.get())))};
    if (!RefreshVisualizer_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_RefreshVisualizer_Static{PyType_FromSpecWithBases(&type_spec_RefreshVisualizer_Static, RefreshVisualizer_Static_bases.get())};
    if (!type_RefreshVisualizer_Static)
    {
        return nullptr;
    }

    py::pyobj_handle RefreshVisualizer_bases{PyTuple_Pack(1, windows_ui_xaml_controls_Control_type.get())};
    if (!RefreshVisualizer_bases)
    {
        return nullptr;
    }

    py::pytype_handle RefreshVisualizer_type{py::register_python_type(module.get(), &type_spec_RefreshVisualizer, RefreshVisualizer_bases.get(), reinterpret_cast<PyTypeObject*>(type_RefreshVisualizer_Static.get()))};
    if (!RefreshVisualizer_type)
    {
        return nullptr;
    }

    py::pyobj_handle RevealListViewItemPresenter_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(windows_ui_xaml_controls_primitives_ListViewItemPresenter_type.get())))};
    if (!RevealListViewItemPresenter_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_RevealListViewItemPresenter_Static{PyType_FromSpecWithBases(&type_spec_RevealListViewItemPresenter_Static, RevealListViewItemPresenter_Static_bases.get())};
    if (!type_RevealListViewItemPresenter_Static)
    {
        return nullptr;
    }

    py::pyobj_handle RevealListViewItemPresenter_bases{PyTuple_Pack(1, windows_ui_xaml_controls_primitives_ListViewItemPresenter_type.get())};
    if (!RevealListViewItemPresenter_bases)
    {
        return nullptr;
    }

    py::pytype_handle RevealListViewItemPresenter_type{py::register_python_type(module.get(), &type_spec_RevealListViewItemPresenter, RevealListViewItemPresenter_bases.get(), reinterpret_cast<PyTypeObject*>(type_RevealListViewItemPresenter_Static.get()))};
    if (!RevealListViewItemPresenter_type)
    {
        return nullptr;
    }

    py::pyobj_handle SplitButton_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(windows_ui_xaml_controls_ContentControl_type.get())))};
    if (!SplitButton_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_SplitButton_Static{PyType_FromSpecWithBases(&type_spec_SplitButton_Static, SplitButton_Static_bases.get())};
    if (!type_SplitButton_Static)
    {
        return nullptr;
    }

    py::pyobj_handle SplitButton_bases{PyTuple_Pack(1, windows_ui_xaml_controls_ContentControl_type.get())};
    if (!SplitButton_bases)
    {
        return nullptr;
    }

    py::pytype_handle SplitButton_type{py::register_python_type(module.get(), &type_spec_SplitButton, SplitButton_bases.get(), reinterpret_cast<PyTypeObject*>(type_SplitButton_Static.get()))};
    if (!SplitButton_type)
    {
        return nullptr;
    }

    py::pytype_handle SplitButtonClickEventArgs_type{py::register_python_type(module.get(), &type_spec_SplitButtonClickEventArgs, object_bases.get(), inspectable_meta_type)};
    if (!SplitButtonClickEventArgs_type)
    {
        return nullptr;
    }

    py::pyobj_handle VirtualizingLayout_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(Layout_type.get())))};
    if (!VirtualizingLayout_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_VirtualizingLayout_Static{PyType_FromSpecWithBases(&type_spec_VirtualizingLayout_Static, VirtualizingLayout_Static_bases.get())};
    if (!type_VirtualizingLayout_Static)
    {
        return nullptr;
    }

    py::pyobj_handle VirtualizingLayout_bases{PyTuple_Pack(1, Layout_type.get())};
    if (!VirtualizingLayout_bases)
    {
        return nullptr;
    }

    py::pytype_handle VirtualizingLayout_type{py::register_python_type(module.get(), &type_spec_VirtualizingLayout, VirtualizingLayout_bases.get(), reinterpret_cast<PyTypeObject*>(type_VirtualizingLayout_Static.get()))};
    if (!VirtualizingLayout_type)
    {
        return nullptr;
    }

    py::pyobj_handle StackLayout_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(VirtualizingLayout_type.get())))};
    if (!StackLayout_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_StackLayout_Static{PyType_FromSpecWithBases(&type_spec_StackLayout_Static, StackLayout_Static_bases.get())};
    if (!type_StackLayout_Static)
    {
        return nullptr;
    }

    py::pyobj_handle StackLayout_bases{PyTuple_Pack(1, VirtualizingLayout_type.get())};
    if (!StackLayout_bases)
    {
        return nullptr;
    }

    py::pytype_handle StackLayout_type{py::register_python_type(module.get(), &type_spec_StackLayout, StackLayout_bases.get(), reinterpret_cast<PyTypeObject*>(type_StackLayout_Static.get()))};
    if (!StackLayout_type)
    {
        return nullptr;
    }

    py::pyobj_handle SwipeControl_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(windows_ui_xaml_controls_ContentControl_type.get())))};
    if (!SwipeControl_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_SwipeControl_Static{PyType_FromSpecWithBases(&type_spec_SwipeControl_Static, SwipeControl_Static_bases.get())};
    if (!type_SwipeControl_Static)
    {
        return nullptr;
    }

    py::pyobj_handle SwipeControl_bases{PyTuple_Pack(1, windows_ui_xaml_controls_ContentControl_type.get())};
    if (!SwipeControl_bases)
    {
        return nullptr;
    }

    py::pytype_handle SwipeControl_type{py::register_python_type(module.get(), &type_spec_SwipeControl, SwipeControl_bases.get(), reinterpret_cast<PyTypeObject*>(type_SwipeControl_Static.get()))};
    if (!SwipeControl_type)
    {
        return nullptr;
    }

    py::pyobj_handle SwipeItem_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(windows_ui_xaml_DependencyObject_type.get())))};
    if (!SwipeItem_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_SwipeItem_Static{PyType_FromSpecWithBases(&type_spec_SwipeItem_Static, SwipeItem_Static_bases.get())};
    if (!type_SwipeItem_Static)
    {
        return nullptr;
    }

    py::pyobj_handle SwipeItem_bases{PyTuple_Pack(1, windows_ui_xaml_DependencyObject_type.get())};
    if (!SwipeItem_bases)
    {
        return nullptr;
    }

    py::pytype_handle SwipeItem_type{py::register_python_type(module.get(), &type_spec_SwipeItem, SwipeItem_bases.get(), reinterpret_cast<PyTypeObject*>(type_SwipeItem_Static.get()))};
    if (!SwipeItem_type)
    {
        return nullptr;
    }

    py::pytype_handle SwipeItemInvokedEventArgs_type{py::register_python_type(module.get(), &type_spec_SwipeItemInvokedEventArgs, object_bases.get(), inspectable_meta_type)};
    if (!SwipeItemInvokedEventArgs_type)
    {
        return nullptr;
    }

    py::pyobj_handle SwipeItems_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(windows_ui_xaml_DependencyObject_type.get())))};
    if (!SwipeItems_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_SwipeItems_Static{PyType_FromSpecWithBases(&type_spec_SwipeItems_Static, SwipeItems_Static_bases.get())};
    if (!type_SwipeItems_Static)
    {
        return nullptr;
    }

    py::pyobj_handle SwipeItems_bases{PyTuple_Pack(1, windows_ui_xaml_DependencyObject_type.get())};
    if (!SwipeItems_bases)
    {
        return nullptr;
    }

    py::pytype_handle SwipeItems_type{py::register_python_type(module.get(), &type_spec_SwipeItems, SwipeItems_bases.get(), reinterpret_cast<PyTypeObject*>(type_SwipeItems_Static.get()))};
    if (!SwipeItems_type)
    {
        return nullptr;
    }

    py::pyobj_handle SymbolIconSource_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(IconSource_type.get())))};
    if (!SymbolIconSource_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_SymbolIconSource_Static{PyType_FromSpecWithBases(&type_spec_SymbolIconSource_Static, SymbolIconSource_Static_bases.get())};
    if (!type_SymbolIconSource_Static)
    {
        return nullptr;
    }

    py::pyobj_handle SymbolIconSource_bases{PyTuple_Pack(1, IconSource_type.get())};
    if (!SymbolIconSource_bases)
    {
        return nullptr;
    }

    py::pytype_handle SymbolIconSource_type{py::register_python_type(module.get(), &type_spec_SymbolIconSource, SymbolIconSource_bases.get(), reinterpret_cast<PyTypeObject*>(type_SymbolIconSource_Static.get()))};
    if (!SymbolIconSource_type)
    {
        return nullptr;
    }

    py::pyobj_handle TabView_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(windows_ui_xaml_controls_Control_type.get())))};
    if (!TabView_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_TabView_Static{PyType_FromSpecWithBases(&type_spec_TabView_Static, TabView_Static_bases.get())};
    if (!type_TabView_Static)
    {
        return nullptr;
    }

    py::pyobj_handle TabView_bases{PyTuple_Pack(1, windows_ui_xaml_controls_Control_type.get())};
    if (!TabView_bases)
    {
        return nullptr;
    }

    py::pytype_handle TabView_type{py::register_python_type(module.get(), &type_spec_TabView, TabView_bases.get(), reinterpret_cast<PyTypeObject*>(type_TabView_Static.get()))};
    if (!TabView_type)
    {
        return nullptr;
    }

    py::pyobj_handle TabViewItem_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(windows_ui_xaml_controls_ListViewItem_type.get())))};
    if (!TabViewItem_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_TabViewItem_Static{PyType_FromSpecWithBases(&type_spec_TabViewItem_Static, TabViewItem_Static_bases.get())};
    if (!type_TabViewItem_Static)
    {
        return nullptr;
    }

    py::pyobj_handle TabViewItem_bases{PyTuple_Pack(1, windows_ui_xaml_controls_ListViewItem_type.get())};
    if (!TabViewItem_bases)
    {
        return nullptr;
    }

    py::pytype_handle TabViewItem_type{py::register_python_type(module.get(), &type_spec_TabViewItem, TabViewItem_bases.get(), reinterpret_cast<PyTypeObject*>(type_TabViewItem_Static.get()))};
    if (!TabViewItem_type)
    {
        return nullptr;
    }

    py::pyobj_handle TabViewItemTemplateSettings_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(windows_ui_xaml_DependencyObject_type.get())))};
    if (!TabViewItemTemplateSettings_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_TabViewItemTemplateSettings_Static{PyType_FromSpecWithBases(&type_spec_TabViewItemTemplateSettings_Static, TabViewItemTemplateSettings_Static_bases.get())};
    if (!type_TabViewItemTemplateSettings_Static)
    {
        return nullptr;
    }

    py::pyobj_handle TabViewItemTemplateSettings_bases{PyTuple_Pack(1, windows_ui_xaml_DependencyObject_type.get())};
    if (!TabViewItemTemplateSettings_bases)
    {
        return nullptr;
    }

    py::pytype_handle TabViewItemTemplateSettings_type{py::register_python_type(module.get(), &type_spec_TabViewItemTemplateSettings, TabViewItemTemplateSettings_bases.get(), reinterpret_cast<PyTypeObject*>(type_TabViewItemTemplateSettings_Static.get()))};
    if (!TabViewItemTemplateSettings_type)
    {
        return nullptr;
    }

    py::pytype_handle TabViewTabCloseRequestedEventArgs_type{py::register_python_type(module.get(), &type_spec_TabViewTabCloseRequestedEventArgs, object_bases.get(), inspectable_meta_type)};
    if (!TabViewTabCloseRequestedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle TabViewTabDragCompletedEventArgs_type{py::register_python_type(module.get(), &type_spec_TabViewTabDragCompletedEventArgs, object_bases.get(), inspectable_meta_type)};
    if (!TabViewTabDragCompletedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle TabViewTabDragStartingEventArgs_type{py::register_python_type(module.get(), &type_spec_TabViewTabDragStartingEventArgs, object_bases.get(), inspectable_meta_type)};
    if (!TabViewTabDragStartingEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle TabViewTabDroppedOutsideEventArgs_type{py::register_python_type(module.get(), &type_spec_TabViewTabDroppedOutsideEventArgs, object_bases.get(), inspectable_meta_type)};
    if (!TabViewTabDroppedOutsideEventArgs_type)
    {
        return nullptr;
    }

    py::pyobj_handle TeachingTip_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(windows_ui_xaml_controls_ContentControl_type.get())))};
    if (!TeachingTip_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_TeachingTip_Static{PyType_FromSpecWithBases(&type_spec_TeachingTip_Static, TeachingTip_Static_bases.get())};
    if (!type_TeachingTip_Static)
    {
        return nullptr;
    }

    py::pyobj_handle TeachingTip_bases{PyTuple_Pack(1, windows_ui_xaml_controls_ContentControl_type.get())};
    if (!TeachingTip_bases)
    {
        return nullptr;
    }

    py::pytype_handle TeachingTip_type{py::register_python_type(module.get(), &type_spec_TeachingTip, TeachingTip_bases.get(), reinterpret_cast<PyTypeObject*>(type_TeachingTip_Static.get()))};
    if (!TeachingTip_type)
    {
        return nullptr;
    }

    py::pytype_handle TeachingTipClosedEventArgs_type{py::register_python_type(module.get(), &type_spec_TeachingTipClosedEventArgs, object_bases.get(), inspectable_meta_type)};
    if (!TeachingTipClosedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle TeachingTipClosingEventArgs_type{py::register_python_type(module.get(), &type_spec_TeachingTipClosingEventArgs, object_bases.get(), inspectable_meta_type)};
    if (!TeachingTipClosingEventArgs_type)
    {
        return nullptr;
    }

    py::pyobj_handle TeachingTipTemplateSettings_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(windows_ui_xaml_DependencyObject_type.get())))};
    if (!TeachingTipTemplateSettings_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_TeachingTipTemplateSettings_Static{PyType_FromSpecWithBases(&type_spec_TeachingTipTemplateSettings_Static, TeachingTipTemplateSettings_Static_bases.get())};
    if (!type_TeachingTipTemplateSettings_Static)
    {
        return nullptr;
    }

    py::pyobj_handle TeachingTipTemplateSettings_bases{PyTuple_Pack(1, windows_ui_xaml_DependencyObject_type.get())};
    if (!TeachingTipTemplateSettings_bases)
    {
        return nullptr;
    }

    py::pytype_handle TeachingTipTemplateSettings_type{py::register_python_type(module.get(), &type_spec_TeachingTipTemplateSettings, TeachingTipTemplateSettings_bases.get(), reinterpret_cast<PyTypeObject*>(type_TeachingTipTemplateSettings_Static.get()))};
    if (!TeachingTipTemplateSettings_type)
    {
        return nullptr;
    }

    py::pyobj_handle TextCommandBarFlyout_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(CommandBarFlyout_type.get())))};
    if (!TextCommandBarFlyout_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_TextCommandBarFlyout_Static{PyType_FromSpecWithBases(&type_spec_TextCommandBarFlyout_Static, TextCommandBarFlyout_Static_bases.get())};
    if (!type_TextCommandBarFlyout_Static)
    {
        return nullptr;
    }

    py::pyobj_handle TextCommandBarFlyout_bases{PyTuple_Pack(1, CommandBarFlyout_type.get())};
    if (!TextCommandBarFlyout_bases)
    {
        return nullptr;
    }

    py::pytype_handle TextCommandBarFlyout_type{py::register_python_type(module.get(), &type_spec_TextCommandBarFlyout, TextCommandBarFlyout_bases.get(), reinterpret_cast<PyTypeObject*>(type_TextCommandBarFlyout_Static.get()))};
    if (!TextCommandBarFlyout_type)
    {
        return nullptr;
    }

    py::pyobj_handle ToggleSplitButton_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(SplitButton_type.get())))};
    if (!ToggleSplitButton_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_ToggleSplitButton_Static{PyType_FromSpecWithBases(&type_spec_ToggleSplitButton_Static, ToggleSplitButton_Static_bases.get())};
    if (!type_ToggleSplitButton_Static)
    {
        return nullptr;
    }

    py::pyobj_handle ToggleSplitButton_bases{PyTuple_Pack(1, SplitButton_type.get())};
    if (!ToggleSplitButton_bases)
    {
        return nullptr;
    }

    py::pytype_handle ToggleSplitButton_type{py::register_python_type(module.get(), &type_spec_ToggleSplitButton, ToggleSplitButton_bases.get(), reinterpret_cast<PyTypeObject*>(type_ToggleSplitButton_Static.get()))};
    if (!ToggleSplitButton_type)
    {
        return nullptr;
    }

    py::pytype_handle ToggleSplitButtonIsCheckedChangedEventArgs_type{py::register_python_type(module.get(), &type_spec_ToggleSplitButtonIsCheckedChangedEventArgs, object_bases.get(), inspectable_meta_type)};
    if (!ToggleSplitButtonIsCheckedChangedEventArgs_type)
    {
        return nullptr;
    }

    py::pyobj_handle TreeView_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(windows_ui_xaml_controls_Control_type.get())))};
    if (!TreeView_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_TreeView_Static{PyType_FromSpecWithBases(&type_spec_TreeView_Static, TreeView_Static_bases.get())};
    if (!type_TreeView_Static)
    {
        return nullptr;
    }

    py::pyobj_handle TreeView_bases{PyTuple_Pack(1, windows_ui_xaml_controls_Control_type.get())};
    if (!TreeView_bases)
    {
        return nullptr;
    }

    py::pytype_handle TreeView_type{py::register_python_type(module.get(), &type_spec_TreeView, TreeView_bases.get(), reinterpret_cast<PyTypeObject*>(type_TreeView_Static.get()))};
    if (!TreeView_type)
    {
        return nullptr;
    }

    py::pytype_handle TreeViewCollapsedEventArgs_type{py::register_python_type(module.get(), &type_spec_TreeViewCollapsedEventArgs, object_bases.get(), inspectable_meta_type)};
    if (!TreeViewCollapsedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle TreeViewDragItemsCompletedEventArgs_type{py::register_python_type(module.get(), &type_spec_TreeViewDragItemsCompletedEventArgs, object_bases.get(), inspectable_meta_type)};
    if (!TreeViewDragItemsCompletedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle TreeViewDragItemsStartingEventArgs_type{py::register_python_type(module.get(), &type_spec_TreeViewDragItemsStartingEventArgs, object_bases.get(), inspectable_meta_type)};
    if (!TreeViewDragItemsStartingEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle TreeViewExpandingEventArgs_type{py::register_python_type(module.get(), &type_spec_TreeViewExpandingEventArgs, object_bases.get(), inspectable_meta_type)};
    if (!TreeViewExpandingEventArgs_type)
    {
        return nullptr;
    }

    py::pyobj_handle TreeViewItem_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(windows_ui_xaml_controls_ListViewItem_type.get())))};
    if (!TreeViewItem_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_TreeViewItem_Static{PyType_FromSpecWithBases(&type_spec_TreeViewItem_Static, TreeViewItem_Static_bases.get())};
    if (!type_TreeViewItem_Static)
    {
        return nullptr;
    }

    py::pyobj_handle TreeViewItem_bases{PyTuple_Pack(1, windows_ui_xaml_controls_ListViewItem_type.get())};
    if (!TreeViewItem_bases)
    {
        return nullptr;
    }

    py::pytype_handle TreeViewItem_type{py::register_python_type(module.get(), &type_spec_TreeViewItem, TreeViewItem_bases.get(), reinterpret_cast<PyTypeObject*>(type_TreeViewItem_Static.get()))};
    if (!TreeViewItem_type)
    {
        return nullptr;
    }

    py::pytype_handle TreeViewItemInvokedEventArgs_type{py::register_python_type(module.get(), &type_spec_TreeViewItemInvokedEventArgs, object_bases.get(), inspectable_meta_type)};
    if (!TreeViewItemInvokedEventArgs_type)
    {
        return nullptr;
    }

    py::pyobj_handle TreeViewItemTemplateSettings_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(windows_ui_xaml_DependencyObject_type.get())))};
    if (!TreeViewItemTemplateSettings_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_TreeViewItemTemplateSettings_Static{PyType_FromSpecWithBases(&type_spec_TreeViewItemTemplateSettings_Static, TreeViewItemTemplateSettings_Static_bases.get())};
    if (!type_TreeViewItemTemplateSettings_Static)
    {
        return nullptr;
    }

    py::pyobj_handle TreeViewItemTemplateSettings_bases{PyTuple_Pack(1, windows_ui_xaml_DependencyObject_type.get())};
    if (!TreeViewItemTemplateSettings_bases)
    {
        return nullptr;
    }

    py::pytype_handle TreeViewItemTemplateSettings_type{py::register_python_type(module.get(), &type_spec_TreeViewItemTemplateSettings, TreeViewItemTemplateSettings_bases.get(), reinterpret_cast<PyTypeObject*>(type_TreeViewItemTemplateSettings_Static.get()))};
    if (!TreeViewItemTemplateSettings_type)
    {
        return nullptr;
    }

    py::pyobj_handle TreeViewList_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(windows_ui_xaml_controls_ListView_type.get())))};
    if (!TreeViewList_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_TreeViewList_Static{PyType_FromSpecWithBases(&type_spec_TreeViewList_Static, TreeViewList_Static_bases.get())};
    if (!type_TreeViewList_Static)
    {
        return nullptr;
    }

    py::pyobj_handle TreeViewList_bases{PyTuple_Pack(1, windows_ui_xaml_controls_ListView_type.get())};
    if (!TreeViewList_bases)
    {
        return nullptr;
    }

    py::pytype_handle TreeViewList_type{py::register_python_type(module.get(), &type_spec_TreeViewList, TreeViewList_bases.get(), reinterpret_cast<PyTypeObject*>(type_TreeViewList_Static.get()))};
    if (!TreeViewList_type)
    {
        return nullptr;
    }

    py::pyobj_handle TreeViewNode_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(windows_ui_xaml_DependencyObject_type.get())))};
    if (!TreeViewNode_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_TreeViewNode_Static{PyType_FromSpecWithBases(&type_spec_TreeViewNode_Static, TreeViewNode_Static_bases.get())};
    if (!type_TreeViewNode_Static)
    {
        return nullptr;
    }

    py::pyobj_handle TreeViewNode_bases{PyTuple_Pack(1, windows_ui_xaml_DependencyObject_type.get())};
    if (!TreeViewNode_bases)
    {
        return nullptr;
    }

    py::pytype_handle TreeViewNode_type{py::register_python_type(module.get(), &type_spec_TreeViewNode, TreeViewNode_bases.get(), reinterpret_cast<PyTypeObject*>(type_TreeViewNode_Static.get()))};
    if (!TreeViewNode_type)
    {
        return nullptr;
    }

    py::pyobj_handle TwoPaneView_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(windows_ui_xaml_controls_Control_type.get())))};
    if (!TwoPaneView_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_TwoPaneView_Static{PyType_FromSpecWithBases(&type_spec_TwoPaneView_Static, TwoPaneView_Static_bases.get())};
    if (!type_TwoPaneView_Static)
    {
        return nullptr;
    }

    py::pyobj_handle TwoPaneView_bases{PyTuple_Pack(1, windows_ui_xaml_controls_Control_type.get())};
    if (!TwoPaneView_bases)
    {
        return nullptr;
    }

    py::pytype_handle TwoPaneView_type{py::register_python_type(module.get(), &type_spec_TwoPaneView, TwoPaneView_bases.get(), reinterpret_cast<PyTypeObject*>(type_TwoPaneView_Static.get()))};
    if (!TwoPaneView_type)
    {
        return nullptr;
    }

    py::pyobj_handle UniformGridLayout_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(VirtualizingLayout_type.get())))};
    if (!UniformGridLayout_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_UniformGridLayout_Static{PyType_FromSpecWithBases(&type_spec_UniformGridLayout_Static, UniformGridLayout_Static_bases.get())};
    if (!type_UniformGridLayout_Static)
    {
        return nullptr;
    }

    py::pyobj_handle UniformGridLayout_bases{PyTuple_Pack(1, VirtualizingLayout_type.get())};
    if (!UniformGridLayout_bases)
    {
        return nullptr;
    }

    py::pytype_handle UniformGridLayout_type{py::register_python_type(module.get(), &type_spec_UniformGridLayout, UniformGridLayout_bases.get(), reinterpret_cast<PyTypeObject*>(type_UniformGridLayout_Static.get()))};
    if (!UniformGridLayout_type)
    {
        return nullptr;
    }

    py::pyobj_handle VirtualizingLayoutContext_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(LayoutContext_type.get())))};
    if (!VirtualizingLayoutContext_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_VirtualizingLayoutContext_Static{PyType_FromSpecWithBases(&type_spec_VirtualizingLayoutContext_Static, VirtualizingLayoutContext_Static_bases.get())};
    if (!type_VirtualizingLayoutContext_Static)
    {
        return nullptr;
    }

    py::pyobj_handle VirtualizingLayoutContext_bases{PyTuple_Pack(1, LayoutContext_type.get())};
    if (!VirtualizingLayoutContext_bases)
    {
        return nullptr;
    }

    py::pytype_handle VirtualizingLayoutContext_type{py::register_python_type(module.get(), &type_spec_VirtualizingLayoutContext, VirtualizingLayoutContext_bases.get(), reinterpret_cast<PyTypeObject*>(type_VirtualizingLayoutContext_Static.get()))};
    if (!VirtualizingLayoutContext_type)
    {
        return nullptr;
    }

    py::pyobj_handle WebView2_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(windows_ui_xaml_controls_Control_type.get())))};
    if (!WebView2_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_WebView2_Static{PyType_FromSpecWithBases(&type_spec_WebView2_Static, WebView2_Static_bases.get())};
    if (!type_WebView2_Static)
    {
        return nullptr;
    }

    py::pyobj_handle WebView2_bases{PyTuple_Pack(1, windows_ui_xaml_controls_Control_type.get())};
    if (!WebView2_bases)
    {
        return nullptr;
    }

    py::pytype_handle WebView2_type{py::register_python_type(module.get(), &type_spec_WebView2, WebView2_bases.get(), reinterpret_cast<PyTypeObject*>(type_WebView2_Static.get()))};
    if (!WebView2_type)
    {
        return nullptr;
    }

    py::pyobj_handle XamlControlsResources_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(windows_ui_xaml_ResourceDictionary_type.get())))};
    if (!XamlControlsResources_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_XamlControlsResources_Static{PyType_FromSpecWithBases(&type_spec_XamlControlsResources_Static, XamlControlsResources_Static_bases.get())};
    if (!type_XamlControlsResources_Static)
    {
        return nullptr;
    }

    py::pyobj_handle XamlControlsResources_bases{PyTuple_Pack(1, windows_ui_xaml_ResourceDictionary_type.get())};
    if (!XamlControlsResources_bases)
    {
        return nullptr;
    }

    py::pytype_handle XamlControlsResources_type{py::register_python_type(module.get(), &type_spec_XamlControlsResources, XamlControlsResources_bases.get(), reinterpret_cast<PyTypeObject*>(type_XamlControlsResources_Static.get()))};
    if (!XamlControlsResources_type)
    {
        return nullptr;
    }

    py::pytype_handle IAnimatedVisual_type{py::register_python_type(module.get(), &type_spec_IAnimatedVisual, object_bases.get(), nullptr)};
    if (!IAnimatedVisual_type)
    {
        return nullptr;
    }

    py::pytype_handle ImplementsIAnimatedVisual_type{py::register_python_type(module.get(), &type_spec_ImplementsIAnimatedVisual, nullptr, inspectable_meta_type)};
    if (!ImplementsIAnimatedVisual_type)
    {
        return nullptr;
    }

    if (PyModule_AddType(module.get(), ImplementsIAnimatedVisual_type.get()) == -1)
    {
        return nullptr;
    }

    py::pytype_handle IAnimatedVisual2_type{py::register_python_type(module.get(), &type_spec_IAnimatedVisual2, object_bases.get(), nullptr)};
    if (!IAnimatedVisual2_type)
    {
        return nullptr;
    }

    py::pytype_handle ImplementsIAnimatedVisual2_type{py::register_python_type(module.get(), &type_spec_ImplementsIAnimatedVisual2, nullptr, inspectable_meta_type)};
    if (!ImplementsIAnimatedVisual2_type)
    {
        return nullptr;
    }

    if (PyModule_AddType(module.get(), ImplementsIAnimatedVisual2_type.get()) == -1)
    {
        return nullptr;
    }

    py::pytype_handle IAnimatedVisualSource_type{py::register_python_type(module.get(), &type_spec_IAnimatedVisualSource, object_bases.get(), nullptr)};
    if (!IAnimatedVisualSource_type)
    {
        return nullptr;
    }

    py::pytype_handle ImplementsIAnimatedVisualSource_type{py::register_python_type(module.get(), &type_spec_ImplementsIAnimatedVisualSource, nullptr, inspectable_meta_type)};
    if (!ImplementsIAnimatedVisualSource_type)
    {
        return nullptr;
    }

    if (PyModule_AddType(module.get(), ImplementsIAnimatedVisualSource_type.get()) == -1)
    {
        return nullptr;
    }

    py::pytype_handle IAnimatedVisualSource2_type{py::register_python_type(module.get(), &type_spec_IAnimatedVisualSource2, object_bases.get(), nullptr)};
    if (!IAnimatedVisualSource2_type)
    {
        return nullptr;
    }

    py::pytype_handle ImplementsIAnimatedVisualSource2_type{py::register_python_type(module.get(), &type_spec_ImplementsIAnimatedVisualSource2, nullptr, inspectable_meta_type)};
    if (!ImplementsIAnimatedVisualSource2_type)
    {
        return nullptr;
    }

    if (PyModule_AddType(module.get(), ImplementsIAnimatedVisualSource2_type.get()) == -1)
    {
        return nullptr;
    }

    py::pytype_handle IAnimatedVisualSource3_type{py::register_python_type(module.get(), &type_spec_IAnimatedVisualSource3, object_bases.get(), nullptr)};
    if (!IAnimatedVisualSource3_type)
    {
        return nullptr;
    }

    py::pytype_handle ImplementsIAnimatedVisualSource3_type{py::register_python_type(module.get(), &type_spec_ImplementsIAnimatedVisualSource3, nullptr, inspectable_meta_type)};
    if (!ImplementsIAnimatedVisualSource3_type)
    {
        return nullptr;
    }

    if (PyModule_AddType(module.get(), ImplementsIAnimatedVisualSource3_type.get()) == -1)
    {
        return nullptr;
    }

    py::pytype_handle IDynamicAnimatedVisualSource_type{py::register_python_type(module.get(), &type_spec_IDynamicAnimatedVisualSource, object_bases.get(), nullptr)};
    if (!IDynamicAnimatedVisualSource_type)
    {
        return nullptr;
    }

    py::pytype_handle ImplementsIDynamicAnimatedVisualSource_type{py::register_python_type(module.get(), &type_spec_ImplementsIDynamicAnimatedVisualSource, nullptr, inspectable_meta_type)};
    if (!ImplementsIDynamicAnimatedVisualSource_type)
    {
        return nullptr;
    }

    if (PyModule_AddType(module.get(), ImplementsIDynamicAnimatedVisualSource_type.get()) == -1)
    {
        return nullptr;
    }

    py::pytype_handle IKeyIndexMapping_type{py::register_python_type(module.get(), &type_spec_IKeyIndexMapping, object_bases.get(), nullptr)};
    if (!IKeyIndexMapping_type)
    {
        return nullptr;
    }

    py::pytype_handle ImplementsIKeyIndexMapping_type{py::register_python_type(module.get(), &type_spec_ImplementsIKeyIndexMapping, nullptr, inspectable_meta_type)};
    if (!ImplementsIKeyIndexMapping_type)
    {
        return nullptr;
    }

    if (PyModule_AddType(module.get(), ImplementsIKeyIndexMapping_type.get()) == -1)
    {
        return nullptr;
    }


    return module.detach();
}
