// WARNING: Please don't edit this file. It was generated by Python/WinRT v0.0.0

#include "py.Windows.Foundation.h"


static int64_t custom_get(winrt::event_token const& instance)
{
    return instance.value;
}

static void custom_set(winrt::event_token& instance, int64_t value)
{
    instance.value = value;
}

static int32_t custom_get(winrt::hresult const& instance)
{
    return instance;
}

static void custom_set(winrt::hresult& instance, int32_t value)
{
    instance = value;
}

namespace py::cpp::Windows::Foundation
{
    // ----- Deferral class --------------------

    static PyObject* _new_Deferral(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::DeferralCompletedHandler>(args, 0);

                winrt::Windows::Foundation::Deferral instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_Deferral(py::wrapper::Windows::Foundation::Deferral* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* Deferral_Close(py::wrapper::Windows::Foundation::Deferral* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.Deferral", L"Close", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Deferral_Complete(py::wrapper::Windows::Foundation::Deferral* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.Deferral", L"Complete", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Complete();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_Deferral(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Foundation::Deferral>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_Deferral(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Foundation::Deferral>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_Deferral(py::wrapper::Windows::Foundation::Deferral* self, PyObject* /*unused*/) noexcept
    {
        return Py_NewRef(self);
    }

    static PyObject* _exit_Deferral(py::wrapper::Windows::Foundation::Deferral* self, PyObject* /*unused*/) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_Deferral[] = {
        { "close", reinterpret_cast<PyCFunction>(Deferral_Close), METH_VARARGS, nullptr },
        { "complete", reinterpret_cast<PyCFunction>(Deferral_Complete), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_Deferral, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_Deferral), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_Deferral), METH_NOARGS, nullptr },
        { "__exit__", reinterpret_cast<PyCFunction>(_exit_Deferral), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_Deferral[] = {
        { }
    };

    static PyType_Slot _type_slots_Deferral[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_Deferral) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_Deferral) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_Deferral) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_Deferral) },
        { },
    };

    static PyType_Spec type_spec_Deferral =
    {
        "winrt._winrt_windows_foundation.Deferral",
        sizeof(py::wrapper::Windows::Foundation::Deferral),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_Deferral
    };

    // ----- GuidHelper class --------------------

    static PyObject* _new_GuidHelper(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Foundation::GuidHelper>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Foundation::GuidHelper>::type_name);
        return nullptr;
    }

    static PyObject* GuidHelper_CreateNewGuid(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.GuidHelper", L"CreateNewGuid", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(winrt::Windows::Foundation::GuidHelper::CreateNewGuid());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* GuidHelper_Equals(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.GuidHelper", L"Equals", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::guid>(args, 0);
                auto param1 = py::convert_to<winrt::guid>(args, 1);

                return py::convert(winrt::Windows::Foundation::GuidHelper::Equals(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* GuidHelper_get_Empty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Foundation.GuidHelper", L"Empty"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Foundation::GuidHelper::Empty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_GuidHelper[] = {
        { }
    };

    static PyGetSetDef _getset_GuidHelper[] = {
        { }
    };

    static PyType_Slot _type_slots_GuidHelper[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_GuidHelper) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_GuidHelper) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_GuidHelper) },
        { },
    };

    static PyType_Spec type_spec_GuidHelper =
    {
        "winrt._winrt_windows_foundation.GuidHelper",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_GuidHelper
    };

    static PyGetSetDef getset_GuidHelper_Static[] = {
        { "empty", reinterpret_cast<getter>(GuidHelper_get_Empty), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_GuidHelper_Static[] = {
        { "create_new_guid", reinterpret_cast<PyCFunction>(GuidHelper_CreateNewGuid), METH_VARARGS, nullptr },
        { "equals", reinterpret_cast<PyCFunction>(GuidHelper_Equals), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_GuidHelper_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_GuidHelper_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_GuidHelper_Static) },
        { }
    };

    static PyType_Spec type_spec_GuidHelper_Static =
    {
        "winrt._winrt_windows_foundation.GuidHelper_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_GuidHelper_Static
    };

    // ----- MemoryBuffer class --------------------

    static PyObject* _new_MemoryBuffer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);

                winrt::Windows::Foundation::MemoryBuffer instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_MemoryBuffer(py::wrapper::Windows::Foundation::MemoryBuffer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MemoryBuffer_Close(py::wrapper::Windows::Foundation::MemoryBuffer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.MemoryBuffer", L"Close", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MemoryBuffer_CreateReference(py::wrapper::Windows::Foundation::MemoryBuffer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.MemoryBuffer", L"CreateReference", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.CreateReference());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_MemoryBuffer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Foundation::MemoryBuffer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MemoryBuffer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Foundation::MemoryBuffer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_MemoryBuffer(py::wrapper::Windows::Foundation::MemoryBuffer* self, PyObject* /*unused*/) noexcept
    {
        return Py_NewRef(self);
    }

    static PyObject* _exit_MemoryBuffer(py::wrapper::Windows::Foundation::MemoryBuffer* self, PyObject* /*unused*/) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MemoryBuffer[] = {
        { "close", reinterpret_cast<PyCFunction>(MemoryBuffer_Close), METH_VARARGS, nullptr },
        { "create_reference", reinterpret_cast<PyCFunction>(MemoryBuffer_CreateReference), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_MemoryBuffer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MemoryBuffer), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_MemoryBuffer), METH_NOARGS, nullptr },
        { "__exit__", reinterpret_cast<PyCFunction>(_exit_MemoryBuffer), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_MemoryBuffer[] = {
        { }
    };

    static PyType_Slot _type_slots_MemoryBuffer[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MemoryBuffer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MemoryBuffer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MemoryBuffer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MemoryBuffer) },
        { },
    };

    static PyType_Spec type_spec_MemoryBuffer =
    {
        "winrt._winrt_windows_foundation.MemoryBuffer",
        sizeof(py::wrapper::Windows::Foundation::MemoryBuffer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MemoryBuffer
    };

    // ----- PropertyValue class --------------------

    static PyObject* _new_PropertyValue(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Foundation::PropertyValue>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Foundation::PropertyValue>::type_name);
        return nullptr;
    }

    static PyObject* PropertyValue_CreateBoolean(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.PropertyValue", L"CreateBoolean", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<bool>(args, 0);

                return py::convert(winrt::Windows::Foundation::PropertyValue::CreateBoolean(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PropertyValue_CreateBooleanArray(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.PropertyValue", L"CreateBooleanArray", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<py::pybuf_view<bool, false>>(args, 0);

                return py::convert(winrt::Windows::Foundation::PropertyValue::CreateBooleanArray(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PropertyValue_CreateChar16(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.PropertyValue", L"CreateChar16", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<char16_t>(args, 0);

                return py::convert(winrt::Windows::Foundation::PropertyValue::CreateChar16(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PropertyValue_CreateChar16Array(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.PropertyValue", L"CreateChar16Array", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<py::pybuf_view<char16_t, false>>(args, 0);

                return py::convert(winrt::Windows::Foundation::PropertyValue::CreateChar16Array(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PropertyValue_CreateDateTime(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.PropertyValue", L"CreateDateTime", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::DateTime>(args, 0);

                return py::convert(winrt::Windows::Foundation::PropertyValue::CreateDateTime(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PropertyValue_CreateDateTimeArray(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.PropertyValue", L"CreateDateTimeArray", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<py::pybuf_view<winrt::Windows::Foundation::DateTime, false>>(args, 0);

                return py::convert(winrt::Windows::Foundation::PropertyValue::CreateDateTimeArray(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PropertyValue_CreateDouble(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.PropertyValue", L"CreateDouble", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<double>(args, 0);

                return py::convert(winrt::Windows::Foundation::PropertyValue::CreateDouble(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PropertyValue_CreateDoubleArray(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.PropertyValue", L"CreateDoubleArray", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<py::pybuf_view<double, false>>(args, 0);

                return py::convert(winrt::Windows::Foundation::PropertyValue::CreateDoubleArray(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PropertyValue_CreateEmpty(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.PropertyValue", L"CreateEmpty", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(winrt::Windows::Foundation::PropertyValue::CreateEmpty());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PropertyValue_CreateGuid(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.PropertyValue", L"CreateGuid", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::guid>(args, 0);

                return py::convert(winrt::Windows::Foundation::PropertyValue::CreateGuid(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PropertyValue_CreateGuidArray(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.PropertyValue", L"CreateGuidArray", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<py::pybuf_view<winrt::guid, false>>(args, 0);

                return py::convert(winrt::Windows::Foundation::PropertyValue::CreateGuidArray(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PropertyValue_CreateInspectable(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.PropertyValue", L"CreateInspectable", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 0);

                return py::convert(winrt::Windows::Foundation::PropertyValue::CreateInspectable(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PropertyValue_CreateInspectableArray(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.PropertyValue", L"CreateInspectableArray", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<py::pybuf_view<winrt::Windows::Foundation::IInspectable, false>>(args, 0);

                return py::convert(winrt::Windows::Foundation::PropertyValue::CreateInspectableArray(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PropertyValue_CreateInt16(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.PropertyValue", L"CreateInt16", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<int16_t>(args, 0);

                return py::convert(winrt::Windows::Foundation::PropertyValue::CreateInt16(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PropertyValue_CreateInt16Array(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.PropertyValue", L"CreateInt16Array", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<py::pybuf_view<int16_t, false>>(args, 0);

                return py::convert(winrt::Windows::Foundation::PropertyValue::CreateInt16Array(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PropertyValue_CreateInt32(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.PropertyValue", L"CreateInt32", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<int32_t>(args, 0);

                return py::convert(winrt::Windows::Foundation::PropertyValue::CreateInt32(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PropertyValue_CreateInt32Array(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.PropertyValue", L"CreateInt32Array", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<py::pybuf_view<int32_t, false>>(args, 0);

                return py::convert(winrt::Windows::Foundation::PropertyValue::CreateInt32Array(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PropertyValue_CreateInt64(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.PropertyValue", L"CreateInt64", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<int64_t>(args, 0);

                return py::convert(winrt::Windows::Foundation::PropertyValue::CreateInt64(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PropertyValue_CreateInt64Array(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.PropertyValue", L"CreateInt64Array", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<py::pybuf_view<int64_t, false>>(args, 0);

                return py::convert(winrt::Windows::Foundation::PropertyValue::CreateInt64Array(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PropertyValue_CreatePoint(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.PropertyValue", L"CreatePoint", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Point>(args, 0);

                return py::convert(winrt::Windows::Foundation::PropertyValue::CreatePoint(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PropertyValue_CreatePointArray(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.PropertyValue", L"CreatePointArray", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<py::pybuf_view<winrt::Windows::Foundation::Point, false>>(args, 0);

                return py::convert(winrt::Windows::Foundation::PropertyValue::CreatePointArray(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PropertyValue_CreateRect(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.PropertyValue", L"CreateRect", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Rect>(args, 0);

                return py::convert(winrt::Windows::Foundation::PropertyValue::CreateRect(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PropertyValue_CreateRectArray(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.PropertyValue", L"CreateRectArray", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<py::pybuf_view<winrt::Windows::Foundation::Rect, false>>(args, 0);

                return py::convert(winrt::Windows::Foundation::PropertyValue::CreateRectArray(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PropertyValue_CreateSingle(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.PropertyValue", L"CreateSingle", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<float>(args, 0);

                return py::convert(winrt::Windows::Foundation::PropertyValue::CreateSingle(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PropertyValue_CreateSingleArray(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.PropertyValue", L"CreateSingleArray", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<py::pybuf_view<float, false>>(args, 0);

                return py::convert(winrt::Windows::Foundation::PropertyValue::CreateSingleArray(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PropertyValue_CreateSize(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.PropertyValue", L"CreateSize", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Size>(args, 0);

                return py::convert(winrt::Windows::Foundation::PropertyValue::CreateSize(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PropertyValue_CreateSizeArray(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.PropertyValue", L"CreateSizeArray", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<py::pybuf_view<winrt::Windows::Foundation::Size, false>>(args, 0);

                return py::convert(winrt::Windows::Foundation::PropertyValue::CreateSizeArray(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PropertyValue_CreateString(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.PropertyValue", L"CreateString", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Foundation::PropertyValue::CreateString(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PropertyValue_CreateStringArray(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.PropertyValue", L"CreateStringArray", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<py::pybuf_view<winrt::hstring, false>>(args, 0);

                return py::convert(winrt::Windows::Foundation::PropertyValue::CreateStringArray(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PropertyValue_CreateTimeSpan(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.PropertyValue", L"CreateTimeSpan", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(args, 0);

                return py::convert(winrt::Windows::Foundation::PropertyValue::CreateTimeSpan(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PropertyValue_CreateTimeSpanArray(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.PropertyValue", L"CreateTimeSpanArray", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<py::pybuf_view<winrt::Windows::Foundation::TimeSpan, false>>(args, 0);

                return py::convert(winrt::Windows::Foundation::PropertyValue::CreateTimeSpanArray(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PropertyValue_CreateUInt16(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.PropertyValue", L"CreateUInt16", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint16_t>(args, 0);

                return py::convert(winrt::Windows::Foundation::PropertyValue::CreateUInt16(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PropertyValue_CreateUInt16Array(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.PropertyValue", L"CreateUInt16Array", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<py::pybuf_view<uint16_t, false>>(args, 0);

                return py::convert(winrt::Windows::Foundation::PropertyValue::CreateUInt16Array(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PropertyValue_CreateUInt32(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.PropertyValue", L"CreateUInt32", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint32_t>(args, 0);

                return py::convert(winrt::Windows::Foundation::PropertyValue::CreateUInt32(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PropertyValue_CreateUInt32Array(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.PropertyValue", L"CreateUInt32Array", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<py::pybuf_view<uint32_t, false>>(args, 0);

                return py::convert(winrt::Windows::Foundation::PropertyValue::CreateUInt32Array(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PropertyValue_CreateUInt64(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.PropertyValue", L"CreateUInt64", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint64_t>(args, 0);

                return py::convert(winrt::Windows::Foundation::PropertyValue::CreateUInt64(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PropertyValue_CreateUInt64Array(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.PropertyValue", L"CreateUInt64Array", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<py::pybuf_view<uint64_t, false>>(args, 0);

                return py::convert(winrt::Windows::Foundation::PropertyValue::CreateUInt64Array(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PropertyValue_CreateUInt8(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.PropertyValue", L"CreateUInt8", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint8_t>(args, 0);

                return py::convert(winrt::Windows::Foundation::PropertyValue::CreateUInt8(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PropertyValue_CreateUInt8Array(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.PropertyValue", L"CreateUInt8Array", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<py::pybuf_view<uint8_t, false>>(args, 0);

                return py::convert(winrt::Windows::Foundation::PropertyValue::CreateUInt8Array(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyMethodDef _methods_PropertyValue[] = {
        { }
    };

    static PyGetSetDef _getset_PropertyValue[] = {
        { }
    };

    static PyType_Slot _type_slots_PropertyValue[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PropertyValue) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PropertyValue) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PropertyValue) },
        { },
    };

    static PyType_Spec type_spec_PropertyValue =
    {
        "winrt._winrt_windows_foundation.PropertyValue",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PropertyValue
    };

    static PyGetSetDef getset_PropertyValue_Static[] = {
        { }
    };

    static PyMethodDef methods_PropertyValue_Static[] = {
        { "create_boolean", reinterpret_cast<PyCFunction>(PropertyValue_CreateBoolean), METH_VARARGS, nullptr },
        { "create_boolean_array", reinterpret_cast<PyCFunction>(PropertyValue_CreateBooleanArray), METH_VARARGS, nullptr },
        { "create_char16", reinterpret_cast<PyCFunction>(PropertyValue_CreateChar16), METH_VARARGS, nullptr },
        { "create_char16_array", reinterpret_cast<PyCFunction>(PropertyValue_CreateChar16Array), METH_VARARGS, nullptr },
        { "create_date_time", reinterpret_cast<PyCFunction>(PropertyValue_CreateDateTime), METH_VARARGS, nullptr },
        { "create_date_time_array", reinterpret_cast<PyCFunction>(PropertyValue_CreateDateTimeArray), METH_VARARGS, nullptr },
        { "create_double", reinterpret_cast<PyCFunction>(PropertyValue_CreateDouble), METH_VARARGS, nullptr },
        { "create_double_array", reinterpret_cast<PyCFunction>(PropertyValue_CreateDoubleArray), METH_VARARGS, nullptr },
        { "create_empty", reinterpret_cast<PyCFunction>(PropertyValue_CreateEmpty), METH_VARARGS, nullptr },
        { "create_guid", reinterpret_cast<PyCFunction>(PropertyValue_CreateGuid), METH_VARARGS, nullptr },
        { "create_guid_array", reinterpret_cast<PyCFunction>(PropertyValue_CreateGuidArray), METH_VARARGS, nullptr },
        { "create_inspectable", reinterpret_cast<PyCFunction>(PropertyValue_CreateInspectable), METH_VARARGS, nullptr },
        { "create_inspectable_array", reinterpret_cast<PyCFunction>(PropertyValue_CreateInspectableArray), METH_VARARGS, nullptr },
        { "create_int16", reinterpret_cast<PyCFunction>(PropertyValue_CreateInt16), METH_VARARGS, nullptr },
        { "create_int16_array", reinterpret_cast<PyCFunction>(PropertyValue_CreateInt16Array), METH_VARARGS, nullptr },
        { "create_int32", reinterpret_cast<PyCFunction>(PropertyValue_CreateInt32), METH_VARARGS, nullptr },
        { "create_int32_array", reinterpret_cast<PyCFunction>(PropertyValue_CreateInt32Array), METH_VARARGS, nullptr },
        { "create_int64", reinterpret_cast<PyCFunction>(PropertyValue_CreateInt64), METH_VARARGS, nullptr },
        { "create_int64_array", reinterpret_cast<PyCFunction>(PropertyValue_CreateInt64Array), METH_VARARGS, nullptr },
        { "create_point", reinterpret_cast<PyCFunction>(PropertyValue_CreatePoint), METH_VARARGS, nullptr },
        { "create_point_array", reinterpret_cast<PyCFunction>(PropertyValue_CreatePointArray), METH_VARARGS, nullptr },
        { "create_rect", reinterpret_cast<PyCFunction>(PropertyValue_CreateRect), METH_VARARGS, nullptr },
        { "create_rect_array", reinterpret_cast<PyCFunction>(PropertyValue_CreateRectArray), METH_VARARGS, nullptr },
        { "create_single", reinterpret_cast<PyCFunction>(PropertyValue_CreateSingle), METH_VARARGS, nullptr },
        { "create_single_array", reinterpret_cast<PyCFunction>(PropertyValue_CreateSingleArray), METH_VARARGS, nullptr },
        { "create_size", reinterpret_cast<PyCFunction>(PropertyValue_CreateSize), METH_VARARGS, nullptr },
        { "create_size_array", reinterpret_cast<PyCFunction>(PropertyValue_CreateSizeArray), METH_VARARGS, nullptr },
        { "create_string", reinterpret_cast<PyCFunction>(PropertyValue_CreateString), METH_VARARGS, nullptr },
        { "create_string_array", reinterpret_cast<PyCFunction>(PropertyValue_CreateStringArray), METH_VARARGS, nullptr },
        { "create_time_span", reinterpret_cast<PyCFunction>(PropertyValue_CreateTimeSpan), METH_VARARGS, nullptr },
        { "create_time_span_array", reinterpret_cast<PyCFunction>(PropertyValue_CreateTimeSpanArray), METH_VARARGS, nullptr },
        { "create_uint16", reinterpret_cast<PyCFunction>(PropertyValue_CreateUInt16), METH_VARARGS, nullptr },
        { "create_uint16_array", reinterpret_cast<PyCFunction>(PropertyValue_CreateUInt16Array), METH_VARARGS, nullptr },
        { "create_uint32", reinterpret_cast<PyCFunction>(PropertyValue_CreateUInt32), METH_VARARGS, nullptr },
        { "create_uint32_array", reinterpret_cast<PyCFunction>(PropertyValue_CreateUInt32Array), METH_VARARGS, nullptr },
        { "create_uint64", reinterpret_cast<PyCFunction>(PropertyValue_CreateUInt64), METH_VARARGS, nullptr },
        { "create_uint64_array", reinterpret_cast<PyCFunction>(PropertyValue_CreateUInt64Array), METH_VARARGS, nullptr },
        { "create_uint8", reinterpret_cast<PyCFunction>(PropertyValue_CreateUInt8), METH_VARARGS, nullptr },
        { "create_uint8_array", reinterpret_cast<PyCFunction>(PropertyValue_CreateUInt8Array), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_PropertyValue_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_PropertyValue_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_PropertyValue_Static) },
        { }
    };

    static PyType_Spec type_spec_PropertyValue_Static =
    {
        "winrt._winrt_windows_foundation.PropertyValue_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_PropertyValue_Static
    };

    // ----- Uri class --------------------

    static PyObject* _new_Uri(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                winrt::Windows::Foundation::Uri instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                winrt::Windows::Foundation::Uri instance{ param0, param1 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_Uri(py::wrapper::Windows::Foundation::Uri* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* Uri_CombineUri(py::wrapper::Windows::Foundation::Uri* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.Uri", L"CombineUri", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.CombineUri(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Uri_Equals(py::wrapper::Windows::Foundation::Uri* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.Uri", L"Equals", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);

                return py::convert(self->obj.Equals(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Uri_EscapeComponent(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.Uri", L"EscapeComponent", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Foundation::Uri::EscapeComponent(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Uri_ToString(py::wrapper::Windows::Foundation::Uri* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.Uri", L"ToString", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.ToString());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Uri_UnescapeComponent(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.Uri", L"UnescapeComponent", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Foundation::Uri::UnescapeComponent(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Uri_get_AbsoluteUri(py::wrapper::Windows::Foundation::Uri* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Foundation.Uri", L"AbsoluteUri"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.AbsoluteUri());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Uri_get_DisplayUri(py::wrapper::Windows::Foundation::Uri* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Foundation.Uri", L"DisplayUri"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DisplayUri());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Uri_get_Domain(py::wrapper::Windows::Foundation::Uri* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Foundation.Uri", L"Domain"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Domain());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Uri_get_Extension(py::wrapper::Windows::Foundation::Uri* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Foundation.Uri", L"Extension"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Extension());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Uri_get_Fragment(py::wrapper::Windows::Foundation::Uri* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Foundation.Uri", L"Fragment"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Fragment());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Uri_get_Host(py::wrapper::Windows::Foundation::Uri* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Foundation.Uri", L"Host"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Host());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Uri_get_Password(py::wrapper::Windows::Foundation::Uri* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Foundation.Uri", L"Password"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Password());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Uri_get_Path(py::wrapper::Windows::Foundation::Uri* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Foundation.Uri", L"Path"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Path());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Uri_get_Port(py::wrapper::Windows::Foundation::Uri* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Foundation.Uri", L"Port"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Port());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Uri_get_Query(py::wrapper::Windows::Foundation::Uri* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Foundation.Uri", L"Query"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Query());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Uri_get_QueryParsed(py::wrapper::Windows::Foundation::Uri* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Foundation.Uri", L"QueryParsed"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.QueryParsed());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Uri_get_RawUri(py::wrapper::Windows::Foundation::Uri* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Foundation.Uri", L"RawUri"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.RawUri());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Uri_get_SchemeName(py::wrapper::Windows::Foundation::Uri* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Foundation.Uri", L"SchemeName"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SchemeName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Uri_get_Suspicious(py::wrapper::Windows::Foundation::Uri* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Foundation.Uri", L"Suspicious"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Suspicious());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Uri_get_UserName(py::wrapper::Windows::Foundation::Uri* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Foundation.Uri", L"UserName"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.UserName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Uri_get_AbsoluteCanonicalUri(py::wrapper::Windows::Foundation::Uri* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Foundation.Uri", L"AbsoluteCanonicalUri"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.AbsoluteCanonicalUri());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Uri_get_DisplayIri(py::wrapper::Windows::Foundation::Uri* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Foundation.Uri", L"DisplayIri"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DisplayIri());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_Uri(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Foundation::Uri>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_Uri(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Foundation::Uri>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _str_Uri(py::wrapper::Windows::Foundation::Uri* self) noexcept
    {
        try
        {
            return py::convert(self->obj.ToString());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_Uri[] = {
        { "combine_uri", reinterpret_cast<PyCFunction>(Uri_CombineUri), METH_VARARGS, nullptr },
        { "equals", reinterpret_cast<PyCFunction>(Uri_Equals), METH_VARARGS, nullptr },
        { "to_string", reinterpret_cast<PyCFunction>(Uri_ToString), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_Uri, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_Uri), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_Uri[] = {
        { "absolute_uri", reinterpret_cast<getter>(Uri_get_AbsoluteUri), nullptr, nullptr, nullptr },
        { "display_uri", reinterpret_cast<getter>(Uri_get_DisplayUri), nullptr, nullptr, nullptr },
        { "domain", reinterpret_cast<getter>(Uri_get_Domain), nullptr, nullptr, nullptr },
        { "extension", reinterpret_cast<getter>(Uri_get_Extension), nullptr, nullptr, nullptr },
        { "fragment", reinterpret_cast<getter>(Uri_get_Fragment), nullptr, nullptr, nullptr },
        { "host", reinterpret_cast<getter>(Uri_get_Host), nullptr, nullptr, nullptr },
        { "password", reinterpret_cast<getter>(Uri_get_Password), nullptr, nullptr, nullptr },
        { "path", reinterpret_cast<getter>(Uri_get_Path), nullptr, nullptr, nullptr },
        { "port", reinterpret_cast<getter>(Uri_get_Port), nullptr, nullptr, nullptr },
        { "query", reinterpret_cast<getter>(Uri_get_Query), nullptr, nullptr, nullptr },
        { "query_parsed", reinterpret_cast<getter>(Uri_get_QueryParsed), nullptr, nullptr, nullptr },
        { "raw_uri", reinterpret_cast<getter>(Uri_get_RawUri), nullptr, nullptr, nullptr },
        { "scheme_name", reinterpret_cast<getter>(Uri_get_SchemeName), nullptr, nullptr, nullptr },
        { "suspicious", reinterpret_cast<getter>(Uri_get_Suspicious), nullptr, nullptr, nullptr },
        { "user_name", reinterpret_cast<getter>(Uri_get_UserName), nullptr, nullptr, nullptr },
        { "absolute_canonical_uri", reinterpret_cast<getter>(Uri_get_AbsoluteCanonicalUri), nullptr, nullptr, nullptr },
        { "display_iri", reinterpret_cast<getter>(Uri_get_DisplayIri), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_Uri[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_Uri) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_Uri) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_Uri) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_Uri) },
        { Py_tp_str, reinterpret_cast<void*>(_str_Uri) },
        { },
    };

    static PyType_Spec type_spec_Uri =
    {
        "winrt._winrt_windows_foundation.Uri",
        sizeof(py::wrapper::Windows::Foundation::Uri),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_Uri
    };

    static PyGetSetDef getset_Uri_Static[] = {
        { }
    };

    static PyMethodDef methods_Uri_Static[] = {
        { "escape_component", reinterpret_cast<PyCFunction>(Uri_EscapeComponent), METH_VARARGS, nullptr },
        { "unescape_component", reinterpret_cast<PyCFunction>(Uri_UnescapeComponent), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_Uri_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_Uri_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_Uri_Static) },
        { }
    };

    static PyType_Spec type_spec_Uri_Static =
    {
        "winrt._winrt_windows_foundation.Uri_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_Uri_Static
    };

    // ----- WwwFormUrlDecoder class --------------------

    static PyObject* _new_WwwFormUrlDecoder(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                winrt::Windows::Foundation::WwwFormUrlDecoder instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_WwwFormUrlDecoder(py::wrapper::Windows::Foundation::WwwFormUrlDecoder* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* WwwFormUrlDecoder_First(py::wrapper::Windows::Foundation::WwwFormUrlDecoder* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.WwwFormUrlDecoder", L"First", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.First());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* WwwFormUrlDecoder_GetAt(py::wrapper::Windows::Foundation::WwwFormUrlDecoder* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.WwwFormUrlDecoder", L"GetAt", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint32_t>(args, 0);

                return py::convert(self->obj.GetAt(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* WwwFormUrlDecoder_GetFirstValueByName(py::wrapper::Windows::Foundation::WwwFormUrlDecoder* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.WwwFormUrlDecoder", L"GetFirstValueByName", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.GetFirstValueByName(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* WwwFormUrlDecoder_GetMany(py::wrapper::Windows::Foundation::WwwFormUrlDecoder* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.WwwFormUrlDecoder", L"GetMany", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<py::pybuf_view<winrt::Windows::Foundation::IWwwFormUrlDecoderEntry, true>>(args, 1);

                return py::convert(self->obj.GetMany(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* WwwFormUrlDecoder_IndexOf(py::wrapper::Windows::Foundation::WwwFormUrlDecoder* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.WwwFormUrlDecoder", L"IndexOf", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::IWwwFormUrlDecoderEntry>(args, 0);
                uint32_t param1{};

                auto return_value = self->obj.IndexOf(param0, param1);

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out1{ py::convert(param1) };
                if (!out1)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out_return_value.get(), out1.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* WwwFormUrlDecoder_get_Size(py::wrapper::Windows::Foundation::WwwFormUrlDecoder* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Foundation.WwwFormUrlDecoder", L"Size"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_WwwFormUrlDecoder(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Foundation::WwwFormUrlDecoder>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_WwwFormUrlDecoder(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Foundation::WwwFormUrlDecoder>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _iterator_WwwFormUrlDecoder(py::wrapper::Windows::Foundation::WwwFormUrlDecoder* self) noexcept
    {
        try
        {
            return py::convert(self->obj.First());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static Py_ssize_t _seq_length_WwwFormUrlDecoder(py::wrapper::Windows::Foundation::WwwFormUrlDecoder* self) noexcept
    {
        try
        {
            return static_cast<Py_ssize_t>(self->obj.Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _seq_item_WwwFormUrlDecoder(py::wrapper::Windows::Foundation::WwwFormUrlDecoder* self, Py_ssize_t i) noexcept
    {
        try
        {
            return py::convert(self->obj.GetAt(static_cast<uint32_t>(i)));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _seq_subscript_WwwFormUrlDecoder(py::wrapper::Windows::Foundation::WwwFormUrlDecoder* self, PyObject* slice) noexcept
    {
        try
        {
            if (PyIndex_Check(slice))
            {
                pyobj_handle index{PyNumber_Index(slice)};

                if (!index)
                {
                    return nullptr;
                }

                auto i = PyNumber_AsSsize_t(index.get(), PyExc_IndexError);

                if (i == -1 && PyErr_Occurred())
                {
                    return nullptr;
                }

                return _seq_item_WwwFormUrlDecoder(self, i);
            }

            if (!PySlice_Check(slice))
            {
                PyErr_Format(PyExc_TypeError, "indices must be integers, not '%s'", Py_TYPE(slice)->tp_name);
            }

            Py_ssize_t start, stop, step, length;

            if (PySlice_GetIndicesEx(slice, self->obj.Size(), &start, &stop, &step, &length) < 0)
            {
                return nullptr;
            }

            if (step != 1)
            {
                PyErr_SetString(PyExc_NotImplementedError, "slices with step other than 1 are not implemented");
                return nullptr;
            }

            winrt::com_array<winrt::Windows::Foundation::IWwwFormUrlDecoderEntry> items(static_cast<uint32_t>(length), empty_instance<winrt::Windows::Foundation::IWwwFormUrlDecoderEntry>::get());

            auto count = self->obj.GetMany(static_cast<uint32_t>(start), items);

            if (count != static_cast<uint32_t>(length))
            {
                PyErr_Format(PyExc_RuntimeError, "returned count %d did not match requested length %zd", count, length);
                return nullptr;
            }

            return convert(items);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_WwwFormUrlDecoder[] = {
        { "first", reinterpret_cast<PyCFunction>(WwwFormUrlDecoder_First), METH_VARARGS, nullptr },
        { "get_at", reinterpret_cast<PyCFunction>(WwwFormUrlDecoder_GetAt), METH_VARARGS, nullptr },
        { "get_first_value_by_name", reinterpret_cast<PyCFunction>(WwwFormUrlDecoder_GetFirstValueByName), METH_VARARGS, nullptr },
        { "get_many", reinterpret_cast<PyCFunction>(WwwFormUrlDecoder_GetMany), METH_VARARGS, nullptr },
        { "index_of", reinterpret_cast<PyCFunction>(WwwFormUrlDecoder_IndexOf), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_WwwFormUrlDecoder, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_WwwFormUrlDecoder), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_WwwFormUrlDecoder[] = {
        { "size", reinterpret_cast<getter>(WwwFormUrlDecoder_get_Size), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_WwwFormUrlDecoder[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_WwwFormUrlDecoder) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_WwwFormUrlDecoder) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_WwwFormUrlDecoder) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_WwwFormUrlDecoder) },
        { Py_tp_iter, reinterpret_cast<void*>(_iterator_WwwFormUrlDecoder) },
        { Py_sq_length, reinterpret_cast<void*>(_seq_length_WwwFormUrlDecoder) },
        { Py_sq_item, reinterpret_cast<void*>(_seq_item_WwwFormUrlDecoder) },
        { Py_mp_subscript, reinterpret_cast<void*>(_seq_subscript_WwwFormUrlDecoder) },
        { },
    };

    static PyType_Spec type_spec_WwwFormUrlDecoder =
    {
        "winrt._winrt_windows_foundation.WwwFormUrlDecoder",
        sizeof(py::wrapper::Windows::Foundation::WwwFormUrlDecoder),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_WwwFormUrlDecoder
    };

    // ----- WwwFormUrlDecoderEntry class --------------------

    static PyObject* _new_WwwFormUrlDecoderEntry(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Foundation::WwwFormUrlDecoderEntry>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Foundation::WwwFormUrlDecoderEntry>::type_name);
        return nullptr;
    }

    static void _dealloc_WwwFormUrlDecoderEntry(py::wrapper::Windows::Foundation::WwwFormUrlDecoderEntry* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* WwwFormUrlDecoderEntry_get_Name(py::wrapper::Windows::Foundation::WwwFormUrlDecoderEntry* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Foundation.WwwFormUrlDecoderEntry", L"Name"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Name());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WwwFormUrlDecoderEntry_get_Value(py::wrapper::Windows::Foundation::WwwFormUrlDecoderEntry* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Foundation.WwwFormUrlDecoderEntry", L"Value"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Value());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_WwwFormUrlDecoderEntry(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Foundation::WwwFormUrlDecoderEntry>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_WwwFormUrlDecoderEntry(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Foundation::WwwFormUrlDecoderEntry>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_WwwFormUrlDecoderEntry[] = {
        { "_assign_array_", _assign_array_WwwFormUrlDecoderEntry, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_WwwFormUrlDecoderEntry), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_WwwFormUrlDecoderEntry[] = {
        { "name", reinterpret_cast<getter>(WwwFormUrlDecoderEntry_get_Name), nullptr, nullptr, nullptr },
        { "value", reinterpret_cast<getter>(WwwFormUrlDecoderEntry_get_Value), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_WwwFormUrlDecoderEntry[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_WwwFormUrlDecoderEntry) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_WwwFormUrlDecoderEntry) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_WwwFormUrlDecoderEntry) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_WwwFormUrlDecoderEntry) },
        { },
    };

    static PyType_Spec type_spec_WwwFormUrlDecoderEntry =
    {
        "winrt._winrt_windows_foundation.WwwFormUrlDecoderEntry",
        sizeof(py::wrapper::Windows::Foundation::WwwFormUrlDecoderEntry),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_WwwFormUrlDecoderEntry
    };

    // ----- IAsyncAction interface --------------------

    static PyObject* _new_IAsyncAction(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Foundation::IAsyncAction>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Foundation::IAsyncAction>::type_name);
        return nullptr;
    }

    static void _dealloc_IAsyncAction(py::wrapper::Windows::Foundation::IAsyncAction* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IAsyncAction_Cancel(py::wrapper::Windows::Foundation::IAsyncAction* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.IAsyncInfo", L"Cancel", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Cancel();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IAsyncAction_Close(py::wrapper::Windows::Foundation::IAsyncAction* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.IAsyncInfo", L"Close", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IAsyncAction_GetResults(py::wrapper::Windows::Foundation::IAsyncAction* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.IAsyncAction", L"GetResults", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.GetResults();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IAsyncAction_get_Completed(py::wrapper::Windows::Foundation::IAsyncAction* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Foundation.IAsyncAction", L"Completed"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Completed());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IAsyncAction_put_Completed(py::wrapper::Windows::Foundation::IAsyncAction* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Foundation.IAsyncAction", L"Completed"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::AsyncActionCompletedHandler>(arg);

            self->obj.Completed(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* IAsyncAction_get_ErrorCode(py::wrapper::Windows::Foundation::IAsyncAction* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Foundation.IAsyncInfo", L"ErrorCode"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ErrorCode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IAsyncAction_get_Id(py::wrapper::Windows::Foundation::IAsyncAction* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Foundation.IAsyncInfo", L"Id"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Id());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IAsyncAction_get_Status(py::wrapper::Windows::Foundation::IAsyncAction* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Foundation.IAsyncInfo", L"Status"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_IAsyncAction(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Foundation::IAsyncAction>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IAsyncAction(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Foundation::IAsyncAction>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _await_IAsyncAction(py::wrapper::Windows::Foundation::IAsyncAction* self) noexcept
    {
        return py::dunder_await(self->obj);
    }

    static PyMethodDef _methods_IAsyncAction[] = {
        { "cancel", reinterpret_cast<PyCFunction>(IAsyncAction_Cancel), METH_VARARGS, nullptr },
        { "close", reinterpret_cast<PyCFunction>(IAsyncAction_Close), METH_VARARGS, nullptr },
        { "get_results", reinterpret_cast<PyCFunction>(IAsyncAction_GetResults), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_IAsyncAction, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IAsyncAction), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IAsyncAction[] = {
        { "completed", reinterpret_cast<getter>(IAsyncAction_get_Completed), reinterpret_cast<setter>(IAsyncAction_put_Completed), nullptr, nullptr },
        { "error_code", reinterpret_cast<getter>(IAsyncAction_get_ErrorCode), nullptr, nullptr, nullptr },
        { "id", reinterpret_cast<getter>(IAsyncAction_get_Id), nullptr, nullptr, nullptr },
        { "status", reinterpret_cast<getter>(IAsyncAction_get_Status), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IAsyncAction[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_IAsyncAction) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IAsyncAction) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IAsyncAction) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IAsyncAction) },
        { Py_am_await, reinterpret_cast<void*>(_await_IAsyncAction) },
        { },
    };

    static PyType_Spec type_spec_IAsyncAction =
    {
        "winrt._winrt_windows_foundation.IAsyncAction",
        sizeof(py::wrapper::Windows::Foundation::IAsyncAction),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IAsyncAction
    };

    // ----- IAsyncActionWithProgress interface --------------------

    static PyObject* _new_IAsyncActionWithProgress(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<py::proj::Windows::Foundation::IAsyncActionWithProgress>::type_name);
        py::set_invalid_activation_error(py::py_type<py::proj::Windows::Foundation::IAsyncActionWithProgress>::type_name);
        return nullptr;
    }

    static void _dealloc_IAsyncActionWithProgress(py::wrapper::Windows::Foundation::IAsyncActionWithProgress* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        std::destroy_at(&self->impl);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IAsyncActionWithProgress_Cancel(py::wrapper::Windows::Foundation::IAsyncActionWithProgress* self, PyObject* args) noexcept
    {
        return self->impl->Cancel(args);
    }

    static PyObject* IAsyncActionWithProgress_Close(py::wrapper::Windows::Foundation::IAsyncActionWithProgress* self, PyObject* args) noexcept
    {
        return self->impl->Close(args);
    }

    static PyObject* IAsyncActionWithProgress_GetResults(py::wrapper::Windows::Foundation::IAsyncActionWithProgress* self, PyObject* args) noexcept
    {
        return self->impl->GetResults(args);
    }

    static PyObject* IAsyncActionWithProgress_get_Progress(py::wrapper::Windows::Foundation::IAsyncActionWithProgress* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Foundation.IAsyncActionWithProgress`1", L"Progress"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return self->impl->get_Progress();
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IAsyncActionWithProgress_put_Progress(py::wrapper::Windows::Foundation::IAsyncActionWithProgress* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Foundation.IAsyncActionWithProgress`1", L"Progress"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            return self->impl->put_Progress(arg);
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* IAsyncActionWithProgress_get_Completed(py::wrapper::Windows::Foundation::IAsyncActionWithProgress* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Foundation.IAsyncActionWithProgress`1", L"Completed"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return self->impl->get_Completed();
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IAsyncActionWithProgress_put_Completed(py::wrapper::Windows::Foundation::IAsyncActionWithProgress* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Foundation.IAsyncActionWithProgress`1", L"Completed"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            return self->impl->put_Completed(arg);
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* IAsyncActionWithProgress_get_ErrorCode(py::wrapper::Windows::Foundation::IAsyncActionWithProgress* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Foundation.IAsyncInfo", L"ErrorCode"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return self->impl->get_ErrorCode();
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IAsyncActionWithProgress_get_Id(py::wrapper::Windows::Foundation::IAsyncActionWithProgress* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Foundation.IAsyncInfo", L"Id"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return self->impl->get_Id();
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IAsyncActionWithProgress_get_Status(py::wrapper::Windows::Foundation::IAsyncActionWithProgress* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Foundation.IAsyncInfo", L"Status"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return self->impl->get_Status();
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _await_IAsyncActionWithProgress(py::wrapper::Windows::Foundation::IAsyncActionWithProgress* self) noexcept
    {
        return self->impl->dunder_await();
    }

    static PyMethodDef _methods_IAsyncActionWithProgress[] = {
        { "cancel", reinterpret_cast<PyCFunction>(IAsyncActionWithProgress_Cancel), METH_VARARGS, nullptr },
        { "close", reinterpret_cast<PyCFunction>(IAsyncActionWithProgress_Close), METH_VARARGS, nullptr },
        { "get_results", reinterpret_cast<PyCFunction>(IAsyncActionWithProgress_GetResults), METH_VARARGS, nullptr },
        { "__class_getitem__", Py_GenericAlias, METH_O | METH_CLASS, PyDoc_STR("See PEP 585") },
        { }
    };

    static PyGetSetDef _getset_IAsyncActionWithProgress[] = {
        { "progress", reinterpret_cast<getter>(IAsyncActionWithProgress_get_Progress), reinterpret_cast<setter>(IAsyncActionWithProgress_put_Progress), nullptr, nullptr },
        { "completed", reinterpret_cast<getter>(IAsyncActionWithProgress_get_Completed), reinterpret_cast<setter>(IAsyncActionWithProgress_put_Completed), nullptr, nullptr },
        { "error_code", reinterpret_cast<getter>(IAsyncActionWithProgress_get_ErrorCode), nullptr, nullptr, nullptr },
        { "id", reinterpret_cast<getter>(IAsyncActionWithProgress_get_Id), nullptr, nullptr, nullptr },
        { "status", reinterpret_cast<getter>(IAsyncActionWithProgress_get_Status), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IAsyncActionWithProgress[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_IAsyncActionWithProgress) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IAsyncActionWithProgress) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IAsyncActionWithProgress) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IAsyncActionWithProgress) },
        { Py_am_await, reinterpret_cast<void*>(_await_IAsyncActionWithProgress) },
        { },
    };

    static PyType_Spec type_spec_IAsyncActionWithProgress =
    {
        "winrt._winrt_windows_foundation.IAsyncActionWithProgress",
        sizeof(py::wrapper::Windows::Foundation::IAsyncActionWithProgress),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IAsyncActionWithProgress
    };

    // ----- IAsyncInfo interface --------------------

    static PyObject* _new_IAsyncInfo(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Foundation::IAsyncInfo>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Foundation::IAsyncInfo>::type_name);
        return nullptr;
    }

    static void _dealloc_IAsyncInfo(py::wrapper::Windows::Foundation::IAsyncInfo* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IAsyncInfo_Cancel(py::wrapper::Windows::Foundation::IAsyncInfo* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.IAsyncInfo", L"Cancel", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Cancel();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IAsyncInfo_Close(py::wrapper::Windows::Foundation::IAsyncInfo* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.IAsyncInfo", L"Close", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IAsyncInfo_get_ErrorCode(py::wrapper::Windows::Foundation::IAsyncInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Foundation.IAsyncInfo", L"ErrorCode"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ErrorCode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IAsyncInfo_get_Id(py::wrapper::Windows::Foundation::IAsyncInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Foundation.IAsyncInfo", L"Id"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Id());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IAsyncInfo_get_Status(py::wrapper::Windows::Foundation::IAsyncInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Foundation.IAsyncInfo", L"Status"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_IAsyncInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Foundation::IAsyncInfo>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IAsyncInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Foundation::IAsyncInfo>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IAsyncInfo[] = {
        { "cancel", reinterpret_cast<PyCFunction>(IAsyncInfo_Cancel), METH_VARARGS, nullptr },
        { "close", reinterpret_cast<PyCFunction>(IAsyncInfo_Close), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_IAsyncInfo, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IAsyncInfo), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IAsyncInfo[] = {
        { "error_code", reinterpret_cast<getter>(IAsyncInfo_get_ErrorCode), nullptr, nullptr, nullptr },
        { "id", reinterpret_cast<getter>(IAsyncInfo_get_Id), nullptr, nullptr, nullptr },
        { "status", reinterpret_cast<getter>(IAsyncInfo_get_Status), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IAsyncInfo[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_IAsyncInfo) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IAsyncInfo) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IAsyncInfo) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IAsyncInfo) },
        { },
    };

    static PyType_Spec type_spec_IAsyncInfo =
    {
        "winrt._winrt_windows_foundation.IAsyncInfo",
        sizeof(py::wrapper::Windows::Foundation::IAsyncInfo),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IAsyncInfo
    };

    // ----- IAsyncOperationWithProgress interface --------------------

    static PyObject* _new_IAsyncOperationWithProgress(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<py::proj::Windows::Foundation::IAsyncOperationWithProgress>::type_name);
        py::set_invalid_activation_error(py::py_type<py::proj::Windows::Foundation::IAsyncOperationWithProgress>::type_name);
        return nullptr;
    }

    static void _dealloc_IAsyncOperationWithProgress(py::wrapper::Windows::Foundation::IAsyncOperationWithProgress* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        std::destroy_at(&self->impl);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IAsyncOperationWithProgress_Cancel(py::wrapper::Windows::Foundation::IAsyncOperationWithProgress* self, PyObject* args) noexcept
    {
        return self->impl->Cancel(args);
    }

    static PyObject* IAsyncOperationWithProgress_Close(py::wrapper::Windows::Foundation::IAsyncOperationWithProgress* self, PyObject* args) noexcept
    {
        return self->impl->Close(args);
    }

    static PyObject* IAsyncOperationWithProgress_GetResults(py::wrapper::Windows::Foundation::IAsyncOperationWithProgress* self, PyObject* args) noexcept
    {
        return self->impl->GetResults(args);
    }

    static PyObject* IAsyncOperationWithProgress_get_Progress(py::wrapper::Windows::Foundation::IAsyncOperationWithProgress* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Foundation.IAsyncOperationWithProgress`2", L"Progress"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return self->impl->get_Progress();
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IAsyncOperationWithProgress_put_Progress(py::wrapper::Windows::Foundation::IAsyncOperationWithProgress* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Foundation.IAsyncOperationWithProgress`2", L"Progress"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            return self->impl->put_Progress(arg);
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* IAsyncOperationWithProgress_get_Completed(py::wrapper::Windows::Foundation::IAsyncOperationWithProgress* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Foundation.IAsyncOperationWithProgress`2", L"Completed"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return self->impl->get_Completed();
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IAsyncOperationWithProgress_put_Completed(py::wrapper::Windows::Foundation::IAsyncOperationWithProgress* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Foundation.IAsyncOperationWithProgress`2", L"Completed"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            return self->impl->put_Completed(arg);
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* IAsyncOperationWithProgress_get_ErrorCode(py::wrapper::Windows::Foundation::IAsyncOperationWithProgress* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Foundation.IAsyncInfo", L"ErrorCode"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return self->impl->get_ErrorCode();
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IAsyncOperationWithProgress_get_Id(py::wrapper::Windows::Foundation::IAsyncOperationWithProgress* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Foundation.IAsyncInfo", L"Id"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return self->impl->get_Id();
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IAsyncOperationWithProgress_get_Status(py::wrapper::Windows::Foundation::IAsyncOperationWithProgress* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Foundation.IAsyncInfo", L"Status"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return self->impl->get_Status();
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _await_IAsyncOperationWithProgress(py::wrapper::Windows::Foundation::IAsyncOperationWithProgress* self) noexcept
    {
        return self->impl->dunder_await();
    }

    static PyMethodDef _methods_IAsyncOperationWithProgress[] = {
        { "cancel", reinterpret_cast<PyCFunction>(IAsyncOperationWithProgress_Cancel), METH_VARARGS, nullptr },
        { "close", reinterpret_cast<PyCFunction>(IAsyncOperationWithProgress_Close), METH_VARARGS, nullptr },
        { "get_results", reinterpret_cast<PyCFunction>(IAsyncOperationWithProgress_GetResults), METH_VARARGS, nullptr },
        { "__class_getitem__", Py_GenericAlias, METH_O | METH_CLASS, PyDoc_STR("See PEP 585") },
        { }
    };

    static PyGetSetDef _getset_IAsyncOperationWithProgress[] = {
        { "progress", reinterpret_cast<getter>(IAsyncOperationWithProgress_get_Progress), reinterpret_cast<setter>(IAsyncOperationWithProgress_put_Progress), nullptr, nullptr },
        { "completed", reinterpret_cast<getter>(IAsyncOperationWithProgress_get_Completed), reinterpret_cast<setter>(IAsyncOperationWithProgress_put_Completed), nullptr, nullptr },
        { "error_code", reinterpret_cast<getter>(IAsyncOperationWithProgress_get_ErrorCode), nullptr, nullptr, nullptr },
        { "id", reinterpret_cast<getter>(IAsyncOperationWithProgress_get_Id), nullptr, nullptr, nullptr },
        { "status", reinterpret_cast<getter>(IAsyncOperationWithProgress_get_Status), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IAsyncOperationWithProgress[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_IAsyncOperationWithProgress) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IAsyncOperationWithProgress) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IAsyncOperationWithProgress) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IAsyncOperationWithProgress) },
        { Py_am_await, reinterpret_cast<void*>(_await_IAsyncOperationWithProgress) },
        { },
    };

    static PyType_Spec type_spec_IAsyncOperationWithProgress =
    {
        "winrt._winrt_windows_foundation.IAsyncOperationWithProgress",
        sizeof(py::wrapper::Windows::Foundation::IAsyncOperationWithProgress),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IAsyncOperationWithProgress
    };

    // ----- IAsyncOperation interface --------------------

    static PyObject* _new_IAsyncOperation(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<py::proj::Windows::Foundation::IAsyncOperation>::type_name);
        py::set_invalid_activation_error(py::py_type<py::proj::Windows::Foundation::IAsyncOperation>::type_name);
        return nullptr;
    }

    static void _dealloc_IAsyncOperation(py::wrapper::Windows::Foundation::IAsyncOperation* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        std::destroy_at(&self->impl);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IAsyncOperation_Cancel(py::wrapper::Windows::Foundation::IAsyncOperation* self, PyObject* args) noexcept
    {
        return self->impl->Cancel(args);
    }

    static PyObject* IAsyncOperation_Close(py::wrapper::Windows::Foundation::IAsyncOperation* self, PyObject* args) noexcept
    {
        return self->impl->Close(args);
    }

    static PyObject* IAsyncOperation_GetResults(py::wrapper::Windows::Foundation::IAsyncOperation* self, PyObject* args) noexcept
    {
        return self->impl->GetResults(args);
    }

    static PyObject* IAsyncOperation_get_Completed(py::wrapper::Windows::Foundation::IAsyncOperation* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Foundation.IAsyncOperation`1", L"Completed"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return self->impl->get_Completed();
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IAsyncOperation_put_Completed(py::wrapper::Windows::Foundation::IAsyncOperation* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Foundation.IAsyncOperation`1", L"Completed"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            return self->impl->put_Completed(arg);
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* IAsyncOperation_get_ErrorCode(py::wrapper::Windows::Foundation::IAsyncOperation* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Foundation.IAsyncInfo", L"ErrorCode"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return self->impl->get_ErrorCode();
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IAsyncOperation_get_Id(py::wrapper::Windows::Foundation::IAsyncOperation* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Foundation.IAsyncInfo", L"Id"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return self->impl->get_Id();
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IAsyncOperation_get_Status(py::wrapper::Windows::Foundation::IAsyncOperation* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Foundation.IAsyncInfo", L"Status"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return self->impl->get_Status();
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _await_IAsyncOperation(py::wrapper::Windows::Foundation::IAsyncOperation* self) noexcept
    {
        return self->impl->dunder_await();
    }

    static PyMethodDef _methods_IAsyncOperation[] = {
        { "cancel", reinterpret_cast<PyCFunction>(IAsyncOperation_Cancel), METH_VARARGS, nullptr },
        { "close", reinterpret_cast<PyCFunction>(IAsyncOperation_Close), METH_VARARGS, nullptr },
        { "get_results", reinterpret_cast<PyCFunction>(IAsyncOperation_GetResults), METH_VARARGS, nullptr },
        { "__class_getitem__", Py_GenericAlias, METH_O | METH_CLASS, PyDoc_STR("See PEP 585") },
        { }
    };

    static PyGetSetDef _getset_IAsyncOperation[] = {
        { "completed", reinterpret_cast<getter>(IAsyncOperation_get_Completed), reinterpret_cast<setter>(IAsyncOperation_put_Completed), nullptr, nullptr },
        { "error_code", reinterpret_cast<getter>(IAsyncOperation_get_ErrorCode), nullptr, nullptr, nullptr },
        { "id", reinterpret_cast<getter>(IAsyncOperation_get_Id), nullptr, nullptr, nullptr },
        { "status", reinterpret_cast<getter>(IAsyncOperation_get_Status), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IAsyncOperation[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_IAsyncOperation) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IAsyncOperation) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IAsyncOperation) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IAsyncOperation) },
        { Py_am_await, reinterpret_cast<void*>(_await_IAsyncOperation) },
        { },
    };

    static PyType_Spec type_spec_IAsyncOperation =
    {
        "winrt._winrt_windows_foundation.IAsyncOperation",
        sizeof(py::wrapper::Windows::Foundation::IAsyncOperation),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IAsyncOperation
    };

    // ----- IClosable interface --------------------

    static PyObject* _new_IClosable(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Foundation::IClosable>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Foundation::IClosable>::type_name);
        return nullptr;
    }

    static void _dealloc_IClosable(py::wrapper::Windows::Foundation::IClosable* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IClosable_Close(py::wrapper::Windows::Foundation::IClosable* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.IClosable", L"Close", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_IClosable(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Foundation::IClosable>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IClosable(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Foundation::IClosable>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_IClosable(py::wrapper::Windows::Foundation::IClosable* self, PyObject* /*unused*/) noexcept
    {
        return Py_NewRef(self);
    }

    static PyObject* _exit_IClosable(py::wrapper::Windows::Foundation::IClosable* self, PyObject* /*unused*/) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IClosable[] = {
        { "close", reinterpret_cast<PyCFunction>(IClosable_Close), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_IClosable, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IClosable), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_IClosable), METH_NOARGS, nullptr },
        { "__exit__", reinterpret_cast<PyCFunction>(_exit_IClosable), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_IClosable[] = {
        { }
    };

    static PyType_Slot _type_slots_IClosable[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_IClosable) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IClosable) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IClosable) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IClosable) },
        { },
    };

    static PyType_Spec type_spec_IClosable =
    {
        "winrt._winrt_windows_foundation.IClosable",
        sizeof(py::wrapper::Windows::Foundation::IClosable),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IClosable
    };

    // ----- IGetActivationFactory interface --------------------

    static PyObject* _new_IGetActivationFactory(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Foundation::IGetActivationFactory>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Foundation::IGetActivationFactory>::type_name);
        return nullptr;
    }

    static void _dealloc_IGetActivationFactory(py::wrapper::Windows::Foundation::IGetActivationFactory* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IGetActivationFactory_GetActivationFactory(py::wrapper::Windows::Foundation::IGetActivationFactory* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.IGetActivationFactory", L"GetActivationFactory", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.GetActivationFactory(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_IGetActivationFactory(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Foundation::IGetActivationFactory>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IGetActivationFactory(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Foundation::IGetActivationFactory>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IGetActivationFactory[] = {
        { "get_activation_factory", reinterpret_cast<PyCFunction>(IGetActivationFactory_GetActivationFactory), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_IGetActivationFactory, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IGetActivationFactory), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IGetActivationFactory[] = {
        { }
    };

    static PyType_Slot _type_slots_IGetActivationFactory[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_IGetActivationFactory) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IGetActivationFactory) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IGetActivationFactory) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IGetActivationFactory) },
        { },
    };

    static PyType_Spec type_spec_IGetActivationFactory =
    {
        "winrt._winrt_windows_foundation.IGetActivationFactory",
        sizeof(py::wrapper::Windows::Foundation::IGetActivationFactory),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IGetActivationFactory
    };

    // ----- IMemoryBuffer interface --------------------

    static PyObject* _new_IMemoryBuffer(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Foundation::IMemoryBuffer>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Foundation::IMemoryBuffer>::type_name);
        return nullptr;
    }

    static void _dealloc_IMemoryBuffer(py::wrapper::Windows::Foundation::IMemoryBuffer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IMemoryBuffer_Close(py::wrapper::Windows::Foundation::IMemoryBuffer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.IClosable", L"Close", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IMemoryBuffer_CreateReference(py::wrapper::Windows::Foundation::IMemoryBuffer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.IMemoryBuffer", L"CreateReference", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.CreateReference());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_IMemoryBuffer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Foundation::IMemoryBuffer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IMemoryBuffer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Foundation::IMemoryBuffer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_IMemoryBuffer(py::wrapper::Windows::Foundation::IMemoryBuffer* self, PyObject* /*unused*/) noexcept
    {
        return Py_NewRef(self);
    }

    static PyObject* _exit_IMemoryBuffer(py::wrapper::Windows::Foundation::IMemoryBuffer* self, PyObject* /*unused*/) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IMemoryBuffer[] = {
        { "close", reinterpret_cast<PyCFunction>(IMemoryBuffer_Close), METH_VARARGS, nullptr },
        { "create_reference", reinterpret_cast<PyCFunction>(IMemoryBuffer_CreateReference), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_IMemoryBuffer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IMemoryBuffer), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_IMemoryBuffer), METH_NOARGS, nullptr },
        { "__exit__", reinterpret_cast<PyCFunction>(_exit_IMemoryBuffer), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_IMemoryBuffer[] = {
        { }
    };

    static PyType_Slot _type_slots_IMemoryBuffer[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_IMemoryBuffer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IMemoryBuffer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IMemoryBuffer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IMemoryBuffer) },
        { },
    };

    static PyType_Spec type_spec_IMemoryBuffer =
    {
        "winrt._winrt_windows_foundation.IMemoryBuffer",
        sizeof(py::wrapper::Windows::Foundation::IMemoryBuffer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IMemoryBuffer
    };

    // ----- IMemoryBufferReference interface --------------------

    static PyObject* _new_IMemoryBufferReference(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Foundation::IMemoryBufferReference>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Foundation::IMemoryBufferReference>::type_name);
        return nullptr;
    }

    static void _dealloc_IMemoryBufferReference(py::wrapper::Windows::Foundation::IMemoryBufferReference* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IMemoryBufferReference_Close(py::wrapper::Windows::Foundation::IMemoryBufferReference* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.IClosable", L"Close", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IMemoryBufferReference_get_Capacity(py::wrapper::Windows::Foundation::IMemoryBufferReference* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Foundation.IMemoryBufferReference", L"Capacity"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Capacity());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IMemoryBufferReference_add_Closed(py::wrapper::Windows::Foundation::IMemoryBufferReference* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Foundation.IMemoryBufferReference", L"Closed"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Foundation::IMemoryBufferReference, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.Closed(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IMemoryBufferReference_remove_Closed(py::wrapper::Windows::Foundation::IMemoryBufferReference* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Foundation.IMemoryBufferReference", L"Closed"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Closed(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_IMemoryBufferReference(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Foundation::IMemoryBufferReference>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IMemoryBufferReference(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Foundation::IMemoryBufferReference>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_IMemoryBufferReference(py::wrapper::Windows::Foundation::IMemoryBufferReference* self, PyObject* /*unused*/) noexcept
    {
        return Py_NewRef(self);
    }

    static PyObject* _exit_IMemoryBufferReference(py::wrapper::Windows::Foundation::IMemoryBufferReference* self, PyObject* /*unused*/) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int _get_buffer_IMemoryBufferReference(py::wrapper::Windows::Foundation::IMemoryBufferReference* self, Py_buffer* view, int flags) noexcept
    {
        try
        {
            return PyBuffer_FillInfo(view, reinterpret_cast<PyObject*>(self), reinterpret_cast<void*>(self->obj.data()), static_cast<Py_ssize_t>(self->obj.Capacity()), 0, flags);
        }
        catch (...)
        {
            view->obj = nullptr;
            PyErr_SetNone(PyExc_BufferError);
            return -1;
        }
    }

    static PyMethodDef _methods_IMemoryBufferReference[] = {
        { "close", reinterpret_cast<PyCFunction>(IMemoryBufferReference_Close), METH_VARARGS, nullptr },
        { "add_closed", reinterpret_cast<PyCFunction>(IMemoryBufferReference_add_Closed), METH_O, nullptr },
        { "remove_closed", reinterpret_cast<PyCFunction>(IMemoryBufferReference_remove_Closed), METH_O, nullptr },
        { "_assign_array_", _assign_array_IMemoryBufferReference, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IMemoryBufferReference), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_IMemoryBufferReference), METH_NOARGS, nullptr },
        { "__exit__", reinterpret_cast<PyCFunction>(_exit_IMemoryBufferReference), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_IMemoryBufferReference[] = {
        { "capacity", reinterpret_cast<getter>(IMemoryBufferReference_get_Capacity), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IMemoryBufferReference[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_IMemoryBufferReference) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IMemoryBufferReference) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IMemoryBufferReference) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IMemoryBufferReference) },
        { Py_bf_getbuffer, reinterpret_cast<void*>(_get_buffer_IMemoryBufferReference) },
        { },
    };

    static PyType_Spec type_spec_IMemoryBufferReference =
    {
        "winrt._winrt_windows_foundation.IMemoryBufferReference",
        sizeof(py::wrapper::Windows::Foundation::IMemoryBufferReference),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IMemoryBufferReference
    };

    // ----- IPropertyValue interface --------------------

    static PyObject* _new_IPropertyValue(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Foundation::IPropertyValue>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Foundation::IPropertyValue>::type_name);
        return nullptr;
    }

    static void _dealloc_IPropertyValue(py::wrapper::Windows::Foundation::IPropertyValue* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IPropertyValue_GetBoolean(py::wrapper::Windows::Foundation::IPropertyValue* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.IPropertyValue", L"GetBoolean", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetBoolean());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IPropertyValue_GetBooleanArray(py::wrapper::Windows::Foundation::IPropertyValue* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.IPropertyValue", L"GetBooleanArray", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                winrt::com_array<bool> param0{};

                self->obj.GetBooleanArray(param0);

                py::pyobj_handle out0{ py::convert(param0) };
                if (!out0)
                {
                    return nullptr;
                }
                return out0.detach();
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IPropertyValue_GetChar16(py::wrapper::Windows::Foundation::IPropertyValue* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.IPropertyValue", L"GetChar16", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetChar16());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IPropertyValue_GetChar16Array(py::wrapper::Windows::Foundation::IPropertyValue* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.IPropertyValue", L"GetChar16Array", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                winrt::com_array<char16_t> param0{};

                self->obj.GetChar16Array(param0);

                py::pyobj_handle out0{ py::convert(param0) };
                if (!out0)
                {
                    return nullptr;
                }
                return out0.detach();
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IPropertyValue_GetDateTime(py::wrapper::Windows::Foundation::IPropertyValue* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.IPropertyValue", L"GetDateTime", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetDateTime());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IPropertyValue_GetDateTimeArray(py::wrapper::Windows::Foundation::IPropertyValue* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.IPropertyValue", L"GetDateTimeArray", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                winrt::com_array<winrt::Windows::Foundation::DateTime> param0{};

                self->obj.GetDateTimeArray(param0);

                py::pyobj_handle out0{ py::convert(param0) };
                if (!out0)
                {
                    return nullptr;
                }
                return out0.detach();
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IPropertyValue_GetDouble(py::wrapper::Windows::Foundation::IPropertyValue* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.IPropertyValue", L"GetDouble", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetDouble());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IPropertyValue_GetDoubleArray(py::wrapper::Windows::Foundation::IPropertyValue* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.IPropertyValue", L"GetDoubleArray", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                winrt::com_array<double> param0{};

                self->obj.GetDoubleArray(param0);

                py::pyobj_handle out0{ py::convert(param0) };
                if (!out0)
                {
                    return nullptr;
                }
                return out0.detach();
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IPropertyValue_GetGuid(py::wrapper::Windows::Foundation::IPropertyValue* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.IPropertyValue", L"GetGuid", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetGuid());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IPropertyValue_GetGuidArray(py::wrapper::Windows::Foundation::IPropertyValue* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.IPropertyValue", L"GetGuidArray", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                winrt::com_array<winrt::guid> param0{};

                self->obj.GetGuidArray(param0);

                py::pyobj_handle out0{ py::convert(param0) };
                if (!out0)
                {
                    return nullptr;
                }
                return out0.detach();
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IPropertyValue_GetInspectableArray(py::wrapper::Windows::Foundation::IPropertyValue* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.IPropertyValue", L"GetInspectableArray", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                winrt::com_array<winrt::Windows::Foundation::IInspectable> param0{};

                self->obj.GetInspectableArray(param0);

                py::pyobj_handle out0{ py::convert(param0) };
                if (!out0)
                {
                    return nullptr;
                }
                return out0.detach();
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IPropertyValue_GetInt16(py::wrapper::Windows::Foundation::IPropertyValue* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.IPropertyValue", L"GetInt16", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetInt16());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IPropertyValue_GetInt16Array(py::wrapper::Windows::Foundation::IPropertyValue* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.IPropertyValue", L"GetInt16Array", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                winrt::com_array<int16_t> param0{};

                self->obj.GetInt16Array(param0);

                py::pyobj_handle out0{ py::convert(param0) };
                if (!out0)
                {
                    return nullptr;
                }
                return out0.detach();
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IPropertyValue_GetInt32(py::wrapper::Windows::Foundation::IPropertyValue* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.IPropertyValue", L"GetInt32", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetInt32());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IPropertyValue_GetInt32Array(py::wrapper::Windows::Foundation::IPropertyValue* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.IPropertyValue", L"GetInt32Array", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                winrt::com_array<int32_t> param0{};

                self->obj.GetInt32Array(param0);

                py::pyobj_handle out0{ py::convert(param0) };
                if (!out0)
                {
                    return nullptr;
                }
                return out0.detach();
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IPropertyValue_GetInt64(py::wrapper::Windows::Foundation::IPropertyValue* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.IPropertyValue", L"GetInt64", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetInt64());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IPropertyValue_GetInt64Array(py::wrapper::Windows::Foundation::IPropertyValue* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.IPropertyValue", L"GetInt64Array", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                winrt::com_array<int64_t> param0{};

                self->obj.GetInt64Array(param0);

                py::pyobj_handle out0{ py::convert(param0) };
                if (!out0)
                {
                    return nullptr;
                }
                return out0.detach();
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IPropertyValue_GetPoint(py::wrapper::Windows::Foundation::IPropertyValue* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.IPropertyValue", L"GetPoint", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetPoint());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IPropertyValue_GetPointArray(py::wrapper::Windows::Foundation::IPropertyValue* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.IPropertyValue", L"GetPointArray", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                winrt::com_array<winrt::Windows::Foundation::Point> param0{};

                self->obj.GetPointArray(param0);

                py::pyobj_handle out0{ py::convert(param0) };
                if (!out0)
                {
                    return nullptr;
                }
                return out0.detach();
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IPropertyValue_GetRect(py::wrapper::Windows::Foundation::IPropertyValue* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.IPropertyValue", L"GetRect", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetRect());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IPropertyValue_GetRectArray(py::wrapper::Windows::Foundation::IPropertyValue* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.IPropertyValue", L"GetRectArray", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                winrt::com_array<winrt::Windows::Foundation::Rect> param0{};

                self->obj.GetRectArray(param0);

                py::pyobj_handle out0{ py::convert(param0) };
                if (!out0)
                {
                    return nullptr;
                }
                return out0.detach();
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IPropertyValue_GetSingle(py::wrapper::Windows::Foundation::IPropertyValue* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.IPropertyValue", L"GetSingle", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetSingle());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IPropertyValue_GetSingleArray(py::wrapper::Windows::Foundation::IPropertyValue* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.IPropertyValue", L"GetSingleArray", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                winrt::com_array<float> param0{};

                self->obj.GetSingleArray(param0);

                py::pyobj_handle out0{ py::convert(param0) };
                if (!out0)
                {
                    return nullptr;
                }
                return out0.detach();
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IPropertyValue_GetSize(py::wrapper::Windows::Foundation::IPropertyValue* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.IPropertyValue", L"GetSize", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetSize());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IPropertyValue_GetSizeArray(py::wrapper::Windows::Foundation::IPropertyValue* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.IPropertyValue", L"GetSizeArray", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                winrt::com_array<winrt::Windows::Foundation::Size> param0{};

                self->obj.GetSizeArray(param0);

                py::pyobj_handle out0{ py::convert(param0) };
                if (!out0)
                {
                    return nullptr;
                }
                return out0.detach();
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IPropertyValue_GetString(py::wrapper::Windows::Foundation::IPropertyValue* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.IPropertyValue", L"GetString", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetString());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IPropertyValue_GetStringArray(py::wrapper::Windows::Foundation::IPropertyValue* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.IPropertyValue", L"GetStringArray", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                winrt::com_array<winrt::hstring> param0{};

                self->obj.GetStringArray(param0);

                py::pyobj_handle out0{ py::convert(param0) };
                if (!out0)
                {
                    return nullptr;
                }
                return out0.detach();
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IPropertyValue_GetTimeSpan(py::wrapper::Windows::Foundation::IPropertyValue* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.IPropertyValue", L"GetTimeSpan", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetTimeSpan());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IPropertyValue_GetTimeSpanArray(py::wrapper::Windows::Foundation::IPropertyValue* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.IPropertyValue", L"GetTimeSpanArray", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                winrt::com_array<winrt::Windows::Foundation::TimeSpan> param0{};

                self->obj.GetTimeSpanArray(param0);

                py::pyobj_handle out0{ py::convert(param0) };
                if (!out0)
                {
                    return nullptr;
                }
                return out0.detach();
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IPropertyValue_GetUInt16(py::wrapper::Windows::Foundation::IPropertyValue* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.IPropertyValue", L"GetUInt16", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetUInt16());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IPropertyValue_GetUInt16Array(py::wrapper::Windows::Foundation::IPropertyValue* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.IPropertyValue", L"GetUInt16Array", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                winrt::com_array<uint16_t> param0{};

                self->obj.GetUInt16Array(param0);

                py::pyobj_handle out0{ py::convert(param0) };
                if (!out0)
                {
                    return nullptr;
                }
                return out0.detach();
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IPropertyValue_GetUInt32(py::wrapper::Windows::Foundation::IPropertyValue* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.IPropertyValue", L"GetUInt32", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetUInt32());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IPropertyValue_GetUInt32Array(py::wrapper::Windows::Foundation::IPropertyValue* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.IPropertyValue", L"GetUInt32Array", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                winrt::com_array<uint32_t> param0{};

                self->obj.GetUInt32Array(param0);

                py::pyobj_handle out0{ py::convert(param0) };
                if (!out0)
                {
                    return nullptr;
                }
                return out0.detach();
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IPropertyValue_GetUInt64(py::wrapper::Windows::Foundation::IPropertyValue* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.IPropertyValue", L"GetUInt64", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetUInt64());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IPropertyValue_GetUInt64Array(py::wrapper::Windows::Foundation::IPropertyValue* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.IPropertyValue", L"GetUInt64Array", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                winrt::com_array<uint64_t> param0{};

                self->obj.GetUInt64Array(param0);

                py::pyobj_handle out0{ py::convert(param0) };
                if (!out0)
                {
                    return nullptr;
                }
                return out0.detach();
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IPropertyValue_GetUInt8(py::wrapper::Windows::Foundation::IPropertyValue* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.IPropertyValue", L"GetUInt8", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetUInt8());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IPropertyValue_GetUInt8Array(py::wrapper::Windows::Foundation::IPropertyValue* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.IPropertyValue", L"GetUInt8Array", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                winrt::com_array<uint8_t> param0{};

                self->obj.GetUInt8Array(param0);

                py::pyobj_handle out0{ py::convert(param0) };
                if (!out0)
                {
                    return nullptr;
                }
                return out0.detach();
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IPropertyValue_get_IsNumericScalar(py::wrapper::Windows::Foundation::IPropertyValue* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Foundation.IPropertyValue", L"IsNumericScalar"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsNumericScalar());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IPropertyValue_get_Type(py::wrapper::Windows::Foundation::IPropertyValue* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Foundation.IPropertyValue", L"Type"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Type());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_IPropertyValue(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Foundation::IPropertyValue>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IPropertyValue(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Foundation::IPropertyValue>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IPropertyValue[] = {
        { "get_boolean", reinterpret_cast<PyCFunction>(IPropertyValue_GetBoolean), METH_VARARGS, nullptr },
        { "get_boolean_array", reinterpret_cast<PyCFunction>(IPropertyValue_GetBooleanArray), METH_VARARGS, nullptr },
        { "get_char16", reinterpret_cast<PyCFunction>(IPropertyValue_GetChar16), METH_VARARGS, nullptr },
        { "get_char16_array", reinterpret_cast<PyCFunction>(IPropertyValue_GetChar16Array), METH_VARARGS, nullptr },
        { "get_date_time", reinterpret_cast<PyCFunction>(IPropertyValue_GetDateTime), METH_VARARGS, nullptr },
        { "get_date_time_array", reinterpret_cast<PyCFunction>(IPropertyValue_GetDateTimeArray), METH_VARARGS, nullptr },
        { "get_double", reinterpret_cast<PyCFunction>(IPropertyValue_GetDouble), METH_VARARGS, nullptr },
        { "get_double_array", reinterpret_cast<PyCFunction>(IPropertyValue_GetDoubleArray), METH_VARARGS, nullptr },
        { "get_guid", reinterpret_cast<PyCFunction>(IPropertyValue_GetGuid), METH_VARARGS, nullptr },
        { "get_guid_array", reinterpret_cast<PyCFunction>(IPropertyValue_GetGuidArray), METH_VARARGS, nullptr },
        { "get_inspectable_array", reinterpret_cast<PyCFunction>(IPropertyValue_GetInspectableArray), METH_VARARGS, nullptr },
        { "get_int16", reinterpret_cast<PyCFunction>(IPropertyValue_GetInt16), METH_VARARGS, nullptr },
        { "get_int16_array", reinterpret_cast<PyCFunction>(IPropertyValue_GetInt16Array), METH_VARARGS, nullptr },
        { "get_int32", reinterpret_cast<PyCFunction>(IPropertyValue_GetInt32), METH_VARARGS, nullptr },
        { "get_int32_array", reinterpret_cast<PyCFunction>(IPropertyValue_GetInt32Array), METH_VARARGS, nullptr },
        { "get_int64", reinterpret_cast<PyCFunction>(IPropertyValue_GetInt64), METH_VARARGS, nullptr },
        { "get_int64_array", reinterpret_cast<PyCFunction>(IPropertyValue_GetInt64Array), METH_VARARGS, nullptr },
        { "get_point", reinterpret_cast<PyCFunction>(IPropertyValue_GetPoint), METH_VARARGS, nullptr },
        { "get_point_array", reinterpret_cast<PyCFunction>(IPropertyValue_GetPointArray), METH_VARARGS, nullptr },
        { "get_rect", reinterpret_cast<PyCFunction>(IPropertyValue_GetRect), METH_VARARGS, nullptr },
        { "get_rect_array", reinterpret_cast<PyCFunction>(IPropertyValue_GetRectArray), METH_VARARGS, nullptr },
        { "get_single", reinterpret_cast<PyCFunction>(IPropertyValue_GetSingle), METH_VARARGS, nullptr },
        { "get_single_array", reinterpret_cast<PyCFunction>(IPropertyValue_GetSingleArray), METH_VARARGS, nullptr },
        { "get_size", reinterpret_cast<PyCFunction>(IPropertyValue_GetSize), METH_VARARGS, nullptr },
        { "get_size_array", reinterpret_cast<PyCFunction>(IPropertyValue_GetSizeArray), METH_VARARGS, nullptr },
        { "get_string", reinterpret_cast<PyCFunction>(IPropertyValue_GetString), METH_VARARGS, nullptr },
        { "get_string_array", reinterpret_cast<PyCFunction>(IPropertyValue_GetStringArray), METH_VARARGS, nullptr },
        { "get_time_span", reinterpret_cast<PyCFunction>(IPropertyValue_GetTimeSpan), METH_VARARGS, nullptr },
        { "get_time_span_array", reinterpret_cast<PyCFunction>(IPropertyValue_GetTimeSpanArray), METH_VARARGS, nullptr },
        { "get_uint16", reinterpret_cast<PyCFunction>(IPropertyValue_GetUInt16), METH_VARARGS, nullptr },
        { "get_uint16_array", reinterpret_cast<PyCFunction>(IPropertyValue_GetUInt16Array), METH_VARARGS, nullptr },
        { "get_uint32", reinterpret_cast<PyCFunction>(IPropertyValue_GetUInt32), METH_VARARGS, nullptr },
        { "get_uint32_array", reinterpret_cast<PyCFunction>(IPropertyValue_GetUInt32Array), METH_VARARGS, nullptr },
        { "get_uint64", reinterpret_cast<PyCFunction>(IPropertyValue_GetUInt64), METH_VARARGS, nullptr },
        { "get_uint64_array", reinterpret_cast<PyCFunction>(IPropertyValue_GetUInt64Array), METH_VARARGS, nullptr },
        { "get_uint8", reinterpret_cast<PyCFunction>(IPropertyValue_GetUInt8), METH_VARARGS, nullptr },
        { "get_uint8_array", reinterpret_cast<PyCFunction>(IPropertyValue_GetUInt8Array), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_IPropertyValue, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IPropertyValue), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IPropertyValue[] = {
        { "is_numeric_scalar", reinterpret_cast<getter>(IPropertyValue_get_IsNumericScalar), nullptr, nullptr, nullptr },
        { "type", reinterpret_cast<getter>(IPropertyValue_get_Type), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IPropertyValue[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_IPropertyValue) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IPropertyValue) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IPropertyValue) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IPropertyValue) },
        { },
    };

    static PyType_Spec type_spec_IPropertyValue =
    {
        "winrt._winrt_windows_foundation.IPropertyValue",
        sizeof(py::wrapper::Windows::Foundation::IPropertyValue),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IPropertyValue
    };

    // ----- IReferenceArray interface --------------------

    static PyObject* _new_IReferenceArray(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<py::proj::Windows::Foundation::IReferenceArray>::type_name);
        py::set_invalid_activation_error(py::py_type<py::proj::Windows::Foundation::IReferenceArray>::type_name);
        return nullptr;
    }

    static void _dealloc_IReferenceArray(py::wrapper::Windows::Foundation::IReferenceArray* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        std::destroy_at(&self->impl);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IReferenceArray_GetBoolean(py::wrapper::Windows::Foundation::IReferenceArray* self, PyObject* args) noexcept
    {
        return self->impl->GetBoolean(args);
    }

    static PyObject* IReferenceArray_GetBooleanArray(py::wrapper::Windows::Foundation::IReferenceArray* self, PyObject* args) noexcept
    {
        return self->impl->GetBooleanArray(args);
    }

    static PyObject* IReferenceArray_GetChar16(py::wrapper::Windows::Foundation::IReferenceArray* self, PyObject* args) noexcept
    {
        return self->impl->GetChar16(args);
    }

    static PyObject* IReferenceArray_GetChar16Array(py::wrapper::Windows::Foundation::IReferenceArray* self, PyObject* args) noexcept
    {
        return self->impl->GetChar16Array(args);
    }

    static PyObject* IReferenceArray_GetDateTime(py::wrapper::Windows::Foundation::IReferenceArray* self, PyObject* args) noexcept
    {
        return self->impl->GetDateTime(args);
    }

    static PyObject* IReferenceArray_GetDateTimeArray(py::wrapper::Windows::Foundation::IReferenceArray* self, PyObject* args) noexcept
    {
        return self->impl->GetDateTimeArray(args);
    }

    static PyObject* IReferenceArray_GetDouble(py::wrapper::Windows::Foundation::IReferenceArray* self, PyObject* args) noexcept
    {
        return self->impl->GetDouble(args);
    }

    static PyObject* IReferenceArray_GetDoubleArray(py::wrapper::Windows::Foundation::IReferenceArray* self, PyObject* args) noexcept
    {
        return self->impl->GetDoubleArray(args);
    }

    static PyObject* IReferenceArray_GetGuid(py::wrapper::Windows::Foundation::IReferenceArray* self, PyObject* args) noexcept
    {
        return self->impl->GetGuid(args);
    }

    static PyObject* IReferenceArray_GetGuidArray(py::wrapper::Windows::Foundation::IReferenceArray* self, PyObject* args) noexcept
    {
        return self->impl->GetGuidArray(args);
    }

    static PyObject* IReferenceArray_GetInspectableArray(py::wrapper::Windows::Foundation::IReferenceArray* self, PyObject* args) noexcept
    {
        return self->impl->GetInspectableArray(args);
    }

    static PyObject* IReferenceArray_GetInt16(py::wrapper::Windows::Foundation::IReferenceArray* self, PyObject* args) noexcept
    {
        return self->impl->GetInt16(args);
    }

    static PyObject* IReferenceArray_GetInt16Array(py::wrapper::Windows::Foundation::IReferenceArray* self, PyObject* args) noexcept
    {
        return self->impl->GetInt16Array(args);
    }

    static PyObject* IReferenceArray_GetInt32(py::wrapper::Windows::Foundation::IReferenceArray* self, PyObject* args) noexcept
    {
        return self->impl->GetInt32(args);
    }

    static PyObject* IReferenceArray_GetInt32Array(py::wrapper::Windows::Foundation::IReferenceArray* self, PyObject* args) noexcept
    {
        return self->impl->GetInt32Array(args);
    }

    static PyObject* IReferenceArray_GetInt64(py::wrapper::Windows::Foundation::IReferenceArray* self, PyObject* args) noexcept
    {
        return self->impl->GetInt64(args);
    }

    static PyObject* IReferenceArray_GetInt64Array(py::wrapper::Windows::Foundation::IReferenceArray* self, PyObject* args) noexcept
    {
        return self->impl->GetInt64Array(args);
    }

    static PyObject* IReferenceArray_GetPoint(py::wrapper::Windows::Foundation::IReferenceArray* self, PyObject* args) noexcept
    {
        return self->impl->GetPoint(args);
    }

    static PyObject* IReferenceArray_GetPointArray(py::wrapper::Windows::Foundation::IReferenceArray* self, PyObject* args) noexcept
    {
        return self->impl->GetPointArray(args);
    }

    static PyObject* IReferenceArray_GetRect(py::wrapper::Windows::Foundation::IReferenceArray* self, PyObject* args) noexcept
    {
        return self->impl->GetRect(args);
    }

    static PyObject* IReferenceArray_GetRectArray(py::wrapper::Windows::Foundation::IReferenceArray* self, PyObject* args) noexcept
    {
        return self->impl->GetRectArray(args);
    }

    static PyObject* IReferenceArray_GetSingle(py::wrapper::Windows::Foundation::IReferenceArray* self, PyObject* args) noexcept
    {
        return self->impl->GetSingle(args);
    }

    static PyObject* IReferenceArray_GetSingleArray(py::wrapper::Windows::Foundation::IReferenceArray* self, PyObject* args) noexcept
    {
        return self->impl->GetSingleArray(args);
    }

    static PyObject* IReferenceArray_GetSize(py::wrapper::Windows::Foundation::IReferenceArray* self, PyObject* args) noexcept
    {
        return self->impl->GetSize(args);
    }

    static PyObject* IReferenceArray_GetSizeArray(py::wrapper::Windows::Foundation::IReferenceArray* self, PyObject* args) noexcept
    {
        return self->impl->GetSizeArray(args);
    }

    static PyObject* IReferenceArray_GetString(py::wrapper::Windows::Foundation::IReferenceArray* self, PyObject* args) noexcept
    {
        return self->impl->GetString(args);
    }

    static PyObject* IReferenceArray_GetStringArray(py::wrapper::Windows::Foundation::IReferenceArray* self, PyObject* args) noexcept
    {
        return self->impl->GetStringArray(args);
    }

    static PyObject* IReferenceArray_GetTimeSpan(py::wrapper::Windows::Foundation::IReferenceArray* self, PyObject* args) noexcept
    {
        return self->impl->GetTimeSpan(args);
    }

    static PyObject* IReferenceArray_GetTimeSpanArray(py::wrapper::Windows::Foundation::IReferenceArray* self, PyObject* args) noexcept
    {
        return self->impl->GetTimeSpanArray(args);
    }

    static PyObject* IReferenceArray_GetUInt16(py::wrapper::Windows::Foundation::IReferenceArray* self, PyObject* args) noexcept
    {
        return self->impl->GetUInt16(args);
    }

    static PyObject* IReferenceArray_GetUInt16Array(py::wrapper::Windows::Foundation::IReferenceArray* self, PyObject* args) noexcept
    {
        return self->impl->GetUInt16Array(args);
    }

    static PyObject* IReferenceArray_GetUInt32(py::wrapper::Windows::Foundation::IReferenceArray* self, PyObject* args) noexcept
    {
        return self->impl->GetUInt32(args);
    }

    static PyObject* IReferenceArray_GetUInt32Array(py::wrapper::Windows::Foundation::IReferenceArray* self, PyObject* args) noexcept
    {
        return self->impl->GetUInt32Array(args);
    }

    static PyObject* IReferenceArray_GetUInt64(py::wrapper::Windows::Foundation::IReferenceArray* self, PyObject* args) noexcept
    {
        return self->impl->GetUInt64(args);
    }

    static PyObject* IReferenceArray_GetUInt64Array(py::wrapper::Windows::Foundation::IReferenceArray* self, PyObject* args) noexcept
    {
        return self->impl->GetUInt64Array(args);
    }

    static PyObject* IReferenceArray_GetUInt8(py::wrapper::Windows::Foundation::IReferenceArray* self, PyObject* args) noexcept
    {
        return self->impl->GetUInt8(args);
    }

    static PyObject* IReferenceArray_GetUInt8Array(py::wrapper::Windows::Foundation::IReferenceArray* self, PyObject* args) noexcept
    {
        return self->impl->GetUInt8Array(args);
    }

    static PyObject* IReferenceArray_get_Value(py::wrapper::Windows::Foundation::IReferenceArray* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Foundation.IReferenceArray`1", L"Value"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return self->impl->get_Value();
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IReferenceArray_get_IsNumericScalar(py::wrapper::Windows::Foundation::IReferenceArray* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Foundation.IPropertyValue", L"IsNumericScalar"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return self->impl->get_IsNumericScalar();
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IReferenceArray_get_Type(py::wrapper::Windows::Foundation::IReferenceArray* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Foundation.IPropertyValue", L"Type"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return self->impl->get_Type();
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IReferenceArray[] = {
        { "get_boolean", reinterpret_cast<PyCFunction>(IReferenceArray_GetBoolean), METH_VARARGS, nullptr },
        { "get_boolean_array", reinterpret_cast<PyCFunction>(IReferenceArray_GetBooleanArray), METH_VARARGS, nullptr },
        { "get_char16", reinterpret_cast<PyCFunction>(IReferenceArray_GetChar16), METH_VARARGS, nullptr },
        { "get_char16_array", reinterpret_cast<PyCFunction>(IReferenceArray_GetChar16Array), METH_VARARGS, nullptr },
        { "get_date_time", reinterpret_cast<PyCFunction>(IReferenceArray_GetDateTime), METH_VARARGS, nullptr },
        { "get_date_time_array", reinterpret_cast<PyCFunction>(IReferenceArray_GetDateTimeArray), METH_VARARGS, nullptr },
        { "get_double", reinterpret_cast<PyCFunction>(IReferenceArray_GetDouble), METH_VARARGS, nullptr },
        { "get_double_array", reinterpret_cast<PyCFunction>(IReferenceArray_GetDoubleArray), METH_VARARGS, nullptr },
        { "get_guid", reinterpret_cast<PyCFunction>(IReferenceArray_GetGuid), METH_VARARGS, nullptr },
        { "get_guid_array", reinterpret_cast<PyCFunction>(IReferenceArray_GetGuidArray), METH_VARARGS, nullptr },
        { "get_inspectable_array", reinterpret_cast<PyCFunction>(IReferenceArray_GetInspectableArray), METH_VARARGS, nullptr },
        { "get_int16", reinterpret_cast<PyCFunction>(IReferenceArray_GetInt16), METH_VARARGS, nullptr },
        { "get_int16_array", reinterpret_cast<PyCFunction>(IReferenceArray_GetInt16Array), METH_VARARGS, nullptr },
        { "get_int32", reinterpret_cast<PyCFunction>(IReferenceArray_GetInt32), METH_VARARGS, nullptr },
        { "get_int32_array", reinterpret_cast<PyCFunction>(IReferenceArray_GetInt32Array), METH_VARARGS, nullptr },
        { "get_int64", reinterpret_cast<PyCFunction>(IReferenceArray_GetInt64), METH_VARARGS, nullptr },
        { "get_int64_array", reinterpret_cast<PyCFunction>(IReferenceArray_GetInt64Array), METH_VARARGS, nullptr },
        { "get_point", reinterpret_cast<PyCFunction>(IReferenceArray_GetPoint), METH_VARARGS, nullptr },
        { "get_point_array", reinterpret_cast<PyCFunction>(IReferenceArray_GetPointArray), METH_VARARGS, nullptr },
        { "get_rect", reinterpret_cast<PyCFunction>(IReferenceArray_GetRect), METH_VARARGS, nullptr },
        { "get_rect_array", reinterpret_cast<PyCFunction>(IReferenceArray_GetRectArray), METH_VARARGS, nullptr },
        { "get_single", reinterpret_cast<PyCFunction>(IReferenceArray_GetSingle), METH_VARARGS, nullptr },
        { "get_single_array", reinterpret_cast<PyCFunction>(IReferenceArray_GetSingleArray), METH_VARARGS, nullptr },
        { "get_size", reinterpret_cast<PyCFunction>(IReferenceArray_GetSize), METH_VARARGS, nullptr },
        { "get_size_array", reinterpret_cast<PyCFunction>(IReferenceArray_GetSizeArray), METH_VARARGS, nullptr },
        { "get_string", reinterpret_cast<PyCFunction>(IReferenceArray_GetString), METH_VARARGS, nullptr },
        { "get_string_array", reinterpret_cast<PyCFunction>(IReferenceArray_GetStringArray), METH_VARARGS, nullptr },
        { "get_time_span", reinterpret_cast<PyCFunction>(IReferenceArray_GetTimeSpan), METH_VARARGS, nullptr },
        { "get_time_span_array", reinterpret_cast<PyCFunction>(IReferenceArray_GetTimeSpanArray), METH_VARARGS, nullptr },
        { "get_uint16", reinterpret_cast<PyCFunction>(IReferenceArray_GetUInt16), METH_VARARGS, nullptr },
        { "get_uint16_array", reinterpret_cast<PyCFunction>(IReferenceArray_GetUInt16Array), METH_VARARGS, nullptr },
        { "get_uint32", reinterpret_cast<PyCFunction>(IReferenceArray_GetUInt32), METH_VARARGS, nullptr },
        { "get_uint32_array", reinterpret_cast<PyCFunction>(IReferenceArray_GetUInt32Array), METH_VARARGS, nullptr },
        { "get_uint64", reinterpret_cast<PyCFunction>(IReferenceArray_GetUInt64), METH_VARARGS, nullptr },
        { "get_uint64_array", reinterpret_cast<PyCFunction>(IReferenceArray_GetUInt64Array), METH_VARARGS, nullptr },
        { "get_uint8", reinterpret_cast<PyCFunction>(IReferenceArray_GetUInt8), METH_VARARGS, nullptr },
        { "get_uint8_array", reinterpret_cast<PyCFunction>(IReferenceArray_GetUInt8Array), METH_VARARGS, nullptr },
        { "__class_getitem__", Py_GenericAlias, METH_O | METH_CLASS, PyDoc_STR("See PEP 585") },
        { }
    };

    static PyGetSetDef _getset_IReferenceArray[] = {
        { "value", reinterpret_cast<getter>(IReferenceArray_get_Value), nullptr, nullptr, nullptr },
        { "is_numeric_scalar", reinterpret_cast<getter>(IReferenceArray_get_IsNumericScalar), nullptr, nullptr, nullptr },
        { "type", reinterpret_cast<getter>(IReferenceArray_get_Type), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IReferenceArray[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_IReferenceArray) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IReferenceArray) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IReferenceArray) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IReferenceArray) },
        { },
    };

    static PyType_Spec type_spec_IReferenceArray =
    {
        "winrt._winrt_windows_foundation.IReferenceArray",
        sizeof(py::wrapper::Windows::Foundation::IReferenceArray),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IReferenceArray
    };

    // ----- IReference interface --------------------

    static PyObject* _new_IReference(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<py::proj::Windows::Foundation::IReference>::type_name);
        py::set_invalid_activation_error(py::py_type<py::proj::Windows::Foundation::IReference>::type_name);
        return nullptr;
    }

    static void _dealloc_IReference(py::wrapper::Windows::Foundation::IReference* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        std::destroy_at(&self->impl);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IReference_GetBoolean(py::wrapper::Windows::Foundation::IReference* self, PyObject* args) noexcept
    {
        return self->impl->GetBoolean(args);
    }

    static PyObject* IReference_GetBooleanArray(py::wrapper::Windows::Foundation::IReference* self, PyObject* args) noexcept
    {
        return self->impl->GetBooleanArray(args);
    }

    static PyObject* IReference_GetChar16(py::wrapper::Windows::Foundation::IReference* self, PyObject* args) noexcept
    {
        return self->impl->GetChar16(args);
    }

    static PyObject* IReference_GetChar16Array(py::wrapper::Windows::Foundation::IReference* self, PyObject* args) noexcept
    {
        return self->impl->GetChar16Array(args);
    }

    static PyObject* IReference_GetDateTime(py::wrapper::Windows::Foundation::IReference* self, PyObject* args) noexcept
    {
        return self->impl->GetDateTime(args);
    }

    static PyObject* IReference_GetDateTimeArray(py::wrapper::Windows::Foundation::IReference* self, PyObject* args) noexcept
    {
        return self->impl->GetDateTimeArray(args);
    }

    static PyObject* IReference_GetDouble(py::wrapper::Windows::Foundation::IReference* self, PyObject* args) noexcept
    {
        return self->impl->GetDouble(args);
    }

    static PyObject* IReference_GetDoubleArray(py::wrapper::Windows::Foundation::IReference* self, PyObject* args) noexcept
    {
        return self->impl->GetDoubleArray(args);
    }

    static PyObject* IReference_GetGuid(py::wrapper::Windows::Foundation::IReference* self, PyObject* args) noexcept
    {
        return self->impl->GetGuid(args);
    }

    static PyObject* IReference_GetGuidArray(py::wrapper::Windows::Foundation::IReference* self, PyObject* args) noexcept
    {
        return self->impl->GetGuidArray(args);
    }

    static PyObject* IReference_GetInspectableArray(py::wrapper::Windows::Foundation::IReference* self, PyObject* args) noexcept
    {
        return self->impl->GetInspectableArray(args);
    }

    static PyObject* IReference_GetInt16(py::wrapper::Windows::Foundation::IReference* self, PyObject* args) noexcept
    {
        return self->impl->GetInt16(args);
    }

    static PyObject* IReference_GetInt16Array(py::wrapper::Windows::Foundation::IReference* self, PyObject* args) noexcept
    {
        return self->impl->GetInt16Array(args);
    }

    static PyObject* IReference_GetInt32(py::wrapper::Windows::Foundation::IReference* self, PyObject* args) noexcept
    {
        return self->impl->GetInt32(args);
    }

    static PyObject* IReference_GetInt32Array(py::wrapper::Windows::Foundation::IReference* self, PyObject* args) noexcept
    {
        return self->impl->GetInt32Array(args);
    }

    static PyObject* IReference_GetInt64(py::wrapper::Windows::Foundation::IReference* self, PyObject* args) noexcept
    {
        return self->impl->GetInt64(args);
    }

    static PyObject* IReference_GetInt64Array(py::wrapper::Windows::Foundation::IReference* self, PyObject* args) noexcept
    {
        return self->impl->GetInt64Array(args);
    }

    static PyObject* IReference_GetPoint(py::wrapper::Windows::Foundation::IReference* self, PyObject* args) noexcept
    {
        return self->impl->GetPoint(args);
    }

    static PyObject* IReference_GetPointArray(py::wrapper::Windows::Foundation::IReference* self, PyObject* args) noexcept
    {
        return self->impl->GetPointArray(args);
    }

    static PyObject* IReference_GetRect(py::wrapper::Windows::Foundation::IReference* self, PyObject* args) noexcept
    {
        return self->impl->GetRect(args);
    }

    static PyObject* IReference_GetRectArray(py::wrapper::Windows::Foundation::IReference* self, PyObject* args) noexcept
    {
        return self->impl->GetRectArray(args);
    }

    static PyObject* IReference_GetSingle(py::wrapper::Windows::Foundation::IReference* self, PyObject* args) noexcept
    {
        return self->impl->GetSingle(args);
    }

    static PyObject* IReference_GetSingleArray(py::wrapper::Windows::Foundation::IReference* self, PyObject* args) noexcept
    {
        return self->impl->GetSingleArray(args);
    }

    static PyObject* IReference_GetSize(py::wrapper::Windows::Foundation::IReference* self, PyObject* args) noexcept
    {
        return self->impl->GetSize(args);
    }

    static PyObject* IReference_GetSizeArray(py::wrapper::Windows::Foundation::IReference* self, PyObject* args) noexcept
    {
        return self->impl->GetSizeArray(args);
    }

    static PyObject* IReference_GetString(py::wrapper::Windows::Foundation::IReference* self, PyObject* args) noexcept
    {
        return self->impl->GetString(args);
    }

    static PyObject* IReference_GetStringArray(py::wrapper::Windows::Foundation::IReference* self, PyObject* args) noexcept
    {
        return self->impl->GetStringArray(args);
    }

    static PyObject* IReference_GetTimeSpan(py::wrapper::Windows::Foundation::IReference* self, PyObject* args) noexcept
    {
        return self->impl->GetTimeSpan(args);
    }

    static PyObject* IReference_GetTimeSpanArray(py::wrapper::Windows::Foundation::IReference* self, PyObject* args) noexcept
    {
        return self->impl->GetTimeSpanArray(args);
    }

    static PyObject* IReference_GetUInt16(py::wrapper::Windows::Foundation::IReference* self, PyObject* args) noexcept
    {
        return self->impl->GetUInt16(args);
    }

    static PyObject* IReference_GetUInt16Array(py::wrapper::Windows::Foundation::IReference* self, PyObject* args) noexcept
    {
        return self->impl->GetUInt16Array(args);
    }

    static PyObject* IReference_GetUInt32(py::wrapper::Windows::Foundation::IReference* self, PyObject* args) noexcept
    {
        return self->impl->GetUInt32(args);
    }

    static PyObject* IReference_GetUInt32Array(py::wrapper::Windows::Foundation::IReference* self, PyObject* args) noexcept
    {
        return self->impl->GetUInt32Array(args);
    }

    static PyObject* IReference_GetUInt64(py::wrapper::Windows::Foundation::IReference* self, PyObject* args) noexcept
    {
        return self->impl->GetUInt64(args);
    }

    static PyObject* IReference_GetUInt64Array(py::wrapper::Windows::Foundation::IReference* self, PyObject* args) noexcept
    {
        return self->impl->GetUInt64Array(args);
    }

    static PyObject* IReference_GetUInt8(py::wrapper::Windows::Foundation::IReference* self, PyObject* args) noexcept
    {
        return self->impl->GetUInt8(args);
    }

    static PyObject* IReference_GetUInt8Array(py::wrapper::Windows::Foundation::IReference* self, PyObject* args) noexcept
    {
        return self->impl->GetUInt8Array(args);
    }

    static PyObject* IReference_get_Value(py::wrapper::Windows::Foundation::IReference* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Foundation.IReference`1", L"Value"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return self->impl->get_Value();
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IReference_get_IsNumericScalar(py::wrapper::Windows::Foundation::IReference* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Foundation.IPropertyValue", L"IsNumericScalar"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return self->impl->get_IsNumericScalar();
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IReference_get_Type(py::wrapper::Windows::Foundation::IReference* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Foundation.IPropertyValue", L"Type"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return self->impl->get_Type();
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IReference[] = {
        { "get_boolean", reinterpret_cast<PyCFunction>(IReference_GetBoolean), METH_VARARGS, nullptr },
        { "get_boolean_array", reinterpret_cast<PyCFunction>(IReference_GetBooleanArray), METH_VARARGS, nullptr },
        { "get_char16", reinterpret_cast<PyCFunction>(IReference_GetChar16), METH_VARARGS, nullptr },
        { "get_char16_array", reinterpret_cast<PyCFunction>(IReference_GetChar16Array), METH_VARARGS, nullptr },
        { "get_date_time", reinterpret_cast<PyCFunction>(IReference_GetDateTime), METH_VARARGS, nullptr },
        { "get_date_time_array", reinterpret_cast<PyCFunction>(IReference_GetDateTimeArray), METH_VARARGS, nullptr },
        { "get_double", reinterpret_cast<PyCFunction>(IReference_GetDouble), METH_VARARGS, nullptr },
        { "get_double_array", reinterpret_cast<PyCFunction>(IReference_GetDoubleArray), METH_VARARGS, nullptr },
        { "get_guid", reinterpret_cast<PyCFunction>(IReference_GetGuid), METH_VARARGS, nullptr },
        { "get_guid_array", reinterpret_cast<PyCFunction>(IReference_GetGuidArray), METH_VARARGS, nullptr },
        { "get_inspectable_array", reinterpret_cast<PyCFunction>(IReference_GetInspectableArray), METH_VARARGS, nullptr },
        { "get_int16", reinterpret_cast<PyCFunction>(IReference_GetInt16), METH_VARARGS, nullptr },
        { "get_int16_array", reinterpret_cast<PyCFunction>(IReference_GetInt16Array), METH_VARARGS, nullptr },
        { "get_int32", reinterpret_cast<PyCFunction>(IReference_GetInt32), METH_VARARGS, nullptr },
        { "get_int32_array", reinterpret_cast<PyCFunction>(IReference_GetInt32Array), METH_VARARGS, nullptr },
        { "get_int64", reinterpret_cast<PyCFunction>(IReference_GetInt64), METH_VARARGS, nullptr },
        { "get_int64_array", reinterpret_cast<PyCFunction>(IReference_GetInt64Array), METH_VARARGS, nullptr },
        { "get_point", reinterpret_cast<PyCFunction>(IReference_GetPoint), METH_VARARGS, nullptr },
        { "get_point_array", reinterpret_cast<PyCFunction>(IReference_GetPointArray), METH_VARARGS, nullptr },
        { "get_rect", reinterpret_cast<PyCFunction>(IReference_GetRect), METH_VARARGS, nullptr },
        { "get_rect_array", reinterpret_cast<PyCFunction>(IReference_GetRectArray), METH_VARARGS, nullptr },
        { "get_single", reinterpret_cast<PyCFunction>(IReference_GetSingle), METH_VARARGS, nullptr },
        { "get_single_array", reinterpret_cast<PyCFunction>(IReference_GetSingleArray), METH_VARARGS, nullptr },
        { "get_size", reinterpret_cast<PyCFunction>(IReference_GetSize), METH_VARARGS, nullptr },
        { "get_size_array", reinterpret_cast<PyCFunction>(IReference_GetSizeArray), METH_VARARGS, nullptr },
        { "get_string", reinterpret_cast<PyCFunction>(IReference_GetString), METH_VARARGS, nullptr },
        { "get_string_array", reinterpret_cast<PyCFunction>(IReference_GetStringArray), METH_VARARGS, nullptr },
        { "get_time_span", reinterpret_cast<PyCFunction>(IReference_GetTimeSpan), METH_VARARGS, nullptr },
        { "get_time_span_array", reinterpret_cast<PyCFunction>(IReference_GetTimeSpanArray), METH_VARARGS, nullptr },
        { "get_uint16", reinterpret_cast<PyCFunction>(IReference_GetUInt16), METH_VARARGS, nullptr },
        { "get_uint16_array", reinterpret_cast<PyCFunction>(IReference_GetUInt16Array), METH_VARARGS, nullptr },
        { "get_uint32", reinterpret_cast<PyCFunction>(IReference_GetUInt32), METH_VARARGS, nullptr },
        { "get_uint32_array", reinterpret_cast<PyCFunction>(IReference_GetUInt32Array), METH_VARARGS, nullptr },
        { "get_uint64", reinterpret_cast<PyCFunction>(IReference_GetUInt64), METH_VARARGS, nullptr },
        { "get_uint64_array", reinterpret_cast<PyCFunction>(IReference_GetUInt64Array), METH_VARARGS, nullptr },
        { "get_uint8", reinterpret_cast<PyCFunction>(IReference_GetUInt8), METH_VARARGS, nullptr },
        { "get_uint8_array", reinterpret_cast<PyCFunction>(IReference_GetUInt8Array), METH_VARARGS, nullptr },
        { "__class_getitem__", Py_GenericAlias, METH_O | METH_CLASS, PyDoc_STR("See PEP 585") },
        { }
    };

    static PyGetSetDef _getset_IReference[] = {
        { "value", reinterpret_cast<getter>(IReference_get_Value), nullptr, nullptr, nullptr },
        { "is_numeric_scalar", reinterpret_cast<getter>(IReference_get_IsNumericScalar), nullptr, nullptr, nullptr },
        { "type", reinterpret_cast<getter>(IReference_get_Type), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IReference[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_IReference) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IReference) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IReference) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IReference) },
        { },
    };

    static PyType_Spec type_spec_IReference =
    {
        "winrt._winrt_windows_foundation.IReference",
        sizeof(py::wrapper::Windows::Foundation::IReference),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IReference
    };

    // ----- IStringable interface --------------------

    static PyObject* _new_IStringable(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Foundation::IStringable>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Foundation::IStringable>::type_name);
        return nullptr;
    }

    static void _dealloc_IStringable(py::wrapper::Windows::Foundation::IStringable* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IStringable_ToString(py::wrapper::Windows::Foundation::IStringable* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.IStringable", L"ToString", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.ToString());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_IStringable(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Foundation::IStringable>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IStringable(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Foundation::IStringable>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _str_IStringable(py::wrapper::Windows::Foundation::IStringable* self) noexcept
    {
        try
        {
            return py::convert(self->obj.ToString());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IStringable[] = {
        { "to_string", reinterpret_cast<PyCFunction>(IStringable_ToString), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_IStringable, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IStringable), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IStringable[] = {
        { }
    };

    static PyType_Slot _type_slots_IStringable[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_IStringable) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IStringable) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IStringable) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IStringable) },
        { Py_tp_str, reinterpret_cast<void*>(_str_IStringable) },
        { },
    };

    static PyType_Spec type_spec_IStringable =
    {
        "winrt._winrt_windows_foundation.IStringable",
        sizeof(py::wrapper::Windows::Foundation::IStringable),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IStringable
    };

    // ----- IWwwFormUrlDecoderEntry interface --------------------

    static PyObject* _new_IWwwFormUrlDecoderEntry(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Foundation::IWwwFormUrlDecoderEntry>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Foundation::IWwwFormUrlDecoderEntry>::type_name);
        return nullptr;
    }

    static void _dealloc_IWwwFormUrlDecoderEntry(py::wrapper::Windows::Foundation::IWwwFormUrlDecoderEntry* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IWwwFormUrlDecoderEntry_get_Name(py::wrapper::Windows::Foundation::IWwwFormUrlDecoderEntry* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Foundation.IWwwFormUrlDecoderEntry", L"Name"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Name());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IWwwFormUrlDecoderEntry_get_Value(py::wrapper::Windows::Foundation::IWwwFormUrlDecoderEntry* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Foundation.IWwwFormUrlDecoderEntry", L"Value"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Value());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_IWwwFormUrlDecoderEntry(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Foundation::IWwwFormUrlDecoderEntry>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IWwwFormUrlDecoderEntry(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Foundation::IWwwFormUrlDecoderEntry>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IWwwFormUrlDecoderEntry[] = {
        { "_assign_array_", _assign_array_IWwwFormUrlDecoderEntry, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IWwwFormUrlDecoderEntry), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IWwwFormUrlDecoderEntry[] = {
        { "name", reinterpret_cast<getter>(IWwwFormUrlDecoderEntry_get_Name), nullptr, nullptr, nullptr },
        { "value", reinterpret_cast<getter>(IWwwFormUrlDecoderEntry_get_Value), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IWwwFormUrlDecoderEntry[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_IWwwFormUrlDecoderEntry) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IWwwFormUrlDecoderEntry) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IWwwFormUrlDecoderEntry) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IWwwFormUrlDecoderEntry) },
        { },
    };

    static PyType_Spec type_spec_IWwwFormUrlDecoderEntry =
    {
        "winrt._winrt_windows_foundation.IWwwFormUrlDecoderEntry",
        sizeof(py::wrapper::Windows::Foundation::IWwwFormUrlDecoderEntry),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IWwwFormUrlDecoderEntry
    };

    // ----- EventRegistrationToken struct --------------------

    winrt_struct_wrapper<winrt::event_token>* _new_EventRegistrationToken(PyTypeObject* subclass, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        auto self = reinterpret_cast<winrt_struct_wrapper<winrt::event_token>*>(subclass->tp_alloc(subclass, 0));

        if (!self)
        {
            return nullptr;
        }

        std::construct_at(&self->obj);

        return self;
    }

    int _init_EventRegistrationToken(winrt_struct_wrapper<winrt::event_token>* self, PyObject* args, PyObject* kwds) noexcept
    {
        auto tuple_size = PyTuple_Size(args);

        if ((tuple_size == 0) && (kwds == nullptr))
        {
            self->obj = {};
            return 0;
        }

        int64_t _Value{};

        static const char* kwlist[] = {"value", nullptr};
        if (!PyArg_ParseTupleAndKeywords(args, kwds, "L", const_cast<char**>(kwlist), &_Value))
        {
            return -1;
        }

        try
        {
            self->obj = {_Value};
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static void _dealloc_EventRegistrationToken(py::wrapper::Windows::Foundation::EventRegistrationToken* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_EventRegistrationToken(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::event_token>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyMethodDef _methods_EventRegistrationToken[] = {
        { "_assign_array_", _assign_array_EventRegistrationToken, METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyObject* EventRegistrationToken_get_Value(py::wrapper::Windows::Foundation::EventRegistrationToken* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(custom_get(self->obj));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EventRegistrationToken_set_Value(py::wrapper::Windows::Foundation::EventRegistrationToken* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            custom_set(self->obj, py::converter<int64_t>::convert_to(arg));
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyGetSetDef _getset_EventRegistrationToken[] = {
        { "value", reinterpret_cast<getter>(EventRegistrationToken_get_Value), reinterpret_cast<setter>(EventRegistrationToken_set_Value), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_EventRegistrationToken[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_EventRegistrationToken) },
        { Py_tp_init, reinterpret_cast<void*>(_init_EventRegistrationToken) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_EventRegistrationToken) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_EventRegistrationToken) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_EventRegistrationToken) },
        { },
    };

    static PyType_Spec type_spec_EventRegistrationToken =
    {
        "winrt._winrt_windows_foundation.EventRegistrationToken",
        sizeof(py::wrapper::Windows::Foundation::EventRegistrationToken),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_EventRegistrationToken
    };

    // ----- HResult struct --------------------

    winrt_struct_wrapper<winrt::hresult>* _new_HResult(PyTypeObject* subclass, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        auto self = reinterpret_cast<winrt_struct_wrapper<winrt::hresult>*>(subclass->tp_alloc(subclass, 0));

        if (!self)
        {
            return nullptr;
        }

        std::construct_at(&self->obj);

        return self;
    }

    int _init_HResult(winrt_struct_wrapper<winrt::hresult>* self, PyObject* args, PyObject* kwds) noexcept
    {
        auto tuple_size = PyTuple_Size(args);

        if ((tuple_size == 0) && (kwds == nullptr))
        {
            self->obj = {};
            return 0;
        }

        int32_t _Value{};

        static const char* kwlist[] = {"value", nullptr};
        if (!PyArg_ParseTupleAndKeywords(args, kwds, "i", const_cast<char**>(kwlist), &_Value))
        {
            return -1;
        }

        try
        {
            self->obj = {_Value};
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static void _dealloc_HResult(py::wrapper::Windows::Foundation::HResult* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_HResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::hresult>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyMethodDef _methods_HResult[] = {
        { "_assign_array_", _assign_array_HResult, METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyObject* HResult_get_Value(py::wrapper::Windows::Foundation::HResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(custom_get(self->obj));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int HResult_set_Value(py::wrapper::Windows::Foundation::HResult* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            custom_set(self->obj, py::converter<int32_t>::convert_to(arg));
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyGetSetDef _getset_HResult[] = {
        { "value", reinterpret_cast<getter>(HResult_get_Value), reinterpret_cast<setter>(HResult_set_Value), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_HResult[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_HResult) },
        { Py_tp_init, reinterpret_cast<void*>(_init_HResult) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_HResult) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_HResult) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_HResult) },
        { },
    };

    static PyType_Spec type_spec_HResult =
    {
        "winrt._winrt_windows_foundation.HResult",
        sizeof(py::wrapper::Windows::Foundation::HResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_HResult
    };

    // ----- Point struct --------------------

    winrt_struct_wrapper<winrt::Windows::Foundation::Point>* _new_Point(PyTypeObject* subclass, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        auto self = reinterpret_cast<winrt_struct_wrapper<winrt::Windows::Foundation::Point>*>(subclass->tp_alloc(subclass, 0));

        if (!self)
        {
            return nullptr;
        }

        std::construct_at(&self->obj);

        return self;
    }

    int _init_Point(winrt_struct_wrapper<winrt::Windows::Foundation::Point>* self, PyObject* args, PyObject* kwds) noexcept
    {
        auto tuple_size = PyTuple_Size(args);

        if ((tuple_size == 0) && (kwds == nullptr))
        {
            self->obj = {};
            return 0;
        }

        float _X{};
        float _Y{};

        static const char* kwlist[] = {"x", "y", nullptr};
        if (!PyArg_ParseTupleAndKeywords(args, kwds, "ff", const_cast<char**>(kwlist), &_X, &_Y))
        {
            return -1;
        }

        try
        {
            self->obj = {_X, _Y};
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static void _dealloc_Point(py::wrapper::Windows::Foundation::Point* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_Point(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Foundation::Point>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyMethodDef _methods_Point[] = {
        { "_assign_array_", _assign_array_Point, METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyObject* Point_get_X(py::wrapper::Windows::Foundation::Point* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.X);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Point_set_X(py::wrapper::Windows::Foundation::Point* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.X = py::converter<float>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Point_get_Y(py::wrapper::Windows::Foundation::Point* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Y);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Point_set_Y(py::wrapper::Windows::Foundation::Point* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.Y = py::converter<float>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyGetSetDef _getset_Point[] = {
        { "x", reinterpret_cast<getter>(Point_get_X), reinterpret_cast<setter>(Point_set_X), nullptr, nullptr },
        { "y", reinterpret_cast<getter>(Point_get_Y), reinterpret_cast<setter>(Point_set_Y), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_Point[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_Point) },
        { Py_tp_init, reinterpret_cast<void*>(_init_Point) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_Point) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_Point) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_Point) },
        { },
    };

    static PyType_Spec type_spec_Point =
    {
        "winrt._winrt_windows_foundation.Point",
        sizeof(py::wrapper::Windows::Foundation::Point),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_Point
    };

    // ----- Rect struct --------------------

    winrt_struct_wrapper<winrt::Windows::Foundation::Rect>* _new_Rect(PyTypeObject* subclass, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        auto self = reinterpret_cast<winrt_struct_wrapper<winrt::Windows::Foundation::Rect>*>(subclass->tp_alloc(subclass, 0));

        if (!self)
        {
            return nullptr;
        }

        std::construct_at(&self->obj);

        return self;
    }

    int _init_Rect(winrt_struct_wrapper<winrt::Windows::Foundation::Rect>* self, PyObject* args, PyObject* kwds) noexcept
    {
        auto tuple_size = PyTuple_Size(args);

        if ((tuple_size == 0) && (kwds == nullptr))
        {
            self->obj = {};
            return 0;
        }

        float _X{};
        float _Y{};
        float _Width{};
        float _Height{};

        static const char* kwlist[] = {"x", "y", "width", "height", nullptr};
        if (!PyArg_ParseTupleAndKeywords(args, kwds, "ffff", const_cast<char**>(kwlist), &_X, &_Y, &_Width, &_Height))
        {
            return -1;
        }

        try
        {
            self->obj = {_X, _Y, _Width, _Height};
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static void _dealloc_Rect(py::wrapper::Windows::Foundation::Rect* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_Rect(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Foundation::Rect>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyMethodDef _methods_Rect[] = {
        { "_assign_array_", _assign_array_Rect, METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyObject* Rect_get_X(py::wrapper::Windows::Foundation::Rect* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.X);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Rect_set_X(py::wrapper::Windows::Foundation::Rect* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.X = py::converter<float>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Rect_get_Y(py::wrapper::Windows::Foundation::Rect* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Y);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Rect_set_Y(py::wrapper::Windows::Foundation::Rect* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.Y = py::converter<float>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Rect_get_Width(py::wrapper::Windows::Foundation::Rect* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Width);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Rect_set_Width(py::wrapper::Windows::Foundation::Rect* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.Width = py::converter<float>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Rect_get_Height(py::wrapper::Windows::Foundation::Rect* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Height);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Rect_set_Height(py::wrapper::Windows::Foundation::Rect* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.Height = py::converter<float>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyGetSetDef _getset_Rect[] = {
        { "x", reinterpret_cast<getter>(Rect_get_X), reinterpret_cast<setter>(Rect_set_X), nullptr, nullptr },
        { "y", reinterpret_cast<getter>(Rect_get_Y), reinterpret_cast<setter>(Rect_set_Y), nullptr, nullptr },
        { "width", reinterpret_cast<getter>(Rect_get_Width), reinterpret_cast<setter>(Rect_set_Width), nullptr, nullptr },
        { "height", reinterpret_cast<getter>(Rect_get_Height), reinterpret_cast<setter>(Rect_set_Height), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_Rect[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_Rect) },
        { Py_tp_init, reinterpret_cast<void*>(_init_Rect) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_Rect) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_Rect) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_Rect) },
        { },
    };

    static PyType_Spec type_spec_Rect =
    {
        "winrt._winrt_windows_foundation.Rect",
        sizeof(py::wrapper::Windows::Foundation::Rect),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_Rect
    };

    // ----- Size struct --------------------

    winrt_struct_wrapper<winrt::Windows::Foundation::Size>* _new_Size(PyTypeObject* subclass, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        auto self = reinterpret_cast<winrt_struct_wrapper<winrt::Windows::Foundation::Size>*>(subclass->tp_alloc(subclass, 0));

        if (!self)
        {
            return nullptr;
        }

        std::construct_at(&self->obj);

        return self;
    }

    int _init_Size(winrt_struct_wrapper<winrt::Windows::Foundation::Size>* self, PyObject* args, PyObject* kwds) noexcept
    {
        auto tuple_size = PyTuple_Size(args);

        if ((tuple_size == 0) && (kwds == nullptr))
        {
            self->obj = {};
            return 0;
        }

        float _Width{};
        float _Height{};

        static const char* kwlist[] = {"width", "height", nullptr};
        if (!PyArg_ParseTupleAndKeywords(args, kwds, "ff", const_cast<char**>(kwlist), &_Width, &_Height))
        {
            return -1;
        }

        try
        {
            self->obj = {_Width, _Height};
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static void _dealloc_Size(py::wrapper::Windows::Foundation::Size* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_Size(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Foundation::Size>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyMethodDef _methods_Size[] = {
        { "_assign_array_", _assign_array_Size, METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyObject* Size_get_Width(py::wrapper::Windows::Foundation::Size* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Width);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Size_set_Width(py::wrapper::Windows::Foundation::Size* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.Width = py::converter<float>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Size_get_Height(py::wrapper::Windows::Foundation::Size* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Height);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Size_set_Height(py::wrapper::Windows::Foundation::Size* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.Height = py::converter<float>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyGetSetDef _getset_Size[] = {
        { "width", reinterpret_cast<getter>(Size_get_Width), reinterpret_cast<setter>(Size_set_Width), nullptr, nullptr },
        { "height", reinterpret_cast<getter>(Size_get_Height), reinterpret_cast<setter>(Size_set_Height), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_Size[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_Size) },
        { Py_tp_init, reinterpret_cast<void*>(_init_Size) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_Size) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_Size) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_Size) },
        { },
    };

    static PyType_Spec type_spec_Size =
    {
        "winrt._winrt_windows_foundation.Size",
        sizeof(py::wrapper::Windows::Foundation::Size),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_Size
    };

    // ----- Windows.Foundation Initialization --------------------

    PyDoc_STRVAR(module_doc, "Windows.Foundation");

    static PyModuleDef module_def = {
        PyModuleDef_HEAD_INIT,
        "_winrt_windows_foundation",
        module_doc,
        0,
        nullptr,
        nullptr,
        nullptr,
        nullptr,
        nullptr};
} // py::cpp::Windows::Foundation

PyMODINIT_FUNC PyInit__winrt_windows_foundation(void) noexcept
{
    using namespace py::cpp::Windows::Foundation;

    if (py::import_winrt_runtime() == -1)
    {
        return nullptr;
    }

    py::pyobj_handle module{PyModule_Create(&module_def)};

    if (!module)
    {
        return nullptr;
    }

    auto object_type = py::get_object_type();
    if (!object_type)
    {
        return nullptr;
    }

    py::pyobj_handle object_bases{PyTuple_Pack(1, object_type)};

    if (!object_bases)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_Deferral, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_GuidHelper_Static{PyType_FromSpec(&type_spec_GuidHelper_Static)};
    if (!type_GuidHelper_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_GuidHelper, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_GuidHelper_Static.get())) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_MemoryBuffer, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_PropertyValue_Static{PyType_FromSpec(&type_spec_PropertyValue_Static)};
    if (!type_PropertyValue_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_PropertyValue, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_PropertyValue_Static.get())) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_Uri_Static{PyType_FromSpec(&type_spec_Uri_Static)};
    if (!type_Uri_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_Uri, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_Uri_Static.get())) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_WwwFormUrlDecoder, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_WwwFormUrlDecoderEntry, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_IAsyncAction, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_IAsyncActionWithProgress, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_IAsyncInfo, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_IAsyncOperationWithProgress, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_IAsyncOperation, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_IClosable, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_IGetActivationFactory, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_IMemoryBuffer, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_IMemoryBufferReference, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_IPropertyValue, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_IReferenceArray, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_IReference, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_IStringable, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_IWwwFormUrlDecoderEntry, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_EventRegistrationToken, nullptr, nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_HResult, nullptr, nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_Point, nullptr, nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_Rect, nullptr, nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_Size, nullptr, nullptr) == -1)
    {
        return nullptr;
    }


    return module.detach();
}
