// WARNING: Please don't edit this file. It was generated by Python/WinRT v2.0.1

#include "py.Windows.Devices.Midi.h"


namespace py::cpp::Windows::Devices::Midi
{
    // ----- MidiActiveSensingMessage class --------------------

    static PyObject* _new_MidiActiveSensingMessage(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Devices::Midi::MidiActiveSensingMessage instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_MidiActiveSensingMessage(py::wrapper::Windows::Devices::Midi::MidiActiveSensingMessage* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MidiActiveSensingMessage_get_RawData(py::wrapper::Windows::Devices::Midi::MidiActiveSensingMessage* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Midi.MidiActiveSensingMessage", L"RawData"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.RawData());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MidiActiveSensingMessage_get_Timestamp(py::wrapper::Windows::Devices::Midi::MidiActiveSensingMessage* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Midi.MidiActiveSensingMessage", L"Timestamp"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Timestamp());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MidiActiveSensingMessage_get_Type(py::wrapper::Windows::Devices::Midi::MidiActiveSensingMessage* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Midi.MidiActiveSensingMessage", L"Type"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Type());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MidiActiveSensingMessage(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Midi::MidiActiveSensingMessage>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MidiActiveSensingMessage(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Midi::MidiActiveSensingMessage>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MidiActiveSensingMessage[] = {
        { "_assign_array_", _assign_array_MidiActiveSensingMessage, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MidiActiveSensingMessage), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MidiActiveSensingMessage[] = {
        { "raw_data", reinterpret_cast<getter>(MidiActiveSensingMessage_get_RawData), nullptr, nullptr, nullptr },
        { "timestamp", reinterpret_cast<getter>(MidiActiveSensingMessage_get_Timestamp), nullptr, nullptr, nullptr },
        { "type", reinterpret_cast<getter>(MidiActiveSensingMessage_get_Type), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MidiActiveSensingMessage[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MidiActiveSensingMessage) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MidiActiveSensingMessage) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MidiActiveSensingMessage) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MidiActiveSensingMessage) },
        { },
    };

    static PyType_Spec type_spec_MidiActiveSensingMessage =
    {
        "winrt._winrt_windows_devices_midi.MidiActiveSensingMessage",
        sizeof(py::wrapper::Windows::Devices::Midi::MidiActiveSensingMessage),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MidiActiveSensingMessage
    };

    // ----- MidiChannelPressureMessage class --------------------

    static PyObject* _new_MidiChannelPressureMessage(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<uint8_t>(args, 0);
                auto param1 = py::convert_to<uint8_t>(args, 1);

                winrt::Windows::Devices::Midi::MidiChannelPressureMessage instance{ param0, param1 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_MidiChannelPressureMessage(py::wrapper::Windows::Devices::Midi::MidiChannelPressureMessage* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MidiChannelPressureMessage_get_Channel(py::wrapper::Windows::Devices::Midi::MidiChannelPressureMessage* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Midi.MidiChannelPressureMessage", L"Channel"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Channel());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MidiChannelPressureMessage_get_Pressure(py::wrapper::Windows::Devices::Midi::MidiChannelPressureMessage* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Midi.MidiChannelPressureMessage", L"Pressure"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Pressure());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MidiChannelPressureMessage_get_RawData(py::wrapper::Windows::Devices::Midi::MidiChannelPressureMessage* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Midi.MidiChannelPressureMessage", L"RawData"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.RawData());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MidiChannelPressureMessage_get_Timestamp(py::wrapper::Windows::Devices::Midi::MidiChannelPressureMessage* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Midi.MidiChannelPressureMessage", L"Timestamp"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Timestamp());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MidiChannelPressureMessage_get_Type(py::wrapper::Windows::Devices::Midi::MidiChannelPressureMessage* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Midi.MidiChannelPressureMessage", L"Type"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Type());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MidiChannelPressureMessage(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Midi::MidiChannelPressureMessage>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MidiChannelPressureMessage(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Midi::MidiChannelPressureMessage>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MidiChannelPressureMessage[] = {
        { "_assign_array_", _assign_array_MidiChannelPressureMessage, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MidiChannelPressureMessage), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MidiChannelPressureMessage[] = {
        { "channel", reinterpret_cast<getter>(MidiChannelPressureMessage_get_Channel), nullptr, nullptr, nullptr },
        { "pressure", reinterpret_cast<getter>(MidiChannelPressureMessage_get_Pressure), nullptr, nullptr, nullptr },
        { "raw_data", reinterpret_cast<getter>(MidiChannelPressureMessage_get_RawData), nullptr, nullptr, nullptr },
        { "timestamp", reinterpret_cast<getter>(MidiChannelPressureMessage_get_Timestamp), nullptr, nullptr, nullptr },
        { "type", reinterpret_cast<getter>(MidiChannelPressureMessage_get_Type), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MidiChannelPressureMessage[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MidiChannelPressureMessage) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MidiChannelPressureMessage) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MidiChannelPressureMessage) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MidiChannelPressureMessage) },
        { },
    };

    static PyType_Spec type_spec_MidiChannelPressureMessage =
    {
        "winrt._winrt_windows_devices_midi.MidiChannelPressureMessage",
        sizeof(py::wrapper::Windows::Devices::Midi::MidiChannelPressureMessage),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MidiChannelPressureMessage
    };

    // ----- MidiContinueMessage class --------------------

    static PyObject* _new_MidiContinueMessage(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Devices::Midi::MidiContinueMessage instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_MidiContinueMessage(py::wrapper::Windows::Devices::Midi::MidiContinueMessage* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MidiContinueMessage_get_RawData(py::wrapper::Windows::Devices::Midi::MidiContinueMessage* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Midi.MidiContinueMessage", L"RawData"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.RawData());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MidiContinueMessage_get_Timestamp(py::wrapper::Windows::Devices::Midi::MidiContinueMessage* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Midi.MidiContinueMessage", L"Timestamp"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Timestamp());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MidiContinueMessage_get_Type(py::wrapper::Windows::Devices::Midi::MidiContinueMessage* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Midi.MidiContinueMessage", L"Type"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Type());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MidiContinueMessage(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Midi::MidiContinueMessage>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MidiContinueMessage(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Midi::MidiContinueMessage>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MidiContinueMessage[] = {
        { "_assign_array_", _assign_array_MidiContinueMessage, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MidiContinueMessage), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MidiContinueMessage[] = {
        { "raw_data", reinterpret_cast<getter>(MidiContinueMessage_get_RawData), nullptr, nullptr, nullptr },
        { "timestamp", reinterpret_cast<getter>(MidiContinueMessage_get_Timestamp), nullptr, nullptr, nullptr },
        { "type", reinterpret_cast<getter>(MidiContinueMessage_get_Type), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MidiContinueMessage[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MidiContinueMessage) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MidiContinueMessage) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MidiContinueMessage) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MidiContinueMessage) },
        { },
    };

    static PyType_Spec type_spec_MidiContinueMessage =
    {
        "winrt._winrt_windows_devices_midi.MidiContinueMessage",
        sizeof(py::wrapper::Windows::Devices::Midi::MidiContinueMessage),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MidiContinueMessage
    };

    // ----- MidiControlChangeMessage class --------------------

    static PyObject* _new_MidiControlChangeMessage(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<uint8_t>(args, 0);
                auto param1 = py::convert_to<uint8_t>(args, 1);
                auto param2 = py::convert_to<uint8_t>(args, 2);

                winrt::Windows::Devices::Midi::MidiControlChangeMessage instance{ param0, param1, param2 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_MidiControlChangeMessage(py::wrapper::Windows::Devices::Midi::MidiControlChangeMessage* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MidiControlChangeMessage_get_Channel(py::wrapper::Windows::Devices::Midi::MidiControlChangeMessage* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Midi.MidiControlChangeMessage", L"Channel"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Channel());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MidiControlChangeMessage_get_ControlValue(py::wrapper::Windows::Devices::Midi::MidiControlChangeMessage* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Midi.MidiControlChangeMessage", L"ControlValue"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ControlValue());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MidiControlChangeMessage_get_Controller(py::wrapper::Windows::Devices::Midi::MidiControlChangeMessage* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Midi.MidiControlChangeMessage", L"Controller"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Controller());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MidiControlChangeMessage_get_RawData(py::wrapper::Windows::Devices::Midi::MidiControlChangeMessage* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Midi.MidiControlChangeMessage", L"RawData"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.RawData());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MidiControlChangeMessage_get_Timestamp(py::wrapper::Windows::Devices::Midi::MidiControlChangeMessage* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Midi.MidiControlChangeMessage", L"Timestamp"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Timestamp());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MidiControlChangeMessage_get_Type(py::wrapper::Windows::Devices::Midi::MidiControlChangeMessage* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Midi.MidiControlChangeMessage", L"Type"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Type());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MidiControlChangeMessage(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Midi::MidiControlChangeMessage>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MidiControlChangeMessage(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Midi::MidiControlChangeMessage>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MidiControlChangeMessage[] = {
        { "_assign_array_", _assign_array_MidiControlChangeMessage, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MidiControlChangeMessage), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MidiControlChangeMessage[] = {
        { "channel", reinterpret_cast<getter>(MidiControlChangeMessage_get_Channel), nullptr, nullptr, nullptr },
        { "control_value", reinterpret_cast<getter>(MidiControlChangeMessage_get_ControlValue), nullptr, nullptr, nullptr },
        { "controller", reinterpret_cast<getter>(MidiControlChangeMessage_get_Controller), nullptr, nullptr, nullptr },
        { "raw_data", reinterpret_cast<getter>(MidiControlChangeMessage_get_RawData), nullptr, nullptr, nullptr },
        { "timestamp", reinterpret_cast<getter>(MidiControlChangeMessage_get_Timestamp), nullptr, nullptr, nullptr },
        { "type", reinterpret_cast<getter>(MidiControlChangeMessage_get_Type), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MidiControlChangeMessage[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MidiControlChangeMessage) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MidiControlChangeMessage) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MidiControlChangeMessage) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MidiControlChangeMessage) },
        { },
    };

    static PyType_Spec type_spec_MidiControlChangeMessage =
    {
        "winrt._winrt_windows_devices_midi.MidiControlChangeMessage",
        sizeof(py::wrapper::Windows::Devices::Midi::MidiControlChangeMessage),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MidiControlChangeMessage
    };

    // ----- MidiInPort class --------------------

    static PyObject* _new_MidiInPort(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Midi::MidiInPort>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Midi::MidiInPort>::type_name);
        return nullptr;
    }

    static void _dealloc_MidiInPort(py::wrapper::Windows::Devices::Midi::MidiInPort* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MidiInPort_Close(py::wrapper::Windows::Devices::Midi::MidiInPort* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Midi.MidiInPort", L"Close", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MidiInPort_FromIdAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Midi.MidiInPort", L"FromIdAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Devices::Midi::MidiInPort::FromIdAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MidiInPort_GetDeviceSelector(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Midi.MidiInPort", L"GetDeviceSelector", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(winrt::Windows::Devices::Midi::MidiInPort::GetDeviceSelector());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MidiInPort_get_DeviceId(py::wrapper::Windows::Devices::Midi::MidiInPort* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Midi.MidiInPort", L"DeviceId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DeviceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MidiInPort_add_MessageReceived(py::wrapper::Windows::Devices::Midi::MidiInPort* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Midi.MidiInPort", L"MessageReceived"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Midi::MidiInPort, winrt::Windows::Devices::Midi::MidiMessageReceivedEventArgs>>(arg);

            return py::convert(self->obj.MessageReceived(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MidiInPort_remove_MessageReceived(py::wrapper::Windows::Devices::Midi::MidiInPort* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Midi.MidiInPort", L"MessageReceived"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.MessageReceived(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MidiInPort(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Midi::MidiInPort>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MidiInPort(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Midi::MidiInPort>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_MidiInPort(py::wrapper::Windows::Devices::Midi::MidiInPort* self, PyObject* /*unused*/) noexcept
    {
        return Py_NewRef(self);
    }

    static PyObject* _exit_MidiInPort(py::wrapper::Windows::Devices::Midi::MidiInPort* self, PyObject* /*unused*/) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MidiInPort[] = {
        { "close", reinterpret_cast<PyCFunction>(MidiInPort_Close), METH_VARARGS, nullptr },
        { "add_message_received", reinterpret_cast<PyCFunction>(MidiInPort_add_MessageReceived), METH_O, nullptr },
        { "remove_message_received", reinterpret_cast<PyCFunction>(MidiInPort_remove_MessageReceived), METH_O, nullptr },
        { "_assign_array_", _assign_array_MidiInPort, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MidiInPort), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_MidiInPort), METH_NOARGS, nullptr },
        { "__exit__",  reinterpret_cast<PyCFunction>(_exit_MidiInPort), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_MidiInPort[] = {
        { "device_id", reinterpret_cast<getter>(MidiInPort_get_DeviceId), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MidiInPort[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MidiInPort) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MidiInPort) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MidiInPort) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MidiInPort) },
        { },
    };

    static PyType_Spec type_spec_MidiInPort =
    {
        "winrt._winrt_windows_devices_midi.MidiInPort",
        sizeof(py::wrapper::Windows::Devices::Midi::MidiInPort),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MidiInPort
    };

    static PyGetSetDef getset_MidiInPort_Static[] = {
        { }
    };

    static PyMethodDef methods_MidiInPort_Static[] = {
        { "from_id_async", reinterpret_cast<PyCFunction>(MidiInPort_FromIdAsync), METH_VARARGS, nullptr },
        { "get_device_selector", reinterpret_cast<PyCFunction>(MidiInPort_GetDeviceSelector), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_MidiInPort_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_MidiInPort_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_MidiInPort_Static) },
        { }
    };

    static PyType_Spec type_spec_MidiInPort_Static =
    {
        "winrt._winrt_windows_devices_midi.MidiInPort_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_MidiInPort_Static
    };

    // ----- MidiMessageReceivedEventArgs class --------------------

    static PyObject* _new_MidiMessageReceivedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Midi::MidiMessageReceivedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Midi::MidiMessageReceivedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_MidiMessageReceivedEventArgs(py::wrapper::Windows::Devices::Midi::MidiMessageReceivedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MidiMessageReceivedEventArgs_get_Message(py::wrapper::Windows::Devices::Midi::MidiMessageReceivedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Midi.MidiMessageReceivedEventArgs", L"Message"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Message());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MidiMessageReceivedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Midi::MidiMessageReceivedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MidiMessageReceivedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Midi::MidiMessageReceivedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MidiMessageReceivedEventArgs[] = {
        { "_assign_array_", _assign_array_MidiMessageReceivedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MidiMessageReceivedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MidiMessageReceivedEventArgs[] = {
        { "message", reinterpret_cast<getter>(MidiMessageReceivedEventArgs_get_Message), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MidiMessageReceivedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MidiMessageReceivedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MidiMessageReceivedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MidiMessageReceivedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MidiMessageReceivedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_MidiMessageReceivedEventArgs =
    {
        "winrt._winrt_windows_devices_midi.MidiMessageReceivedEventArgs",
        sizeof(py::wrapper::Windows::Devices::Midi::MidiMessageReceivedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MidiMessageReceivedEventArgs
    };

    // ----- MidiNoteOffMessage class --------------------

    static PyObject* _new_MidiNoteOffMessage(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<uint8_t>(args, 0);
                auto param1 = py::convert_to<uint8_t>(args, 1);
                auto param2 = py::convert_to<uint8_t>(args, 2);

                winrt::Windows::Devices::Midi::MidiNoteOffMessage instance{ param0, param1, param2 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_MidiNoteOffMessage(py::wrapper::Windows::Devices::Midi::MidiNoteOffMessage* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MidiNoteOffMessage_get_RawData(py::wrapper::Windows::Devices::Midi::MidiNoteOffMessage* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Midi.MidiNoteOffMessage", L"RawData"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.RawData());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MidiNoteOffMessage_get_Timestamp(py::wrapper::Windows::Devices::Midi::MidiNoteOffMessage* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Midi.MidiNoteOffMessage", L"Timestamp"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Timestamp());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MidiNoteOffMessage_get_Type(py::wrapper::Windows::Devices::Midi::MidiNoteOffMessage* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Midi.MidiNoteOffMessage", L"Type"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Type());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MidiNoteOffMessage_get_Channel(py::wrapper::Windows::Devices::Midi::MidiNoteOffMessage* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Midi.MidiNoteOffMessage", L"Channel"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Channel());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MidiNoteOffMessage_get_Note(py::wrapper::Windows::Devices::Midi::MidiNoteOffMessage* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Midi.MidiNoteOffMessage", L"Note"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Note());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MidiNoteOffMessage_get_Velocity(py::wrapper::Windows::Devices::Midi::MidiNoteOffMessage* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Midi.MidiNoteOffMessage", L"Velocity"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Velocity());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MidiNoteOffMessage(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Midi::MidiNoteOffMessage>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MidiNoteOffMessage(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Midi::MidiNoteOffMessage>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MidiNoteOffMessage[] = {
        { "_assign_array_", _assign_array_MidiNoteOffMessage, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MidiNoteOffMessage), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MidiNoteOffMessage[] = {
        { "raw_data", reinterpret_cast<getter>(MidiNoteOffMessage_get_RawData), nullptr, nullptr, nullptr },
        { "timestamp", reinterpret_cast<getter>(MidiNoteOffMessage_get_Timestamp), nullptr, nullptr, nullptr },
        { "type", reinterpret_cast<getter>(MidiNoteOffMessage_get_Type), nullptr, nullptr, nullptr },
        { "channel", reinterpret_cast<getter>(MidiNoteOffMessage_get_Channel), nullptr, nullptr, nullptr },
        { "note", reinterpret_cast<getter>(MidiNoteOffMessage_get_Note), nullptr, nullptr, nullptr },
        { "velocity", reinterpret_cast<getter>(MidiNoteOffMessage_get_Velocity), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MidiNoteOffMessage[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MidiNoteOffMessage) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MidiNoteOffMessage) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MidiNoteOffMessage) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MidiNoteOffMessage) },
        { },
    };

    static PyType_Spec type_spec_MidiNoteOffMessage =
    {
        "winrt._winrt_windows_devices_midi.MidiNoteOffMessage",
        sizeof(py::wrapper::Windows::Devices::Midi::MidiNoteOffMessage),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MidiNoteOffMessage
    };

    // ----- MidiNoteOnMessage class --------------------

    static PyObject* _new_MidiNoteOnMessage(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<uint8_t>(args, 0);
                auto param1 = py::convert_to<uint8_t>(args, 1);
                auto param2 = py::convert_to<uint8_t>(args, 2);

                winrt::Windows::Devices::Midi::MidiNoteOnMessage instance{ param0, param1, param2 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_MidiNoteOnMessage(py::wrapper::Windows::Devices::Midi::MidiNoteOnMessage* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MidiNoteOnMessage_get_RawData(py::wrapper::Windows::Devices::Midi::MidiNoteOnMessage* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Midi.MidiNoteOnMessage", L"RawData"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.RawData());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MidiNoteOnMessage_get_Timestamp(py::wrapper::Windows::Devices::Midi::MidiNoteOnMessage* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Midi.MidiNoteOnMessage", L"Timestamp"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Timestamp());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MidiNoteOnMessage_get_Type(py::wrapper::Windows::Devices::Midi::MidiNoteOnMessage* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Midi.MidiNoteOnMessage", L"Type"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Type());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MidiNoteOnMessage_get_Channel(py::wrapper::Windows::Devices::Midi::MidiNoteOnMessage* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Midi.MidiNoteOnMessage", L"Channel"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Channel());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MidiNoteOnMessage_get_Note(py::wrapper::Windows::Devices::Midi::MidiNoteOnMessage* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Midi.MidiNoteOnMessage", L"Note"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Note());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MidiNoteOnMessage_get_Velocity(py::wrapper::Windows::Devices::Midi::MidiNoteOnMessage* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Midi.MidiNoteOnMessage", L"Velocity"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Velocity());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MidiNoteOnMessage(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Midi::MidiNoteOnMessage>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MidiNoteOnMessage(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Midi::MidiNoteOnMessage>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MidiNoteOnMessage[] = {
        { "_assign_array_", _assign_array_MidiNoteOnMessage, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MidiNoteOnMessage), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MidiNoteOnMessage[] = {
        { "raw_data", reinterpret_cast<getter>(MidiNoteOnMessage_get_RawData), nullptr, nullptr, nullptr },
        { "timestamp", reinterpret_cast<getter>(MidiNoteOnMessage_get_Timestamp), nullptr, nullptr, nullptr },
        { "type", reinterpret_cast<getter>(MidiNoteOnMessage_get_Type), nullptr, nullptr, nullptr },
        { "channel", reinterpret_cast<getter>(MidiNoteOnMessage_get_Channel), nullptr, nullptr, nullptr },
        { "note", reinterpret_cast<getter>(MidiNoteOnMessage_get_Note), nullptr, nullptr, nullptr },
        { "velocity", reinterpret_cast<getter>(MidiNoteOnMessage_get_Velocity), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MidiNoteOnMessage[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MidiNoteOnMessage) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MidiNoteOnMessage) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MidiNoteOnMessage) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MidiNoteOnMessage) },
        { },
    };

    static PyType_Spec type_spec_MidiNoteOnMessage =
    {
        "winrt._winrt_windows_devices_midi.MidiNoteOnMessage",
        sizeof(py::wrapper::Windows::Devices::Midi::MidiNoteOnMessage),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MidiNoteOnMessage
    };

    // ----- MidiOutPort class --------------------

    static PyObject* _new_MidiOutPort(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Midi::MidiOutPort>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Midi::MidiOutPort>::type_name);
        return nullptr;
    }

    static void _dealloc_MidiOutPort(py::wrapper::Windows::Devices::Midi::MidiOutPort* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MidiOutPort_Close(py::wrapper::Windows::Devices::Midi::MidiOutPort* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Midi.MidiOutPort", L"Close", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MidiOutPort_FromIdAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Midi.MidiOutPort", L"FromIdAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Devices::Midi::MidiOutPort::FromIdAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MidiOutPort_GetDeviceSelector(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Midi.MidiOutPort", L"GetDeviceSelector", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(winrt::Windows::Devices::Midi::MidiOutPort::GetDeviceSelector());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MidiOutPort_SendBuffer(py::wrapper::Windows::Devices::Midi::MidiOutPort* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Midi.MidiOutPort", L"SendBuffer", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 0);

                self->obj.SendBuffer(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MidiOutPort_SendMessage(py::wrapper::Windows::Devices::Midi::MidiOutPort* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Midi.MidiOutPort", L"SendMessage", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Midi::IMidiMessage>(args, 0);

                self->obj.SendMessage(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MidiOutPort_get_DeviceId(py::wrapper::Windows::Devices::Midi::MidiOutPort* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Midi.MidiOutPort", L"DeviceId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DeviceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MidiOutPort(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Midi::MidiOutPort>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MidiOutPort(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Midi::MidiOutPort>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_MidiOutPort(py::wrapper::Windows::Devices::Midi::MidiOutPort* self, PyObject* /*unused*/) noexcept
    {
        return Py_NewRef(self);
    }

    static PyObject* _exit_MidiOutPort(py::wrapper::Windows::Devices::Midi::MidiOutPort* self, PyObject* /*unused*/) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MidiOutPort[] = {
        { "close", reinterpret_cast<PyCFunction>(MidiOutPort_Close), METH_VARARGS, nullptr },
        { "send_buffer", reinterpret_cast<PyCFunction>(MidiOutPort_SendBuffer), METH_VARARGS, nullptr },
        { "send_message", reinterpret_cast<PyCFunction>(MidiOutPort_SendMessage), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_MidiOutPort, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MidiOutPort), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_MidiOutPort), METH_NOARGS, nullptr },
        { "__exit__",  reinterpret_cast<PyCFunction>(_exit_MidiOutPort), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_MidiOutPort[] = {
        { "device_id", reinterpret_cast<getter>(MidiOutPort_get_DeviceId), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MidiOutPort[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MidiOutPort) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MidiOutPort) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MidiOutPort) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MidiOutPort) },
        { },
    };

    static PyType_Spec type_spec_MidiOutPort =
    {
        "winrt._winrt_windows_devices_midi.MidiOutPort",
        sizeof(py::wrapper::Windows::Devices::Midi::MidiOutPort),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MidiOutPort
    };

    static PyGetSetDef getset_MidiOutPort_Static[] = {
        { }
    };

    static PyMethodDef methods_MidiOutPort_Static[] = {
        { "from_id_async", reinterpret_cast<PyCFunction>(MidiOutPort_FromIdAsync), METH_VARARGS, nullptr },
        { "get_device_selector", reinterpret_cast<PyCFunction>(MidiOutPort_GetDeviceSelector), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_MidiOutPort_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_MidiOutPort_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_MidiOutPort_Static) },
        { }
    };

    static PyType_Spec type_spec_MidiOutPort_Static =
    {
        "winrt._winrt_windows_devices_midi.MidiOutPort_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_MidiOutPort_Static
    };

    // ----- MidiPitchBendChangeMessage class --------------------

    static PyObject* _new_MidiPitchBendChangeMessage(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<uint8_t>(args, 0);
                auto param1 = py::convert_to<uint16_t>(args, 1);

                winrt::Windows::Devices::Midi::MidiPitchBendChangeMessage instance{ param0, param1 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_MidiPitchBendChangeMessage(py::wrapper::Windows::Devices::Midi::MidiPitchBendChangeMessage* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MidiPitchBendChangeMessage_get_RawData(py::wrapper::Windows::Devices::Midi::MidiPitchBendChangeMessage* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Midi.MidiPitchBendChangeMessage", L"RawData"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.RawData());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MidiPitchBendChangeMessage_get_Timestamp(py::wrapper::Windows::Devices::Midi::MidiPitchBendChangeMessage* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Midi.MidiPitchBendChangeMessage", L"Timestamp"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Timestamp());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MidiPitchBendChangeMessage_get_Type(py::wrapper::Windows::Devices::Midi::MidiPitchBendChangeMessage* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Midi.MidiPitchBendChangeMessage", L"Type"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Type());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MidiPitchBendChangeMessage_get_Bend(py::wrapper::Windows::Devices::Midi::MidiPitchBendChangeMessage* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Midi.MidiPitchBendChangeMessage", L"Bend"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Bend());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MidiPitchBendChangeMessage_get_Channel(py::wrapper::Windows::Devices::Midi::MidiPitchBendChangeMessage* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Midi.MidiPitchBendChangeMessage", L"Channel"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Channel());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MidiPitchBendChangeMessage(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Midi::MidiPitchBendChangeMessage>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MidiPitchBendChangeMessage(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Midi::MidiPitchBendChangeMessage>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MidiPitchBendChangeMessage[] = {
        { "_assign_array_", _assign_array_MidiPitchBendChangeMessage, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MidiPitchBendChangeMessage), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MidiPitchBendChangeMessage[] = {
        { "raw_data", reinterpret_cast<getter>(MidiPitchBendChangeMessage_get_RawData), nullptr, nullptr, nullptr },
        { "timestamp", reinterpret_cast<getter>(MidiPitchBendChangeMessage_get_Timestamp), nullptr, nullptr, nullptr },
        { "type", reinterpret_cast<getter>(MidiPitchBendChangeMessage_get_Type), nullptr, nullptr, nullptr },
        { "bend", reinterpret_cast<getter>(MidiPitchBendChangeMessage_get_Bend), nullptr, nullptr, nullptr },
        { "channel", reinterpret_cast<getter>(MidiPitchBendChangeMessage_get_Channel), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MidiPitchBendChangeMessage[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MidiPitchBendChangeMessage) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MidiPitchBendChangeMessage) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MidiPitchBendChangeMessage) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MidiPitchBendChangeMessage) },
        { },
    };

    static PyType_Spec type_spec_MidiPitchBendChangeMessage =
    {
        "winrt._winrt_windows_devices_midi.MidiPitchBendChangeMessage",
        sizeof(py::wrapper::Windows::Devices::Midi::MidiPitchBendChangeMessage),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MidiPitchBendChangeMessage
    };

    // ----- MidiPolyphonicKeyPressureMessage class --------------------

    static PyObject* _new_MidiPolyphonicKeyPressureMessage(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<uint8_t>(args, 0);
                auto param1 = py::convert_to<uint8_t>(args, 1);
                auto param2 = py::convert_to<uint8_t>(args, 2);

                winrt::Windows::Devices::Midi::MidiPolyphonicKeyPressureMessage instance{ param0, param1, param2 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_MidiPolyphonicKeyPressureMessage(py::wrapper::Windows::Devices::Midi::MidiPolyphonicKeyPressureMessage* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MidiPolyphonicKeyPressureMessage_get_RawData(py::wrapper::Windows::Devices::Midi::MidiPolyphonicKeyPressureMessage* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Midi.MidiPolyphonicKeyPressureMessage", L"RawData"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.RawData());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MidiPolyphonicKeyPressureMessage_get_Timestamp(py::wrapper::Windows::Devices::Midi::MidiPolyphonicKeyPressureMessage* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Midi.MidiPolyphonicKeyPressureMessage", L"Timestamp"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Timestamp());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MidiPolyphonicKeyPressureMessage_get_Type(py::wrapper::Windows::Devices::Midi::MidiPolyphonicKeyPressureMessage* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Midi.MidiPolyphonicKeyPressureMessage", L"Type"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Type());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MidiPolyphonicKeyPressureMessage_get_Channel(py::wrapper::Windows::Devices::Midi::MidiPolyphonicKeyPressureMessage* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Midi.MidiPolyphonicKeyPressureMessage", L"Channel"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Channel());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MidiPolyphonicKeyPressureMessage_get_Note(py::wrapper::Windows::Devices::Midi::MidiPolyphonicKeyPressureMessage* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Midi.MidiPolyphonicKeyPressureMessage", L"Note"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Note());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MidiPolyphonicKeyPressureMessage_get_Pressure(py::wrapper::Windows::Devices::Midi::MidiPolyphonicKeyPressureMessage* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Midi.MidiPolyphonicKeyPressureMessage", L"Pressure"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Pressure());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MidiPolyphonicKeyPressureMessage(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Midi::MidiPolyphonicKeyPressureMessage>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MidiPolyphonicKeyPressureMessage(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Midi::MidiPolyphonicKeyPressureMessage>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MidiPolyphonicKeyPressureMessage[] = {
        { "_assign_array_", _assign_array_MidiPolyphonicKeyPressureMessage, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MidiPolyphonicKeyPressureMessage), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MidiPolyphonicKeyPressureMessage[] = {
        { "raw_data", reinterpret_cast<getter>(MidiPolyphonicKeyPressureMessage_get_RawData), nullptr, nullptr, nullptr },
        { "timestamp", reinterpret_cast<getter>(MidiPolyphonicKeyPressureMessage_get_Timestamp), nullptr, nullptr, nullptr },
        { "type", reinterpret_cast<getter>(MidiPolyphonicKeyPressureMessage_get_Type), nullptr, nullptr, nullptr },
        { "channel", reinterpret_cast<getter>(MidiPolyphonicKeyPressureMessage_get_Channel), nullptr, nullptr, nullptr },
        { "note", reinterpret_cast<getter>(MidiPolyphonicKeyPressureMessage_get_Note), nullptr, nullptr, nullptr },
        { "pressure", reinterpret_cast<getter>(MidiPolyphonicKeyPressureMessage_get_Pressure), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MidiPolyphonicKeyPressureMessage[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MidiPolyphonicKeyPressureMessage) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MidiPolyphonicKeyPressureMessage) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MidiPolyphonicKeyPressureMessage) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MidiPolyphonicKeyPressureMessage) },
        { },
    };

    static PyType_Spec type_spec_MidiPolyphonicKeyPressureMessage =
    {
        "winrt._winrt_windows_devices_midi.MidiPolyphonicKeyPressureMessage",
        sizeof(py::wrapper::Windows::Devices::Midi::MidiPolyphonicKeyPressureMessage),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MidiPolyphonicKeyPressureMessage
    };

    // ----- MidiProgramChangeMessage class --------------------

    static PyObject* _new_MidiProgramChangeMessage(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<uint8_t>(args, 0);
                auto param1 = py::convert_to<uint8_t>(args, 1);

                winrt::Windows::Devices::Midi::MidiProgramChangeMessage instance{ param0, param1 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_MidiProgramChangeMessage(py::wrapper::Windows::Devices::Midi::MidiProgramChangeMessage* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MidiProgramChangeMessage_get_RawData(py::wrapper::Windows::Devices::Midi::MidiProgramChangeMessage* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Midi.MidiProgramChangeMessage", L"RawData"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.RawData());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MidiProgramChangeMessage_get_Timestamp(py::wrapper::Windows::Devices::Midi::MidiProgramChangeMessage* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Midi.MidiProgramChangeMessage", L"Timestamp"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Timestamp());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MidiProgramChangeMessage_get_Type(py::wrapper::Windows::Devices::Midi::MidiProgramChangeMessage* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Midi.MidiProgramChangeMessage", L"Type"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Type());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MidiProgramChangeMessage_get_Channel(py::wrapper::Windows::Devices::Midi::MidiProgramChangeMessage* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Midi.MidiProgramChangeMessage", L"Channel"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Channel());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MidiProgramChangeMessage_get_Program(py::wrapper::Windows::Devices::Midi::MidiProgramChangeMessage* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Midi.MidiProgramChangeMessage", L"Program"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Program());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MidiProgramChangeMessage(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Midi::MidiProgramChangeMessage>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MidiProgramChangeMessage(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Midi::MidiProgramChangeMessage>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MidiProgramChangeMessage[] = {
        { "_assign_array_", _assign_array_MidiProgramChangeMessage, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MidiProgramChangeMessage), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MidiProgramChangeMessage[] = {
        { "raw_data", reinterpret_cast<getter>(MidiProgramChangeMessage_get_RawData), nullptr, nullptr, nullptr },
        { "timestamp", reinterpret_cast<getter>(MidiProgramChangeMessage_get_Timestamp), nullptr, nullptr, nullptr },
        { "type", reinterpret_cast<getter>(MidiProgramChangeMessage_get_Type), nullptr, nullptr, nullptr },
        { "channel", reinterpret_cast<getter>(MidiProgramChangeMessage_get_Channel), nullptr, nullptr, nullptr },
        { "program", reinterpret_cast<getter>(MidiProgramChangeMessage_get_Program), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MidiProgramChangeMessage[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MidiProgramChangeMessage) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MidiProgramChangeMessage) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MidiProgramChangeMessage) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MidiProgramChangeMessage) },
        { },
    };

    static PyType_Spec type_spec_MidiProgramChangeMessage =
    {
        "winrt._winrt_windows_devices_midi.MidiProgramChangeMessage",
        sizeof(py::wrapper::Windows::Devices::Midi::MidiProgramChangeMessage),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MidiProgramChangeMessage
    };

    // ----- MidiSongPositionPointerMessage class --------------------

    static PyObject* _new_MidiSongPositionPointerMessage(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<uint16_t>(args, 0);

                winrt::Windows::Devices::Midi::MidiSongPositionPointerMessage instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_MidiSongPositionPointerMessage(py::wrapper::Windows::Devices::Midi::MidiSongPositionPointerMessage* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MidiSongPositionPointerMessage_get_RawData(py::wrapper::Windows::Devices::Midi::MidiSongPositionPointerMessage* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Midi.MidiSongPositionPointerMessage", L"RawData"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.RawData());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MidiSongPositionPointerMessage_get_Timestamp(py::wrapper::Windows::Devices::Midi::MidiSongPositionPointerMessage* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Midi.MidiSongPositionPointerMessage", L"Timestamp"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Timestamp());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MidiSongPositionPointerMessage_get_Type(py::wrapper::Windows::Devices::Midi::MidiSongPositionPointerMessage* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Midi.MidiSongPositionPointerMessage", L"Type"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Type());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MidiSongPositionPointerMessage_get_Beats(py::wrapper::Windows::Devices::Midi::MidiSongPositionPointerMessage* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Midi.MidiSongPositionPointerMessage", L"Beats"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Beats());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MidiSongPositionPointerMessage(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Midi::MidiSongPositionPointerMessage>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MidiSongPositionPointerMessage(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Midi::MidiSongPositionPointerMessage>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MidiSongPositionPointerMessage[] = {
        { "_assign_array_", _assign_array_MidiSongPositionPointerMessage, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MidiSongPositionPointerMessage), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MidiSongPositionPointerMessage[] = {
        { "raw_data", reinterpret_cast<getter>(MidiSongPositionPointerMessage_get_RawData), nullptr, nullptr, nullptr },
        { "timestamp", reinterpret_cast<getter>(MidiSongPositionPointerMessage_get_Timestamp), nullptr, nullptr, nullptr },
        { "type", reinterpret_cast<getter>(MidiSongPositionPointerMessage_get_Type), nullptr, nullptr, nullptr },
        { "beats", reinterpret_cast<getter>(MidiSongPositionPointerMessage_get_Beats), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MidiSongPositionPointerMessage[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MidiSongPositionPointerMessage) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MidiSongPositionPointerMessage) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MidiSongPositionPointerMessage) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MidiSongPositionPointerMessage) },
        { },
    };

    static PyType_Spec type_spec_MidiSongPositionPointerMessage =
    {
        "winrt._winrt_windows_devices_midi.MidiSongPositionPointerMessage",
        sizeof(py::wrapper::Windows::Devices::Midi::MidiSongPositionPointerMessage),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MidiSongPositionPointerMessage
    };

    // ----- MidiSongSelectMessage class --------------------

    static PyObject* _new_MidiSongSelectMessage(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<uint8_t>(args, 0);

                winrt::Windows::Devices::Midi::MidiSongSelectMessage instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_MidiSongSelectMessage(py::wrapper::Windows::Devices::Midi::MidiSongSelectMessage* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MidiSongSelectMessage_get_RawData(py::wrapper::Windows::Devices::Midi::MidiSongSelectMessage* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Midi.MidiSongSelectMessage", L"RawData"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.RawData());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MidiSongSelectMessage_get_Timestamp(py::wrapper::Windows::Devices::Midi::MidiSongSelectMessage* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Midi.MidiSongSelectMessage", L"Timestamp"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Timestamp());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MidiSongSelectMessage_get_Type(py::wrapper::Windows::Devices::Midi::MidiSongSelectMessage* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Midi.MidiSongSelectMessage", L"Type"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Type());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MidiSongSelectMessage_get_Song(py::wrapper::Windows::Devices::Midi::MidiSongSelectMessage* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Midi.MidiSongSelectMessage", L"Song"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Song());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MidiSongSelectMessage(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Midi::MidiSongSelectMessage>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MidiSongSelectMessage(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Midi::MidiSongSelectMessage>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MidiSongSelectMessage[] = {
        { "_assign_array_", _assign_array_MidiSongSelectMessage, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MidiSongSelectMessage), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MidiSongSelectMessage[] = {
        { "raw_data", reinterpret_cast<getter>(MidiSongSelectMessage_get_RawData), nullptr, nullptr, nullptr },
        { "timestamp", reinterpret_cast<getter>(MidiSongSelectMessage_get_Timestamp), nullptr, nullptr, nullptr },
        { "type", reinterpret_cast<getter>(MidiSongSelectMessage_get_Type), nullptr, nullptr, nullptr },
        { "song", reinterpret_cast<getter>(MidiSongSelectMessage_get_Song), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MidiSongSelectMessage[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MidiSongSelectMessage) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MidiSongSelectMessage) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MidiSongSelectMessage) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MidiSongSelectMessage) },
        { },
    };

    static PyType_Spec type_spec_MidiSongSelectMessage =
    {
        "winrt._winrt_windows_devices_midi.MidiSongSelectMessage",
        sizeof(py::wrapper::Windows::Devices::Midi::MidiSongSelectMessage),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MidiSongSelectMessage
    };

    // ----- MidiStartMessage class --------------------

    static PyObject* _new_MidiStartMessage(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Devices::Midi::MidiStartMessage instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_MidiStartMessage(py::wrapper::Windows::Devices::Midi::MidiStartMessage* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MidiStartMessage_get_RawData(py::wrapper::Windows::Devices::Midi::MidiStartMessage* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Midi.MidiStartMessage", L"RawData"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.RawData());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MidiStartMessage_get_Timestamp(py::wrapper::Windows::Devices::Midi::MidiStartMessage* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Midi.MidiStartMessage", L"Timestamp"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Timestamp());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MidiStartMessage_get_Type(py::wrapper::Windows::Devices::Midi::MidiStartMessage* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Midi.MidiStartMessage", L"Type"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Type());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MidiStartMessage(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Midi::MidiStartMessage>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MidiStartMessage(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Midi::MidiStartMessage>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MidiStartMessage[] = {
        { "_assign_array_", _assign_array_MidiStartMessage, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MidiStartMessage), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MidiStartMessage[] = {
        { "raw_data", reinterpret_cast<getter>(MidiStartMessage_get_RawData), nullptr, nullptr, nullptr },
        { "timestamp", reinterpret_cast<getter>(MidiStartMessage_get_Timestamp), nullptr, nullptr, nullptr },
        { "type", reinterpret_cast<getter>(MidiStartMessage_get_Type), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MidiStartMessage[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MidiStartMessage) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MidiStartMessage) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MidiStartMessage) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MidiStartMessage) },
        { },
    };

    static PyType_Spec type_spec_MidiStartMessage =
    {
        "winrt._winrt_windows_devices_midi.MidiStartMessage",
        sizeof(py::wrapper::Windows::Devices::Midi::MidiStartMessage),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MidiStartMessage
    };

    // ----- MidiStopMessage class --------------------

    static PyObject* _new_MidiStopMessage(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Devices::Midi::MidiStopMessage instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_MidiStopMessage(py::wrapper::Windows::Devices::Midi::MidiStopMessage* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MidiStopMessage_get_RawData(py::wrapper::Windows::Devices::Midi::MidiStopMessage* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Midi.MidiStopMessage", L"RawData"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.RawData());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MidiStopMessage_get_Timestamp(py::wrapper::Windows::Devices::Midi::MidiStopMessage* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Midi.MidiStopMessage", L"Timestamp"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Timestamp());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MidiStopMessage_get_Type(py::wrapper::Windows::Devices::Midi::MidiStopMessage* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Midi.MidiStopMessage", L"Type"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Type());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MidiStopMessage(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Midi::MidiStopMessage>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MidiStopMessage(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Midi::MidiStopMessage>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MidiStopMessage[] = {
        { "_assign_array_", _assign_array_MidiStopMessage, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MidiStopMessage), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MidiStopMessage[] = {
        { "raw_data", reinterpret_cast<getter>(MidiStopMessage_get_RawData), nullptr, nullptr, nullptr },
        { "timestamp", reinterpret_cast<getter>(MidiStopMessage_get_Timestamp), nullptr, nullptr, nullptr },
        { "type", reinterpret_cast<getter>(MidiStopMessage_get_Type), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MidiStopMessage[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MidiStopMessage) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MidiStopMessage) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MidiStopMessage) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MidiStopMessage) },
        { },
    };

    static PyType_Spec type_spec_MidiStopMessage =
    {
        "winrt._winrt_windows_devices_midi.MidiStopMessage",
        sizeof(py::wrapper::Windows::Devices::Midi::MidiStopMessage),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MidiStopMessage
    };

    // ----- MidiSynthesizer class --------------------

    static PyObject* _new_MidiSynthesizer(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Midi::MidiSynthesizer>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Midi::MidiSynthesizer>::type_name);
        return nullptr;
    }

    static void _dealloc_MidiSynthesizer(py::wrapper::Windows::Devices::Midi::MidiSynthesizer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MidiSynthesizer_Close(py::wrapper::Windows::Devices::Midi::MidiSynthesizer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Midi.MidiSynthesizer", L"Close", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MidiSynthesizer_CreateAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Midi.MidiSynthesizer", L"CreateAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(winrt::Windows::Devices::Midi::MidiSynthesizer::CreateAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Midi.MidiSynthesizer", L"CreateAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Enumeration::DeviceInformation>(args, 0);

                return py::convert(winrt::Windows::Devices::Midi::MidiSynthesizer::CreateAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MidiSynthesizer_IsSynthesizer(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Midi.MidiSynthesizer", L"IsSynthesizer", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Enumeration::DeviceInformation>(args, 0);

                return py::convert(winrt::Windows::Devices::Midi::MidiSynthesizer::IsSynthesizer(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MidiSynthesizer_SendBuffer(py::wrapper::Windows::Devices::Midi::MidiSynthesizer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Midi.MidiSynthesizer", L"SendBuffer", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 0);

                self->obj.SendBuffer(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MidiSynthesizer_SendMessage(py::wrapper::Windows::Devices::Midi::MidiSynthesizer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Midi.MidiSynthesizer", L"SendMessage", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Midi::IMidiMessage>(args, 0);

                self->obj.SendMessage(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MidiSynthesizer_get_DeviceId(py::wrapper::Windows::Devices::Midi::MidiSynthesizer* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Midi.MidiSynthesizer", L"DeviceId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DeviceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MidiSynthesizer_get_Volume(py::wrapper::Windows::Devices::Midi::MidiSynthesizer* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Midi.MidiSynthesizer", L"Volume"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Volume());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MidiSynthesizer_put_Volume(py::wrapper::Windows::Devices::Midi::MidiSynthesizer* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Midi.MidiSynthesizer", L"Volume"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.Volume(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MidiSynthesizer_get_AudioDevice(py::wrapper::Windows::Devices::Midi::MidiSynthesizer* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Midi.MidiSynthesizer", L"AudioDevice"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AudioDevice());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MidiSynthesizer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Midi::MidiSynthesizer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MidiSynthesizer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Midi::MidiSynthesizer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_MidiSynthesizer(py::wrapper::Windows::Devices::Midi::MidiSynthesizer* self, PyObject* /*unused*/) noexcept
    {
        return Py_NewRef(self);
    }

    static PyObject* _exit_MidiSynthesizer(py::wrapper::Windows::Devices::Midi::MidiSynthesizer* self, PyObject* /*unused*/) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MidiSynthesizer[] = {
        { "close", reinterpret_cast<PyCFunction>(MidiSynthesizer_Close), METH_VARARGS, nullptr },
        { "send_buffer", reinterpret_cast<PyCFunction>(MidiSynthesizer_SendBuffer), METH_VARARGS, nullptr },
        { "send_message", reinterpret_cast<PyCFunction>(MidiSynthesizer_SendMessage), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_MidiSynthesizer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MidiSynthesizer), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_MidiSynthesizer), METH_NOARGS, nullptr },
        { "__exit__",  reinterpret_cast<PyCFunction>(_exit_MidiSynthesizer), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_MidiSynthesizer[] = {
        { "device_id", reinterpret_cast<getter>(MidiSynthesizer_get_DeviceId), nullptr, nullptr, nullptr },
        { "volume", reinterpret_cast<getter>(MidiSynthesizer_get_Volume), reinterpret_cast<setter>(MidiSynthesizer_put_Volume), nullptr, nullptr },
        { "audio_device", reinterpret_cast<getter>(MidiSynthesizer_get_AudioDevice), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MidiSynthesizer[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MidiSynthesizer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MidiSynthesizer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MidiSynthesizer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MidiSynthesizer) },
        { },
    };

    static PyType_Spec type_spec_MidiSynthesizer =
    {
        "winrt._winrt_windows_devices_midi.MidiSynthesizer",
        sizeof(py::wrapper::Windows::Devices::Midi::MidiSynthesizer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MidiSynthesizer
    };

    static PyGetSetDef getset_MidiSynthesizer_Static[] = {
        { }
    };

    static PyMethodDef methods_MidiSynthesizer_Static[] = {
        { "create_async", reinterpret_cast<PyCFunction>(MidiSynthesizer_CreateAsync), METH_VARARGS, nullptr },
        { "is_synthesizer", reinterpret_cast<PyCFunction>(MidiSynthesizer_IsSynthesizer), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_MidiSynthesizer_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_MidiSynthesizer_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_MidiSynthesizer_Static) },
        { }
    };

    static PyType_Spec type_spec_MidiSynthesizer_Static =
    {
        "winrt._winrt_windows_devices_midi.MidiSynthesizer_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_MidiSynthesizer_Static
    };

    // ----- MidiSystemExclusiveMessage class --------------------

    static PyObject* _new_MidiSystemExclusiveMessage(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 0);

                winrt::Windows::Devices::Midi::MidiSystemExclusiveMessage instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_MidiSystemExclusiveMessage(py::wrapper::Windows::Devices::Midi::MidiSystemExclusiveMessage* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MidiSystemExclusiveMessage_get_RawData(py::wrapper::Windows::Devices::Midi::MidiSystemExclusiveMessage* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Midi.MidiSystemExclusiveMessage", L"RawData"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.RawData());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MidiSystemExclusiveMessage_get_Timestamp(py::wrapper::Windows::Devices::Midi::MidiSystemExclusiveMessage* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Midi.MidiSystemExclusiveMessage", L"Timestamp"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Timestamp());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MidiSystemExclusiveMessage_get_Type(py::wrapper::Windows::Devices::Midi::MidiSystemExclusiveMessage* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Midi.MidiSystemExclusiveMessage", L"Type"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Type());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MidiSystemExclusiveMessage(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Midi::MidiSystemExclusiveMessage>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MidiSystemExclusiveMessage(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Midi::MidiSystemExclusiveMessage>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MidiSystemExclusiveMessage[] = {
        { "_assign_array_", _assign_array_MidiSystemExclusiveMessage, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MidiSystemExclusiveMessage), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MidiSystemExclusiveMessage[] = {
        { "raw_data", reinterpret_cast<getter>(MidiSystemExclusiveMessage_get_RawData), nullptr, nullptr, nullptr },
        { "timestamp", reinterpret_cast<getter>(MidiSystemExclusiveMessage_get_Timestamp), nullptr, nullptr, nullptr },
        { "type", reinterpret_cast<getter>(MidiSystemExclusiveMessage_get_Type), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MidiSystemExclusiveMessage[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MidiSystemExclusiveMessage) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MidiSystemExclusiveMessage) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MidiSystemExclusiveMessage) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MidiSystemExclusiveMessage) },
        { },
    };

    static PyType_Spec type_spec_MidiSystemExclusiveMessage =
    {
        "winrt._winrt_windows_devices_midi.MidiSystemExclusiveMessage",
        sizeof(py::wrapper::Windows::Devices::Midi::MidiSystemExclusiveMessage),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MidiSystemExclusiveMessage
    };

    // ----- MidiSystemResetMessage class --------------------

    static PyObject* _new_MidiSystemResetMessage(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Devices::Midi::MidiSystemResetMessage instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_MidiSystemResetMessage(py::wrapper::Windows::Devices::Midi::MidiSystemResetMessage* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MidiSystemResetMessage_get_RawData(py::wrapper::Windows::Devices::Midi::MidiSystemResetMessage* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Midi.MidiSystemResetMessage", L"RawData"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.RawData());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MidiSystemResetMessage_get_Timestamp(py::wrapper::Windows::Devices::Midi::MidiSystemResetMessage* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Midi.MidiSystemResetMessage", L"Timestamp"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Timestamp());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MidiSystemResetMessage_get_Type(py::wrapper::Windows::Devices::Midi::MidiSystemResetMessage* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Midi.MidiSystemResetMessage", L"Type"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Type());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MidiSystemResetMessage(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Midi::MidiSystemResetMessage>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MidiSystemResetMessage(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Midi::MidiSystemResetMessage>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MidiSystemResetMessage[] = {
        { "_assign_array_", _assign_array_MidiSystemResetMessage, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MidiSystemResetMessage), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MidiSystemResetMessage[] = {
        { "raw_data", reinterpret_cast<getter>(MidiSystemResetMessage_get_RawData), nullptr, nullptr, nullptr },
        { "timestamp", reinterpret_cast<getter>(MidiSystemResetMessage_get_Timestamp), nullptr, nullptr, nullptr },
        { "type", reinterpret_cast<getter>(MidiSystemResetMessage_get_Type), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MidiSystemResetMessage[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MidiSystemResetMessage) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MidiSystemResetMessage) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MidiSystemResetMessage) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MidiSystemResetMessage) },
        { },
    };

    static PyType_Spec type_spec_MidiSystemResetMessage =
    {
        "winrt._winrt_windows_devices_midi.MidiSystemResetMessage",
        sizeof(py::wrapper::Windows::Devices::Midi::MidiSystemResetMessage),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MidiSystemResetMessage
    };

    // ----- MidiTimeCodeMessage class --------------------

    static PyObject* _new_MidiTimeCodeMessage(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<uint8_t>(args, 0);
                auto param1 = py::convert_to<uint8_t>(args, 1);

                winrt::Windows::Devices::Midi::MidiTimeCodeMessage instance{ param0, param1 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_MidiTimeCodeMessage(py::wrapper::Windows::Devices::Midi::MidiTimeCodeMessage* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MidiTimeCodeMessage_get_RawData(py::wrapper::Windows::Devices::Midi::MidiTimeCodeMessage* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Midi.MidiTimeCodeMessage", L"RawData"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.RawData());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MidiTimeCodeMessage_get_Timestamp(py::wrapper::Windows::Devices::Midi::MidiTimeCodeMessage* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Midi.MidiTimeCodeMessage", L"Timestamp"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Timestamp());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MidiTimeCodeMessage_get_Type(py::wrapper::Windows::Devices::Midi::MidiTimeCodeMessage* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Midi.MidiTimeCodeMessage", L"Type"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Type());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MidiTimeCodeMessage_get_FrameType(py::wrapper::Windows::Devices::Midi::MidiTimeCodeMessage* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Midi.MidiTimeCodeMessage", L"FrameType"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.FrameType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MidiTimeCodeMessage_get_Values(py::wrapper::Windows::Devices::Midi::MidiTimeCodeMessage* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Midi.MidiTimeCodeMessage", L"Values"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Values());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MidiTimeCodeMessage(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Midi::MidiTimeCodeMessage>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MidiTimeCodeMessage(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Midi::MidiTimeCodeMessage>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MidiTimeCodeMessage[] = {
        { "_assign_array_", _assign_array_MidiTimeCodeMessage, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MidiTimeCodeMessage), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MidiTimeCodeMessage[] = {
        { "raw_data", reinterpret_cast<getter>(MidiTimeCodeMessage_get_RawData), nullptr, nullptr, nullptr },
        { "timestamp", reinterpret_cast<getter>(MidiTimeCodeMessage_get_Timestamp), nullptr, nullptr, nullptr },
        { "type", reinterpret_cast<getter>(MidiTimeCodeMessage_get_Type), nullptr, nullptr, nullptr },
        { "frame_type", reinterpret_cast<getter>(MidiTimeCodeMessage_get_FrameType), nullptr, nullptr, nullptr },
        { "values", reinterpret_cast<getter>(MidiTimeCodeMessage_get_Values), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MidiTimeCodeMessage[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MidiTimeCodeMessage) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MidiTimeCodeMessage) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MidiTimeCodeMessage) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MidiTimeCodeMessage) },
        { },
    };

    static PyType_Spec type_spec_MidiTimeCodeMessage =
    {
        "winrt._winrt_windows_devices_midi.MidiTimeCodeMessage",
        sizeof(py::wrapper::Windows::Devices::Midi::MidiTimeCodeMessage),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MidiTimeCodeMessage
    };

    // ----- MidiTimingClockMessage class --------------------

    static PyObject* _new_MidiTimingClockMessage(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Devices::Midi::MidiTimingClockMessage instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_MidiTimingClockMessage(py::wrapper::Windows::Devices::Midi::MidiTimingClockMessage* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MidiTimingClockMessage_get_RawData(py::wrapper::Windows::Devices::Midi::MidiTimingClockMessage* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Midi.MidiTimingClockMessage", L"RawData"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.RawData());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MidiTimingClockMessage_get_Timestamp(py::wrapper::Windows::Devices::Midi::MidiTimingClockMessage* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Midi.MidiTimingClockMessage", L"Timestamp"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Timestamp());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MidiTimingClockMessage_get_Type(py::wrapper::Windows::Devices::Midi::MidiTimingClockMessage* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Midi.MidiTimingClockMessage", L"Type"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Type());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MidiTimingClockMessage(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Midi::MidiTimingClockMessage>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MidiTimingClockMessage(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Midi::MidiTimingClockMessage>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MidiTimingClockMessage[] = {
        { "_assign_array_", _assign_array_MidiTimingClockMessage, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MidiTimingClockMessage), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MidiTimingClockMessage[] = {
        { "raw_data", reinterpret_cast<getter>(MidiTimingClockMessage_get_RawData), nullptr, nullptr, nullptr },
        { "timestamp", reinterpret_cast<getter>(MidiTimingClockMessage_get_Timestamp), nullptr, nullptr, nullptr },
        { "type", reinterpret_cast<getter>(MidiTimingClockMessage_get_Type), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MidiTimingClockMessage[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MidiTimingClockMessage) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MidiTimingClockMessage) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MidiTimingClockMessage) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MidiTimingClockMessage) },
        { },
    };

    static PyType_Spec type_spec_MidiTimingClockMessage =
    {
        "winrt._winrt_windows_devices_midi.MidiTimingClockMessage",
        sizeof(py::wrapper::Windows::Devices::Midi::MidiTimingClockMessage),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MidiTimingClockMessage
    };

    // ----- MidiTuneRequestMessage class --------------------

    static PyObject* _new_MidiTuneRequestMessage(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Devices::Midi::MidiTuneRequestMessage instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_MidiTuneRequestMessage(py::wrapper::Windows::Devices::Midi::MidiTuneRequestMessage* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MidiTuneRequestMessage_get_RawData(py::wrapper::Windows::Devices::Midi::MidiTuneRequestMessage* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Midi.MidiTuneRequestMessage", L"RawData"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.RawData());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MidiTuneRequestMessage_get_Timestamp(py::wrapper::Windows::Devices::Midi::MidiTuneRequestMessage* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Midi.MidiTuneRequestMessage", L"Timestamp"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Timestamp());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MidiTuneRequestMessage_get_Type(py::wrapper::Windows::Devices::Midi::MidiTuneRequestMessage* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Midi.MidiTuneRequestMessage", L"Type"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Type());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MidiTuneRequestMessage(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Midi::MidiTuneRequestMessage>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MidiTuneRequestMessage(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Midi::MidiTuneRequestMessage>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MidiTuneRequestMessage[] = {
        { "_assign_array_", _assign_array_MidiTuneRequestMessage, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MidiTuneRequestMessage), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MidiTuneRequestMessage[] = {
        { "raw_data", reinterpret_cast<getter>(MidiTuneRequestMessage_get_RawData), nullptr, nullptr, nullptr },
        { "timestamp", reinterpret_cast<getter>(MidiTuneRequestMessage_get_Timestamp), nullptr, nullptr, nullptr },
        { "type", reinterpret_cast<getter>(MidiTuneRequestMessage_get_Type), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MidiTuneRequestMessage[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MidiTuneRequestMessage) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MidiTuneRequestMessage) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MidiTuneRequestMessage) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MidiTuneRequestMessage) },
        { },
    };

    static PyType_Spec type_spec_MidiTuneRequestMessage =
    {
        "winrt._winrt_windows_devices_midi.MidiTuneRequestMessage",
        sizeof(py::wrapper::Windows::Devices::Midi::MidiTuneRequestMessage),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MidiTuneRequestMessage
    };

    // ----- IMidiMessage interface --------------------

    static PyObject* _new_IMidiMessage(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Midi::IMidiMessage>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Midi::IMidiMessage>::type_name);
        return nullptr;
    }

    static void _dealloc_IMidiMessage(py::wrapper::Windows::Devices::Midi::IMidiMessage* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IMidiMessage_get_RawData(py::wrapper::Windows::Devices::Midi::IMidiMessage* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Midi.IMidiMessage", L"RawData"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.RawData());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IMidiMessage_get_Timestamp(py::wrapper::Windows::Devices::Midi::IMidiMessage* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Midi.IMidiMessage", L"Timestamp"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Timestamp());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IMidiMessage_get_Type(py::wrapper::Windows::Devices::Midi::IMidiMessage* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Midi.IMidiMessage", L"Type"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Type());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_IMidiMessage(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Midi::IMidiMessage>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IMidiMessage(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Midi::IMidiMessage>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IMidiMessage[] = {
        { "_assign_array_", _assign_array_IMidiMessage, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IMidiMessage), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IMidiMessage[] = {
        { "raw_data", reinterpret_cast<getter>(IMidiMessage_get_RawData), nullptr, nullptr, nullptr },
        { "timestamp", reinterpret_cast<getter>(IMidiMessage_get_Timestamp), nullptr, nullptr, nullptr },
        { "type", reinterpret_cast<getter>(IMidiMessage_get_Type), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IMidiMessage[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_IMidiMessage) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IMidiMessage) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IMidiMessage) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IMidiMessage) },
        { },
    };

    static PyType_Spec type_spec_IMidiMessage =
    {
        "winrt._winrt_windows_devices_midi.IMidiMessage",
        sizeof(py::wrapper::Windows::Devices::Midi::IMidiMessage),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IMidiMessage
    };

    // ----- IMidiOutPort interface --------------------

    static PyObject* _new_IMidiOutPort(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Midi::IMidiOutPort>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Midi::IMidiOutPort>::type_name);
        return nullptr;
    }

    static void _dealloc_IMidiOutPort(py::wrapper::Windows::Devices::Midi::IMidiOutPort* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IMidiOutPort_Close(py::wrapper::Windows::Devices::Midi::IMidiOutPort* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.IClosable", L"Close", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IMidiOutPort_SendBuffer(py::wrapper::Windows::Devices::Midi::IMidiOutPort* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Midi.IMidiOutPort", L"SendBuffer", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 0);

                self->obj.SendBuffer(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IMidiOutPort_SendMessage(py::wrapper::Windows::Devices::Midi::IMidiOutPort* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Midi.IMidiOutPort", L"SendMessage", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Midi::IMidiMessage>(args, 0);

                self->obj.SendMessage(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IMidiOutPort_get_DeviceId(py::wrapper::Windows::Devices::Midi::IMidiOutPort* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Midi.IMidiOutPort", L"DeviceId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DeviceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_IMidiOutPort(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Midi::IMidiOutPort>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IMidiOutPort(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Midi::IMidiOutPort>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_IMidiOutPort(py::wrapper::Windows::Devices::Midi::IMidiOutPort* self, PyObject* /*unused*/) noexcept
    {
        return Py_NewRef(self);
    }

    static PyObject* _exit_IMidiOutPort(py::wrapper::Windows::Devices::Midi::IMidiOutPort* self, PyObject* /*unused*/) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IMidiOutPort[] = {
        { "close", reinterpret_cast<PyCFunction>(IMidiOutPort_Close), METH_VARARGS, nullptr },
        { "send_buffer", reinterpret_cast<PyCFunction>(IMidiOutPort_SendBuffer), METH_VARARGS, nullptr },
        { "send_message", reinterpret_cast<PyCFunction>(IMidiOutPort_SendMessage), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_IMidiOutPort, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IMidiOutPort), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_IMidiOutPort), METH_NOARGS, nullptr },
        { "__exit__",  reinterpret_cast<PyCFunction>(_exit_IMidiOutPort), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_IMidiOutPort[] = {
        { "device_id", reinterpret_cast<getter>(IMidiOutPort_get_DeviceId), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IMidiOutPort[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_IMidiOutPort) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IMidiOutPort) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IMidiOutPort) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IMidiOutPort) },
        { },
    };

    static PyType_Spec type_spec_IMidiOutPort =
    {
        "winrt._winrt_windows_devices_midi.IMidiOutPort",
        sizeof(py::wrapper::Windows::Devices::Midi::IMidiOutPort),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IMidiOutPort
    };

    // ----- Windows.Devices.Midi Initialization --------------------
    PyDoc_STRVAR(module_doc, "Windows::Devices::Midi");


    static PyModuleDef module_def
        = {PyModuleDef_HEAD_INIT,
           "_winrt_windows_devices_midi",
           module_doc,
           0,
           nullptr,
           nullptr,
           nullptr,
           nullptr,
           nullptr};

} // py::cpp::Windows::Devices::Midi

PyMODINIT_FUNC PyInit__winrt_windows_devices_midi(void) noexcept
{
    using namespace py::cpp::Windows::Devices::Midi;

    if (py::import_winrt_runtime() == -1)
    {
        return nullptr;
    }

    py::pyobj_handle module{PyModule_Create(&module_def)};

    if (!module)
    {
        return nullptr;
    }

    auto object_type = py::get_object_type();
    if (!object_type)
    {
        return nullptr;
    }

    py::pyobj_handle object_bases{PyTuple_Pack(1, object_type)};

    if (!object_bases)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_MidiActiveSensingMessage, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_MidiChannelPressureMessage, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_MidiContinueMessage, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_MidiControlChangeMessage, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_MidiInPort_Static{PyType_FromSpec(&type_spec_MidiInPort_Static)};
    if (!type_MidiInPort_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_MidiInPort, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_MidiInPort_Static.get())) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_MidiMessageReceivedEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_MidiNoteOffMessage, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_MidiNoteOnMessage, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_MidiOutPort_Static{PyType_FromSpec(&type_spec_MidiOutPort_Static)};
    if (!type_MidiOutPort_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_MidiOutPort, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_MidiOutPort_Static.get())) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_MidiPitchBendChangeMessage, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_MidiPolyphonicKeyPressureMessage, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_MidiProgramChangeMessage, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_MidiSongPositionPointerMessage, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_MidiSongSelectMessage, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_MidiStartMessage, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_MidiStopMessage, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_MidiSynthesizer_Static{PyType_FromSpec(&type_spec_MidiSynthesizer_Static)};
    if (!type_MidiSynthesizer_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_MidiSynthesizer, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_MidiSynthesizer_Static.get())) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_MidiSystemExclusiveMessage, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_MidiSystemResetMessage, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_MidiTimeCodeMessage, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_MidiTimingClockMessage, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_MidiTuneRequestMessage, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_IMidiMessage, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_IMidiOutPort, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }


    return module.detach();
}
