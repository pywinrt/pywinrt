# WARNING: Please don't edit this file. It was generated by Python/WinRT v2.0.0-beta.2

import datetime
import sys
import types
import typing
import uuid as _uuid
from builtins import property as _property

import winrt._winrt
import winrt.system
import winrt.windows.applicationmodel
import winrt.windows.data.xml.dom
import winrt.windows.foundation
import winrt.windows.foundation.collections
import winrt.windows.system

from winrt.windows.ui.notifications import AdaptiveNotificationContentKind, BadgeTemplateType, NotificationKinds, NotificationMirroring, NotificationSetting, NotificationUpdateResult, PeriodicUpdateRecurrence, TileFlyoutTemplateType, TileTemplateType, ToastDismissalReason, ToastHistoryChangedType, ToastNotificationMode, ToastNotificationPriority, ToastTemplateType, UserNotificationChangedKind

Self = typing.TypeVar('Self')

@typing.final
class AdaptiveNotificationText(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> AdaptiveNotificationText: ...
    def __new__(cls: typing.Type[AdaptiveNotificationText]) -> AdaptiveNotificationText:...
    @_property
    def hints(self) -> typing.Optional[winrt.windows.foundation.collections.IMap[str, str]]: ...
    @_property
    def kind(self) -> AdaptiveNotificationContentKind: ...
    @_property
    def text(self) -> str: ...
    @text.setter
    def text(self, value: str) -> None: ...
    @_property
    def language(self) -> str: ...
    @language.setter
    def language(self, value: str) -> None: ...

@typing.final
class BadgeNotification(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> BadgeNotification: ...
    def __new__(cls: typing.Type[BadgeNotification], content: typing.Optional[winrt.windows.data.xml.dom.XmlDocument]) -> BadgeNotification:...
    @_property
    def expiration_time(self) -> typing.Optional[typing.Optional[datetime.datetime]]: ...
    @expiration_time.setter
    def expiration_time(self, value: typing.Optional[typing.Optional[datetime.datetime]]) -> None: ...
    @_property
    def content(self) -> typing.Optional[winrt.windows.data.xml.dom.XmlDocument]: ...

@typing.final
class BadgeUpdateManager_Static(type):
    @typing.overload
    def create_badge_updater_for_application(cls) -> typing.Optional[BadgeUpdater]: ...
    @typing.overload
    def create_badge_updater_for_application(cls, application_id: str, /) -> typing.Optional[BadgeUpdater]: ...
    def create_badge_updater_for_secondary_tile(cls, tile_id: str, /) -> typing.Optional[BadgeUpdater]: ...
    def get_for_user(cls, user: typing.Optional[winrt.windows.system.User], /) -> typing.Optional[BadgeUpdateManagerForUser]: ...
    def get_template_content(cls, type: BadgeTemplateType, /) -> typing.Optional[winrt.windows.data.xml.dom.XmlDocument]: ...

@typing.final
class BadgeUpdateManager(winrt.system.Object, metaclass=BadgeUpdateManager_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> BadgeUpdateManager: ...

@typing.final
class BadgeUpdateManagerForUser(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> BadgeUpdateManagerForUser: ...
    @typing.overload
    def create_badge_updater_for_application(self) -> typing.Optional[BadgeUpdater]: ...
    @typing.overload
    def create_badge_updater_for_application(self, application_id: str, /) -> typing.Optional[BadgeUpdater]: ...
    def create_badge_updater_for_secondary_tile(self, tile_id: str, /) -> typing.Optional[BadgeUpdater]: ...
    @_property
    def user(self) -> typing.Optional[winrt.windows.system.User]: ...

@typing.final
class BadgeUpdater(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> BadgeUpdater: ...
    def clear(self) -> None: ...
    @typing.overload
    def start_periodic_update(self, badge_content: typing.Optional[winrt.windows.foundation.Uri], requested_interval: PeriodicUpdateRecurrence, /) -> None: ...
    @typing.overload
    def start_periodic_update(self, badge_content: typing.Optional[winrt.windows.foundation.Uri], start_time: datetime.datetime, requested_interval: PeriodicUpdateRecurrence, /) -> None: ...
    def stop_periodic_update(self) -> None: ...
    def update(self, notification: typing.Optional[BadgeNotification], /) -> None: ...

@typing.final
class KnownAdaptiveNotificationHints_Static(type):
    @_property
    def align(cls) -> str: ...
    @_property
    def max_lines(cls) -> str: ...
    @_property
    def min_lines(cls) -> str: ...
    @_property
    def style(cls) -> str: ...
    @_property
    def text_stacking(cls) -> str: ...
    @_property
    def wrap(cls) -> str: ...

@typing.final
class KnownAdaptiveNotificationHints(winrt.system.Object, metaclass=KnownAdaptiveNotificationHints_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> KnownAdaptiveNotificationHints: ...

@typing.final
class KnownAdaptiveNotificationTextStyles_Static(type):
    @_property
    def base(cls) -> str: ...
    @_property
    def base_subtle(cls) -> str: ...
    @_property
    def body(cls) -> str: ...
    @_property
    def body_subtle(cls) -> str: ...
    @_property
    def caption(cls) -> str: ...
    @_property
    def caption_subtle(cls) -> str: ...
    @_property
    def header(cls) -> str: ...
    @_property
    def header_numeral(cls) -> str: ...
    @_property
    def header_numeral_subtle(cls) -> str: ...
    @_property
    def header_subtle(cls) -> str: ...
    @_property
    def subheader(cls) -> str: ...
    @_property
    def subheader_numeral(cls) -> str: ...
    @_property
    def subheader_numeral_subtle(cls) -> str: ...
    @_property
    def subheader_subtle(cls) -> str: ...
    @_property
    def subtitle(cls) -> str: ...
    @_property
    def subtitle_subtle(cls) -> str: ...
    @_property
    def title(cls) -> str: ...
    @_property
    def title_numeral(cls) -> str: ...
    @_property
    def title_subtle(cls) -> str: ...

@typing.final
class KnownAdaptiveNotificationTextStyles(winrt.system.Object, metaclass=KnownAdaptiveNotificationTextStyles_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> KnownAdaptiveNotificationTextStyles: ...

@typing.final
class KnownNotificationBindings_Static(type):
    @_property
    def toast_generic(cls) -> str: ...

@typing.final
class KnownNotificationBindings(winrt.system.Object, metaclass=KnownNotificationBindings_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> KnownNotificationBindings: ...

@typing.final
class Notification(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> Notification: ...
    def __new__(cls: typing.Type[Notification]) -> Notification:...
    @_property
    def visual(self) -> typing.Optional[NotificationVisual]: ...
    @visual.setter
    def visual(self, value: typing.Optional[NotificationVisual]) -> None: ...
    @_property
    def expiration_time(self) -> typing.Optional[typing.Optional[datetime.datetime]]: ...
    @expiration_time.setter
    def expiration_time(self, value: typing.Optional[typing.Optional[datetime.datetime]]) -> None: ...

@typing.final
class NotificationBinding(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> NotificationBinding: ...
    def get_text_elements(self) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[AdaptiveNotificationText]]: ...
    @_property
    def template(self) -> str: ...
    @template.setter
    def template(self, value: str) -> None: ...
    @_property
    def language(self) -> str: ...
    @language.setter
    def language(self, value: str) -> None: ...
    @_property
    def hints(self) -> typing.Optional[winrt.windows.foundation.collections.IMap[str, str]]: ...

@typing.final
class NotificationData(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> NotificationData: ...
    @typing.overload
    def __new__(cls: typing.Type[NotificationData], initial_values: typing.Iterable[winrt.windows.foundation.collections.IKeyValuePair[str, str]], sequence_number: winrt.system.UInt32) -> NotificationData:...
    @typing.overload
    def __new__(cls: typing.Type[NotificationData], initial_values: typing.Iterable[winrt.windows.foundation.collections.IKeyValuePair[str, str]]) -> NotificationData:...
    @typing.overload
    def __new__(cls: typing.Type[NotificationData]) -> NotificationData:...
    @_property
    def sequence_number(self) -> winrt.system.UInt32: ...
    @sequence_number.setter
    def sequence_number(self, value: winrt.system.UInt32) -> None: ...
    @_property
    def values(self) -> typing.Optional[winrt.windows.foundation.collections.IMap[str, str]]: ...

@typing.final
class NotificationVisual(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> NotificationVisual: ...
    def get_binding(self, template_name: str, /) -> typing.Optional[NotificationBinding]: ...
    @_property
    def language(self) -> str: ...
    @language.setter
    def language(self, value: str) -> None: ...
    @_property
    def bindings(self) -> typing.Optional[winrt.windows.foundation.collections.IVector[NotificationBinding]]: ...

@typing.final
class ScheduledTileNotification(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ScheduledTileNotification: ...
    def __new__(cls: typing.Type[ScheduledTileNotification], content: typing.Optional[winrt.windows.data.xml.dom.XmlDocument], delivery_time: datetime.datetime) -> ScheduledTileNotification:...
    @_property
    def tag(self) -> str: ...
    @tag.setter
    def tag(self, value: str) -> None: ...
    @_property
    def id(self) -> str: ...
    @id.setter
    def id(self, value: str) -> None: ...
    @_property
    def expiration_time(self) -> typing.Optional[typing.Optional[datetime.datetime]]: ...
    @expiration_time.setter
    def expiration_time(self, value: typing.Optional[typing.Optional[datetime.datetime]]) -> None: ...
    @_property
    def content(self) -> typing.Optional[winrt.windows.data.xml.dom.XmlDocument]: ...
    @_property
    def delivery_time(self) -> datetime.datetime: ...

@typing.final
class ScheduledToastNotification(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ScheduledToastNotification: ...
    @typing.overload
    def __new__(cls: typing.Type[ScheduledToastNotification], content: typing.Optional[winrt.windows.data.xml.dom.XmlDocument], delivery_time: datetime.datetime) -> ScheduledToastNotification:...
    @typing.overload
    def __new__(cls: typing.Type[ScheduledToastNotification], content: typing.Optional[winrt.windows.data.xml.dom.XmlDocument], delivery_time: datetime.datetime, snooze_interval: datetime.timedelta, maximum_snooze_count: winrt.system.UInt32) -> ScheduledToastNotification:...
    @_property
    def id(self) -> str: ...
    @id.setter
    def id(self, value: str) -> None: ...
    @_property
    def content(self) -> typing.Optional[winrt.windows.data.xml.dom.XmlDocument]: ...
    @_property
    def delivery_time(self) -> datetime.datetime: ...
    @_property
    def maximum_snooze_count(self) -> winrt.system.UInt32: ...
    @_property
    def snooze_interval(self) -> typing.Optional[typing.Optional[datetime.timedelta]]: ...
    @_property
    def tag(self) -> str: ...
    @tag.setter
    def tag(self, value: str) -> None: ...
    @_property
    def suppress_popup(self) -> bool: ...
    @suppress_popup.setter
    def suppress_popup(self, value: bool) -> None: ...
    @_property
    def group(self) -> str: ...
    @group.setter
    def group(self, value: str) -> None: ...
    @_property
    def remote_id(self) -> str: ...
    @remote_id.setter
    def remote_id(self, value: str) -> None: ...
    @_property
    def notification_mirroring(self) -> NotificationMirroring: ...
    @notification_mirroring.setter
    def notification_mirroring(self, value: NotificationMirroring) -> None: ...
    @_property
    def expiration_time(self) -> typing.Optional[typing.Optional[datetime.datetime]]: ...
    @expiration_time.setter
    def expiration_time(self, value: typing.Optional[typing.Optional[datetime.datetime]]) -> None: ...

@typing.final
class ScheduledToastNotificationShowingEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ScheduledToastNotificationShowingEventArgs: ...
    def get_deferral(self) -> typing.Optional[winrt.windows.foundation.Deferral]: ...
    @_property
    def cancel(self) -> bool: ...
    @cancel.setter
    def cancel(self, value: bool) -> None: ...
    @_property
    def scheduled_toast_notification(self) -> typing.Optional[ScheduledToastNotification]: ...

@typing.final
class ShownTileNotification(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ShownTileNotification: ...
    @_property
    def arguments(self) -> str: ...

@typing.final
class TileFlyoutNotification(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> TileFlyoutNotification: ...
    def __new__(cls: typing.Type[TileFlyoutNotification], content: typing.Optional[winrt.windows.data.xml.dom.XmlDocument]) -> TileFlyoutNotification:...
    @_property
    def expiration_time(self) -> typing.Optional[typing.Optional[datetime.datetime]]: ...
    @expiration_time.setter
    def expiration_time(self, value: typing.Optional[typing.Optional[datetime.datetime]]) -> None: ...
    @_property
    def content(self) -> typing.Optional[winrt.windows.data.xml.dom.XmlDocument]: ...

@typing.final
class TileFlyoutUpdateManager_Static(type):
    @typing.overload
    def create_tile_flyout_updater_for_application(cls) -> typing.Optional[TileFlyoutUpdater]: ...
    @typing.overload
    def create_tile_flyout_updater_for_application(cls, application_id: str, /) -> typing.Optional[TileFlyoutUpdater]: ...
    def create_tile_flyout_updater_for_secondary_tile(cls, tile_id: str, /) -> typing.Optional[TileFlyoutUpdater]: ...
    def get_template_content(cls, type: TileFlyoutTemplateType, /) -> typing.Optional[winrt.windows.data.xml.dom.XmlDocument]: ...

@typing.final
class TileFlyoutUpdateManager(winrt.system.Object, metaclass=TileFlyoutUpdateManager_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> TileFlyoutUpdateManager: ...

@typing.final
class TileFlyoutUpdater(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> TileFlyoutUpdater: ...
    def clear(self) -> None: ...
    @typing.overload
    def start_periodic_update(self, tile_flyout_content: typing.Optional[winrt.windows.foundation.Uri], requested_interval: PeriodicUpdateRecurrence, /) -> None: ...
    @typing.overload
    def start_periodic_update(self, tile_flyout_content: typing.Optional[winrt.windows.foundation.Uri], start_time: datetime.datetime, requested_interval: PeriodicUpdateRecurrence, /) -> None: ...
    def stop_periodic_update(self) -> None: ...
    def update(self, notification: typing.Optional[TileFlyoutNotification], /) -> None: ...
    @_property
    def setting(self) -> NotificationSetting: ...

@typing.final
class TileNotification(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> TileNotification: ...
    def __new__(cls: typing.Type[TileNotification], content: typing.Optional[winrt.windows.data.xml.dom.XmlDocument]) -> TileNotification:...
    @_property
    def tag(self) -> str: ...
    @tag.setter
    def tag(self, value: str) -> None: ...
    @_property
    def expiration_time(self) -> typing.Optional[typing.Optional[datetime.datetime]]: ...
    @expiration_time.setter
    def expiration_time(self, value: typing.Optional[typing.Optional[datetime.datetime]]) -> None: ...
    @_property
    def content(self) -> typing.Optional[winrt.windows.data.xml.dom.XmlDocument]: ...

@typing.final
class TileUpdateManager_Static(type):
    @typing.overload
    def create_tile_updater_for_application(cls) -> typing.Optional[TileUpdater]: ...
    @typing.overload
    def create_tile_updater_for_application(cls, application_id: str, /) -> typing.Optional[TileUpdater]: ...
    def create_tile_updater_for_secondary_tile(cls, tile_id: str, /) -> typing.Optional[TileUpdater]: ...
    def get_for_user(cls, user: typing.Optional[winrt.windows.system.User], /) -> typing.Optional[TileUpdateManagerForUser]: ...
    def get_template_content(cls, type: TileTemplateType, /) -> typing.Optional[winrt.windows.data.xml.dom.XmlDocument]: ...

@typing.final
class TileUpdateManager(winrt.system.Object, metaclass=TileUpdateManager_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> TileUpdateManager: ...

@typing.final
class TileUpdateManagerForUser(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> TileUpdateManagerForUser: ...
    def create_tile_updater_for_application(self, application_id: str, /) -> typing.Optional[TileUpdater]: ...
    def create_tile_updater_for_application_for_user(self) -> typing.Optional[TileUpdater]: ...
    def create_tile_updater_for_secondary_tile(self, tile_id: str, /) -> typing.Optional[TileUpdater]: ...
    @_property
    def user(self) -> typing.Optional[winrt.windows.system.User]: ...

@typing.final
class TileUpdater(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> TileUpdater: ...
    def add_to_schedule(self, scheduled_tile: typing.Optional[ScheduledTileNotification], /) -> None: ...
    def clear(self) -> None: ...
    def enable_notification_queue(self, enable: bool, /) -> None: ...
    def enable_notification_queue_for_square150x150(self, enable: bool, /) -> None: ...
    def enable_notification_queue_for_square310x310(self, enable: bool, /) -> None: ...
    def enable_notification_queue_for_wide310x150(self, enable: bool, /) -> None: ...
    def get_scheduled_tile_notifications(self) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[ScheduledTileNotification]]: ...
    def remove_from_schedule(self, scheduled_tile: typing.Optional[ScheduledTileNotification], /) -> None: ...
    @typing.overload
    def start_periodic_update(self, tile_content: typing.Optional[winrt.windows.foundation.Uri], requested_interval: PeriodicUpdateRecurrence, /) -> None: ...
    @typing.overload
    def start_periodic_update(self, tile_content: typing.Optional[winrt.windows.foundation.Uri], start_time: datetime.datetime, requested_interval: PeriodicUpdateRecurrence, /) -> None: ...
    @typing.overload
    def start_periodic_update_batch(self, tile_contents: typing.Iterable[winrt.windows.foundation.Uri], requested_interval: PeriodicUpdateRecurrence, /) -> None: ...
    @typing.overload
    def start_periodic_update_batch(self, tile_contents: typing.Iterable[winrt.windows.foundation.Uri], start_time: datetime.datetime, requested_interval: PeriodicUpdateRecurrence, /) -> None: ...
    def stop_periodic_update(self) -> None: ...
    def update(self, notification: typing.Optional[TileNotification], /) -> None: ...
    @_property
    def setting(self) -> NotificationSetting: ...

@typing.final
class ToastActivatedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ToastActivatedEventArgs: ...
    @_property
    def arguments(self) -> str: ...
    @_property
    def user_input(self) -> typing.Optional[winrt.windows.foundation.collections.ValueSet]: ...

@typing.final
class ToastCollection(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ToastCollection: ...
    def __new__(cls: typing.Type[ToastCollection], collection_id: str, display_name: str, launch_args: str, icon_uri: typing.Optional[winrt.windows.foundation.Uri]) -> ToastCollection:...
    @_property
    def launch_args(self) -> str: ...
    @launch_args.setter
    def launch_args(self, value: str) -> None: ...
    @_property
    def icon(self) -> typing.Optional[winrt.windows.foundation.Uri]: ...
    @icon.setter
    def icon(self, value: typing.Optional[winrt.windows.foundation.Uri]) -> None: ...
    @_property
    def display_name(self) -> str: ...
    @display_name.setter
    def display_name(self, value: str) -> None: ...
    @_property
    def id(self) -> str: ...

@typing.final
class ToastCollectionManager(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ToastCollectionManager: ...
    def find_all_toast_collections_async(self) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.foundation.collections.IVectorView[ToastCollection]]: ...
    def get_toast_collection_async(self, collection_id: str, /) -> winrt.windows.foundation.IAsyncOperation[ToastCollection]: ...
    def remove_all_toast_collections_async(self) -> winrt.windows.foundation.IAsyncAction: ...
    def remove_toast_collection_async(self, collection_id: str, /) -> winrt.windows.foundation.IAsyncAction: ...
    def save_toast_collection_async(self, collection: typing.Optional[ToastCollection], /) -> winrt.windows.foundation.IAsyncAction: ...
    @_property
    def app_id(self) -> str: ...
    @_property
    def user(self) -> typing.Optional[winrt.windows.system.User]: ...

@typing.final
class ToastDismissedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ToastDismissedEventArgs: ...
    @_property
    def reason(self) -> ToastDismissalReason: ...

@typing.final
class ToastFailedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ToastFailedEventArgs: ...
    @_property
    def error_code(self) -> winrt.windows.foundation.HResult: ...

@typing.final
class ToastNotification(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ToastNotification: ...
    def __new__(cls: typing.Type[ToastNotification], content: typing.Optional[winrt.windows.data.xml.dom.XmlDocument]) -> ToastNotification:...
    def add_activated(self, handler: winrt.windows.foundation.TypedEventHandler[ToastNotification, winrt.system.Object], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_activated(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_dismissed(self, handler: winrt.windows.foundation.TypedEventHandler[ToastNotification, ToastDismissedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_dismissed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_failed(self, handler: winrt.windows.foundation.TypedEventHandler[ToastNotification, ToastFailedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_failed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    @_property
    def expiration_time(self) -> typing.Optional[typing.Optional[datetime.datetime]]: ...
    @expiration_time.setter
    def expiration_time(self, value: typing.Optional[typing.Optional[datetime.datetime]]) -> None: ...
    @_property
    def content(self) -> typing.Optional[winrt.windows.data.xml.dom.XmlDocument]: ...
    @_property
    def tag(self) -> str: ...
    @tag.setter
    def tag(self, value: str) -> None: ...
    @_property
    def suppress_popup(self) -> bool: ...
    @suppress_popup.setter
    def suppress_popup(self, value: bool) -> None: ...
    @_property
    def group(self) -> str: ...
    @group.setter
    def group(self, value: str) -> None: ...
    @_property
    def remote_id(self) -> str: ...
    @remote_id.setter
    def remote_id(self, value: str) -> None: ...
    @_property
    def notification_mirroring(self) -> NotificationMirroring: ...
    @notification_mirroring.setter
    def notification_mirroring(self, value: NotificationMirroring) -> None: ...
    @_property
    def priority(self) -> ToastNotificationPriority: ...
    @priority.setter
    def priority(self, value: ToastNotificationPriority) -> None: ...
    @_property
    def data(self) -> typing.Optional[NotificationData]: ...
    @data.setter
    def data(self, value: typing.Optional[NotificationData]) -> None: ...
    @_property
    def expires_on_reboot(self) -> bool: ...
    @expires_on_reboot.setter
    def expires_on_reboot(self, value: bool) -> None: ...

@typing.final
class ToastNotificationActionTriggerDetail(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ToastNotificationActionTriggerDetail: ...
    @_property
    def argument(self) -> str: ...
    @_property
    def user_input(self) -> typing.Optional[winrt.windows.foundation.collections.ValueSet]: ...

@typing.final
class ToastNotificationHistory(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ToastNotificationHistory: ...
    @typing.overload
    def clear(self) -> None: ...
    @typing.overload
    def clear(self, application_id: str, /) -> None: ...
    @typing.overload
    def get_history(self) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[ToastNotification]]: ...
    @typing.overload
    def get_history(self, application_id: str, /) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[ToastNotification]]: ...
    @typing.overload
    def remove(self, tag: str, /) -> None: ...
    @typing.overload
    def remove(self, tag: str, group: str, /) -> None: ...
    @typing.overload
    def remove(self, tag: str, group: str, application_id: str, /) -> None: ...
    @typing.overload
    def remove_group(self, group: str, /) -> None: ...
    @typing.overload
    def remove_group(self, group: str, application_id: str, /) -> None: ...

@typing.final
class ToastNotificationHistoryChangedTriggerDetail(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ToastNotificationHistoryChangedTriggerDetail: ...
    @_property
    def change_type(self) -> ToastHistoryChangedType: ...
    @_property
    def collection_id(self) -> str: ...

@typing.final
class ToastNotificationManager_Static(type):
    def configure_notification_mirroring(cls, value: NotificationMirroring, /) -> None: ...
    @typing.overload
    def create_toast_notifier(cls) -> typing.Optional[ToastNotifier]: ...
    @typing.overload
    def create_toast_notifier(cls, application_id: str, /) -> typing.Optional[ToastNotifier]: ...
    def get_default(cls) -> typing.Optional[ToastNotificationManagerForUser]: ...
    def get_for_user(cls, user: typing.Optional[winrt.windows.system.User], /) -> typing.Optional[ToastNotificationManagerForUser]: ...
    def get_template_content(cls, type: ToastTemplateType, /) -> typing.Optional[winrt.windows.data.xml.dom.XmlDocument]: ...
    @_property
    def history(cls) -> typing.Optional[ToastNotificationHistory]: ...

@typing.final
class ToastNotificationManager(winrt.system.Object, metaclass=ToastNotificationManager_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ToastNotificationManager: ...

@typing.final
class ToastNotificationManagerForUser(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ToastNotificationManagerForUser: ...
    @typing.overload
    def create_toast_notifier(self) -> typing.Optional[ToastNotifier]: ...
    @typing.overload
    def create_toast_notifier(self, application_id: str, /) -> typing.Optional[ToastNotifier]: ...
    def get_history_for_toast_collection_id_async(self, collection_id: str, /) -> winrt.windows.foundation.IAsyncOperation[ToastNotificationHistory]: ...
    @typing.overload
    def get_toast_collection_manager(self) -> typing.Optional[ToastCollectionManager]: ...
    @typing.overload
    def get_toast_collection_manager(self, app_id: str, /) -> typing.Optional[ToastCollectionManager]: ...
    def get_toast_notifier_for_toast_collection_id_async(self, collection_id: str, /) -> winrt.windows.foundation.IAsyncOperation[ToastNotifier]: ...
    def add_notification_mode_changed(self, handler: winrt.windows.foundation.TypedEventHandler[ToastNotificationManagerForUser, winrt.system.Object], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_notification_mode_changed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    @_property
    def history(self) -> typing.Optional[ToastNotificationHistory]: ...
    @_property
    def user(self) -> typing.Optional[winrt.windows.system.User]: ...
    @_property
    def notification_mode(self) -> ToastNotificationMode: ...

@typing.final
class ToastNotifier(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ToastNotifier: ...
    def add_to_schedule(self, scheduled_toast: typing.Optional[ScheduledToastNotification], /) -> None: ...
    def get_scheduled_toast_notifications(self) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[ScheduledToastNotification]]: ...
    def hide(self, notification: typing.Optional[ToastNotification], /) -> None: ...
    def remove_from_schedule(self, scheduled_toast: typing.Optional[ScheduledToastNotification], /) -> None: ...
    def show(self, notification: typing.Optional[ToastNotification], /) -> None: ...
    @typing.overload
    def update(self, data: typing.Optional[NotificationData], tag: str, /) -> NotificationUpdateResult: ...
    @typing.overload
    def update(self, data: typing.Optional[NotificationData], tag: str, group: str, /) -> NotificationUpdateResult: ...
    def add_scheduled_toast_notification_showing(self, handler: winrt.windows.foundation.TypedEventHandler[ToastNotifier, ScheduledToastNotificationShowingEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_scheduled_toast_notification_showing(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    @_property
    def setting(self) -> NotificationSetting: ...

@typing.final
class UserNotification(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> UserNotification: ...
    @_property
    def app_info(self) -> typing.Optional[winrt.windows.applicationmodel.AppInfo]: ...
    @_property
    def creation_time(self) -> datetime.datetime: ...
    @_property
    def id(self) -> winrt.system.UInt32: ...
    @_property
    def notification(self) -> typing.Optional[Notification]: ...

@typing.final
class UserNotificationChangedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> UserNotificationChangedEventArgs: ...
    @_property
    def change_kind(self) -> UserNotificationChangedKind: ...
    @_property
    def user_notification_id(self) -> winrt.system.UInt32: ...

@typing.final
class IAdaptiveNotificationContent(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> IAdaptiveNotificationContent: ...
    @_property
    def hints(self) -> typing.Optional[winrt.windows.foundation.collections.IMap[str, str]]: ...
    @_property
    def kind(self) -> AdaptiveNotificationContentKind: ...

